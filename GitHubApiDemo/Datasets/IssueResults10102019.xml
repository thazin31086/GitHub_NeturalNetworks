<Issues>
  <Issue>
    <IssueID>27060</IssueID>
    <RepoID>1</RepoID>
    <Title>Assert in SemanticModel on typing invalid collection initializer</Title>
    <Description>Typed in this invalid code (cursor expression shows where my cursor was, had just typed the 2):
```C#
using System.Collections.Generic;

interface I : IEnumerable&lt;int&gt;
{
    void Add(int i);
}

class C
{
    void M()
    {
        I i = new I() { 1, 2[||]}
    }
}
```
Got this stack trace:
```
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 584	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 329	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 1729	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2141	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 60	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node) Line 1815	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node) Line 457	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, out Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode bindableNode, out Microsoft.CodeAnalysis.CSharp.BoundNode lowestBoundNode, out Microsoft.CodeAnalysis.CSharp.BoundNode highestBoundNode, out Microsoft.CodeAnalysis.CSharp.BoundNode boundParent) Line 1200	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 1090	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 310	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken) Line 864	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 4555	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 4628	C#
 	Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 322	C#
 	Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 60	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext context) Line 45	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan state, Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider provider, Microsoft.CodeAnalysis.Extensions.IExtensionManager extensionManager, System.Threading.CancellationToken cancellationToken) Line 142	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.HasRefactoringsAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan state, System.Threading.CancellationToken cancellationToken) Line 80	C#
```</Description>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>31/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38226</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler computes incorrect common type for switch expression with null arm</Title>
    <Description>See https://github.com/dotnet/roslyn/issues/37950

The following method does not compile, but it should.  A switch expression should only be considered to have a natural type when all switch arm expressions can be converted to the computed common type.

``` c#
class Program
{
    public static void Main() { }

    public static bool? GetBool(string name)
    {
        return name switch
        {
            "a" =&gt; true,
            "b" =&gt; false,
            _ =&gt; null, // error CS0037: Cannot convert null to 'bool' because it is a non-nullable value type
        };
    }
}
```
</Description>
    <CreatedDate>22/08/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36443</IssueID>
    <RepoID>1</RepoID>
    <Title>Compound Assignment when ref temps are required crashes the compiler</Title>
    <Description>```C#
using System;
using System.Threading.Tasks;
struct S
{
    int? i;

    static async Task Main()
    {    

        S s = default;
        Console.WriteLine(s.i += await GetInt());
    }

    static Task&lt;int?&gt; GetInt() =&gt; Task.FromResult((int?)1);
}
```
This code crashes the compiler with the following stack:
&lt;details&gt;

```
Message: 
    System.InvalidOperationException : Unexpected value 'Local' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
    
  Stack Trace: 
    at ThrowingTraceListener.Fail(String message, String detailMessage) in ThrowingTraceListener.cs line: 24
    at TraceListener.Fail(String message)
    at TraceInternal.Fail(String message)
    at Debug.Assert(Boolean condition, String message)
    at ExceptionUtilities.UnexpectedValue(Object o) in ExceptionUtilities.cs line: 18
    at MethodToStateMachineRewriter.HoistExpression(BoundExpression expr, AwaitExpressionSyntax awaitSyntaxOpt, Int32 syntaxOffset, RefKind refKind, ArrayBuilder`1 sideEffects, ArrayBuilder`1 hoistedFields, Boolean&amp; needsSacrificialEvaluation) in MethodToStateMachineRewriter.cs line: 606
    at MethodToStateMachineRewriter.HoistExpression(BoundExpression expr, AwaitExpressionSyntax awaitSyntaxOpt, Int32 syntaxOffset, RefKind refKind, ArrayBuilder`1 sideEffects, ArrayBuilder`1 hoistedFields, Boolean&amp; needsSacrificialEvaluation) in MethodToStateMachineRewriter.cs line: 549
    at MethodToStateMachineRewriter.HoistRefInitialization(SynthesizedLocal local, BoundAssignmentOperator node) in MethodToStateMachineRewriter.cs line: 484
    at MethodToStateMachineRewriter.VisitAssignmentOperator(BoundAssignmentOperator node) in MethodToStateMachineRewriter.cs line: 779
    at BoundAssignmentOperator.Accept(BoundTreeVisitor visitor) in BoundNodes.xml.Generated.cs line: 1507
    at BoundTreeVisitor.Visit(BoundNode node) in BoundTreeVisitors.cs line: 145
    at BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) in BoundTreeRewriter.cs line: 97
    at BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node) in BoundTreeVisitors.cs line: 223
    at BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node) in BoundTreeVisitors.cs line: 204
    at BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in BoundTreeRewriter.cs line: 84
    at MethodToStateMachineRewriter.Visit(BoundNode node) in MethodToStateMachineRewriter.cs line: 658
    at AsyncMethodToStateMachineRewriter.VisitExpressionStatement(BoundExpressionStatement node) in AsyncMethodToStateMachineRewriter.cs line: 272
    at BoundExpressionStatement.Accept(BoundTreeVisitor visitor) in BoundNodes.xml.Generated.cs line: 3023
    at BoundTreeVisitor.Visit(BoundNode node) in BoundTreeVisitors.cs line: 145
    at BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in BoundTreeRewriter.cs line: 87
    at MethodToStateMachineRewriter.Visit(BoundNode node) in MethodToStateMachineRewriter.cs line: 658
    at BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in BoundTreeRewriter.cs line: 37
    at BoundTreeRewriter.VisitList[T](ImmutableArray`1 list) in BoundTreeRewriter.cs line: 26
    at MethodToClassRewriter.VisitBlock(BoundBlock node) in MethodToClassRewriter.cs line: 139
    at MethodToStateMachineRewriter.&lt;&gt;n__0(BoundBlock node)
    at &lt;&gt;c__DisplayClass42_0.&lt;VisitBlock&gt;b__0() in MethodToStateMachineRewriter.cs line: 665
    at MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in MethodToStateMachineRewriter.cs line: 301
    at MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in MethodToStateMachineRewriter.cs line: 665
    at BoundBlock.Accept(BoundTreeVisitor visitor) in BoundNodes.xml.Generated.cs line: 2673
    at BoundTreeVisitor.Visit(BoundNode node) in BoundTreeVisitors.cs line: 145
    at BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in BoundTreeRewriter.cs line: 87
    at MethodToStateMachineRewriter.Visit(BoundNode node) in MethodToStateMachineRewriter.cs line: 658
    at BoundTreeRewriter.VisitSequencePoint(BoundSequencePoint node) in BoundNodes.xml.Generated.cs line: 9546
    at BoundSequencePoint.Accept(BoundTreeVisitor visitor) in BoundNodes.xml.Generated.cs line: 2614
    at BoundTreeVisitor.Visit(BoundNode node) in BoundTreeVisitors.cs line: 145
    at BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in BoundTreeRewriter.cs line: 87
    at MethodToStateMachineRewriter.Visit(BoundNode node) in MethodToStateMachineRewriter.cs line: 658
    at BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in BoundTreeRewriter.cs line: 37
    at BoundTreeRewriter.VisitList[T](ImmutableArray`1 list) in BoundTreeRewriter.cs line: 26
    at MethodToClassRewriter.VisitBlock(BoundBlock node) in MethodToClassRewriter.cs line: 139
    at MethodToStateMachineRewriter.&lt;&gt;n__0(BoundBlock node)
    at &lt;&gt;c__DisplayClass42_0.&lt;VisitBlock&gt;b__0() in MethodToStateMachineRewriter.cs line: 665
    at MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in MethodToStateMachineRewriter.cs line: 301
    at MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in MethodToStateMachineRewriter.cs line: 665
    at BoundBlock.Accept(BoundTreeVisitor visitor) in BoundNodes.xml.Generated.cs line: 2673
    at BoundTreeVisitor.Visit(BoundNode node) in BoundTreeVisitors.cs line: 145
    at BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in BoundTreeRewriter.cs line: 87
    at MethodToStateMachineRewriter.Visit(BoundNode node) in MethodToStateMachineRewriter.cs line: 658
    at AsyncMethodToStateMachineRewriter.VisitBody(BoundStatement body) in AsyncMethodToStateMachineRewriter.cs line: 255
    at AsyncMethodToStateMachineRewriter.GenerateMoveNext(BoundStatement body, MethodSymbol moveNextMethod) in AsyncMethodToStateMachineRewriter.cs line: 121
    at AsyncRewriter.GenerateMoveNext(SynthesizedImplementationMethod moveNextMethod) in AsyncRewriter.cs line: 269
    at AsyncRewriter.GenerateMethodImplementations() in AsyncRewriter.cs line: 140
    at StateMachineRewriter.Rewrite() in StateMachineRewriter.cs line: 114
    at AsyncRewriter.Rewrite(BoundStatement bodyWithAwaitLifted, MethodSymbol method, Int32 methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, AsyncStateMachine&amp; stateMachineType) in AsyncRewriter.cs line: 81
    at MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt) in MethodCompiler.cs line: 1346
    at MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in MethodCompiler.cs line: 1099
    at MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in MethodCompiler.cs line: 507
    at &lt;&gt;c__DisplayClass22_0.&lt;CompileNamedTypeAsTask&gt;b__0() in MethodCompiler.cs line: 397
    at &lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in UICultureUtilities.cs line: 136
    at Task.InnerInvoke()
    at Task.Execute()
    at --- End of stack trace from previous location where exception was thrown ---
```

&lt;/details&gt;

The issue here is that `TransformCompoundAssignmentLHS` can return a `ref` local for the [following case](https://github.com/dotnet/roslyn/blob/d5b8d64b4d840b26c947abd2a00b1070cbee55f0/src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_CompoundAssignmentOperator.cs#L622-L635):

https://github.com/dotnet/roslyn/blob/d5b8d64b4d840b26c947abd2a00b1070cbee55f0/src/Compilers/CSharp/Portable/Lowering/LocalRewriter/LocalRewriter_CompoundAssignmentOperator.cs#L490-L493

The fix is likely to simply issue an understandable error here, instead of throwing an UnreachableCode exception. FYI @jcouv @agocke.</Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>30/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38129</IssueID>
    <RepoID>1</RepoID>
    <Title>Should static local functions be able to access non-static local functions from parent scope?</Title>
    <Description>**Version Used**: master from SharpLab (a08336fd917ddb3cb884f37f974830da24143c6d)

**Steps to Reproduce**:

Compile the following code:

```c#
class C
{
    static void M()
    {
        int i = 42;
        
        static void StaticLocal() { }
        int Local() =&gt; i;

        static void SL()
        {
            StaticLocal();
            Local();
        }
        
        SL();
    }
}
```

**Expected Behavior**:

Since `Local` gives access to local state, `SL` should not be able to call it.

**Actual Behavior**:

[The code compiles fine and `SL` captures state.](https://sharplab.io/#v2:EYLgtghgzgLgpgJwD4AEBMACAwgWAFADe+GJGKAjAGxkAsGAsgBQCUxpRepXGAlgHYxeGALwYaaANxtuGadwrUUdAMowIMHgGMAMgHtNEADYsMBDAF85XfoL0HjzEQD5eUvFdILaGZdpYeSDhkZVXUtOyMWN2DuCIdo4MtOYICfP2YEkiTzIA===) I think that goes against the design of local functions. Or is this actually the intended behavior?</Description>
    <CreatedDate>20/08/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38105</IssueID>
    <RepoID>1</RepoID>
    <Title>VS21019 C# version 7.2 accepts pointer to nested generic type that is rejected by VS2017</Title>
    <Description>The following code is an error in C# 7.0 in VS 2017.  However, the same code is accepted in C# 7.0 in VS 2019.  This is a forward compatibility error (we are accepting code not part of C# 7.0 in that language version in VS 2019).

``` c#
class Program
{
    unsafe static void Main(string[] args)
    {
        G&lt;int&gt;.S* p = null;
    }
}

public class G&lt;T&gt;
{
    public struct S { int x; }
}
```
</Description>
    <CreatedDate>19/08/2019</CreatedDate>
    <ClosedDate>20/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36381</IssueID>
    <RepoID>1</RepoID>
    <Title>Hit NRE in completion (GetDescriptionAsync)</Title>
    <Description>**Version Used**: 

Version 16.2.0 Preview 2.0 [28930.63.d16.2stg]

**Steps to Reproduce**:

I don't have repro steps, just saw an NRE reported in goldbar with the following exception stack in activity log:

```
System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.Completion.CommonCompletionProvider.&lt;GetDescriptionAsync&gt;d__2.MoveNext()
 --- End of stack trace from previous location where exception was thrown
 ---    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.AsyncCompletion.CompletionSource.&lt;GetDescriptionAsync&gt;d__23.MoveNext()
 --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.VisualStudio.Text.Utilities.GuardedOperations.&lt;CallExtensionPointAsync&gt;d__35`1.MoveNext() ---
 End of stack trace from previous location where exception was thrown ---
    at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>16/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38010</IssueID>
    <RepoID>1</RepoID>
    <Title>preview8: Typing `ReferenceEquals(` crashes VS with IndexOutOfRangeException in NullableWalker.LearnFromEqualsMethod</Title>
    <Description>**Version Used**:

* .NET Core 3.0.100-preview8-013656
* Microsoft Visual Studio Community 2019 Preview Version 16.3.0 Preview 2.0
* Microsoft Windows 10 Pro x64 10.0.17763 N/A Build 17763

**Steps to Reproduce**:

1. Create a new C# .NET Core console project.
2. Enable NRTs by adding `&lt;Nullable&gt;enable&lt;/Nullable&gt;` to the csproj file.
3. Click Save All because you're about to lose any unsaved changes.
4. In the generated `Main` method, type `ReferenceEquals(`.

**Expected Behavior**: Lack of a crash.

**Actual Behavior**: Visual Studio crashes immediately without an error dialog of any kind.

```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.LearnFromEqualsMethod(MethodSymbol method, BoundCall node, TypeWithState receiverType, ImmutableArray`1 results)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.ReinferMethodAndVisitArguments(BoundCall node, TypeWithState receiverType)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitRvalue(BoundExpression node, Boolean isKnownToBeAnLvalue)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitStatements(ImmutableArray`1 statements)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.Analyze(Boolean&amp; badRegion, Optional`1 initialState)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Analyze(NullableWalker walker, Symbol symbol, DiagnosticBag diagnostics, VariableState initialState, Builder snapshotBuilderOpt)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.Analyze(CSharpCompilation compilation, Symbol symbol, BoundNode node, Binder binder, Conversions conversions, DiagnosticBag diagnostics, Boolean useMethodSignatureParameterTypes, MethodSymbol methodSignatureOpt, VariableState initialState, Builder analyzedNullabilityMapOpt, Builder updatedMethodSymbolMapOpt, Builder snapshotBuilderOpt, ArrayBuilder`1 returnTypesOpt)
   at Microsoft.CodeAnalysis.CSharp.NullableWalker.AnalyzeAndRewrite(CSharpCompilation compilation, Symbol symbol, BoundNode node, Binder binder, DiagnosticBag diagnostics, Boolean createSnapshots, SnapshotManager&amp; snapshotManager)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.RewriteNullableBoundNodesWithSnapshots(BoundNode boundRoot, Binder binder, DiagnosticBag diagnostics, Boolean createSnapshots, SnapshotManager&amp; snapshotManager)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.&lt;EnsureNullabilityAnalysisPerformedIfNecessary&gt;g__ensureSpeculativeNodeBound|127_0(&lt;&gt;c__DisplayClass127_0&amp; )
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.EnsureNullabilityAnalysisPerformedIfNecessary()
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetMemberGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetMemberGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Pythia.PythiaSignatureHelpProvider.&lt;GetItemsWorkerAsync&gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)
   at Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider.&lt;GetItemsAsync&gt;d__15.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller.Session.&lt;ComputeItemsAsync&gt;d__9.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;ComputeItemsAsync&gt;d__9.MoveNext()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(System.Threading.Tasks.Task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;ComputeItemsAsync&gt;d__9.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.ValueTuple`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;ComputeItemsAsync&gt;d__9, Microsoft.CodeAnalysis.EditorFeatures, Version=3.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ComputeItemsAsync&gt;d__9 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session.ComputeItemsAsync(System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider&gt;, Microsoft.VisualStudio.Text.SnapshotPoint, Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo, Microsoft.CodeAnalysis.Document, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;ComputeModelInBackgroundAsync&gt;d__4.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;ComputeModelInBackgroundAsync&gt;d__4, Microsoft.CodeAnalysis.EditorFeatures, Version=3.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ComputeModelInBackgroundAsync&gt;d__4 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session.ComputeModelInBackgroundAsync(Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Model, System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider&gt;, Microsoft.VisualStudio.Text.SnapshotPoint, Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.DisconnectedBufferGraph, Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Controller+Session+&lt;&gt;c__DisplayClass3_0.&lt;ComputeModel&gt;b__0(Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.SignatureHelp.Model, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.ModelComputation`1+&lt;&gt;c__DisplayClass17_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;ChainTaskAndNotifyControllerWhenFinished&gt;b__0(System.Threading.Tasks.Task`1&lt;System.__Canon&gt;)
   at Roslyn.Utilities.TaskExtensions+&lt;&gt;c__DisplayClass15_0`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;SafeContinueWithFromAsync&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```</Description>
    <CreatedDate>15/08/2019</CreatedDate>
    <ClosedDate>16/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37572</IssueID>
    <RepoID>1</RepoID>
    <Title>Error with Large HTML</Title>
    <Description>**Version Used**: 
VS2019 COMMUNITY

**Steps to Reproduce**:
1. FIRST CREATE A VB WEB PROJECT WEB FORMS
2. CREATE PAGE1.ASPX
3. WRITE A LARGE HTML IN IT
4. TRY TO RUN THE PROJECT

**Expected Behavior**:
SEE HTML NORMALLY

**Actual Behavior**:
ERROR THAT APPEAR:
https://github.com/rogeriorlima3/errorVS2019/issues/1
</Description>
    <CreatedDate>30/07/2019</CreatedDate>
    <ClosedDate>15/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17707</IssueID>
    <RepoID>1</RepoID>
    <Title>Misleading error message when returning 'this' by reference from class member</Title>
    <Description>**Version Used**: 
Master branch @ March 9
**Steps to Reproduce**:

Compile the following code:
```csharp
class C {
    ref C M() =&gt; ref this;   
}
```

**Expected Behavior**:
The compiler emits error "Class members cannot return 'this' by reference".

**Actual Behavior**:
The compiler emits error "Struct members cannot return 'this' or other instance members by reference"
</Description>
    <CreatedDate>10/03/2017</CreatedDate>
    <ClosedDate>10/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37713</IssueID>
    <RepoID>1</RepoID>
    <Title>Test await in switch arm when state machine has a live ref struct value</Title>
    <Description>We should test both the switch statement and the switch expression behavior when there is an await in the when expression, and the switch's state machine contains a value of a ref struct type that is still alive after the when (e.g. when it is false).  Such a temp would have to be spilled but cannot be spilled, so a diagnostic must be given.</Description>
    <CreatedDate>03/08/2019</CreatedDate>
    <ClosedDate>20/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37527</IssueID>
    <RepoID>1</RepoID>
    <Title>Constant folding produces different IL depending on host architecture</Title>
    <Description>**Version Used**: 

3.3.0-beta2-19374-02

**Steps to Reproduce**:

1. Compile and run the following program:
```csharp
Test program:

using System;

namespace HelloWorld
{
    class Program
    {
        static double nan = double.NaN;
        static float nanf = float.NaN;
        static double ninf = double.NegativeInfinity;
        static float ninff = float.NegativeInfinity;
        static double inf = double.PositiveInfinity;
        static float inff = float.PositiveInfinity;

        static void Main(string[] args)
        {
            Console.WriteLine(unchecked((ulong)double.NaN));
            Console.WriteLine(unchecked((ulong)nan));
            Console.WriteLine(unchecked((uint)double.NaN));
            Console.WriteLine(unchecked((uint)nan));
            Console.WriteLine(unchecked((ulong)float.NaN));
            Console.WriteLine(unchecked((ulong)nanf));
            Console.WriteLine(unchecked((uint)float.NaN));
            Console.WriteLine(unchecked((uint)nanf));

            Console.WriteLine(unchecked((ulong)double.NegativeInfinity));
            Console.WriteLine(unchecked((ulong)ninf));
            Console.WriteLine(unchecked((uint)double.NegativeInfinity));
            Console.WriteLine(unchecked((uint)ninf));
            Console.WriteLine(unchecked((ulong)float.NegativeInfinity));
            Console.WriteLine(unchecked((ulong)ninff));
            Console.WriteLine(unchecked((uint)float.NegativeInfinity));
            Console.WriteLine(unchecked((uint)ninff));

            Console.WriteLine(unchecked((ulong)double.PositiveInfinity));
            Console.WriteLine(unchecked((ulong)inf));
            Console.WriteLine(unchecked((uint)double.PositiveInfinity));
            Console.WriteLine(unchecked((uint)inf));
            Console.WriteLine(unchecked((ulong)float.PositiveInfinity));
            Console.WriteLine(unchecked((ulong)inff));
            Console.WriteLine(unchecked((uint)float.PositiveInfinity));
            Console.WriteLine(unchecked((uint)inff));
        }
    }
}
```
2. Repeat step 1 on different architectures (x64, ARM64)

**Expected Behavior**:

Identical IL is produced.

**Actual Behavior**:

`(ulong)double.PositiveInfinity` is constant folded to `0` on x64 host. On ARM host it is folded to `ulong.MaxValue`. Similarly for all the other variations of `PositiveInfinity`.

While the actual behavior for this conversion in C# may be undefined this causes some hard to debug issues. When program is compiled and run on the same architecture the values are self-consistent. However, when the program is compiled on x64 and run on ARM64 it produces inconsistent results.

This was hit in practice with CoreFX tests for System.Linq.Expressions. The tests are compiled on x64 and consumed in binary form for CoreCLR and Mono tests. Cross-reference: https://github.com/mono/mono/pull/15871

x64 code:
```
        IL_0000: ldc.i4.0
        IL_0001: conv.i8
        IL_0002: call void [System.Console]System.Console::WriteLine(uint64)
        IL_0007: ldsfld float64 HelloWorld.Program::nan
        IL_000c: conv.u8
        IL_000d: call void [System.Console]System.Console::WriteLine(uint64)
        IL_0012: ldc.i4.0
        IL_0013: call void [System.Console]System.Console::WriteLine(uint32)
        IL_0018: ldsfld float64 HelloWorld.Program::nan
        IL_001d: conv.u4
        IL_001e: call void [System.Console]System.Console::WriteLine(uint32)
        IL_0023: ldc.i4.0
        IL_0024: conv.i8
        IL_0025: call void [System.Console]System.Console::WriteLine(uint64)
        IL_002a: ldsfld float32 HelloWorld.Program::nanf
        IL_002f: conv.u8
        IL_0030: call void [System.Console]System.Console::WriteLine(uint64)
        IL_0035: ldc.i4.0
        IL_0036: call void [System.Console]System.Console::WriteLine(uint32)
        IL_003b: ldsfld float32 HelloWorld.Program::nanf
        IL_0040: conv.u4
        IL_0041: call void [System.Console]System.Console::WriteLine(uint32)
        IL_0046: ldc.i8 -9223372036854775808
        IL_004f: call void [System.Console]System.Console::WriteLine(uint64)
        IL_0054: ldsfld float64 HelloWorld.Program::ninf
        IL_0059: conv.u8
        IL_005a: call void [System.Console]System.Console::WriteLine(uint64)
        IL_005f: ldc.i4.0
        IL_0060: call void [System.Console]System.Console::WriteLine(uint32)
        IL_0065: ldsfld float64 HelloWorld.Program::ninf
        IL_006a: conv.u4
        IL_006b: call void [System.Console]System.Console::WriteLine(uint32)
        IL_0070: ldc.i8 -9223372036854775808
        IL_0079: call void [System.Console]System.Console::WriteLine(uint64)
        IL_007e: ldsfld float32 HelloWorld.Program::ninff
        IL_0083: conv.u8
        IL_0084: call void [System.Console]System.Console::WriteLine(uint64)
        IL_0089: ldc.i4.0
        IL_008a: call void [System.Console]System.Console::WriteLine(uint32)
        IL_008f: ldsfld float32 HelloWorld.Program::ninff
        IL_0094: conv.u4
        IL_0095: call void [System.Console]System.Console::WriteLine(uint32)
        IL_009a: ldc.i4.0
        IL_009b: conv.i8
        IL_009c: call void [System.Console]System.Console::WriteLine(uint64)
        IL_00a1: ldsfld float64 HelloWorld.Program::inf
        IL_00a6: conv.u8
        IL_00a7: call void [System.Console]System.Console::WriteLine(uint64)
        IL_00ac: ldc.i4.0
        IL_00ad: call void [System.Console]System.Console::WriteLine(uint32)
        IL_00b2: ldsfld float64 HelloWorld.Program::inf
        IL_00b7: conv.u4
        IL_00b8: call void [System.Console]System.Console::WriteLine(uint32)
        IL_00bd: ldc.i4.0
        IL_00be: conv.i8
        IL_00bf: call void [System.Console]System.Console::WriteLine(uint64)
        IL_00c4: ldsfld float32 HelloWorld.Program::inff
        IL_00c9: conv.u8
        IL_00ca: call void [System.Console]System.Console::WriteLine(uint64)
        IL_00cf: ldc.i4.0
        IL_00d0: call void [System.Console]System.Console::WriteLine(uint32)
        IL_00d5: ldsfld float32 HelloWorld.Program::inff
        IL_00da: conv.u4
        IL_00db: call void [System.Console]System.Console::WriteLine(uint32)
        IL_00e0: ret
```

ARM64 code:
```
	IL_0000: nop
	IL_0001: ldc.i4.0
	IL_0002: conv.i8
	IL_0003: call void [System.Console]System.Console::WriteLine(uint64)
	IL_0008: nop
	IL_0009: ldsfld float64 HelloWorld.Program::nan
	IL_000e: conv.u8
	IL_000f: call void [System.Console]System.Console::WriteLine(uint64)
	IL_0014: nop
	IL_0015: ldc.i4.0
	IL_0016: call void [System.Console]System.Console::WriteLine(uint32)
	IL_001b: nop
	IL_001c: ldsfld float64 HelloWorld.Program::nan
	IL_0021: conv.u4
	IL_0022: call void [System.Console]System.Console::WriteLine(uint32)
	IL_0027: nop
	IL_0028: ldc.i4.0
	IL_0029: conv.i8
	IL_002a: call void [System.Console]System.Console::WriteLine(uint64)
	IL_002f: nop
	IL_0030: ldsfld float32 HelloWorld.Program::nanf
	IL_0035: conv.u8
	IL_0036: call void [System.Console]System.Console::WriteLine(uint64)
	IL_003b: nop
	IL_003c: ldc.i4.0
	IL_003d: call void [System.Console]System.Console::WriteLine(uint32)
	IL_0042: nop
	IL_0043: ldsfld float32 HelloWorld.Program::nanf
	IL_0048: conv.u4
	IL_0049: call void [System.Console]System.Console::WriteLine(uint32)
	IL_004e: nop
	IL_004f: ldc.i4.0
	IL_0050: conv.i8
	IL_0051: call void [System.Console]System.Console::WriteLine(uint64)
	IL_0056: nop
	IL_0057: ldsfld float64 HelloWorld.Program::ninf
	IL_005c: conv.u8
	IL_005d: call void [System.Console]System.Console::WriteLine(uint64)
	IL_0062: nop
	IL_0063: ldc.i4.0
	IL_0064: call void [System.Console]System.Console::WriteLine(uint32)
	IL_0069: nop
	IL_006a: ldsfld float64 HelloWorld.Program::ninf
	IL_006f: conv.u4
	IL_0070: call void [System.Console]System.Console::WriteLine(uint32)
	IL_0075: nop
	IL_0076: ldc.i4.0
	IL_0077: conv.i8
	IL_0078: call void [System.Console]System.Console::WriteLine(uint64)
	IL_007d: nop
	IL_007e: ldsfld float32 HelloWorld.Program::ninff
	IL_0083: conv.u8
	IL_0084: call void [System.Console]System.Console::WriteLine(uint64)
	IL_0089: nop
	IL_008a: ldc.i4.0
	IL_008b: call void [System.Console]System.Console::WriteLine(uint32)
	IL_0090: nop
	IL_0091: ldsfld float32 HelloWorld.Program::ninff
	IL_0096: conv.u4
	IL_0097: call void [System.Console]System.Console::WriteLine(uint32)
	IL_009c: nop
	IL_009d: ldc.i4.m1
	IL_009e: conv.i8
	IL_009f: call void [System.Console]System.Console::WriteLine(uint64)
	IL_00a4: nop
	IL_00a5: ldsfld float64 HelloWorld.Program::inf
	IL_00aa: conv.u8
	IL_00ab: call void [System.Console]System.Console::WriteLine(uint64)
	IL_00b0: nop
	IL_00b1: ldc.i4.m1
	IL_00b2: call void [System.Console]System.Console::WriteLine(uint32)
	IL_00b7: nop
	IL_00b8: ldsfld float64 HelloWorld.Program::inf
	IL_00bd: conv.u4
	IL_00be: call void [System.Console]System.Console::WriteLine(uint32)
	IL_00c3: nop
	IL_00c4: ldc.i4.m1
	IL_00c5: conv.i8
	IL_00c6: call void [System.Console]System.Console::WriteLine(uint64)
	IL_00cb: nop
	IL_00cc: ldsfld float32 HelloWorld.Program::inff
	IL_00d1: conv.u8
	IL_00d2: call void [System.Console]System.Console::WriteLine(uint64)
	IL_00d7: nop
	IL_00d8: ldc.i4.m1
	IL_00d9: call void [System.Console]System.Console::WriteLine(uint32)
	IL_00de: nop
	IL_00df: ldsfld float32 HelloWorld.Program::inff
	IL_00e4: conv.u4
	IL_00e5: call void [System.Console]System.Console::WriteLine(uint32)
	IL_00ea: nop
	IL_00eb: ret
```</Description>
    <CreatedDate>29/07/2019</CreatedDate>
    <ClosedDate>30/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37231</IssueID>
    <RepoID>1</RepoID>
    <Title>UniqueItem is not triggered when completion is initiated by backspace</Title>
    <Description>**Version Used**:  16.1.6, 16.3 preview 1
**Regression**:
This is a regression from 15.9.13

**Steps to Reproduce**:

1. Type AccessViolationException
2. Ensure completion is closed (you can do it using Ctrl+Space)
3. Hit backspace
4. Hit Ctrl+Space

![image](https://user-images.githubusercontent.com/1673956/61238712-153b1200-a6f2-11e9-985f-3468ede150ec.png)


**Expected Behavior**:
AccessViolationException is committed

This will be possible when Roslyn's `IAsyncCompletionItemManager.UpdateCompletionListAsync` sets the `UniqueItem` property

**Actual Behavior**:
AccessViolationException is not committed.

This happens because Roslyn's `IAsyncCompletionItemManager.UpdateCompletionListAsync` does not set the `UniqueItem` property, but it should
</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>09/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37467</IssueID>
    <RepoID>1</RepoID>
    <Title>SyntaxFactory.MethodDeclaration bug</Title>
    <Description>**Version Used**: 
v3.1.0 Microsoft.CodeAnalysis.CSharp

**Steps to Reproduce**:
Use `SyntaxFactory.MethodDeclaration(SyntaxList&lt;AttributeListSyntax&gt;, SyntaxTokenList, TypeSyntax, ExplicitInterfaceSpecifierSyntax, SyntaxToken, TypeParameterListSyntax, ParameterListSyntax, SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt;, BlockSyntax, SyntaxToken)` overload

**Expected Behavior**:
Semicolon SyntaxToken passed to wrapped method

**Actual Behavior**:
Semicolon SyntaxToken replaced with `default(SyntaxToken)`

Checked IL in downloaded nugget package to verify issue.</Description>
    <CreatedDate>25/07/2019</CreatedDate>
    <ClosedDate>26/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37427</IssueID>
    <RepoID>1</RepoID>
    <Title>Region analysis gives incorrect results in the presence of local functions</Title>
    <Description>Region analysis gives incorrect results in the presence of local functions.  The implementation does not properly track the start and end of the region, resulting in incorrect results.

See also https://github.com/dotnet/roslyn/issues/37421 https://github.com/dotnet/roslyn/issues/19497

/cc @CyrusNajmabadi @agocke 

``` c#
        [Fact, WorkItem(37427, "https://github.com/dotnet/roslyn/issues/37427")]
        public void RegionWithLocalFunctions()
        {
            var analysisResults = CompileAndAnalyzeDataFlowStatements(@"
class A
{
    static void M(int p)
    {
        int i, j;
        i = 1;
        /*&lt;bind&gt;*/
        int L1() =&gt; 1;
        int k;
        j = i;
        int L2() =&gt; 2;
        /*&lt;/bind&gt;*/
        k = j;
    }
}
");
            var dataFlowAnalysisResults = analysisResults;
            Assert.True(dataFlowAnalysisResults.Succeeded);
            Assert.Equal("k", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
            // should be "j"
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.AlwaysAssigned));
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.Captured));
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.CapturedInside));
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.CapturedOutside));
            // should be "i"
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsIn));
            // should be "j"
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.DataFlowsOut));
            // should be "i"
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.ReadInside));
            // should be "j"
            Assert.Equal("i, j", GetSymbolNamesJoined(dataFlowAnalysisResults.ReadOutside));
            // should be "j"
            Assert.Equal(null, GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenInside));
            // should be "p, i, k"
            Assert.Equal("p, i, j, k", GetSymbolNamesJoined(dataFlowAnalysisResults.WrittenOutside));
        }
```
</Description>
    <CreatedDate>23/07/2019</CreatedDate>
    <ClosedDate>26/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37082</IssueID>
    <RepoID>1</RepoID>
    <Title>No new line after pressing Enter with suggestion open</Title>
    <Description>VSF_TYPE_MARKDOWNI have set the option to only insert a new line on pressing Enter if the suggested word was typed completely. I always did that and it used to work in VS 2017. Now it doesn't work in VS 2019. The suggestion dropdown closes but no new line is inserted. The cursor remains at the end of the typed word.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/608806/no-new-line-after-pressing-enter-with-suggestion-o.html
VSTS ticketId: 922763_
_These are the original issue comments:_

Visual Studio Feedback System on 6/17/2019, 02:50 AM (22 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Visual Studio Feedback System on 6/24/2019, 00:02 AM (15 days ago): &lt;markdown&gt;&lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;
&lt;/markdown&gt;
_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36938</IssueID>
    <RepoID>1</RepoID>
    <Title>Hang on applying code action on a single unopened file</Title>
    <Description>VSF_TYPE_MARKDOWNTrying to invoke a quick action or intellisense sometimes causes VS to freeze and needs to be force closed.

No specific repro steps, it happens seemingly randomly a couple of times a day.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/624919/ui-hang.html
VSTS ticketId: 938306_
_These are the original issue comments:_

Visual Studio Feedback System on 6/27/2019, 01:15 AM (5 days ago): &lt;markdown&gt;&lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;
&lt;/markdown&gt;
Visual Studio Feedback System on 7/1/2019, 05:04 PM (23 hours ago): &lt;markdown&gt;&lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;
&lt;/markdown&gt;
ext.par.bjorklund on 7/1/2019, 10:11 PM (18 hours ago): &lt;p&gt;I got frustrated yesterday and uninstalled IntelliCode and things have been better since then. I wouldn't say completely gone but happening less often and shorter time periods&lt;/p&gt;

Gunnar Skogsholm on 7/2/2019, 06:49 AM (9 hours ago): I have also been experiencing this at various times, since VS2015 days.  A couple of releases have been better than others, but it's back now with 16.1.4
_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>02/07/2019</CreatedDate>
    <ClosedDate>03/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36496</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler "Failed to emit module" with empty var tuple pattern</Title>
    <Description>The following program does not compile:
``` c#
public class C
{
    public static void Main() { }
    public void M(C c)
    {
        if (c is var ()) { }
    }
    public void Deconstruct() { }
}
```
The error is "error CS7038: Failed to emit module"
</Description>
    <CreatedDate>17/06/2019</CreatedDate>
    <ClosedDate>28/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36513</IssueID>
    <RepoID>1</RepoID>
    <Title>Intellisense changes existing, correct variable to differently capitalized type of the same name</Title>
    <Description>**Version Used**: Visual Studio 16.2.0 Preview 1.0

**Steps to Reproduce**:

1. Create a C# file with a struct `Structure` and an instance of that `Structure structure`
2. Attempt to autocomplete `structure.`, backspace over the `.` then type in `.` again. 
3. Rinse and repeat.

**Expected Behavior**:

Autocomplete/Intellisense will always provide completions for the valid local variable `structure`. Autocomplete/IntelliSense will never change the `structure` that I typed to `Structure`.

**Actual Behavior**:

As of Visual Studio 16 (perhaps specifically a later preview build), sometimes the `structure` I had previously typed out will be changed to `Structure`. *This appears to be a race condition*, as it does not reproduce every time. 

This is a demonstration of the bug: https://www.youtube.com/watch?v=cEnwzAPYTFc&amp;feature=youtu.be

I am sorry I do not have a 100% reproducible case, but this has been observed for awhile now on multiple PCs since upgrading to Visual Studio 2019 preview.</Description>
    <CreatedDate>17/06/2019</CreatedDate>
    <ClosedDate>24/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35301</IssueID>
    <RepoID>1</RepoID>
    <Title>completion: CTRL+Space is not applicable in Delete/Backspace triggered session</Title>
    <Description>Both old and new completions. 
Start with 

```C#
class C
{
    void Method()
    {
        var s = "";
        s.Length$$
    }
}
```

Intellisense TriggerOnDelete should be ON
SendBackspace
SendCommitIfUnique

**Expected**
No active completion session
`s.Length` is in the current line

**Actual**
Active completion session
`s.Lengt` is in the current line</Description>
    <CreatedDate>26/04/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36187</IssueID>
    <RepoID>1</RepoID>
    <Title>Odd IntelliSense Behavior with Overloaded Methods</Title>
    <Description>VSF_TYPE_MARKDOWNWhen you type the following code:

```
private enum A
{
	A,
	B,
}

private void Get(A a) { }
private void Get(string a) { }

private void Test()
{
	Get(
}
```

When you type the `(` after the `Get` in the `Test` method, VS suggests to autocomplete the first parameter of type `A`, which is exactly expected.

See this picture: https://cdn.discordapp.com/attachments/369794346142269441/577795445443657728/unknown.png

But when you change the declaration order of the two `Get` methods, like this:

```
private enum A
{
	A,
	B,
}

private void Get(string a) { }
private void Get(A a) { }

private void Test()
{
	Get(
}
```

And now if you type `(`, you get no suggestions. Notice that the first overloaded method that shows up is still the one with the `A` parameter, and not the `string` one.

See this picture: https://cdn.discordapp.com/attachments/369794346142269441/577795671596335124/unknown.png

Pressin the default `Ctrl+Space` does not help either.

**Expected behavior:** When the `Get(A a)` method is selected as the current overload, pressing `Ctrl+Space` should suggest to complete that given parameter.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/567651/odd-intellisense-behavior-with-overloaded-methods.html
VSTS ticketId: 892502_
_These are the original issue comments:_

Visual Studio Feedback System on 5/14/2019, 09:42 PM (21 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Vatsalya Agrawal [MSFT] on 5/15/2019, 00:11 PM (21 days ago): &lt;p&gt;Thank you for providing feedback, and we're sorry to hear it's not behaving as you expect. Based on your description so far, we were unable to reproduce the issue. Pressing Ctrl + Space seems to be suggesting the right parameter. If possible please provide a sample project where this issue is occurring.&lt;/p&gt;

matej.zajacik on 5/15/2019, 00:33 PM (21 days ago): &lt;strong&gt;(private comment)&lt;/strong&gt;&lt;p&gt;Thank you for the reply!&lt;/p&gt;&lt;p&gt;When the declaration order is `Get(A a)` and then `Get(string a)`, everything works okay. Right after typing `(`, it does the expected thing, that is suggesting the enum `A` (the first picture). But when the order is `Get(string a)` and then `Get(A a)`, I get no suggestion at all (the second picture). When I press `Ctrl+Space`, it suggests to use the `ToString()` method:&lt;/p&gt;&lt;p&gt;&lt;a target='_blank' href="https://developercommunity.visualstudio.com/storage/attachments/73607-intellisenseissue00.png"&gt;intellisenseissue00.png&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The project: &lt;a target='_blank' href="https://developercommunity.visualstudio.com/storage/attachments/73608-intellisenseissue.zip"&gt;intellisenseissue.zip&lt;/a&gt;&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>05/06/2019</CreatedDate>
    <ClosedDate>11/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36029</IssueID>
    <RepoID>1</RepoID>
    <Title>vs16.1.0 can not find  navigation properties in the Completion preview list</Title>
    <Description>&lt;p&gt;I'm using the. Netcore writing application, and there are navigation properties in my entity model that resemble the following&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;    Public class Fieldpermission:auditedentity&amp;lt;int&amp;gt;
{
        Public int RoleId {get; set;}
        Public Role Role {get; set;}
        Public string TableName {get; set;}
    Public string PermissionsList {get; set;}
} &lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;When I write code, I can't find the navigation properties Role by filling out the list&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;Var fields = await _fieldPermissionRepository.GetAllIncluding (t =&amp;gt; t.Role) 
.ToListAsync ();&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;The t.Role inside GetAllIncluding (T =&amp;gt; t.Role) cannot be found in the Completion preview list There was no problem with the previous version, and the update did not occur until version 16.1.0&lt;/p&gt;

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/577215/vs1610-代码补全预览列表不显示导航属性的内容.html
VSTS ticketId: 896840_
_These are the original issue comments:_

Visual Studio Feedback System on 5/22/2019, 01:43 AM (7 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Visual Studio Feedback System on 5/22/2019, 10:05 AM (7 days ago): &lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;

Ivan Basov [MSFT] on 5/22/2019, 11:54 AM (7 days ago): &lt;p&gt;Thank you for your feedback! Could you please provide a sample application when you observe the issue?&lt;/p&gt;

Ivan Basov [MSFT] on 5/22/2019, 11:55 AM (7 days ago): &lt;p&gt;Thank you for your feedback! Could you please provide a sample application where you observe the issue?&lt;/p&gt;

1025676114 on 5/27/2019, 03:01 AM (2 days ago): ok，I have created a simple project, you can clone from  https://github.com/matoushan/FeedbackApp  , and read README.md file, I am enclosing my project now
1025676114 on 5/27/2019, 02:13 AM (2 days ago): ok，I have created a simple project, you can clone from  https://github.com/matoushan/FeedbackApp , and read README.md file
_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>29/05/2019</CreatedDate>
    <ClosedDate>03/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32889</IssueID>
    <RepoID>1</RepoID>
    <Title>CSharpEditAndContinueAnalyzer.ClassifyUpdate of VariableDeclaratorSyntax. Cast exception on  (TypeDeclarationSyntax)oldNode.Parent.Parent.Parent;</Title>
    <Description>**Callstack reported**: 
```
System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax'.
   at Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.EditClassifier.ClassifyUpdate(VariableDeclaratorSyntax oldNode, VariableDeclaratorSyntax newNode)
   at Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.EditClassifier.ClassifyUpdate(SyntaxNode oldNode, SyntaxNode newNode)
   at Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.EditClassifier.ClassifyEdit()
   at Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.ReportSyntacticRudeEdits(List`1 diagnostics, Match`1 match, Edit`1 edit, Dictionary`2 editMap)
   at Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AnalyzeSyntax(EditScript`1 script, Dictionary`2 editMap, SourceText oldText, SourceText newText, DocumentId documentId, IActiveStatementTrackingService trackingService, ImmutableArray`1 oldActiveStatements, ActiveStatement[] newActiveStatements, ImmutableArray`1[] newExceptionRegions, List`1 updatedMethods, List`1 diagnostics)
   at Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.&lt;AnalyzeDocumentAsync&gt;d__65.MoveNext()
…
```

It seems that 
http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp.Features/EditAndContinue/CSharpEditAndContinueAnalyzer.cs,2491
should be changed from
 `   var fieldDeclaration = (FieldDeclarationSyntax)oldNode.Parent.Parent;`
to
`    var fieldDeclaration = (BaseFieldDeclarationSyntax)oldNode.Parent.Parent;`

We should add a unit test for this as well.
</Description>
    <CreatedDate>28/01/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35764</IssueID>
    <RepoID>1</RepoID>
    <Title>Invalid IL generated for stackalloc assigned to Span</Title>
    <Description>3.2.0-beta1-19253-08

**Steps to Reproduce**:

1. Compile System.Private.CoreLib

**Expected Behavior**:

Valid IL generated for `Environment.GetEnvironmentVariableCore` method

**Actual Behavior**:

Invalid IL generated for `Environment.GetEnvironmentVariableCore` method

The ECMA spec requires that IL stack is empty, apart from the size item, for localloc instruction.

Details in https://github.com/dotnet/coreclr/pull/24369#issuecomment-493130547</Description>
    <CreatedDate>16/05/2019</CreatedDate>
    <ClosedDate>21/05/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35584</IssueID>
    <RepoID>1</RepoID>
    <Title>'Is' operator casts Int32 to null within constructor of generic type</Title>
    <Description>**Version Used**: Unsure - let me know how to determine, or if you need further information. Using VS2019 Enterprise, targeting .NET Framework 4.6.1, LangVersion 7.3, Microsoft.Net.Compilers 3.0.0.

**Steps to Reproduce**:

```
[Test]
public void UnexpectedlyCastToNull_ViaIsOperator_WhenGeneric()
{
    var nonGenericfoo = new NonGenericFoo(0);  // no problem

    var genericFoo = new GenericFoo&lt;int&gt;(0); // Kaboom exception thrown
}

private class NonGenericFoo
{
    public NonGenericFoo(int value)
    {
        if (value is object obj &amp;&amp; obj == null)
        {
            throw new Exception("Kaboom!");
        }
    }
}

private class GenericFoo&lt;T&gt;
{
    public GenericFoo(T value)
    {
        if (value is object obj &amp;&amp; obj == null)
        {
            throw new Exception("Kaboom!");
        }
    }
}
```

**Expected Behavior**:

I believe that if the expression `value is object obj` evaluates to `true`, then `obj` should be a non-null object. As such, the subsequent `obj == null` expression in the `GenericFoo` constructor should evaluate to false, and not throw the exception.

**Actual Behavior**:

The `is` operator in the `GenericFoo` constructor casts `value` to a null object, which then throws the "Kaboom!" exception.

Also relevant: if the value `1` is passed into the constructor instead of `0`, the test passes without any exception being thrown.</Description>
    <CreatedDate>08/05/2019</CreatedDate>
    <ClosedDate>15/05/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35709</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix bug where pattern-matching treats a type parameter as if it is a reference (which it might not be) (16.2p1)</Title>
    <Description>Dual-checkin of https://github.com/dotnet/roslyn/pull/35664

FYI @gafter @RikkiGibson </Description>
    <CreatedDate>14/05/2019</CreatedDate>
    <ClosedDate>14/05/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>31685</IssueID>
    <RepoID>1</RepoID>
    <Title>Lambda type parameter lowering for implicit cast to ReadOnlySpan&lt;T&gt; appears to be incorrect</Title>
    <Description>**Version Used**: 
Don't know. I know it happened as of the build of Roslyn that was used to compile several of the most recently released versions of ML.NET (0.7 and 0.8)

**Steps to Reproduce**:

1. Build the https://github.com/dotnet/machinelearning repo
2. Examine Microsoft.ML.Transforms.dll
3. Examine the  lambda body associated with  Microsoft.ML.Transforms.Conversions.HashJoiningTransform.ComposeGetterVecToVec&lt;TSrc&gt;.
4. The translation of the lambda incorrectly handles the method generic parameter associated with the implicit conversion to a ReadOnlySpan.

The problematic line of code is line 563 of HashJoiningTransform.cs ( see https://github.com/dotnet/machinelearning/blob/521acad830408b43175821575f5f774629aeafe7/src/Microsoft.ML.Transforms/HashJoiningTransform.cs ) 

**Expected Behavior**:

The above C# line is translated into
```
IL_0084:  call       valuetype [System.Memory]System.ReadOnlySpan`1&lt;!0&gt; valuetype [System.Memory]System.ReadOnlySpan`1&lt;!0&gt;::op_Implicit(!0[])
```

**Actual Behavior**:
```
IL_0084:  call       valuetype [System.Memory]System.ReadOnlySpan`1&lt;!0&gt; valuetype [System.Memory]System.ReadOnlySpan`1&lt;!!0&gt;::op_Implicit(!0[])
```
Note... the difference is that the broken line specifies a method generic parameter not the necessary type generic parameter.
</Description>
    <CreatedDate>11/12/2018</CreatedDate>
    <ClosedDate>07/05/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35027</IssueID>
    <RepoID>1</RepoID>
    <Title>Intellisense broken inside of methods that have delegates as arguments</Title>
    <Description>Intellisense broken for callbacks. Inside of the Foo callback below builder. shows intellisense for the Delegate type instead of the Builder type. This works fine in 16 but broken in 16.1 preview 2.

```csharp
using System;
namespace ConsoleApp40
{
    class Program
    {
        static void Main(string[] args)
        {
            Foo(builder =&amp;gt;
            {
                builder.
            });
        }
        static void Foo(Action&amp;lt;Builder&amp;gt; configure)
        {
            var builder = new Builder();
            configure(builder);
        }
    }
    class Builder
    {
        public int Something { get; set; }
    }
}
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/533644/intellisense-broken-inside-of-methods-that-have-de.html
VSTS ticketId: 847803_
_These are the original issue comments:_

Visual Studio Feedback System on 4/15/2019, 08:17 PM (20 hours ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Visual Studio Feedback System on 4/16/2019, 00:07 PM (5 hours ago): &lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>17/04/2019</CreatedDate>
    <ClosedDate>19/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32818</IssueID>
    <RepoID>1</RepoID>
    <Title>Simulate the C# 7 compiler's behavior on traditional switch statements with old language versions</Title>
    <Description>Fixes #32806
This was a "forward compatibility" bug, where new compilers would accept code in old language versions that the older compilers would not have accepted.</Description>
    <CreatedDate>26/01/2019</CreatedDate>
    <ClosedDate>29/01/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35011</IssueID>
    <RepoID>1</RepoID>
    <Title>switch case without default no longer compiles in visual studio 2019 [c#]</Title>
    <Description>VSF_TYPE_MARKDOWNThe following code compiles fine in Visual Studio 2017, but not in Visual Studio 2019. Is there a default compiler option that has changed which can resolve this?

    using System;
    
    namespace NoDefaultCase
    {
        public static class Program
        {
            public const string Database = &amp;quot;MongoDB&amp;quot;;
    
            public static string GetDb()
            {
                switch (Database)
                {
                    case &amp;quot;MongoDB&amp;quot;:
                        return Database;
                }
            }
    
            public static void Main(string[] args)
            {
                Console.WriteLine($&amp;quot;The value returned is \&amp;quot;{GetDb()}\&amp;quot;.&amp;quot;);
                Console.WriteLine(&amp;quot;Press a key to exit&amp;quot;);
                Console.ReadKey();
            }
        }
    }

There is also a Stack Overflow ticket for this item:
https://stackoverflow.com/questions/55541269/why-does-a-switch-case-statement-on-a-string-constant-require-a-default-in-visua

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/520522/switch-case-without-default-no-longer-compiles-in.html
VSTS ticketId: 841662_
_These are the original issue comments:_

Martin Eyles on 4/6/2019, 05:37 AM (10 days ago): &lt;p&gt;In Visual Studio 2017, the output of the build is:&lt;br&gt;&lt;br&gt;    1&amp;gt;------ Rebuild All started: Project: NoDefaultCase, Configuration: Debug Any CPU ------&lt;br&gt;    1&amp;gt;  NoDefaultCase -&amp;gt; C:\Users\MartinEyles\source\repos\NoDefaultCase\NoDefaultCase\bin\Debug\NoDefaultCase.exe&lt;br&gt;    ========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========&lt;br&gt;&lt;br&gt;In Visual Studio 2019, the output of the build is:&lt;br&gt;&lt;br&gt;    1&amp;gt;------ Rebuild All started: Project: NoDefaultCase, Configuration: Debug Any CPU ------&lt;br&gt;    1&amp;gt;C:\Users\MartinEyles\source\repos\NoDefaultCase\NoDefaultCase\Program.cs(9,30,9,35): error CS0161: 'Program.GetDb()': not all code paths return a value&lt;br&gt;    ========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========&lt;/p&gt;

Visual Studio Feedback System on 4/8/2019, 02:55 AM (8 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Martin Eyles on 4/8/2019, 03:07 AM (8 days ago): &lt;p&gt;A github repository containing the example solution can be found at &lt;a target='_blank' href="https://github.com/martineyles/NoDefaultCase"&gt;https://github.com/martineyles/NoDefaultCase&lt;/a&gt; This includes an archive of the example solution in the state before it was added to github (NoDefaultCase - Before Github.zip).&lt;/p&gt;

Martin Eyles on 4/8/2019, 05:59 AM (8 days ago): &lt;p&gt;I experience this issue in &lt;/p&gt;&lt;p&gt;Microsoft Visual Studio Enterprise 2019 &lt;br&gt;Version 16.0.0&lt;br&gt;VisualStudio.16.Release/16.0.0+28729.10&lt;br&gt;Microsoft .NET Framework Version 4.7.03056'&lt;/p&gt;&lt;p&gt;It has been suggested by others in the Stack Overflow community that a preview version of Visual Studio 2019 behaves the same way as Visual Studio 2017&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:24 AM (4 days ago): &lt;p&gt;The issue is still present in:&lt;br&gt;&lt;br&gt;Microsoft Visual Studio Enterprise 2019&lt;br&gt;Version 16.0.1&lt;br&gt;VisualStudio.16.Release/16.0.1+28803.156&lt;br&gt;Microsoft .NET Framework Version 4.7.03056&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:26 AM (4 days ago): &lt;p&gt;Stack overflow users has suggested that this does not meet the C#  specification, and is likely to be either a bug or a change in the  specification that hasn't yet been documented.&lt;/p&gt;

Martin Eyles on 4/12/2019, 05:29 AM (4 days ago): &lt;p&gt;To quote a user with very good reputation on stack overflow:&lt;/p&gt;&lt;p&gt;The &lt;a target='_blank' href="https://www.ecma-international.org/publications/standards/Ecma-334.htm"&gt;ECMA C# 5 standard&lt;/a&gt; section 13.8.3 describes the reachability of the end of a switch statement:&lt;/p&gt;&lt;p&gt;  
&lt;/p&gt;&lt;blockquote&gt;   
&lt;p&gt;The end point of a switch statement is reachable if at least one of the following is true:&lt;/p&gt;&lt;p&gt;      
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The switch statement contains a reachable break statement that exits the switch statement.&lt;/li&gt;&lt;li&gt;The switch statement is reachable, the switch expression is a non-constant value, and no default label is present.&lt;/li&gt;&lt;li&gt;The switch statement is reachable, the switch expression is a  constant value that doesn’t match any case label, and no default label  is present.&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;  
&lt;/p&gt;&lt;p&gt;None of these seem to be the case in your example:&lt;/p&gt;&lt;p&gt;  
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There are no break statements&lt;/li&gt;&lt;li&gt;The switch expression is a constant value&lt;/li&gt;&lt;li&gt;The constant value &lt;em&gt;does&lt;/em&gt; match a case label&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;  
&lt;/p&gt;&lt;p&gt;So with C# 5 rules, the end point of this switch statement is &lt;em&gt;not&lt;/em&gt; reachable, and it should compile with no problems. The &lt;a target='_blank' href="https://github.com/dotnet/csharplang/blob/master/spec/statements.md"&gt;draft specification in GitHub&lt;/a&gt; has the same text, so it doesn't look like it's changed there yet...&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>16/04/2019</CreatedDate>
    <ClosedDate>19/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33852</IssueID>
    <RepoID>1</RepoID>
    <Title>Regex Completion + Async Completion = Failure to trigger on `[` in VB</Title>
    <Description>**Version Used**: Visual Studio 2019 Preview 4

**Steps to Reproduce**:

1. Paste VB code:

```VB
Imports System.Text.RegularExpressions
Class C
    Sub M()
        Dim r = New Regex("$$")
    End Sub
End Class
```

2. Remove the `$$` and type `[` at that location

**Expected Behavior**: Completion should show
**Actual Behavior**: Completion does not show

**Notes**:

This is related to a couple test failures for VB, including `TestCaretPlacement` and `OnlyClasses`.

Completion does work, but just not when triggered on `[`. For example, try triggering with `\` instead. In Old Completion, it correctly triggers on `[`.

I commented out the following line, and completion started triggering on `[` (but I don't know what else would go wrong as a result):
https://github.com/dotnet/roslyn/blob/6752c0f7c544b36ff574603d43d04a8c4b217cf2/src/Features/Core/Portable/EmbeddedLanguages/RegularExpressions/RegexEmbeddedCompletionProvider.cs#L32

</Description>
    <CreatedDate>04/03/2019</CreatedDate>
    <ClosedDate>19/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34905</IssueID>
    <RepoID>1</RepoID>
    <Title>Switch on enum type nested in generic type produces LangVersion error</Title>
    <Description>I think this is related to #34678.

**Version Used**: 
master as of April 9 (commit 43f2329f0)

**Steps to Reproduce**:

1. Create a project using non-preview LangVersion
2. Write the following code
```cs
public class C&lt;T&gt;
{
    public enum E
    {
        V1, V2
    }

    public void M()
    {
        switch(default(E))
        {
            case E.V1: // error CS8511
            break;
        }
    }
}
```

**Expected Behavior**:
Builds successfully (as it does in dev15.9)

**Actual Behavior**:
```
CS8511	An expression of type 'C&lt;T&gt;.E' cannot be handled by a pattern of type 'C&lt;T&gt;.E'. Please use language version 'preview' or greater to match an open type with a constant pattern.
```
</Description>
    <CreatedDate>10/04/2019</CreatedDate>
    <ClosedDate>11/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34601</IssueID>
    <RepoID>1</RepoID>
    <Title>Async Completion - Ctrl+Space isn't filtering the list (when non-unique)</Title>
    <Description>**Version Used**: 28725.219.d16.0stg

**Steps to Reproduce**:

1. Paste C# code:

```C#
class C
{
    void Method()
    {
        Me$$
    }
}

```

2. Delete the `$$`, place your caret there, and press Ctrl+Space

**Expected Behavior**: As per 15.9, a filtered list (only `MemberwiseClone` and `Method`, and backspacing / typing further brings things back into the list).

**Actual Behavior**: The list is initially unfiltered and stays unfiltered (it's acting like Ctrl+J in that respect). But if there's a unique item at the time of Ctrl+Space, it does complete it automatically, so it's not like the two triggers are completely confused.</Description>
    <CreatedDate>29/03/2019</CreatedDate>
    <ClosedDate>04/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25529</IssueID>
    <RepoID>1</RepoID>
    <Title>Reporting "field is uninitialized" for constructor that throws an exception</Title>
    <Description>Reports: `(5,14): warning CS8618: Non-nullable field '_f' is uninitialized.`
```
using System;
class C
{
    private object _f;
    internal C()
    {
        throw new NotImplementedException();
    }
}
```</Description>
    <CreatedDate>16/03/2018</CreatedDate>
    <ClosedDate>02/04/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30022</IssueID>
    <RepoID>1</RepoID>
    <Title>Unexpected WRN_UninitializedNonNullableField warnings when ```this``` is assigned in constructor</Title>
    <Description>```
        [Fact]
        public void StructAssignThis()
        {
            var source =
@"struct S
{
#pragma warning disable 0169
    private readonly string F;
    private string[] P { get; set; }
    internal S(S s)
    {
        this = s;
    }
}";
            var comp = CreateCompilation(new[] { source, NonNullTypesTrue, NonNullTypesAttributesDefinition }, parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }
```

Observed:
```
                // (6,14): warning CS8618: Non-nullable property 'P' is uninitialized.
                //     internal S(S s)
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "S").WithArguments("property", "P").WithLocation(6, 14),
                // (6,14): warning CS8618: Non-nullable field 'F' is uninitialized.
                //     internal S(S s)
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "S").WithArguments("field", "F").WithLocation(6, 14)
```
</Description>
    <CreatedDate>19/09/2018</CreatedDate>
    <ClosedDate>20/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34237</IssueID>
    <RepoID>1</RepoID>
    <Title>[Regression] Completion gets in the way attempting to line up arguments</Title>
    <Description>This is a regression from Version 15.9.9.

**Version Used**: 
Version 16.0.0 Preview 4.2 [28711.60.d16.0]

**Steps to Reproduce**:

At $, press ENTER and then TAB:
``` C#
String.Equals("foo", "bar", $StringComparison.CurrentCulture)
```

**Expected (15.9):**

``` C#
String.Equals("foo", "bar", 
        StringComparison.CurrentCulture)
```

**Actual (16.0):** 

``` C#
String.Equals("foo", "bar", 
    StringComparisonStringComparison.CurrentCulture)
```

Here's a video of it:

![Completion3](https://user-images.githubusercontent.com/1103906/54586952-b1ba1400-4a72-11e9-98cd-d69bd47c8388.gif)</Description>
    <CreatedDate>19/03/2019</CreatedDate>
    <ClosedDate>26/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32444</IssueID>
    <RepoID>1</RepoID>
    <Title>CS8618 lines numbers are unhelpful</Title>
    <Description>_From @Spongman on January 14, 2019 23:3_

```
c:\path\file.cs(14,27,14,41): CS8618: Non-nullable property 'XYZ' is uninitialized.
```

the line number points to the line containing the property's parent `class` definition. it would be _much_ more useful if it pointed to the property definition itself.

_Copied from original issue: dotnet/csharplang#2143_</Description>
    <CreatedDate>14/01/2019</CreatedDate>
    <ClosedDate>20/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34101</IssueID>
    <RepoID>1</RepoID>
    <Title>Suppressed warning + errorlog + warnaserror -&gt; Silent failed compilation with zero exit code</Title>
    <Description>**Version Used**: 3.0.19.15604 (7d31dd6e)

**Steps to Reproduce**:

1. Create test.cs
``` C#
#pragma warning disable 1591

public class P {
    public static void Main() {}
}
```
2. `csc.exe test.cs -doc:doc.xml -errorlog:errors.json -warnaserror`

**Expected Behavior**:

Compilation succeeds, test.exe is generated.

**Actual Behavior**:

Csc.exe returns 0, but test.exe is not generated</Description>
    <CreatedDate>14/03/2019</CreatedDate>
    <ClosedDate>19/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33783</IssueID>
    <RepoID>1</RepoID>
    <Title>Different handling of unreachable code and default fallthrough in switch block</Title>
    <Description>**Version Used**: 
Visual Studio 2019 RC (csc.exe 3.0.19.12206 (ec366687))

**Steps to Reproduce**:
Compile this code (I used `csc.exe Class1.cs -target:library -langversion:7.3`):

    int Foo(bool a)
    {
        switch (a)
        {
            case true:
                return 1;
            case false:
                return 2;
            default:
                return 3;
        }
    }

**Expected Behavior**:
No warnings.

**Actual Behavior**:
You'll get warning CS0162: Unreachable code detected. This wasn't the case with Visual Studio 2017 (csc.exe 2.10.0.0 (b9fb1610)). This warning is of course promoted to an error if warnings as errors is enabled, which is how I found it. Is this a problem? I realize that analysis may have improved.

However, 2019 then suggests replacing it with:

    int Foo(bool a)
    {
        switch (a)
        {
            case true:
                return 1;
            case false:
                return 2;
            default:
        }
    }

Which now compiles without warnings. This code *fails* with Visual Studio 2017:

    CS8070: Control cannot fall out of switch from final case label ('default')
    CS0161: 'Class1.Foo(bool)': not all code paths return a value

But I am using langversion 7.3 for both. Shouldn't the same language version mean that it should compile with the same result?</Description>
    <CreatedDate>01/03/2019</CreatedDate>
    <ClosedDate>12/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27522</IssueID>
    <RepoID>1</RepoID>
    <Title>Suppression operator on L-values</Title>
    <Description>- `M(out x!);` (note this also definitely assigns to `x` through the `!`)
- `M(out (x!));`
- `M(out (RefReturning()!));`
- `x! = y;`
- `M(out string x!);`

Current implementation is to allow in `out` scenarios, but disallow in assignment scenarios.
</Description>
    <CreatedDate>06/06/2018</CreatedDate>
    <ClosedDate>05/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33744</IssueID>
    <RepoID>1</RepoID>
    <Title>16.0 Preview 4. Up and down key do not work for editor if the old completion is turned on</Title>
    <Description>1. Use VS 2019 Preview 4.
2. Turn off "Async completion" in preview features options
3. Restart VS if just turned off.
4. Open a C# solution
5. Try to navigate with Up and Down key on the source code

**Expected**
Cursor is moving up and down in the editor window

**Actual**
Cursor is not moving down. On moving up it goes to class and method dropdowns.

Regression by https://github.com/dotnet/roslyn/pull/33196</Description>
    <CreatedDate>28/02/2019</CreatedDate>
    <ClosedDate>01/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33675</IssueID>
    <RepoID>1</RepoID>
    <Title>Wrong parsing of parenthesized constant pattern expression in switch expression arm</Title>
    <Description>**Version Used**: 

master branch from feb 26

**Steps to Reproduce**:

Compile the following code:
```c#
class C {
  bool M(object o) {
    const int X = 42;
    return o switch { (X) =&gt; true, _ =&gt; false };
  }
}
```

**Expected Behavior**:

Compile fine, do constant pattern matching at runtime.

**Actual Behavior**:

&gt; CS0118: 'X' is a variable but is used like a type
&gt; CS1525: Invalid expression term '=&gt;'

cc @gafter </Description>
    <CreatedDate>25/02/2019</CreatedDate>
    <ClosedDate>11/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33626</IssueID>
    <RepoID>1</RepoID>
    <Title>async completion: eats existing code on commit</Title>
    <Description>**Version Used**: 
VS 2019 Preview 3
**Steps to Reproduce**:

1.  Create standard Console app
2. type `override` above `static void Main..` method
3. create space and press Ctrl+Space to trigger code completion
4. type `asdasdasdasdasdasd` or any random text
5. select one of code completion options and press Enter

**Expected Behavior**:
Nicely inserted new code
**Actual Behavior**:
&lt;img width="439" alt="image" src="https://user-images.githubusercontent.com/774791/53282110-7d815b00-3733-11e9-80ea-1002d7b7b96f.png"&gt;
</Description>
    <CreatedDate>23/02/2019</CreatedDate>
    <ClosedDate>06/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33407</IssueID>
    <RepoID>1</RepoID>
    <Title>Convert to struct has errors on uninitiated members</Title>
    <Description>**Version Used**: Visual studio 2019

**Steps to Reproduce**:

1. Have code

```csharp
public class Class
{
    void MyMethod()
    {
        var tuple = (3, "string");
    }

```
2. Place cursor before open parenthesis and type (Ctrl+.) to open codefixes
![image](https://user-images.githubusercontent.com/8293542/52825445-a178d880-3071-11e9-822e-47189759e04c.png)

3. Select Convert to struct

**Expected Behavior**:
Generated struct gives no errors.

**Actual Behavior**:
Generated struct gives errors on uninitialized members Item1 and Item2.
![image](https://user-images.githubusercontent.com/8293542/52825427-9160f900-3071-11e9-92e5-3ecd00e1f702.png)

Adding these declarations fixes warnings:
```
internal struct NewStruct
{
    public int Item1 { get; }
    public string Item2 { get; }
...
```

@CyrusNajmabadi Julien mentioned you might want to take a look. :)</Description>
    <CreatedDate>15/02/2019</CreatedDate>
    <ClosedDate>21/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32247</IssueID>
    <RepoID>1</RepoID>
    <Title>[Dev16]Error "Changes are not allowed while code is running" shows while ENC about VB framework app</Title>
    <Description>There are some VSO bugs / Feedback requests. Here are some of them: https://developercommunity.visualstudio.com/content/problem/410323/vs-2019-preview-11-cannot-edit-code-in-break-mode.html
https://developercommunity.visualstudio.com/content/problem/415406/edit-and-continue-is-not-working.html

**[Machine]**

OS: Windows-10-Enterprise-RS4

Product: VS Enterprise ENU d16.0stg 28405.127
 

Steps to reproduce:


1. Create a VB Console app(.Net Framework) and add code as following:
```
Sub Main()
For index = 1 To 10
Console.WriteLine("hello")
Next
End Sub
```
2. Set a BP at line which contains string "Console.WriteLine("hello")" 
3. F5
4. Press "Enter" key on the end of the line while it hit BP

**[Expected]**
It could modify code successfully.

**[Actual]**
It cannot ENC(see Capture.PNG).

Microsoft Visual Studio
Changes are not allowed while code is running.
OK   
![image](https://user-images.githubusercontent.com/5455484/50856161-c1b0cb80-133e-11e9-9ff3-b36a370aeca8.png)


 [Investigate]

1. The issue cannot repro on VB core console app.</Description>
    <CreatedDate>08/01/2019</CreatedDate>
    <ClosedDate>16/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32774</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio 2019 Preview 2 breaks Switch Case with when Statements</Title>
    <Description>**Version Used**: 
Visual Studio 2019 Preview 2

**Steps to Reproduce**:
Certain switch case statements including a when clause stopped working since updating to VS 2019 Preview 2.

The following statement will fail for every case that is not matched before the when clause:

        switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

The following exception is thrown:  
_System.InvalidCastException: Unable to cast object of type 'System.Double' to type 'IOtherObject'._

However if you have an additional case just after the when where check without a condition it works fine:  

         switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IObject x:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

I uploaded a demo project to github that includes both cases and respective tests to showcase the problem:
https://github.com/huserben/VS19_SwitchCaseWhen

You can run the tests in VS 19 Preview 1 and one will fail, while both succeed if run from VS 2017

**Expected Behavior**:
Switch Case works in any of the cases
</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>09/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32808</IssueID>
    <RepoID>1</RepoID>
    <Title>Bad code for consecutive interface type tests with a when clause in a switch</Title>
    <Description>Fixes #32774

@dotnet/roslyn-compiler May I please have a couple of reviews for this bad code fix targeting preview 3?
</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>09/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33054</IssueID>
    <RepoID>1</RepoID>
    <Title>[x64](3.0.100-preview-010184) Switch expression bug</Title>
    <Description>Hi

Looks like the new pattern matching feature broke old style switch expression

https://github.com/rds1983/StbImageSharp/blob/master/src/StbImageSharp/PngDecoder.cs#L714

Doesn't compile anymore 

```
  PngDecoder.cs(714, 38): [CS1003] Syntax error, ':' expected
  PngDecoder.cs(714, 70): [CS1002] ; expected
  PngDecoder.cs(714, 70): [CS1513] } expected
  PngDecoder.cs(718, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(774, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(793, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(842, 39): [CS1003] Syntax error, ',' expected
  PngDecoder.cs(878, 39): [CS1003] Syntax error, ',' expected
```</Description>
    <CreatedDate>01/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33208</IssueID>
    <RepoID>1</RepoID>
    <Title>Breaking: case no longer works with constant expressions</Title>
    <Description>**Version Used**: VisualStudio.16.Preview/16.0.0-pre.2.1+28529.54

**Steps to Reproduce**:
Switching on an integer variable:
`case ((2) + (2)):` and `case ((2 + 2) - 2):`
```
(3,10): error CS8370: Feature 'recursive patterns' is not available in C# 7.3. Please use language version 8.0 or greater.
(3,15): error CS1003: Chyba syntaxe; očekávána hodnota: ,
```

`case (2) | (2):` or `case ((2 &lt;&lt; 2) | 2):`
```
(3,20): error CS1026: Očekává se ).
(3,20): error CS1003: Chyba syntaxe; očekávána hodnota: :
(3,20): error CS1525: Neplatný výraz |
(3,23): error CS1002: Očekával se středník (;).
(3,23): error CS1513: Očekával se znak }.
```

All cases above work in VS 2017.

(Sorry for non-English exceptions which is probably unrelated regression in VS2019.)</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32940</IssueID>
    <RepoID>1</RepoID>
    <Title>The focus of IntelliSence is not right in  vs2019preview2 when async code completion=on</Title>
    <Description>**Version Used**: The one in vs2019 preview2

The testcase used to be crash in vs2019preview1(#31263), so not sure what happened in preview1. And works well in vs2017 15.9.5.

**Steps to Reproduce**:

1. Set Options/Environment/Preview Features/`Use asynchronous code completion in C# and Basic` to on.
2. Type `string.Equals("","",StringComparison.[cursor here, and an autocompleted char ')']` in an .cs file
3. Press arrow up/down.

**Expected Behavior**:
Switch between members of `StringComparison`, like it does in vs2017 15.9.5

**Actual Behavior**:
Switch between the overload of method `string.Equals`.</Description>
    <CreatedDate>30/01/2019</CreatedDate>
    <ClosedDate>21/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32806</IssueID>
    <RepoID>1</RepoID>
    <Title>Switch Expression Exhaustiveness needs to be conditions on langver</Title>
    <Description>```C#
namespace ConsoleApp1
{
    class Program
    {
        static int Main(string[] args)
        {
            bool? test = null;

            switch (test)
            {
                case true:
                    return 1;
                case false:
                    return 0;
                case null:
                    return -1;
            }
        }
    }
}
```

This code currently compiles in a brand-new C# project on dev16, but will not compile with an older 7.x roslyn compiler because it did not do the exhaustiveness checking that the new compiler will do. We need to condition this on langver 8.</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>29/01/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32774</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio 2019 Preview 2 breaks Switch Case with when Statements</Title>
    <Description>**Version Used**: 
Visual Studio 2019 Preview 2

**Steps to Reproduce**:
Certain switch case statements including a when clause stopped working since updating to VS 2019 Preview 2.

The following statement will fail for every case that is not matched before the when clause:

        switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

The following exception is thrown:  
_System.InvalidCastException: Unable to cast object of type 'System.Double' to type 'IOtherObject'._

However if you have an additional case just after the when where check without a condition it works fine:  

         switch (someObject)
         {
            case string x:
               return true;
            case int x:
               return true;
            case IObject x when x.SubObject != null:
               return true;
            case IObject x:
               return true;
            case IOtherObject x:
               return true;
            case double x:
               return true;
            default:
               return false;
         }

I uploaded a demo project to github that includes both cases and respective tests to showcase the problem:
https://github.com/huserben/VS19_SwitchCaseWhen

You can run the tests in VS 19 Preview 1 and one will fail, while both succeed if run from VS 2017

**Expected Behavior**:
Switch Case works in any of the cases
</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>09/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>31889</IssueID>
    <RepoID>1</RepoID>
    <Title>Range indexer on array should probably not be ref-returning</Title>
    <Description>The following works:

```C#
using System;
public class C {
    public void M(int[] arr) {
        ref int[] x = ref arr[0..2];
    }
}
```

But I'm not sure it should.</Description>
    <CreatedDate>18/12/2018</CreatedDate>
    <ClosedDate>17/01/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19034</IssueID>
    <RepoID>1</RepoID>
    <Title>Incomplete member name in errors CS0541 and CS0065 </Title>
    <Description>```
public interface I2 { }

public interface I1
{
    abstract event System.Action I2.P10;
}
```

Observed:
Error	CS0541	'I1.': explicit interface declaration can only be declared in a class or struct	
Error	CS0065	'I1.': event property must have both add and remove accessors	

Expected:
Error	CS0541	'I1.P10': explicit interface declaration can only be declared in a class or struct	
Error	CS0065	'I1.P10': event property must have both add and remove accessors	</Description>
    <CreatedDate>27/04/2017</CreatedDate>
    <ClosedDate>14/01/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30661</IssueID>
    <RepoID>1</RepoID>
    <Title>Rename tracking crashed</Title>
    <Description>The initial blame of the null reference is here:

https://github.com/dotnet/roslyn/blob/5a8dabf92d3abb17b47b9c54d33d93313dc8d725/src/EditorFeatures/Core/Implementation/RenameTracking/RenameTrackingTaggerProvider.StateMachine.cs#L123

Although as is often the case, it might be a few lines earlier or later since I haven't done a careful analysis.

Dump is available at `\\mlangfs1\public\jasonmal\Dumps\Roslyn\30661\`</Description>
    <CreatedDate>23/10/2018</CreatedDate>
    <ClosedDate>22/12/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28634</IssueID>
    <RepoID>1</RepoID>
    <Title>Some switch changes in recursive patterns changes flow graph produced</Title>
    <Description>In the recursive patterns branch, some flow graphs produced for switch statements is different. The differences need to be investigated. The affected tests are marked with this bug ID.</Description>
    <CreatedDate>18/07/2018</CreatedDate>
    <ClosedDate>28/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30561</IssueID>
    <RepoID>1</RepoID>
    <Title>Variable should be nullable outside try block if assigned nullable value inside try block</Title>
    <Description>`s.Length` should result in a warning:
```c#
[System.Runtime.CompilerServices.NonNullTypes]
class C
{
    static void MayThrow()
    {
        throw null;
    }
    static int F()
    {
        string? s = "";
        try
        {
            s = null;
            MayThrow();
            s = "";
        }
        catch (System.Exception)
        {
        }
        return s.Length; // warning: possibly null
    }
}
```
Reported by @gafter.</Description>
    <CreatedDate>17/10/2018</CreatedDate>
    <ClosedDate>13/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30429</IssueID>
    <RepoID>1</RepoID>
    <Title>Project.FilePath is null for Project class instance created for Word 2013 or 2016 VSTO AddIn</Title>
    <Description>**Version Used**: 
15.8.6

**Steps to Reproduce**:

1. Create new Word 2013 or 2016 VSTO AddIn c# project
2. Obtain roslyn Project class instance for this newly created project

**Expected Behavior**:
Project.FilePath should contain correct data

**Actual Behavior**:
Project.FilePath is null</Description>
    <CreatedDate>10/10/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>1233</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable turning a method into an async method or iterator in VB</Title>
    <Description>Enables an edit that updates a regular method to an async method or an iterator in VB. All work has been done already as a part of C# and this PR simply removes RudeEdit checks.
</Description>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>12/03/2015</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>1240</IssueID>
    <RepoID>1</RepoID>
    <Title>Formatter inserts spaces instead of tabs after incomplete if</Title>
    <Description>Source (entire document, with tabs rather than spaces):

``` C#
class C {
    C() {
        if ()
    }
```

Formatting the document will replace the tab in the last line with spaces.
</Description>
    <CreatedDate>13/03/2015</CreatedDate>
    <ClosedDate>23/04/2015</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>1256</IssueID>
    <RepoID>1</RepoID>
    <Title>cleanup progression graph query creation</Title>
    <Description>don't display roslyn queries on non-roslyn nodes and also only display the
'Contains' query where it makes sense.

Fixes #1255.
</Description>
    <CreatedDate>13/03/2015</CreatedDate>
    <ClosedDate>18/03/2015</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33555</IssueID>
    <RepoID>1</RepoID>
    <Title>Object Browser hangs</Title>
    <Description>Pressing &amp;quot;Go to definition&amp;quot; (F12) on a method or class that is not in the project opens up the Object Browser, but it opens synchronously, blocking all other operations, and it takes up to 30 seconds the first time it opens.

So this issue consists of 2 problems:
1: The load time of the Object Browser is too high, and should hopefully be lowered.
2: The Object Browser should load asynchronously, not causing Visual Studio to hang.

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/461895/object-browser-hangs.html
VSTS ticketId: 796040_
_These are the original issue comments:_

Visual Studio Feedback System on 2/19/2019, 02:04 AM (2 days ago): &lt;p&gt;We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.&lt;/p&gt;

Jinu Joseph [MSFT] on 2/19/2019, 07:53 PM (35 hours ago): &lt;p&gt;Thank you for providing feedback, and we're sorry to hear about your experience . Based on your description so far, it sounds like you are experiencing a problem which is historically hard to diagnose and resolve using the normal &amp;quot;steps to reproduce&amp;quot;. We created a set of instructions for providing additional information which will help us track down the true source of the problems. (&lt;a target="_blank"&gt; https://github.com/dotnet/roslyn/wiki/Reporting-Visual-Studio-crashes-and-performance-issues#performance-issues &lt;/a&gt;)&lt;/p&gt;&lt;p&gt;We look forward to hearing from you&lt;/p&gt;

Bendik Nesbo on 2/20/2019, 02:41 AM (29 hours ago): attaching trace here.&lt;br&gt;Note: This time it was not as drastic as other times. Possibly cached? Sometimes it takes over 20 seconds for the Object Browser to load.
Visual Studio Feedback System on 2/21/2019, 03:38 AM (4 hours ago): &lt;p&gt;This issue is currently being investigated. Our team will get back to you if either more information is needed, a workaround is available, or the issue is resolved.&lt;/p&gt;

_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>21/02/2019</CreatedDate>
    <ClosedDate>22/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30543</IssueID>
    <RepoID>1</RepoID>
    <Title>Delete dead comment in MethodTypeInference.cs</Title>
    <Description>The following comment in `MethodTypeInference.cs` is obsolete - it doesn't refer to anything the code does now or ever will do in the future.

``` c#
            // If the argument is a TYPEORNAMESPACEERROR and the pSource is an
            // error type, then we want to set it to the generic error type 
            // that has no name text. This is because of the following scenario:
            //
            // void M&lt;T&gt;(T t) { }
            // void Goo()
            // {
            //     UnknownType t;
            //     M(t);
            //     M(undefinedVariable);
            // }
            //
            // In the first call to M, we'll have an EXPRLOCAL with an error type,
            // which is correct - we want the parameter help to display that we've
            // got an inferred type of UnknownType, which is an error type since 
            // its undefined.
            //
            // However, for the M in the second call, we DON'T want to display parameter
            // help that gives undefinedVariable as the type parameter for T, because
            // there is no parameter of that name, let alone that type. This appears
            // as an EXPRTYPEORNAMESPACEERROR with an ErrorType. We create a new error sym
            // without the type name.

            // UNDONE: if (pExpr-&gt;isTYPEORNAMESPACEERROR() &amp;&amp; pSource-&gt;IsErrorType())
            // UNDONE:{
            // UNDONE:    pSource = GetTypeManager().GetErrorSym();
            // UNDONE:}
```
</Description>
    <CreatedDate>16/10/2018</CreatedDate>
    <ClosedDate>22/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30439</IssueID>
    <RepoID>1</RepoID>
    <Title>Compilers should normalize NaNs produced for 0.0/0.0 for determinism</Title>
    <Description>Apparently some CLRs have issues such that `0.0 / 0.0` produces different results (specifically, NaNs with different bit patterns) on different platforms.  To work around this, Roslyn compilers should normalize NaNs so that we produce the same result on all platforms.

See also https://github.com/dotnet/corefx/pull/32741 which adds tests for possibly problematic runtimes.
</Description>
    <CreatedDate>10/10/2018</CreatedDate>
    <ClosedDate>29/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29371</IssueID>
    <RepoID>1</RepoID>
    <Title>`in` arguments crash the compiler when temp stores are required</Title>
    <Description>When trying to build one of my solution's code libraries, csc.exe exits with errorlevel 0x‭80131623‬, and 'dotnet build shows these stack traces:

```
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error : FailFast: System.InvalidOperationException: Unexpected value '4' of type 'Microsoft.CodeAnalysis.RefKind' [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.StoreToTemp(BoundExpression argument, BoundAssignmentOperator&amp;amp; store, RefKind refKind, SynthesizedLocalKind kind, SyntaxNode syntaxOpt) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.BuildStoresToTemps(Boolean expanded, ImmutableArray`1 argsToParamsOpt, ImmutableArray`1 parameters, ImmutableArray`1 argumentRefKinds, ImmutableArray`1 rewrittenArguments, Boolean forceLambdaSpilling, BoundExpression[] arguments, ArrayBuilder`1 refKinds, ArrayBuilder`1 storesToTemps) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeArguments(SyntaxNode syntax, ImmutableArray`1 rewrittenArguments, Symbol methodOrIndexer, MethodSymbol optionalParametersMethod, Boolean expanded, ImmutableArray`1 argsToParamsOpt, ImmutableArray`1&amp;amp; argumentRefKindsOpt, ImmutableArray`1&amp;amp; temps, Boolean invokedAsExtensionMethod, ThreeState enableCallerInfo) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitObjectCreationExpression(BoundObjectCreationExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression.Accept(BoundTreeVisitor visitor) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp;amp; recursionDepth, BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionImpl(BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitObjectCreationExpression(BoundObjectCreationExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression.Accept(BoundTreeVisitor visitor) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp;amp; recursionDepth, BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionImpl(BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitCall(BoundCall node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
C:\Program Files\dotnet\sdk\2.1.400-preview-009171\Roslyn\Microsoft.CSharp.Core.targets(52,5): error :    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp;amp; recursionDepth, BoundExpression node) [E:\projects\testframework-wow\src\Blizzard.TestFramework.WoW\Blizzard.TestFramework.WoW.csproj]
...
```

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/306848/unexpected-value-4-of-type-microsoftcodeanalysisre.html
VSTS ticketId: 659932_
_These are the original issue comments:_

Daniel Hobbs on 8/15/2018, 08:47 AM (2 days ago): I had a similar problem. (Unexpected value '4' of type 'Microsoft.CodeAnalysis.RefKind') I think it may be due to lowering with 'in'. I'm on VS 15.8. Here is a repro.

```C#
public readonly struct S
{        
    private static readonly S s_Default = default;        
    public static ref readonly S Default =&gt; ref s_Default;
}    
public class C
{
    public C(in S s, int i = 0)\{ }    
}    
public static class Foo 
{        
    // Crashes CSC - "csc.exe" exited with code -2146232797        
    public static C Instance { get; } = new C(s: in S.Default); // use 'in' and omit optional arg    
}
```


_These are the original issue solutions:_
(no solutions)</Description>
    <CreatedDate>17/08/2018</CreatedDate>
    <ClosedDate>09/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29145</IssueID>
    <RepoID>1</RepoID>
    <Title>EnC allows adding explicit interface implementation methods</Title>
    <Description>
[ENCMetadataCrashTest.zip](https://github.com/dotnet/roslyn/files/2267748/ENCMetadataCrashTest.zip)

**Version Used**: 
VS 15.8 Preview

**Steps to Reproduce**:

See attached project, the issue repros with a subclass where it implements interfaces defined in another module, then adds explicit implementations of methods with the same signature from two different interfaces.

1.	Set a breakpoint in Main
2.	Make sure string IConflict.Get() and string IConflict2.Get() are commented out in SubClass
3.	Start debugging
4.	Uncomment string IConflict.Get() 
5.	Step once
6.	Uncomment string IConflict2.Get()
7.	Step once more
8.	AV in RegMeta::PreSave

**Expected Behavior**:
Rude edit is reported and user cannot proceed debugging

**Actual Behavior**:
VS crashes</Description>
    <CreatedDate>07/08/2018</CreatedDate>
    <ClosedDate>29/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29481</IssueID>
    <RepoID>1</RepoID>
    <Title>Finally block belonging to unexecuted try runs anyway</Title>
    <Description>_From @jakobbotsch on August 23, 2018 12:50_

The following program prints something in release even though it shouldn't:
```csharp
// Debug: Prints 0 lines
// Release: Prints 1 line
using System;

public class Program
{
    public static void Main()
    {
        try
        {
            bool b = false;
            if (b)
            {
                try
                {
                    return;
                }
                finally
                {
                    Console.WriteLine("Prints");
                }
            }
            else
            {
                return;
            }
        }
        finally
        {
            GC.KeepAlive(null);
        }
    }
}
```

Disassembly is:
```asm
; Assembly listing for method Program:Main()
; Emitting BLENDED_CODE for X64 CPU with AVX
; optimized code
; rbp based frame
; fully interruptible
; Final local variable assignments
;
;  V00 OutArgs      [V00    ] (  1,  1   )  lclBlk (32) [rsp+0x00]
;  V01 PSPSym       [V01    ] (  1,  1   )    long  -&gt;  [rbp-0x10]   do-not-enreg[X] addr-exposed
;
; Lcl frame size = 48

G_M5092_IG01:
       55                   push     rbp
       4883EC30             sub      rsp, 48
       488D6C2430           lea      rbp, [rsp+30H]
       488965F0             mov      qword ptr [rbp-10H], rsp

G_M5092_IG02:
       48B968302ED59B010000 mov      rcx, 0x19BD52E3068
       488B09               mov      rcx, gword ptr [rcx]
       E850FCFFFF           call     System.Console:WriteLine(ref)
       90                   nop

G_M5092_IG03:
       33C9                 xor      rcx, rcx
       E8B85B1E5E           call     System.GC:KeepAlive(ref)
       90                   nop

G_M5092_IG04:
       488D6500             lea      rsp, [rbp]
       5D                   pop      rbp
       C3                   ret

G_M5092_IG05:
       55                   push     rbp
       4883EC30             sub      rsp, 48
       488B6920             mov      rbp, qword ptr [rcx+32]
       48896C2420           mov      qword ptr [rsp+20H], rbp
       488D6D30             lea      rbp, [rbp+30H]

G_M5092_IG06:
       33C9                 xor      rcx, rcx
       E8985B1E5E           call     System.GC:KeepAlive(ref)
       90                   nop

G_M5092_IG07:
       4883C430             add      rsp, 48
       5D                   pop      rbp
       C3                   ret

; Total bytes of code 79, prolog size 14 for method Program:Main()
; ============================================================
```

_Copied from original issue: dotnet/coreclr#19627_</Description>
    <CreatedDate>23/08/2018</CreatedDate>
    <ClosedDate>05/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28862</IssueID>
    <RepoID>1</RepoID>
    <Title>LambdaSymbol parameter with Locations[0] == null</Title>
    <Description>Compiling the following, the `SourceParameterSymbol` for the  `LambdaSymbol` `y != null` has `Locations.Length == 1` and `Locations[0] == null`. `Locations` should contain non-`null` values only.
```c#
using System.Linq;
class C
{
    static string F(object o) =&gt; throw null;
    static void G(object[] c)
    {
        var z = from x in c
            let y = F(x)
            where y != null
            select y;
    }
}
```</Description>
    <CreatedDate>26/07/2018</CreatedDate>
    <ClosedDate>12/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26457</IssueID>
    <RepoID>1</RepoID>
    <Title>VS crashes on code that uses ref assignments</Title>
    <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017 Preview (2)
Version 15.7.0 Preview 5.0
VisualStudio.15.Preview/15.7.0-pre.5.0+27625.0
Microsoft .NET Framework
Version 4.7.02556

**Steps to Reproduce**:

Paste the following code into VS:
```cs
class C
{
  public void M(ref int r1)
  {
    int x = 0;
    ref int rx = ref x;
    rx = ((rx =)) = ref x;
  }
}
```

**Expected Behavior**:

VS doesn't crash

**Actual Behavior**:

VS becomes unresponsive for a few seconds and then crashes.</Description>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>27/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28300</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge dev15.8-preview3-vs-deps to master-vs-deps</Title>
    <Description>
This is an automatically generated pull request from dev15.8-preview3-vs-deps into master-vs-deps.

``` bash
git fetch --all
git checkout merges/dev15.8-preview3-vs-deps-to-master-vs-deps
git reset --hard upstream/master-vs-deps
git merge upstream/dev15.8-preview3-vs-deps
# Fix merge conflicts
git commit
git push merges/dev15.8-preview3-vs-deps-to-master-vs-deps --force
```

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
    <CreatedDate>05/07/2018</CreatedDate>
    <ClosedDate>09/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27049</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler should report base method calls in ref struct declarations</Title>
    <Description>**Version Used**: 
Visual Studio 2017 d15.7+

**Steps to Reproduce**:

1. Create a C# project
2. Add a `ref struct` declaration, override any of the base methods and inside the body, call base method. for example:
```C#
public readonly ref struct S
{
    public override bool Equals(object obj) =&gt; base.Equals(obj);

    public override int GetHashCode() =&gt; base.GetHashCode();

    public override string ToString() =&gt; base.ToString();
}
```
3. Call any of these methods in a context, for example:
```C#
public static void Main(string[] args)
{
    S s = default;
    s.GetHashCode();
}
```

**Expected Behavior**:
Compiler should report the usage of the base method invocations inside the `ref struct`, issue a warning or an error to disallow the invocation of base methods from `System.Object`.

**Actual Behavior**:
You will get a runtime error: `System.InvalidProgramException`: Cannot create boxed by-ref like object. 

</Description>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>07/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26028</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion failure in PreciseAbstractFlowPass: "last comes before first"</Title>
    <Description>1. Checkout master &amp; run a debug build of VisualStudioSetup
2. Paste the following code &amp; put cursor after 'x':
```c#
class C
{
    void M()
    {
        foreach (var x
    }
}
```

This is what I get:
![image](https://user-images.githubusercontent.com/11444821/38473592-b270d7c0-3b92-11e8-9c2f-7431cddfb886.png)
</Description>
    <CreatedDate>08/04/2018</CreatedDate>
    <ClosedDate>16/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19845</IssueID>
    <RepoID>1</RepoID>
    <Title>ExtractMethodCodeRefactoringProvider throws on property reference in initializer</Title>
    <Description>**Version Used**:  15.2 (26430.6) Release

```C#
class C {
    static int X { get; set; }
    int Y = X;
}
```

Select the second `X` and press Ctrl+Dot.

````
System.NullReferenceException : Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver,PropertySymbol propertySymbol,Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth,BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion,DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation,Symbol member,BoundNode node,Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.AnalyzeReadWrite()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Captured()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```</Description>
    <CreatedDate>29/05/2017</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27969</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash in DataFlowAnalysis</Title>
    <Description>**Version Used**: 
Microsoft.CodeAnalysis v2.8.2

**Steps to Reproduce**:
Consider the next program, which runs data flow analysis on lambda expression `x =&gt; true`:
```csharp
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RoslynDataFlowCrash
{
    class Program
    {
        static void Main()
        {
            const string source = @"
class C
{
    object P { get; } = Create(nameof(P), x =&gt; true);

    static object Create(string name, Func&lt;string, bool&gt; f) =&gt; throw null;
}
";

            SyntaxTree tree = CSharpSyntaxTree.ParseText(source);
            var compilation = CSharpCompilation.Create("test.dll", new[] { tree });
            var model = compilation.GetSemanticModel(tree);

            SimpleLambdaExpressionSyntax lambdaSyntax = tree.GetRoot().DescendantNodes().OfType&lt;SimpleLambdaExpressionSyntax&gt;().First();

            DataFlowAnalysis dataFlowAnalysis = model.AnalyzeDataFlow(lambdaSyntax.Body);

            bool succeeded = dataFlowAnalysis.Succeeded; // NullReferenceException
        }
    }
}
```

**Expected Behavior**:
No exception.

**Actual Behavior**:
`NullReferenceException`. Full stack trace:
```
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=Microsoft.CodeAnalysis.CSharp
  StackTrace:
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundExpression receiver, PropertySymbol propertySymbol, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.Binder.AccessingAutoPropertyFromConstructor(BoundPropertyAccess propertyAccess, Symbol fromMember)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitPropertyAccess(BoundPropertyAccess node)
   at Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitNameOfOperator(BoundNameOfOperator node)
   at Microsoft.CodeAnalysis.CSharp.BoundNameOfOperator.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, Boolean convertInsufficientExecutionStackExceptionToCancelledByStackGuardException)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_UnassignedVariables()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_DataFlowsIn()
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_Succeeded()
   at RoslynDataFlowCrash.Program.Main() in E:\Bart\Source\Visual Studio 2017\RoslynDataFlowCrash\RoslynDataFlowCrash\Program.cs:line 29
```</Description>
    <CreatedDate>18/06/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28238</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio crashed when type { object = ref</Title>
    <Description>**Version Used**: 
15.7.4

**Steps to Reproduce**:
open any method, or C# interactive and start writing:
var temp = new { object = ref

**Expected Behavior**:
Error that "object" appears.

**Actual Behavior**:
Visual Studio crashed
</Description>
    <CreatedDate>02/07/2018</CreatedDate>
    <ClosedDate>07/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28118</IssueID>
    <RepoID>1</RepoID>
    <Title>Ref-assigning to array elements should produce an error</Title>
    <Description>Fixes #28087 </Description>
    <CreatedDate>26/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27220</IssueID>
    <RepoID>1</RepoID>
    <Title>Map 'none' in .editorconfig to ReportDiagnostic.Suppress</Title>
    <Description>Fixes #26972 

:memo: This is an intentionally constrained change.

* Each commit is a unit of work (single topic, complete, all tests passing). I **strongly encourage** reviewing each commit separately after a quick look to understand the overall direction.
* All *known* breaking (or possibly breaking) changes, except for those described in the design for #26972, are called out in comments.
* The inconsistent handling of `DiagnosticSeverity.Hidden` is preserved for all current diagnostics. Given the new ability to differentiate between `ReportDiagnostic.Hidden` and `ReportDiagnostic.Suppress`, we will likely want to revisit this behavior and make all diagnostics consistent.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>11/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27720</IssueID>
    <RepoID>1</RepoID>
    <Title>build -pack does not work</Title>
    <Description>In master branch, in a clean repository, repro as follows:

``` none
cd Roslyn
restore
build -pack
```

![image](https://user-images.githubusercontent.com/3804346/41251846-0d794940-6d70-11e8-8674-fa170918645b.png)

This is blocking our attempt to diagnose #27523 

</Description>
    <CreatedDate>11/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28216</IssueID>
    <RepoID>1</RepoID>
    <Title>Create combined tests for diagnostic/refactoring pairs</Title>
    <Description>Currently analyzers and refactorings are tested separately, which leaves the test suite unable to detect certain regressions. See the root cause analysis in #28217 for details.</Description>
    <CreatedDate>29/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28117</IssueID>
    <RepoID>1</RepoID>
    <Title>Ref-assigning to a non-ref parameter should be an error</Title>
    <Description>```csharp
public class C {
    void M(int a, ref int b) {
        int local = 0;
        
        a = ref b;           // no error
        local = ref b;       // CS8373: The left-hand side of a ref assignment must be a ref local or parameter.
    }
}
```</Description>
    <CreatedDate>26/06/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27831</IssueID>
    <RepoID>1</RepoID>
    <Title>csc.exe FailFast exception on combination of implicit array cast, `await` and `in` keyword</Title>
    <Description>**Version Used**: 
Microsoft.Net.Compilers 2.8.2

**Steps to Reproduce**:

1. Checkout https://github.com/mycroes/NetStandardConversionCrash (or add the following code:)
```
public async Task A(object[] items)
{
    C(items, await B());
}

private async Task&lt;int&gt; B() =&gt; 0;

private void C(in IEnumerable&lt;object&gt; items, in int length)
{
}
```
2. Try to compile

**Expected Behavior**:
Successful compilation.

**Actual Behavior**:
```
Error	MSB6006	"csc.exe" exited with code -2146232797.	NetStandardConversionCrash	C:\Users\michaelc\.nuget\packages\microsoft.net.compilers\2.8.2\tools\Microsoft.CSharp.Core.targets	52	
```

Further notes:
When the `in` keyword is removed from `items` in C, the crash is gone. When the `length` passed is a constant in `A`, the crash is gone.</Description>
    <CreatedDate>14/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28087</IssueID>
    <RepoID>1</RepoID>
    <Title>Exception: Unexpected value 'ArrayAccess' In BoundExpressionExtensions.GetRefKind()</Title>
    <Description>Examples of the crash:

```csharp
public class C {
    public void M() {
        uint[] ar = new uint[10];
        ar[pos] = ref ar[0];
    }
}
```

And

```csharp
public class C {
    public void M() {
        IntPtr[] a = new IntPtr[5];
        Byte[,] b = new byte[10, 10];
        a[0] = ref b[0, 0];
    }
}
```</Description>
    <CreatedDate>23/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26956</IssueID>
    <RepoID>1</RepoID>
    <Title>VenusCommandFilter/AbstractVsTextViewFilter uses incorrect buffer whe…</Title>
    <Description>### Customer scenario

**Steps to Reproduce**:

1.  Try to debug a CSHTML file with some C# code
2.  Hover over on a variable with C# object.

**Expected Behavior**:
See object type description and value.

**Actual Behavior**:
See object type description but no value.

### Bugs this fixes
Partially fixes: https://github.com/dotnet/roslyn/issues/26873

### Workarounds, if any
No

### Risk
Low

### Performance impact
None

### Is this a regression from a previous update?
No

### Root cause analysis
This error was there for a long time but as we heard appeared only in 15.7 when VS changed its approach to communication with Roslyn for Quick Info Data Tips. Likely, it previously used other approach.

The root cause that this code is on the boundary between Roslyn and VS and we do not have enough unit test coverage for this.

### How was the bug found?
Customer feedback (VS Feedback)</Description>
    <CreatedDate>18/05/2018</CreatedDate>
    <ClosedDate>18/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26873</IssueID>
    <RepoID>1</RepoID>
    <Title>VenusCommandFilter/AbstractVsTextViewFilter uses incorrect buffer when providing values on hover over for cshtml files on debugging</Title>
    <Description>**Steps to Reproduce**:

1.  Try to debug a CSHTML file with some C# code
2.  Hover over on a variable with C# object.

**Expected Behavior**:
See object type description and value.

**Actual Behavior**:
See object type description but no value.

**Analysis**
There could be some problems on VS side but Roslyn attempts to use an incorrect buffer to search for span.

1. [VenusCommandFilter calls](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/Venus/VenusCommandFilter.cs,93) AbstractVsTextViewFilter.GetDataTipTextImpl

2.  Then, [it gets](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/AbstractVsTextViewFilter%25602.cs,56) a buffer from caret
`var subjectBuffer = WpfTextView.GetBufferContainingCaret();`

3. However, the caret can be in HTML but the item hovered over can be in C#. Then, the buffer is null. And we stop search for the span.</Description>
    <CreatedDate>15/05/2018</CreatedDate>
    <ClosedDate>18/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27945</IssueID>
    <RepoID>1</RepoID>
    <Title>Investigate PR 27424 Breaking change around unfixed expressions</Title>
    <Description>PR #27424 caused a build break for the following scenario:

```csharp
using System;
public unsafe sealed class PinnedStreamReader
{
    public unsafe byte* GetPointer(int position)
    {
        return (&amp;bufferStart[position]);
    }
 	
    byte* bufferStart;
}
```

It now produced: `error CS0212: You can only take the address of an unfixed expression inside of a fixed statement initializer`

PR #27944 reverted it in master. We should investigate this and bring back the fix, without breaking additional scenarios.</Description>
    <CreatedDate>17/06/2018</CreatedDate>
    <ClosedDate>27/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27424</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixed error messages around fixed fields</Title>
    <Description>Fixes #26688 
Fixes #26743 </Description>
    <CreatedDate>04/06/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27772</IssueID>
    <RepoID>1</RepoID>
    <Title>GetInvocationEscapeScope() issue allows accessing invalid stack locations</Title>
    <Description>From @TessenR in #27218

Compile and run the following code in debug to get access violation exception:
```cs
using System;
class C
{
  static void Main(string[] args)
  {
    ref long x = ref M(default); // get a reference to the stack which will be used for the next method
    M2(ref x); // break things
    Console.ReadKey();
  }

  public static ref long M(S reciever)
  {
    Span&lt;long&gt; ls = stackalloc long[0]; // change the length of this stackalloc to move the resulting pointer and break different things
    long x = 0;
    ref var y = ref x;
    {
      ref var z = ref reciever.M(ref y);
      return ref z;
    }
  }

  static void M2(ref long q)
  {
    Span&lt;long&gt; span = stackalloc long[50];
    var element = span[0]; // it was ok
    q = -1; // break things
    element = span[0]; // and not it's broken:
                       // System.AccessViolationException: 'Attempted to read or write protected memory. This is often an indication that other memory is corrupt.'
  }
}

ref struct S
{
  public ref long M(ref long x) =&gt; ref x;
}
```

This looks like a problem in `GetInvocationEscapeScope`
http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,e627ff4c04c0ce8a


```cs
            // check receiver if ref-like
            if (receiverOpt?.Type?.IsByRefLikeType == true)
            {
                return GetValEscape(receiverOpt, scopeOfTheContainingExpression);
            }
 
            return escapeScope;
```

If  the receiver is ref-like and the code did not return earlier (that's why an additional scope is required in the example above) the method completely ignores arguments' aggregated escape scope and just returns the receiver's value escape scope which is 'external scope' in this case.</Description>
    <CreatedDate>12/06/2018</CreatedDate>
    <ClosedDate>02/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27357</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect and inconsistent error for mismatching byref arguments' escape scopes</Title>
    <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017 
Version 15.7.2
VisualStudio.15.Release/15.7.2+27703.2018
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

```cs
using System;

static class C
{
  static void M(Span&lt;int&gt; s1)
  {
    Span&lt;int&gt; s2 = stackalloc int[10];
    M(s2, s1); // no errors here
    M(s2, in s1); // errors
  }

  public static void M(Span&lt;int&gt; x, in Span&lt;int&gt; y)
  {
  }
}
```

**Expected Behavior**:
Either errors for both invocations or for neither of them

**Actual Behavior**:
Errors reported only for the second invocation.
```
Error CS8350: This combination of arguments to 'C.M(Span&lt;int&gt;, in Span&lt;int&gt;)' is disallowed because it may expose variables referenced by parameter 'x' outside of their declaration scope
Error CS8352: Cannot use local 's2' in this context because it may expose referenced variables outside of their declaration scope
```

**Notes**
These errors should be reported either for both invocations or for neither of them since these calls are equivalent.
I personally think that this error should not be reported for `in` arguments at all because possible byvalue leaks to `ref`/`out` arguments are already reported regardless of `in` arguments and their byref assignments will be limited to the callee.
</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>28/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27874</IssueID>
    <RepoID>1</RepoID>
    <Title>Returning ref-like ref parameter types by ref should be allowed</Title>
    <Description>From @tessenr in #27357

Similar problem exists with parameters' ref escape scopes:
```cs
class C
{
  static ref Span&lt;int&gt; M1(ref Span&lt;int&gt; x)
  {
    ref Span&lt;int&gt; q = ref x;
    return ref q; // error cannot be returned by reference
  }

  static ref Span&lt;int&gt; M2(ref Span&lt;int&gt; x)
  {
    return ref x; // OK
  }
}
```

In this case it's caused by discrepancy between [GetRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,604613d82bb46358) and  [CheckParameterRefEscape](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder.ValueChecks.cs,376ab6d77b1940ea) methods' logic

`GetRefEscape` defines parameters' with escape scope as `TopLevelScope` for `ByRefLike` types
```cs
                    // byval parameters can escape to method's top level.
                    // others can be escape further, unless they are ref-like.
                    // NOTE: "method" here means nearest containing method, lambda or nested method
                    return parameter.RefKind == RefKind.None || parameter.Type?.IsByRefLikeType == true ?
                        Binder.TopLevelScope :
                        Binder.ExternalScope;
```

`CheckParameterRefEscape` on the other hand allows `ref/out/in` parameters to escape to any scope regardless of whether they are `ByRefLike` or not:
```cs
        private static bool CheckParameterRefEscape(SyntaxNode node, BoundParameter parameter, uint escapeTo, bool checkingReceiver, DiagnosticBag diagnostics)
        {
            ParameterSymbol parameterSymbol = parameter.ParameterSymbol;
 
            // byval parameters can escape to method's top level.
            // others can be escape further, unless they are ref-like.
            if (escapeTo == Binder.ExternalScope &amp;&amp; parameterSymbol.RefKind == RefKind.None)
            {
                if (checkingReceiver)
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter2, parameter.Syntax, parameterSymbol.Name);
                }
                else
                {
                    Error(diagnostics, ErrorCode.ERR_RefReturnParameter, node, parameterSymbol.Name);
                }
                return false;
            }
 
            // can ref-escape to any scope otherwise
            return true;
        }
```

I believe that these two methods were intended to be consistent and have similar logic.</Description>
    <CreatedDate>14/06/2018</CreatedDate>
    <ClosedDate>28/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27972</IssueID>
    <RepoID>1</RepoID>
    <Title>Escape scope errors are not consistent for different parameter types</Title>
    <Description>Escape scope errors are not consistent for different parameter types. Example:

```csharp
class C
{
    void M(ref int arg)
    {
        int local = default;
        arg = ref local;   // error CS8374: Cannot ref-assign 'local' to 'arg' because 'local' has a narrower escape scope than 'arg'.

    }
    
    void M(ref string arg)
    {
        string local = default;
        arg = ref local;   // error CS8374: Cannot ref-assign 'local' to 'arg' because 'local' has a narrower escape scope than 'arg'.
    }
    
    void M(ref S arg)
    {
        S local = default;
        arg = ref local;   // No errors
    }
}

ref struct S { }
```</Description>
    <CreatedDate>19/06/2018</CreatedDate>
    <ClosedDate>28/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18727</IssueID>
    <RepoID>1</RepoID>
    <Title>Confusing error message when using a var pattern in switch/case with pointer input</Title>
    <Description>**Version Used**:  2.1.0.61520

**Steps to Reproduce**:

```csharp
using System;

class Test
{
    unsafe static void Main()
    {
        fixed (char *x = "hello")
        {
            switch (x)
            {
                case var y: break;
            }
        }
    }
}
```

**Expected Behavior**:

An error message that helps the user understand what's wrong.

**Actual Behavior**:

&gt; Test.cs(11,22): error CS0244: Neither 'is' nor 'as' is valid on pointer types

This is confusing (if you don't happen to be thinking about patterns in general) as the code doesn't contain an `is` or `as` operator.

I can't immediately think of any pattern match that would be valid for pointer types, so perhaps it would be clearer to make that the error message, even for `is` / `as` operators? ("Pattern matching is not valid on pointer types".) Of course, it's possible that I've misunderstood and there *are* patterns that match pointers, or will be in the future...</Description>
    <CreatedDate>15/04/2017</CreatedDate>
    <ClosedDate>18/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27218</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler allows code to ref return a reference to the current method's stack</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017 
Version 15.7.2
VisualStudio.15.Release/15.7.2+27703.2018
Microsoft .NET Framework
Version 4.7.03056

**Steps to Reproduce**:

Compile and run the following code:
```cs
using System;
class C
{
  static void Main(string[] args)
  {
    ref int x = ref M(); // get a reference to the stack which will be used for the next method
    M2(ref x); // break things
    Console.ReadKey();
  }

  static ref int M()
  {
    Span&lt;int&gt; outer = stackalloc int[100];
    if (outer is Span&lt;int&gt; inner) // copy stackalloc span to a pattern variable
    {
      return ref inner[50]; // return a reference to the current method's stack
    }

    throw null;
  }

  static void M2(ref int q)
  {
    q = -1;
    Console.WriteLine(q); // prints '-1'

    Span&lt;long&gt; span = stackalloc long[50]; // allocate something on the new stack

    Console.WriteLine(q); // prints '0', stackalloc zero-ed the memory

    long sum = 0;
    foreach(var x in span)
      sum+=x;
    Console.WriteLine(sum); // prints '0', all elements of stackalloc are zero

    q = -1; // here we actually write to the memory allocated by 'stackalloc'

    sum = 0;
    foreach(var x in span)
      sum+=x;
    Console.WriteLine(sum); // prints '4294967295', one of the element was set to '0xFFFFFFFF' and reinterpreted as long
  }
}
```
**Expected Behavior**:
Compiler error on the line `return ref inner[50]`
```Error CS8352 Cannot use local 'inner' in this context because it may expose referenced variables outside of their declaration scope```

**Actual Behavior**:
the code prints
```
-1
0
0
4294967295
```

you could break things in a more interesting way if you return an odd element of `stackalloc int[]` from the first method. E.g. returning the 25th element will print `-4294967296` instead.

</Description>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26910</IssueID>
    <RepoID>1</RepoID>
    <Title>fix for CLR_EXCEPTION_System.NullReferenceException_80004003_Microsoft.VisualStudio.InteractiveWindow.dll (master)</Title>
    <Description>This is a copy of https://github.com/dotnet/roslyn/pull/26770 but targeting `master` instead of `dev15.7.x`

### Customer scenario

Visual Studio closes or restarts and attempts to close and restart Roslyn which attempts to do the same with Interactive Host. Interactive Host attempts to send a message that it is closing back to Roslyn. However, Roslyn disappears just before. This is a race condition.

### Bugs this fixes
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/514822

### Workarounds, if any
No

### Risk
Low

### Performance impact
None

### Is this a regression from a previous update?
No

### Root cause analysis
We haven't considered all possible timing combinations happening between threads.

### How was the bug found?
Customer reports (Watson)</Description>
    <CreatedDate>16/05/2018</CreatedDate>
    <ClosedDate>18/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26585</IssueID>
    <RepoID>1</RepoID>
    <Title>"csc.exe" exited with code -2146232797</Title>
    <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017 Preview (2)
Version 15.7.0 Preview 5.0
VisualStudio.15.Preview/15.7.0-pre.5.0+27625.0
Microsoft .NET Framework
Version 4.7.02556

**Steps to Reproduce**:

Try to compile a foreach cycle with a ref iterator variable in an async/iterator method
e.g.

```cs
using System;
class E
{
  public class Enumerator
  {
    public ref readonly int Current =&gt; throw new NotImplementedException();
    public bool MoveNext() =&gt; throw new NotImplementedException();
  }
  public Enumerator GetEnumerator() =&gt; new Enumerator();
}
class C
{
  public async void M()
  {
    foreach (ref readonly int x in new E()) {}
  }
}
```

or 

```cs
using System;
class E
{
  public class Enumerator
  {
    public ref readonly int Current =&gt; throw new NotImplementedException();
    public bool MoveNext() =&gt; throw new NotImplementedException();
  }
  public Enumerator GetEnumerator() =&gt; new Enumerator();
}
class C
{
  public System.Collections.Generic.IEnumerable&lt;int&gt;  M()
  {
    yield return 0;
    foreach (ref readonly int x in new E()) {}
  }
}
```

**Expected Behavior**:

Meaningful error.

**Actual Behavior**:

```"csc.exe" exited with code -2146232797```

Stacktrace from [sharplab.io](https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQxASwDZICYgNQA+AAgAwAERAjANwCwAUEQExkCiDA3g2RQMwUtWAOwCuYRBBgB7BNzJd6PHkX4I4AMzJqI2KUIwBPMmiEwyAYREI1psgF4AfGRgALBFIDuZIXC8A5KRgASTAABww4cVM4bFYADwBjOFCYND0ACgBKOkUlFTJgKSkMMgBZKQA3OD84OJgs+ydXdy8ff0CQ8Mi4aNjE5NSM7LkAXzl84TEJaQQyAHE4GEnxBEkZBsdvXzZRFbWELJyxxhZzTnH+IgAOCgAWMqy5BSUydRk4CASXMnS1TW1dPojCYzHFjEItl5WFlMvJjjxjiMgA==)
```
    System.InvalidCastException: Unable to cast object of type 'ForEachLocalSymbol' to type 'Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal'.

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitAssignmentOperator(BoundAssignmentOperator node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 774

       at Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 1245

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 97

       at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 225

       at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 206

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 82

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter.VisitExpressionStatement(BoundExpressionStatement node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs:line 252

       at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2693

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitSequencePointWithSpan(BoundSequencePointWithSpan node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9006

       at Microsoft.CodeAnalysis.CSharp.BoundSequencePointWithSpan.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2267

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\MethodToClassRewriter.cs:line 137

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.&lt;&gt;c__DisplayClass41_0.&lt;VisitBlock&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 308

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2303

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitStatementList(BoundStatementList node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9266

       at Microsoft.CodeAnalysis.CSharp.BoundStatementList.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 4076

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\MethodToClassRewriter.cs:line 137

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.&lt;&gt;c__DisplayClass41_0.&lt;VisitBlock&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 265

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2303

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitTryStatement(BoundTryStatement node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 801

       at Microsoft.CodeAnalysis.CSharp.BoundTryStatement.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 3489

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\MethodToClassRewriter.cs:line 137

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.&lt;&gt;c__DisplayClass41_0.&lt;VisitBlock&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 308

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2303

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitStatementList(BoundStatementList node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9266

       at Microsoft.CodeAnalysis.CSharp.BoundStatementList.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 4076

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37

       at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\MethodToClassRewriter.cs:line 137

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.&lt;&gt;c__DisplayClass41_0.&lt;VisitBlock&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(ImmutableArray`1 locals, Func`1 wrapped) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 265

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 657

       at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2303

       at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 87

       at Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\MethodToStateMachineRewriter.cs:line 649

       at Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter.GenerateMoveNext(BoundStatement body, MethodSymbol moveNextMethod) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncMethodToStateMachineRewriter.cs:line 120

       at Microsoft.CodeAnalysis.CSharp.AsyncRewriter.GenerateMoveNext(SynthesizedImplementationMethod moveNextMethod) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs:line 248

       at Microsoft.CodeAnalysis.CSharp.AsyncRewriter.GenerateMethodImplementations() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs:line 124

       at Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.Rewrite() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\StateMachineRewriter\StateMachineRewriter.cs:line 106

       at Microsoft.CodeAnalysis.CSharp.AsyncRewriter.Rewrite(BoundStatement body, MethodSymbol method, Int32 methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, AsyncStateMachine&amp; stateMachineType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Lowering\AsyncRewriter\AsyncRewriter.cs:line 68

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1326

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1079

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 494

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 384

       at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136

       at System.Threading.Tasks.Task.InnerInvoke()

       at System.Threading.Tasks.Task.Execute()

    --- End of stack trace from previous location where exception was thrown ---

       at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 299

       at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 144

       at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, Boolean emitMetadataOnly, Boolean emitTestCoverageData, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2533

       at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream metadataPEStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2195

       at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, Stream metadataPEStream, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2143

       at SharpLab.Server.Compilation.Compiler.&lt;TryCompileToStreamAsync&gt;d__0.MoveNext()

    --- End of stack trace from previous location where exception was thrown ---

       at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)

       at SharpLab.Server.MirrorSharp.SlowUpdate.&lt;ProcessAsync&gt;d__7.MoveNext()

    --- End of stack trace from previous location where exception was thrown ---

       at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

       at MirrorSharp.Internal.Handlers.SlowUpdateHandler.&lt;ExecuteAsync&gt;d__4.MoveNext()

    --- End of stack trace from previous location where exception was thrown ---

       at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)

       at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessInternalAsync&gt;d__13.MoveNext()

    --- End of stack trace from previous location where exception was thrown ---

       at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)

       at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

       at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessAsync&gt;d__12.MoveNext()
```</Description>
    <CreatedDate>03/05/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27321</IssueID>
    <RepoID>1</RepoID>
    <Title>Empty type for the designator in a recursive-pattern </Title>
    <Description>**Version Used**: `recursive-patterns` branch

**Steps to Reproduce**:

```cs
class C {
    extern (int,int)? GetNullableTuple();

    void M() {       
    	/* (1) */ if (GetNullableTuple() is (int x, int y) tuple) {}
        /* (2) */ if (GetNullableTuple() is (int x, int y) _) {}
    }
}
```

**Expected Behavior**:

(1) either a sensible error, or `(int, int)` as the type of `tuple`.
(2) no error

**Actual Behavior**: `error CS0648: '' is a type not supported by the language` for both cases.
</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>08/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25047</IssueID>
    <RepoID>1</RepoID>
    <Title>[SQLite] Bump and use byte[] variants added to blob_open for performance</Title>
    <Description>Fixes https://github.com/dotnet/roslyn/issues/23424

NOTE: Currently using CI as a build bot, roslyn builds take too much time on my machine.

&lt;details&gt;&lt;summary&gt;Ask Mode template not completed&lt;/summary&gt;

&lt;!-- This template is not always required. If you aren't sure about whether it's needed or want help filling out the sections,
submit the pull request and then ask us for help. :) --&gt;

### Customer scenario

What does the customer do to get into this situation, and why do we think this
is common enough to address for this release.  (Granted, sometimes this will be
obvious "Open project, VS crashes" but in general, I need to understand how
common a scenario is)

### Bugs this fixes

(either VSO or GitHub links)

### Workarounds, if any

Also, why we think they are insufficient for RC vs. RC2, RC3, or RTW

### Risk

This is generally a measure our how central the affected code is to adjacent
scenarios and thus how likely your fix is to destabilize a broader area of code

### Performance impact

(with a brief justification for that assessment (e.g. "Low perf impact because no extra allocations/no complexity changes" vs. "Low")

### Is this a regression from a previous update?

### Root cause analysis

How did we miss it?  What tests are we adding to guard against it in the future?

### How was the bug found?

(E.g. customer reported it vs. ad hoc testing)

### Test documentation updated?

If this is a new non-compiler feature or a significant improvement to an existing feature, update https://github.com/dotnet/roslyn/wiki/Manual-Testing once you know which release it is targeting.

&lt;/details&gt;
</Description>
    <CreatedDate>25/02/2018</CreatedDate>
    <ClosedDate>29/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26688</IssueID>
    <RepoID>1</RepoID>
    <Title>C# 7.3 fixed field still requires pinning with implicit `this` reference</Title>
    <Description>**Version Used**:  C# 7.3 / VS 15.7

**Steps to Reproduce**:

In reading through the proposal for relaxing the pinning requirement for fixed fields, I believe the following code should now be valid


```C#
unsafe struct Foo
{
    private fixed int Bar[4];

    public int FirstBar =&gt; Bar[0];
}
```

But I still get the "You cannot use fixed size buffers contained in unfixed expressions".  However, if I use an explicit `this` reference I don't get the error

```C#
unsafe struct Foo2
{
    private fixed int Bar[4];

    public int FirstBar =&gt; this.Bar[0];
}
```

Is there a reason these would be interpreted differently by the compiler?
</Description>
    <CreatedDate>07/05/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26743</IssueID>
    <RepoID>1</RepoID>
    <Title>C# 7.3 allows unmanaged pointer to fixed field without pinning</Title>
    <Description>**Version Used**: C# 7.3 / VS 15.7.1

**Steps to Reproduce**:

Using an explicit `this` pointer to work around #26688, I am able to take the address of a fixed field, giving me an unmanaged pointer without pinning.  If I'm understanding the relaxed restrictions correctly, this should not be possible, as the pointer should only be useable as an indexer.

```C#
unsafe struct Foo
{
	private fixed byte buff1[256];
	private fixed byte buff2[256];

	public void DoUnsafeThing()
	{
		Buffer.MemoryCopy(&amp;this.buff1[0], &amp;this.buff2[0], 256, 256);
	}
}

```
</Description>
    <CreatedDate>09/05/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26612</IssueID>
    <RepoID>1</RepoID>
    <Title>lower interpolated strings to string concatenation where possible</Title>
    <Description>This PR handles #22594 and is a follow up for #22595.

**Customer scenario**

The user uses string interpolation where concatenation could be used.

**Risk**

This PR modifies code generation of interpolated strings, but only in the case where all fill-ins are strings without alignment or format specifiers.

**Performance impact**

Code generation for interpolated strings will be somewhat slower. The generated code will be significantly faster in the case where all fill-ins in the interpolated string are strings, without alignment or format specifiers. In all other cases, the new implementation has one additional loop over the parts with no memory allocations in it, fairly simple logic and early exit as soon it is determined that the code gen optimization cannot be done.

Given the following declarations:

    const string constantabc = "abc";
    const string constantnull = null;

With `/o`, the following methods compile to the following IL:

    string M1() =&gt; $"";

	IL_0000: ldstr ""
	IL_0005: ret

    string M2() =&gt; $"abc";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M3() =&gt; $"{constantabc}";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M4() =&gt; $"{constantnull}";

	IL_0000: ldstr ""
	IL_0005: ret

    string M5() =&gt; $"{constantabc}{constantnull}";

	IL_0000: ldstr "abc"
	IL_0005: ret

    string M6(string a) =&gt; $"{a}";

	IL_0000: ldarg.1
	IL_0001: dup
	IL_0002: brtrue.s IL_000a
	IL_0004: pop
	IL_0005: ldstr ""
	IL_000a: ret

    string M7(string a) =&gt; $"a: {a}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Concat(string, string)
	IL_000b: ret

    string M8(string a, string b) =&gt; $"{a + b}";

	IL_0000: ldarg.1
	IL_0001: ldarg.2
	IL_0002: call string [mscorlib]System.String::Concat(string, string)
	IL_0007: ret

    string M9(string a, string b) =&gt; $"{a}{b}";

	IL_0000: ldarg.1
	IL_0001: ldarg.2
	IL_0002: call string [mscorlib]System.String::Concat(string, string)
	IL_0007: ret

    string M10(string a, string b) =&gt; $"a: {a}, b: {b}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: ldstr ", b: "
	IL_000b: ldarg.2
	IL_000c: call string [mscorlib]System.String::Concat(string, string, string, string)
	IL_0011: ret

    string M11(object a) =&gt; $"{a}";

	IL_0000: ldstr "{0}"
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Format(string, object)
	IL_000b: ret

    string M12(object a) =&gt; $"a: {a}";

	IL_0000: ldstr "a: {0}"
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Format(string, object)
	IL_000b: ret

    string M13(string a) =&gt; $"{{{a}}}";

	IL_0000: ldstr "{"
	IL_0005: ldarg.1
	IL_0006: ldstr "}"
	IL_000b: call string [mscorlib]System.String::Concat(string, string, string)
	IL_0010: ret

    string M14(string a) =&gt; "a:" + $" {a}";

	IL_0000: ldstr "a: "
	IL_0005: ldarg.1
	IL_0006: call string [mscorlib]System.String::Concat(string, string)
	IL_000b: ret</Description>
    <CreatedDate>03/05/2018</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27045</IssueID>
    <RepoID>1</RepoID>
    <Title>Wrong CS2021 is reported for *.resources files</Title>
    <Description>**Investigation**
A change in src/Compilers/CSharp/Portable/CommandLine/CSharpCommandLineParser.cs made in https://github.com/dotnet/roslyn/commit/d23cc53f65501798ae46e8ab9f3aa74077a7586d causes a bug.

There, PathUtilities.IsValidFilePath is called for a fileName instead of a filePath. Inside it,
new FileInfo(fileName) is created, and there is no parent directory in fileName, so current directory is used. In our case current directory is a path to compiler binaries, and it is rather long. If path to compiler binaries length + file name length exceed 260 characters, then PathTooLongException is thrown and that results in CS2021 error.

Compiler errors should not depend on a path to compiler binaries, only on path to files being compiled.

**Version Used**: 
2.8 (from dev15.7)

**Steps to Reproduce**:
1. Place compiler binaries into a folder with a path length &gt;=127 characters (say, C:\Users\SomeUserAtSomeCompany\AppData\Local\MyFolder1\~\Toolset\A367E15E0EE028AF\MyFolder1.Toolset.Roslyn.2.8.20180511.192024)
2. Make a resource file with a name length &gt;= 135 characters (say, MyCompany.SomeNamespace.SubNamespace.MoreNamespace.OneMoreNamespace.EvenMoreNamespace.Control.ShowMeSomeOptionsOptionsPagePanel.resources) and place it in your project with a short folder name so that a full path length to resource file would not exceed 260 characters.
3. Compile your project with a said resource file using a compiler run from its folder from step 1.

**Expected Behavior**:
No errors are produced

**Actual Behavior**:
CSC : error CS2021: File name '...\MyCompany.SomeNamespace.SubNamespace.MoreNamespace.OneMoreNamespace.EvenMoreNamespace.Control.ShowMeSomeOptionsOptionsPagePanel.resources' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long

</Description>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>07/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26516</IssueID>
    <RepoID>1</RepoID>
    <Title>Exception binding bad ref</Title>
    <Description>Consider the following code:

``` c#
using System;
public class C {
    void G() { } 
    public void M() {
        int x = 42;
        G(ref void = ref x);
    }
}
```

This causes a cash in `BindAssignment` because it ends up calling `GetRefKind` on the void expression. 

``` txt
ystem.InvalidOperationException: Unexpected value 'TypeExpression' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs:line 34
   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1315
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 404
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics, ExpressionSyntax argumentExpression, RefKind refKind, Boolean allowArglist) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2494
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2270
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean&amp; hadError, Boolean&amp; hadLangVersionError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 2235
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Invocation.cs:line 148
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 384
```

</Description>
    <CreatedDate>30/04/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26978</IssueID>
    <RepoID>1</RepoID>
    <Title>Binding DynamicMemberAccess expressions crashes VS</Title>
    <Description>```csharp
class C
{
    void M(dynamic x)
    {
        x.test = ref x;
    }
}
```
Result on latest master:
```
System.InvalidOperationException: Unexpected value 'DynamicMemberAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions.GetRefKind(BoundExpression node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundExpressionExtensions.cs:line 34
   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1315
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 404
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 329
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 566
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 559
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1599
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 43
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode declaration, BlockSyntax blockBody, ArrowExpressionClauseSyntax expressionBody, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3073
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode syntax, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3021
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested, ValueTuple`3&amp; forSemanticModel) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1622
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 943
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 494
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 384
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
```</Description>
    <CreatedDate>18/05/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26873</IssueID>
    <RepoID>1</RepoID>
    <Title>VenusCommandFilter/AbstractVsTextViewFilter uses incorrect buffer when providing values on hover over for cshtml files on debugging</Title>
    <Description>**Steps to Reproduce**:

1.  Try to debug a CSHTML file with some C# code
2.  Hover over on a variable with C# object.

**Expected Behavior**:
See object type description and value.

**Actual Behavior**:
See object type description but no value.

**Analysis**
There could be some problems on VS side but Roslyn attempts to use an incorrect buffer to search for span.

1. [VenusCommandFilter calls](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/Venus/VenusCommandFilter.cs,93) AbstractVsTextViewFilter.GetDataTipTextImpl

2.  Then, [it gets](http://source.roslyn.io/#Microsoft.VisualStudio.LanguageServices/Implementation/AbstractVsTextViewFilter%25602.cs,56) a buffer from caret
`var subjectBuffer = WpfTextView.GetBufferContainingCaret();`

3. However, the caret can be in HTML but the item hovered over can be in C#. Then, the buffer is null. And we stop search for the span.</Description>
    <CreatedDate>15/05/2018</CreatedDate>
    <ClosedDate>18/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26896</IssueID>
    <RepoID>1</RepoID>
    <Title>Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections uses C# binder to bind sections that declare locals</Title>
    <Description>See Microsoft.CodeAnalysis.CSharp.UnitTests.OutVarTests.ExpressionVariableInCase_1 unit-test for example

A BoundSwitchSection is created instead of BoundPatternSwitchSection, locals are not preserved in the bound tree and not exposed in IOperation tree. This is blocking CFG work </Description>
    <CreatedDate>16/05/2018</CreatedDate>
    <ClosedDate>20/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26418</IssueID>
    <RepoID>1</RepoID>
    <Title>Ref declaration expressions shouldn't be parsed in out arguments</Title>
    <Description>**Version Used**: 

Microsoft Visual Studio Professional 2017 Preview (2)
Version 15.7.0 Preview 4.0
VisualStudio.15.Preview/15.7.0-pre.4.0+27617.1
Microsoft .NET Framework
Version 4.7.02556

**Steps to Reproduce**:

Compile and run the following code
```cs
class C
{
  public static void Main()
  {
    M();
  }
  public static void M()
  {
    M(out ref readonly int x);
    ref readonly int y = ref x;
    x = 6;
  }
  public static void M(out int q)
  {
    q = 0;
  }
}
```

**Expected Behavior**:

Compilation error for `M(out ref readonly int x)`
Compilation error for `x = 6;` as it assigns 'readonly' ref.


**Actual Behavior**:

Code compiles and runs without errors.</Description>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>16/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26770</IssueID>
    <RepoID>1</RepoID>
    <Title>fix for CLR_EXCEPTION_System.NullReferenceException_80004003_Microsoft.VisualStudio.InteractiveWindow.dll</Title>
    <Description>### Customer scenario

Visual Studio closes or restarts and attempts to close and restart Roslyn which attempts to do the same with Interactive Host. Interactive Host attempts to send a message that it is closing back to Roslyn. However, Roslyn disappears just before. This is a race condition.

### Bugs this fixes
https://devdiv.visualstudio.com/DevDiv/_workitems/edit/514822

### Workarounds, if any
No

### Risk
Low

### Performance impact
None

### Is this a regression from a previous update?
No

### Root cause analysis
We haven't considered all possible timing combinations happening between threads.

### How was the bug found?
Customer reports (Watson)</Description>
    <CreatedDate>10/05/2018</CreatedDate>
    <ClosedDate>15/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19394</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crashes when a user defined struct is used as a well known attribute synthesized by the compiler</Title>
    <Description>Example test:

```csharp
            var code = @"
namespace System.Runtime.CompilerServices
{
    public struct DynamicAttribute
    {
        public DynamicAttribute(bool[] transformFlags)
        {
        }
}
}
class T
{
    void M(dynamic x) {}
}
";

            CreateCompilationWithMscorlib(code).VerifyEmitDiagnostics(/* there should be an error */);
```

However, the compiler crashes with the following:

```
	System.Collections.Generic.KeyNotFoundException : The given key was not present in the dictionary.
	at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
	at Microsoft.Cci.FullMetadataWriter.DefinitionIndex`1.get_Item(T item)
	at Microsoft.Cci.FullMetadataWriter.GetMethodDefinitionHandle(IMethodDefinition def)
	at Microsoft.Cci.MetadataWriter.GetCustomAttributeTypeCodedIndex(IMethodReference methodReference)
	at Microsoft.Cci.MetadataWriter.AddCustomAttributeToTable(EntityHandle parentHandle, ICustomAttribute customAttribute)
	at Microsoft.Cci.MetadataWriter.AddCustomAttributesToTable[T](IEnumerable`1 parentList, Func`2 getDefinitionHandle)
	at Microsoft.Cci.MetadataWriter.PopulateCustomAttributeTableRows(ImmutableArray`1 sortedGenericParameters)
	at Microsoft.Cci.MetadataWriter.PopulateTypeSystemTables(Int32[] methodBodyOffsets, BlobBuilder mappedFieldDataWriter, BlobBuilder resourceWriter, BlobBuilder dynamicAnalysisDataOpt, Blob&amp; mvidFixup)
	at Microsoft.Cci.MetadataWriter.BuildMetadataAndIL(PdbWriter nativePdbWriterOpt, BlobBuilder ilBuilder, BlobBuilder mappedFieldDataBuilder, BlobBuilder managedResourceDataBuilder, Blob&amp; mvidFixup, Blob&amp; mvidStringFixup)
	at Microsoft.Cci.PeWriter.WritePeToStream(EmitContext context, CommonMessageProvider messageProvider, Func`1 getPeStream, Func`1 getPortablePdbStreamOpt, PdbWriter nativePdbWriterOpt, String pdbPathOpt, Boolean allowMissingMethodBodies, Boolean isDeterministic, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Compilation.SerializeToPeStream(CommonPEModuleBuilder moduleBeingBuilt, EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, Func`1 testSymWriterFactory, DiagnosticBag diagnostics, Boolean metadataOnly, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.DiagnosticExtensions.GetEmitDiagnostics[TCompilation](TCompilation c, EmitOptions options, IEnumerable`1 manifestResources)
	at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyEmitDiagnostics[TCompilation](TCompilation c, EmitOptions options, DiagnosticDescription[] expected)
	at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyEmitDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
	Attributes\AttributeTests_RefReadOnly.cs(1666,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.AttributeTests_RefReadOnly.RefReadOnlyDefinitionsInsideUserDefinedIxxxsReadOnlyAttribute_Struct()
```</Description>
    <CreatedDate>10/05/2017</CreatedDate>
    <ClosedDate>18/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26584</IssueID>
    <RepoID>1</RepoID>
    <Title>Parenthesized expression is parsed as a cast if it's followed by 'switch'</Title>
    <Description>**Version Used**:  branch `features/recusrive-patterns`

**Steps to Reproduce**:

```cs
class C {
    void M(bool t)  {
        Console.Write((t) switch {var x =&gt; x});
    }
}
```


**Expected Behavior**:

No error.

**Actual Behavior**:

`error CS1525: Invalid expression term 'switch'`
`error CS0118: 't' is a variable but is used like a type`</Description>
    <CreatedDate>03/05/2018</CreatedDate>
    <ClosedDate>12/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25829</IssueID>
    <RepoID>1</RepoID>
    <Title>It looks like IDiscardSymbols returned by SemanticModel are never going to be equal</Title>
    <Description>```
        public override Symbol ExpressionSymbol
        {
            get
            {
                Debug.Assert((object)this.Type != null);
                return new DiscardSymbol(this.Type);
            }
        }
```

Expected:
Symbols for the same syntax and the same type should be equal</Description>
    <CreatedDate>30/03/2018</CreatedDate>
    <ClosedDate>10/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26613</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash on positional pattern `(a: 1)`</Title>
    <Description>[Repro](https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRIMaOQSwG4SoAOsMECAdsgDQAmIA1AD4ACADAAQsCMA3ALAAoFgGYuAJg4BhDgG8hHRVzEsALBwCyACgCUchUsMB9DgF4OMABY5kHGxy1QQHbjoGDDAXyGegA===)

```C#
public class C {
    public void M() {
        _ = this is (a: 1);
    }
}
```

```C#
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstructionPattern(DeconstructionPatternSyntax node, TypeSymbol inputType, Boolean hasErrors, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 517
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, TypeSymbol inputType, Boolean hasErrors, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 102
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 30
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 564
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 329
   at Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1322
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 404
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 329
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 566
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 559
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 49
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 1599
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 43
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode declaration, BlockSyntax blockBody, ArrowExpressionClauseSyntax expressionBody, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3073
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodBody(CSharpSyntaxNode syntax, DiagnosticBag diagnostics) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 3021
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested, ValueTuple`3&amp; forSemanticModel) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1619
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 943
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 494
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 384
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 299
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 144
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2175
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, DiagnosticBag diagnostics, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2144
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2061
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GetAllDiagnosticsWithoutStateTrackingAsync&gt;d__50.MoveNext() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\DiagnosticAnalyzer\CompilationWithAnalyzers.cs:line 451
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GetAllDiagnosticsAsync&gt;d__43.MoveNext() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\DiagnosticAnalyzer\CompilationWithAnalyzers.cs:line 324
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at MirrorSharp.Internal.Roslyn.RoslynSession.&lt;GetDiagnosticsAsync&gt;d__16.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at MirrorSharp.Internal.Handlers.SlowUpdateHandler.&lt;ExecuteAsync&gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)
   at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessInternalAsync&gt;d__13.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessAsync&gt;d__12.MoveNext()

```</Description>
    <CreatedDate>03/05/2018</CreatedDate>
    <ClosedDate>05/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26467</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion hit in  MakeTestsAndBindings</Title>
    <Description>```C#
                    Debug.Assert(recursive.HasAnyErrors); // line 451
```

![image](https://user-images.githubusercontent.com/12466233/39390934-df9d446e-4a50-11e8-9bea-b190fbc20f7e.png)

I think the assertion is reached before I typed the last character, so it would be `_ = a is ()`.

![image](https://user-images.githubusercontent.com/12466233/39390967-696bb7ac-4a51-11e8-9269-2fbd31819256.png)


Tagging @gafter 
</Description>
    <CreatedDate>28/04/2018</CreatedDate>
    <ClosedDate>29/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26387</IssueID>
    <RepoID>1</RepoID>
    <Title>Intermittent false negatives when using "is T v" where T is tuple</Title>
    <Description>**Version Used**: netcoreapp2.0 using dotnet CLI 15.6.0-preview-20180109-01, also observed on Ubuntu with .NET Core 2.0 and Windows with .NET Core 2.0 and Visual Studio 15.3.3 and donet CLI 2.0.0.

**Steps to Reproduce**:

Using this .csproj: 

```
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.7.0" /&gt;
    &lt;PackageReference Include="xunit" Version="2.3.1" /&gt;
    &lt;PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
```

and this .cs file:

```
using System;
using Xunit;

namespace ConsoleApp1
{
    public class TestHelper
    {
        [Fact]
        public void TestHelperNeverReturnsNull()
        {
            IsValueTypeT(new Result&lt;(Cls, IInt)&gt;((new Cls(), new Int())));
        }

        [Fact]
        public void TestHelperNeverReturnsNull_Continously()
        {
            Assert.Throws&lt;NotPossibleException&gt;(
                new Action(() =&gt;
                {
                    while (true)
                        TestHelperNeverReturnsNull();
                }));
        }

        public static void IsValueTypeT&lt;T&gt;(Result&lt;T&gt; result)
        {
            if (!(result.Value is T v))
                throw new NotPossibleException();
        }
    }

    public class Result&lt;T&gt;
    {
        public T Value { get; }

        public Result(T value)
        {
            Value = value;
        }
    }

    public class Cls { }
    public interface IInt { }

    public class Int : IInt { }

    public class NotPossibleException : Exception { }
}
```

Running `dotnet test --configuration Release`. Gives output

```
Build started, please wait...                                                                                                                                                                     
Program.cs(25,28): warning xUnit1013: Public method 'IsValueTypeT' on test class 'TestHelper' should be marked as a Theory. [C:\Users\kim\source\repos\ConsoleApp1\ConsoleApp1\ConsoleApp1.csproj]
Build completed.                                                                                                                                                                                  
                                                                                                                                                                                                  
Test run for C:\Users\kim\source\repos\ConsoleApp1\ConsoleApp1\bin\Release\netcoreapp2.0\ConsoleApp1.dll(.NETCoreApp,Version=v2.0)                                                                
Microsoft (R) Test Execution Command Line Tool Version 15.6.0-preview-20180109-01                                                                                                                 
Copyright (c) Microsoft Corporation.  All rights reserved.                                                                                                                                        
                                                                                                                                                                                                  
Starting test execution, please wait...                                                                                                                                                           
[xUnit.net 00:00:00.3542121]   Discovering: ConsoleApp1                                                                                                                                           
[xUnit.net 00:00:00.4069510]   Discovered:  ConsoleApp1                                                                                                                                           
[xUnit.net 00:00:00.4122708]   Starting:    ConsoleApp1                                                                                                                                           
[xUnit.net 00:00:00.5435184]     ConsoleApp1.TestHelper.TestHelperNeverReturnsNull [FAIL]                                                                                                         
[xUnit.net 00:00:00.5446641]       ConsoleApp1.NotPossibleException : Exception of type 'ConsoleApp1.NotPossibleException' was thrown.                                                            
[xUnit.net 00:00:00.5458188]       Stack Trace:                                                                                                                                                   
[xUnit.net 00:00:00.5471366]         C:\Users\kim\source\repos\ConsoleApp1\ConsoleApp1\Program.cs(28,0): at ConsoleApp1.TestHelper.IsValueTypeT[T](Result`1 result)                               
[xUnit.net 00:00:00.5605291]   Finished:    ConsoleApp1                                                                                                                                           
Failed   ConsoleApp1.TestHelper.TestHelperNeverReturnsNull                                                                                                                                        
Error Message:                                                                                                                                                                                    
 ConsoleApp1.NotPossibleException : Exception of type 'ConsoleApp1.NotPossibleException' was thrown.                                                                                              
Stack Trace:                                                                                                                                                                                      
   at ConsoleApp1.TestHelper.IsValueTypeT[T](Result`1 result) in C:\Users\kim\source\repos\ConsoleApp1\ConsoleApp1\Program.cs:line 28                                                             
                                                                                                                                                                                                  
Total tests: 2. Passed: 1. Failed: 1. Skipped: 0.                                                                                                                                                 
Test Run Failed.                                                                                                                                                                                  
Test execution time: 1,2055 Seconds                                                                                                                                                               

```

This code creates a tuple in a wrapper the type of which is then tested in `IsValueTypeT` using a type parameter. This should never fail - or fail (at compile time) if it wasn't allowed. 

I've also seen this behavior outside of an xunit test, and I've reproduced it in Visual Studio 2017 15.6.6 in Debug configuration. In CLI I couldn't reproduce in Debug configuration.

**Expected Behavior**:

TestHelperNeverReturnsNull should pass and TestHelperNeverReturnsNull_Continously should never finish.

**Actual Behavior**:

TestHelperNeverReturnsNull  passes most of the time and TestHelperNeverReturnsNull_Continously completes at some point (indicating that the NotPossibleException was thrown).



</Description>
    <CreatedDate>25/04/2018</CreatedDate>
    <ClosedDate>25/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26001</IssueID>
    <RepoID>1</RepoID>
    <Title>[Ubuntu tests] build.sh: Permission denied</Title>
    <Description>I get consistent failures in Ubuntu tests on the features/recursive-patterns branch, with messages like this in https://ci.dot.net/job/dotnet_roslyn/job/features_recursive-patterns/job/ubuntu_16_mono_debug_prtest/85/consoleFull

``` none
12:28:10     Merge bcaa4ffa89d0231c486890f75bab356bf989f4df into 8de96ab87ecd16046b24eb65a5ca6973369abbba
12:28:10 ./build/scripts/cibuild.sh: line 27: /mnt/j/workspace/dotnet_roslyn/features_recursive-patterns/ubuntu_16_mono_debug_prtest/build.sh: Permission denied
```
</Description>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>25/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24112</IssueID>
    <RepoID>1</RepoID>
    <Title>Debugger inserts DisplayText instead of InsertionText.</Title>
    <Description>1. New Console App, set a breakpoint, F5. Do not type in the editor.
2. After hitting the breakpoint, open the Watch window and type an expression.
3. Type "List" and observe that "List&lt;&gt;" is highlighted.
4. Press Tab to commit the "List&lt;&gt;" items.

Expected:
`List` inserted into watch window

Actual:
`List&lt;&gt;` inserted into watch window.

Interesting:
If you do the same in the main editor, `List` is always inserted. After doing this in the main editor, Debugger Intellisense starts inserting `List` instead of `List&lt;&gt;`

This was reported by the Pythia team who received a bug report because their CompletionProvider always inserts an InsertionText that differs from its DisplayText.</Description>
    <CreatedDate>09/01/2018</CreatedDate>
    <ClosedDate>10/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26394</IssueID>
    <RepoID>1</RepoID>
    <Title>Implement a better fix for when completion runs in the debugger before it runs in the normal editor</Title>
    <Description>This tracks fixing https://github.com/dotnet/roslyn/pull/26361 the better way. We should ensure that the CompletionService used to trigger completion in the debugger is the same CompletionService used to show the description and perform the commit.</Description>
    <CreatedDate>25/04/2018</CreatedDate>
    <ClosedDate>22/01/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25813</IssueID>
    <RepoID>1</RepoID>
    <Title>C# compiler chooses inaccessible extension method over accessible one</Title>
    <Description>**Version Used**: 
Microsoft (R) Visual C# Compiler version 2.6.0.62329 (5429b35d)

**Steps to Reproduce**:

1. Create new console application with following code in `Program.cs`:
```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Program
{
    static void Main(string[] args)
    {
        var a = new[] { 0 };
        var b = new[] { 1, 2, 3 };
        Console.WriteLine(b.Count(a.Contains));
    }
}

public static class Extensions
{
    // NOTE: private access modifier simulates internal class public method in referenced assembly.
    private static bool Contains&lt;T&gt;(this IEnumerable&lt;T&gt; a, T value) =&gt;
        throw new NotImplementedException();
}
```
2. Build project or wait full solution analysis to complete

**Expected Behavior**:
Project compiled successfully. `System.Linq.Enumerable.Contains()` used as an argument of `System.Linq.Enumerable.Count()` function.

**Actual Behavior**:
Compiler error CS0122: 'Extensions.Contains&lt;T&gt;(IEnumerable&lt;T&gt;, T)' is inaccessible due to its protection level

Original case is described in [C# compiler chooses wrong extension method](https://stackoverflow.com/questions/49554228/c-sharp-compiler-chooses-wrong-extension-method#comment86117664_49554228) question on StackOverflow. [CS0122 wrong member inaccessible when overload does not exist](https://github.com/dotnet/roslyn/issues/15401) issue looks related.</Description>
    <CreatedDate>29/03/2018</CreatedDate>
    <ClosedDate>27/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26344</IssueID>
    <RepoID>1</RepoID>
    <Title>semantic model vs extension method group</Title>
    <Description>When binding an instance method group, we try twice. First, assuming we will find something applicable, we apply the language rules correctly. Then, if that fails, we are more relaxed and gather even inapplicable and inaccessible candidates. This permits us to produce better diagnostics and information from `SemanticModel` for failed invocations.

However, we only do one pass for extension methods. As a result the `SemanticModel` has to do some work on its own to try to reconstruct things. It cannot always do a decent job. Below shows a regression in a test in a recent PR due to this. There was a line that used to read

``` c#
            Assert.Equal(CandidateReason.Inaccessible, semanticInfo.CandidateReason);
```

that now reads

``` c#
            Assert.Equal(CandidateReason.OverloadResolutionFailure, semanticInfo.CandidateReason);
```

That is because the compiler now avoids considering inaccessible methods when resolving extension methods (this was necessary to fix https://github.com/dotnet/roslyn/issues/25813)

The offending test is

``` c#
        [WorkItem(542850, "http://vstfdevdiv:8080/DevDiv2/DevDiv/_workitems/edit/542850")]
        [Fact]
        public void InaccessibleExtensionMethod()
        {
            string sourceCode = @"
using System;
using System.Collections.Generic;
using System.Linq;

public static class Extensions
{
    private static int Goo(this string z) { return 3; }
}

class Program
{
    static void Main(string[] args)
    {
        args[0]./*&lt;bind&gt;*/Goo/*&lt;/bind&gt;*/();
    }
}
";
            var semanticInfo = GetSemanticInfoForTest&lt;IdentifierNameSyntax&gt;(sourceCode);

            Assert.Null(semanticInfo.Type);
            Assert.Null(semanticInfo.ConvertedType);
            Assert.Equal(ConversionKind.Identity, semanticInfo.ImplicitConversion.Kind);

            Assert.Null(semanticInfo.Symbol);
            Assert.Equal(CandidateReason.OverloadResolutionFailure, semanticInfo.CandidateReason);
            Assert.Equal(1, semanticInfo.CandidateSymbols.Length);
            var sortedCandidates = semanticInfo.CandidateSymbols.OrderBy(s =&gt; s.ToTestDisplayString(), StringComparer.Ordinal).ToArray();
            Assert.Equal("System.Int32 System.String.Goo()", sortedCandidates[0].ToTestDisplayString());
            Assert.Equal(SymbolKind.Method, sortedCandidates[0].Kind);

            Assert.Equal(1, semanticInfo.MethodGroup.Length);
            var sortedMethodGroup = semanticInfo.MethodGroup.OrderBy(s =&gt; s.ToTestDisplayString(), StringComparer.Ordinal).ToArray();
            Assert.Equal("System.Int32 System.String.Goo()", sortedMethodGroup[0].ToTestDisplayString());

            Assert.False(semanticInfo.IsCompileTimeConstant);
        }
```
</Description>
    <CreatedDate>23/04/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26274</IssueID>
    <RepoID>1</RepoID>
    <Title>KeyNotFoundException in StackOptimizerPass1 for switch expression in features/recursive-patterns</Title>
    <Description>**Version Used**: dc34a02, the latest commit in features/recursive-patterns

**Steps to Reproduce**:

Try to compile [the following code](https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRIMaOQSwG4SoAOsMECAdsgD4ACATAAQDCAsAFADeHjvjwAewEAbRgFEAjnCjDkACgHAAVhAwxGipQEpGAXgB8PPgEhNjZAHccMDAAsjfPt3aPXfZozwy4EPfsYwCD4ANA5ufAD6foxgMsgQYY4AvgDcHElAA) in SharpLab:

```c#
class C
{
    bool Equals(object obj) =&gt;
    	obj switch
        {
            C value =&gt; true,
            _ =&gt; false
        };
}
```

**Expected Behavior**: Successful compilation.

**Actual Behavior**:

```
System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.RecordVarWrite(LocalSymbol local) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 1802
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitAssignmentOperator(BoundAssignmentOperator node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 998
   at Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 1261
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitExpressionCore(BoundExpression node, ExprContext context) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 465
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitExpressionCoreWithStackGuard(BoundExpression node, ExprContext context) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 521
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitExpression(BoundExpression node, ExprContext context) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 508
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitExpressionStatement(BoundExpressionStatement node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 849
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2638
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9911
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 627
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2288
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9911
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 627
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2288
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitSequencePoint(BoundSequencePoint node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9901
   at Microsoft.CodeAnalysis.CSharp.BoundSequencePoint.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2221
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 9911
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitBlock(BoundBlock node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 627
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 2288
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 37
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitStatementList(BoundStatementList node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 10135
   at Microsoft.CodeAnalysis.CSharp.BoundStatementList.Accept(BoundTreeVisitor visitor) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Generated\BoundNodes.xml.Generated.cs:line 3855
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.VisitSideEffect(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 578
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Visit(BoundNode node) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 445
   at Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.Analyze(BoundNode node, Dictionary`2 locals, Boolean debugFriendly) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 434
   at Microsoft.CodeAnalysis.CSharp.CodeGen.Optimizer.Optimize(BoundStatement src, Boolean debugFriendly, HashSet`1&amp; stackLocals) in D:\$TC\work\c99972099bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\Optimizer.cs:line 60
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator..ctor(MethodSymbol method, BoundStatement boundBody, ILBuilder builder, PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics, OptimizationLevel optimizations, Boolean emittingPdb) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs:line 121
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, Boolean emitTestCoverageData, ImmutableArray`1 dynamicAnalysisSpans) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1370
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1187
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 494
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 384
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 299
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean emittingPdb, Boolean emitTestCoverageData, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 144
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, Boolean emitMetadataOnly, Boolean emitTestCoverageData, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2520
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream metadataPEStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2195
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, Stream metadataPEStream, CancellationToken cancellationToken) in D:\$TC\work\c99972096bc51e45\!roslyn\sources\dotnet\src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2143
   at SharpLab.Server.Compilation.Compiler.&lt;TryCompileToStreamAsync&gt;d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)
   at SharpLab.Server.MirrorSharp.SlowUpdate.&lt;ProcessAsync&gt;d__7.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at MirrorSharp.Internal.Handlers.SlowUpdateHandler.&lt;ExecuteAsync&gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)
   at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessInternalAsync&gt;d__13.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at MirrorSharp.Internal.Connection.&lt;ReceiveAndProcessAsync&gt;d__12.MoveNext()
```

I found two issues with similar stack traces: https://github.com/dotnet/roslyn/issues/13712 and https://github.com/dotnet/roslyn/issues/13159, but they don't seem to be closely related to this issue.

---

Also, trying to compile [this similar, but invalid code](https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLRIMaOQSwG4SoAOsMECAdsgD4ACATAAQDCAsAFADeHjvjwAewEAbRgFEAjnCjDkACgHAAVhAwxGipQEpGAXgB8PPgEhNjZAHccMDAAsjfPt3aPXfZozwy4EPfsYwCD4OrgC+ANwcoUA==):

```c#
class C
{
    bool Equals(object obj) =&gt;
    	obj switch
        {
            C value =&gt; true
        };
}
```

Results in:

&gt; error CS7038: Failed to emit module '_'.

I don't think that's a reasonable error message for this code.

---

As with https://github.com/dotnet/roslyn/issues/25591 before, I understand that this branch is a prototype, but I though reporting this issue might be useful nonetheless.

cc: @gafter </Description>
    <CreatedDate>19/04/2018</CreatedDate>
    <ClosedDate>28/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26195</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio crashes while analyzing provided code</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio Professional 2017, Version 15.6.6

**Steps to Reproduce**:
Create new solution and copy-paste sample code there:

```C#
using System;
unsafe class Test
{
	public void Method()
	{
		Test obj1 = stackalloc int[2];
	}

	public static implicit operator Test2(int* value)
	{
		return default(Test);
	}
}
```

**Expected Behavior**:
No crasg

**Actual Behavior**:
Visual studio crashes
</Description>
    <CreatedDate>17/04/2018</CreatedDate>
    <ClosedDate>09/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25654</IssueID>
    <RepoID>1</RepoID>
    <Title>Type inference doesn't work with a pointer of a generic unmanaged type</Title>
    <Description>**Version Used**:  `dev15.7.x`

**Steps to Reproduce**:

```cs
class C {
    unsafe void M&lt;T&gt;(T* a) where T : unmanaged {
        var p = stackalloc T[10];
        M(p);
    }
}
```

**Expected Behavior**: No error

**Actual Behavior**:

`The type arguments for method 'C.M&lt;T&gt;(T*)' cannot be inferred from the usage. Try specifying the type arguments explicitly.`

/cc @OmarTawfik </Description>
    <CreatedDate>21/03/2018</CreatedDate>
    <ClosedDate>21/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22455</IssueID>
    <RepoID>1</RepoID>
    <Title>`in` and `out` arguments should be disallowed in `__arglist`</Title>
    <Description>varargs should disallow  `out` and `in` arguments. There is no way the calee can express its part of the contract.

We currently allow both and `out` was allowed in old compiler versions too. We should disallow both. 

Arguably it would be a breaking change for `out`, but it is very unlikely it would affect real code. 

Example:

```C#

    class Program
    {
        static void Main(string[] args)
        {
            int unassigned;
            int doNotChange = 42;

            Test(__arglist(out unassigned, in doNotChange));  // &lt;--  out?   in?  really?

            System.Console.WriteLine(unassigned);
            System.Console.WriteLine(doNotChange);
        }

        static void Test(__arglist)
        {
            var args = new ArgIterator(__arglist);

            // leave unassigned unassigned
            ref var unassigned = ref __refvalue(args.GetNextArg(), int);

            // assign junk to doNotChange
            ref var doNotChange = ref __refvalue(args.GetNextArg(), int);
            doNotChange = unassigned;
        }
    }
```

</Description>
    <CreatedDate>30/09/2017</CreatedDate>
    <ClosedDate>17/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24975</IssueID>
    <RepoID>1</RepoID>
    <Title>Arrays of tuples don't work with `is`</Title>
    <Description>I was directed here from https://github.com/dotnet/csharplang/issues/1334

**Version Used**: 

VBCSCompiler.exe is 2.6.0.62329, not sure if that's the version you're interested in

**Steps to Reproduce**:

Compile this:

    using System;
    class A
    {
        void Test()
        {
            (object, object)[] a = new (object, object)[1]; // This line has no errors
            var b = a as (object, object)[]; // No errors
            if (a is (object, object)[]) // CS1525: Invalid expression term 'object', CS0443: Syntax error; value expected
            {
                Console.WriteLine("Hello");
            }
            if (a is (object, object)[] c) // CS1525: Invalid expression term 'object', CS0443: Syntax error; value expected
            {
                Console.WriteLine("World");
            }
        }
    }

**Expected Behavior**:
Successful compilation

**Actual Behavior**:
See embedded comments and also https://github.com/dotnet/csharplang/issues/1334</Description>
    <CreatedDate>21/02/2018</CreatedDate>
    <ClosedDate>18/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25999</IssueID>
    <RepoID>1</RepoID>
    <Title>When keyword recommender failure with constant named `var`</Title>
    <Description>Some tests are skipped in the branch `features/recursive-patterns` because the compiler treats `var` as a keyword in pattern contexts. It is not clear if that is intentional.

Here is an example from `WhenKeywordRecommenderTests.cs`:

``` c#
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/25999"), Trait(Traits.Feature, Traits.Features.KeywordRecommending)]
        public async Task TestForSwitchCase_SemanticCheck_AfterClassAndLocalConstantVar_BeforeBreak() =&gt;
    await VerifyKeywordAsync(@"
class var { }
class C
{
    void M() { const object var = null; switch (new object()) { case var $$ break; } }
}");
```
</Description>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>18/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26000</IssueID>
    <RepoID>1</RepoID>
    <Title>Pattern-matching compiler does not permit a constant named `var` as a pattern</Title>
    <Description>See https://github.com/dotnet/roslyn/issues/25999

It isn't clear if this is intentional. If it is, it needs to be documented.
</Description>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>18/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23525</IssueID>
    <RepoID>1</RepoID>
    <Title>Compilation.Emit may crash when invalid pdb path is specified</Title>
    <Description>This line should call ```PathUtilities.GetFileName``` instead of ```Path.GetFileName```:
http://source.roslyn.io/#Microsoft.CodeAnalysis/Compilation/Compilation.cs,2428, or we should catch the exception and report a diagnostic.

```Path.GetFileName``` throws if the path contains invalid characters.

Repro from command line:

```
C:\Temp&gt;csc a.cs /debug:embedded /pathmap:C:\="
Microsoft (R) Visual C# Compiler version 2.6.0.62321 (74213c90)
Copyright (C) Microsoft Corporation. All rights reserved.


Unhandled Exception: System.ArgumentException: Illegal characters in path.
   at System.IO.Path.CheckInvalidPathChars(String path, Boolean checkAdditional)
   at System.IO.Path.GetFileName(String path)
   at Microsoft.CodeAnalysis.Compilation.SerializeToPeStream(CommonPEModuleBuilder moduleBeingBuilt, EmitStreamProvider peStreamProvider, EmitStreamProvider metadataPEStreamProvider, EmitStreamProvider pdbStreamProvider, Func`1 testSymWriterFactory, DiagnosticBag diagnostics, Boolean metadataOnly, Boolean includePrivateMembers, Boolean emitTestCoverageData, String pePdbFilePath, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CommonCompiler.RunCore(TextWriter consoleOutput, ErrorLogger errorLogger, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CommonCompiler.Run(TextWriter consoleOutput, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CommandLine.Csc.&lt;&gt;c__DisplayClass1_0.&lt;Run&gt;b__0(TextWriter tw)
   at Microsoft.CodeAnalysis.CSharp.CommandLine.Csc.Run(String[] args, BuildPaths buildPaths, TextWriter textWriter, IAnalyzerAssemblyLoader analyzerLoader)
   at Microsoft.CodeAnalysis.CommandLine.DesktopBuildClient.RunLocalCompilation(String[] arguments, BuildPaths buildPaths, TextWriter textWriter)
   at Microsoft.CodeAnalysis.CommandLine.BuildClient.RunCompilation(IEnumerable`1 originalArguments, BuildPaths buildPaths, TextWriter textWriter)
   at Microsoft.CodeAnalysis.CommandLine.DesktopBuildClient.Run(IEnumerable`1 arguments, RequestLanguage language, CompileFunc compileFunc, IAnalyzerAssemblyLoader analyzerAssemblyLoader)
   at Microsoft.CodeAnalysis.CSharp.CommandLine.Program.Main(String[] args)
```
</Description>
    <CreatedDate>01/12/2017</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25399</IssueID>
    <RepoID>1</RepoID>
    <Title>partial methods shouldn't be allowed to have different ref-kinds</Title>
    <Description>**Version Used**: master

**Steps to Reproduce**:
```cs
partial class C {
    partial void M(in int i);
    partial void M(ref int i) {}  
}
```
**Expected Behavior**: Error: ref-kind doesn't match

` CS0759: No defining declaration found for implementing declaration of partial method `

**Actual Behavior**: No error


/cc @OmarTawfik </Description>
    <CreatedDate>10/03/2018</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25211</IssueID>
    <RepoID>1</RepoID>
    <Title>AbstractGenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider failure in the MEF cache for 15.7</Title>
    <Description>15.7.0 Preview 1.0 [27501.3002.d15.7stg]

```
Error #1
Microsoft.VisualStudio.Composition.PartDiscoveryException: Failure while scanning type "Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider". ---&gt; System.InvalidOperationException: No importing constructor found.
   at Microsoft.Verify.Operation(Boolean condition, String message)
   at Microsoft.VisualStudio.Composition.AttributedPartDiscovery.CreatePart(Type partType, Boolean typeExplicitlyRequested)
   at Microsoft.VisualStudio.Composition.PartDiscovery.CombinedPartDiscovery.CreatePart(Type partType, Boolean typeExplicitlyRequested)
   at Microsoft.VisualStudio.Composition.PartDiscovery.&lt;&gt;c__DisplayClass27_0.&lt;CreateDiscoveryBlockChain&gt;b__0(Type type)
   --- End of inner exception stack trace ---
```</Description>
    <CreatedDate>05/03/2018</CreatedDate>
    <ClosedDate>16/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24603</IssueID>
    <RepoID>1</RepoID>
    <Title>Test localization failures on non english machines: BoundTupleExpression.Display returns a string instead a FormattableString</Title>
    <Description>Extracted from the closed PR #24539 

**Steps to Reproduce**:

Run `Microsoft.CodeAnalysis.CSharp.UnitTests.OverloadResolutionTests.GenericInferenceOnInErrTuples` on a non-english machine.

**Expected Behavior**:

Test passes.

**Actual Behavior**:

Test fails for Diagnostics with a `BoundTupleExpression` because `BoundTupleExpression.Display` returns a localized string (e.g. German during the test run). BoundTupleExpression.Display should return a formattable string instead. There are some more tests that also fail. See the original PR for details.

**History**

The issue was discussed but not resolved in #24539. The relevant sections are:

@Mastr11
The diagnostic is created [here](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Binder/Semantics/OverloadResolution/OverloadResolutionResult.cs#L991) and the argument is created via  `argument.Display` 
The problem here is that the [BoundTupleExpression.Display](https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/BoundTree/Formatting.cs#L85) uses a stringbuilder. So the argument is a text as opposed to a `LocalizableErrorArgument`. I don't see any straight forward way on how to resolve this. @AlekseyTs I would propose to revert my changes here and let the test fail on non english machines for now. 

@AlekseyTs 
It would be great if you could fix it because you can easily verify the effect, but it is up to you.
I think there is a simple fix for BoundTupleExpression.Display. Instead of building complete string, we can build a format string with argument markers and collect arguments in an array. Then we call to System.Runtime.CompilerServices.FormattableStringFactory.Create and return its result.
There is also an issue with

```CS
    internal partial class BoundStackAllocArrayCreation
    {
        public override object Display
        {
            get { return string.Format(MessageID.IDS_StackAllocExpression.Localize().ToString(), ElementType, Count.Syntax); }
        }
    }
```

This one can be fixed by creating an object that is very similar to LocalizableErrorArgument, that calls Format after getting the string for requested culture.</Description>
    <CreatedDate>02/02/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25086</IssueID>
    <RepoID>1</RepoID>
    <Title>Test Span&lt;T&gt; with constraint on T</Title>
    <Description>From https://github.com/dotnet/roslyn/pull/25035#issuecomment-368637816
A comment from Aleksey in another PR made me think of this: what if you create a custom Span&lt;T&gt; type with some constraints on T. Do we properly check and report on such constraints?
See BindStackAllocArrayCreationExpression line 3130 (type = spanType.Construct(elementType);).</Description>
    <CreatedDate>27/02/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25038</IssueID>
    <RepoID>1</RepoID>
    <Title>Span&lt;RefStruct&gt; is permitted through an implicitly-typed variable</Title>
    <Description>**Version Used**: https://github.com/dotnet/roslyn/commit/37e71921d2f539854ec3a5ebd45cdda5a1a5eccf head of `features/compilers`

**Steps to Reproduce**:

```cs
ref struct S {}

void M(bool c) {
  // ERROR: The type 'S' may not be used as a type argument
  Span&lt;S&gt; x = c ? stackalloc S[2] : stackalloc S[3]; 

  // OK?
  var y = c ? stackalloc S[2] : stackalloc S[3]; 
}
```

**Expected Behavior**: error in both cases

**Actual Behavior**: error only if `S` is spelt out
</Description>
    <CreatedDate>24/02/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25043</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion failure in ControlFlowPass.IntersectWith with local function inside switch statement</Title>
    <Description>1. Checkout master &amp; run a debug build of VisualStudioSetup.Next
2. Paste the following code:
```c#
class C
{
    void M()
    {
        switch (true)
        {
            case true:
                void f()
                {
                }
        }
    }
}
```
3. Select the line with `switch (true)` or any line inside the switch statement. This repros most consistently when selecting the whole line by clicking in the left margin in VS.

This is what I get:
![image](https://user-images.githubusercontent.com/11444821/36645188-474f4a6a-1a65-11e8-9e7f-08ae262f29aa.png)
</Description>
    <CreatedDate>25/02/2018</CreatedDate>
    <ClosedDate>27/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25028</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix `GetStackAllocConversion` and remove `Binder.CheckFeatureAvailability` method</Title>
    <Description>During overload resolution or conversion classification, we use use-site diagnostics to report problems with symbols that might affect the correctness of result. 
`GetStackAllocConversion` should not be putting language-version-related diagnostics as use-site diagnostics since there was nothing wrong with symbols. Also, we don't want language version to affect the result of the binding (including conversion classification).

We should review this method's use of use-site diagnostics to comply with this guideline.

This was reported by @AlekseyTs in a PR that was also going to mis-use use-site diagnostics (https://github.com/dotnet/roslyn/pull/24913#discussion_r170335206).

```

        public override Conversion GetStackAllocConversion(BoundStackAllocArrayCreation sourceExpression, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)
        {
...
                            Binder.CheckFeatureAvailability(sourceExpression.Syntax, MessageID.IDS_FeatureRefStructs, ref useSiteDiagnostics);
                            Binder.GetWellKnownTypeMember(_binder.Compilation, WellKnownMember.System_Span_T__ctor, out DiagnosticInfo memberDiagnosticInfo);
                            HashSetExtensions.InitializeAndAdd(ref useSiteDiagnostics, memberDiagnosticInfo);

                            return Conversion.MakeStackAllocToSpanType(spanConversion);
                        }
...
        }
```

Tagging @VSadov @OmarTawfik </Description>
    <CreatedDate>24/02/2018</CreatedDate>
    <ClosedDate>28/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24776</IssueID>
    <RepoID>1</RepoID>
    <Title>csc.exe compiler error -2146232797 with ref struct C# 7.2 modifier</Title>
    <Description>Hello, both VS 15.5 Preview 5 and the official VS 15.5 fail to compile my library using the C# 7.2 ref struct modifier in one of the structs I'm using.

Here's the link to the exact code that reproduces the error, just clone and try to compile the library &amp;quot;NeuralNetwork.NET&amp;quot;:
https://github.com/Sergio0694/NeuralNetwork.NET/tree/VS_test_csc-compiler-error

Removing the ref struct modifier from the &amp;quot;FloatSpan2D&amp;quot; struct solves the issue.

If this is not a bug and that struct is actually being moved to the heap somehow/somewhere, it'd be useful to have some sort of warning to be able to fix the code error.
Otherwise, I hope this will help you pinpoint the cause of the issue.
Cheers!

_This issue has been moved from https://developercommunity.visualstudio.com/content/problem/160134/cscexe-compiler-error-2146232797-with-ref-struct-c.html
VSTS ticketId: 533142_
_These are the original issue comments:_
(no comments)
_These are the original issue solutions:_
(no solutions)

---

Edit by @OmarTawfik
Smaller repro:
```csharp
public ref struct Tensor {
    public void TryFree() { }
}
public class C {
        public static unsafe void TryFree(params Tensor[] tensors)
        {
            fixed (Tensor* p = tensors)
                for (int i = 0; i &lt; tensors.Length; i++)
                    p[i].TryFree();
        }
}
```
It hits the following assert:
```
System.InvalidOperationException: Unexpected value 'PointerElementAccess expression of Tensor type' of type 'System.String'
   at Microsoft.CodeAnalysis.CSharp.Binder.GetValEscape(BoundExpression expr, UInt32 scopeOfTheContainingExpression)
   at Microsoft.CodeAnalysis.CSharp.Binder.CheckInvocationArgMixing(SyntaxNode syntax, Symbol symbol, BoundExpression receiverOpt, ImmutableArray`1 parameters, ImmutableArray`1 argsOpt, ImmutableArray`1 argRefKindsOpt, ImmutableArray`1 argsToParamsOpt, UInt32 scopeOfTheContainingExpression, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpressionContinued(SyntaxNode node, SyntaxNode expression, String methodName, OverloadResolutionResult`1 result, AnalyzedArguments analyzedArguments, MethodGroup methodGroup, NamedTypeSymbol delegateTypeOpt, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindMethodGroupInvocation(SyntaxNode syntax, SyntaxNode expression, String methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(SyntaxNode node, SyntaxNode expression, String methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, Boolean allowUnexpandedForm)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPossibleEmbeddedStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(ForStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(DiagnosticBag diagnostics, Binder originalBinder)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPossibleEmbeddedStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFixedStatementParts(FixedStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindFixedStatement(FixedStatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass21_0.&lt;CompileNamedTypeAsTask&gt;b__0()

```</Description>
    <CreatedDate>12/02/2018</CreatedDate>
    <ClosedDate>05/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20600</IssueID>
    <RepoID>1</RepoID>
    <Title>nameof requires a non-static member in a sub-expression</Title>
    <Description>**Version Used**: https://github.com/dotnet/roslyn/commit/5fbdd5c567b854e9b5f6f1ea64944373a40efb26

**Steps to Reproduce**:

```cs
class C
{
    public string Instance;
    public static string Static;
      
    void M()
    {
         _ = nameof(C.Instance);             // OK         
         _ = nameof(C.Instance.Length);      // ERROR
         _ = nameof(C.Static);               // OK  
         _ = nameof(C.Static.Length);        // OK
    }
}

class C&lt;T&gt;
{
    public T Instance;
    public static T Static;
     
    void M()
    {
         _ = nameof(C&lt;string&gt;.Instance);	// OK
	 _ = nameof(C&lt;string&gt;.Instance.Length); // ERROR
         _ = nameof(C&lt;string&gt;.Static);		// OK
         _ = nameof(C&lt;string&gt;.Static.Length);   // OK
    }
}
```

**Expected Behavior**: No error.

**Actual Behavior**:  

`CS0120: An object reference is required for the non-static field, method, or property 'C.Instance'`
</Description>
    <CreatedDate>01/07/2017</CreatedDate>
    <ClosedDate>20/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24522</IssueID>
    <RepoID>1</RepoID>
    <Title>is operator not working if implicit conversion operator exists on generic type</Title>
    <Description>**Version Used**: 7.2

**Steps to Reproduce**:

    class Base&lt;T&gt;
    {
        //without implicit operator everything works as expected
        public static implicit operator Derived(Base&lt;T&gt; obj)
        {
            return new Derived();
        }
    }

    class Derived : Base&lt;object&gt;
    {

    }

    class Program
    {
        static void Main(string[] args)
        {
            Base&lt;object&gt; x = new Derived();
            if (x is Derived) //Problem: this is always false!!
            {

            }
        }
    }

**Expected Behavior**: (x is Derived) should be true in this case (it worked like that in the old csc.exe).

**Actual Behavior**: (x is Derived) is always false.
</Description>
    <CreatedDate>29/01/2018</CreatedDate>
    <ClosedDate>06/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24351</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion in EnsureIsReadOnlyAttributeExists during rename</Title>
    <Description>**Version Used**: 

Private build.

```
---------------------------
Assertion Failed: Abort=Quit, Retry=Debug, Ignore=Continue
---------------------------




   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.EnsureIsReadOnlyAttributeExists(DiagnosticBag diagnostics, Location location, Boolean modifyCompilationForRefReadOnly) in C:\R0\src\Compilers\CSharp\Portable\Symbols\Compilation_WellKnownMembers.cs:line 465

   at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.AfterMembersChecks(DiagnosticBag diagnostics) in C:\R0\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs:line 1419

   at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken) in C:\R0\src\Compilers\CSharp\Portable\Symbols\Source\SourceMemberContainerSymbol.cs:line 507

   at Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken) in C:\R0\src\Compilers\CSharp\Portable\Symbols\Symbol.cs:line 712

   at Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTy......

&lt;truncated&gt;
---------------------------
Abort   Retry   Ignore   
---------------------------
```

Crash dump:
%internal_share%\public\tomat\Bugs\Roslyn24351</Description>
    <CreatedDate>19/01/2018</CreatedDate>
    <ClosedDate>09/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30566</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler exits with error code compiling Async Stream project</Title>
    <Description>**Version Used**: 
Branch Dev16.0.x

**Steps to Reproduce**:

See attached solution.

1.  Open attached solution.
2.  Compile.
3.  Compile fails - check output window, etc.

**Expected Behavior**:
Successfully compile, or report the issue with the code.

**Actual Behavior**:
Compiler fails with an error code.

```log
c:\users\darenmay\appdata\local\microsoft\visualstudio\15.0_641a84e6roslyndev\extensions\microsoft\roslyn compilers\42.42.42.4242424\Microsoft.CSharp.Core.targets(52,5): error MSB6006: "csc.exe" exited with code -2146232797.
```

@jcouv This is the issue we discussed.

[AsyncStreamRepro.zip](https://github.com/dotnet/roslyn/files/2489052/AsyncStreamRepro.zip)
</Description>
    <CreatedDate>17/10/2018</CreatedDate>
    <ClosedDate>02/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18780</IssueID>
    <RepoID>1</RepoID>
    <Title>Optimization: Passing static method as Action parameter should no allocate</Title>
    <Description>In the code below, compare the two methods of passing `StaticMethod` to `F`.
Calling with a lambda generates a lazy singleton `Action`, but calling with the method creates a new `Action` on every call. 
It seems the former would be more efficient, but to get that behavior, users have to type extra glue code. 
That is even more pronounced for the scenario where the static method takes parameters (passing into a method that accepts `Func&lt;...&gt;`).

```C#
class C
{
    static void StaticMethod() { }
    void F(System.Action a) { }
    void M()
    {
        // compare the following two methods of passing StaticMethod to F
        // F(() =&gt; StaticMethod());
        // F(StaticMethod);
    }
}
```

```C#
// decompiled code for F(() =&gt; StaticMethod());
internal class C
{
    [CompilerGenerated]
    [Serializable]
    private sealed class &lt;&gt;c
    {
        public static readonly C.&lt;&gt;c &lt;&gt;9;
        public static Action &lt;&gt;9__2_0;
        static &lt;&gt;c()
        {
            // Note: this type is marked as 'beforefieldinit'.
            C.&lt;&gt;c.&lt;&gt;9 = new C.&lt;&gt;c();
        }
        internal void &lt;M&gt;b__2_0()
        {
            C.StaticMethod();
        }
    }
    private static void StaticMethod()
    {
    }
    private void F(Action a)
    {
    }
    private void M()
    {
        Action arg_21_1;
        if (arg_21_1 = C.&lt;&gt;c.&lt;&gt;9__2_0 == null)
        {
            arg_21_1 = C.&lt;&gt;c.&lt;&gt;9__2_0 = new Action(C.&lt;&gt;c.&lt;&gt;9.&lt;M&gt;b__2_0);
        }
        this.F(arg_21_1);
    }
}
```

```C#
// decompiled code for F(StaticMethod);
internal class C
{
    private static void StaticMethod()
    {
    }
    private void F(Action a)
    {
    }
    private void M()
    {
        this.F(new Action(C.StaticMethod));
    }
}
```

FYI @CyrusNajmabadi @cston </Description>
    <CreatedDate>18/04/2017</CreatedDate>
    <ClosedDate>18/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24137</IssueID>
    <RepoID>1</RepoID>
    <Title>Long-running VBCSCompiler.dll process runs at 100% CPU after parent process dies</Title>
    <Description>**Version Used**: 
Using dotnet SDK 2.2.0-preview1-007866 on macOS 10.13.2

**Steps to Reproduce**:
TBH not sure 100% how to get into bad state. I don't know what is launching VBCSCompiler.dll. The parent process is gone...which is the issue.

But, it has been happening fairly often over the last few days while working on the https://github.com/dotnet/cli repo using VS Code - Insiders + C# extension 1.13.1.

If someone can point me to how to capture more information about how this long-running compiler server starts, I can provide a better repro.

**Expected Behavior**:
No long running compiler process after I shutdown tools and build scripts.

**Actual Behavior**:
![image](https://user-images.githubusercontent.com/2696087/34750111-03aae97a-f55a-11e7-86ac-6bd6c6f97a22.png)

VS Code is closed, and I've killed the the build.sh script, yet I have two VBCSCompiler processes running. `ps` reports the processes have been open for ~ 18 hours.

The process was launched with these arguments:
```
/Users/namc/.dotnet/dotnet /Users/namc/.dotnet/sdk/2.2.0-preview1-007866/Roslyn/bincore/VBCSCompiler.dll -pipename:namc.False.bZ9mpL2HFmG8IVwxPkEmz6_N4OMYW1cLZOeZGRjGfv0
```

Process sample: 
[processample.txt](https://github.com/dotnet/roslyn/files/1617126/processample.txt)

#### [EDIT]
See below for a workaround: https://github.com/dotnet/roslyn/issues/24137#issuecomment-388494024</Description>
    <CreatedDate>10/01/2018</CreatedDate>
    <ClosedDate>03/05/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20900</IssueID>
    <RepoID>1</RepoID>
    <Title>Move Microsoft.NETCore.Compilers to a release package</Title>
    <Description>This should be an "official" release package for CoreCLR as soon as https://github.com/dotnet/roslyn/issues/16717 is completed.</Description>
    <CreatedDate>14/07/2017</CreatedDate>
    <ClosedDate>24/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24072</IssueID>
    <RepoID>1</RepoID>
    <Title>VBCSCompiler server not working in .NET Core on Windows 10</Title>
    <Description>**Version Used**: 
.NET Core CLI 2.2.0-preview1-007870

**Steps to Reproduce**:
1. Windows 10
2. Install CLI (I used the .zip version)
3. `git clone https://github.com/OrchardCMS/OrchardCore`
4. `cd OrchardCore`
5. `dotnet build --no-incremental`

**Expected Behavior**:
Compilation happens inside the `dotnet vbcscompiler.dll` process.

**Actual Behavior**:
The `dotnet vbcscompiler.dll` process is started and stays running, but it's doesn't use any CPU.  Instead, one instance of `dotnet csc.dll` is created for each project in the solution.

**Comments**
The same scenario appears to be working correctly on Ubuntu 16.04 LTS.</Description>
    <CreatedDate>06/01/2018</CreatedDate>
    <ClosedDate>30/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17814</IssueID>
    <RepoID>1</RepoID>
    <Title>Roslyn crashes with 'KeyNotFoundException' when completion is invoked after a local fun declaration</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio Community 2017
Version 15.0.26228.4 D15RTWSVC
Microsoft .NET Framework
Version 4.6.01586

**Steps to Reproduce**:

1. Create a C# project in Visual Studio 17
2. Paste the following code:
```
class C {
  static void foo()
  {
     void f&lt;[X]T&gt;(){}

  }
}
```
3. Put the caret at the empty line following the local function f declaration and press Ctrl+Space

**Expected Behavior**: No crash

**Actual Behavior**: Visual Studio crashes with System.Collections.Generic.KeyNotFoundException "The given key was not present in the dictionary."

```
	System.Collections.Immutable.dll!System.Collections.Immutable.ImmutableDictionary&lt;Microsoft.CodeAnalysis.SyntaxTree, int&gt;.this[Microsoft.CodeAnalysis.SyntaxTree].get(Microsoft.CodeAnalysis.SyntaxTree key)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSyntaxTreeOrdinal(Microsoft.CodeAnalysis.SyntaxTree tree)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetBinderFactory(Microsoft.CodeAnalysis.SyntaxTree syntaxTree = {Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParsedSyntaxTree})	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributesToBind(Roslyn.Utilities.OneOrMany&lt;Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;&gt; attributeDeclarationSyntaxLists, Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation symbolPart = None, Microsoft.CodeAnalysis.DiagnosticBag diagnostics = Count = 0, Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation = {Microsoft.CodeAnalysis.CSharp.CSharpCompilation}, Microsoft.CodeAnalysis.CSharp.Binder rootBinderOpt = null, out System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Binder&gt; binders = Uninitialized)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany&lt;Microsoft.CodeAnalysis.SyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax&gt;&gt; attributesSyntaxLists, ref Microsoft.CodeAnalysis.CustomAttributesBag&lt;Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData&gt; lazyCustomAttributesBag = null, Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation symbolPart = None, bool earlyDecodingOnly = false, Microsoft.CodeAnalysis.DiagnosticBag addToDiagnostics = Count = 0, Microsoft.CodeAnalysis.CSharp.Binder binderOpt)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributesBag(Microsoft.CodeAnalysis.DiagnosticBag diagnosticsOpt)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.LocalFunctionSymbol.GetDeclarationDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag addTo = Count = 0)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node = LocalFunctionStatementSyntax LocalFunctionStatement void f&lt;[X]T&gt;() { }, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node = BlockSyntax Block { void f&lt;[X]T&gt;() { } }, Microsoft.CodeAnalysis.DiagnosticBag diagnostics = Count = 0)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node = LocalFunctionStatementSyntax LocalFunctionStatement void f&lt;[X]T&gt;() { })	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, out Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode bindableNode = IdentifierNameSyntax IdentifierName X, out Microsoft.CodeAnalysis.CSharp.BoundNode lowestBoundNode = null, out Microsoft.CodeAnalysis.CSharp.BoundNode highestBoundNode = null, out Microsoft.CodeAnalysis.CSharp.BoundNode boundParent = null)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions options = DefaultOptions, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name = IdentifierNameSyntax IdentifierName X, Microsoft.CodeAnalysis.SemanticModel semanticModel = {Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel}, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode syntax = IdentifierNameSyntax IdentifierName X)	Unknown
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()	Unknown
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Text.TextSpan textSpan, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt; list, System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getNodeClassifiers, System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getTokenClassifiers, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document document = Program.cs, Microsoft.CodeAnalysis.Text.TextSpan textSpan = {Microsoft.CodeAnalysis.Text.TextSpan}, System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getNodeClassifiers = IsCancellationRequested = false, System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getTokenClassifiers = {Method = {System.Reflection.RuntimeMethodInfo}}, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt; result = {Method = {System.Reflection.RuntimeMethodInfo}}, System.Threading.CancellationToken cancellationToken = Count = 0)	Unknown
 	mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start&lt;Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5&gt;(ref Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5 stateMachine)	Unknown
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan textSpan, System.Func&lt;Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getNodeClassifiers, System.Func&lt;Microsoft.CodeAnalysis.SyntaxToken, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt; getTokenClassifiers, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt; result, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan textSpan, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt; result, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context = {Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan}, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag = {Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;}, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService = {Microsoft.CodeAnalysis.Editor.CSharp.Classification.CSharpEditorClassificationService}, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap = {Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap})	Unknown
 	mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start&lt;Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;ClassifySpansAsync&gt;d__2&gt;(ref Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;ClassifySpansAsync&gt;d__2 stateMachine)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context = {Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;}, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag = {Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan}, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService = {Microsoft.CodeAnalysis.Editor.CSharp.Classification.CSharpEditorClassificationService}, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap = {Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap})	Unknown
 	mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;bool&gt;.Start&lt;Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;TryClassifyContainingMemberSpan&gt;d__1&gt;(ref Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;TryClassifyContainingMemberSpan&gt;d__1 stateMachine)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context = {Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan}, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag = {Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;}, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService = {Microsoft.CodeAnalysis.Editor.CSharp.Classification.CSharpEditorClassificationService}, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap = {Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap})	Unknown
 	mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start&lt;Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;ProduceTagsAsync&gt;d__0&gt;(ref Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.&lt;ProduceTagsAsync&gt;d__0 stateMachine)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan spanToTag, Microsoft.CodeAnalysis.Editor.IEditorClassificationService classificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap typeMap)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt; context)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;.TagSource.RecomputeTagsAsync(object oldState = IsCancellationRequested = false, Microsoft.VisualStudio.Text.SnapshotPoint? caretPosition = {Microsoft.CodeAnalysis.VersionStamp}, Microsoft.CodeAnalysis.Text.TextChangeRange? textChangeRange = Count = 1, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt; spansToTag = {Microsoft.VisualStudio.Text.SnapshotPoint}, System.Collections.Immutable.ImmutableDictionary&lt;Microsoft.VisualStudio.Text.ITextBuffer, Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;&gt; oldTagTrees = {Microsoft.CodeAnalysis.Text.TextChangeRange}, System.Threading.CancellationToken cancellationToken = Count = 1)	Unknown
 	mscorlib.dll!System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start&lt;Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;.TagSource.&lt;RecomputeTagsAsync&gt;d__83&gt;(ref Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;.TagSource.&lt;RecomputeTagsAsync&gt;d__83 stateMachine)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;.TagSource.RecomputeTagsAsync(object oldState, Microsoft.VisualStudio.Text.SnapshotPoint? caretPosition, Microsoft.CodeAnalysis.Text.TextChangeRange? textChangeRange, System.Collections.Generic.List&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt; spansToTag, System.Collections.Immutable.ImmutableDictionary&lt;Microsoft.VisualStudio.Text.ITextBuffer, Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;&gt; oldTagTrees, System.Threading.CancellationToken cancellationToken)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider&lt;System.__Canon&gt;.TagSource.RecomputeTagsForeground.AnonymousMethod__0(System.Threading.CancellationToken ct)	Unknown
 	Microsoft.CodeAnalysis.EditorFeatures.dll!Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue.EnqueueBackgroundTask.AnonymousMethod__0(System.Threading.Tasks.Task _)	Unknown
 	mscorlib.dll!System.Threading.Tasks.ContinuationResultTaskFromTask&lt;System.Threading.Tasks.Task&gt;.InnerInvoke()	Unknown
 	mscorlib.dll!System.Threading.Tasks.Task.Execute()	Unknown
 	mscorlib.dll!System.Threading.Tasks.Task.ExecutionContextCallback(object obj)	Unknown
 	mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)	Unknown
 	mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)	Unknown
 	mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot = Id = 24707, Status = Running, Method = "System.Threading.Tasks.Task &lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)", Result = "{Not yet computed}")	Unknown
 	mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry(bool bPreventDoubleExecution)	Unknown
 	mscorlib.dll!System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()	Unknown
 	mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch()	Unknown
 	mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()	Unknown
```</Description>
    <CreatedDate>13/03/2017</CreatedDate>
    <ClosedDate>11/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23883</IssueID>
    <RepoID>1</RepoID>
    <Title>Quick Info over malformed code crashes Visual Studio</Title>
    <Description>**Version Used**: 
15.6.0 Preview 1.1 [27217.0.d15.6]
15.6.0 Preview 2.0 [27206.4000.vsuvscore]

**Steps to Reproduce**:

1. Insert this code
```csharp
        void method1()
        {
            if (method2())
                .Any(b =&gt; b.ContentType, out var chars)
            {
            }
        }
```
2. Hover over `b.ContentType`

**Expected Behavior**:
Quick info shows `(parameter) ? b` over `b`
and nothing over `ContentType`

**Actual Behavior**:
Visual Studio crashes when mouse is over either `b` or `ContentType`

**Notes**

When editing code, I ended up with invalid syntax that combines extra closing parenthesis, multi line and `out var`. VS crashed when I tried to invoke completion. I noticed that it also crashes on quick info. 

The issue goes away when I remove `, out var chars` in the second line:
```csharp
if (method2())
.Any(b =&gt; b.ContentType)
```
or if the code is all in one line, 
```csharp
if (method2()).Any(b =&gt; b.ContentType, out var chars)
```

**Stack Trace**
**"This program location is thought to be unreachable."**
```
   at Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableDeclarationArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindOutDeclarationArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean&amp; hadError, Boolean&amp; hadLangVersionError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, Boolean allowsAnyExpression, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundLambdaOrQuery(CSharpSyntaxNode lambdaOrQuery)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetEnclosingBinderInternal(CSharpSyntaxNode node, Int32 position)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetEnclosingBinderInternal(Int32 position)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetEnclosingBinderInternal(Int32 position)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingSymbol(Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingSymbolCore(Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetEnclosingSymbol[TSymbol](SemanticModel semanticModel, Int32 position, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.QuickInfo.AbstractSemanticQuickInfoProvider.&lt;BindTokenAsync&gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.QuickInfo.AbstractSemanticQuickInfoProvider.&lt;BuildContentAsync&gt;d__1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.QuickInfo.AbstractQuickInfoProvider.&lt;GetQuickInfoItemAsync&gt;d__8.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.QuickInfo.AbstractQuickInfoProvider.&lt;GetItemAsync&gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.QuickInfo.Controller.&lt;ComputeModelInBackgroundAsync&gt;d__9.MoveNext()
```</Description>
    <CreatedDate>20/12/2017</CreatedDate>
    <ClosedDate>05/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22472</IssueID>
    <RepoID>1</RepoID>
    <Title>Change ArgumentSyntax.RefOrOutKeyword to RefKindKeyword</Title>
    <Description>And add overloads for compatibility.
Fixes #22441

This is an API change that reflects the presence of a new ref mode for arguments.

@dotnet/roslyn-compiler @AnthonyDGreen @jaredpar Please review.
@jcouv for 15.5 approval.</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>17/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23957</IssueID>
    <RepoID>1</RepoID>
    <Title>XML code comments and 'in' parameters</Title>
    <Description>@andi6 commented on [Thu Dec 21 2017](https://github.com/dotnet/csharplang/issues/1209)

I don't find a way to reference a method with an 'in' parameter in xml code comments. Also VisualStudio (15.5.2) seems to be unable to do it.

If I take a sample method:

`public void MethodWithInPar(in double dummy) { }`

VisualStudio suggests

```
		/// &lt;summary&gt;
		/// This is the summary for &lt;see cref="MethodWithInPar(double)"/&gt;.
		/// &lt;/summary&gt;
```

with xml comment generation enabled in project settings (classic .NET framework project) I get CS1574.



---

@HaloFour commented on [Thu Dec 21 2017](https://github.com/dotnet/csharplang/issues/1209#issuecomment-353348770)

@andi6 

What about:

```cs
// &lt;summary&gt;
/// This is the summary for &lt;see cref="MethodWithInPar(ref double)"/&gt;.
/// &lt;/summary&gt;
```

---

@andi6 commented on [Thu Dec 21 2017](https://github.com/dotnet/csharplang/issues/1209#issuecomment-353368592)

Sorry, wrong button

@HaloFour 

I've tried this also: CS1574

</Description>
    <CreatedDate>28/12/2017</CreatedDate>
    <ClosedDate>10/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13759</IssueID>
    <RepoID>1</RepoID>
    <Title>Unnecessarily lifted field in async state machine</Title>
    <Description>**Version Used**: 
2.0.0.60620

**Steps to Reproduce**:
Compile this code:

``` C#
using System.IO;
using System.Threading.Tasks;

class Program
{
    public static void Main() { }

    public static async Task Repro1(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        int bytesRead;
        while ((bytesRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
        {
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }

    public static async Task Repro2(Stream source, Stream destination)
    {
        byte[] buffer = new byte[0x1000];
        while (true)
        {
            int bytesRead = await source.ReadAsync(buffer, 0, buffer.Length);
            if (bytesRead == 0) break;
            await destination.WriteAsync(buffer, 0, bytesRead);
        }
    }
}
```

**Expected Behavior**:
The async state machine does not have a field for `bytesRead`.

**Actual Behavior**:
In Repro2, as expected, the async state machine does not lift `bytesRead` to the state machine.  But in Repro1, it does lift `bytesRead` to the state machine, even though the value of `bytesRead` doesn't need to be preserved across an await.
</Description>
    <CreatedDate>13/09/2016</CreatedDate>
    <ClosedDate>09/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23929</IssueID>
    <RepoID>1</RepoID>
    <Title>Add tests for lifted variables in async/iterator code</Title>
    <Description>We do not have many tests that verify the set of variables lifted in async or iterator code. It would be good to add a bit of testing infrastructure to make that easy, and add tests. Also, this could be added to the checklist for new features.</Description>
    <CreatedDate>26/12/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23833</IssueID>
    <RepoID>1</RepoID>
    <Title>Property ref get crash</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio 2017, Version 15.5.2
C# 7.2
**Steps to Reproduce**:

1. Write `ref get;` in any property

**Expected Behavior**:
It was just mistake, I just wanted to know can I make property getter as ref return.
**Actual Behavior**:
Visual studio just get crashed.</Description>
    <CreatedDate>18/12/2017</CreatedDate>
    <ClosedDate>05/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23627</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio Crashes when creating ref struct from readonly struct</Title>
    <Description>**Version Used**: 

Visual Studio 15.5

**Steps to Reproduce**:

1. Create a new .NET Core 2.0 C# project. 
2. Set the compiler version to C# 7.2
3. Paste the code below in.

```
using System;

namespace CSharp72TestApp
{
    public ref struct Point
    {
    }
    class Program
    {
        public static readonly Point rwp = new Point();

        static void PrintNormal()
        {
            var tmp = rwp;
        }
    }
}
```

**Expected Behavior**:

Visual Studio should not freeze, and instead just have a compiler error.

**Actual Behavior**:
Visual Studio freezes, and requires killing in task manager.

Also pasted below is a copy of my csproj file.
```
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'"&gt;
    &lt;LangVersion&gt;7.2&lt;/LangVersion&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
```

@dotnet/roslyn-compiler</Description>
    <CreatedDate>06/12/2017</CreatedDate>
    <ClosedDate>05/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23691</IssueID>
    <RepoID>1</RepoID>
    <Title>Optional `in` parameters are passed by value</Title>
    <Description>Originally filed by @ufcpp on #23636

```csharp
using System;

class Program
{
    static void Main()
    {
        // buffer overrun
        A(1);

        // throw NullReference or AccessViolation Exception
        B(1, 2);
    }

    static void A(in double x = 1, in string y = "") =&gt; Console.WriteLine(y);
    static double B(in float x, in float y, in float z = 1.0f) =&gt; x * y * z;

}
```</Description>
    <CreatedDate>10/12/2017</CreatedDate>
    <ClosedDate>19/12/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15987</IssueID>
    <RepoID>1</RepoID>
    <Title>Encapsulate field consecutive capital letters</Title>
    <Description>(minor inconvenience)

**Version Used**: 2.0.0.61205

**Steps to Reproduce**:

```C#
public int ID;
```

**Actual Behavior**: After encapsulate field and use property:
```C#
private int iD;
public int ID { get =&gt; iD; set =&gt; iD = value; }
```

**Expected Behavior**: Depends on the code style settings, but definitely not `iD`. If a quick fix is lowering case, it should lower group of capital letters except the last one if small letters follow, i.e. _IPAddress_ should become _ipAddress_, _UI12_ should become _ui12_ etc.

(For the record, ID is not an acronym so it [shouldn't](https://msdn.microsoft.com/en-us/library/ms229043(v=vs.110).aspx#Anchor_1) be all capital.)</Description>
    <CreatedDate>18/12/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34232</IssueID>
    <RepoID>1</RepoID>
    <Title>Recompute Deconstruct method from nullable type and state of receiver in pattern-matching</Title>
    <Description>In the nullable walker's handling of pattern-matching, we may need to recompute the Deconstruct method for a deconstruction if the receiver type has changed (e.g. its nested nullability).</Description>
    <CreatedDate>19/03/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14934</IssueID>
    <RepoID>1</RepoID>
    <Title>Task&lt;SemaphoreDisposer&gt; taking lots of memory</Title>
    <Description>@mavasani @CyrusNajmabadi 

Is there a way we can do this without allocating for a disposable/using pattern?

D:\projects\roslyn\roslyn\src\Workspaces\Core\Portable\FindSymbols\SymbolTree\SymbolTreeInfo_Metadata.cs

        public static async Task&lt;SymbolTreeInfo&gt; TryGetInfoForMetadataReferenceAsync(

            // Find the lock associated with this piece of metadata.  This way only one thread is
            // computing a symbol tree info for a particular piece of metadata at a time.
            var gate = s_metadataIdToGate.GetValue(metadata.Id, s_metadataIdToGateCallback);
            using (await gate.DisposableWaitAsync(cancellationToken).ConfigureAwait(false))

D:\projects\roslyn\roslyn\src\Compilers\Core\Portable\InternalUtilities\SemaphoreSlimExtensions.cs
        public async static Task&lt;SemaphoreDisposer&gt; DisposableWaitAsync(this SemaphoreSlim semaphore, CancellationToken cancellationToken = default(CancellationToken))
        {
            await semaphore.WaitAsync(cancellationToken).ConfigureAwait(false);
            return new SemaphoreDisposer(semaphore);
        }

It is currently allocating over half a GB of memory.

Name                                                                                                                                                       Inc %             Inc
Type System.Threading.Tasks.Task`1[Roslyn.Utilities.SemaphoreSlimExtensions+SemaphoreDisposer]                                                              2.7     543,110,656
+ mscorlib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[Roslyn.Utilities.SemaphoreSlimExtensions+SemaphoreDisposer].GetTaskForResult(!0)         2.7     534,304,064
|+ mscorlib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[Roslyn.Utilities.SemaphoreSlimExtensions+SemaphoreDisposer].SetResult(!0)               2.7     534,304,064
| + Microsoft.CodeAnalysis.Workspaces!Roslyn.Utilities.SemaphoreSlimExtensions+&lt;DisposableWaitAsync&gt;d__1.MoveNext()                                          2.7     534,304,064
|  + mscorlib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[Roslyn.Utilities.SemaphoreSlimExtensions+SemaphoreDisposer].Start(!!0&amp;)               2.7    534,304,064
|   + Microsoft.CodeAnalysis.Workspaces!SemaphoreSlimExtensions.DisposableWaitAsync                                                                          2.7     534,304,064
|    + Microsoft.CodeAnalysis.Workspaces!Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo+&lt;TryGetInfoForMetadataReferenceAsync&gt;d__4.MoveNext()              2.7     533,767,168
|    |+ mscorlib!System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[System.__Canon].Start(!!0&amp;)                                                        2.7     533,767,168
|    | + Microsoft.CodeAnalysis.Workspaces!SymbolTreeInfo.TryGetInfoForMetadataReferenceAsync                                                                2.7     533,767,168
</Description>
    <CreatedDate>03/11/2016</CreatedDate>
    <ClosedDate>06/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23584</IssueID>
    <RepoID>1</RepoID>
    <Title>Span&lt;T&gt; stackalloc IntelliSense</Title>
    <Description>**Version Used**: 

VS 15.5.0

**Steps to Reproduce**:

1. type `Span&lt;byte&gt; s = stac`...
2. Ctrl + Space

**Expected Behavior**:

C# 7.2 introduce safe `stackalloc` with the `Span&lt;T&gt;` struct. So `stackalloc` keyword should be listed in the IntelliSense window.

**Actual Behavior**:

![image](https://user-images.githubusercontent.com/3760955/33609970-6794aab0-da0d-11e7-879a-aed381229fbe.png)
</Description>
    <CreatedDate>05/12/2017</CreatedDate>
    <ClosedDate>21/12/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23499</IssueID>
    <RepoID>1</RepoID>
    <Title>Disallow `default` as a constant pattern.</Title>
    <Description>The LDM has tentatively decided to disallow a `default` keyword (literal) as a constant pattern, in order to reduce confusion with "default" cases in switch statements and expressions. A programmer can always write `null`, `0`, or `'\0'` instead. This is technically a breaking change.

In a switch statement, the case label
`case default:`
is proposed to produce an error something like
`error CS8313: A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.`
We already produce approximately this diagnostic, but as a warning.

In an _is-pattern_ expression and other places where patterns appear
`e is default`
is proposed to produce an error something like
`error CS8405: A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.`

This will need review from the compatibility council.
</Description>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>10/12/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15673</IssueID>
    <RepoID>1</RepoID>
    <Title>Performance test: Typing responsiveness</Title>
    <Description>Create tests for C#/VB that:

Load a language-specific snapshot of Roslyn.sln. 
Navigate to a particular file.
Type text using the custom delay typing files collected during the Dev14 timeframe.

The test should measure how long each keystroke takes to enter the editor.
</Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23020</IssueID>
    <RepoID>1</RepoID>
    <Title>Generation of the GetHashCode method of anonymous types is not deterministic</Title>
    <Description>**Version Used**: 
Commit 72b8f88b0d

**Steps to Reproduce**:

1. Create the following .cs file:
```
class Program
{
    static void Main()
    {
        var a = new { a = 4 };
    }
}
```
2. Compile it with core MSBuild
3. Copy the output .dll elsewhere and compile it again
4. Alternatively, use csc and set the `deterministic` flag:
`dotnet csc.dll Program.cs /target:library /deterministic /noconfig /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Collections.dll" /reference:"C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.0.0\ref\netcoreapp2.0\System.Runtime.dll"`

**Expected Behavior**:
The compiler should produce the exact same output both times.

**Actual Behavior**:
The compiler's output differs every time.
If the net46 csc build is used, the compiler produces the same output each time it is run.

**Reason**:
The difference comes from the GetHashCode method of the created anonymous type. Here's the IL from two separate compiles.
```
  .method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0x1af3bd32
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```
```
.method public hidebysig virtual instance int32 
          GetHashCode() cil managed
  {
    // Code size       29 (0x1d)
    .maxstack  8
    IL_0000:  ldc.i4     0xc61810dc
    IL_0005:  ldc.i4     0xa5555529
    IL_000a:  mul
```

One of the constants used in the hash method changes every time. This is because Roslyn uses the hash codes of the backing fields of anonymous types to generate the above constant. ([Code here](https://github.com/dotnet/roslyn/blob/72b8f88b0daf42e1a8b1d6687cbfc9ccbb0cc21a/src/Compilers/CSharp/Portable/Compiler/AnonymousTypeMethodBodySynthesizer.cs#L190))

This isn't a problem in .NET Framework because [randomized string hashing](https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element) is disabled by default. However, it's enabled by default in coreclr, so identical strings will give different hash codes each time the process is run, creating non-deterministic IL code.</Description>
    <CreatedDate>06/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23100</IssueID>
    <RepoID>1</RepoID>
    <Title>The C# compiler failed to compile "obj is byte*[]" form</Title>
    <Description>**Version Used**: 
Visual Studio 2017
C#7.1
.NET Framework 4.7

**Steps to Reproduce**:

1. Try to compile this code:
```C#
namespace Test
{
    static unsafe class Program
    {
        static void Main()
        {
            object obj = new byte*[10];
            bool b = obj is byte*[];
        }
    }
}
```

**Expected Behavior**:
Compile success.

**Actual Behavior**:
Program.cs(8,20,8,24): error CS1525: Invalid expression term 'byte'
Program.cs(8,25,8,26): error CS1525: Invalid expression term '['
Program.cs(8,26,8,27): error CS0443: Syntax error; value expected</Description>
    <CreatedDate>09/11/2017</CreatedDate>
    <ClosedDate>27/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22619</IssueID>
    <RepoID>1</RepoID>
    <Title>"x is var _" results in the expression being true without x being evaluated</Title>
    <Description>**Version Used**: 
C# 7.1, debug mode

**Steps to Reproduce**:
```cs
internal class Program
{
    private static void Main()
    {
        var test = new Program();
        var result = test.IsVarMethod();
        Console.WriteLine($"Result = {result}");
        Console.Read();
    }

    private int IsVarMethod() =&gt; ThrowingMethod() is var _ ? 1 : 0;
    private bool ThrowingMethod() =&gt; throw new Exception("Oh");
}
```

**Expected Behavior**:
I'd expect `ThrowingMethod()` to be invoked, resulting in an exception.

**Actual Behavior**:
The method, `IsVarMethod()`, returns `1` and no exception is thrown.

This only occurs if the `x is T y` expression uses the var pattern and a discard. Change `var` to `bool` or `_` to eg `y` and the method is invoked and the exception thrown. </Description>
    <CreatedDate>09/10/2017</CreatedDate>
    <ClosedDate>21/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22994</IssueID>
    <RepoID>1</RepoID>
    <Title>Wrong error message for `in ref` parameters</Title>
    <Description>**Version Used**: 
https://github.com/dotnet/roslyn/commit/7dfc2fa4ee55c7c8c391ddbfc3fc4312c0c617db

**Steps to Reproduce**:
https://sharplab.io/#v2:EYLgtghgzgLgpgJwDQxASwDZICYgNQA+AAgAwAERAjANwCwAUEQMwUBMZAwmQN4Nn8UWRACxkAsgAo0AOzII4AMzIyYygJQ8+AgL4NtQA===
```
using System;
public class C {
    public void M(in ref int i) {
    }
}
```
**Expected Behavior**:
```
error CS8328: The parameter modifier 'ref' cannot be used with 'in'
```
**Actual Behavior**:
```
error CS8328: The parameter modifier 'out' cannot be used with 'in'
```</Description>
    <CreatedDate>02/11/2017</CreatedDate>
    <ClosedDate>10/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22424</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixes #22381 - Use in for parameters and arguments</Title>
    <Description>Fixes #22381 - Use `in` for parameters and arguments</Description>
    <CreatedDate>29/09/2017</CreatedDate>
    <ClosedDate>29/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22641</IssueID>
    <RepoID>1</RepoID>
    <Title>Marshalling methods with `in` parameters should have [In] attribute</Title>
    <Description>As an optimization, compiler should place `[InAttribute]` if user didn't on `in` parameters in marshaling methods. This saves an extra copy by the run-time on method return. because right now, it is treated as an ordinary `ref`, and the value is copied in and out.

cc @tannergooding @jcouv </Description>
    <CreatedDate>10/10/2017</CreatedDate>
    <ClosedDate>16/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22830</IssueID>
    <RepoID>1</RepoID>
    <Title>Dictionary with Func with DateTime does not compile (parsing error)</Title>
    <Description>```
using System;
using System.Collections.Generic;

namespace CompilerBug
{
    class Program
    {
        static void Main(string[] args)
        {
            new Dictionary&lt;int, Func&lt;int, bool&gt;&gt;
            {
                [0] = x =&gt; DateTime.UtcNow &lt; DateTime.UtcNow,
                [1] = x =&gt; true
            };
        }
    }
}

```


```
C:\source\repos\CompilerBug&gt;dotnet build
Microsoft (R) Build Engine version 15.5.160.37545 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

Program.cs(13,21): error CS1031: Type expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,1): error CS1031: Type expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,18): error CS1001: Identifier expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,21): error CS1003: Syntax error, '&gt;' expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]

Build FAILED.

Program.cs(13,21): error CS1031: Type expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,1): error CS1031: Type expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,18): error CS1001: Identifier expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
Program.cs(13,21): error CS1003: Syntax error, '&gt;' expected [C:\source\repos\CompilerBug\CompilerBug\CompilerBug.csproj]
    0 Warning(s)
    4 Error(s)

Time Elapsed 00:00:01.87
```

Doing any of the following will make it compile.
-Changing the `&lt;` sign to `&gt;` 
-Changing the `&lt;` sign to `==`
-Removing the line ` [1] = x =&gt; true`
-Adding `&amp;&amp; true` to the expression `DateTime.UtcNow &lt; DateTime.UtcNow`

```
C:\source\repos\CompilerBug&gt;dotnet --info
.NET Command Line Tools (2.1.1-preview-007094)

Product Information:
 Version:            2.1.1-preview-007094
 Commit SHA-1 hash:  f657648f07

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.15063
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.1-preview-007094\

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.0
```

</Description>
    <CreatedDate>24/10/2017</CreatedDate>
    <ClosedDate>07/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22768</IssueID>
    <RepoID>1</RepoID>
    <Title>IDE0007 reported for stackalloc to Span&lt;T&gt;</Title>
    <Description>**Version Used**: 15.5 Preview 1

**Steps to Reproduce**:

```csharp
Span&lt;int&gt; span = stackalloc int[3];
```

**Expected Behavior**:

IDE0007 is not reported, because a change to use `var` also changes the type of `span`.

**Actual Behavior**:

IDE0007 is reported, and the code fix causes the code to break.</Description>
    <CreatedDate>19/10/2017</CreatedDate>
    <ClosedDate>03/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22385</IssueID>
    <RepoID>1</RepoID>
    <Title>Generate Property CodeAction should know about ref-readonly-ness</Title>
    <Description>After `in` is implemented at call-site, the IDE will be able to know if it was in a ref-readonly context or not, therefore, it can generate a property with that `RefKind`.
This means that `GenerateVariableCodeAction` should accept a `RefKind` in the constructor, and not just `bool _returnsByRef`. Also, the following test should pass if added to `GenerateVariableTests.cs`:

```csharp
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsGenerateVariable)]
        public async Task TestGeneratePropertyInRefReadOnly()
        {
            await TestInRegularAndScriptAsync(
@"
using System;
class Class
{
    void Method(ref readonly int i)
    {
        Method(in this.[|goo|]);
    }
}",
@"
using System;
class Class
{
    public ref readonly int goo =&gt; throw new NotImplementedException();

    void Method(ref readonly int i)
    {
        Method(in this.goo);
    }
}", index: 2);
        }
```

cc @VSadov </Description>
    <CreatedDate>27/09/2017</CreatedDate>
    <ClosedDate>24/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22472</IssueID>
    <RepoID>1</RepoID>
    <Title>Change ArgumentSyntax.RefOrOutKeyword to RefKindKeyword</Title>
    <Description>And add overloads for compatibility.
Fixes #22441

This is an API change that reflects the presence of a new ref mode for arguments.

@dotnet/roslyn-compiler @AnthonyDGreen @jaredpar Please review.
@jcouv for 15.5 approval.</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>17/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22640</IssueID>
    <RepoID>1</RepoID>
    <Title>Users should not be allowed to place [Out] on `in` parameters</Title>
    <Description>```csharp
public class C {
    public void M([Out] in int x) {
    }
}
```
**Expected:** a compiler error.
**Actual:** attribute is emitted.

cc @jcouv @tannergooding </Description>
    <CreatedDate>10/10/2017</CreatedDate>
    <ClosedDate>16/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22564</IssueID>
    <RepoID>1</RepoID>
    <Title>ref and readonly structs should be displayed in IDE</Title>
    <Description>For both types, quickinfo and symbol display should be able to hint if they're annotated with `ref` and `readonly` keywords or not.

**Current behavior:**

![image](https://user-images.githubusercontent.com/15987992/31255870-0a4f2000-a9e4-11e7-89e2-2f5b153dce6e.png)

@VSadov 's comment on #19421 

&gt; After working with actual ref structs, I am convinced that ref must be surfaced in the symbol display.
&gt; When chasing through an escape violation, it would be useful to know which types are ref structs and which are not.
&gt; Also consider "readonly". It may be useful too, but also longer...</Description>
    <CreatedDate>05/10/2017</CreatedDate>
    <ClosedDate>23/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22206</IssueID>
    <RepoID>1</RepoID>
    <Title>EE escape analysis crashes when compiling lambdas</Title>
    <Description>Code:

```csharp
namespace ConsoleApp3
{
    public delegate ref  int D();

    class Program
    {
        static void Main(string[] args)
        {
            int x = 0;
        }

        static ref  int M(D lambda)
        {
            return ref lambda();
        }
    }
}
```

Put a breakpoint after `int x = 0` in `Main()`, and F5. When it hits, evaluate the expression `M(() =&gt; ref x)`.

**Expectation:**  error CS8168: Cannot return local 'x' by reference because it is not a ref local
**Actual:** compiler crashes because `RefEscapeScope` is not implemented for EE symbols.

**Suggestion**: Both `RefEscapeScope` and `ValEscapeScope` should be abstracted and implemented wherever possible, instead of throwing an unreachable exception.</Description>
    <CreatedDate>19/09/2017</CreatedDate>
    <ClosedDate>30/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22450</IssueID>
    <RepoID>1</RepoID>
    <Title>IDE visualizes span as [deprecated]</Title>
    <Description>![image](https://user-images.githubusercontent.com/8218165/31048319-795b052c-a5cf-11e7-91b3-bbda0edc7f12.png)

The Obsolete attributes on ref-like types are a part of compiler/runtime handshake and should not be visualized when follow the pattern.

I am not sure on what side this is - symbol display or some higher IDE level, but these obsolete should be filtered out.</Description>
    <CreatedDate>30/09/2017</CreatedDate>
    <ClosedDate>11/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22504</IssueID>
    <RepoID>1</RepoID>
    <Title>Hide [deprecated] quick info on ref-like types</Title>
    <Description>Fixes #22450

@dotnet/roslyn-compiler @dotnet/roslyn-ide for code review
@gafter for API review
@jaredpar for ask mode approval</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>04/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22454</IssueID>
    <RepoID>1</RepoID>
    <Title>Keyword recommender needs adjustments for "in" arguments</Title>
    <Description>![image](https://user-images.githubusercontent.com/8218165/31048699-92bb01f4-a5d7-11e7-984e-72f3d22099c0.png)

No "in" in the completion list.</Description>
    <CreatedDate>30/09/2017</CreatedDate>
    <ClosedDate>03/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20103</IssueID>
    <RepoID>1</RepoID>
    <Title>The given expression is never of the provided type when pattern matching is used</Title>
    <Description>**Version Used**: 2.3.0.61719 (5fbdd5c5)

**Steps to Reproduce**:

```csharp
class C
{
	static object Test ()
	{
		const object o = null;
		return o is object res; // Removing unused res shows the warning
	}

	static void Main ()
	{
	}
}
```

**Expected Behavior**:

`warning CS0184: The given expression is never of the provided ('object') type` is issued or even CS8121 error to be consistent with other pattern matching checks.

**Actual Behavior**:

No warning CS0184
</Description>
    <CreatedDate>08/06/2017</CreatedDate>
    <ClosedDate>11/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18348</IssueID>
    <RepoID>1</RepoID>
    <Title>False positive "Using directive is unnecessary" in partial classes</Title>
    <Description>**Version Used**: 
VS 2017 (15.0.26228.10) / Roslyn 2.0.0

**Steps to Reproduce**:

Partial class file 1:
```C#
using RoslynCodeAnalysisTests.Attributes;

namespace RoslynCodeAnalysisTests
{
    public partial class PartialClass
    {
        partial void PartialMethod([MyAttr] string a)
        {
        }
    }
}
```

Partial class file 2:
```C#
using RoslynCodeAnalysisTests.Attributes;

namespace RoslynCodeAnalysisTests
{
    [MyAttr]
    public partial class PartialClass
    {
        partial void PartialMethod(string a);
    }
}
```

=&gt; Roslyn shows "Using directive is unnecessary" in file 1 for `using RoslynCodeAnalysisTests.Attributes` which is wrong.

![image](https://cloud.githubusercontent.com/assets/388796/24554311/59f8c318-162d-11e7-9ff8-1dfdc1755065.png)


**Expected Behavior**:
Do not show "Using directive is unnecessary". It makes my compilation failing when doing this.

BTW: When executing the corresponding quick-fix it doesn't change anything.
</Description>
    <CreatedDate>31/03/2017</CreatedDate>
    <ClosedDate>01/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20210</IssueID>
    <RepoID>1</RepoID>
    <Title>Inconsistent error CS8120: The switch case has already been handled by a previous case.</Title>
    <Description>**Version Used**: 
VisualStudio.15.Preview/15.3.0-Preview+26510.0

**Steps to Reproduce**:

Consider the following code:

```cs
class Program
{
  public static void Main()
  {
    switch (default(object)) // OK
    {
      case bool _:
      case true:
      case false:
        break;
    }

    switch (new object()) // errors
    {
      case bool _:
      case true:
      case false:
        break;
    }

    switch ((object)null) // OK
    {
      case bool _:
      case true:
      case false:
        break;
    }

    switch ((bool?)null) // OK
    {
      case bool _:
      case true:
      case false:
        break;
    }

    switch (default(bool?)) // errors
    {
      case bool _:
      case true:
      case false:
        break;
    }

    switch (default(bool)) // errors
    {
      case bool _:
      case true:
      case false:
        break;
    }
  }
}
```

**Expected Behavior**:
```
error CS8120: The switch case has already been handled by a previous case.
```
is reported either for each switch statement in the program or for neither of them.

**Actual Behavior**:
the error is reported only for some of switch statements in the program.
It is reported for switches over `new object()`, `default(bool?)` and `default(bool)` but not for switches over `default(object)`, `(object)null`, `(bool?)null`.</Description>
    <CreatedDate>14/06/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22242</IssueID>
    <RepoID>1</RepoID>
    <Title>Implement Interface loses "ref readonly"</Title>
    <Description>Implement interface refactoring loses "ref readonly" on parameters. 

Inherit from abstract class does this too. </Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22241</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace lambda with local function loses "ref readonly"</Title>
    <Description>```cs
        delegate ref readonly int D1(ref readonly int arg);

            D1 dd = (ref readonly int a) =&gt; ref a;
```

Replace dd with a local function using IDE. - loses "ref readonly"
</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22240</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Accessibility modifier removes "ref" from a ref struct</Title>
    <Description>
Invoke Refactor/Add Accessibility modifiers on 

```cs
readonly unsafe ref struct S1 { }
```
The dialog offers adding "private", but also offers to remove "ref"

</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22239</IssueID>
    <RepoID>1</RepoID>
    <Title>Change Signature does not show "ref readonly" modifier on parameters</Title>
    <Description>
The Change Signature  shows  other modifiers like "out" but not "ref readonly" - not sure if it does not understand it or because it simply does not fit. There is no much space in that UI.</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22238</IssueID>
    <RepoID>1</RepoID>
    <Title>Extract interface loses "ref readonly" on parameters and returns</Title>
    <Description>
parameters become an ordinary `ref`, returns become ordinary byval returns.</Description>
    <CreatedDate>21/09/2017</CreatedDate>
    <ClosedDate>28/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16968</IssueID>
    <RepoID>1</RepoID>
    <Title>VBCompiler- With Statement with Inline Sub</Title>
    <Description>Following VBCode raises a null exception in the inline eventhandler:

```VB
Module Module1

    Private f As Foo 'global. prevent GC

    Sub Main()

        f = New Foo()
        With f
            AddHandler .Baz, Sub(s, e)
                                 .Bar = "" ' null exception
                             End Sub
        End With

        f.RaiseBaz()

        Console.ReadKey()

    End Sub

End Module

Class Foo

    Public Property Bar As String

    Public Event Baz As EventHandler(Of EventArgs)

    Public Sub RaiseBaz()
        RaiseEvent Baz(Me, New EventArgs())
    End Sub

End Class
```

The Compiler-Output of this code is:

```VB
Namespace _VBCompilerBug_WithInlineAddHandler
	Friend Module Module1
		&lt;CompilerGenerated()&gt;
		Friend Class _Closure$__1-0
			Public $W2 As Foo

			Friend Sub _Lambda$__0(s As Object, e As EventArgs)
				Me.$W2.Bar = ""
			End Sub
		End Class

		Private f As Foo

		&lt;STAThread()&gt;
		Public Sub Main()
			Module1.f = New Foo()
			Dim $W2 As Foo = Module1.f
			AddHandler $W2.Baz, Sub(s As Object, e As EventArgs)
				$W2.Bar = ""
			End Sub
			$W2 = Nothing
			Module1.f.RaiseBaz()
			Console.ReadKey()
		End Sub
	End Module
End Namespace
```

**Version Used**: Visual Studio 2015 + .NET Framework 4.6

**Steps to Reproduce**:

1. Create a new VB Console project with Framework 4.6
2. Insert the code above
3. Click on Run

**Expected behavior**:
- Compiler error in the inline eventhandler. So i have to use `f.Bar = ""` instead of `.Bar = ""`
- Or Working code




</Description>
    <CreatedDate>06/02/2017</CreatedDate>
    <ClosedDate>21/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21935</IssueID>
    <RepoID>1</RepoID>
    <Title>csc 2.3.0 regression: pdb path emitted to PE file even when pdb generation is disabled</Title>
    <Description>**Version Used**: 

This is a regression introduced between 2.3.0.61801 (3722bb71) and 2.3.0.61703 (8f02e048). Most likely by https://github.com/dotnet/roslyn/commit/b66f68c485fb1c6bbfa69c62490ff47d37d5dae5 (/cc @jaredpar).

**Steps to Reproduce**:

Test file:

```csharp
using System;

namespace cscpathbug
{
    public class Class1
    {
    }
}
```

1. Compile with csc 2.3.0-beta2 (note the `-debug-` option to turn off PDB generation):
```
csc.exe -deterministic -debug- -target:library Class1.cs
```
2. Observe that the path to the (non-existing) pdb file is embedded in the PE:
```
$ strings Class1.dll | grep ".pdb"
/Users/alexander/dev/test/cscpathbug/Class1.pdb
```
3. Do the same with 2.3.0-beta1 or earlier versions and observe no path is embedded

**Expected Behavior**:

No path embedded in the PE file when debug symbols are turned off.

**Actual Behavior**:

Path embedded in the PE file no matter what the `debug` option is set to.</Description>
    <CreatedDate>06/09/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>9861</IssueID>
    <RepoID>1</RepoID>
    <Title>Attempt to diagnose the flakiness in TestTagsChangesForEntireFile</Title>
    <Description>I'm unable to figure out what is going wrong here. My best guess is that
a second workspace event happens before the text changes that causes
classification to refresh while still on the original snapshot.

This adds some additional diagnostics to our test to try to identify that.

Also changes CheckPoint.Release to CheckPoint.TryRelease, so that it's
possible to observe if someone else already caused the checkpoint task to
complete.

Related to #9723.

(tag @dotnet/roslyn-ide @dotnet/roslyn-infrastructure @jaredpar for review)
</Description>
    <CreatedDate>17/03/2016</CreatedDate>
    <ClosedDate>29/03/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21673</IssueID>
    <RepoID>1</RepoID>
    <Title>Add support for the CLI invoking Roslyn without CscToolPath</Title>
    <Description>The new `DotnetHost` class is the core of the logic here. It handles the following:

* If we're running under desktop, search for `csc.exe`, and don't touch the command line.
* If we're running under dotnet, search for `csc.dll`, and rewrite the command line to use `dotnet` as the process, and `csc.dll` as the first command line argument.

Additionally, add `&lt;task dll path&gt;/bincore/&lt;search name&gt;` to the list of paths searched. This corresponds to the way the `Microsoft.NETCore.Compilers` package is laid out.

The logic to detect which case we're in could be refined. Currently in this PR, this is the logic:

* If the environment variable `DOTNET_HOST_PATH` is set, assume we're running under `dotnet`, and use that as the path to the `dotnet` process (the presence/meaning of that environment variable was discussed in other PRs/issues)
* Otherwise, assume we're running under desktop.

We could multitarget the build task: the above logic would fail if we're actually running under desktop, and `DOTNET_HOST_PATH` is set to something silly. However, I feel like this is a good first revision.

I have left the `RunCsc` scripts in this repo, as they should still function (and, before being updated, CLI still needs them).

The above is identical for VB - swap out csc for vbc where appropriate.

---

These changes were manually tested in the CLI, using this build of Roslyn as a local package source. I wish there was a better way to test :(

Additionally, I have changes in the CLI that removes all setting of `CscHostPath`, and will submit that once these changes are in a Roslyn nuget.

---

This change is part of a larger process to reduce coupling of Roslyn and the CLI. Once this is in, we can begin to modify the msbuild task to use a new cross-plat compiler server, etc.

Ping @jaredpar as an FYI (and also reviewer).</Description>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>06/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21371</IssueID>
    <RepoID>1</RepoID>
    <Title>MSBuild parameter /p:GenerateDocumentation=false getting ignored</Title>
    <Description>_From @Styxxy on August 7, 2017 9:48_

Hi,

I use TFS Build agen on premise and I have configured my solution build to include the MSBuild parameter /p:GenerateDocumentation=false (as this is an internally deployed solution). However I notice that the XML documentation files are still being generated by the Roslyn compiler.

Do I need to use another MSBuild swith to (globally) disable the XML documentation generation?

Command line :

"D:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\15.0\Bin\msbuild.exe" "D:\Agent1\_work\12\s\Build\A\Solutions\MyBuild.sln" /nologo /nr:false /dl:CentralLogger,"D:\Agent1\_work\_tasks\VSBuild_71a9a2d3-a98a-4caa-96ab-affca411ecda\1.119.0\ps_modules\MSBuildHelpers\Microsoft.TeamFoundation.DistributedTask.MSBuild.Logger.dll";"RootDetailId=f4898fed-92af-4959-8a0a-a738cf06b707|SolutionDir=D:\Agent1\_work\12\s\Build\A\Solutions"*ForwardingLogger,"D:\Agent1\_work\_tasks\VSBuild_71a9a2d3-a98a-4caa-96ab-affca411ecda\1.119.0\ps_modules\MSBuildHelpers\Microsoft.TeamFoundation.DistributedTask.MSBuild.Logger.dll" /p:OutDir=D:\Agent1\_work\12\b\MyBuild /p:AllowedReferenceRelatedFileExtensions=".pdb" /p:GenerateDocumentation=false /p:platform="Any CPU" /p:configuration="Release" /p:VisualStudioVersion="15.0" /p:_MSDeployUserAgent="TFS_f34008ba-370e-492f-9e2b-88fef545c6c0_build_1073_50124"

In the MSBuild output I find following info :

```
CoreCompile:
  D:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\15.0\Bin\Roslyn\vbc.exe /noconfig /imports:Microsoft.VisualBasic,System,System.Collections,System.Collections.Generic,System.Data,System.Diagnostics,System.Linq,System.Xml.Linq /doc- /optioncompare:Binary /optionexplicit+ /optionstrict+ /optioninfer+ /nostdlib /rootnamespace:AA /sdkpath:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2" /highentropyva+ /doc:obj\Release\A.xml /define:"CODE_ANALYSIS=-1,CONFIG=\"Release\",TRACE=-1,_MyType=\"Windows\",PLATFORM=\"AnyCPU\"" /reference:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Core.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Data.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Runtime.Serialization.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.ServiceModel.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Xml.dll","C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2\System.Xml.Linq.dll" /debug:pdbonly /filealign:512 /optimize+ /out:obj\Release\A.dll /subsystemversion:6.00 /resource:obj\Release\A.Resources.resources /target:library /utf8output MyCode.vb "My Project\AssemblyInfo.vb" "My Project\Application.Designer.vb" "My Project\Resources.Designer.vb" "My Project\Settings.Designer.vb" "C:\Users\TFSBUILD\AppData\Local\Temp\.NETFramework,Version=v4.5.2.AssemblyAttributes.vb" /warnaserror+:41999,42016,42017,42018,42019,42020,42021,42022,42032,42036
  Using shared compilation with compiler from directory: D:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\15.0\Bin\Roslyn
  
CopyFilesToOutputDirectory:
  Copying file from "obj\Release\A.dll" to "D:\Agent1\_work\12\b\MyBuild\A.dll".
  A -&gt; D:\Agent1\_work\12\b\MyBuild\A.dll
  Copying file from "obj\Release\A.pdb" to "D:\Agent1\_work\12\b\MyBuild\A.pdb".
  Copying file from "obj\Release\A.xml" to "D:\Agent1\_work\12\b\MyBuild\A.xml".
```

With kind regards,
Hans

_Copied from original issue: Microsoft/msbuild#2403_</Description>
    <CreatedDate>08/08/2017</CreatedDate>
    <ClosedDate>14/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21692</IssueID>
    <RepoID>1</RepoID>
    <Title>Generate constructor refactoring generate delegate constructor with circular calls</Title>
    <Description>**Version Used**: 
VS 2017 15.3
**Steps to Reproduce**:

```csharp
    class C
    {
        public C(int a) : this(1, 2)
        {
        }
    }
```

**Expected Behavior**:
```csharp
    class C
    {
        private int v;

        public C(int a) : this(1, 2)
        {
        }

        public C(int a, int v)
        {
            this.v = v;
        }
    }
```
**Actual Behavior**:
```csharp
    class C
    {
        private int v;

        public C(int a) : this(1, 2)
        {
        }

        public C(int a, int v) : this(a)
        {
            this.v = v;
        }
    }
```</Description>
    <CreatedDate>23/08/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21687</IssueID>
    <RepoID>1</RepoID>
    <Title>Introduce constant field refactoring produce not compiled code if namespace name is equal to class name </Title>
    <Description>**Version Used**: 
VS 2017 15.3
**Steps to Reproduce**:

```csharp
namespace Program
{
    class Program
    {
        void M()
        {
            var t = new { foo = 1 + 1 };
        }
    }
}
```

**Expected Behavior**:
```csharp
namespace Program
{
    class Program
    {
        private const int V = 1 + 1;

        void M()
        {
            var t = new { foo = V };
        }
    }
}
```
**Actual Behavior**:
```csharp
namespace Program
{
    class Program
    {
        private const int V = 1 + 1;

        void M()
        {
            var t = new { foo = Program.Program.V };
        }
    }
}
```</Description>
    <CreatedDate>23/08/2017</CreatedDate>
    <ClosedDate>12/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21665</IssueID>
    <RepoID>1</RepoID>
    <Title>Extract Local refactoring: variable name should be equal to value tuple field name</Title>
    <Description>**Version Used**: 
current master branch
**Steps to Reproduce**:

```csharp
var tuple = (key: "key", value: DateTime.Now.ToString());
```

**Expected Behavior**:
```csharp
var value = DateTime.Now.ToString();
var tuple = (key: "key", value: value);
```
**Actual Behavior**:
```csharp
var value1 = DateTime.Now.ToString();
var tuple = (key: "key", value: value1);
```</Description>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21317</IssueID>
    <RepoID>1</RepoID>
    <Title>Calling a generic local function with a dynamic parameter produces a BadImageFormatException</Title>
    <Description>**Version Used**: Roslyn 2.0

**Steps to Reproduce**:

1. Write the following lines of code in a method
```
GenericLocal((dynamic)"");
void GenericLocal&lt;T&gt;(T val) {}
```
2. Invoke the method

**Expected Behavior**:

GenericLocal should be invoked, with `string` as `T`.

**Actual Behavior**:

BadImageFormatException: An attempt was made to load a program with an incorrect format. (Exception from HRESULT: 0x8007000B)

------

I described this on a [StackOverflow post](https://stackoverflow.com/questions/45495869) and the general consensus was that I'd found a bug. Note that the stacktrace shows the exception being thrown inside the method with this code, but no code actually gets run before the exception occurs.
</Description>
    <CreatedDate>04/08/2017</CreatedDate>
    <ClosedDate>14/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21136</IssueID>
    <RepoID>1</RepoID>
    <Title>Potential parameter switch in AssemblyResolution.TryRedirect</Title>
    <Description>**Version Used**: 
Source code on master [AssemblyResolution.TryRedirect](https://github.com/dotnet/roslyn/blob/master/src/Compilers/Core/MSBuildTask/AssemblyResolution.cs#L79).

**Expected Behavior**:
The `Version` class constructor with [4 parameters](https://msdn.microsoft.com/en-us/library/kstyaxxh(v=vs.110).aspx) is defined with the following order major, minor, build and revision so it is likely that the code is wrong and should be defined as the following:
`var version = new Version(major, minor, build, revision);`

**Actual Behavior**:
`var version = new Version(major, minor, revision, build);`</Description>
    <CreatedDate>26/07/2017</CreatedDate>
    <ClosedDate>02/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20693</IssueID>
    <RepoID>1</RepoID>
    <Title>Literal should escape surrogate unicode</Title>
    <Description>**Version Used**: 2.2

**Steps to Reproduce**:

1. Run following code:

    ```cs
    var sw = new StreamWriter(new MemoryStream());
    sw.Write(SyntaxFactory.LiteralExpression(
        SyntaxKind.CharacterLiteralExpression,
        SyntaxFactory.Literal('\uDBFF')));
    sw.Flush();
    ```

**Expected Behavior**:
'\uDBFF'

**Actual Behavior**:
System.Text.EncoderFallbackException: Unable to translate Unicode character \uDBFF at index 1 to specified code page.

https://github.com/dotnet/docfx/issues/1817</Description>
    <CreatedDate>07/07/2017</CreatedDate>
    <ClosedDate>31/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27060</IssueID>
    <RepoID>1</RepoID>
    <Title>Assert in SemanticModel on typing invalid collection initializer</Title>
    <Description>Typed in this invalid code (cursor expression shows where my cursor was, had just typed the 2):
```C#
using System.Collections.Generic;

interface I : IEnumerable&lt;int&gt;
{
    void Add(int i);
}

class C
{
    void M()
    {
        I i = new I() { 1, 2[||]}
    }
}
```
Got this stack trace:
```
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 584	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 329	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 1729	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2141	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 60	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node) Line 1815	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node) Line 457	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, out Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode bindableNode, out Microsoft.CodeAnalysis.CSharp.BoundNode lowestBoundNode, out Microsoft.CodeAnalysis.CSharp.BoundNode highestBoundNode, out Microsoft.CodeAnalysis.CSharp.BoundNode boundParent) Line 1200	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 1090	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 310	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken) Line 864	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 4555	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 4628	C#
 	Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 322	C#
 	Microsoft.CodeAnalysis.dll!Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Threading.CancellationToken cancellationToken) Line 60	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext context) Line 45	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan state, Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider provider, Microsoft.CodeAnalysis.Extensions.IExtensionManager extensionManager, System.Threading.CancellationToken cancellationToken) Line 142	C#
 	Microsoft.CodeAnalysis.Features.dll!Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.HasRefactoringsAsync(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.Text.TextSpan state, System.Threading.CancellationToken cancellationToken) Line 80	C#
```</Description>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>31/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20583</IssueID>
    <RepoID>1</RepoID>
    <Title>Inference failure for tuple type vs tuple underlying type (regression)</Title>
    <Description>The following correct program compiles successfully in VS2015, but fails to compile in VS2017:

``` c#
using System;
public class C
{
    public static void Main()
    {
        // var b = (1, 2, 3, 4, 5, 6, 7, 8);
        var b = new ValueTuple&lt;int, int, int, int, int, int, int, ValueTuple&lt;int&gt;&gt;(1, 2, 3, 4, 5, 6, 7, new ValueTuple&lt;int&gt;(8));
        M1(b);
    }
    public static void M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; a) where TRest : struct { Console.Write(1); }
}
```

with the following error

``` none
Error CS0411: The type arguments for method 'C.M1&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;(ValueTuple&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
```
</Description>
    <CreatedDate>30/06/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20452</IssueID>
    <RepoID>1</RepoID>
    <Title>"Neither 'is' nor 'as' are valid on void type"</Title>
    <Description>**Version Used**: Visual Studio Enterprise 2017 15.2 (26430.12), .NET Framework 4.6.2

Consider the following line of code:
```c#
bool b = Console.Write("A") is var _;
```
Visual Studio shows a red squiggle with the following error:
&gt;Neither 'is' nor 'as' are valid on void type

However, the code successfully builds. 

I suspect this is not the desired behavior.</Description>
    <CreatedDate>26/06/2017</CreatedDate>
    <ClosedDate>05/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20395</IssueID>
    <RepoID>1</RepoID>
    <Title>ref extension methods should require 7.2</Title>
    <Description>It appears that ref extension methods work on 7.0

NOTE: `ref readonly this` requires 7.2 because `ref readonly` requires that, but `ref this` is ok with 7.0.

Repro:
Try recent build -

https://dotnet.myget.org/feed/roslyn/package/vsix/0b48e25b-9903-4d8b-ad39-d4cca196e3c7/2.6.0.6182203

direct link:
https://dotnet.myget.org/feed/roslyn/package/vsix/0b48e25b-9903-4d8b-ad39-d4cca196e3c7/2.6.0.6182203

The following works in a default console app (7.0), but it should demand 7.2

```C#
    public static class C1
    {
        public static void Ext(ref this Guid self, int arg)
        {

        }
    }
```</Description>
    <CreatedDate>22/06/2017</CreatedDate>
    <ClosedDate>19/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18633</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException inside Microsoft.CodeAnalysis.BuildTasks.Csc.AddResponseFileCommands()</Title>
    <Description>**Version Used**:
Microsoft.CodeAnalysis.* = 2.0.0
Visual Studio 2017
Inside .NET Framework 4.6.2 console application

**Steps to Reproduce**:

1. Install Microsoft.CodeAnalysis.CSharp.Workspaces into a .NET Framework 4.6.2 console application
2. Write the following code (the project being loaded here is a .NET Framework 4.6.2 library):
```
MSBuildWorkspace workspace = MSBuildWorkspace.Create();
workspace.OpenProjectAsync(@"E:\Code\Wyam\src\core\Wyam.Hosting\Wyam.Hosting.csproj").Result;
```

**Expected Behavior**:
The project loads into the workspace without problems.

**Actual Behavior**:
`workspace.Diagnostics` contains a diagnostic with the message `{[Failure] Msbuild failed when processing the file 'E:\Code\Wyam\src\core\Wyam.Hosting\Wyam.Hosting.csproj'}`

---

I first noticed this behavior in a more complex application that does run-time loading of project files into workspaces and logs any diagnostic messages. I was getting a ton of these `Msbuild failed when processing` messages, though they didn't seem to actually stop the project file from loading. I figured I'd attempt to reproduce in a simple application to make sure it wasn't something with my host (I do a lot of crazy assembly stuff, so I was concerned that was messing it up). I was able to repro:

![2017-04-12_11h48_51](https://cloud.githubusercontent.com/assets/1020407/24967233/700a943a-1f77-11e7-8f21-8e5d77d3077a.png)

Exploring further, I turned on exception breaking at caught a `NullReferenceException` in `Microsoft.CodeAnalysis.BuildTasks.Csc.AddResponseFileCommands()`:

![2017-04-12_10h54_43](https://cloud.githubusercontent.com/assets/1020407/24967309/ae54c4f4-1f77-11e7-97d4-6730d473533a.png)

A couple points:
* Notice that the `Microsoft.Build.Tasks.CodeAnalysis.dll` assembly is coming from my Visual Studio 2017 folder. Even if I install `Microsoft.Net.Compilers` (disabling the MSBuild tasks that actually use that package for compilation of the host application) and copy the `Microsoft.Build.Tasks.CodeAnalysis.dll` assembly out of the tools folder and into the bin, it still binds to the version in the Visual Studio 2017 path.
* The PDB and source code here is decompiled from the assembly in the Visual Studio 2017 path that I'm apparently linking to.
* I've highlighted the line I think is throwing the NRE.

My best guess (and I could be totally off) is that there's a type mismatch in here somewhere between the `ICscHostObject` interface we're trying to cast to and the actual one implemented by `this.HostObject` (which is a `CSharpCompilerInputs`). The cast fails and we get the NRE.
</Description>
    <CreatedDate>12/04/2017</CreatedDate>
    <ClosedDate>13/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18477</IssueID>
    <RepoID>1</RepoID>
    <Title>Invalid error message on passing in parameters by ref</Title>
    <Description>```csharp
public class C {
    public void M(ref readonly int x) {
    }
    
    public void User() {
        int x = 0;
        M(x);     // OK
        M(ref x); // ERROR
    }
}
```

**Expected**: error CS1620: Argument 1 must be passed **_without_** the 'ref' keyword
**Actual**: error CS1620: Argument 1 must be passed **_with_** the 'in' keyword
</Description>
    <CreatedDate>05/04/2017</CreatedDate>
    <ClosedDate>19/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26721</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failure: StaticNullChecking.SuppressNullableWarning_InvalidOperand</Title>
    <Description>Test failure in windows_debug_spanish_unit32_prtest:
```
Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics.StaticNullChecking.SuppressNullableWarning_InvalidOperand (from Roslyn.Compilers.CSharp.Semantic.UnitTests)
Diff:
++&gt;                 Diagnostic(ErrorCode.ERR_BadArgType, \"F!\").WithArguments(\"1\", \"grupo de métodos!\", \"object\").WithLocation(5, 11),
--&gt;                 Diagnostic(ErrorCode.ERR_BadArgType, \"F!\").WithArguments(\"1\", \"method group!\", \"object\").WithLocation(5, 11),
                    Diagnostic(ErrorCode.ERR_PropertyLacksGet, \"c.P\").WithArguments(\"C.P\").WithLocation(6, 11)
```</Description>
    <CreatedDate>08/05/2018</CreatedDate>
    <ClosedDate>06/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37624</IssueID>
    <RepoID>1</RepoID>
    <Title>Generate IOperation Interfaces and OperationKind enum</Title>
    <Description>I've had generating IOperations on my backlog for a long time now, and as part of ripping out the laziness in IOperation I think it's a good time to finally accomplish it. This is the first in a series of PRs to accomplish this, generating _just_ the IOperation interfaces themselves and the OperationKind enum.

I highly, highly, highly, super highly, seriously recommend reviewing this commit by commit:
* Commit 1 introduces the generation structure and generates the interfaces and enum _in place_. This allows for easy diffing of the changes that the generator makes compared to the existing definitions. By an large it's just whitespace, with a couple of small comment changes. No binary changes were introduced.
* Commit 2 moves the generated output from being in the original files to being in 3 files, one for each namespace we're generating. It also enables verification like we have for the bound nodes, so if changes are made to the files or the xml we'll get a CI error.

@dotnet/roslyn-compiler for review. /cc @mavasani @genlu.</Description>
    <CreatedDate>31/07/2019</CreatedDate>
    <ClosedDate>07/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13247</IssueID>
    <RepoID>1</RepoID>
    <Title>Suboptimal code for e is null</Title>
    <Description>Currently `e is null` translates to an `object.Equals` call on master. The question is that (1) does it meant to be a shorthand for explicit reference null check `(object)e == null`? If so, (2) shouldn't it just translate to a `ceq`? 
</Description>
    <CreatedDate>18/08/2016</CreatedDate>
    <ClosedDate>30/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19731</IssueID>
    <RepoID>1</RepoID>
    <Title>Bad code for pattern switch with constant expression</Title>
    <Description>The following produces code that does nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1()
    {
        switch (1)
        {
            case 0 when true:
                ;
            case 1:
                Console.Write(1);
                break;
            case 2:
                ;
        }
    }
```
</Description>
    <CreatedDate>23/05/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17090</IssueID>
    <RepoID>1</RepoID>
    <Title>Switch expression instrumentation not produced for constant expression in pattern switch</Title>
    <Description>Code generation for a pattern switch does not evaluate the switch expression at runtime when it is a constant. Consequently there is no place in the generated code for the compiler to generate the instrumentation, and the compiler does not produce instrumentation for the switch expression in this case. We should evaluate what the proper treatment of this situation should be.</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19734</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect code for generic pattern switch on a constant expression</Title>
    <Description>The following produces incorrect code. When `T` is `long`, it prints nothing.

This is a regression in master versus the most recent update.

``` c#
    static void M1&lt;T&gt;()
    {
        switch (1)
        {
            case T t:
                Console.Write(1);
                break;
            case int i:
                Console.Write(2);
                break;
        }
    }
```

This is a new issue in 15.3, as the code was illegal previously.
</Description>
    <CreatedDate>23/05/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16829</IssueID>
    <RepoID>1</RepoID>
    <Title>VB: TupleElementNamesAttribute is not emitted for property setter argument</Title>
    <Description>`TupleElementNamesAttribute` is not emitted for `set_P` or `set_Q`:
```
Class C
    Shared Property P As (x As Integer, y As Integer)
    Shared Property Q As (x As Integer, y As Integer)
        Get
            Return Nothing
        End Get
        Set
        End Set
    End Property
End Class
```</Description>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>27/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38874</IssueID>
    <RepoID>1</RepoID>
    <Title>#pragma warning disable nullable does not disable warning</Title>
    <Description>**Version Used**:
 VS Mac 8.3.0 - Roslyn 3.3.1-beta3-19454-05
VS Win 16.3

**Steps to Reproduce**:

Posted on the Developer Community forum:

https://developercommunity.visualstudio.com/content/problem/745884/vs-for-mac-does-not-respect-pragma-warning-nullabl.html

1. .NET Standard project with:
```
		&lt;LangVersion&gt;8.0&lt;/LangVersion&gt;
		&lt;Nullable&gt;enable&lt;/Nullable&gt;
```
2. Add a public property to a class in the project.
3. Warnings about a non-nullable property shown in the editor.
4. Add a pragma to disable the check.

```
public class Class1
{
#pragma warning disable nullable
        public string Foo { get; set; }
#pragma warning restore nullable
}
```

**Expected Behavior**:

The documentation indicates that this feature is available and should remove the warning shown in the text editor.

https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references#nullable-contexts

**Actual Behavior**:

The warning about the non-nullable property is still shown in the text editor.

Using `#nullable disable' at the top of the file works.
Using the code CS8618 instead of nullable in the disable pragma also works.

There are a few existing Roslyn issues which are possibly related:

https://github.com/dotnet/roslyn/issues/36550
https://github.com/dotnet/roslyn/issues/35747

Not sure if the documentation is incorrect here.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19310</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash in `is` operator used with tuple</Title>
    <Description>**Version Used**: 

VS2015 most recent update

**Steps to Reproduce**:

1. Type the following statements
``` c#
var x = (1, 2);
if (x is ValueTuple&lt;long, long&gt;) { }
```

**Expected Behavior**:

Compiler reports "warning, the given expression is never of the provided (long, long) type."

**Actual Behavior**:

Visual Studio crashes.
</Description>
    <CreatedDate>05/05/2017</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19151</IssueID>
    <RepoID>1</RepoID>
    <Title>Matching an expression of type `byte?` with a pattern of type `int` should not be allowed</Title>
    <Description>**Version Used**: 

15.3 (master)

**Steps to Reproduce**:

1. Compile the following
``` c#
    public static void M(byte? x)
    {
        switch (x)
        {
            case int i:
                Console.Write(i);
                break;
        }
    }
```

**Expected Behavior**:

Compile-time error "a value of type `byte?` can never be handled by a pattern of type `int`".

**Actual Behavior**:

Compiles with no error. Pattern never matches.
</Description>
    <CreatedDate>01/05/2017</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19273</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge subsumption implementations</Title>
    <Description>There are a few different implementations of subsumption in the patter-matching implementation:

- One in binding
- One related implementation for warning with the old-style operator `is`
- One in lowering

They should be consolidated. It is likely we can make things more precise in the process.</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16129</IssueID>
    <RepoID>1</RepoID>
    <Title>pattern matching with structs causes unnecessary boxing, nullable conversions</Title>
    <Description>```c#
using System;

class C
{
    static void Main()
    {
        if (TrySomething() is ValueTuple&lt;string, bool&gt; v &amp;&amp; v.Item2 == true)
        {
            System.Console.Write(v.Item1 == null);
        }
    }

    static (string Value, bool Success) TrySomething()
    {
        return (null, true);
    }
}
```

For the Main I'd expect to see an IL equivalent of

```C#
    static void Main()
    {
        {
            ValueTuple&lt;string, bool&gt; v = TrySomething();
            if (v.Item2 == true)
            {
                System.Console.Write(v.Item1 == null);
            }
        }
    }
```

instead I see (decompiled)
```C#
    private static void Main()
    {
        ValueTuple&lt;string, bool&gt;? valueTuple = (object)C.TrySomething() as ValueTuple&lt;string, bool&gt;?;
        ValueTuple&lt;string, bool&gt; valueOrDefault = valueTuple.GetValueOrDefault();
        bool flag = valueTuple.HasValue &amp;&amp; valueOrDefault.Item2;
        if (flag)
        {
            Console.Write(valueOrDefault.Item1 == null);
        }
    }
```

</Description>
    <CreatedDate>28/12/2016</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18944</IssueID>
    <RepoID>1</RepoID>
    <Title>Struct unboxing - very bad performance of pattern matching</Title>
    <Description>**Version Used**: 15.1 (26403.7)

Suppose we have following struct:
```C#
struct MyStruct
{
    public readonly int Value;

    public bool Equals1(object obj)
    {
        if (obj is MyStruct)
        {
            return Equals((MyStruct)obj);
        }
        return false;
    }

    public bool Equals2(object obj)
    {
        try
        {
            return Equals((MyStruct)obj);
        }
        catch
        {
            return false;
        }
    }

    public bool Equals3(object obj)
    {
        var sn = obj as MyStruct?;
        return sn.HasValue ? Equals(sn.Value) : false;
    }

    public bool Equals4(object obj)
    {
        return obj is MyStruct s ? Equals(s) : false;
    }

    public bool Equals(MyStruct other)
    {
        return Value == other.Value;
    }
}
```

`Equals1` goes against recommendation for not using "is" and than "cast" but is the fastest one.
`Equals2` looks stupid but is the second fastest (assuming `obj` is always `MyStruct`).
`Equals3` looks more clever (i was using it before C# 7) but it is MUCH MUCH slower than `Equals1` and even `Equals2` (found out just now).
`Equals4` is the the slowest one. It is translated to similar MSIL as `Equals3` but there is one more local variable.

I believe the syntax of `Equals4` should be the recommended one (or any better idea?).
Not sure why it's so slow, but probably because of working with `Nullable&lt;MyStruct&gt;`.
Shouldn't compiler emit more efficient MSIL for this cases?

Here is my measurements (Win7, Intel Xeon E5-1650 v3):
Release/32bit:
Equals1: 367.0922ms
Equals2: 1084.6545ms
Equals3: 10767.0583ms
Equals4: 11156.0162ms
Equals: 93.8451ms

Release/64bit:
Equals1: 279.8061ms
Equals2: 1052.9261ms
Equals3: 8290.5574ms
Equals4: 8774.8108ms
Equals: 95.9861ms

Measuring code looks like this:
```C#
var watch = new Stopwatch();
var a = new MyStruct();
var b = (object)new MyStruct();

a.Equals1(b);
a.Equals2(b);
a.Equals3(b);
a.Equals4(b);

const int Count = 300000000;

watch.Restart();
for (int i = 0; i &lt; Count; i++)
{
    a.Equals1(b);
}
Console.WriteLine($"Equals1: {watch.Elapsed.TotalMilliseconds}ms");

watch.Restart();
for (int i = 0; i &lt; Count; i++)
{
    a.Equals2(b);
}
Console.WriteLine($"Equals2: {watch.Elapsed.TotalMilliseconds}ms");

watch.Restart();
for (int i = 0; i &lt; Count; i++)
{
    a.Equals3(b);
}
Console.WriteLine($"Equals3: {watch.Elapsed.TotalMilliseconds}ms");

watch.Restart();
for (int i = 0; i &lt; Count; i++)
{
    a.Equals4(b);
}
Console.WriteLine($"Equals4: {watch.Elapsed.TotalMilliseconds}ms");

watch.Restart();
for (int i = 0; i &lt; Count; i++)
{
    a.Equals(a);
}
Console.WriteLine($"Equals: {watch.Elapsed.TotalMilliseconds}ms");
```</Description>
    <CreatedDate>24/04/2017</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14252</IssueID>
    <RepoID>1</RepoID>
    <Title>Code generation for type pattern: optimize value type cases</Title>
    <Description>Currently, code generated for simple patterns like this:

``` c#
public int M(object o) =&gt; (o is int x) ? x : -1;
```

...actually involves unboxing into `Nullable&lt;int&gt;` and checking for it's members:

``` c#
public int M(object o)
{
  int? num = o as int?;
  int valueOrDefault = num.GetValueOrDefault();
  return num.HasValue ? valueOrDefault : -1;
}
```

This generated code seems to be verbose and suboptimal, there is no real need to rely on runtime's support of unboxing object references into `Nullable&lt;T&gt;` value and manipulate with it where simple unboxing is required. Equivalent method takes 2 times less MSIL instructions:

``` c#
public int M2(object o) =&gt; o is int ? (int) o : -1;
```
</Description>
    <CreatedDate>03/10/2016</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26623</IssueID>
    <RepoID>1</RepoID>
    <Title>open a .sln file in linux in .netcore 2.0 console app</Title>
    <Description>I'm trying to open a .sln file out of visual studio in a .netcore console app and run some analysis on that. unfortunately all code about `MSBuildWorkspace` that i found doesn't work. all codes are using DTE from `EnvDTE` or Roslyn `MsBuildWorkspace` but almost nothing works. i wonder if what I'm going to achieve is possible or not. i appreciate if you guide me with some sample code or drop some blog or article in here, and tell me what nugget packages i need. there is not many guide out there if not i wouldn't create this issue here. 

Thanks 

**Version Used**:'2.8.0 
</Description>
    <CreatedDate>04/05/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18811</IssueID>
    <RepoID>1</RepoID>
    <Title>InvalidCastException if System.Nullable`1 is missing</Title>
    <Description>**Version Used**: current master branch

**Steps to Reproduce**:

```C#
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace ConsoleApp1234 {
	class Program {
		static void Main(string[] args) {
			var source = @"
namespace System {
	public class Object { }
	public abstract class ValueType { }
	public struct Void { }
	public struct Boolean { }
	public struct Int32 { }
}
static class C {
	public static bool M() =&gt; ((object)123) is int i;
}
";
			var syntaxTree = CSharpSyntaxTree.ParseText(source);
			var compilation = CSharpCompilation.Create("test", new[] { syntaxTree }, options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
			var output = new MemoryStream();
			var result = compilation.Emit(output);
		}
	}
}
```

`System.InvalidCastException: 'Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedErrorTypeSymbol' to type 'Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNamedTypeSymbol'.'`

```
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AsMember(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol newOwner) Line 821	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.UnsafeGetNullableMethod(Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol nullableType, Microsoft.CodeAnalysis.SpecialMember member) Line 1725	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeIsDeclarationPattern(Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.CSharp.BoundExpression loweredInput, Microsoft.CodeAnalysis.CSharp.BoundExpression loweredTarget, bool requiresNullTest) Line 198	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeIsDeclarationPattern(Microsoft.CodeAnalysis.CSharp.BoundDeclarationPattern loweredPattern, Microsoft.CodeAnalysis.CSharp.BoundExpression loweredInput) Line 99	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeIsPattern(Microsoft.CodeAnalysis.CSharp.BoundPattern loweredPattern, Microsoft.CodeAnalysis.CSharp.BoundExpression loweredInput) Line 28	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.BoundIsPatternExpression node) Line 16	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundIsPatternExpression.Accept(Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor visitor) Line 5786	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression node) Line 96	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression node) Line 225	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(ref int recursionDepth, Microsoft.CodeAnalysis.CSharp.BoundExpression node) Line 206	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithStackGuard(Microsoft.CodeAnalysis.CSharp.BoundExpression node) Line 91	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionImpl(Microsoft.CodeAnalysis.CSharp.BoundExpression node) Line 177	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode node) Line 137	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.BoundReturnStatement node) Line 8689	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.BoundReturnStatement node) Line 13	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundReturnStatement.Accept(Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor visitor) Line 2473	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode node) Line 140	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitBlock(Microsoft.CodeAnalysis.CSharp.BoundBlock node) Line 24	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor visitor) Line 2195	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(Microsoft.CodeAnalysis.CSharp.BoundNode node) Line 140	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol method, int methodOrdinal, Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol containingType, Microsoft.CodeAnalysis.CSharp.BoundStatement statement, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, bool allowOmissionOfConditionalCalls, bool instrumentForDynamicAnalysis, ref System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; dynamicAnalysisSpans, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider debugDocumentProvider, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, out bool sawLambdas, out bool sawLocalFunctions, out bool sawAwaitInExceptionHandler) Line 94	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol method, int methodOrdinal, Microsoft.CodeAnalysis.CSharp.BoundStatement body, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState, bool instrumentForDynamicAnalysis, Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider debugDocumentProvider, ref System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CodeGen.SourceSpan&gt; dynamicAnalysisSpans, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, ref Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator lazyVariableSlotAllocator, Microsoft.CodeAnalysis.ArrayBuilder&lt;Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo&gt; lambdaDebugInfoBuilder, Microsoft.CodeAnalysis.ArrayBuilder&lt;Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo&gt; closureDebugInfoBuilder, out Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol stateMachineTypeOpt) Line 1171	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol methodSymbol, int methodOrdinal, ref Microsoft.CodeAnalysis.CSharp.Binder.ProcessedFieldInitializers processedInitializers, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState) Line 1001	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol containingType) Line 434	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedTypeAsTask.AnonymousMethod__0() Line 324	C#
 	Microsoft.CodeAnalysis.dll!Roslyn.Utilities.UICultureUtilities.WithCurrentUICulture.AnonymousMethod__0() Line 136	C#
```</Description>
    <CreatedDate>19/04/2017</CreatedDate>
    <ClosedDate>01/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18750</IssueID>
    <RepoID>1</RepoID>
    <Title>Misleading diagnostic for constant `false` when clause</Title>
    <Description>**Version Used**: 15.3 (master)

**Steps to Reproduce**:

1. compile
``` c#
            try
            {
            }
            catch (Exception) when (false)
            {
            }
```

**Expected Behavior**: `Warning: filter expression is constant 'false'; consider removing try-catch.`

**Actual Behavior**: `Warning: filter expression is constant, consider removing the filter.`

It would be a change of behavior to remove the filter as suggested by the diagnostic.
</Description>
    <CreatedDate>17/04/2017</CreatedDate>
    <ClosedDate>13/11/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18859</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException when switching on enum with type pattern match</Title>
    <Description>**Version Used**: 

C# 7 (VS2017 install from 2017-04-20)

**Steps to Reproduce**:

```
switch (StringSplitOptions.RemoveEmptyEntries)
{
	case object o:
		Console.WriteLine(o);
		break;
}
```

**Expected Behavior**: Prints "RemoveEmptyEntries"

**Actual Behavior**: Throws NullReferenceException

Stack Trace:
&gt;    at System.IO.TextWriter.SyncTextWriter.WriteLine(Object value)
   at System.Console.WriteLine(Object value)

NOTE: I found [this issue](https://github.com/dotnet/roslyn/issues/9131) which seems similar, but the example code there runs fine for me.</Description>
    <CreatedDate>20/04/2017</CreatedDate>
    <ClosedDate>03/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18905</IssueID>
    <RepoID>1</RepoID>
    <Title>No error reported for an expression bodied accessor in abstract event</Title>
    <Description>```
abstract class Test
{
    public abstract event System.Action E
    {
        add =&gt; throw null;
        remove =&gt; throw null;
    }
}
```

Expected:
```
error CS0500: 'Test.E.add' cannot declare a body because it is marked abstract
error CS0500: 'Test.E.remove' cannot declare a body because it is marked abstract
```
</Description>
    <CreatedDate>21/04/2017</CreatedDate>
    <ClosedDate>28/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18257</IssueID>
    <RepoID>1</RepoID>
    <Title>Pattern switch in async method causes compiler crash</Title>
    <Description>The following code (thanks to @TyOverby) causes a compiler assertion

``` c#
// csc /t:library /optimize+ repro.cs
using System;
 
public class Foo {}
 
public class C {
    public async void M() {
        switch (new object())
        {
            case Foo _:
            default:
                throw new InvalidOperationException();
        }
    }
}
```

The lowering temp produced by pattern-matching is not classified as long-lived, and probably should be.
</Description>
    <CreatedDate>28/03/2017</CreatedDate>
    <ClosedDate>19/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10604</IssueID>
    <RepoID>1</RepoID>
    <Title>Need to confirm how extra compiler generated blocks affect caching</Title>
    <Description>@AlekseyTs You added the following PROTOTYPE comment, but I'm not sure exactly what it means. Please rewrite this issue to describe it.

``` cs
            /// &lt;summary&gt;
            /// Decides whether to the add the bound node to the cache or not.
            /// &lt;/summary&gt;
            /// &lt;param name="currentBoundNode"&gt;The bound node.&lt;/param&gt;
            private bool ShouldAddNode(BoundNode currentBoundNode)
            {
                BoundBlock block;

                // PROTOTYPE(patterns): Need to confirm how extra compiler generated blocks affect caching.
                //                      Do we actually benefit from adding them to the cache, or effect is negative or neutral.

```
</Description>
    <CreatedDate>15/04/2016</CreatedDate>
    <ClosedDate>15/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16306</IssueID>
    <RepoID>1</RepoID>
    <Title>Inline Declaration refactoring on out parameter crashes IDE</Title>
    <Description>Start with the following code:

```c#
using System;
using System.Collections.Generic;

class C
{
    void Foo()
    {
        int rowCountMember;
        var item = "";
        int rowCount;
        foreach (var row in function1(item, out rowCount))
        {
            function2(row);
        }

        rowCountMember = rowCount;
    }

    private IEnumerable&lt;object&gt; function1(string item, out int rowCount)
    {
        throw new NotImplementedException();
    }

    private void function2(object row)
    {
        throw new NotImplementedException();
    }
}
```

Try to invoke 'inline declaration' on ```int rowCount```.  This crashes the IDE with this callstack:

```
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax node) Line 776	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax node) Line 2117	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetForEachStatementInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) Line 720	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.GetForEachSymbols(Microsoft.CodeAnalysis.SemanticModel model, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEach, out Microsoft.CodeAnalysis.IMethodSymbol getEnumeratorMethod, out Microsoft.CodeAnalysis.ITypeSymbol elementType) Line 714	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementBreaksForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax newForEachStatement) Line 566	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemanticsForNode(Microsoft.CodeAnalysis.SyntaxNode currentOriginalNode, Microsoft.CodeAnalysis.SyntaxNode currentReplacedNode, Microsoft.CodeAnalysis.SyntaxNode previousOriginalNode, Microsoft.CodeAnalysis.SyntaxNode previousReplacedNode) Line 496	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemantics(Microsoft.CodeAnalysis.SyntaxNode currentOriginalNode, Microsoft.CodeAnalysis.SyntaxNode currentReplacedNode, Microsoft.CodeAnalysis.SyntaxNode originalRoot, bool skipVerificationForCurrentNode) Line 437	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer&lt;Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Conversion&gt;.ReplacementChangesSemantics() Line 416	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.CanReplaceWithReducedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax reducedName, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Threading.CancellationToken cancellationToken) Line 1955	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduce(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 1477	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceExplicitName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 697	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.TryReduceOrSimplifyExplicitName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SemanticModel semanticModel, out Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax replacementNode, out Microsoft.CodeAnalysis.Text.TextSpan issueSpan, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 664	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.SimplifyName(Microsoft.CodeAnalysis.SyntaxNode node, Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.Options.OptionSet optionSet, System.Threading.CancellationToken cancellationToken) Line 42	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.SimplifyNode&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node, Microsoft.CodeAnalysis.SyntaxNode newNode, Microsoft.CodeAnalysis.SyntaxNode parentNode, System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Options.OptionSet, System.Threading.CancellationToken, Microsoft.CodeAnalysis.SyntaxNode&gt; simplifier) Line 104	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.SimplifyExpression&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax expression, Microsoft.CodeAnalysis.SyntaxNode newNode, System.Func&lt;Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Options.OptionSet, System.Threading.CancellationToken, Microsoft.CodeAnalysis.SyntaxNode&gt; simplifier) Line 128	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) Line 48	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 423	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) Line 2481	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.CSharpNameReducer.Rewriter.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) Line 66	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 150	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) Line 2801	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3836	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) Line 2788	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3672	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt;(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) Line 163	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt;(Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt; list) Line 216	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) Line 2771	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3469	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) Line 161	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 3277	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) Line 3278	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.Accept&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor&lt;Microsoft.CodeAnalysis.SyntaxNode&gt; visitor) Line 9391	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(Microsoft.CodeAnalysis.SyntaxNode node) Line 37	C#
 	Microsoft.CodeAnalysis.CSharp.Workspaces.dll!Microsoft.CodeAnalysis.CSharp.Simplification.AbstractCSharpReducer.AbstractExpressionRewriter.VisitNodeOrToken(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.SemanticModel semanticModel, bool simplifyAllDescendants) Line 176	C#
 	Microsoft.CodeAnalysis.Workspaces.dll!Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax&gt;.ReduceAsync.AnonymousMethod__0() Line 246	C#
```

With an exception:

```
System.InvalidCastException: 'Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.BoundBlock' to type 'Microsoft.CodeAnalysis.CSharp.BoundForEachStatement'.'
```

</Description>
    <CreatedDate>06/01/2017</CreatedDate>
    <ClosedDate>15/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18188</IssueID>
    <RepoID>1</RepoID>
    <Title>C# 7.0 Multiple values for a case bug</Title>
    <Description>**Version Used**:  2.0.0.61501

**Steps to Reproduce**:

1. Create a switch that uses Byte or Ushort  

```
byte testByte = 130;

switch (testByte)
{
    case 127: // 0111 1111
    case 128: // 1000 0000
        Console.WriteLine(@"BUGGGGGGGGGGGGGGGGG");
        break;
    default:
        Console.WriteLine(@"OK :D");
        break;
}

ushort testUshort = 32769;

switch (testUshort)
{
    case 32767: // 0111 1111 1111 1111
    case 32768: // 1000 0000 0000 0000
        Console.WriteLine(@"BUGGGGGGGGGGGGGGGGG");
        break;
    default:
        Console.WriteLine(@"OK :D");
        break;
}
```

**Expected Behavior**:

The expected behavior was the switch goes to default statement

**Actual Behavior**:

The switch goes to the case statement.

The compiler converts the 'switch' to 'if', but the conversion occurs in the wrong way.
</Description>
    <CreatedDate>27/03/2017</CreatedDate>
    <ClosedDate>14/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18579</IssueID>
    <RepoID>1</RepoID>
    <Title>ConstantValue needs an overhaul</Title>
    <Description>There are numerous inconsistencies and irregularities in `ConstantValue`. For one, the conversions implemented do not match either language's conversion rules. For example, a value of type `byte` or `ushort` is sign-extended rather than padded when converted to `int`. We should have more extensive documentation and tests, and the implementation should be simplified so as to be more reliable.

See also https://github.com/dotnet/roslyn/pull/18521 and https://github.com/gafter/roslyn/tree/ConstantValue</Description>
    <CreatedDate>10/04/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11497</IssueID>
    <RepoID>1</RepoID>
    <Title>Inconsistent compiler behaviour between OS X and Windows if keyFile is the empty string</Title>
    <Description>**Version Used**: 

_OS X_:

``` sh
computer:api user$ dotnet --info
.NET Command Line Tools (1.0.0-preview1-002702)

Product Information:
 Version:     1.0.0-preview1-002702
 Commit Sha:  6cde21225e

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.11
 OS Platform: Darwin
 RID:         osx.10.11-x64
```

_Windows_:

``` cmd
PS C:\Coding\api&gt; dotnet --info
.NET Command Line Tools (1.0.0-preview1-002702)

Product Information:
 Version:     1.0.0-preview1-002702
 Commit Sha:  6cde21225e

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.10240
 OS Platform: Windows
 RID:         win10-x64
```

**Steps to Reproduce**:
1. Clone [https://github.com/martincostello/api.git](https://github.com/martincostello/api.git) from commit [c7d2e8a448470c07d98160bc19cbc2786cb28fc6](https://github.com/martincostello/api/commit/c7d2e8a448470c07d98160bc19cbc2786cb28fc6).
2. Run `dotnet build src/API` from the root of the repository.

**Expected Behaviour**:

OS X and Windows build attempts exhibit the same behaviour, which is either to:
1. Treat `""` as `null` on both platforms and compile successfully with no strong name, or;
2. Treat `""` as an invalid key file and error with `error CS7088: Invalid 'CryptoKeyFile' value: ''.` on both platforms. I'm tending towards this being the preferrable behaviour as in my case I didn't have a key file at all, so I resolved the error by using `null` explicitly in [this commit](https://github.com/martincostello/api/commit/0dc2557083103f2ac500ae871a9a901cb0c8a293).

**Actual Behaviour**:

_OS X_:

``` sh
computer:api user$ dotnet build src/API
Project API (.NETCoreApp,Version=v1.0) will be compiled because expected inputs are missing
Compiling API for .NETCoreApp,Version=v1.0
/usr/local/share/dotnet/dotnet compile-csc @/Users/user/Coding/api/src/API/obj/Debug/netcoreapp1.0/dotnet-compile.rsp returned Exit Code 1
/Users/user/Coding/api/src/API/error CS7088: Invalid 'CryptoKeyFile' value: ''.

Compilation failed.
    0 Warning(s)
    1 Error(s)

Time elapsed 00:00:01.5841885
```

_Windows_:

``` cmd
PS C:\Coding\api&gt; dotnet build .\src\API\
Project API (.NETCoreApp,Version=v1.0) will be compiled because expected inputs are missing
Compiling API for .NETCoreApp,Version=v1.0

Compilation succeeded.
    0 Warning(s)
    0 Error(s)

Time elapsed 00:00:02.5016735
```
</Description>
    <CreatedDate>23/05/2016</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18092</IssueID>
    <RepoID>1</RepoID>
    <Title>VB UWP No ConstructorArguments for ITypeSymbol Attributes</Title>
    <Description>Affected Branch: 
Affected Build: 15.1
Affected Product Language: VB only

Steps to reproduce:

1. Launch VS version 15.1
2. Create a UWP VB project, set platform target version to RS2
3. Open MainPage.xaml
4. Add &lt;InkToolbar&gt;&lt;/InkToolbar&gt; inside the root Grid

Expected:
You get a min target version incompatible warning
![image](https://cloud.githubusercontent.com/assets/16904420/24227714/7f7046c8-0f2c-11e7-81ae-c19ce15cc2cb.png)

Actual:
For VB project, you don't see this warning. This scenario works fine on C# and C++ UWP projects.

The root cause is we get the ContractVersionAttribute from a ITypeSymbol, and then get the apiContract name and version from the attributeData's ConstructorArguments. This works as expected for C# and C++ projects, but for VB, the ConstructorArguments are always empty.

This bug is blocking a new XAML feature for RS2 - warn about types and properties not available in the target platform minimum version supported by the project.
</Description>
    <CreatedDate>23/03/2017</CreatedDate>
    <ClosedDate>04/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17921</IssueID>
    <RepoID>1</RepoID>
    <Title>Assert failure in SymbolDistinguisher compiling (_, _) = (1, Main())</Title>
    <Description>```
class C
{
    static void Main()
    {
        (_, _) = (1, Main());
    }
}
```
```
Debug.Assert() failure:
Microsoft.CodeAnalysis.CSharp.SymbolDistinguisher.SymbolDistinguisher(Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.CSharp.Symbol symbol0, Microsoft.CodeAnalysis.CSharp.Symbol symbol1) Line 30	C#
Microsoft.CodeAnalysis.CSharp.Binder.GenerateImplicitConversionError(Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.Compilation compilation, Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.CSharp.Conversion conversion, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol sourceType, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol targetType, Microsoft.CodeAnalysis.ConstantValue sourceConstantValueOpt) Line 2687	C#
Microsoft.CodeAnalysis.CSharp.Binder.MakeDeconstructionConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol type, Microsoft.CodeAnalysis.SyntaxNode syntax, Microsoft.CodeAnalysis.SyntaxNode rightSyntax, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.ArrayBuilder&lt;Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable&gt; variables, out Microsoft.CodeAnalysis.CSharp.Conversion conversion) Line 254	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstructionAssignment(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.BoundExpression boundRHS, Microsoft.CodeAnalysis.ArrayBuilder&lt;Microsoft.CodeAnalysis.CSharp.Binder.DeconstructionVariable&gt; checkedVariables, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 126	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstruction(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode deconstruction, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, ref Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax declaration, ref Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.BoundDeconstructValuePlaceholder rightPlaceholder) Line 96	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindDeconstruction(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 32	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 1713	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 470	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 396	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind valueKind) Line 304	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode node, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax syntax, bool allowsAnyExpression, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 512	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 505	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 50	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2336	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2324	C#
Microsoft.CodeAnalysis.CSharp.Binder.BindEmbeddedBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2316	C#
Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol method, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, out Microsoft.CodeAnalysis.CSharp.ImportChain importChain, out bool originalBodyNested) Line 1527	C#
Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol methodSymbol, int methodOrdinal, ref Microsoft.CodeAnalysis.CSharp.Binder.ProcessedFieldInitializers processedInitializers, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields previousSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState compilationState) Line 879	C#
Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol containingType) Line 434	C#
Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedTypeAsTask.AnonymousMethod__0() Line 324	C#
Roslyn.Utilities.UICultureUtilities.WithCurrentUICulture.AnonymousMethod__0() Line 136	C#
```</Description>
    <CreatedDate>16/03/2017</CreatedDate>
    <ClosedDate>14/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17971</IssueID>
    <RepoID>1</RepoID>
    <Title>Extract method refactoring exception for incomplete foreach</Title>
    <Description>**Version Used**: VS 2017, March 14, 2017 (build 26228.09)

**Steps to Reproduce**:

1.  Create .NET 4.6.1 console project.
2. Enter this code in Program.cs:
```
using System;
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("1"); // select from here
            foreach () // can be without braces - result is same
            Console.WriteLine("2"); // to here
        }
    }
}
```
3. Select all code in Main method.

**Expected Behavior**:
Lightbulb with Extract Method refactoring appears in editor or no refactorings appears (because code is broken).

**Actual Behavior**:
`'ExtractMethodCodeRefactoringProvider' encountered an error and has been disabled` appears at top of editor with stack trace:
```
System.InvalidOperationException : Sequence contains no elements
   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)
   at Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.VisitForEachIterationVariables(BoundForEachStatement node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitForEachStatement(BoundForEachStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundForEachStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractRegionControlFlowPass.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatements(ImmutableArray`1 statements)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractRegionControlFlowPass.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.Analyze(CSharpCompilation compilation,Symbol member,BoundNode node,BoundNode firstInRegion,BoundNode lastInRegion)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_VariablesDeclared()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
```</Description>
    <CreatedDate>19/03/2017</CreatedDate>
    <ClosedDate>19/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17674</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler permits `_ = M()` for void-returning method</Title>
    <Description>The compiler should not permit a void-returning method invocation on the right-hand-side of an assignment expression, but it appears to permit that when the left-hand-side is a discard `_`.

We probably want to fix this sooner rather than later so that people don't take a dependency on this.
</Description>
    <CreatedDate>09/03/2017</CreatedDate>
    <ClosedDate>18/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17067</IssueID>
    <RepoID>1</RepoID>
    <Title>API crashes when getting diagnostics of parsed tokens</Title>
    <Description>Here is a test that repros the crash. Tokens should not assume they've parse trees, or a parse tree should be created for independently parsed tokens:

```csharp
        public void APICrash()
        {
            var code = "token 1l";
            var tokens = SyntaxFactory.ParseTokens(code).ToList();
            Assert.Equal(3, tokens.Count); // "token", "1l", "EOF"

            var numeric = tokens[1];
            Assert.Equal("1l", numeric.Text);

            var diagnostics = numeric.GetDiagnostics();
            // Expecting to get a warning about using 'L' instead of 'l'.
            // NRE here because the token has no syntax tree attached to it.
        }
```</Description>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>31/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17458</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException in SyntaxFactory.ParseStatement()</Title>
    <Description>**Version Used**: 
NuGet Microsoft.CodeAnalysis 2.0.0-rc4

**Steps to Reproduce**:

1. New C# console app, install Microsoft.CodeAnalysis package version 2.0.0-rc4
2. Program.cs method body: `SyntaxFactory.ParseStatement("private");`

**Expected Behavior**:
Does not crash

**Actual Behavior**:
NullReferenceException:

```
Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddError&lt;Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax&gt; Line 702	C#
 	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ConsumeUnexpectedTokens&lt;Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax&gt; Line 11847	C#
&gt;	Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseStatement Line 1780	C#
 	RoslynApp1.exe!RoslynApp1.Program.Main Line 14	C#
```

This is because here we don't check the node for null:
http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/SyntaxFactory.cs,1780</Description>
    <CreatedDate>28/02/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15885</IssueID>
    <RepoID>1</RepoID>
    <Title>Parse incomplete code differently to better reflect user intent.</Title>
    <Description>Fixes https://github.com/dotnet/roslyn/issues/15881

This is a port of a parsing strategy we took in TypeScript to better deal with code as the user is typing it.  Note that this is a change in how we parse code in *error*, and it involves heuristics to make the tree better match the user intent.  The code in question is code like:

```c#
Task.
await Task.Delay(...);
```

Today, the C# parser eagerly parses this as a local declaration of the form "Task.await Task".  i.e. the "Type" is "Task.await" and the VariableDeclarator is "Task".  This clearly doesn't match what the user intends, and it messes up higher layers of the stack.

Specifically, because "Task." is a QualifiedName, that changes how we treat it (when it really should be a MemberAccessExpression).  Similarly, because it looks like we're declaring a local called 'Task', we introduce a bogus LocalSymbol into scope, which messes up binding of names like "Task" (it finds the local instead of the type).

The fix is to tweak how we parse here.  We specifically look for the pattern:

```
Id dot new-line
Id id
```

And we do not think of it as a LocalDeclaration *unless* we see a following token that more definitely demonstrates that it is local-variable.  i.e.

```
X.
Y z;
```

In this case, there is no syntax error, so we have to accept this code as being a local variable declaration. 

</Description>
    <CreatedDate>14/12/2016</CreatedDate>
    <ClosedDate>19/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17683</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler sensitive to newline in parsing an expression</Title>
    <Description>In VS2017 (C# 7), the compiler now rejects the following. Eliminating the newline before `MinValue` allows it to compile. This code compiled in previous versions of the product.

See also our [internal VSO bug](https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems?id=393733&amp;_a=edit) tracking this and the [community feedback page](https://developercommunity.visualstudio.com/content/problem/25465/c-linq-expression-doesnt-compile-in-vs2017.html).

``` c#
using System;
using System.Linq;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = from t in Enumerable.Range(0, 10)
                    where
                    t == Int32.
                    MinValue
                    select t;
        }
    }
}
```
</Description>
    <CreatedDate>10/03/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33208</IssueID>
    <RepoID>1</RepoID>
    <Title>Breaking: case no longer works with constant expressions</Title>
    <Description>**Version Used**: VisualStudio.16.Preview/16.0.0-pre.2.1+28529.54

**Steps to Reproduce**:
Switching on an integer variable:
`case ((2) + (2)):` and `case ((2 + 2) - 2):`
```
(3,10): error CS8370: Feature 'recursive patterns' is not available in C# 7.3. Please use language version 8.0 or greater.
(3,15): error CS1003: Chyba syntaxe; očekávána hodnota: ,
```

`case (2) | (2):` or `case ((2 &lt;&lt; 2) | 2):`
```
(3,20): error CS1026: Očekává se ).
(3,20): error CS1003: Chyba syntaxe; očekávána hodnota: :
(3,20): error CS1525: Neplatný výraz |
(3,23): error CS1002: Očekával se středník (;).
(3,23): error CS1513: Očekával se znak }.
```

All cases above work in VS 2017.

(Sorry for non-English exceptions which is probably unrelated regression in VS2019.)</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>15/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37789</IssueID>
    <RepoID>1</RepoID>
    <Title>InvalidOperationException: Regression after netcore3.0-preview4</Title>
    <Description>Hi !
**Version Used**: 
dotnet core: 3.0.100-preview7-012821
Microsoft (R) Build Engine version 16.3.0-preview-19329-01+d31fdbf01 for .NET Core
**Steps to Reproduce**:

```
using System;
namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
	    var span = new Span&lt;byte&gt;(new byte[2]);
	    span[^1] &lt;&lt;= 1;
	}
    }
}
```

**Expected Behavior**:
Compile correctly (compile fine in preview4).
**Actual Behavior**:
Fail to compile and fail horribly.

&gt; C:\Program Files\dotnet\sdk\3.0.100-preview7-012821\Roslyn\Microsoft.CSharp.Core.targets(59,5): error : Process terminated. System.InvalidOperationException: Unexpected value 'IndexOrRangePatternIndexerAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind' [C:\Users\nicolas.vandeginste\test\test.csproj]
&gt;[Truncated]
</Description>
    <CreatedDate>07/08/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17321</IssueID>
    <RepoID>1</RepoID>
    <Title>Visual Studio crashes when attempting to match a tuple using var and then filter on the newly declared variable</Title>
    <Description>**Version Used**: VisualStudio/15.0.0-RC.4+26206.0

**Steps to Reproduce**: 

1. Start with:

```
class Repro
{
    void M()
    {
        var t = (1, 2);

        switch (t)
        {
            case (int x, int y) when x == 1:
                break;
                
            default:
                break;
        }
    }
}
```

2. Change `(int x, int y)` to `(var x, int y)` on line 9.

**Expected Behavior**: Visual Studio not to crash

**Actual Behavior**: Visual Studio crashes
</Description>
    <CreatedDate>23/02/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17281</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException when selecting a switch label with errors in pattern matching</Title>
    <Description>**Version Used**: 
VS 2017 d15rel 26214.1
**Steps to Reproduce**:

1. paste the following code in a C# file
```csharp
class A { }

class Test
{
    private void Repro(A node)
    {
        switch (node)
        {
            case A _:
                break;
            case Unknown:
                break;
            default:
                return;
        }
    }
}
```
2. double click to select "Unknown"

**Expected Behavior**:
No error
**Actual Behavior**:
Error about extract method code refactoring provider

```
System.NullReferenceException : Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.NoteDeclaredPatternVariables(BoundPattern pattern)
   at Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.VisitPattern(BoundExpression expression,BoundPattern pattern)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitPatternSwitchBlock(BoundPatternSwitchStatement node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitPatternSwitchStatement(BoundPatternSwitchStatement node)
   at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitPatternSwitchStatement(BoundPatternSwitchStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractRegionControlFlowPass.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatements(ImmutableArray`1 statements)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.AbstractRegionControlFlowPass.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker.Analyze(CSharpCompilation compilation,Symbol member,BoundNode node,BoundNode firstInRegion,BoundNode lastInRegion)
   at Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.get_VariablesDeclared()
   at Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.GenerateVariableInfoMap(SemanticModel model,DataFlowAnalysis dataFlowAnalysisData,Dictionary`2 symbolMap)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.Analyzer.AnalyzeAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor.ExtractMethodAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.ExtractMethodAsync[TValidator,TExtractor,TResult](&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.GetCodeActionAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider.ComputeRefactoringsAsync(&lt;Unknown Parameters&gt;)
   at async Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService.GetRefactoringFromProviderAsync(&lt;Unknown Parameters&gt;)
   at Microsoft.VisualStudio.Telemetry.WindowsErrorReporting.WatsonReport.GetClrWatsonExceptionInfo(Exception exceptionObject)
```

</Description>
    <CreatedDate>21/02/2017</CreatedDate>
    <ClosedDate>02/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16801</IssueID>
    <RepoID>1</RepoID>
    <Title>SemanticModel.LookupNames/LookupSymbols APIs do not return Local Function type parameters in any place within the function signature</Title>
    <Description>This is a clone of TestMethodParameterAndTypeParameterScope unit-test from src\compilers\csharp\test\semantic\semantics\lookuppositiontests.cs
```
        [Fact]
        public void TestLocalFunctionParameterAndTypeParameterScope()
        {
            var text = @"
class C
`{
    void Test()
    `{
        `void `M`&lt;T&gt;(int x) `{ `}
    `}
`}
";

            var expectedNames = MakeExpectedSymbols(
                Add( //Global
                    "C",
                    "System",
                    "Microsoft"),
                Add( //C
                    "void C.Test()",
                    "System.Boolean System.Object.Equals(System.Object obj)",
                    "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
                    "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)",
                    "System.Int32 System.Object.GetHashCode()",
                    "System.Object System.Object.MemberwiseClone()",
                    "void System.Object.Finalize()",
                    "System.String System.Object.ToString()",
                    "System.Type System.Object.GetType()"),
                Add("void M&lt;T&gt;(System.Int32 x)"), // Test body
                Add("T"), s_pop, //C.C(int) return type
                Add("T"), //C.C(int) between name and body
                Add("System.Int32 x"), //C.C(int) body
                Combine(s_pop, s_pop), //C.C(int)
                s_pop, // Test body
                s_pop //C
            );

            TestLookupNames(text, expectedNames);
        }
```

```
Test 'Microsoft.CodeAnalysis.CSharp.UnitTests.LookupPositionTests.TestLocalFunctionParameterAndTypeParameterScope' failed:
	Lookup(46) - 'void' in 'void' after 3th '`' - "--&gt;" found but not expected, "++&gt;" expected but not found

Expected:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
T,
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Actual:
C,
Microsoft,
System,
System.Boolean System.Object.Equals(System.Object obj),
System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
System.Int32 System.Object.GetHashCode(),
System.Object System.Object.MemberwiseClone(),
System.String System.Object.ToString(),
System.Type System.Object.GetType(),
void C.Test(),
void M&lt;T&gt;(System.Int32 x),
void System.Object.Finalize()
Differences:
    C,
    Microsoft,
    System,
    System.Boolean System.Object.Equals(System.Object obj),
    System.Boolean System.Object.Equals(System.Object objA, System.Object objB),
    System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB),
    System.Int32 System.Object.GetHashCode(),
    System.Object System.Object.MemberwiseClone(),
    System.String System.Object.ToString(),
    System.Type System.Object.GetType(),
--&gt; T,
    void C.Test(),
    void M&lt;T&gt;(System.Int32 x),
    void System.Object.Finalize()

Expected: True
Actual:   False
```</Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17198</IssueID>
    <RepoID>1</RepoID>
    <Title>MemberSemanticModel.GetDeclaredSymbol(LocalFunctionStatementSyntax shouldn't bind LocalFunctionStatementSyntax</Title>
    <Description>It should work similar to ```GetDeclaredSymbol(VariableDeclaratorSyntax```, which doesn't bind any syntax. </Description>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17266</IssueID>
    <RepoID>1</RepoID>
    <Title>Double evaluation in pattern matching </Title>
    <Description>The following code prints "eval" twice

```C#
using System;
public class C
{
    public static void Main()
    {
        if (TryGet() is int index)
        {
            System.Console.WriteLine(index);
        }
    }

    public static int? TryGet()
    {
        System.Console.WriteLine("eval");
        return null;
    }
}
```
</Description>
    <CreatedDate>21/02/2017</CreatedDate>
    <ClosedDate>21/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12052</IssueID>
    <RepoID>1</RepoID>
    <Title>A misleading error is reported for a local or parameter conflicting with a range variable from an outer scope</Title>
    <Description>```
        var res = from a in new[] { 1 }
                  select (Func&lt;int, int&gt;)(a =&gt; 1);
```

Observed:
                  select (Func&lt;int, int&gt;)(**a** =&gt; 1);
error CS0412: 'a': a parameter or local variable cannot have the same name as a method type parameter

Expected:
An error indicating a conflict with a range variable.

This is going to affect pattern variable declarations and out variable declarations.
</Description>
    <CreatedDate>16/06/2016</CreatedDate>
    <ClosedDate>23/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16962</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crash with field-like event in deconstruction assignment</Title>
    <Description>**Version Used**: 

Master branch @ February 5

**Steps to Reproduce**:

Try compiling this code:
```c#
class C {
  event System.EventHandler E;
  void M() {
    (E, _) = (null, 1);
  }
}
```

**Expected Behavior**:

Successful compilation, runtime behavior equal to `E = null;`

**Actual Behavior**:

```
Unexpected value 'EventAccess' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.TransformCompoundAssignmentLHS(BoundExpression originalLHS, ArrayBuilder`1 stores, ArrayBuilder`1 temps, Boolean isDynamicAssignment) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_CompoundAssignmentOperator.cs:line 548
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.&lt;&gt;c.&lt;GetAssignmentTargetsAndSideEffects&gt;b__176_0(BoundExpression variable, ValueTuple`4 args) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_DeconstructionAssignmentOperator.cs:line 168
   at Microsoft.CodeAnalysis.CSharp.BoundTupleExpression.VisitAllElements[T](Action`2 action, T args) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundExpression.cs:line 651
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetAssignmentTargetsAndSideEffects(BoundTupleExpression variables, ArrayBuilder`1 temps, ArrayBuilder`1 stores) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_DeconstructionAssignmentOperator.cs:line 159
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitDeconstructionAssignmentOperator(BoundDeconstructionAssignmentOperator node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_DeconstructionAssignmentOperator.cs:line 20
   at Microsoft.CodeAnalysis.CSharp.BoundDeconstructionAssignmentOperator.Accept(BoundTreeVisitor visitor) in \dotnet\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 1200
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 147
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 96
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 225
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 206
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithStackGuard(BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 91
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionImpl(BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 177
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpression(BoundExpression node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 151
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitUnusedExpression(BoundExpression expression) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_ExpressionStatement.cs:line 73
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteExpressionStatement(BoundExpressionStatement node, Boolean suppressInstrumentation) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_ExpressionStatement.cs:line 21
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitExpressionStatement(BoundExpressionStatement node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_ExpressionStatement.cs:line 16
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor) in \dotnet\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2708
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 140
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitBlock(BoundBlock node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_Block.cs:line 24
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in \dotnet\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2321
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 140
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(CSharpCompilation compilation, MethodSymbol method, Int32 methodOrdinal, NamedTypeSymbol containingType, BoundStatement statement, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, Boolean allowOmissionOfConditionalCalls, Boolean instrumentForDynamicAnalysis, ImmutableArray`1&amp; dynamicAnalysisSpans, DebugDocumentProvider debugDocumentProvider, DiagnosticBag diagnostics, Boolean&amp; sawLambdas, Boolean&amp; sawLocalFunctions, Boolean&amp; sawAwaitInExceptionHandler) in \dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 94
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt) in \dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1170
```</Description>
    <CreatedDate>05/02/2017</CreatedDate>
    <ClosedDate>22/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17089</IssueID>
    <RepoID>1</RepoID>
    <Title>Declaration pattern should not support `dynamic`</Title>
    <Description>Since no runtime object ever has type `dynamic`, it should not be supported as the type in a declaration pattern. The compiler does, today, permit that.

Related to that, when the input is of type `dynamic`, the compiler does not currently permit any type in a declaration pattern (other than `var` or `dynamic`). The compiler should treat such an input as being of type `object`.</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>04/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17138</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crash: discard designation in expression tree lambda</Title>
    <Description>**Version Used**: 

Master branch @ Feb 14

**Steps to Reproduce**:

Compile the following code:
```c#
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

class C
{
  public Expression&lt;Func&lt;Dictionary&lt;int, int&gt;, bool&gt;&gt; Expression =&gt;
    dict =&gt; dict.TryGetValue(42, out var _);
}
```
Or with shorter form of discard:
```c#
    dict =&gt; dict.TryGetValue(42, out _)
```

**Expected Behavior**:

Compiler error, similar to "error CS8198: An expression tree may not contain an out argument variable declaration."

**Actual Behavior**:

```
Unexpected value 'Sequence' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExpressionWithoutStackGuard(BoundExpression node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 244
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitInternal(BoundExpression node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 260
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.Visit(BoundExpression node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 171
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.TranslateLambdaBody(BoundBlock block) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 138
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitLambdaInternal(BoundLambda node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 752
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.RewriteLambda(BoundLambda node, TypeCompilationState compilationState, TypeMap typeMap, Int32 recursionDepth, DiagnosticBag diagnostics) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\ExpressionLambdaRewriter.cs:line 114
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaConversion(BoundLambda node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 1480
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitConversion(BoundConversion conversion) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 1179
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2072
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 147
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 96
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 225
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 206
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 83
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitReturnStatement(BoundReturnStatement node) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 8881
   at Microsoft.CodeAnalysis.CSharp.BoundReturnStatement.Accept(BoundTreeVisitor visitor) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2599
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 147
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 86
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitSequencePoint(BoundSequencePoint node) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 8822
   at Microsoft.CodeAnalysis.CSharp.BoundSequencePoint.Accept(BoundTreeVisitor visitor) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2223
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 147
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 86
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 994
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 975
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in \Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2321
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeVisitors.cs:line 147
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node) in \Src\Compilers\CSharp\Portable\BoundTree\BoundTreeRewriter.cs:line 86
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, Boolean assignLocals) in \Src\Compilers\CSharp\Portable\Lowering\LambdaRewriter\LambdaRewriter.cs:line 259
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt) in \Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1221
```</Description>
    <CreatedDate>14/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16935</IssueID>
    <RepoID>1</RepoID>
    <Title>Unexpected error CS8200 for an expression variable declared within a lambda within a field initializer.</Title>
    <Description>```
        [Fact]
        public void GlobalCode_Lambda_02()
        {
            var source =
@"
System.Func&lt;bool&gt; l = () =&gt; TakeOutParam(1, out int x1) &amp;&amp; Dummy(x1); 
System.Console.WriteLine(l());

static bool Dummy(int x) 
{
    System.Console.WriteLine(x);
    return true;
}

static bool TakeOutParam(int y, out int x) 
{
    x = y;
    return true;
}
";
            var compilation = CreateCompilationWithMscorlib45(source, options: TestOptions.ReleaseExe.WithScriptClassName("Script"), parseOptions: TestOptions.Script);
            CompileAndVerify(compilation, expectedOutput: @"1
True");

            var tree = compilation.SyntaxTrees.Single();
            var model = compilation.GetSemanticModel(tree);

            var x1Decl = GetOutVarDeclarations(tree, "x1").Single();
            var x1Ref = GetReferences(tree, "x1").Single();
            VerifyModelForOutVar(model, x1Decl, x1Ref);
        }
```

Result:
```
(2,49): error CS8200: Out variable and pattern variable declarations are not allowed within constructor initializers, field initializers, or property initializers.
```</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12838</IssueID>
    <RepoID>1</RepoID>
    <Title>Test asserts temporary variable that can be inlined cannot be inlined</Title>
    <Description>The following test appears to be incorrect

``` cs
        [Fact, Trait(Traits.Feature, Traits.Features.CodeActionsInlineTemporary)]
        public async Task WithRefInitializer1()
        {
            await TestMissingAsync(@"
class C
{
    ref int M()
    {
        int[] arr = new[] { 1, 2, 3 };
        ref int [||]x = ref arr[2];
        return ref x;
    }
}");
        }
```

If I understand it correctly, this asserts that the temporary variable x cannot be inlined. But it can be inlined. This was broken by a refactoring of the syntax model for ref locals.
</Description>
    <CreatedDate>30/07/2016</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16913</IssueID>
    <RepoID>1</RepoID>
    <Title>csc reports errors only one pre-processor symbol per -define flag</Title>
    <Description>Example:
`csc -define:valid1,2,3`

**Expected**: Errors for invalid symbols `2` and `3`.
**Actual**: Error for just `2`.</Description>
    <CreatedDate>02/02/2017</CreatedDate>
    <ClosedDate>14/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14689</IssueID>
    <RepoID>1</RepoID>
    <Title>Select from namespace doesn't issue error</Title>
    <Description>Consider the following code:

``` cs
using System.Linq;

namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
        }

        public static int Test()
        {
            var x = from c in ConsoleApp
                    select 3;
            return x.First();
        }
    }
}
```

This code is invalid and fails to compile.  The error though is the emit catch all "failed to emit".  That means the compiler is issuing an error earlier and not surfacing it.  In larger programs that makes the problem very difficult to track down.  Need to correct this. 
</Description>
    <CreatedDate>23/10/2016</CreatedDate>
    <ClosedDate>10/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16876</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash (assertion error) compiling pattern switch</Title>
    <Description>Crash (assertion error) compiling pattern switch

The following switch crashes the compiler with an assertion error in Miltstone 2.0 RTM.

``` c#
    static void M2(object o, bool b)
    {
        switch (o)
        {
            case null:
                Console.WriteLine(""M2a""); break;
            case var _ when b:
                Console.WriteLine(""M2b""); break;
            case 1:
                Console.WriteLine(""M2c""); break;
        }
    }
```
</Description>
    <CreatedDate>01/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37711</IssueID>
    <RepoID>1</RepoID>
    <Title>Permit stackalloc to be used in an async method as long as it need not be spilled.</Title>
    <Description>Fixes #37461</Description>
    <CreatedDate>03/08/2019</CreatedDate>
    <ClosedDate>19/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37755</IssueID>
    <RepoID>1</RepoID>
    <Title>workspace.TryApplyChanges should respect changes to DefaultNamespace</Title>
    <Description>This is a follow up PR to https://github.com/dotnet/roslyn/pull/35486

In the original PR, the default namespace APIs were made public but the `TryApplyChanges` method of the workspace wouldn't respect it. As a result, we needed to use a [reflection workaround in OmniSharp](https://github.com/OmniSharp/omnisharp-roslyn/blob/master/src/OmniSharp.Roslyn/OmniSharpWorkspace.cs#L478-L492).

This PR ensures that default namespace change is propagated via `TryApplyChanges`.</Description>
    <CreatedDate>06/08/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16751</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect SemanticModel behavior within attributes in Local Functions</Title>
    <Description>```
        [Fact]
        public void Scope_LocalFunction_Attribute_99()
        {
            var source =
@"
public class X
{
    public static void Main()
    {
        const bool b1 = true;

        void Local1(
            [Test(p = b1)]
            [Test(p = b2)]
            int p1)
        {
        }

        Local1(1);
    }
}

class b1 {}

class Test : System.Attribute
{
    public bool p {get; set;}
}
";
            var compilation = CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe, parseOptions: TestOptions.Regular);
            compilation.GetDiagnostics().Where(d =&gt; d.Code != (int)ErrorCode.ERR_AttributesInLocalFuncDecl).Verify(
                // (10,23): error CS0103: The name 'b2' does not exist in the current context
                //             [Test(p = b2)]
                Diagnostic(ErrorCode.ERR_NameNotInContext, "b2").WithArguments("b2").WithLocation(10, 23),
                // (6,20): warning CS0219: The variable 'b1' is assigned but its value is never used
                //         const bool b1 = true;
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "b1").WithArguments("b1").WithLocation(6, 20)
                );

            var tree = compilation.SyntaxTrees.Single();
            var model = compilation.GetSemanticModel(tree);

            var b2 = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "b2").Single();
            Assert.Null(model.GetSymbolInfo(b2).Symbol);

            var b1 = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "b1").Single();
            var b1Symbol = model.GetSymbolInfo(b1).Symbol;
            Assert.Equal("b1", b1Symbol.ToTestDisplayString());
            Assert.Equal(SymbolKind.Local, b1Symbol.Kind);
        }
```

The last Assert in the test fails:
Test 'Scope_LocalFunction_Attribute_99' failed: Assert.Equal() Failure
Expected: Local
Actual:   NamedType
</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16748</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash in SemanticModel when an expression variable is declared in default parameter value of an Anonymous Method</Title>
    <Description>```
        [Fact]
        public void DeclarationInAnonymousMethodParameterDefault()
        {
            var text = @"
class C
{
    public static void Main(int arg)
    {
        System.Action&lt;bool, int&gt; d1 = delegate (
                                                bool b = M(M(out int z1), z1), 
                                                int s2 = z1) 
                                            { var t = z1; };
        System.Action&lt;bool, int&gt; d2 = delegate (
                                                bool b = M(M(out var z2), z2), 
                                                int s2 = z2)  
                                            { var t = z2; };

        int x = z1 + z2;
        d1 = d2 = null;
    }
    static int M(out int z) =&gt; z = 1;
    static int M(int a, int b) =&gt; a+b;
}
";
            var compilation = CreateCompilationWithMscorlib45(text);

            var tree = compilation.SyntaxTrees[0];
            var model = compilation.GetSemanticModel(tree);

            var z1 = tree.GetRoot().DescendantNodes().OfType&lt;IdentifierNameSyntax&gt;().Where(id =&gt; id.Identifier.ValueText == "z1").First();
            Assert.Equal("", model.GetTypeInfo(z1).Type.ToTestDisplayString());
        }
```

```
Test 'DeclarationInAnonymousMethodParameterDefault' failed: 
    System.InvalidOperationException : This program location is thought to be unreachable.
	at Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableDeclarationArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableArgument(DeclarationExpressionSyntax declarationExpression, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(SeparatedSyntaxList`1 arguments, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindValueAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentExpression(DiagnosticBag diagnostics, ExpressionSyntax argumentExpression, RefKind refKind, Boolean allowArglist)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(DiagnosticBag diagnostics, ArgumentSyntax argumentSyntax, Boolean allowArglist, RefKind refKind)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, Boolean hadError, ArgumentSyntax argumentSyntax, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(SeparatedSyntaxList`1 arguments, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result, Boolean allowArglist, Boolean isDelegateCreation)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
	at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
	at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
	at Microsoft.CodeAnalysis.SemanticModel.GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken)
	Semantics\OutVarTests.cs(28978,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.OutVarTests.DeclarationInAnonymousMethodParameterDefault()
```</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16374</IssueID>
    <RepoID>1</RepoID>
    <Title>Bound nodes not preserved for local function parameter default values</Title>
    <Description>The following proposed test (for `OutVarTests.cs`) would fail because a few of the SemanticModel APIs don't work without bound nodes, and we don't have bound nodes for the parameter default values.

I would not be surprised if we have similar issues for other contexts requiring constants.

```cs
        [Fact, WorkItem(16167, "https://github.com/dotnet/roslyn/issues/16167")]
        public void DeclarationInLocalFunctionParameterDefault()
        {
            var text = @"
class C
{
    public static void Main(int arg)
    {
        void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
        void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}

        int x = z1 + z2;
    }
    static int M(out int z) =&gt; z = 1;
    static int M(int a, int b) =&gt; a+b;
}
";
            // the scope of an expression variable introduced in the default expression
            // of a local function parameter is that default expression.
            var compilation = CreateCompilationWithMscorlib45(text);
            compilation.VerifyDiagnostics(
                // (6,30): error CS1736: Default parameter value for 'b' must be a compile-time constant
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "M(M(out int z1), z1)").WithArguments("b").WithLocation(6, 30),
                // (6,61): error CS0103: The name 'z1' does not exist in the current context
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z1").WithArguments("z1").WithLocation(6, 61),
                // (6,56): error CS1750: A value of type '?' cannot be used as a default parameter because there are no standard conversions to type 'int'
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "s2").WithArguments("?", "int").WithLocation(6, 56),
                // (7,30): error CS1736: Default parameter value for 'b' must be a compile-time constant
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "M(M(out var z2), z2)").WithArguments("b").WithLocation(7, 30),
                // (7,61): error CS0103: The name 'z2' does not exist in the current context
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z2").WithArguments("z2").WithLocation(7, 61),
                // (7,56): error CS1750: A value of type '?' cannot be used as a default parameter because there are no standard conversions to type 'int'
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "s2").WithArguments("?", "int").WithLocation(7, 56),
                // (9,17): error CS0103: The name 'z1' does not exist in the current context
                //         int x = z1 + z2;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z1").WithArguments("z1").WithLocation(9, 17),
                // (9,22): error CS0103: The name 'z2' does not exist in the current context
                //         int x = z1 + z2;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "z2").WithArguments("z2").WithLocation(9, 22),
                // (6,14): warning CS0168: The variable 'Local2' is declared but never used
                //         void Local2(bool b = M(M(out int z1), z1), int s2 = z1) {}
                Diagnostic(ErrorCode.WRN_UnreferencedVar, "Local2").WithArguments("Local2").WithLocation(6, 14),
                // (7,14): warning CS0168: The variable 'Local5' is declared but never used
                //         void Local5(bool b = M(M(out var z2), z2), int s2 = z2) {}
                Diagnostic(ErrorCode.WRN_UnreferencedVar, "Local5").WithArguments("Local5").WithLocation(7, 14)
                );
            var tree = compilation.SyntaxTrees[0];
            var model = compilation.GetSemanticModel(tree);

            for (int i = 1; i &lt;= 2; i++)
            {
                var name = $"z{i}";
                var decl = GetOutVarDeclaration(tree, name);
                var refs = GetReferences(tree, name).ToArray();
                Assert.Equal(3, refs.Length);
                VerifyModelForOutVarInNotExecutableCode(model, decl, refs[0]);
                VerifyNotInScope(model, refs[1]);
                VerifyNotInScope(model, refs[2]);
                var symbol = (ILocalSymbol)model.GetDeclaredSymbol(decl.Designation);
                Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString());
            }
        }
```
</Description>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16757</IssueID>
    <RepoID>1</RepoID>
    <Title>SemanticModel.GetDeclaredSymbol(ParameterSyntax) doesn't work for parameters of a Local Function</Title>
    <Description>This is going to affect IDE experience. I noticed that IDE doesn't show tooltips on the parameters and "Find All References" finds nothing when invoked on the parameters. This issue is the likely reason for the behavior.</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16706</IssueID>
    <RepoID>1</RepoID>
    <Title>InvalidOperationException "Cannot enqueue data after PromiseNotToEnqueue." if an analyzer calls GetDiagnostics in the RegisterCompilationAction callback</Title>
    <Description>**Version Used**: 1.3.2 (also repros in 2.0.0-rc2)

**Steps to Reproduce**:
Full repro code available at https://github.com/dpaoliello/PromiseNotToEnqueueRepro

This requires two threads:

Thread 1 (Main C# Compiler thread):
1. Calls `CommonCompiler.RunCore`.
2. Which calls `CSharpCompilation.GetDeclarationDiagnostics`.
3. Which calls `ForceComplete` on symbols recursively.
4. Which calls a method that calls `SymbolCompletionState.NotePartCompleted` *before* calling `CSharpCompilation.SymbolDeclaredEvent` (e.g. `SourceMemberFieldSymbol.FixedSize`).
5. After calling `NotePartCompleted` the thread is suspended (note that `SymbolDeclaredEvent` has not yet been called).

Thread 2 (Thread for analyzer):
1. Calls `CSharpCompilation.GetDiagnostics`.
2. Which calls `ForceComplete` on symbols recursively.
3. Since Thread 1 has marked part of the compilation complete, continues to complete the compilation.
4. `GetDiagnostics` then calls `Compilation.EnsureCompilationEventQueueCompleted` which marks the `EventQueue` as completed and promises not to enqueue any other events.

Thread 1 then continues, and calls `SymbolDeclaredEvent` which attempts to enqueue the event, but finds that the queue has been completed, thus throws the `InvalidOperationException`.

There are two possible ways I can think of to fix this:
1. A careful review of each call to `NotePartCompleted` to ensure that all events are queued *before* completing the part.
2. Ensure that only one thread is walking the `ForceComplete` chain at a time - perhaps the first thread that does this can atomically set a task that other threads can then wait on.</Description>
    <CreatedDate>23/01/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16753</IssueID>
    <RepoID>1</RepoID>
    <Title>Race condition completing (empty) attribute list for an event</Title>
    <Description>The following test (recommended in `CompilationEventTests.cs`)

``` c#
        [Fact, WorkItem(16753, "https://github.com/dotnet/roslyn/issues/16753")]
        public void TestConcurrentCompletionMany()
        {
            for (int i = 0; i &lt; 1000; i++)
            {
                TestConcurrentCompletion();
            }
        }

        private static void TestConcurrentCompletion()
        {
            var source =
@"
using System;
public enum E1 { A, B, C, D, E }
public class C1
{
    public event Action e1;
    public event Action e2;
    public event Action e3;
    Action Events =&gt; e1 + e2 + e3;
}
public unsafe struct S1
{
    public fixed int X[10];
    public int A, B, C, D;
    public CI P1 =&gt; null;
    public CI P2 =&gt; null;
    public CI P3 =&gt; null;
    public CI this[CI a, CI b, CI c] =&gt; null;
}
internal class CI {}
";
            var q = new AsyncQueue&lt;CompilationEvent&gt;();
            var compilation = CreateCompilationWithMscorlib45(source).WithEventQueue(q);
            Func&lt;Task&gt; makeTask = async () =&gt; {
                try
                {
                    while (true)
                    {
                        var compilationEvent = await q.DequeueAsync();
                        compilation.GetDiagnostics();
                    }
                }
                catch (OperationCanceledException)
                {
                }
            };
            Task kickoff = Task.Run(() =&gt;
            {
                compilation.GetDiagnostics();
            });
            // start a handful of tasks each of which waits on the queue
            var tasks = Enumerable.Range(0, 30).Select(i =&gt; i != 19 ? makeTask() : kickoff).ToArray();
            Task.WaitAll(tasks);
        }
```

frequently fails with an assertion error here in SourceEventSymbol.cs:

``` c#
        private CustomAttributesBag&lt;CSharpAttributeData&gt; GetAttributesBag()
        {
            if ((_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed) &amp;&amp;
                LoadAndValidateAttributes(OneOrMany.Create(this.AttributeDeclarationSyntaxList), ref _lazyCustomAttributesBag))
            {
                var completed = state.NotePartComplete(CompletionPart.Attributes);
                Debug.Assert(completed);
                DeclaringCompilation.SymbolDeclaredEvent(this);
            }

            return _lazyCustomAttributesBag;
        }
```

This looks like it may be a previously unknown race condition.
</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>12/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16671</IssueID>
    <RepoID>1</RepoID>
    <Title>Pattern Matching and Generics types confusion</Title>
    <Description>**Version Used**: Visual Studio 2017 RC

**Steps to Reproduce**:

Here is a piece of code that doesn't compile ([gist](https://gist.github.com/Pvlerick/80f610e67033b434ab949dd60b23add1#file-program01-cs))
```CSharp
static void PatternMatching&lt;TBase, TDerived&gt;(TBase o) where TDerived : TBase
{
    switch (o)
    {
        case TDerived td:
            Console.WriteLine(nameof(TDerived));
            break;
        case TBase tb:
            //Error CS8120  The switch case has already been handled by a previous case.
            Console.WriteLine(nameof(TBase));
            break;
        default:
            break;
    }
}
```
In this case, the compile seems to assume that any TBase is going to be handled by the TDerived case.

Removing the problematic case and leaving only the TDerived case and calling the method with a TBase gives this ([gist](https://gist.github.com/Pvlerick/80f610e67033b434ab949dd60b23add1#file-program02-cs)):
```CSharp
using System;

namespace ConsoleApp2
{
    class Program
    {
        static void Main(string[] args)
        {
            var c = new C();
            PatternMatching&lt;C, D&gt;(c);
        }

        static void PatternMatching&lt;TBase, TDerived&gt;(TBase o) where TDerived : TBase
        {
            switch (o)
            {
                case TDerived td:
                    //This is where we end up...
                    Console.WriteLine(nameof(TDerived));
                    //This prints "ConsoleApp2.Program+C"
                    Console.WriteLine(td.GetType());
                    break;
                default:
                    Console.WriteLine("Unmatched");
                    break;
            }
        }

        class C { }
        class D : C { }
    }
}
```
Decompiling this with ILSpy gives this:
```CSharp
// ConsoleApp2.Program
private static void PatternMatching&lt;TBase, TDerived&gt;(TBase o) where TDerived : TBase
{
	TDerived td = o;
	Console.WriteLine("TDerived");
	Console.WriteLine(td.GetType());
}
```
So it seems the compiler emits code that "transforms" a C into a D.

Knowing that the real type is C but that the compiler made it into a D, it's possible to act on it as if it was a D while it's not ([gist](https://gist.github.com/Pvlerick/80f610e67033b434ab949dd60b23add1#file-program03-cs)):
```CSharp
using System;

namespace ConsoleApp2
{
    class Program
    {
        static void Main(string[] args)
        {
            var c = new C();
            PatternMatching&lt;C, D&gt;(c, d =&gt; d.M());
        }

        static void PatternMatching&lt;TBase, TDerived&gt;(TBase o, Action&lt;TDerived&gt; a) where TDerived : TBase
        {
            switch (o)
            {
                case TDerived td:
                    //This is where we end up...
                    Console.WriteLine(nameof(TDerived));
                    //This prints "ConsoleApp2.Program+C"
                    Console.WriteLine(td.GetType());
                    a(td);
                    break;
                default:
                    Console.WriteLine("Unmatched");
                    break;
            }
        }

        class C { }

        class D : C {
            private int _i = 42;
            private string _s = "Initialized";

            public void M()
            {
                Console.WriteLine(_i); //0
                Console.WriteLine(_s); //null
                Console.WriteLine(this.GetType()); //ConsoleApp2.Program+C
                //But still, can write to it
                _i = 5;
                Console.WriteLine(_i);
                _s = "What am I in the end?";
                Console.WriteLine(_s);
            }
        }
    }
}
```

**Expected Behavior**: The compiler shouldn't reject the case with TBase to begin with.

**Actual Behavior**: As demonstrated.

I discovered this when investigating on question raised during @BillWagner's talk in NDL London on Friday on pattern matching.</Description>
    <CreatedDate>21/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37344</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect nullability analysis for single and-operator </Title>
    <Description>**Version Used**: 
Visual Studio 16.2.0 Preview 4

**Steps to Reproduce**:
The following if statement with a single **and**-operator (&amp;), gets analysed as both values being possibly null. That is incorrect.

```csharp
    var monkey = CreatePossibleNullMonkey();
    var business = CreatePossibleNullBusiness();
    if (monkey != null &amp; business != null)
    {
        monkey.Do(); // Dereference of a possibly null reference
        business.AsUsual(); // Dereference of a possibly null reference
    }
```

**Note** 
With a shortcut-and-operator (double &amp;&amp;), the analysis _does_ evaluate both as not null, which is correct.
```csharp
    if (monkey != null &amp;&amp; business != null)
    {
        monkey.Do(); // No warning
        business.AsUsual(); // No warning
    }
```

**Inverse**
The inverse has the same problem. Here too, the double **or** ``||`` correctly evaluates both variables as not null which is correct, While the single-or evaluates them as possibly null. Wich is incorrect.

```csharp
    if (!(monkey is null | business is null))
    {
        monkey.Do(); // Dereference of a possibly null reference
        business.AsUsual(); // Dereference of a possibly null reference
    }
```

</Description>
    <CreatedDate>18/07/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16559</IssueID>
    <RepoID>1</RepoID>
    <Title>Stack Overflow in BindPatternSwitchLabelForInference</Title>
    <Description>**Version Used**: VS2015 RC3

**Steps to Reproduce**:

Attempt to compile this code:

```cs
public class Program5815
{
    public static void Main(string[] args)
    {
        switch ((int)M())
        {
            case var x3:
            case true ? x3 : 4:
                break;
        }
    }
    private static object M() =&gt; null;
}
```

**Expected Behavior**: Compiler error about case label not being a constant

**Actual Behavior**: Compiler stack overflow

See also https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?_a=edit&amp;id=369796</Description>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>25/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36979</IssueID>
    <RepoID>1</RepoID>
    <Title>Nullchecked Iterators + Error Messages</Title>
    <Description>
    </Description>
    <CreatedDate>04/07/2019</CreatedDate>
    <ClosedDate>17/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13206</IssueID>
    <RepoID>1</RepoID>
    <Title>VB: Invalid delegate generated for lambda passed as delegate with ByRef return type</Title>
    <Description>Invalid delegate generated for `Function o.F()`:

```
public delegate ref T D&lt;T&gt;();
public class A&lt;T&gt;
{
#pragma warning disable 0649
    private T _t;
    public ref T F()
    {
        return ref _t;
    }
}
public class B
{
    public static void F&lt;T&gt;(D&lt;T&gt; d, T t)
    {
        d() = t;
    }
}
```

```
Module M
    Sub Main()
        Dim o As New A(Of Integer)()
        B.F(Function() o.F(), 2)
        System.Console.Write(o.F())
    End Sub
End Module
```
</Description>
    <CreatedDate>16/08/2016</CreatedDate>
    <ClosedDate>24/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36982</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix Solution.WithDocumentFilePath not updating the file path of the tree</Title>
    <Description>DocumentState.UpdateFilePath was still passing in the old attributes when producing a new tree source -- oops!</Description>
    <CreatedDate>04/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37026</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge release/dev16.3-preview1-vs-deps to master-vs-deps</Title>
    <Description>
This is an automatically generated pull request from release/dev16.3-preview1-vs-deps into master-vs-deps.

``` bash
git fetch --all
git checkout merges/release/dev16.3-preview1-vs-deps-to-master-vs-deps
git reset --hard upstream/master-vs-deps
git merge upstream/release/dev16.3-preview1-vs-deps
# Fix merge conflicts
git commit
git push upstream merges/release/dev16.3-preview1-vs-deps-to-master-vs-deps --force
```

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
    <CreatedDate>06/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16177</IssueID>
    <RepoID>1</RepoID>
    <Title>Roslyn should embed interop structs with [ComVisible(true)]</Title>
    <Description>**Version**: VS 2015 Update 3

**Steps to Reproduce**:

1. Create a ATL COM library:

```
import "oaidl.idl";
import "ocidl.idl";

[
	uuid(E9832E6C-053B-4E7B-9F94-624964D2177B),
	version(1.0),
]
library FooLib
{
	importlib("stdole2.tlb");

	 [uuid(823F7C79-0238-4830-A7F2-8610ED1B3550),
	 version(1.0)]
	 typedef struct FooStruct {

		long operand1;
		long operand2;

	} FooStruct;
	[
		uuid(C58291E0-9474-438A-97E4-F7976B919C30)		
	]
	coclass Bar
	{
		[default] interface IBar;
	};

	[
		object,
		uuid(57D5CCE9-B3E2-4884-95F8-5B268DDF3DF2),
		oleautomation,
		dual,
		nonextensible,
		pointer_default(unique)
	]
	interface IBar : IDispatch {
		[id(1)]
		HRESULT CallFoos([in] SAFEARRAY(FooStruct)* ppFoos);
	};

};
```

2. Create a C# desktop/console project, reference ATL com library (Add reference), and set Embed Interop Types = true, and make sure [ComVisible(false)] in the assemblyInfo.cs.

3. Try to call CallFoos with following code:

```
new Bar().CallFoos(new FooStruct[] {  new FooStruct() })
```

**Expected Behavior**:
Succeed

**Actual Behavior**:
Fail. CLR throws ArgumentException with HRESULT=0x80070057 (E_INVALIDARG).

**Reason**:
The underlying problem is caused by interop type embeding. When marshaling SAFEARRAY of structs, CLR needs to locate the IRecordInfo from the typelib in order to be able to correctly represent them in VARIANTs. 
Due to interop embeding, CLR is not able to correctly locate the type lib GUID (the right GUID is on the interop assembly that is not inherited into the main app, and in the case of multiple embedding interop assemblies, it simply can't), so registering the TLB actually don't work. As a result, CLR has to resort back to dynamically export a tlb on the fly to solve the issue. 
This usually works well for embedded interop classes and interfaces since they are [ComImport], but not for structs since it can't have [ComImport]. Therefore, CLR uses [ComVisible()] setting on struct to determine whether the importing is needed. If [ComVisible(false)] is set on assembly level (which is the **default**), CLR would ignore the struct and the struct would fail to be found in the exported type lib. 
If you turn off embed interop types, or change the default [ComVisible(false)] to true, you wouldn't see this issue. 
To work well with CLR, it might be reasonable to make such structs [ComVisible(true)] when embedding them. 
</Description>
    <CreatedDate>01/01/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16279</IssueID>
    <RepoID>1</RepoID>
    <Title>Apply ComVisible attribute to embedded value types.</Title>
    <Description>**Customer scenario**
Marshaling of embedded value types is not working in some interop scenarios when ComVisible(false) is applied to the embedding assembly. See #16177 for more information.

**Bugs this fixes:** 
Fixes #16177.

**Workarounds, if any**
Remove ComVisible(false) from the assembly, but this is going to expose all types not explicitly marked with ComVisible(false) to COM, which is not always desirable.

**Risk**
Low

**Performance impact**
Low

**Is this a regression from a previous update?**
No.

**Root cause analysis:**
Added tests.

**How was the bug found?**
Customer reported.

@dotnet/roslyn-compiler Please review.</Description>
    <CreatedDate>06/01/2017</CreatedDate>
    <ClosedDate>06/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16478</IssueID>
    <RepoID>1</RepoID>
    <Title>Regression around order in which convertibility of arguments is evaluated</Title>
    <Description>As found [here](https://github.com/aspnet/Common/issues/181).

**Version Used**: 
2.0.0.61213

**Steps to Reproduce**:

1. Compile and run this:
```c#
using System;
using System.Collections.Generic;

public class Test
{
    public static void Assert&lt;T&gt;(T a, T b)
    {
        Console.WriteLine("Non collection");
    }

    public static void Assert&lt;T&gt;(IEnumerable&lt;T&gt; a, IEnumerable&lt;T&gt; b)
    {
        Console.WriteLine("Collection");
    }
    
    public static void Main()
    {
        string[] a = new[] { "A" };
        StringValues b = new StringValues();

        Assert(a, b);
    }
    
    private class StringValues : List&lt;string&gt;
    {
        public static implicit operator StringValues(string[] values)
        {
            return new StringValues();
        }
        
        public static implicit operator string[] (StringValues value)
        {
            return new string[0];
        }
    }
}
```
using version 2.0.0.61213. Note that the result is "Non collection".

2. Compile it using version 1.3.1.60616 and note that the result is "Collection".

**Expected Behavior**:
We expect the same implicit conversion (and thus Assert overload) to be performed.

**Actual Behavior**:
The other implicit conversion is used instead.

CC @pranavkm</Description>
    <CreatedDate>12/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36982</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix Solution.WithDocumentFilePath not updating the file path of the tree</Title>
    <Description>DocumentState.UpdateFilePath was still passing in the old attributes when producing a new tree source -- oops!</Description>
    <CreatedDate>04/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15536</IssueID>
    <RepoID>1</RepoID>
    <Title>Bad codegen in call-forward to local function in different switch block</Title>
    <Description>From #15322:

```csharp
class Program
{
    static void Main(string[] args)
    {
        object o = null;
        switch (o)
        {
            case string x:
                Assign();
                Foo();
                break;
            case int x:
                void Assign() { x = 5; }
                void Foo() =&gt; System.Console.WriteLine(x);
                break;
        }
    }
}
```

The problem seems to be getting the information for the local in CodeGen. It's not clear if this is an issue </Description>
    <CreatedDate>26/11/2016</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16066</IssueID>
    <RepoID>1</RepoID>
    <Title>Pattern matching crashes if lambda captures pattern variable</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 2017 RC
Version 15.0.26014.0 D15REL
Microsoft .NET Framework
Version 4.6.01055

**Steps to Reproduce**:
Run the following app:

```
using System.Collections.Generic;
using System.Linq;

namespace ConsoleApp2017
{
    class Program
    {
        class A
        {
        }
        
        static void Main(string[] args)
        {                           
            var dummy = new List&lt;int&gt;();

            switch((object)new A())
            {
                case A a:
                    {
                        dummy.Any(x =&gt; a != null);
                    }
                    break;
            }
        }
    }
}
```
**Expected Behavior**:
App just runs, no output.

**Actual Behavior**:
Null-reference on the switch statement, when trying to initialize not created instance of a hidden class &lt;&gt;c__DisplayClass27_0 CS$&lt;&gt;8__locals0;

Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object.
   at ConsoleApp2017.Program.Main(String[] args) in D:\Temp\ConsoleApp2017\ConsoleApp2017\Program.cs:line 16
</Description>
    <CreatedDate>22/12/2016</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36982</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix Solution.WithDocumentFilePath not updating the file path of the tree</Title>
    <Description>DocumentState.UpdateFilePath was still passing in the old attributes when producing a new tree source -- oops!</Description>
    <CreatedDate>04/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16513</IssueID>
    <RepoID>1</RepoID>
    <Title>The semantic of constant pattern</Title>
    <Description>I propose to change the semantic of constant pattern match from current:
```c#
foo is 42 /* == */ object.Equals(foo, 42)
```
…to the opposite:
```c#
foo is 42 /* == */ object.Equals(42, foo)
```

And this is how `object.Equals(object, object)` is implemented:
```c#
public static bool Equals(Object objA, Object objB) {
  if (objA==objB) {
    return true;
  }
  if (objA==null || objB==null) {
    return false;
  }
  return objA.Equals(objB);
}
```

The reasons behind proposed change:
1. Currently the "constant patterns" are not that "constant": generated code involves the execution of arbitrary 'object.Equals(object)' implementation on `foo` instance (in the case it is not `null`), since `object.Equals(object, object)` invokes it on first argument.
2. The idiom `foo is null` do not actually means `((object) foo) == null` as most of users would expect. It is easy to define a type that would pass `foo is null` check while being not-`null` (how would this play with future non-nullable types and their dataflow analysis?).
3. You won't be able to get rid of suboptimal code for constant patterns of reference types #13247, since such optimizations would change the semantic of matching.
4. If the arguments of `object.Equals()` would be reversed, the nice property of `is` expression would be restored — if right operand (type or pattern) has a type, the `is` expression only produce `true` if the left operand is of implicitly convertible type. Constant patterns do have types, literal expression do have types, `42` is of type `int`… who would expect `(int) foo` after successful `foo is 42` check to throw `InvalidCastException`?

p.s. Maybe it's a good idea to behave like F#: literal patterns of type `int` are only allowed when pattern is matched against the value of `int` type (but that's because of ML's "no implicit conversions" rule, I think).

cc @gafter</Description>
    <CreatedDate>14/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33603</IssueID>
    <RepoID>1</RepoID>
    <Title>If multiple constructors exist, offer Add Parameters to constructor for each one</Title>
    <Description>If more than one constructor exists, the "Add Parameters to constructor" refactoring only offers to add parameters to one of them.  We should expand to include each applicable constructor individual.

Related to #8925 </Description>
    <CreatedDate>22/02/2019</CreatedDate>
    <ClosedDate>26/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29457</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix issue where 'remove parens' would break code with ++/-- operators.</Title>
    <Description>Fixes https://github.com/dotnet/roslyn/issues/29454

Also fixes a related issue i found while looking into this area where we could break code of the form `x+(++y)`.  </Description>
    <CreatedDate>23/08/2018</CreatedDate>
    <ClosedDate>30/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36894</IssueID>
    <RepoID>1</RepoID>
    <Title>When should variance be permitted for nullable type arguments?</Title>
    <Description>I encountered the following couple of scenarios just now:

```cs
#nullable enable

using System.Threading.Tasks;

public class C {
    public Task&lt;string?&gt; M1() {
        // warning CS8619: Nullability of reference types in value of type
        // 'Task&lt;string&gt;' doesn't match target type 'Task&lt;string?&gt;'.
        return Task.FromResult("hello");
    }

    public void M2(Task&lt;string?&gt; task) { }
    public void M3()
    {
        // warning CS8620: Argument of type 'Task&lt;string&gt;' cannot be used for
        // parameter 'task' of type 'Task&lt;string?&gt;' in 'void C.M2(Task&lt;string?&gt; task)'
        // due to differences in the nullability of reference types.
        M2(Task.FromResult("hello"));
    }
}
```

I see a few fixes users can do for this:
1. change to `Task.FromResult("hello")!`
2. change to `Task.FromResult&lt;string?&gt;("hello")`
3. `Task.FromResult((string?)"hello")` ~~(this gets marked as redundant by the IDE)~~

It feels like there should be some way to allow nullable variance of certain type parameters so that such workarounds aren't necessary. Interface types can have `in`/`out` modifiers on their type parameters but this doesn't work for types like `Task&lt;T&gt;`.</Description>
    <CreatedDate>29/06/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36371</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge master-vs-deps to release/dev16.3-preview1-vs-deps</Title>
    <Description>
This is an automatically generated pull request from master-vs-deps into release/dev16.3-preview1-vs-deps.
(created from a manual run of the PR generation tool)

``` bash
git fetch --all
git checkout merges/master-vs-deps-to-release/dev16.3-preview1-vs-deps
git reset --hard upstream/release/dev16.3-preview1-vs-deps
git merge upstream/master-vs-deps
# Fix merge conflicts
git commit
git push upstream merges/master-vs-deps-to-release/dev16.3-preview1-vs-deps --force
```

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>12/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36416</IssueID>
    <RepoID>1</RepoID>
    <Title>Add nullable to IntroduceVariableService</Title>
    <Description>Use symbol info on exrpressions to get the nullable type if applicable

Fixes #30318</Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>20/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16296</IssueID>
    <RepoID>1</RepoID>
    <Title>ArgumentNullException binding a pattern switch</Title>
    <Description>When running some custom static code analysis on Roslyn.sln, I get an "Unknown hard error". In the Windows EventViewer, I find the following error:
```
Application: csc.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.ArgumentNullException: Value cannot be null.
Parameter name: key
   at System.Collections.Generic.Dictionary`2.FindEntry(TKey key)
   at System.Collections.Generic.Dictionary`2.TryGetValue(TKey key, TValue&amp; value)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(BoundPattern pattern, DecisionTree decisionTree, Boolean inputCouldBeNull)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(BoundPatternSwitchLabel label, DiagnosticBag diagnostics, Boolean&amp; valueMatched)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(BoundExpression boundSwitchExpression, SwitchSectionSyntax node, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; someValueMatched, SubsumptionDiagnosticBuilder subsumption, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(BoundExpression boundSwitchExpression, SyntaxList`1 sections, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, Boolean&amp; isComplete, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(ForStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].FindEntry(System.__Canon)
   at System.Collections.Generic.Dictionary`2[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].TryGetValue(System.__Canon, System.__Canon ByRef)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.CheckSubsumed(Microsoft.CodeAnalysis.CSharp.BoundPattern, Microsoft.CodeAnalysis.CSharp.DecisionTree, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder.AddLabel(Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel, Microsoft.CodeAnalysis.DiagnosticBag, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.CSharp.SubsumptionDiagnosticBuilder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Boolean ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.ForLoopBinder.BindForParts(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Microsoft.CodeAnalysis.CSharp.TypeCompilationState, Microsoft.CodeAnalysis.DiagnosticBag, Microsoft.CodeAnalysis.CSharp.ImportChain ByRef, Boolean ByRef)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol, Int32, ProcessedFieldInitializers ByRef, Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields, Microsoft.CodeAnalysis.CSharp.TypeCompilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler+&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities+&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task, Boolean)
   at System.Threading.Tasks.Task.WrappedTryRunInline()
   at System.Threading.Tasks.Task.InternalWait(Int32, System.Threading.CancellationToken)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(Microsoft.CodeAnalysis.CSharp.CSharpCompilation, Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder, Boolean, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, System.Predicate`1&lt;Microsoft.CodeAnalysis.CSharp.Symbol&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(Microsoft.CodeAnalysis.DiagnosticBag, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(Microsoft.CodeAnalysis.CompilationStage, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable.ExcludePrivateFieldsBasedOnCompilerErrors(System.Collections.Immutable.IImmutableDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,PrivateField&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol&gt;&gt;, System.Collections.Immutable.IImmutableSet`1&lt;Microsoft.CodeAnalysis.ISymbol&gt;, Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)
   at SonarAnalyzer.Rules.CSharp.PrivateFieldUsedAsLocalVariable+&lt;&gt;c.&lt;Initialize&gt;b__9_0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.DiagnosticAnalyzerContextHelper+&lt;&gt;c__DisplayClass0_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeActionInNonGenerated&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at SonarAnalyzer.Helpers.SonarAnalysisContext+&lt;&gt;c__DisplayClass12_0`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;RegisterSyntaxNodeAction&gt;b__0(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor+&lt;&gt;c__DisplayClass42_1`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].&lt;ExecuteSyntaxNodeAction&gt;b__1()
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows_NoLock(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteAndCatchIfThrows(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, System.Action, System.Nullable`1&lt;Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo&gt;)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeAction[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](Microsoft.CodeAnalysis.SyntaxNode, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, System.Action`1&lt;Microsoft.CodeAnalysis.Diagnostic&gt;, SyntaxNodeAnalyzerStateData)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.ExecuteSyntaxNodeActionsCore[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, SyntaxNodeAnalyzerStateData, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor.TryExecuteSyntaxNodeActions[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](System.Collections.Generic.IEnumerable`1&lt;Microsoft.CodeAnalysis.SyntaxNode&gt;, System.Collections.Generic.IDictionary`2&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Collections.Immutable.ImmutableArray`1&lt;Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1&lt;Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;&gt;&gt;, Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer, Microsoft.CodeAnalysis.SemanticModel, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.SyntaxKind&gt;, Microsoft.CodeAnalysis.Text.TextSpan, Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.ISymbol, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.SyntaxReference, Int32, Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, Boolean, Boolean, Boolean, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1[[Microsoft.CodeAnalysis.CSharp.SyntaxKind, Microsoft.CodeAnalysis.CSharp, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]].TryExecuteDeclaringReferenceActions(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessSymbolDeclared(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.TryProcessEventCore(Microsoft.CodeAnalysis.Diagnostics.CompilationEvent, Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;ProcessCompilationEventsCoreAsync&gt;d__70, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProcessCompilationEventsCoreAsync&gt;d__70 ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessCompilationEventsCoreAsync(Microsoft.CodeAnalysis.Diagnostics.AnalysisScope, Microsoft.CodeAnalysis.Diagnostics.AnalysisState, Boolean, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0+&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d, Microsoft.CodeAnalysis, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;&lt;ProcessCompilationEventsAsync&gt;b__0&gt;d ByRef)
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver+&lt;&gt;c__DisplayClass69_0.&lt;ProcessCompilationEventsAsync&gt;b__0()
   at System.Threading.Tasks.Task`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
```

I have no easy repro of the issue. But from the stacktrace it seems that `null` is being passed to the `TryGetValue` of the dictionary in `SubsumptionDiagnosticBuilder.CheckSubsumed`: `byValue.ValueAndDecision.TryGetValue(constantPattern.Value.ConstantValue.Value, out decision)`. 

Sidenote: I have no easy repro of the issue, because I can't identify what input source code and code analyzer produces this error. I'm trying to run a SonarQube analysis of the Roslyn project based on this: http://docs.sonarqube.org/display/SCAN/From+the+Command+Line. Internally what happens is that when `msbuild Roslyn.sln` is called, then a custom analyzer DLLs are being passed to CSC with the help of a targets file. In general this approach is working, and it was also working for the Roslyn.sln, however as the Roslyn.sln dogfeeds the latest CSC to itself, due to the above bug, the analysis also fails. </Description>
    <CreatedDate>06/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16559</IssueID>
    <RepoID>1</RepoID>
    <Title>Stack Overflow in BindPatternSwitchLabelForInference</Title>
    <Description>**Version Used**: VS2015 RC3

**Steps to Reproduce**:

Attempt to compile this code:

```cs
public class Program5815
{
    public static void Main(string[] args)
    {
        switch ((int)M())
        {
            case var x3:
            case true ? x3 : 4:
                break;
        }
    }
    private static object M() =&gt; null;
}
```

**Expected Behavior**: Compiler error about case label not being a constant

**Actual Behavior**: Compiler stack overflow

See also https://devdiv.visualstudio.com/DefaultCollection/DevDiv/_workitems?_a=edit&amp;id=369796</Description>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>25/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16517</IssueID>
    <RepoID>1</RepoID>
    <Title>Bind behavior of simple name under 'is' constant pattern</Title>
    <Description>I'm not sure this is by design or not, but simple name bind in constant pattern under `is` expression differs from ordinary member access bind or bind of constant pattern under `case` label:
```c#
using System;

class Foo {
  public ClassVsProp ClassVsProp { get; }

  public void M(object o) {
    if ((string) o == ClassVsProp.Constant) { } // OK
  
    // error CS0176: Member 'ClassVsProp.Constant' cannot be accessed
    // with an instance reference; qualify it with a type name instead
    if (o is ClassVsProp.Constant) { }

    switch (o) {
      case ClassVsProp.Constant: // OK
        break;
    }
  }
}

class ClassVsProp {
  public const string Constant = "abc";
}
```

I think the difference arises because syntax tree shape: simple syntax name node in `o is ClassVsProp.Constant` is not wrapped into constant pattern syntax node, since it's impossible to disambiguate it with ordinary type usage of `is` expressions.

cc @gafter</Description>
    <CreatedDate>15/01/2017</CreatedDate>
    <ClosedDate>18/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16167</IssueID>
    <RepoID>1</RepoID>
    <Title>VS crashes if xml is pasted in C# editor</Title>
    <Description>**Version Used**: 

**Steps to Reproduce**:

1. create new C# console app
2. paste text below as a body of `Main`
```xml
      &lt;summary&gt;Copies a range of elements from an &lt;see cref="T:System.Array" /&gt; starting at the first element and pastes them into another &lt;see cref="T:System.Array" /&gt; starting at the first element. The length is specified as a 32-bit integer.&lt;/summary&gt;
      &lt;param name="sourceArray"&gt;The &lt;see cref="T:System.Array" /&gt; that contains the data to copy.&lt;/param&gt;
      &lt;param name="destinationArray"&gt;The &lt;see cref="T:System.Array" /&gt; that receives the data.&lt;/param&gt;
      &lt;param name="length"&gt;A 32-bit integer that represents the number of elements to copy.&lt;/param&gt;
      &lt;exception cref="T:System.ArgumentNullException"&gt;
        &lt;paramref name="sourceArray" /&gt; is null.-or-&lt;paramref name="destinationArray" /&gt; is null.&lt;/exception&gt;
      &lt;exception cref="T:System.RankException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; have different ranks.&lt;/exception&gt;
      &lt;exception cref="T:System.ArrayTypeMismatchException"&gt;
        &lt;paramref name="sourceArray" /&gt; and &lt;paramref name="destinationArray" /&gt; are of incompatible types.&lt;/exception&gt;
      &lt;exception cref="T:System.InvalidCastException"&gt;At least one element in &lt;paramref name="sourceArray" /&gt; cannot be cast to the type of &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentOutOfRangeException"&gt;
        &lt;paramref name="length" /&gt; is less than zero.&lt;/exception&gt;
      &lt;exception cref="T:System.ArgumentException"&gt;
        &lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="sourceArray" /&gt;.-or-&lt;paramref name="length" /&gt; is greater than the number of elements in &lt;paramref name="destinationArray" /&gt;.&lt;/exception&gt;

```

**Expected Behavior**:
Sea of red in the editor.

**Actual Behavior**:
VS crashes:
```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(SyntaxNode syntax, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, List`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeOrExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__83&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass74_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()

```
</Description>
    <CreatedDate>31/12/2016</CreatedDate>
    <ClosedDate>13/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16315</IssueID>
    <RepoID>1</RepoID>
    <Title>Expression variables declared in a local function parameter default are given a scope</Title>
    <Description>**Customer scenario**

If you declare an expression variable (e.g. out variable) inside the default value
expression of a parameter to a local function, the IDE crashes.

**Bugs this fixes:** 

Fixes #16167

**Workarounds, if any**

Don't make that mistake.

**Risk**

Small. Corrects a small oversight in the implementation of the interaction of new language features.

**Performance impact**

Trivial.

**Is this a regression from a previous update?**

No.

**Root cause analysis:**

Missing test for interaction between multiple new language features. Lack of dedicated testing team. Lack of coordinated testing role for new features and interactions between new features.

**How was the bug found?**

Customer reported.

@AlekseyTs @agocke @dotnet/roslyn-compiler May I please have a couple of reviews for this very small bug fix?
</Description>
    <CreatedDate>07/01/2017</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14152</IssueID>
    <RepoID>1</RepoID>
    <Title>VB tuples: inference of method type parameters is wrong</Title>
    <Description>The overload resolution for the first invocation of `Test1` below picks `T` as `Integer` and `U` as `(Integer, Integer)`. This results in a crash at runtime.

``` VB
        &lt;Fact&gt;
        Public Sub Inference13()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation name="Tuples"&gt;
    &lt;file name="a.vb"&gt;
Imports System
Public Class C
    Shared Sub Main()
        Test1((a:=1, b:=(a:=1, b:=2)), (a:=1, b:=DirectCast(1, Object)))
        Test1((a:=1, b:=(a:=1, b:=2)), (a:=1, b:=(c:=1, d:=2)))
        Test1((a:=1, b:=(a:=1, b:=2)), (a:=1, b:=(1, 2)))
        Test1((a:=1, b:=(a:=1, b:=2)), (a:=1, b:=(a:=1, b:=2)))
    End Sub

    Shared Sub Test1(Of T, U)(x As (T, U)?, y As (T, U))
        Console.WriteLine(GetType(U))
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
System.Object
System.ValueTuple`2[System.Int32,System.Int32]
System.ValueTuple`2[System.Int32,System.Int32]
System.ValueTuple`2[System.Int32,System.Int32]
")
            ' Compiled code fails at runtime, trying to convert the object to a ValueTuple

        End Sub
```

FYI for @VSadov 
</Description>
    <CreatedDate>28/09/2016</CreatedDate>
    <ClosedDate>12/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16171</IssueID>
    <RepoID>1</RepoID>
    <Title>throw expression in ref returning methods produces an error</Title>
    <Description>**Version Used**: https://github.com/dotnet/roslyn/commit/a2df65047264ed08fb3a985056085dbcee821253

**Steps to Reproduce**:

```cs
class C
{
    ref int M() =&gt; throw null;
}
```
**Expected Behavior**: No error

**Actual Behavior**: `By-value returns may only be used in methods that return by value`


</Description>
    <CreatedDate>01/01/2017</CreatedDate>
    <ClosedDate>05/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16122</IssueID>
    <RepoID>1</RepoID>
    <Title>Throw expression inside Linq.Expression</Title>
    <Description>**Version Used**: 
C#7, VS 2017 RC (Version 15.0.26014.0 D15REL)
**Steps to Reproduce**:

```
Enumerable.Range(0, 100).AsQueryable().Select(i =&gt; i &lt; 1000 ? i : throw new Exception())
```

**Expected Behavior**:
It should translate throw expression into `Expression.Throw(...)` and execute query.

**Actual Behavior**:
In project it says `"csc.exe" exited with code -2146232797.` which is kind of hard to understand. In C# interactive it prints exception:
```
Unexpected error:
System.InvalidOperationException: Unexpected value 'ThrowExpression' of type 'Microsoft.CodeAnalysis.CSharp.BoundKind'
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitInternal(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.Visit(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExactType(BoundExpression e)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitConditionalOperator(BoundConditionalOperator node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitInternal(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.Visit(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.TranslateLambdaBody(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitLambdaInternal(BoundLambda node)
   at Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.RewriteLambda(BoundLambda node, TypeCompilationState compilationState, TypeMap typeMap, Int32 recursionDepth, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteLambdaConversion(BoundLambda node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitConversion(BoundConversion conversion)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.DoVisitList[T](ImmutableArray`1 list)
   at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitConversion(BoundConversion node)
   at Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.VisitConversion(BoundConversion conversion)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitConversion(BoundConversion conversion)
   at Microsoft.CodeAnalysis.CSharp.BoundConversion.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitReturnStatement(BoundReturnStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundReturnStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter.VisitSequencePoint(BoundSequencePoint node)
   at Microsoft.CodeAnalysis.CSharp.BoundSequencePoint.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.RewriteBlock(BoundBlock node, ArrayBuilder`1 prologue, ArrayBuilder`1 newLocals)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, Int32 methodOrdinal, MethodSymbol substitutedSourceMethod, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, Boolean assignLocals)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Scripting.ScriptBuilder.Build[T](Compilation compilation, DiagnosticBag diagnostics, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Scripting.ScriptBuilder.CreateExecutor[T](ScriptCompiler compiler, Compilation compilation, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Scripting.Script`1.GetExecutor(CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Scripting.Script`1.CommonCompile(CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.TryCompile(Script previousScript, String code, String path, ScriptOptions options)
   at Microsoft.CodeAnalysis.Interactive.InteractiveHost.Service.&lt;ExecuteAsync&gt;d__30.MoveNext()
```	
</Description>
    <CreatedDate>28/12/2016</CreatedDate>
    <ClosedDate>05/01/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14365</IssueID>
    <RepoID>1</RepoID>
    <Title>Error symbols are not fully roundtrippable</Title>
    <Description>Currently, it is possible to get error NamedTypeSymbols that we cannot fully roundtrip with the IDE's OOP process.  Specifically, error types may point to error namespaces as their containing symbol.  However, there is currently no way to specify that namespace when we try to re-realize the error type.  i.e. we have this:

```
        public abstract INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
```

But we do not have a way to Create the container in the case of something like an error namespace.  
</Description>
    <CreatedDate>07/10/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29655</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge master to features/embeddedRegex</Title>
    <Description>
This is an automatically generated pull request from master into features/embeddedRegex.

``` bash
git fetch --all
git checkout merges/master-to-features/embeddedRegex
git reset --hard upstream/features/embeddedRegex
git merge upstream/master
# Fix merge conflicts
git commit
git push merges/master-to-features/embeddedRegex --force
```

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
    <CreatedDate>04/09/2018</CreatedDate>
    <ClosedDate>27/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21771</IssueID>
    <RepoID>1</RepoID>
    <Title>InvalidOperationException from Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.GetDocument</Title>
    <Description>Stack trace:

```
   at Roslyn.Utilities.Contract.ThrowIfNull[T](T value, String message)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.GetDocument()
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.FilterModelInBackgroundWorker(Model model, Int32 id, SnapshotPoint caretPosition, CompletionFilterReason filterReason, ImmutableDictionary`2 filterState)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.FilterModelInBackground(Model model, Int32 id, SnapshotPoint caretPosition, CompletionFilterReason filterReason, ImmutableDictionary`2 filterState)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.Completion.Controller.Session.&lt;&gt;c__DisplayClass13_0.&lt;FilterModel&gt;b__0(Model model)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.ModelComputation`1.&lt;&gt;c__DisplayClass16_0.&lt;ChainTaskAndNotifyControllerWhenFinished&gt;b__0(TModel m, CancellationToken c)
   at Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.ModelComputation`1.&lt;&gt;c__DisplayClass17_0.&lt;ChainTaskAndNotifyControllerWhenFinished&gt;b__0(Task`1 t)
   at Roslyn.Utilities.TaskExtensions.&lt;&gt;c__DisplayClass16_0`2.&lt;SafeContinueWithFromAsync&gt;b__0(Task antecedent)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1.InnerInvoke() in f:\dd\ndp\clr\src\BCL\system\threading\Tasks\TaskContinuation.cs:line 121
   at System.Threading.Tasks.Task.Execute() in f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs:line 2498
```

Crash dump: %internal_share%\public\tomat\Bugs\21771

VS version: 15.4.0 P1 (26823.1.d15rel)</Description>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>11/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15934</IssueID>
    <RepoID>1</RepoID>
    <Title>Using a pointer type in a deconstruction crashes the compiler</Title>
    <Description>**Version Used**: https://github.com/dotnet/roslyn/commit/a2df65047264ed08fb3a985056085dbcee821253

**Steps to Reproduce**:
```cs
class C {
    unsafe void M() {
    	(int* x, int y) = M2();
    }
}
```
**Expected Behavior**: The compiler should not crash.

**Actual Behavior**: The compiler crashes with an invalid cast exception. See the [repro and call stack](http://tryroslyn.azurewebsites.net/#b:master/K4OwzghgZgpgBAYwDYTGOBhAUAby3AuANwHsBLAEzgFkAKASn0L0LgEhayQAXAKjgAeAGjhducAJ704AXhoAmBgG4mBAL6q4mzj14ix06osZs8bDWqA=).</Description>
    <CreatedDate>15/12/2016</CreatedDate>
    <ClosedDate>21/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15734</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect precedence of `is` operator</Title>
    <Description>```C#
class Program
{
    static void Main(string[] args)
    {
        if (args is string[] || args.Length &gt; 0) // ok
        {
        }

        if (args is null || args.Length &gt; 0) // error
        {
        }
    }
}
```

**Actual result**

```Operator '||' cannot be applied to operands of type '&lt;null&gt;' and 'bool'```

**Expected result**

No error.
</Description>
    <CreatedDate>07/12/2016</CreatedDate>
    <ClosedDate>21/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15732</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash in out-var analysis.</Title>
    <Description>Tagging @gafter 

Watson bucket: Fault bucket 129302013825, type 5

```
Application: devenv.exe
Framework Version: v4.0.30319
Description: The application requested process termination through System.Environment.FailFast(string message).
Message: System.InvalidOperationException: This program location is thought to be unreachable.
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitOutVariablePendingInference(OutVariablePendingInference node)
   at Microsoft.CodeAnalysis.CSharp.OutVariablePendingInference.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBadExpression(BoundBadExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundBadExpression.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitLvalue(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitForStatement(BoundForStatement node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitForStatement(BoundForStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundForStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState&amp; tryState)
   at Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1.VisitTryStatement(BoundTryStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundTryStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitIfStatement(BoundIfStatement node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitIfStatement(BoundIfStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundIfStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitLambda(BoundLambda node)
   at Microsoft.CodeAnalysis.CSharp.BoundLambda.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitArguments(ImmutableArray`1 arguments, ImmutableArray`1 refKindsOpt, MethodSymbol method)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitCall(BoundCall node)
   at Microsoft.CodeAnalysis.CSharp.BoundCall.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionWithoutStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.VisitExpressionWithStackGuard(Int32&amp; recursionDepth, BoundExpression node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitExpressionStatement(BoundExpressionStatement node)
   at Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitStatementsWithLocalFunctions(BoundBlock block)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitBlock(BoundBlock node)
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Scan(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, Boolean requireOutParamsAssigned)
   at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
   at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1 span, CancellationToken cancellationToken)
```
</Description>
    <CreatedDate>07/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10466</IssueID>
    <RepoID>1</RepoID>
    <Title>MemberSemanticModel.GetQueryEnclosingBinder needs serious overhaul </Title>
    <Description>The logic in the function is fragile in error recovery cases and in some cases might use a binder from a wrong query lambda. For example, from the one preceding the binding failure if binder haven't reached the lambda we are asking for. In presence of match expressions, it becomes very important to get the binder from the right lambda because, if we fail to find a binder for a match case section, binding would crash. And we won't find the binder if we are dealing with a root binder for a different lambda. Perhaps the fix should involve some changes in the binding of query expressions, it should probably keep creating lambdas for query clauses even after an error has been encountered. Alternatively, semantic model should be smart enough to recover by creating the lambdas on the fly.        
</Description>
    <CreatedDate>11/04/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13685</IssueID>
    <RepoID>1</RepoID>
    <Title>Overload resolution uses quadratic algorithm to find the best candidate.</Title>
    <Description>Overload resolution (unary operators, binary operators, and methods) uses a quadratic algorithm to select the best candidate, because it compares every candidate to every other candidate.

There is a simple linear algorithm that gives the same result: scan once to find a possibly best method, and then scan a second time to ensure that it is better than every other candidate.
</Description>
    <CreatedDate>08/09/2016</CreatedDate>
    <ClosedDate>21/06/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13200</IssueID>
    <RepoID>1</RepoID>
    <Title>References to generic types when linking/embedding should fail compilation</Title>
    <Description>This came up in the [PR for missing tuple handling cases](https://github.com/dotnet/roslyn/pull/13024#discussion_r74807282).

``` C#
        [ClrOnlyFact]
        public void CannotEmbedValueTupleImplicitlyReferred()
        {
            string piaSource = @"
using System;
using System.Runtime.InteropServices;

[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]
[assembly: ImportedFromTypeLib(""Pia1.dll"")]

public struct S&lt;T&gt; { }

namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public ValueTuple(T1 item1, T2 item2) { }
    }
}

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58280"")]
public interface ITest1
{
    (int, int) M();
    S&lt;int&gt; M2();
}";

            var pia = CreateCompilationWithMscorlib(piaSource, options: TestOptions.ReleaseDll, assemblyName: "pia");
            pia.VerifyEmitDiagnostics();

            string source = @"
public interface ITest2 : ITest1 { }
";

            // We should expect errors as generic types cannot be embedded
            var expectedDiagnostics = new DiagnosticDescription[]
            {
            };

            var comp1 = CreateCompilationWithMscorlib(source, options: TestOptions.ReleaseDll,
                            references: new MetadataReference[] { pia.ToMetadataReference(embedInteropTypes: true) });
            comp1.VerifyEmitDiagnostics(expectedDiagnostics);

            var comp2 = CreateCompilationWithMscorlib(source, options: TestOptions.ReleaseDll,
                            references: new MetadataReference[] { pia.EmitToImageReference(embedInteropTypes: true) });
            comp2.VerifyEmitDiagnostics(expectedDiagnostics);
        }

        [ClrOnlyFact]
        public void CannotEmbedValueTupleImplicitlyReferredFromMetadata()
        {
            string piaSource = @"
using System;
using System.Runtime.InteropServices;

[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]
[assembly: ImportedFromTypeLib(""Pia1.dll"")]

public struct S&lt;T&gt; { }

namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public ValueTuple(T1 item1, T2 item2) { }
    }
}";

            var libSource = @"
public class D
{
    public static (int, int) M() { throw new System.Exception(); }
    public static S&lt;int&gt; M2() { throw new System.Exception(); }
}";

            var pia = CreateCompilationWithMscorlib(piaSource, options: TestOptions.ReleaseDll, assemblyName: "pia");
            pia.VerifyDiagnostics();

            var lib = CreateCompilationWithMscorlib(libSource, options: TestOptions.ReleaseDll, references: new[] { pia.ToMetadataReference() });
            lib.VerifyEmitDiagnostics();

            string source = @"
public class C
{
    public void TestTupleFromMetadata()
    {
        D.M();
        D.M2();
    }
    public void TestTupleAssignmentFromMetadata()
    {
        var t = D.M();
        t.ToString();
        var t2 = D.M2();
        t2.ToString();
    }
}";

            // We should expect errors, as generic types cannot be embedded
            var expectedDiagnostics = new DiagnosticDescription[]
            {
            };

            var comp1 = CreateCompilationWithMscorlib(source, options: TestOptions.ReleaseDll,
                            references: new MetadataReference[] { pia.ToMetadataReference(embedInteropTypes: true), lib.ToMetadataReference() });
            comp1.VerifyEmitDiagnostics(expectedDiagnostics);

            var comp2 = CreateCompilationWithMscorlib(source, options: TestOptions.ReleaseDll,
                            references: new MetadataReference[] { pia.EmitToImageReference(embedInteropTypes: true), lib.EmitToImageReference() });
            comp2.VerifyEmitDiagnostics(expectedDiagnostics);
        }
```

FYI for @AlekseyTs 
</Description>
    <CreatedDate>16/08/2016</CreatedDate>
    <ClosedDate>06/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12940</IssueID>
    <RepoID>1</RepoID>
    <Title>Missing bound node for out variable declaration</Title>
    <Description>We have a design invariant for the bound nodes that the initial bound tree is roughly isomorphic to the shape of the syntax. We create and retain bound nodes even when they do not represent runtime operations, e.g. local variable declarations.

The out variable declaration is not retained in the initial bound trees. It should be. This would slightly simplify the handling of the diagnostic reporting it being unsupported in expression trees, for example, and would simplify the handling of some error cases in flow analysis. It is necessary for region analysis to compute the "declared inside" property.
</Description>
    <CreatedDate>04/08/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14110</IssueID>
    <RepoID>1</RepoID>
    <Title>DataFlowAnalysis.VariablesDeclared does not handle deconstruction declarations</Title>
    <Description>The following proposed unit test fails.

``` cs
        [Fact, WorkItem(14110, "https://github.com/dotnet/roslyn/issues/14110")]
        public void Test14110()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        var (x, y) = (1, 2);
        (var a, var b) = (3, 4);
/*&lt;/bind&gt;*/
        Console.WriteLine(x + a);
    }
}
");
            Assert.Equal("a, b, x, y", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```

One symptom of this is #14108.
</Description>
    <CreatedDate>27/09/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15640</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException in DeclaredInside for deconstruction foreach loop</Title>
    <Description>The following test fails with a `NullReferenceException`.

```cs
        [Fact, WorkItem(15640, "https://github.com/dotnet/roslyn/issues/15640")]
        public void Test15640()
        {
            var dataFlowAnalysisResults = CompileAndAnalyzeDataFlowStatements(@"
using System;

class Program
{
    static void Main()
    {
/*&lt;bind&gt;*/
        foreach (var (a, b) in new[] { (1, 2) }) {}
/*&lt;/bind&gt;*/
    }
}
");
            Assert.Equal("a, b", GetSymbolNamesJoined(dataFlowAnalysisResults.VariablesDeclared));
        }
```
</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15399</IssueID>
    <RepoID>1</RepoID>
    <Title>Missing error when a ValueTuple contains a pointer type</Title>
    <Description>**Version Used**: 

RC insider VSIX from [this documentation](https://github.com/dotnet/roslyn/blob/master/docs/contributing/Building,%20Debugging,%20and%20Testing%20on%20Windows.md)

Visual Studio 2015 Update 3

**Steps to Reproduce**:

1. Allow unsafe.
2. Paste this code snippet:
```` C#
unsafe void ValueTupleWithPointer()
{
    (byte*, int) t = (null, 1);
}
````
3.  Build

**Expected Behavior**:

CS0306 The type 'byte*' may not be used as a type argument

**Actual Behavior**:

No compile-time error, but runtime error:

````
System.TypeLoadException: The generic type 'System.ValueTuple`2' was used with an invalid instantiation in assembly 'System.ValueTuple, Version=4.0.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.
````</Description>
    <CreatedDate>20/11/2016</CreatedDate>
    <ClosedDate>23/01/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15555</IssueID>
    <RepoID>1</RepoID>
    <Title>Throw in expression bodied lambdas is a syntax error</Title>
    <Description>**Version Used**: 
2017 RC
**Steps to Reproduce**:
@gafter in #13389, it says that a throw expression is permitted as the body of an expression-bodied lambda or method. I receive the error
&gt; error CS8115: A throw expression is not allowed in this context.
With the following code
```C#
Action a = () =&gt; throw new Exception();
```
I'm not sure if this was an intentional change but I don't see it documented. Thanks!
**Expected Behavior**:
Throw expressions may be used in an expression bodied lambda expression.
**Actual Behavior**:
Throw expressions are not legal as the bodies of expression bodied lambda expressions.</Description>
    <CreatedDate>28/11/2016</CreatedDate>
    <ClosedDate>09/12/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14453</IssueID>
    <RepoID>1</RepoID>
    <Title>ReturnType CustomModifiers are simply copied from overridden method</Title>
    <Description>This is not correct when overridden method is generic. The modifiers might refer to its type parameters, they should be substituted with corresponding type parameters of the overriding method.

Should check similar scenario with interface implementation.
</Description>
    <CreatedDate>12/10/2016</CreatedDate>
    <ClosedDate>16/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14453</IssueID>
    <RepoID>1</RepoID>
    <Title>ReturnType CustomModifiers are simply copied from overridden method</Title>
    <Description>This is not correct when overridden method is generic. The modifiers might refer to its type parameters, they should be substituted with corresponding type parameters of the overriding method.

Should check similar scenario with interface implementation.
</Description>
    <CreatedDate>12/10/2016</CreatedDate>
    <ClosedDate>16/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14888</IssueID>
    <RepoID>1</RepoID>
    <Title>Bug: Exception compiling iterator of tuples</Title>
    <Description>**Version Used**: http://tryroslyn.azurewebsites.net/ (master Oct 29 2016)

**Steps to Reproduce**:

```cs
using System;
using System.Collections.Generic;

public class C {
    public IEnumerable&lt;(int, int)&gt; entries() {
        yield return (1, 2);
    }
}
```

**Expected Behavior**:

Compiles successfully.

**Actual Behavior**:

```
Unexpected value 'NoConversion' of type 'Microsoft.CodeAnalysis.CSharp.ConversionKind'
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitConversion(BoundConversion conversion) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitConversion.cs:line 117
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitConversionExpression(BoundConversion conversion, Boolean used) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitConversion.cs:line 34
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCore(BoundExpression expression, Boolean used) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 112
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpressionCoreWithStackGuard(BoundExpression expression, Boolean used) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 72
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitExpression(BoundExpression expression, Boolean used) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitExpression.cs:line 60
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitReturnStatement(BoundReturnStatement boundReturnStatement) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 684
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(BoundStatement statement) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 44
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitBlock(BoundBlock block) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 614
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStatement(BoundStatement statement) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\EmitStatement.cs:line 24
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GenerateImpl() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs:line 248
   at Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.Generate() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\CodeGen\CodeGenerator.cs:line 183
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, Int32 methodOrdinal, BoundStatement block, ImmutableArray`1 lambdaDebugInfo, ImmutableArray`1 closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, Boolean emittingPdb, ImmutableArray`1 dynamicAnalysisSpans) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1311
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedMethods(TypeCompilationState compilationState) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 631
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 537
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 323
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 137
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2335
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2016
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\Compilation\Compilation.cs:line 1964
   at TryRoslyn.Core.Processing.CodeProcessor.Process(String code, ProcessingOptions options) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!sites\dotnet-master\Core\Processing\CodeProcessor.cs:line 44
   at TryRoslyn.Web.Api.Controllers.RoslynController.Compilation(CompilationArguments arguments) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!sites\dotnet-master\Web.Api\Controllers\RoslynController.cs:line 18
   at lambda_method(Closure , Object , Object[] )
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.Tracers.HttpControllerTracer.&lt;ExecuteAsyncCore&gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()
```</Description>
    <CreatedDate>02/11/2016</CreatedDate>
    <ClosedDate>10/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14895</IssueID>
    <RepoID>1</RepoID>
    <Title>Port compiler changes for tuples in #13024 from C# to VB</Title>
    <Description>Port compiler changes for tuples in #13024 from the C# compiler to the VB compiler</Description>
    <CreatedDate>02/11/2016</CreatedDate>
    <ClosedDate>10/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14825</IssueID>
    <RepoID>1</RepoID>
    <Title>VS 2015 crashed on C# 7 out var usage </Title>
    <Description>Please check that this code is compiled fine. My VS 2015 version crashed on this piece of code.

**Steps to Reproduce**:

```cs
using System;
using System.Linq;

public class C
{
  public string[] Foo2(out string x) { x = ""; return null; }

  public string[] Foo5(string u) { return null; }
    
  public void Test()      
    {        
        var t = Foo2(out var a).Concat(Foo5(a));
    }
}
```

**Expected Behavior**:

**Actual Behavior**:
</Description>
    <CreatedDate>31/10/2016</CreatedDate>
    <ClosedDate>31/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14761</IssueID>
    <RepoID>1</RepoID>
    <Title>Missing parser error BC30205: End of statement expected.</Title>
    <Description>```
Module Module1

    Sub Main()

    End Sub

    Sub Test(val As Object)
        Dim r As String

        If val Is Nothing Then r = "null" GoTo label1

label1:
    End Sub
End Module
```

Expected:

```
(11) : error BC30205: End of statement expected.

        If val Is Nothing Then r = "null" GoTo label1
                                          ~~~~~~~~~~~
```

Observed: No error, compilation succeeds.
</Description>
    <CreatedDate>26/10/2016</CreatedDate>
    <ClosedDate>01/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14802</IssueID>
    <RepoID>1</RepoID>
    <Title>XAML DocumentAnalyzer does not run for C++ projects</Title>
    <Description>XAML is supported for C++ as well. However, the VisualStudioWorspaceImpl's solution crawler may not have been started since neither the C# nor VB package may have been loaded.
</Description>
    <CreatedDate>28/10/2016</CreatedDate>
    <ClosedDate>31/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14785</IssueID>
    <RepoID>1</RepoID>
    <Title>C# 'is' expression with template + array no longer compiles</Title>
    <Description>**Version Used**: Dev 15 RC build 15.0.25826.0

**Steps to Reproduce**:
1. Create C# console app, .NET Framework 4.6.1
2. Add the following method to Program class:

```
        private static string GetTypeName3(object item) {
            if (item == null) {
                return "null";
            } else if (item is Dictionary&lt;string, object&gt;[]) { // THIS CONDITION DOESN'T COMPILE
                return "tuple(dict(str -&gt; object))";
            } else if (item is object[]) { // THIS CONDITION IS FINE
                return "tuple(object)";
            } else {
                return item.GetType().Name;
            }
        }
```
1. Compile

**Expected Behavior**:
Compiles with no error, like in VS 2015 Update 3.

**Actual Behavior**:
Compile error, red squiggles in editor.

```
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,43,21,49): error CS1525: Invalid expression term 'string'
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,49,21,50): error CS1026: ) expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,49,21,50): error CS1525: Invalid expression term ','
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,49,21,50): error CS1002: ; expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,49,21,50): error CS1513: } expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,57,21,58): error CS1001: Identifier expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,57,21,58): error CS1002: ; expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,57,21,58): error CS1525: Invalid expression term '&gt;'
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,58,21,59): error CS1525: Invalid expression term '['
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,59,21,60): error CS0443: Syntax error; value expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,60,21,61): error CS1002: ; expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(21,60,21,61): error CS1513: } expected
1&gt;c:\users\huvalo\documents\visual studio 2017\Projects\ConsoleApp2\ConsoleApp2\Program.cs(23,15,23,19): error CS1513: } expected
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
```
</Description>
    <CreatedDate>27/10/2016</CreatedDate>
    <ClosedDate>31/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14740</IssueID>
    <RepoID>1</RepoID>
    <Title>Unexpected stepping behavior in C# 7 switch statement</Title>
    <Description>`break` statements of cases whose condition is false are stepped onto like so:

![image](https://cloud.githubusercontent.com/assets/41759/19710787/d08e5484-9ae5-11e6-9efc-a0e4412b9caa.png)

That's confusing since `break` is not executed, the next step doesn't jump out of the switch statement but to the next case. Instead either the execution should first step on `case int a` then evaluate the condition to false and then step on the next case clause, or it should step directly to the body of the case that evaluates to true.
</Description>
    <CreatedDate>26/10/2016</CreatedDate>
    <ClosedDate>29/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14740</IssueID>
    <RepoID>1</RepoID>
    <Title>Unexpected stepping behavior in C# 7 switch statement</Title>
    <Description>`break` statements of cases whose condition is false are stepped onto like so:

![image](https://cloud.githubusercontent.com/assets/41759/19710787/d08e5484-9ae5-11e6-9efc-a0e4412b9caa.png)

That's confusing since `break` is not executed, the next step doesn't jump out of the switch statement but to the next case. Instead either the execution should first step on `case int a` then evaluate the condition to false and then step on the next case clause, or it should step directly to the body of the case that evaluates to true.
</Description>
    <CreatedDate>26/10/2016</CreatedDate>
    <ClosedDate>29/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14721</IssueID>
    <RepoID>1</RepoID>
    <Title>Bug:  Compiler error matching "null" in switch</Title>
    <Description>**Version Used**: master (Oct 22 2016) via http://tryroslyn.azurewebsites.net/

**Steps to Reproduce**:

``` cs
using System;

static class Program {
    static void Test(object o) {
        switch (o) {
            case var value when value != null:
                Console.WriteLine("is not null");
                break;
            case null:
                Console.WriteLine("is null");
                break;
        }
    }

    static void Main() {
    }
}
```

**Expected Behavior**:

Compiles successfully.

**Actual Behavior**:

```
Operation is not valid due to the current state of the object.
   at Microsoft.CodeAnalysis.ConstantValue.Create(Object value, ConstantValueTypeDiscriminator discriminator) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\ConstantValue.cs:line 346
   at Microsoft.CodeAnalysis.ConstantValue.Create(Object value, SpecialType st) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\ConstantValue.cs:line 310
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerBasicSwitch(ByValue byValue) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 460
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(ByValue byValue) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 347
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(BoundExpression expression, DecisionTree decisionTree) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 227
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(Guarded guarded) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 412
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(BoundExpression expression, DecisionTree decisionTree) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 232
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(ByType byType) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 311
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(BoundExpression expression, DecisionTree decisionTree) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 222
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerDecisionTree(BoundExpression expression, DecisionTree decisionTree, ArrayBuilder`1 loweredDecisionTree) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 185
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.LowerPatternSwitch(BoundExpression loweredExpression, BoundPatternSwitchStatement node, ArrayBuilder`1 loweredDecisionTree) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 126
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.MakeLoweredForm(BoundPatternSwitchStatement node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 76
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.PatternSwitchLocalRewriter.MakeLoweredForm(LocalRewriter localRewriter, BoundPatternSwitchStatement node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 51
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitPatternSwitchStatement(BoundPatternSwitchStatement node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_PatternSwitchStatement.cs:line 16
   at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.Accept(BoundTreeVisitor visitor) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 3008
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 140
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitBlock(BoundBlock node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_Block.cs:line 24
   at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Binaries\Obj\CSharpCodeAnalysis\Debug\BoundNodes.xml.Generated.cs:line 2391
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Visit(BoundNode node) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 140
   at Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(CSharpCompilation compilation, MethodSymbol method, Int32 methodOrdinal, NamedTypeSymbol containingType, BoundStatement statement, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, Boolean allowOmissionOfConditionalCalls, Boolean instrumentForDynamicAnalysis, ImmutableArray`1&amp; dynamicAnalysisSpans, DebugDocumentProvider debugDocumentProvider, DiagnosticBag diagnostics, Boolean&amp; sawLambdas, Boolean&amp; sawLocalFunctions, Boolean&amp; sawAwaitInExceptionHandler) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter.cs:line 94
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.LowerBodyOrInitializer(MethodSymbol method, Int32 methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, Boolean instrumentForDynamicAnalysis, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1&amp; dynamicAnalysisSpans, DiagnosticBag diagnostics, VariableSlotAllocator&amp; lazyVariableSlotAllocator, ArrayBuilder`1 lambdaDebugInfoBuilder, ArrayBuilder`1 closureDebugInfoBuilder, StateMachineTypeSymbol&amp; stateMachineTypeOpt) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1159
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 1000
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 433
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 323
   at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\InternalUtilities\UICultureUtilities.cs:line 136
   at System.Threading.Tasks.Task.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers() in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compiler\MethodCompiler.cs:line 137
   at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CompileMethods(CommonPEModuleBuilder moduleBuilder, Boolean emittingPdb, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\CSharp\Portable\Compilation\CSharpCompilation.cs:line 2335
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\Compilation\Compilation.cs:line 2016
   at Microsoft.CodeAnalysis.Compilation.Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1 manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1 embeddedTexts, CancellationToken cancellationToken) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!roslyn\dotnet\Src\Compilers\Core\Portable\Compilation\Compilation.cs:line 1964
   at TryRoslyn.Core.Processing.CodeProcessor.Process(String code, ProcessingOptions options) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!sites\dotnet-master\Core\Processing\CodeProcessor.cs:line 44
   at TryRoslyn.Web.Api.Controllers.RoslynController.Compilation(CompilationArguments arguments) in D:\#TeamCity\buildAgent\work\596e688e8f7f38c8\!sites\dotnet-master\Web.Api\Controllers\RoslynController.cs:line 18
   at lambda_method(Closure , Object , Object[] )
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.&lt;&gt;c__DisplayClass10.&lt;GetExecutor&gt;b__9(Object instance, Object[] methodParameters)
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ActionExecutor.Execute(Object instance, Object[] arguments)
   at System.Web.Http.Controllers.ReflectedHttpActionDescriptor.ExecuteAsync(HttpControllerContext controllerContext, IDictionary`2 arguments, CancellationToken cancellationToken)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.Tracers.HttpControllerTracer.&lt;ExecuteAsyncCore&gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Tracing.ITraceWriterExtensions.&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()
```

---

Note that reversing the labels does compile successfully.  So does replacing the `case null` with `default` or `case var s` with no case guard condition.
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>27/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26441</IssueID>
    <RepoID>1</RepoID>
    <Title>InteractiveCommandHandlerTests.TestCopyToInteractiveWithoutSelection fails in spainish run</Title>
    <Description> In this [spainish run](https://ci.dot.net/job/dotnet_roslyn/job/master/job/windows_debug_spanish_unit32_prtest/597/)

The listener here:
https://github.com/dotnet/roslyn/blob/95d86bc7a884a1221718b3472ff28a7a3be044cf/src/EditorFeatures/Core/Implementation/Classification/SyntacticClassificationTaggerProvider.TagComputer.cs#L217

Fails to clean up

**Microsoft.CodeAnalysis.Editor.CSharp.UnitTests.Interactive.Commands.InteractiveCommandHandlerTests.TestCopyToInteractiveWithoutSelection** (from Roslyn.VisualStudio.CSharp.UnitTests)

```
MESSAGE:
System.TimeoutException : Failed to clean up listeners in a timely manner.
 ReportEntireFileChanged SyntacticClassificationTaggerProvider.TagComputer.cs 217
---- System.OperationCanceledException : Operación cancelada.
+++++++++++++++++++
STACK TRACE:
 en Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest)
 en Xunit.Sdk.XunitTestInvoker.&lt;&gt;c__DisplayClass6_0.&lt;AfterTestMethodInvokedAsync&gt;b__1()
 en Xunit.Sdk.ExecutionTimer.Aggregate(Action action)
 en Xunit.Sdk.XunitTestInvoker.&lt;&gt;c__DisplayClass6_0.&lt;AfterTestMethodInvokedAsync&gt;b__0()
 en Xunit.Sdk.ExceptionAggregator.Run(Action code)
 ----- Inner Stack Trace -----
 en System.Threading.CancellationToken.ThrowOperationCanceledException()
 en System.Threading.CancellationToken.ThrowIfCancellationRequested()
 en Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcherNoResult(Task task, CancellationToken cancellationToken)
 en Roslyn.Test.Utilities.TaskJoinExtensions.JoinUsingDispatcher(Task task, CancellationToken cancellationToken)
 en Microsoft.CodeAnalysis.Test.Utilities.UseExportProviderAttribute.After(MethodInfo methodUnderTest)
```</Description>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>27/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14707</IssueID>
    <RepoID>1</RepoID>
    <Title>Conditional switch case statements fail to build</Title>
    <Description>**Version Used**: Roslyn.20161021.6  

**Steps to Reproduce**: 
1. Create a conditional switch case statement

Example: 

``` c#
  case Rectangle s when (s.Length == s.Height): 
```

**Expected Behavior**: 
Builds correctly

**Actual Behavior**: 
 No warning/error messages are showing up, but after building I get "csc.exe" exited with code -2146232797. 
</Description>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14717</IssueID>
    <RepoID>1</RepoID>
    <Title>VS crash due NRE in Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern</Title>
    <Description>Version: 
Latest Roslyn RC build (20161024.7).

Repro:
Create a new console app. Replace the code with the following, then copy &amp; paste `is EnvDTE.Project project` to the position indicated by `|`:

``` C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp2
{
    class Program
    {
        static void Main(string[] args)
        {
            switch (args)
            {
                case |
            }
        }
    }
}
```

Stack trace:

```
Message: System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildSwitchLabels(SyntaxList`1 labelsSyntax, Binder sectionBinder, ArrayBuilder`1 labels, DiagnosticBag tempDiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildLabels()
   at Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.get_Labels()
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.get_LabelsByNode()
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(BoundExpression boundSwitchExpression, SwitchSectionSyntax node, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(BoundExpression boundSwitchExpression, SyntaxList`1 sections, Binder originalBinder, BoundPatternSwitchLabel&amp; defaultLabel, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(NameSyntax name, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(SyntaxNode syntax, SemanticModel semanticModel, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ClassifyNode(SyntaxNode syntax)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.Worker.Classify(Workspace workspace, SemanticModel semanticModel, TextSpan textSpan, List`1 list, Func`2 getNodeClassifiers, Func`2 getTokenClassifiers, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
Stack:
   at System.Environment.FailFast(System.String, System.Exception)
   at Microsoft.CodeAnalysis.FailFast.OnFatalException(System.Exception)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception, System.Action`1&lt;System.Exception&gt;)
   at Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Boolean, Microsoft.CodeAnalysis.DiagnosticBag, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, Microsoft.CodeAnalysis.DiagnosticBag, Boolean, Boolean)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildSwitchLabels(Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.ArrayBuilder`1&lt;Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol&gt;, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.BuildLabels()
   at Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.get_Labels()
   at Microsoft.CodeAnalysis.CSharp.SwitchBinder.get_LabelsByNode()
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSection(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindPatternSwitchSections(Microsoft.CodeAnalysis.CSharp.BoundExpression, Microsoft.CodeAnalysis.SyntaxList`1&lt;Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax&gt;, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchLabel ByRef, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.PatternSwitchBinder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindSwitchExpressionAndSections(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel+IncrementalBinder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Microsoft.CodeAnalysis.CSharp.Binder, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.DiagnosticBag)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef, Microsoft.CodeAnalysis.CSharp.BoundNode ByRef)
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, SymbolInfoOptions, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.CSharp.Classification.Classifiers.NameSyntaxClassifier.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode, Microsoft.CodeAnalysis.SemanticModel, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ClassifyNode(Microsoft.CodeAnalysis.SyntaxNode)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.ProcessNodes()
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+Worker.Classify(Microsoft.CodeAnalysis.Workspace, Microsoft.CodeAnalysis.SemanticModel, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Classification.AbstractClassificationService+&lt;AddSemanticClassificationsAsync&gt;d__5, Microsoft.CodeAnalysis.Workspaces, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;AddSemanticClassificationsAsync&gt;d__5 ByRef)
   at Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Func`2&lt;Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier&gt;&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.AbstractEditorClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document, Microsoft.CodeAnalysis.Text.TextSpan, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Classification.ClassifiedSpan&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ClassifySpansAsync&gt;d__2, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ClassifySpansAsync&gt;d__2 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ClassifySpansAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;TryClassifyContainingMemberSpan&gt;d__1, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;TryClassifyContainingMemberSpan&gt;d__1 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.TryClassifyContainingMemberSpan(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities+&lt;ProduceTagsAsync&gt;d__0, Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;ProduceTagsAsync&gt;d__0 ByRef)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationUtilities.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;, Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan, Microsoft.CodeAnalysis.Editor.IEditorClassificationService, Microsoft.CodeAnalysis.Editor.Shared.Utilities.ClassificationTypeMap)
   at Microsoft.CodeAnalysis.Editor.Implementation.Classification.SemanticClassificationViewTaggerProvider.ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;Microsoft.VisualStudio.Text.Tagging.IClassificationTag&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].ProduceTagsAsync(Microsoft.CodeAnalysis.Editor.Tagging.TaggerContext`1&lt;System.__Canon&gt;)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[[Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;RecomputeTagsAsync&gt;d__83[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Microsoft.CodeAnalysis.EditorFeatures, Version=2.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]](&lt;RecomputeTagsAsync&gt;d__83&lt;System.__Canon&gt; ByRef)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].RecomputeTagsAsync(System.Object, System.Nullable`1&lt;Microsoft.VisualStudio.Text.SnapshotPoint&gt;, System.Nullable`1&lt;Microsoft.CodeAnalysis.Text.TextChangeRange&gt;, System.Collections.Generic.List`1&lt;Microsoft.CodeAnalysis.Editor.DocumentSnapshotSpan&gt;, System.Collections.Immutable.ImmutableDictionary`2&lt;Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.CodeAnalysis.Editor.Shared.Tagging.TagSpanIntervalTree`1&lt;System.__Canon&gt;&gt;, System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Tagging.AbstractAsynchronousTaggerProvider`1+TagSource+&lt;&gt;c__DisplayClass74_0[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].&lt;RecomputeTagsForeground&gt;b__0(System.Threading.CancellationToken)
   at Microsoft.CodeAnalysis.Editor.Shared.Threading.AsynchronousSerialWorkQueue+&lt;&gt;c__DisplayClass11_0.&lt;EnqueueBackgroundTask&gt;b__0(System.Threading.Tasks.Task)
   at System.Threading.Tasks.ContinuationResultTaskFromTask`1[[System.__Canon, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]].InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.Tasks.Task.ExecutionContextCallback(System.Object)
   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean)
   at System.Threading.Tasks.Task.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()
   at System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
```
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14727</IssueID>
    <RepoID>1</RepoID>
    <Title>Need additional tests for expression variables defined in a switch case expression</Title>
    <Description>... including the behavior of SemanticModel.

Such tests would have caught https://github.com/dotnet/roslyn/issues/14717 earlier.
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26980</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge dev15.7.x-vs-deps to dev15.8-preview2-vs-deps</Title>
    <Description>
This is an automatically generated pull request from dev15.7.x-vs-deps into dev15.8-preview2-vs-deps.

``` bash
git fetch --all
git checkout merges/dev15.7.x-vs-deps-to-dev15.8-preview2-vs-deps
git reset --hard upstream/dev15.8-preview2-vs-deps
git merge upstream/dev15.7.x-vs-deps
# Fix merge conflicts
git commit
git push merges/dev15.7.x-vs-deps-to-dev15.8-preview2-vs-deps --force
```

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
    <CreatedDate>18/05/2018</CreatedDate>
    <ClosedDate>21/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14696</IssueID>
    <RepoID>1</RepoID>
    <Title>Attributes compiling without a comma separator</Title>
    <Description>Consider the following code:

```
        [One Two]
        class TestClass { }
        class OneAttribute : Attribute { }
        class TwoAttribute : Attribute { }
```

This should not compile because it lacks a comma between the attributes.  Yet it does as of update 3. 
</Description>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14636</IssueID>
    <RepoID>1</RepoID>
    <Title>Breaking change: 'x is nameof' expression</Title>
    <Description>``` c#
class nameof {
  // error CS0119: 'nameof' is a type, which is not valid in the given context
  bool M(object o) =&gt; o is nameof;
}
```

This code is no longer able to compile because parser now prefers parsing constant pattern instead of type syntax.
</Description>
    <CreatedDate>20/10/2016</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10929</IssueID>
    <RepoID>1</RepoID>
    <Title>VisualBasic With statement's expression variable sometimes doesn't get renamed</Title>
    <Description>![vbwithissue](https://cloud.githubusercontent.com/assets/1060731/14870004/87986a18-0cd7-11e6-944a-bc77dcdabf06.png)

**Version Used**: 

VS2015 Update 2

**Steps to Reproduce**:
1. Create a new VB console application targeting .NET Framework 4.6
2. Add a JSON file called project.json and paste the content below to it. You might need to restart VS or close and reopen the solution.
3. Paste the VB code below to Module1.vb
4. Try to rename `vbNode` in the argument list, or place the caret on it

project.json

``` JSON
{
    "dependencies": {
        "Microsoft.CodeAnalysis.VisualBasic": "1.2.1"
    },
    "frameworks": {
        "net46": { }
    },
    "runtimes": {
        "win": { }
    }
}
```

VB code

``` VB
Imports Microsoft.CodeAnalysis
Imports Microsoft.CodeAnalysis.VisualBasic

Namespace N
    Class C
        Sub M(vbNode As VisualBasicSyntaxNode)
            With vbNode
                If .GetCurrentNode(vbNode) Is Nothing Then
                End If
                'Non-extension methods work if you comment above code
                'If .Contains(vbNode) Then
                'End If
            End With
        End Sub
    End Class
End Namespace
```

**Expected Behavior**:

I expect the rename to also rename `vbNode` in `With vbNode` and that it also gets highlighted if the caret is placed on `vbNode` in the argument list.

**Actual Behavior**:

`vbNode` in `With vbNode` is unknown to the IDE and doesn't get renamed or highlighted.

**Notes**:

I can reproduce it if the method is an extension method, but not a normal method, see the code above.
</Description>
    <CreatedDate>27/04/2016</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27371</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable unit tests</Title>
    <Description>
    </Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14565</IssueID>
    <RepoID>1</RepoID>
    <Title>[XAML] Explicitly opt into Roslyn functionality</Title>
    <Description>XAML documents participated in too many incompatible language features. This caused many commands to be handled by Roslyn that should have been handled by Visual Studio. The fix is to opt out of RoslynContentType and explicitly opt into the features supported by XAML.
</Description>
    <CreatedDate>17/10/2016</CreatedDate>
    <ClosedDate>02/11/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14255</IssueID>
    <RepoID>1</RepoID>
    <Title>VB tuples: inference for method type args differs between flat parameters and parameters as tuple</Title>
    <Description>See tests below. If you invoke `Test(Function() 7, Function() 8)` (flat parameters) or `Test((Function() 7, Function() 8))` (tuple of 2 lambdas), the overload resolution between the flat vs tuple versions of `Test` method is different.
The difference stems from `OverloadResolution.EliminateNotApplicableToArguments`. 

For the flat case (no tuple), it updates the second candidate to have a max relaxation level of `DelegateRelaxationLevelWideningToNonLambda`, which causes that candidate to be rejected by `ShadowBasedOnDelegateRelaxation`. This relaxation level is determined by looking at the conversion from lambda to object, which has `ConversionKind.DelegateRelaxationLevelWideningToNonLambda`.

For the tuple case, the conversion is `WideningTuple` which leaves the maximum relaxation level to `None` and so the second candidate isn't rejected.

``` VB

        &lt;Fact&gt;
        Public Sub Inference02()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation name="Tuples"&gt;
    &lt;file name="a.vb"&gt;
Public Class C
    Shared Sub Main()
        Test((Function() 7, Function() 8))
    End Sub

    Shared Sub Test(Of T)(x As (T, T))
        System.Console.WriteLine("first")
    End Sub

    Shared Sub Test(x As (Object, Object))
        System.Console.WriteLine("second")
    End Sub

    Shared Sub Test(Of T)(x As (System.Func(Of T), System.Func(Of T)))
        System.Console.WriteLine("third")
        System.Console.WriteLine(x.Item1().ToString())
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
second
")

        End Sub

        &lt;Fact&gt;
        Public Sub Inference02_WithoutTuple()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation name="Tuples"&gt;
    &lt;file name="a.vb"&gt;
Public Class C
    Shared Sub Main()
        Test(Function() 7, Function() 8)
    End Sub

    Shared Sub Test(Of T)(x As T, y As T)
        System.Console.WriteLine("first")
    End Sub

    Shared Sub Test(x As Object, y As Object)
        System.Console.WriteLine("second")
    End Sub

    Shared Sub Test(Of T)(x As System.Func(Of T), y As System.Func(Of T))
        System.Console.WriteLine("third")
        System.Console.WriteLine(x.ToString())
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
first
")

        End Sub
```

FYI @VSadov @AlekseyTs 
</Description>
    <CreatedDate>03/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14530</IssueID>
    <RepoID>1</RepoID>
    <Title>Invalid lowering of tuple conversion when anonymous delegates are involved</Title>
    <Description>```
        &lt;Fact&gt;
        Public Sub AnonymousDelegate_02()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation&gt;
    &lt;file name="a.vb"&gt;
Public Class C
    Shared Sub Main()
        Dim int = 1
        Dim a = Function(x as Integer) x
        Dim b = (a, int)
        Test2(b)
    End Sub

    Shared Sub Test2(Of T)(x As (System.Func(Of T, T), Integer))
        System.Console.WriteLine("third")
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
")
        End Sub
```

```
ThrowingTraceListener.cs(24,0): at Microsoft.CodeAnalysis.ThrowingTraceListener.Fail(String message, String detailMessage)
at System.Diagnostics.TraceListener.Fail(String message)
at System.Diagnostics.TraceInternal.Fail(String message)
at System.Diagnostics.Debug.Assert(Boolean condition)
Lowering\LocalRewriter\LocalRewriter_Conversion.vb(931,0): at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteAsDirectCast(BoundConversion node)
Lowering\LocalRewriter\LocalRewriter_Conversion.vb(833,0): at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.TransformRewrittenConversion(BoundConversion rewrittenConversion)
Lowering\LocalRewriter\LocalRewriter_Conversion.vb(175,0): at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.MakeTupleConversion(SyntaxNode syntax, BoundExpression rewrittenOperand, TypeSymbol destinationType, Boolean isChecked)
Lowering\LocalRewriter\LocalRewriter_Conversion.vb(123,0): at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.RewriteTupleConversion(BoundConversion node)
Lowering\LocalRewriter\LocalRewriter_Conversion.vb(105,0): at Microsoft.CodeAnalysis.VisualBasic.LocalRewriter.VisitConversion(BoundConversion node)
```

@VSadov, @jcouv FYI 
</Description>
    <CreatedDate>14/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14255</IssueID>
    <RepoID>1</RepoID>
    <Title>VB tuples: inference for method type args differs between flat parameters and parameters as tuple</Title>
    <Description>See tests below. If you invoke `Test(Function() 7, Function() 8)` (flat parameters) or `Test((Function() 7, Function() 8))` (tuple of 2 lambdas), the overload resolution between the flat vs tuple versions of `Test` method is different.
The difference stems from `OverloadResolution.EliminateNotApplicableToArguments`. 

For the flat case (no tuple), it updates the second candidate to have a max relaxation level of `DelegateRelaxationLevelWideningToNonLambda`, which causes that candidate to be rejected by `ShadowBasedOnDelegateRelaxation`. This relaxation level is determined by looking at the conversion from lambda to object, which has `ConversionKind.DelegateRelaxationLevelWideningToNonLambda`.

For the tuple case, the conversion is `WideningTuple` which leaves the maximum relaxation level to `None` and so the second candidate isn't rejected.

``` VB

        &lt;Fact&gt;
        Public Sub Inference02()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation name="Tuples"&gt;
    &lt;file name="a.vb"&gt;
Public Class C
    Shared Sub Main()
        Test((Function() 7, Function() 8))
    End Sub

    Shared Sub Test(Of T)(x As (T, T))
        System.Console.WriteLine("first")
    End Sub

    Shared Sub Test(x As (Object, Object))
        System.Console.WriteLine("second")
    End Sub

    Shared Sub Test(Of T)(x As (System.Func(Of T), System.Func(Of T)))
        System.Console.WriteLine("third")
        System.Console.WriteLine(x.Item1().ToString())
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
second
")

        End Sub

        &lt;Fact&gt;
        Public Sub Inference02_WithoutTuple()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation name="Tuples"&gt;
    &lt;file name="a.vb"&gt;
Public Class C
    Shared Sub Main()
        Test(Function() 7, Function() 8)
    End Sub

    Shared Sub Test(Of T)(x As T, y As T)
        System.Console.WriteLine("first")
    End Sub

    Shared Sub Test(x As Object, y As Object)
        System.Console.WriteLine("second")
    End Sub

    Shared Sub Test(Of T)(x As System.Func(Of T), y As System.Func(Of T))
        System.Console.WriteLine("third")
        System.Console.WriteLine(x.ToString())
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe, additionalRefs:=s_valueTupleRefs)

            CompileAndVerify(comp, expectedOutput:="
first
")

        End Sub
```

FYI @VSadov @AlekseyTs 
</Description>
    <CreatedDate>03/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14473</IssueID>
    <RepoID>1</RepoID>
    <Title>Passing a Tuple literal as an argument causes an unexpected failure in emit.</Title>
    <Description>```
        &lt;Fact&gt;
        Public Sub NarrowingFromNumericConstant_06()

            Dim comp = CreateCompilationWithMscorlibAndVBRuntime(
&lt;compilation&gt;
    &lt;file name="a.vb"&gt;
Option Strict On

Public Class C

    Shared Sub M2 (x as Byte?)
        System.Console.WriteLine("Byte")
    End Sub

    Shared Sub M5 (x as (Byte?, Byte?))
        System.Console.WriteLine("Byte")
    End Sub

    Shared Sub Main()
        Dim a as Byte? = 1
        Dim b as (Byte?, Byte?) = (1, 1)
        M2(1)
        M5((1, 1))
    End Sub
End Class
    &lt;/file&gt;
&lt;/compilation&gt;,
options:=TestOptions.ReleaseExe.WithOverflowChecks(True), additionalRefs:=s_valueTupleRefs)

            AssertTheseDiagnostics(comp, &lt;expected&gt;&lt;/expected&gt;)

            CompileAndVerify(comp, expectedOutput:=
"Byte
Byte")
        End Sub
```

error BC36970: Failed to emit module 'a0b4d275-d8a2-4343-8785-311269516478.exe'.

@VSadov, @jcouv FYI
</Description>
    <CreatedDate>12/10/2016</CreatedDate>
    <ClosedDate>13/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14384</IssueID>
    <RepoID>1</RepoID>
    <Title>Speculatively binding an invocation that contains a "DeclarationExpression" crashes the compiler</Title>
    <Description>As part of a new feature i'm writing, i rewrite an existing invocation to use a DeclarationExpression.  i.e. i transform code for the form:

`Foo(out i)` into `Foo(out int i)`.

To ensure i don't break semantics i speculatively bind the new expression to see if it binds to the same method symbol as before.  Currently, this crashes the compiler here (stack is below):

``` c#
            // Is this a field?
            GlobalExpressionVariable expressionVariableField = LookupDeclaredField(declarationExpression.VariableDesignation());

            if ((object)expressionVariableField == null)
            {
                // We should have the right binder in the chain, cannot continue otherwise.
                throw ExceptionUtilities.Unreachable;
            }
```

The reason seems to be that the we fail the code above this.  Namely: 

``` c#
            // Is this a local?
            SourceLocalSymbol localSymbol = this.LookupLocal(declarationExpression.Identifier());

            if ((object)localSymbol != null)
```

Because this out-variable is not in the locals map, we don't find the local for it and we call into the code that crashes.

Now, i'm not sure what the right thing is here.  It's possible that GetSpeculativeSymbolInfo just can't handle expressions that introduce variables.  If so, that's fine (i'll find another way to verify that semantics don't change).  However, we should not crash when perfectly reasonable inputs as passed in.  So, at the very least we need to harden ourselves to this code.  

That said, i woudl very much like it if this scenario actually worked :)

&lt;details&gt;

```
Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindOutVariableArgument(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax declarationExpression, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 2102  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentValue(Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argumentSyntax, bool allowArglist, Microsoft.CodeAnalysis.RefKind refKind) Line 2090 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentAndName(Microsoft.CodeAnalysis.CSharp.AnalyzedArguments result, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool hadError, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax argumentSyntax, bool allowArglist, bool isDelegateCreation) Line 2060   C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(Microsoft.CodeAnalysis.SeparatedSyntaxList&lt;Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax&gt; arguments, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CSharp.AnalyzedArguments result, bool allowArglist, bool isDelegateCreation) Line 2015 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindArgumentsAndNames(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentListOpt, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, Microsoft.CodeAnalysis.CSharp.AnalyzedArguments result, bool allowArglist, bool isDelegateCreation) Line 1988   C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 153    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 452    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics, bool invoked, bool indexed) Line 396    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 391    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundExpressionHelper(Microsoft.CodeAnalysis.CSharp.Binder binder, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption, Microsoft.CodeAnalysis.DiagnosticBag diagnostics) Line 250  C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundExpression(int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption, out Microsoft.CodeAnalysis.CSharp.Binder binder, out System.Collections.Immutable.ImmutableArray&lt;Microsoft.CodeAnalysis.CSharp.Symbol&gt; crefSymbols) Line 310 C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) Line 680    C#
    Microsoft.CodeAnalysis.CSharp.dll!Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) Line 533   C#
    Microsoft.CodeAnalysis.CSharp.Features.dll!Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider.SemanticsChanged(Microsoft.CodeAnalysis.SemanticModel semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax invocationOrCreation, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax newType, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax declarationExpression) Line 130  C#
```

&lt;/details&gt;
</Description>
    <CreatedDate>08/10/2016</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14296</IssueID>
    <RepoID>1</RepoID>
    <Title>Decision tree produced prematurely</Title>
    <Description>The decision tree for a pattern switch statement is part of the lowered form, and should therefore not be produced until lowering.
</Description>
    <CreatedDate>05/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12175</IssueID>
    <RepoID>1</RepoID>
    <Title>What to do with use-site diagnostics arising in ExpressionOfTypeMatchesPatternType?</Title>
    <Description>The extension method below was introduced in support of pattern-matching, but it discards use-site diagnostics. Is that correct?

``` cs
    internal static class PatternConversionExtensions
    {
        /// &lt;summary&gt;
        /// Does an expression of type &lt;paramref name="expressionType"/&gt; "match" a pattern that looks for
        /// type &lt;paramref name="patternType"/&gt;?
        /// 'true' if the matched type catches all of them, 'false' if it catches none of them, and
        /// 'null' if it might catch some of them. For this test we assume the expression's value
        /// isn't null.
        /// &lt;/summary&gt;
        public static bool? ExpressionOfTypeMatchesPatternType(this Conversions conversions, TypeSymbol expressionType, TypeSymbol patternType)
        {
            if (expressionType == patternType) return true;
            HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics = null;
            var conversion = conversions.ClassifyConversion(expressionType, patternType, ref useSiteDiagnostics, builtinOnly: true);
            // This is for classification purposes only; we discard use-site diagnostics. Use-site diagnostics will
            // be given if a conversion is actually used.
```
</Description>
    <CreatedDate>23/06/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14174</IssueID>
    <RepoID>1</RepoID>
    <Title>ref returns and locals have problems with binding  "ref dynamic"</Title>
    <Description>I suspect it could be result of the recent refactoring of ref returns/locals syntax.
Note that   ref dynamic parameters are ok.

``` cs

   class Program
    {
        static object[] arr = new object[] { "a" };

        static void Main(string[] args)
        {
            RefParam(ref arr[0]);
            System.Console.WriteLine(x.ToString());


            // error
            ref dynamic x = ref arr[0];
            x = "b";

            System.Console.WriteLine(x.ToString());

            RefReturn() = "e";
            System.Console.WriteLine(x.ToString());

        }

        // works fine
        static void RefParam(ref dynamic p)
        {
            p = "c";
        }

        // error
        static ref dynamic RefReturn()
        {
            return ref arr[0];
        }
    }
```

error CS0246: The type or namespace name 'dynamic' could not be found (are you missing a using directive or an assembly reference?)

NOTE: I tried to make a repro similar to https://github.com/dotnet/roslyn/issues/14166 , but with dynamic, not with tuples.
I think we might have same issue with dynamic and my fix for #14166 would fix it, but that is theoretical, since I can't make "ref dynamic" to work at all in these contexts.
</Description>
    <CreatedDate>29/09/2016</CreatedDate>
    <ClosedDate>05/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14172</IssueID>
    <RepoID>1</RepoID>
    <Title>Tests failing on signed builds after merging #13955</Title>
    <Description>https://devdiv.visualstudio.com/DevDiv/_build/index?buildId=351941&amp;_a=summary&amp;tab=ms.vss-test-web.test-result-details

An example test is at Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests.CommandLineTests.Version:

```
Assert.Equal() Failure
 ↓ (pos 6)
Expected: 2.0.0.60929
Actual: 2.0.0.0
 ↑ (pos 6)
```
</Description>
    <CreatedDate>29/09/2016</CreatedDate>
    <ClosedDate>29/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13971</IssueID>
    <RepoID>1</RepoID>
    <Title>Sequence points set to break statements in pattern switch</Title>
    <Description>Stepping through a pattern switch will step through the `break;` statements of preceding `case ... when ...:` statements rather than the `when ...` clauses.
</Description>
    <CreatedDate>22/09/2016</CreatedDate>
    <ClosedDate>05/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12378</IssueID>
    <RepoID>1</RepoID>
    <Title>Support breakpoints in the when clause of a switch case.</Title>
    <Description>
    </Description>
    <CreatedDate>07/07/2016</CreatedDate>
    <ClosedDate>11/10/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13926</IssueID>
    <RepoID>1</RepoID>
    <Title>An Assert in DiagnosticBagExtensions.Add in broken solution</Title>
    <Description>The following shows a failure in the VB compiler (preview 5, opening Roslyn.sln in Release mode) in full solution analysis mode

![image](https://cloud.githubusercontent.com/assets/3804346/18654409/c58b6af2-7e95-11e6-8905-435cfc401f0b.png)

![image](https://cloud.githubusercontent.com/assets/3804346/18654413/cc16bbba-7e95-11e6-9843-1ad856219f58.png)

this is after failing to load some generated parts of the solution.
</Description>
    <CreatedDate>20/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13925</IssueID>
    <RepoID>1</RepoID>
    <Title>An Assert in VB.Symbols.EmbeddedSymbolManager.MarkSymbolAsReferenced</Title>
    <Description>see https://github.com/dotnet/roslyn/issues/13884#issuecomment-248174097

This is the preview 5 Roslyn solution running, opened the preview 5 Roslyn solution with full solution analysis enabled and switched to Release mode.
</Description>
    <CreatedDate>20/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13884</IssueID>
    <RepoID>1</RepoID>
    <Title>Crash in DecisionTreeComputer</Title>
    <Description>**Version Used**: 

**Steps to Reproduce**:
1. Open Roslyn.sln with Full Solution Analysis enabled and wait. 
   **Result** 
   Crash below.  Dump with heap available internally.

**Exception**

&gt; System.ArgumentNullException: Value cannot be null.
&gt; Parameter name: key
&gt;    at System.Collections.Generic.Dictionary`2.FindEntry(TKey key)
&gt;    at System.Collections.Generic.Dictionary`2.TryGetValue(TKey key, TValue&amp; value)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.AddByValue(ByValue byValue, BoundExpression value, DecisionMaker makeDecision, Boolean hasErrors)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.AddByValue(DecisionTree decision, BoundExpression value, DecisionMaker makeDecision, Boolean hasErrors)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.AddByValue(ByType byType, BoundExpression value, DecisionMaker makeDecision, Boolean hasErrors)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.AddByValue(DecisionTree decision, BoundExpression value, DecisionMaker makeDecision, Boolean hasErrors)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.AddToDecisionTree(DecisionTree decisionTree, BoundPatternSwitchLabel label)
&gt;    at Microsoft.CodeAnalysis.CSharp.DecisionTreeComputer.ComputeDecisionTree()
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.ComputeDecisionTree(DiagnosticBag diagnostics)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.EnsureDecisionTree()
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.get_DecisionTreeDiagnostics()
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitPatternSwitchStatement(BoundPatternSwitchStatement node)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundPatternSwitchStatement.Accept(BoundTreeVisitor visitor)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBlock(BoundBlock node)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWhileStatement(BoundWhileStatement node)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundWhileStatement.Accept(BoundTreeVisitor visitor)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.VisitStatement(BoundStatement statement)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitBlock(BoundBlock node)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundBlock.Accept(BoundTreeVisitor visitor)
&gt;    at Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitWithStackGuard(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAlways(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Visit(BoundNode node)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(Boolean&amp; badRegion)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Scan(Boolean&amp; badRegion)
&gt;    at Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Analyze(Boolean&amp; badRegion)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(Boolean&amp; badRegion, DiagnosticBag diagnostics)
&gt;    at Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(CSharpCompilation compilation, Symbol member, BoundBlock block, DiagnosticBag diagnostics)
&gt;    at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Analyze(CSharpCompilation compilation, MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics)
&gt;    at Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, Boolean hasTrailingExpression, Boolean originalBodyNested)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg)
&gt;    at Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
&gt;    at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
&gt;    at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg)
&gt;    at Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept[TArgument,TResult](CSharpSymbolVisitor`2 visitor, TArgument argument)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamespace(NamespaceSymbol symbol)
&gt;    at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
&gt;    at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;ComputeAnalyzerDiagnosticsWithoutStateTrackingAsync&gt;d__48.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GetAnalysisResultWithoutStateTrackingAsync&gt;d__46.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers.&lt;GetAnalysisResultAsync&gt;d__39.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.CodeAnalysis.Diagnostics.EngineV2.InProcCodeAnalysisDiagnosticAnalyzerExecutor.AnalyzerExecutor.&lt;AnalyzeAsync&gt;d__0.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.VisualStudio.LanguageServices.Implementation.Diagnostics.VisualStudioDiagnosticAnalyzerExecutor.&lt;AnalyzeAsync&gt;d__0.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.Executor.&lt;AnalyzeAsync&gt;d__19.MoveNext()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.Executor.&lt;ComputeDiagnosticsAsync&gt;d__6.MoveNext()
</Description>
    <CreatedDate>18/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13901</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failures in GlobalCode_InferenceFailure-*</Title>
    <Description>Three unit tests are failing in master right now

http://dotnet-ci.cloudapp.net/job/dotnet_roslyn/job/master/job/windows_release_unit32/645/testReport/
</Description>
    <CreatedDate>19/09/2016</CreatedDate>
    <ClosedDate>19/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13900</IssueID>
    <RepoID>1</RepoID>
    <Title>Result of type inference for fields declared in Script is not deterministic</Title>
    <Description>Order in which consumer calls certain SemanticModel APIs has effect on which fields fail and which fields succeed type inference. It also affects what diagnostics is getting reported by the compilation. See GlobalCode_InferenceFailure_04 and GlobalCode_InferenceFailure_04 in OutVarTests.cs for examples (note, the issue isn't specific to Out Variables).
</Description>
    <CreatedDate>19/09/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12467</IssueID>
    <RepoID>1</RepoID>
    <Title>Squiggles are on the wrong span for out parameter unassigned error</Title>
    <Description>We select the wrong span for this error: "out parameter must be assigned to before leaves the current method"...

This causes:
![image](https://cloud.githubusercontent.com/assets/1402694/16786289/8ae4a8b0-4848-11e6-9db3-974b3aa89fcb.png)

which makes it really hard to finish writing my method when I have to look through all the squiggles.
</Description>
    <CreatedDate>12/07/2016</CreatedDate>
    <ClosedDate>19/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11986</IssueID>
    <RepoID>1</RepoID>
    <Title>Tuple implementation rejects implicit operators</Title>
    <Description>Related to #11530, the following code is improperly rejected by the tuple implementation in `master`.

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;
        public ValueTuple(T1 item1, T2 item2)
        {
            this.Item1 = item1;
            this.Item2 = item2;
        }

        // error: conversion must convert to or from enclosing type
        public static explicit operator int((T1, T2)? source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator long(Nullable&lt;(T1, T2)&gt; source)
        {
            return 1;
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator string(Nullable&lt;ValueTuple&lt;T1, T2&gt;&gt; source)
        {
            return "";
        }
        // error: conversion must convert to or from enclosing type
        public static explicit operator double(ValueTuple&lt;T1, T2&gt;? source)
        {
            return 1;
        }
    }
}
```
</Description>
    <CreatedDate>14/06/2016</CreatedDate>
    <ClosedDate>20/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11530</IssueID>
    <RepoID>1</RepoID>
    <Title>Tuple implementation rejects implicit operators</Title>
    <Description>The following code is improperly rejected by the tuple implementation

``` cs
namespace System
{
    public struct ValueTuple&lt;T1, T2&gt;
    {
        public T1 Item1;
        public T2 Item2;

        // error: conversion must convert to or from enclosing type
        public static implicit operator Collections.Generic.KeyValuePair&lt;T1, T2&gt;(ValueTuple&lt;T1, T2&gt; tuple)
        {
            T1 k;
            T2 v;
            (k, v) = tuple;
            return new KeyValuePair&lt;T1, T2&gt;(k, v);
        }

        // error: conversion must convert to or from enclosing type
        public static implicit operator ValueTuple&lt;T1, T2&gt;(Collections.Generic.KeyValuePair&lt;T1, T2&gt; kvp)
        {
            return (kvp.Key, kvp.Value);
        }
    }
}
```

This was tested against https://github.com/jcouv/roslyn/tree/tuple-deconstruction (from https://github.com/dotnet/roslyn/pull/11457) at commit https://github.com/jcouv/roslyn/commit/c7b60a478ce0f5993d1e7a85af17545b96611a9e
</Description>
    <CreatedDate>24/05/2016</CreatedDate>
    <ClosedDate>20/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10492</IssueID>
    <RepoID>1</RepoID>
    <Title>Precedence errors in parsing the relational "is" expression</Title>
    <Description>The following short program illustrates two errors in the Roslyn expression parser. These issues interfere with the extension of the parser to support pattern-matching.

``` cs
using System;

class Program
{
    const bool B = true;

    public static void Main(string[] args)
    {
        object a = null;
        B c = null;
        Console.WriteLine(a is B &amp; c); // prints 5 (correct)
        Console.WriteLine(a is B &gt; c); // prints 6 (correct)
        Console.WriteLine(a is B &lt; c); // syntax error but should print 7
        Console.WriteLine(a is B + c); // should be syntax error but prints 8
    }
}

class B
{
    public static int operator &amp;(bool left, B right) =&gt; 5;
    public static int operator &gt;(bool left, B right) =&gt; 6;
    public static int operator &lt;(bool left, B right) =&gt; 7;
    public static int operator +(bool left, B right) =&gt; 8;
}
```

The last of these cases is most problematic for pattern-matching. While `a is B + c` should have been a syntax error in C# 6, in C# 7 it should mean `a is (B + c)`, which works if `B + c` is a constant value. However, we parse it incorrectly as `(a is B) + b`, which is an inversion of the precedence required by the language specification.
</Description>
    <CreatedDate>12/04/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13813</IssueID>
    <RepoID>1</RepoID>
    <Title>New syntactic disambiguation rule for pattern-matching</Title>
    <Description>Related to #10492, there is now a new syntactic ambiguity due to patterns. The case is this

``` cs
M(e is A &lt; B, C &gt; x)
```

Where we are either passing two arguments to `M`, or declaring a pattern variable `x`.

The existing (C# 6) rules say it is two arguments because the token after the `&gt;` isn’t one of the ones on the list in the section entitled _Grammar Ambiguities_ in the _Lexical Structure_ chapter. That seems wrong in the presence of pattern-matching, because there is no other way to write the type so as to disambiguate and give it the meaning of matching the type `A&lt;B,C&gt;`.

Fortunately, previous compilers were unable to parse this according to the specification, and simply gave a syntax error (unable to handle an _is-expression_ on the left of a `&lt;`). That suggests we may have some room to change the rules.

However, if we simply add _identifier_ to the list, we’d get this case wrong

``` cs
M(A &lt; B, C &gt; D)
```

Maybe we only add _identifier_ to the list only when the type is being parsed for a pattern? That is the solution I have currently implemented, and it seems to do the right thing.

This will have to go in the language spec.
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>27/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13797</IssueID>
    <RepoID>1</RepoID>
    <Title>Regression in overload resolution of a parameterless anonymous delegate</Title>
    <Description>Here's a test that demonstrates the problem:

``` csharp
        [Fact]
        public void DelegateAsAction()
        {
            var comp = CreateCompilationWithMscorlib(@"
using System;

public static class C
{
    public static void M() =&gt; Dispatch(delegate { });

    public static T Dispatch&lt;T&gt;(Func&lt;T&gt; func) =&gt; default(T);

    public static void Dispatch(Action func) { }
}");
            CompileAndVerify(comp);
     }
```

This results in an assert in Debug and an ErrorType in the delegate's return type for Release.
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12572</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect "Cast is redundant" when switch on an `object`</Title>
    <Description>**Version Used**: 

Master branch, commit d9b6e87a1b08f2f12f5fbd5eb0b071d82b672beb (latest when submitted this issue)

**Steps to Reproduce**:

``` C#
public static void TestSwitchInt(object i)
{
    switch ((int)i)
    {
        case 0:
            Console.WriteLine("0");
            break;
        case 1:
            Console.WriteLine("1");
            break;
        case 2:
            Console.WriteLine("2");
            break;
    }
}
```

**Expected Behavior**:

No "Cast is redundant" suggestion.

**Actual Behavior**:

"Cast is redundant" on `(int)i`.

Removing it will cause the compiler to generate more complicated code (to check the type of `i`).
</Description>
    <CreatedDate>17/07/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10306</IssueID>
    <RepoID>1</RepoID>
    <Title>[Bug] Redundant "Remove Unnecessary Cast" with pattern-matching</Title>
    <Description>**Version Used**: 
Microsoft Visual Studio Enterprise 15 Preview
Version 15.0.25123.0 PREVIEW
Microsoft .NET Framework
Version 4.6.01038

**Steps to Reproduce**:
Write a code:

``` cs
static class Program
{
  static void Main(string[] args) {
    switch((object)args) {
        // ^~~~~~~^ cast marked as IDE0004  C# Cast is redundant.
    case int[] i:
      break;
    }
  }
}
```
1. Compile code: succeeded
2. Remove cast and compile code: error CS0030: Cannot convert type 'string[]' to 'int[]'

**Expected Behavior**:
Do not suggest to remove a type cast.
</Description>
    <CreatedDate>03/04/2016</CreatedDate>
    <ClosedDate>14/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13520</IssueID>
    <RepoID>1</RepoID>
    <Title>Fail to detect pattern subsumption when there is an intervening case of a supertype</Title>
    <Description>The following test fails. It succeeds when the `case object o...` line is commented out.

``` cs
        [Fact]
        public void Bug13520()
        {
            var source =
@"class Program
{
    public static void Main(string[] args)
    {
        object value = false;
        switch (value)
        {
            case true: break;
            case object o when args.Length == -1: break;
            case false: break;
            case bool b: throw null; // error: bool already handled by previous cases.
        }
    }
    public static bool IsB(char value)
    {
        return value == 'b';
    }
}
";
            var compilation = CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe);
            compilation.VerifyDiagnostics(
                // (11,18): error CS8120: The switch case has already been handled by a previous case.
                //             case bool b: ; // error: bool already handled by previous cases.
                Diagnostic(ErrorCode.ERR_PatternIsSubsumed, "bool b").WithLocation(11, 18)
                );
        }
```
</Description>
    <CreatedDate>01/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13723</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crashes when using a constant pattern against an expression that doesn't have a type</Title>
    <Description>```
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if (null is 1)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

Observed:

```
Test 'M:Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType' failed: Object reference not set to an instance of an object.
    System.NullReferenceException: Object reference not set to an instance of an object.
    Binder\Semantics\Conversions\ConversionsBase.cs(1065,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.HasImplicitEnumerationConversion(BoundExpression source, TypeSymbol destination)
    Binder\Semantics\Conversions\ConversionsBase.cs(786,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitBuiltInConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Semantics\Conversions\ConversionsBase.cs(57,0): at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromExpression(BoundExpression sourceExpression, TypeSymbol destination, HashSet`1&amp; useSiteDiagnostics)
    Binder\Binder_Statements.cs(2369,0): at Microsoft.CodeAnalysis.CSharp.Binder.GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, Boolean isDefaultParameter, RefKind refKind)
    Binder\Binder_Patterns.cs(140,0): at Microsoft.CodeAnalysis.CSharp.Binder.ConvertPatternExpression(TypeSymbol inputType, CSharpSyntaxNode node, BoundExpression expression, ConstantValue&amp; constantValue, DiagnosticBag diagnostics)
    Binder\Binder_Patterns.cs(124,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindConstantPattern(CSharpSyntaxNode node, BoundExpression operand, TypeSymbol operandType, ExpressionSyntax patternExpression, Boolean hasErrors, DiagnosticBag diagnostics, Boolean&amp; wasExpression, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(38,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics, Boolean wasSwitchCase)
    Binder\Binder_Patterns.cs(17,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Expressions.cs(623,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Expressions.cs(396,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed)
    Binder\Binder_Statements.cs(2848,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2804,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindIfStatement(IfStatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(50,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics)
    Binder\Binder_Statements.cs(2315,0): at Microsoft.CodeAnalysis.CSharp.Binder.BindBlockParts(BlockSyntax node, DiagnosticBag diagnostics)
    Compiler\MethodCompiler.cs(1550,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain&amp; importChain, Boolean&amp; originalBodyNested)
    Compiler\MethodCompiler.cs(878,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethod(MethodSymbol methodSymbol, Int32 methodOrdinal, ProcessedFieldInitializers&amp; processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState)
    Compiler\MethodCompiler.cs(433,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileNamedType(NamedTypeSymbol containingType)
    Compiler\MethodCompiler.cs(323,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.&lt;&gt;c__DisplayClass20_0.&lt;CompileNamedTypeAsTask&gt;b__0()
    InternalUtilities\UICultureUtilities.cs(136,0): at Roslyn.Utilities.UICultureUtilities.&lt;&gt;c__DisplayClass5_0.&lt;WithCurrentUICulture&gt;b__0()
    at System.Threading.Tasks.Task.InnerInvoke()
    at System.Threading.Tasks.Task.Execute()
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    Compiler\MethodCompiler.cs(238,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.WaitForWorkers()
    Compiler\MethodCompiler.cs(137,0): at Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, Boolean generateDebugInfo, Boolean hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1 filterOpt, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(2004,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1971,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CompilationStage stage, Boolean includeEarlierStages, CancellationToken cancellationToken)
    Compilation\CSharpCompilation.cs(1910,0): at Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(CancellationToken cancellationToken)
    DiagnosticExtensions.cs(98,0): at Microsoft.CodeAnalysis.DiagnosticExtensions.VerifyDiagnostics[TCompilation](TCompilation c, DiagnosticDescription[] expected)
    Semantics\PatternMatchingTests.cs(14567,0): at Microsoft.CodeAnalysis.CSharp.UnitTests.PatternMatchingTests.ExpressionWithoutAType()
```
</Description>
    <CreatedDate>10/09/2016</CreatedDate>
    <ClosedDate>13/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13746</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crashes with typeless tuple on the left of an is-type operator</Title>
    <Description>``` cs
        [Fact]
        public void ExpressionWithoutAType()
        {
            var source =
@"
public class Vec
{
    public static void Main()
    {
        if ((1, null) is Vec)
        {}
    }
}
";

            CreateCompilationWithMscorlib45(source, options: TestOptions.DebugExe).VerifyDiagnostics(
                );
        }
```

this crashes the C# compiler.
</Description>
    <CreatedDate>12/09/2016</CreatedDate>
    <ClosedDate>13/09/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12573</IssueID>
    <RepoID>1</RepoID>
    <Title>Cannot mix Enum and Int with same value in one switch</Title>
    <Description>**Version Used**: 

Master branch, commit d9b6e87a1b08f2f12f5fbd5eb0b071d82b672beb (latest when submitted this issue)

**Steps to Reproduce**:

``` C#
public enum EnumA
{
    ValueA,
    ValueB,
    ValueC
}

public static void TestSwitchEnumAndInt(object value)
{
    switch (value)
    {
        case EnumA.ValueA:
            Console.WriteLine("A");
            break;
        case 0:
            Console.WriteLine("0");
            break;
        default:
            Console.WriteLine("Default");
            break;
    }
}
```

**Expected Behavior**:

No error.

**Actual Behavior**:

`CS0152 The switch statement contains multiple cases with the label value '0'`

Since the pattern matching will check value's type first, `EnumA.ValueA` is not same as `0`.
</Description>
    <CreatedDate>17/07/2016</CreatedDate>
    <ClosedDate>10/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12883</IssueID>
    <RepoID>1</RepoID>
    <Title>Infinite recursion in inference for deconstruction</Title>
    <Description>The following test causes the compiler to infinitely recurse.

``` cs
        [Fact]
        public void DeclarationWithCircularity2()
        {
            string source = @"
class C
{
    static void Main()
    {
        var (x1, x2) = (x2, x1);
    }
}
";
            var comp = CreateCompilationWithMscorlib(source, references: new[] { ValueTupleRef, SystemRuntimeFacadeRef });
            comp.VerifyDiagnostics(
// should be some kind of error, like "cannot reference var-declared variable in its own initializer"
                );
        }
```
</Description>
    <CreatedDate>02/08/2016</CreatedDate>
    <ClosedDate>09/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12900</IssueID>
    <RepoID>1</RepoID>
    <Title>Make sure that the new language features work in Expression lambdas or give errors.</Title>
    <Description>Most of the new language features do not align well with the set of expression tree nodes available in ET v1.0 that we are targeting.

In fact they would benefit from being represented by higher level reducible nodes as a more expressive form - I.E. instead of a bunch of lowered nested field accesses we could have tuple field accesses directly encoded in the tree as TupleFieldAccess expressions or something like that. 
The nodes would still be compilable by the ET compiler as long as they know how to reduce themselves to the ET2.0 representation, which would be regular nested field accesses.

In the short term we must ensure that new features in the context of expression trees have desirable behavior. (most likely an error for now)
</Description>
    <CreatedDate>03/08/2016</CreatedDate>
    <ClosedDate>11/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12703</IssueID>
    <RepoID>1</RepoID>
    <Title>Error in syntax node for WhenClauseSyntax</Title>
    <Description>For WhenClauseSyntax, in `Syntax.xml` we have

``` none
  &lt;Node Name="WhenClauseSyntax" Base="CSharpSyntaxNode"&gt;
    &lt;Kind Name="WhenClause" /&gt;
    &lt;Field Name="WhenKeyword" Type="SyntaxToken" Optional="true"&gt;
      &lt;Kind Name="WhenKeyword"/&gt;
    &lt;/Field&gt;
    &lt;Field Name="Condition" Type="ExpressionSyntax" Optional="true" /&gt;
  &lt;/Node&gt;
```

But neither of these fields is optional, or ever omitted in nodes that are syntactically correct.
</Description>
    <CreatedDate>24/07/2016</CreatedDate>
    <ClosedDate>28/07/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12219</IssueID>
    <RepoID>1</RepoID>
    <Title>Debugger locals show wrong value for parameter changed and captured by closure in VB</Title>
    <Description>As detailed in #11949, we need to update https://github.com/dotnet/roslyn/blob/master/src/ExpressionEvaluator/VisualBasic/Source/ExpressionCompiler/CompilationContext.vb#L1286 to reference the closure field instead of the original parameter location.
</Description>
    <CreatedDate>27/06/2016</CreatedDate>
    <ClosedDate>22/07/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12061</IssueID>
    <RepoID>1</RepoID>
    <Title>Stack overflow with delegate type that returns itself</Title>
    <Description>**Reproduction steps**:

Compile the following code on the command line (or paste it into VS, which hangs VS).

``` csharp
delegate Del1 Del1();
delegate Del2 Del2();

class Program
{
    static void Method(Del1 del1) { }
    static void Method(Del2 del2) { }
    static void Main()
    {
        Method(() =&gt; null);
    }
}
```

**Version Used**:
1. master (ish): stack overflow
2. 1.2.0.60325 (roslyn): stack overflow
3. 4.6.1038.0 (native): test.cs(10,9): error CS0121: The call is ambiguous between the following methods or properties: 'Program.Method(Del1)' and 'Program.Method(Del2)'

I think this is due to a recursive loop in `OverloadResolution.BetterConversionTarget` - we get into the case where both types are delegates, get their return types, and then recurse with `BetterConversionTarget(r1, r2, ref useSiteDiagnostics)` (r1/r2 are the return types of the delegates). They're the same type as the original delegates, so, _boom_.
</Description>
    <CreatedDate>16/06/2016</CreatedDate>
    <ClosedDate>23/02/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12113</IssueID>
    <RepoID>1</RepoID>
    <Title>Calculating diagnostics for a single file realizes all symbols in GetEntryPoint</Title>
    <Description>Calculating the diagnostics even for a single file in a project producing an exe still realizes all of the symbols for the compilation.

In [`MethodCompiler.CompileMethodBodies`](http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Compiler/MethodCompiler.cs,179), we call `GetEntryPoint` regardless of the value of `filterOpt`.  This is causing performance and memory use for at least one customer who has ~4,000 source files in their main exe.

We should investigate to see if we can skip calling `GetEntryPoint` in the case where we are filtering to a single file.  If we can't, maybe we can use the declaration table to only realize methods called `Main` instead of all symbols in the compilation?
</Description>
    <CreatedDate>20/06/2016</CreatedDate>
    <ClosedDate>21/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12120</IssueID>
    <RepoID>1</RepoID>
    <Title>Only compute entry points when compiling everything.</Title>
    <Description>Fixes #12113 

@dotnet/roslyn-compiler Please review. I suspect we will want to port this to an update.
</Description>
    <CreatedDate>21/06/2016</CreatedDate>
    <ClosedDate>21/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11980</IssueID>
    <RepoID>1</RepoID>
    <Title>Failing VB completion unit test SelectKeywordFirst</Title>
    <Description>The following unit test fails on a fresh clone of master:

``` vb
        &lt;WorkItem(546208, "http://vstfdevdiv:8080/DevDiv2/DevDiv/_workitems/edit/546208")&gt;
        &lt;WpfFact, Trait(Traits.Feature, Traits.Features.Completion)&gt;
        Public Async Function SelectKeywordFirst() As Task
            Using state = TestState.CreateVisualBasicTestState(
                              &lt;Document&gt;
Class C
    Sub M()
        $$
    End Sub

    Sub GetType()
    End Sub
End Class
                              &lt;/Document&gt;)

                state.SendTypeChars("GetType")
                Await state.WaitForAsynchronousOperationsAsync()
                Await state.AssertSelectedCompletionItem("GetType", VBFeaturesResources.GettypeFunction + vbCrLf +
                    ReturnsSystemTypeObject + vbCrLf +
                    $"GetType({Typename}) As Type")
            End Using
        End Function
```

The failure mode is

``` none
------ Test started: Assembly: Roslyn.Services.Editor.UnitTests2.dll ------
Unknown .NET Framework Version: v4.6
Test 'Microsoft.CodeAnalysis.Editor.UnitTests.IntelliSense.VisualBasicCompletionCommandHandlerTests.SelectKeywordFirst' failed:
    Assert.Equal() Failure
          ↓ (pos 0)
Expected: GetType function\r\nReturns a System.Type o···
Actual:   Sub C.GetType()
          ↑ (pos 0)
    IntelliSense\TestState.vb(270,0): at Microsoft.CodeAnalysis.Editor.UnitTests.IntelliSense.TestState.VB$StateMachine_36_AssertSelectedCompletionItem.MoveNext()
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
    IntelliSense\VisualBasicCompletionCommandHandlerTests.vb(1843,0): at Microsoft.CodeAnalysis.Editor.UnitTests.IntelliSense.VisualBasicCompletionCommandHandlerTests.VB$StateMachine_88_SelectKeywordFirst.MoveNext()
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
    --- End of stack trace from previous location where exception was thrown ---
    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)

0 passed, 1 failed, 0 skipped, took 8.87 seconds (xUnit.net 2.1.0 build 3179).
```
</Description>
    <CreatedDate>13/06/2016</CreatedDate>
    <ClosedDate>22/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11053</IssueID>
    <RepoID>1</RepoID>
    <Title>IntelliSense does not understand lambda parameter type, when overloaded with defaultValue</Title>
    <Description>**Version Used**: VS2015.2

**Steps to Reproduce**:

``` csharp
using System;
using System.Collections.Generic;

public static class Program
{
    public static void Main()
    {
        var parameter = new List&lt;string&gt;();
        var result = parameter.FirstOrDefault(x =&gt; x$);
    }
}

public static class Enumerable
{
    public static TSource FirstOrDefault&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, TSource defaultValue)
    {
        return default(TSource);
    }

    public static TSource FirstOrDefault&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate, TSource defaultValue)
    {
        return default(TSource);
    }
}
```
1. Set cursor to $
2. Type `.` and get no IntelliSense

**Expected Behavior**:
IntelliSense picks the correct overload and suggests that the type of `x` is `string`, providing member completion.

**Actual Behavior**:
![IntelliSense showing `(Parameter) ? x`](https://cloud.githubusercontent.com/assets/7110884/15010871/d3f8dda4-11ee-11e6-92f0-219d7a151d02.png)
If you change the `FirstOrDefault&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate, TSource defaultValue)` overload to `FirstOrDefault&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)`, then it works as expected
</Description>
    <CreatedDate>04/05/2016</CreatedDate>
    <ClosedDate>03/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11358</IssueID>
    <RepoID>1</RepoID>
    <Title>No completion offered in partial statement with lambda</Title>
    <Description>**Version Used**: 
Dev14 Update 3

**Steps to Reproduce**:
1. Type the following program
2. Go to the commented line, backspace over the `.`
3. Type `.`

``` cs
using System.Collections.Generic;
using System.Linq;

class Program
{
    static void Main(string[] args)
    {
        new Program().M();
    }

    Thing thing;

    void M()
    {
        if (thing.Collection.FirstOrDefault(d =&gt; d. // no completion offered when typing . here
        var something = thing.Collection;
    }
}

class Thing
{
    public IEnumerable&lt;int&gt; Collection;
}
```

**Expected Behavior**:
Completions offered (members of `int`)

**Actual Behavior**:
No completions offered
</Description>
    <CreatedDate>17/05/2016</CreatedDate>
    <ClosedDate>03/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10525</IssueID>
    <RepoID>1</RepoID>
    <Title>Code Model: Implement internal IParameterKind interface on CodeParameter</Title>
    <Description>There is an internal interface that we failed to implement on CodeParameter that looks like so:

``` C#
internal enum PARAMETER_PASSING_MODE
{
    cmParameterTypeIn = 1,
    cmParameterTypeOut = 2,
    cmParameterTypeInOut = 3
}

[ComImport()]
[Guid("A55CCBCC-7031-432d-B30A-A68DE7BDAD75")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
[ComVisible(true)]
internal interface IParameterKind
{
    void SetParameterPassingMode(PARAMETER_PASSING_MODE ParamPassingMode);
    void SetParameterArrayDimensions(int ulDimensions);
    int GetParameterArrayCount();
    int GetParameterArrayDimensions(int uIndex);
    PARAMETER_PASSING_MODE GetParameterPassingMode();
}
```

It turns out that this interface is used by the Windows Workflow v1 designer and breaks some particular scenarios.
</Description>
    <CreatedDate>13/04/2016</CreatedDate>
    <ClosedDate>20/04/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10529</IssueID>
    <RepoID>1</RepoID>
    <Title>Compiler crash when operand of pattern match is error</Title>
    <Description>**Version Used**:  Future branch, commit a5a17a2fb3d46c84ef05cb92ebd3a04c1d025612

**Reproduce**:

a.

```
if (obj.Property is var o) { } // `obj` doesn't exist.
```

b.

```
var obj = new object();
if (obj| is var o) { } // Now type `.`(dot) at `|`.
```

AND

The IntelliSense thinks the type of `o` is `var` in snippet b, maybe relates to #10174.

**Exception**:

```
System.NullReferenceException: Object reference not set to an instance of an object.

   at Microsoft.CodeAnalysis.CSharp.Binder.IsOperatorErrors(CSharpSyntaxNode node, TypeSymbol operandType, BoundTypeExpression typeExpression, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Operators.cs:line 2566
   at Microsoft.CodeAnalysis.CSharp.Binder.BindDeclarationPattern(DeclarationPatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 358
   at Microsoft.CodeAnalysis.CSharp.Binder.BindPattern(PatternSyntax node, BoundExpression operand, TypeSymbol operandType, Boolean hasErrors, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 28
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIsPatternExpression(IsPatternExpressionSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Patterns.cs:line 17
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 606
   at Microsoft.CodeAnalysis.CSharp.Binder.BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, Boolean invoked, Boolean indexed) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Expressions.cs:line 380
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 2832
   at Microsoft.CodeAnalysis.CSharp.Binder.BindIfStatement(IfStatementSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 2782
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatementCore(StatementSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 61
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1704
   at Microsoft.CodeAnalysis.CSharp.Binder.BindBlock(BlockSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 2350
   at Microsoft.CodeAnalysis.CSharp.Binder.BindStatementCore(StatementSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Statements.cs:line 48
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.BindStatement(StatementSyntax node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1704
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 2036
   at Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MethodBodySemanticModel.cs:line 36
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1461
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(CSharpSyntaxNode node) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 410
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode&amp; bindableNode, BoundNode&amp; lowestBoundNode, BoundNode&amp; highestBoundNode, BoundNode&amp; boundParent) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 1019
   at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetOperationWorker(CSharpSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\MemberSemanticModel.cs:line 854
   at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetOperationWorker(CSharpSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\SyntaxTreeSemanticModel.cs:line 165
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetOperationCore(SyntaxNode node, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\CSharp\Portable\Compilation\CSharpSemanticModel.cs:line 471
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.GetOperationBlocksToAnalyze(ImmutableArray`1 executableBlocks, SemanticModel semanticModel, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 1820
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteDeclaringReferenceActions(SyntaxReference decl, Int32 declarationIndex, SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, Boolean shouldExecuteSyntaxNodeActions, Boolean shouldExecuteOperationActions, Boolean shouldExecuteCodeBlockActions, Boolean shouldExecuteOperationBlockActions, Boolean isInGeneratedCode, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 1586
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteDeclaringReferenceActions(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, Boolean isGeneratedCodeSymbol, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 1448
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessSymbolDeclared(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 875
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ProcessEventCore(CompilationEvent e, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken) in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 833
   at Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.&lt;ProcessCompilationEventsCoreAsync&gt;d__67.MoveNext() in D:\Github\roslyn\src\Compilers\Core\Portable\DiagnosticAnalyzer\AnalyzerDriver.cs:line 809
```
</Description>
    <CreatedDate>13/04/2016</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10465</IssueID>
    <RepoID>1</RepoID>
    <Title>is-pattern-expression (1 is int.MaxValue) does not parse correctly</Title>
    <Description>The code

``` cs
    if (1 is int.MaxValue) {}
```

does not parse correctly when pattern-matching is enabled. The parser finds the type `int` and then treats `.MaxValue` as unexpected tokens.
</Description>
    <CreatedDate>11/04/2016</CreatedDate>
    <ClosedDate>14/04/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17993</IssueID>
    <RepoID>1</RepoID>
    <Title>Try DynamicMethod with ref locals/return scenarios</Title>
    <Description>We expect that DynamicMethod should already handle ref locals, since it operates at the IL level.
We're not sure whether it allows declaring ref return methods.
Either way, it would be good to exercise those code paths to make sure they work.

FYI @VSadov </Description>
    <CreatedDate>20/03/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10358</IssueID>
    <RepoID>1</RepoID>
    <Title>deleted project hierarchy leaked through VisualStudioProjectTracker</Title>
    <Description>**Version Used**: new version inserted into Dev 15 code

**Steps to Reproduce**:
1.  Add a CPS barebone project to a solution
2.  Delete the project
3. Ctrl-Alt-Shift-F12 couple times to force GC
4. Attach Windbg, check UnconfiguredProjectImpl instance in the memory, they should be released.

**Expected Behavior**:
no project object hold in the memory after it is deleted.

**Actual Behavior**:
 leak through this chain:

-&gt;  1c35480c Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.DocumentKey
            -&gt;  1c24ffe8 Microsoft.VisualStudio.LanguageServices.CSharp.ProjectSystemShim.CSharpProjectShimWithServices
            -&gt;  1c1a0714 Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker
            -&gt;  1c1a0808 System.Collections.Generic.List`1[[Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker+WorkspaceHostState, Microsoft.VisualStudio.LanguageServices]]
            -&gt;  23833ad0 Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker+WorkspaceHostState[]
            -&gt;  1c1a0f78 Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.VisualStudioProjectTracker+WorkspaceHostState
            -&gt;  1c1a0f90 System.Collections.Generic.HashSet`1[[Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.AbstractProject, Microsoft.VisualStudio.LanguageServices]]
            -&gt;  1c262a80 System.Collections.Generic.HashSet`1+Slot[[Microsoft.VisualStudio.LanguageServices.Implementation.ProjectSystem.AbstractProject, Microsoft.VisualStudio.LanguageServices]][]
            -&gt;  23c9829c Microsoft.VisualStudio.LanguageServices.CSharp.ProjectSystemShim.CSharpProjectShimWithServices
            -&gt;  23acc8d0 Microsoft.VisualStudio.ProjectSystem.VS.Implementation.Package.ProjectNode
            -&gt;  23aadeb8 Microsoft.VisualStudio.ProjectSystem.UnconfiguredProjectImpl
</Description>
    <CreatedDate>05/04/2016</CreatedDate>
    <ClosedDate>25/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11616</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge master back to stabilization</Title>
    <Description>
    </Description>
    <CreatedDate>27/05/2016</CreatedDate>
    <ClosedDate>27/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11074</IssueID>
    <RepoID>1</RepoID>
    <Title>Use nameof() instead of string literals in ArgumentExceptions</Title>
    <Description>
    </Description>
    <CreatedDate>04/05/2016</CreatedDate>
    <ClosedDate>05/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11708</IssueID>
    <RepoID>1</RepoID>
    <Title>Compilation: use System.Object from target corlib (#8507)</Title>
    <Description>[ported from master: PR https://github.com/dotnet/roslyn/pull/8507]
- Tests: fix minasync Task&lt;T&gt; to derive from Task
- Tests: provide MinAsyncCorlibRef

This combines the async features of minasync with mincorlib to produce
a minimum unversioned corlib with async stubs.
- Compilation: use System.Object from target corlib

When creating a script compilation without an explicit return type,
System.Object was being resolved via reflection from the host.

This resulted in an implicit dependency of a script compilation on the
host corlib, even if a different corlib was specified as a reference
for the compilation (e.g. Xamarin.iOS).

Fix this by using System.Object as defined in the corlib resovled
for the compilation.
</Description>
    <CreatedDate>02/06/2016</CreatedDate>
    <ClosedDate>02/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10920</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge "typeswitch" into future</Title>
    <Description>This merges the "typeswitch" subset of pattern-matching into future.

@dotnet/roslyn-compiler
</Description>
    <CreatedDate>27/04/2016</CreatedDate>
    <ClosedDate>27/04/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11782</IssueID>
    <RepoID>1</RepoID>
    <Title>Update CoreFX to rc3-24206-00</Title>
    <Description>Update CoreFX to rc3-24206-00
</Description>
    <CreatedDate>06/06/2016</CreatedDate>
    <ClosedDate>06/06/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11707</IssueID>
    <RepoID>1</RepoID>
    <Title>Debugger doesn't show field-like events in objects</Title>
    <Description>**Version Used**: Dev14 Update 2

Source:

``` C#
class C {
    event Action E;
    int i;
    public static void Main() {
        var c = new C();
    }
}
```

Set a breakpoint below the variable and hit run.

Expanding the object (in the datatip, locals window, or wherever) shows `i`, but not `E`.

This is extremely annoying when debugging event issues.
</Description>
    <CreatedDate>02/06/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11742</IssueID>
    <RepoID>1</RepoID>
    <Title>stackalloc debugging behavior in x64</Title>
    <Description>**Version Used**: 
VS 2015 Update 2

**Steps to Reproduce**:
1. Create a new C# console application.
2. Copy the following code into `Program.cs`:

``` csharp
unsafe class Program
{
    static void Main(string[] args)
    {
        byte* s = stackalloc byte[100];
        return;
    }
}
```
1. Go to the project properties, allow unsafe code and **force x64**.
2. Set a breakpoint at the `stackalloc` line.
3. Start debugging.
4. Press F10 to step to the `return` statement.

**Expected Behavior**:

Execution moves to the `return` statement.

**Actual Behavior**:

I have to press F10 several times before execution moves to the `return` statement. Additionally, **the debugging session is sometimes abruptly ended when pressing F10 several times to skip over `stackalloc`**, though I have been unable to reproduce this issue with a simple test case. There's an open source project where the issue can be reproduced reliably, if you're interested.

**Additional Remarks**:
- Happens only in x64. Might be a RyuJit issue instead of Roslyn?
- Happens in both Release and Debug builds.
</Description>
    <CreatedDate>03/06/2016</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11301</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing switch cases should not be ordered above Generate Method</Title>
    <Description>
    </Description>
    <CreatedDate>13/05/2016</CreatedDate>
    <ClosedDate>02/06/2016</ClosedDate>
  </Issue>
</Issues>