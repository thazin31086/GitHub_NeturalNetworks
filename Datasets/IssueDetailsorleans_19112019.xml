<IssueDetails>
  <IssueDetail>
    <IssueLabelID>6129</IssueLabelID>
    <Title>[Question] Possible integration scenario using Event Hub streaming</Title>
    <Description>Hello all

I was able to find a couple of topics around Orleans Streaming + Event Hub but I haven't been able to find something around the scenario that I've just tried.

I'd like to integrate a couple of applications and I'd like to take advantage of the rewindable streaming support from Orleans+Event Hub. Direct connection between those products is not doable but the following setup seems to work fine. 

If each application bootstraps their own localhost silo and configure the same Event Hub stream provider they will be able to pass events between each other maintain their own cursor or if I start a new silo and create a new subscriber it will just ingest everything until it catches up. Fortunately this is exactly what I need.

Am I missing something? Is this a valid approach? What are the possible issues I can get into (from the Orleans standpoint/Event Hub standpoint)?



</Description>
    <Title_Description>[Question] Possible integration scenario using Event Hub streaming Hello all

I was able to find a couple of topics around Orleans Streaming + Event Hub but I haven't been able to find something around the scenario that I've just tried.

I'd like to integrate a couple of applications and I'd like to take advantage of the rewindable streaming support from Orleans+Event Hub. Direct connection between those products is not doable but the following setup seems to work fine. 

If each application bootstraps their own localhost silo and configure the same Event Hub stream provider they will be able to pass events between each other maintain their own cursor or if I start a new silo and create a new subscriber it will just ingest everything until it catches up. Fortunately this is exactly what I need.

Am I missing something? Is this a valid approach? What are the possible issues I can get into (from the Orleans standpoint/Event Hub standpoint)?



</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6128</IssueLabelID>
    <Title>InconsistentStateException happened when using single silo</Title>
    <Description>I am using direct client with single silo in same process in asp.net core。
Can this InconsistentStateException  occur in this situation?
net core ：3.0.0
Storage Provider：Azure table Persistence.AzureStorage
orleans：3.0.0</Description>
    <Title_Description>InconsistentStateException happened when using single silo I am using direct client with single silo in same process in asp.net core。
Can this InconsistentStateException  occur in this situation?
net core ：3.0.0
Storage Provider：Azure table Persistence.AzureStorage
orleans：3.0.0</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6126</IssueLabelID>
    <Title>[WIP] DynamoDB: support extended membership protocol</Title>
    <Description>Implements the extended membership protocol for DynamoDB.

Fixes #6099 

Still need to go through testing.

I noticed a few things while implementing this:

1. `ReadAll` isn't guaranteed to return all silo entries at the same version. It seemed like other implementations can also be inconsistent but I'm not familiar enough to say for certain.
2. The Azure implementation seems to be more aggressive at throwing exceptions when rows don't exist than other implementations. I'm not sure what the preference is.
3. `DynamoDBMembershipTable` is getting a bit hard to read with all the low level dynamo db. It could be broken up but it may be better to use a higher level api. That type of refactoring seems outside the scope of this PR though.</Description>
    <Title_Description>[WIP] DynamoDB: support extended membership protocol Implements the extended membership protocol for DynamoDB.

Fixes #6099 

Still need to go through testing.

I noticed a few things while implementing this:

1. `ReadAll` isn't guaranteed to return all silo entries at the same version. It seemed like other implementations can also be inconsistent but I'm not familiar enough to say for certain.
2. The Azure implementation seems to be more aggressive at throwing exceptions when rows don't exist than other implementations. I'm not sure what the preference is.
3. `DynamoDBMembershipTable` is getting a bit hard to read with all the low level dynamo db. It could be broken up but it may be better to use a higher level api. That type of refactoring seems outside the scope of this PR though.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6125</IssueLabelID>
    <Title>Orleans.TestCluster cannot be used at the same time as the unit test. AspNetCore.TestServer is used at the same time.</Title>
    <Description>Orleans.TestCluster cannot be used at the same time as the unit test. AspNetCore.TestServer is used at the same time.
Is there any other solution?
```
            var webHostBuilder = new WebHostBuilder().UseStartup&lt;HttpStartup&gt;();
            this.Server = new TestServer(webHostBuilder);

            var builder = new TestClusterBuilder(1);
            builder.Options.BaseSiloPort = 1000; // this works while ISiloBuilderConfigurator does not
            builder.Options.BaseGatewayPort = 1001;
            builder.AddClientBuilderConfigurator&lt;ClientBuilderConfigurator&gt;();
            builder.AddSiloBuilderConfigurator&lt;SiloBuilderConfigurator&gt;();
            var cluster = builder.Build();
            cluster.DeployAsync().Wait();
            this.Client = cluster.Client;
```</Description>
    <Title_Description>Orleans.TestCluster cannot be used at the same time as the unit test. AspNetCore.TestServer is used at the same time. Orleans.TestCluster cannot be used at the same time as the unit test. AspNetCore.TestServer is used at the same time.
Is there any other solution?
```
            var webHostBuilder = new WebHostBuilder().UseStartup&lt;HttpStartup&gt;();
            this.Server = new TestServer(webHostBuilder);

            var builder = new TestClusterBuilder(1);
            builder.Options.BaseSiloPort = 1000; // this works while ISiloBuilderConfigurator does not
            builder.Options.BaseGatewayPort = 1001;
            builder.AddClientBuilderConfigurator&lt;ClientBuilderConfigurator&gt;();
            builder.AddSiloBuilderConfigurator&lt;SiloBuilderConfigurator&gt;();
            var cluster = builder.Build();
            cluster.DeployAsync().Wait();
            this.Client = cluster.Client;
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6124</IssueLabelID>
    <Title>Fix a typo</Title>
    <Description>
    </Description>
    <Title_Description>Fix a typo </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/11/2019 4:27:30 PM +00:00</CreatedAt>
    <ClosedAt>15/11/2019 4:44:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6123</IssueLabelID>
    <Title>Testing GrainServices in Orleans 2.4.2</Title>
    <Description>Hi there! 

I'm a new bee in Orleans I just joined a team which uses this fantastic tech and now We're in charge of developing some tests **(version 2.4.2)**.

I got to this GrainService and using TestCluster in xUnit I just can't get to the service in the tests. This always returns NULL.

Here are some code from the classes:

Fixture configuring the service in the cluster silos:

```C#
private class SiloBuilderConfigurator : ISiloBuilderConfigurator
 {
    public void Configure(ISiloHostBuilder hostBuilder)
    {
        hostBuilder.ConfigureServices(services =&gt;
        {
          // This two lines below was a try to fix a runtime exception explained in details further on...
            services.AddSingleton&lt;FakeGrainIdentity&gt;();
            services.AddSingleton&lt;IGrainIdentity&gt;(_ =&gt; _.GetService&lt;FakeGrainIdentity&gt;());
              ...
            services.AddSingleton&lt;RmdsSubscriptionService&gt;();
            services.AddSingleton&lt;IRmdsSubscriptionService&gt;(_ =&gt; _.GetService&lt;RmdsSubscriptionService&gt;());

        });
    }
}

public ClusterFixture()
{
    var builder = new TestClusterBuilder();

    builder.ConfigureHostConfiguration(config =&gt;
    {
        config.AddInMemoryCollection(new Dictionary&lt;string string&gt;()
        {
            { nameof(TestClusterId) TestClusterId }
        });
    });

    builder.AddSiloBuilderConfigurator&lt;SiloBuilderConfigurator&gt;();

    Cluster = builder.Build();
    Cluster.Deploy();

}
```

Then the GrainService constructor (where the problem raises):

```C#
    [Reentrant]
    [OneInstancePerCluster]
    public class RmdsSubscriptionService : GrainService IRmdsSubscriptionService
    {
        ....
        public RmdsSubscriptionService(IGrainIdentity grainId Silo silo ILoggerFactory loggerFactory IGrainFactory grainFactory)
            : base(grainId silo loggerFactory) // &lt;== The Exception used to occour here in the GrainId casting.
        {
            this.logger = loggerFactory.CreateLogger(nameof(RmdsSubscriptionService));

            subscriptions = ImmutableArray&lt;ISubscription&gt;.Empty;

            this.grainFactory = grainFactory;
        }
       
    }
```
I implemented a FakeGrainIdentity inheriting IGrainIdentity to try to accomplish a DI in the service constructor but even with this the exception raises as follows:
System.InvalidCastException : Unable to cast object of type 'Grains.Tests.FakeGrainIdentity' to type 'Orleans.Runtime.GrainId'.

After some researching I found an example that uses the GetServiceByName in the ServiceProvider but it keeps returning NULL.

I tried some code as follows:

```C#
// 1st try:
var rmdsService = _fixture.Cluster.ServiceProvider.GetServiceByName&lt;RmdsSubscriptionService&gt;(nameof(RmdsSubscriptionService));

// 2nd try:
var rmdsService = _fixture.Cluster.ServiceProvider.GetServiceByName&lt;RmdsSubscriptionService&gt;(_fixture.TestClusterId);
```

I'm stock in this code with no success. What am I doing wrong? What am I missing here? 

Please help!

Thanks beforehands!





</Description>
    <Title_Description>Testing GrainServices in Orleans 2.4.2 Hi there! 

I'm a new bee in Orleans I just joined a team which uses this fantastic tech and now We're in charge of developing some tests **(version 2.4.2)**.

I got to this GrainService and using TestCluster in xUnit I just can't get to the service in the tests. This always returns NULL.

Here are some code from the classes:

Fixture configuring the service in the cluster silos:

```C#
private class SiloBuilderConfigurator : ISiloBuilderConfigurator
 {
    public void Configure(ISiloHostBuilder hostBuilder)
    {
        hostBuilder.ConfigureServices(services =&gt;
        {
          // This two lines below was a try to fix a runtime exception explained in details further on...
            services.AddSingleton&lt;FakeGrainIdentity&gt;();
            services.AddSingleton&lt;IGrainIdentity&gt;(_ =&gt; _.GetService&lt;FakeGrainIdentity&gt;());
              ...
            services.AddSingleton&lt;RmdsSubscriptionService&gt;();
            services.AddSingleton&lt;IRmdsSubscriptionService&gt;(_ =&gt; _.GetService&lt;RmdsSubscriptionService&gt;());

        });
    }
}

public ClusterFixture()
{
    var builder = new TestClusterBuilder();

    builder.ConfigureHostConfiguration(config =&gt;
    {
        config.AddInMemoryCollection(new Dictionary&lt;string string&gt;()
        {
            { nameof(TestClusterId) TestClusterId }
        });
    });

    builder.AddSiloBuilderConfigurator&lt;SiloBuilderConfigurator&gt;();

    Cluster = builder.Build();
    Cluster.Deploy();

}
```

Then the GrainService constructor (where the problem raises):

```C#
    [Reentrant]
    [OneInstancePerCluster]
    public class RmdsSubscriptionService : GrainService IRmdsSubscriptionService
    {
        ....
        public RmdsSubscriptionService(IGrainIdentity grainId Silo silo ILoggerFactory loggerFactory IGrainFactory grainFactory)
            : base(grainId silo loggerFactory) // &lt;== The Exception used to occour here in the GrainId casting.
        {
            this.logger = loggerFactory.CreateLogger(nameof(RmdsSubscriptionService));

            subscriptions = ImmutableArray&lt;ISubscription&gt;.Empty;

            this.grainFactory = grainFactory;
        }
       
    }
```
I implemented a FakeGrainIdentity inheriting IGrainIdentity to try to accomplish a DI in the service constructor but even with this the exception raises as follows:
System.InvalidCastException : Unable to cast object of type 'Grains.Tests.FakeGrainIdentity' to type 'Orleans.Runtime.GrainId'.

After some researching I found an example that uses the GetServiceByName in the ServiceProvider but it keeps returning NULL.

I tried some code as follows:

```C#
// 1st try:
var rmdsService = _fixture.Cluster.ServiceProvider.GetServiceByName&lt;RmdsSubscriptionService&gt;(nameof(RmdsSubscriptionService));

// 2nd try:
var rmdsService = _fixture.Cluster.ServiceProvider.GetServiceByName&lt;RmdsSubscriptionService&gt;(_fixture.TestClusterId);
```

I'm stock in this code with no success. What am I doing wrong? What am I missing here? 

Please help!

Thanks beforehands!





</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6121</IssueLabelID>
    <Title>Remove 1.5 docs</Title>
    <Description>Even though 1.5 docs aren't linked from the menu they still appear in search and cause more confusion than help. I think it's time to delete them for good.</Description>
    <Title_Description>Remove 1.5 docs Even though 1.5 docs aren't linked from the menu they still appear in search and cause more confusion than help. I think it's time to delete them for good.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>14/11/2019 8:57:50 PM +00:00</CreatedAt>
    <ClosedAt>14/11/2019 11:05:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6120</IssueLabelID>
    <Title>SMS - PubSubRendezvous not active on silo - orleans 3</Title>
    <Description>We just recently updated to netcore3 and Orleans 3 and we have some critical issue with SMS it seems to happen mainly with the `PubSubRendezvousGrain` not activating correctly when its on "heavy load". We are calling `AddStream` on Grain Activation of certain grains and the following is being thrown.

#### Error
![2019-11-14 17_49_48-Discover_ Odin Microservice - Errors - Kibana](https://user-images.githubusercontent.com/3908723/68877961-2f6c1780-0707-11ea-9d14-a6d284666d3c.png)


After a while it seems to stables a bit (sometimes) - tho another error appeared seems a silo got restarted and afterwards it couldn't locate a grain see the following error:

&gt; Current directory at S10.150.18.52:11111:311443752 is not stable to perform the lookup for grainId *grn/814818CD/00000000+CommonHub:crrcp1DxHhge4eUxRYc_GA (it maps to S10.150.21.226:11111:311443752 which is not a valid silo). Retry later.

![image](https://user-images.githubusercontent.com/3908723/68880851-58db7200-070c-11ea-8977-49a337cd31bb.png)


#### Using
- Docker (linux) based on `mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim`
- K8's
- Redis as Storage Provider for SMS
- Silos Count: 9
- Server load 35-60%

Basically we had ended up reverting on prod from using Orleans 3 netcore3 for now as several services are not working correctly.

If you need anything else we be happy to help. Thanks
</Description>
    <Title_Description>SMS - PubSubRendezvous not active on silo - orleans 3 We just recently updated to netcore3 and Orleans 3 and we have some critical issue with SMS it seems to happen mainly with the `PubSubRendezvousGrain` not activating correctly when its on "heavy load". We are calling `AddStream` on Grain Activation of certain grains and the following is being thrown.

#### Error
![2019-11-14 17_49_48-Discover_ Odin Microservice - Errors - Kibana](https://user-images.githubusercontent.com/3908723/68877961-2f6c1780-0707-11ea-9d14-a6d284666d3c.png)


After a while it seems to stables a bit (sometimes) - tho another error appeared seems a silo got restarted and afterwards it couldn't locate a grain see the following error:

&gt; Current directory at S10.150.18.52:11111:311443752 is not stable to perform the lookup for grainId *grn/814818CD/00000000+CommonHub:crrcp1DxHhge4eUxRYc_GA (it maps to S10.150.21.226:11111:311443752 which is not a valid silo). Retry later.

![image](https://user-images.githubusercontent.com/3908723/68880851-58db7200-070c-11ea-8977-49a337cd31bb.png)


#### Using
- Docker (linux) based on `mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim`
- K8's
- Redis as Storage Provider for SMS
- Silos Count: 9
- Server load 35-60%

Basically we had ended up reverting on prod from using Orleans 3 netcore3 for now as several services are not working correctly.

If you need anything else we be happy to help. Thanks
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6119</IssueLabelID>
    <Title>Add a change missed in #6106</Title>
    <Description>
    </Description>
    <Title_Description>Add a change missed in #6106 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6118</IssueLabelID>
    <Title>Add information about Shared/Main SQL scripts</Title>
    <Description>Fixes #6117.</Description>
    <Title_Description>Add information about Shared/Main SQL scripts Fixes #6117.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/11/2019 6:25:50 PM +00:00</CreatedAt>
    <ClosedAt>14/11/2019 11:05:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6116</IssueLabelID>
    <Title>Can two grains of the same interface handle one reminder?</Title>
    <Description>Hi!

Suppose we have two grains implementing one grain interface. `Grain-1` defines a reminder that was persisted so on the next silo start it will be rised. Can `Grain-2` consume this reminder if `Grain-1` wasn't registered after reboot (but `Grain-2` was)?

Specifically my case is this: I need to implement a way to disable some functionality (`Grain-1`) while retaining the ability to dummy-access it (`Grain-2` - dummy). At the same time `Grain-1` creates a reminder that must be processed in a dummy way.

I hope for your help.</Description>
    <Title_Description>Can two grains of the same interface handle one reminder? Hi!

Suppose we have two grains implementing one grain interface. `Grain-1` defines a reminder that was persisted so on the next silo start it will be rised. Can `Grain-2` consume this reminder if `Grain-1` wasn't registered after reboot (but `Grain-2` was)?

Specifically my case is this: I need to implement a way to disable some functionality (`Grain-1`) while retaining the ability to dummy-access it (`Grain-2` - dummy). At the same time `Grain-1` creates a reminder that must be processed in a dummy way.

I hope for your help.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6115</IssueLabelID>
    <Title>Transactions &amp; OnActivateAsync</Title>
    <Description>Hello colleagues

As part of the investigation process for Olreans Transactions I've faced the following issue. One of my grains operates with streams. In order to work properly it requires streams to be resumed as part of `OnActivateAsync` as per official docs. All required information to resume on the interested streams sits inside the state of the grain.

However when I've tried to utilize `ITransactionalState` facet as part of `OnActivateAsync` I've faced the following error:

```cs
2019-11-12 20:05:35439 [9] Error Lifecycle start canceled due to errors at stage 2000: Orleans.Transactions.OrleansTransactionException: A transaction context is required for access. Did you forget a [Transaction] attribute?
   at Orleans.Transactions.TransactionContext.GetRequiredTransactionInfo[T]()
   at Orleans.Transactions.TransactionalState`1.PerformRead[TResult](Func`2 operation)
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.RetrieveEventStreams() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 138
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.RetrieveSubscriptions() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 121
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.OnActivateAsync() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 46
   at Orleans.LifecycleSubject.&lt;OnStart&gt;g__CallOnStart|7_0(Int32 stage OrderedObserver observer CancellationToken cancellationToken)
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
```
Performed two experiments with no success:
1. Marked `OnActivateAsync` with `[Transaction(TransactionOption.CreateOrJoin)]`;
1. Added a method `OnActivateAsync` to my grain interface and marked it with `[Transaction(TransactionOption.CreateOrJoin)]`;

Both of them failed with the error displayed above. 

I'm wondering whether this is generally not supported or I'm doing something wrong. Could you please advise?

Thanks.

@sergeybykov @ReubenBond  @jason-bragg </Description>
    <Title_Description>Transactions &amp; OnActivateAsync Hello colleagues

As part of the investigation process for Olreans Transactions I've faced the following issue. One of my grains operates with streams. In order to work properly it requires streams to be resumed as part of `OnActivateAsync` as per official docs. All required information to resume on the interested streams sits inside the state of the grain.

However when I've tried to utilize `ITransactionalState` facet as part of `OnActivateAsync` I've faced the following error:

```cs
2019-11-12 20:05:35439 [9] Error Lifecycle start canceled due to errors at stage 2000: Orleans.Transactions.OrleansTransactionException: A transaction context is required for access. Did you forget a [Transaction] attribute?
   at Orleans.Transactions.TransactionContext.GetRequiredTransactionInfo[T]()
   at Orleans.Transactions.TransactionalState`1.PerformRead[TResult](Func`2 operation)
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.RetrieveEventStreams() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 138
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.RetrieveSubscriptions() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 121
   at ReviewItEasy.Webhooks.Host.Webhooks.Grains.WebhookGrain.OnActivateAsync() in /home/rakkattakka/Development/rie/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Host/Webhooks/Grains/WebhookGrain.cs:line 46
   at Orleans.LifecycleSubject.&lt;OnStart&gt;g__CallOnStart|7_0(Int32 stage OrderedObserver observer CancellationToken cancellationToken)
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
```
Performed two experiments with no success:
1. Marked `OnActivateAsync` with `[Transaction(TransactionOption.CreateOrJoin)]`;
1. Added a method `OnActivateAsync` to my grain interface and marked it with `[Transaction(TransactionOption.CreateOrJoin)]`;

Both of them failed with the error displayed above. 

I'm wondering whether this is generally not supported or I'm doing something wrong. Could you please advise?

Thanks.

@sergeybykov @ReubenBond  @jason-bragg </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6114</IssueLabelID>
    <Title>Codegen ignores negative integer type codes for TypeCodeOverride attribute</Title>
    <Description>The grain interface and class codes could be a negative integer as returned by [Utils.CalculateIdHash](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Utils/Utils.cs#L200) But codegen skips such codes and instead is falling back to re-calculation.
https://github.com/dotnet/orleans/blob/bc41bf386095a335b7ccaeda431b5ebf2fd9ac60/src/Orleans.Core/CodeGeneration/GrainInterfaceUtils.cs#L424

Having `TypeCodeOverride` is a nice workaround for system evolution scenarios where names/assemblies of the grain interfaces and classes may change and the ability to leave the old type code is crucial. It would be great if this could be patch fixed for 2.4.</Description>
    <Title_Description>Codegen ignores negative integer type codes for TypeCodeOverride attribute The grain interface and class codes could be a negative integer as returned by [Utils.CalculateIdHash](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Utils/Utils.cs#L200) But codegen skips such codes and instead is falling back to re-calculation.
https://github.com/dotnet/orleans/blob/bc41bf386095a335b7ccaeda431b5ebf2fd9ac60/src/Orleans.Core/CodeGeneration/GrainInterfaceUtils.cs#L424

Having `TypeCodeOverride` is a nice workaround for system evolution scenarios where names/assemblies of the grain interfaces and classes may change and the ability to leave the old type code is crucial. It would be great if this could be patch fixed for 2.4.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6113</IssueLabelID>
    <Title>Issues after Orleans 3.0 upgrade running on a Service Fabric Cluster</Title>
    <Description>I recently upgraded to Orleans 3.0 nuget packages on our application which is deployed on a Service Fabric Cluster. After the upgrade when we run our benchmark tests for performance I am seeing a lot of exceptions being thrown:
It starts from 
```
Microsoft.Azure.Cosmos.Table.StorageException at Orleans.Clustering.AzureStorage.AzureTableDataManager`1+&lt;&gt;c__DisplayClass28_0+&lt;&lt;ReadTableEntriesAndEtagsAsync&gt;b__0&gt;d.MoveNext
--

Intermediate issue reading Azure storage table OrleansSiloInstances: IsRetriable=False HTTP status code=NotFound REST status code=TableNotFound Exception Type=Microsoft.Azure.Cosmos.Table.StorageException Message='Not Found'
--
```
Then after a few minutes I see 
```
Orleans.Runtime.SiloUnavailableException
--
The target silo became unavailable for message: NewPlacement Request...

```
and
```

Orleans.Runtime.OrleansMessageRejectionException
--

Target S10.2.69.8:20015:311184127 silo is known to be dead

```
types of messages. I am using the Azure Table Storage Clustering for both the client and server.</Description>
    <Title_Description>Issues after Orleans 3.0 upgrade running on a Service Fabric Cluster I recently upgraded to Orleans 3.0 nuget packages on our application which is deployed on a Service Fabric Cluster. After the upgrade when we run our benchmark tests for performance I am seeing a lot of exceptions being thrown:
It starts from 
```
Microsoft.Azure.Cosmos.Table.StorageException at Orleans.Clustering.AzureStorage.AzureTableDataManager`1+&lt;&gt;c__DisplayClass28_0+&lt;&lt;ReadTableEntriesAndEtagsAsync&gt;b__0&gt;d.MoveNext
--

Intermediate issue reading Azure storage table OrleansSiloInstances: IsRetriable=False HTTP status code=NotFound REST status code=TableNotFound Exception Type=Microsoft.Azure.Cosmos.Table.StorageException Message='Not Found'
--
```
Then after a few minutes I see 
```
Orleans.Runtime.SiloUnavailableException
--
The target silo became unavailable for message: NewPlacement Request...

```
and
```

Orleans.Runtime.OrleansMessageRejectionException
--

Target S10.2.69.8:20015:311184127 silo is known to be dead

```
types of messages. I am using the Azure Table Storage Clustering for both the client and server.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6108</IssueLabelID>
    <Title>Enable to the First Orleans application to be working</Title>
    <Description>Hello

I have followed the instruction from this link in order to create a simple Orleans application (https://dotnet.github.io/orleans/1.5/Tutorials/My-First-Orleans-Application.html)

However I get a error message saying

```
InnerException:
{Orleans.Networking.Shared.SocketConnectionException: Unable to connect to xxx.x.x.x:xxxxx. Error: ConnectionRefused
   at Orleans.Networking.Shared.SocketConnectionFactory.ConnectAsync(EndPoint endpoint CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\Shared\SocketConnectionFactory.cs:line 48
   at Orleans.Runtime.Messaging.ConnectionFactory.ConnectAsync(SiloAddress address CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\ConnectionFactory.cs:line 53
   at Orleans.Internal.OrleansTaskExtentions.MakeCancellable[T](Task`1 task CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Async\TaskExtensions.cs:line 409
   at Orleans.Runtime.Messaging.ConnectionManager.ConnectAsync(SiloAddress address) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\ConnectionManager.cs:line 241}
```

Message:
`"Unable to connect to endpoint S127.0.0.1:30000:0. See InnerException"`

What part am I missing in order for the application to be working?

Thank you!</Description>
    <Title_Description>Enable to the First Orleans application to be working Hello

I have followed the instruction from this link in order to create a simple Orleans application (https://dotnet.github.io/orleans/1.5/Tutorials/My-First-Orleans-Application.html)

However I get a error message saying

```
InnerException:
{Orleans.Networking.Shared.SocketConnectionException: Unable to connect to xxx.x.x.x:xxxxx. Error: ConnectionRefused
   at Orleans.Networking.Shared.SocketConnectionFactory.ConnectAsync(EndPoint endpoint CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\Shared\SocketConnectionFactory.cs:line 48
   at Orleans.Runtime.Messaging.ConnectionFactory.ConnectAsync(SiloAddress address CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\ConnectionFactory.cs:line 53
   at Orleans.Internal.OrleansTaskExtentions.MakeCancellable[T](Task`1 task CancellationToken cancellationToken) in D:\build\agent\_work\17\s\src\Orleans.Core\Async\TaskExtensions.cs:line 409
   at Orleans.Runtime.Messaging.ConnectionManager.ConnectAsync(SiloAddress address) in D:\build\agent\_work\17\s\src\Orleans.Core\Networking\ConnectionManager.cs:line 241}
```

Message:
`"Unable to connect to endpoint S127.0.0.1:30000:0. See InnerException"`

What part am I missing in order for the application to be working?

Thank you!</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6107</IssueLabelID>
    <Title>Improve persistence doc page</Title>
    <Description>Fix an error in storage provider name.
Add a second provider for cart store.</Description>
    <Title_Description>Improve persistence doc page Fix an error in storage provider name.
Add a second provider for cart store.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6102</IssueLabelID>
    <Title>Fix routing of gateway count changed events to registered servi…</Title>
    <Description>Update the `OutsideRuntimeClient` to add registered `GatewayCountChanged` services as handlers of the internal event. This fixes #6098.

Additionally when disposed remove the registered handlers in cases where the cluster client is disposed and registered handlers live longer.</Description>
    <Title_Description>Fix routing of gateway count changed events to registered servi… Update the `OutsideRuntimeClient` to add registered `GatewayCountChanged` services as handlers of the internal event. This fixes #6098.

Additionally when disposed remove the registered handlers in cases where the cluster client is disposed and registered handlers live longer.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6099</IssueLabelID>
    <Title>DynamoDB clustering: support extended membership protocol</Title>
    <Description>The current implementation of the DynamoDB clustering provider only supports the initial membership protocol not the later [extension to the protocol](https://dotnet.github.io/orleans/Documentation/implementation/cluster_management.html#extension-to-totally-order-membership-views) to support totally ordered views of cluster membership.

It's important to support this so that the provider will function correctly.

See this PR which adds such support to Consul: https://github.com/dotnet/orleans/pull/6095</Description>
    <Title_Description>DynamoDB clustering: support extended membership protocol The current implementation of the DynamoDB clustering provider only supports the initial membership protocol not the later [extension to the protocol](https://dotnet.github.io/orleans/Documentation/implementation/cluster_management.html#extension-to-totally-order-membership-views) to support totally ordered views of cluster membership.

It's important to support this so that the provider will function correctly.

See this PR which adds such support to Consul: https://github.com/dotnet/orleans/pull/6095</Title_Description>
    <Label>help wanted</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>7/11/2019 5:58:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6098</IssueLabelID>
    <Title>AddGatewayCountChangedHandler does not work</Title>
    <Description>`AddGatewayCountChangedHandler` doesn't work because the implementation of `OutsideRuntimeClient` doesn't forward on the event like he does for connection lost - https://github.com/dotnet/orleans/blob/c683fa8f2fddf310c2dfc3c9cf43db4fb80be1ad/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs#L121

This means there doesn't seem to be a simple way to know when a connection is re-established? Something that is necessary for client subscription to be resumed.</Description>
    <Title_Description>AddGatewayCountChangedHandler does not work `AddGatewayCountChangedHandler` doesn't work because the implementation of `OutsideRuntimeClient` doesn't forward on the event like he does for connection lost - https://github.com/dotnet/orleans/blob/c683fa8f2fddf310c2dfc3c9cf43db4fb80be1ad/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs#L121

This means there doesn't seem to be a simple way to know when a connection is re-established? Something that is necessary for client subscription to be resumed.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6096</IssueLabelID>
    <Title>Logger names for PubSubRendezvousGrain too fine grained</Title>
    <Description>I'm investigating a memory issue in our orleans cluster. While investigating a process dump I discovered there is a large amount of memory retained inside a dictionary in Microsoft.Extension.LoggingLoggerFactory. This dictionary keeps a mapping between LoggerName and logger. It seems that foreach stream event the PubSubRendezvousGrain is handling a new logger name and logger is created. 

In the dump the this dictionary contains over 40000 loggers which results in 26 MB of memory retention and I suspect it just keeps growing. For reference we use Serilog as logging provider.

Here some examples of created logger names:

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/40a234f781217745a9800a6c5a9bb98806000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0x5F8B8B46`

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/4161ca03098d9df78600e17e3aa7dda206000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0x18AADBD0`

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/47ab2e70ab630b13a05933bcab52978e06000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0xB5C9A4D0`

I think it would be better when the logger names in case would more coarse grained and the grain identity and event information should be moved to the logged message.

So the proposed logger name should just be:

`Orleans.Streams.PubSubRendezvousGrain`



</Description>
    <Title_Description>Logger names for PubSubRendezvousGrain too fine grained I'm investigating a memory issue in our orleans cluster. While investigating a process dump I discovered there is a large amount of memory retained inside a dictionary in Microsoft.Extension.LoggingLoggerFactory. This dictionary keeps a mapping between LoggerName and logger. It seems that foreach stream event the PubSubRendezvousGrain is handling a new logger name and logger is created. 

In the dump the this dictionary contains over 40000 loggers which results in 26 MB of memory retention and I suspect it just keeps growing. For reference we use Serilog as logging provider.

Here some examples of created logger names:

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/40a234f781217745a9800a6c5a9bb98806000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0x5F8B8B46`

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/4161ca03098d9df78600e17e3aa7dda206000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0x18AADBD0`

`Orleans.Streams.PubSubRendezvousGrain.S172.31.201.57:50000:310208942.*grn/716E8E94/47ab2e70ab630b13a05933bcab52978e06000000716e8e94+XXXStreamProvider_XXX.XXXChanged-0xB5C9A4D0`

I think it would be better when the logger names in case would more coarse grained and the grain identity and event information should be moved to the logged message.

So the proposed logger name should just be:

`Orleans.Streams.PubSubRendezvousGrain`



</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6094</IssueLabelID>
    <Title>No storage provider named "xxx" found loading grain type</Title>
    <Description>orleans 3.0
I used as the  document say injected IPersistentState&lt;TState&gt; into the grain as constructor parameters  silo  has been configured with the name "profileStore".
but client throw an exception: No storage provider named "xxx" found loading grain type
inheriting from Grain&lt; TState &gt; This is still supported but is considered legacy. injected IPersistentState&lt; TState &gt; is it the recommended way?
Is there anything wrong here?

```
public class UserGrain : Grain IUserGrain
{
  private readonly IPersistentState&lt;ProfileState&gt; _profile;
  private readonly IPersistentState&lt;CartState&gt; _cart;

  public UserGrain(
    [PersistentState("profile" "myGrainStorage")] IPersistentState&lt;ProfileState&gt; profile
    [PersistentState("cart" "cartStorage")] IPersistentState&lt;CartState&gt; cart
    )
  {
    _profile = profile;
    _cart = cart;
  }
}
```</Description>
    <Title_Description>No storage provider named "xxx" found loading grain type orleans 3.0
I used as the  document say injected IPersistentState&lt;TState&gt; into the grain as constructor parameters  silo  has been configured with the name "profileStore".
but client throw an exception: No storage provider named "xxx" found loading grain type
inheriting from Grain&lt; TState &gt; This is still supported but is considered legacy. injected IPersistentState&lt; TState &gt; is it the recommended way?
Is there anything wrong here?

```
public class UserGrain : Grain IUserGrain
{
  private readonly IPersistentState&lt;ProfileState&gt; _profile;
  private readonly IPersistentState&lt;CartState&gt; _cart;

  public UserGrain(
    [PersistentState("profile" "myGrainStorage")] IPersistentState&lt;ProfileState&gt; profile
    [PersistentState("cart" "cartStorage")] IPersistentState&lt;CartState&gt; cart
    )
  {
    _profile = profile;
    _cart = cart;
  }
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6093</IssueLabelID>
    <Title>IClusterClient in Azure App Service connecting to Silo in a VM</Title>
    <Description>I've got a Orleans silo running on a VM within a VNET with ip address &amp; port 10.1.2.4:30000.
I have an Azure App Service which has been configured with VNET integration to the VM's VNET.
I've currently configured the Network Security Groups &amp; OS Firewalls to allow all connections over the port ranges that the silo has been configured with.

When I attempt to connect a ClusterClient from the .net core web app running in the Azure App Service I get back:
```
Orleans.Networking.Shared.SocketConnectionException
Unable to connect to endpoint S10.1.2.4:30000:0. See InnerException Unable to connect to 10.1.2.4:30000. Error: AccessDenied
```
Note: There is no InnerException. 

In the kudu console of the Azure App Service I'm able to run tcpping 10.1.2.4:30000 and i get back:
```
D:\home&gt;tcpping 10.1.2.4:30000
Connected to 10.1.2.4:30000 time taken: 172ms
Connected to 10.1.2.4:30000 time taken: 13ms
Connected to 10.1.2.4:30000 time taken: 11ms
Connected to 10.1.2.4:30000 time taken: &lt;1ms
Complete: 4/4 successful attempts (100%). Average success time: 49ms
```
Which indicates to me that the App Service is correctly VNET integrated.

I'm also able to successfully connect to the silo with a ClusterClient from my local machine (which has a VPN connection to the VNET) so there isn't an issue with the silo not accepting connections.

Is the IClusterClient meant to be able to run in an Azure App Service ? Does it maybe attempt to listen on a local socket which is not permitted according to the [Azure App Service restrictions](https://github.com/projectkudu/kudu/wiki/Azure-Web-App-sandbox#networking-restrictionsconsiderations)?

Is there some kind of work around that does not involve having to convert everything to run in the hugely complex Kubernetes/Docker nightmare or setting up IIS on virtual machines.</Description>
    <Title_Description>IClusterClient in Azure App Service connecting to Silo in a VM I've got a Orleans silo running on a VM within a VNET with ip address &amp; port 10.1.2.4:30000.
I have an Azure App Service which has been configured with VNET integration to the VM's VNET.
I've currently configured the Network Security Groups &amp; OS Firewalls to allow all connections over the port ranges that the silo has been configured with.

When I attempt to connect a ClusterClient from the .net core web app running in the Azure App Service I get back:
```
Orleans.Networking.Shared.SocketConnectionException
Unable to connect to endpoint S10.1.2.4:30000:0. See InnerException Unable to connect to 10.1.2.4:30000. Error: AccessDenied
```
Note: There is no InnerException. 

In the kudu console of the Azure App Service I'm able to run tcpping 10.1.2.4:30000 and i get back:
```
D:\home&gt;tcpping 10.1.2.4:30000
Connected to 10.1.2.4:30000 time taken: 172ms
Connected to 10.1.2.4:30000 time taken: 13ms
Connected to 10.1.2.4:30000 time taken: 11ms
Connected to 10.1.2.4:30000 time taken: &lt;1ms
Complete: 4/4 successful attempts (100%). Average success time: 49ms
```
Which indicates to me that the App Service is correctly VNET integrated.

I'm also able to successfully connect to the silo with a ClusterClient from my local machine (which has a VPN connection to the VNET) so there isn't an issue with the silo not accepting connections.

Is the IClusterClient meant to be able to run in an Azure App Service ? Does it maybe attempt to listen on a local socket which is not permitted according to the [Azure App Service restrictions](https://github.com/projectkudu/kudu/wiki/Azure-Web-App-sandbox#networking-restrictionsconsiderations)?

Is there some kind of work around that does not involve having to convert everything to run in the hugely complex Kubernetes/Docker nightmare or setting up IIS on virtual machines.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6090</IssueLabelID>
    <Title>Found problems with cluster via Consul</Title>
    <Description>Hi 
Just tried using Orleans first time so I have several issues here when using Consul.
I'm using .NET Core 3.1 and starts silos on local machine.

1. After several silos restart Consul contains information about dead silos and Orleans is trying to reuse it every time. Looks like there is needed purging mechanism from key-value storage.
2. After restarting Consul agent (single in my testing environment) cluster become dead - silos do no register themself anymore and can not find others.

For starting Consul I'm using this command
```
consul.exe agent -dev -bind=127.0.0.1
```

Nothing special here just following your Hello World examples and connected to Consul so if you need my test application I can provide it with ease.</Description>
    <Title_Description>Found problems with cluster via Consul Hi 
Just tried using Orleans first time so I have several issues here when using Consul.
I'm using .NET Core 3.1 and starts silos on local machine.

1. After several silos restart Consul contains information about dead silos and Orleans is trying to reuse it every time. Looks like there is needed purging mechanism from key-value storage.
2. After restarting Consul agent (single in my testing environment) cluster become dead - silos do no register themself anymore and can not find others.

For starting Consul I'm using this command
```
consul.exe agent -dev -bind=127.0.0.1
```

Nothing special here just following your Hello World examples and connected to Consul so if you need my test application I can provide it with ease.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6089</IssueLabelID>
    <Title>SiloStatusChangeNotification being hit multiple times</Title>
    <Description>**Environment:**

- 4 Windows Servers (1 silo on each server)
- Consul Clustering
- Ado Reminders (MariaDB)

Current working orleans version 2.3.4 (no issues)
Issues reported once updated to orleans 2.4.3

**Reported Issue:**

MariaDb database being hit by large amounts of select reminders query. (643945 selects in 40min starting with an empty reminders table then eventually creating about 60 reminders)

`SELECT 		GrainId 		ReminderName 		StartTime 		Period 		Version 	FROM OrleansRemindersTable 	WHERE 		ServiceId = 'xxx' AND 'xxx' IS NOT NULL 		AND ((GrainHash &gt; 2107253094 AND 2107253094 IS NOT NULL) 		OR (GrainHash &lt;= -2052557686 AND -2052557686 IS NOT NULL))`

After tuning on Information logs we've seen 'Added Server..' log more than 13000 times in 40min

`Added Server Sxx.xx.xxx.24:20001:310558213/xA2F1633E. Current view: [Sxx.xx.xxx.21:20001:310557917 -&gt; &lt;MultiRange: Size=x2FE94EF8 %Ring=18.715%&gt; Sxx.xx.xxx.22:20001:310557967 -&gt; &lt;MultiRange: Size=x3C9921CC %Ring=23.671%&gt; Sxx.xx.xxx.24:20001:310558213 -&gt; &lt;MultiRange: Size=x422D3E8A %Ring=25.850%&gt; Sxx.xx.xxx.23:20001:310558077 -&gt; &lt;MultiRange: Size=x515050B2 %Ring=31.763%&gt;]`

This log is being called via this call stack: 

SiloStatusListenerManager.Participate.ProcessMembershipUpdates.NotifyObservers -&gt;
VirtualBucketsRingProvider.SiloStatusChangeNotification.**AddServer**.NotifyLocalRangeSubscribers - &gt; RangeChangeNotification.OnRangeChange.ReadAndUpdateReminders.ReadTableAndStartTimers

The log 'Starting VirtualBucketsRingProvider on silo' is only hit 4 times within the 40min session.

What is triggering Silo Status Change Notification? 





</Description>
    <Title_Description>SiloStatusChangeNotification being hit multiple times **Environment:**

- 4 Windows Servers (1 silo on each server)
- Consul Clustering
- Ado Reminders (MariaDB)

Current working orleans version 2.3.4 (no issues)
Issues reported once updated to orleans 2.4.3

**Reported Issue:**

MariaDb database being hit by large amounts of select reminders query. (643945 selects in 40min starting with an empty reminders table then eventually creating about 60 reminders)

`SELECT 		GrainId 		ReminderName 		StartTime 		Period 		Version 	FROM OrleansRemindersTable 	WHERE 		ServiceId = 'xxx' AND 'xxx' IS NOT NULL 		AND ((GrainHash &gt; 2107253094 AND 2107253094 IS NOT NULL) 		OR (GrainHash &lt;= -2052557686 AND -2052557686 IS NOT NULL))`

After tuning on Information logs we've seen 'Added Server..' log more than 13000 times in 40min

`Added Server Sxx.xx.xxx.24:20001:310558213/xA2F1633E. Current view: [Sxx.xx.xxx.21:20001:310557917 -&gt; &lt;MultiRange: Size=x2FE94EF8 %Ring=18.715%&gt; Sxx.xx.xxx.22:20001:310557967 -&gt; &lt;MultiRange: Size=x3C9921CC %Ring=23.671%&gt; Sxx.xx.xxx.24:20001:310558213 -&gt; &lt;MultiRange: Size=x422D3E8A %Ring=25.850%&gt; Sxx.xx.xxx.23:20001:310558077 -&gt; &lt;MultiRange: Size=x515050B2 %Ring=31.763%&gt;]`

This log is being called via this call stack: 

SiloStatusListenerManager.Participate.ProcessMembershipUpdates.NotifyObservers -&gt;
VirtualBucketsRingProvider.SiloStatusChangeNotification.**AddServer**.NotifyLocalRangeSubscribers - &gt; RangeChangeNotification.OnRangeChange.ReadAndUpdateReminders.ReadTableAndStartTimers

The log 'Starting VirtualBucketsRingProvider on silo' is only hit 4 times within the 40min session.

What is triggering Silo Status Change Notification? 





</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6088</IssueLabelID>
    <Title>Lazy load with IPersistentState</Title>
    <Description>There are a lot use cases when lazy load is preffered way to load the grain state. Will be very helpfull to have ability to configure the using of IPersistentState with lazy manner. Maybe to define new interface IDefferPersistentState or ILazyPersistentState</Description>
    <Title_Description>Lazy load with IPersistentState There are a lot use cases when lazy load is preffered way to load the grain state. Will be very helpfull to have ability to configure the using of IPersistentState with lazy manner. Maybe to define new interface IDefferPersistentState or ILazyPersistentState</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6087</IssueLabelID>
    <Title>Rationale for StorageProvider attribute on grain implementation?</Title>
    <Description>I'm wondering about the rationale behind grain implementations needing to specify `[StorageProvider(name)]` instead of making that a responsibility of the silo.

This coupling looks like a classic case of "leaky abstraction" although I'm still pretty new to Orleans. To me it would seem more natural to specify the provider at the same point in silo setup where `ConfigureApplicationParts` is called (which I realize is used by Orleans but not part of it). The silo controls every other aspect of storage so to me "where to store each grain" seems like a natural fit as well.

I'm curious if I'm overlooking some benefit to this design and whether there might be interest in changing it (perhaps while still supporting the attribute for backwards compatibility).</Description>
    <Title_Description>Rationale for StorageProvider attribute on grain implementation? I'm wondering about the rationale behind grain implementations needing to specify `[StorageProvider(name)]` instead of making that a responsibility of the silo.

This coupling looks like a classic case of "leaky abstraction" although I'm still pretty new to Orleans. To me it would seem more natural to specify the provider at the same point in silo setup where `ConfigureApplicationParts` is called (which I realize is used by Orleans but not part of it). The silo controls every other aspect of storage so to me "where to store each grain" seems like a natural fit as well.

I'm curious if I'm overlooking some benefit to this design and whether there might be interest in changing it (perhaps while still supporting the attribute for backwards compatibility).</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6085</IssueLabelID>
    <Title>Saving references to Other grains</Title>
    <Description>Hey

I've trying out Orleans for some simple projects to get my head around.
I'd like to ask if this is an Orleans way to approach things.

I have Player and player can have multiple inventories (which in turn store multiple items).
Right now I have Player Grain and Inventory Grain. Player Grain can reference multiple Inventory grains.

1. Should I store Inventory Grains IDs inside PlayerState ?
2. Can I just store Inventory References inside PlayerState and will they be automatically serialized ?
3. Should I simply put everything into single grain (Player) ?
</Description>
    <Title_Description>Saving references to Other grains Hey

I've trying out Orleans for some simple projects to get my head around.
I'd like to ask if this is an Orleans way to approach things.

I have Player and player can have multiple inventories (which in turn store multiple items).
Right now I have Player Grain and Inventory Grain. Player Grain can reference multiple Inventory grains.

1. Should I store Inventory Grains IDs inside PlayerState ?
2. Can I just store Inventory References inside PlayerState and will they be automatically serialized ?
3. Should I simply put everything into single grain (Player) ?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6084</IssueLabelID>
    <Title>Null IIncomingGrainCallContext.ImplementationMethod when using ValueTuples</Title>
    <Description>Orleans version: 2.3.2

When using the following signature for a grain method

`public Task Method(List&lt;(int Foo Guid Bar)&gt; valueTupleList)`

it results in a null value for the `ImplementationMethod` and `InterfaceMethod` in `IIncomingGrainCallContext`  to be null.

When the signature is changed to

`public Task Method(List&lt;KeyValuePair&lt;int Guid&gt;&gt; valueTupleList)`

The context is fixed and works as expected.</Description>
    <Title_Description>Null IIncomingGrainCallContext.ImplementationMethod when using ValueTuples Orleans version: 2.3.2

When using the following signature for a grain method

`public Task Method(List&lt;(int Foo Guid Bar)&gt; valueTupleList)`

it results in a null value for the `ImplementationMethod` and `InterfaceMethod` in `IIncomingGrainCallContext`  to be null.

When the signature is changed to

`public Task Method(List&lt;KeyValuePair&lt;int Guid&gt;&gt; valueTupleList)`

The context is fixed and works as expected.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6077</IssueLabelID>
    <Title>Clustering audit log</Title>
    <Description>Hi

I would like to open a discussion:

For me the clustering is sometimes hard to understand and it would be very good to have some kind of an audit log like in kubernetes with high level messages that tell me the status of the cluster such as:

* Member &lt;Hostname&gt; (IP) has joined the cluster.
* Member &lt;Hostname&gt; (IP) is not reachable from &lt;Hostname&gt; (IP) &lt;HostName&gt; (IP) and ...

This could be very valuable because reading the logs can be hard and in case of cluster errors you can have thousand of consecutive errors that you need to filter out.

Just this morning my k8 has restarted my nodes because the health check became unhealthy and do not really understand the reason.

It would be great to have a IAuditLog interface that just logs it to the logger but can also be used to persist it to a database and then consumed by OrleansDashboard or so.

In case you are writing a product for others users like Squidex (https://github.com/squidex/squidex) it is hard to get good default values for the logs. Either it is too much or too less.

Or we need to be more careful with logging categories because class names are not a good source for categories especially when potentially dozens of classes are involved to do a job like clustering.

To be honest I have no idea what something like this means:

     Silo S10.0.0.22:11111:309992883 is rejecting message: Request S10.0.0.22:11111:309992883*stg/13/0000000d@S0000000d-&gt;S10.0.2.132:11111:309992903*stg/10/0000000a@S0000000a #1069522: . Reason = Recent (00:00:00.0755821 ago at 2019-10-30 06:20:30.534 GMT) connection failure trying to reach target silo S10.0.2.132:11111:309992903. Going to drop Request msg 1069522 without sending. CONNECTION_RETRY_DELAY = 00:00:01.


</Description>
    <Title_Description>Clustering audit log Hi

I would like to open a discussion:

For me the clustering is sometimes hard to understand and it would be very good to have some kind of an audit log like in kubernetes with high level messages that tell me the status of the cluster such as:

* Member &lt;Hostname&gt; (IP) has joined the cluster.
* Member &lt;Hostname&gt; (IP) is not reachable from &lt;Hostname&gt; (IP) &lt;HostName&gt; (IP) and ...

This could be very valuable because reading the logs can be hard and in case of cluster errors you can have thousand of consecutive errors that you need to filter out.

Just this morning my k8 has restarted my nodes because the health check became unhealthy and do not really understand the reason.

It would be great to have a IAuditLog interface that just logs it to the logger but can also be used to persist it to a database and then consumed by OrleansDashboard or so.

In case you are writing a product for others users like Squidex (https://github.com/squidex/squidex) it is hard to get good default values for the logs. Either it is too much or too less.

Or we need to be more careful with logging categories because class names are not a good source for categories especially when potentially dozens of classes are involved to do a job like clustering.

To be honest I have no idea what something like this means:

     Silo S10.0.0.22:11111:309992883 is rejecting message: Request S10.0.0.22:11111:309992883*stg/13/0000000d@S0000000d-&gt;S10.0.2.132:11111:309992903*stg/10/0000000a@S0000000a #1069522: . Reason = Recent (00:00:00.0755821 ago at 2019-10-30 06:20:30.534 GMT) connection failure trying to reach target silo S10.0.2.132:11111:309992903. Going to drop Request msg 1069522 without sending. CONNECTION_RETRY_DELAY = 00:00:01.


</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6076</IssueLabelID>
    <Title>Upgrade to Orleans 3.0 from 2.* seems to incur performance issues</Title>
    <Description>An upgrade from 2 to 3.0 seems to make performance worse in two ways:

- The average request time is higher than before
- There are "odd spikes" that go from what would normally be 5ms-20ms to 500ms-1000ms. These seem to not be related to external dependencies

This is running on alpine nightly with dotnet core 3.0 running on AKS.

Screenshot of normal operations:

![normal](https://user-images.githubusercontent.com/5766347/67874630-7a960000-fb35-11e9-9d90-ddeaefeab405.png)

This is the kind of peaks we are experiencing now:

![peaks](https://user-images.githubusercontent.com/5766347/67874663-85509500-fb35-11e9-8601-93eb9c29e659.png)

Information about the system: 

- Load is not high (sub 1 transaction a second)
- Load is very even re-using the same grains
- Backend database has been scaled up but we still have issues
</Description>
    <Title_Description>Upgrade to Orleans 3.0 from 2.* seems to incur performance issues An upgrade from 2 to 3.0 seems to make performance worse in two ways:

- The average request time is higher than before
- There are "odd spikes" that go from what would normally be 5ms-20ms to 500ms-1000ms. These seem to not be related to external dependencies

This is running on alpine nightly with dotnet core 3.0 running on AKS.

Screenshot of normal operations:

![normal](https://user-images.githubusercontent.com/5766347/67874630-7a960000-fb35-11e9-9d90-ddeaefeab405.png)

This is the kind of peaks we are experiencing now:

![peaks](https://user-images.githubusercontent.com/5766347/67874663-85509500-fb35-11e9-8601-93eb9c29e659.png)

Information about the system: 

- Load is not high (sub 1 transaction a second)
- Load is very even re-using the same grains
- Backend database has been scaled up but we still have issues
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6075</IssueLabelID>
    <Title>[doc] Multiple language support</Title>
    <Description>I want to translate the docs to Chinese How can I start?
I prefer add some language identifier folders (en-us zh-cn and so on) to place the translated docs.
</Description>
    <Title_Description>[doc] Multiple language support I want to translate the docs to Chinese How can I start?
I prefer add some language identifier folders (en-us zh-cn and so on) to place the translated docs.
</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/10/2019 11:45:34 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6073</IssueLabelID>
    <Title>error NETSDK1085 when creating package using dotnet cli 3.0.100</Title>
    <Description>After updating `dotnet` tools to 3.0.100 creation of NuGet packages started to fail.

Looks like behavior might have changed in dotnet 3.* as compared to 2.* ([see changes](https://github.com/dotnet/sdk/commit/af4fc22af555a2cc647dc533436e764759ad827f)) and now 
`Microsoft.Orleans.CodeGenerator.MSBuild` violates `NoBuild` constraint. I believe this behavior is the same for 2.4.* and 3.0.* of `Microsoft.Orleans.CodeGenerator.MSBuild`.

#### Command: 
```powershell
dotnet pack --no-build .\Grains.Interfaces\Grains.Interfaces.csproj
```
#### Expected 
New NuGet package is created:
```powershell
Successfully created package '*********REDACTED*********\Grains.Interfaces\bin\Debug\Grains.Interfaces.1.0.0.nupkg'.
```
#### Actual
Error is thrown:
```powershell
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.targets(1335): error NETSDK1085: The 'NoBuild' property was set to true but the 'Build' target was invoked. [*********REDACTED*********\Grains.Models\Grains.Models.csproj]
```

### Setup
I was able to reproduce issue by crating a simple project:
- `Grains.Interfaces.csproj` - contains one interface `ITestGrain : IGrainWithStringKey` with a single method `Task&lt;int&gt; CreateAsync(TestModel testModel);`
- `TestModel` is a POCO defined in `Grains.Models.csproj`
- `Grains.Interfaces.csproj` has reference to  `Grains.Models.csproj` and following NuGet configuration:
```xml
&lt;PackageReference Include="Microsoft.Orleans.CodeGenerator.MSBuild" Version="2.4.3"&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
&lt;/PackageReference&gt;
&lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.4.3" /&gt;
&lt;PackageReference Include="Microsoft.Orleans.Core.Abstractions" Version="2.4.3" /&gt;
```</Description>
    <Title_Description>error NETSDK1085 when creating package using dotnet cli 3.0.100 After updating `dotnet` tools to 3.0.100 creation of NuGet packages started to fail.

Looks like behavior might have changed in dotnet 3.* as compared to 2.* ([see changes](https://github.com/dotnet/sdk/commit/af4fc22af555a2cc647dc533436e764759ad827f)) and now 
`Microsoft.Orleans.CodeGenerator.MSBuild` violates `NoBuild` constraint. I believe this behavior is the same for 2.4.* and 3.0.* of `Microsoft.Orleans.CodeGenerator.MSBuild`.

#### Command: 
```powershell
dotnet pack --no-build .\Grains.Interfaces\Grains.Interfaces.csproj
```
#### Expected 
New NuGet package is created:
```powershell
Successfully created package '*********REDACTED*********\Grains.Interfaces\bin\Debug\Grains.Interfaces.1.0.0.nupkg'.
```
#### Actual
Error is thrown:
```powershell
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.targets(1335): error NETSDK1085: The 'NoBuild' property was set to true but the 'Build' target was invoked. [*********REDACTED*********\Grains.Models\Grains.Models.csproj]
```

### Setup
I was able to reproduce issue by crating a simple project:
- `Grains.Interfaces.csproj` - contains one interface `ITestGrain : IGrainWithStringKey` with a single method `Task&lt;int&gt; CreateAsync(TestModel testModel);`
- `TestModel` is a POCO defined in `Grains.Models.csproj`
- `Grains.Interfaces.csproj` has reference to  `Grains.Models.csproj` and following NuGet configuration:
```xml
&lt;PackageReference Include="Microsoft.Orleans.CodeGenerator.MSBuild" Version="2.4.3"&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
&lt;/PackageReference&gt;
&lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.4.3" /&gt;
&lt;PackageReference Include="Microsoft.Orleans.Core.Abstractions" Version="2.4.3" /&gt;
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6072</IssueLabelID>
    <Title>Removed silo status check before cleaing up system targets from…</Title>
    <Description>Original code assumed producers only moved when their silo died.  This is not the case.</Description>
    <Title_Description>Removed silo status check before cleaing up system targets from… Original code assumed producers only moved when their silo died.  This is not the case.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6071</IssueLabelID>
    <Title>Azure table grain storage inconsistent state on not found</Title>
    <Description>Azure table grain storage returns inconsistent state if modifying state that does not exist.</Description>
    <Title_Description>Azure table grain storage inconsistent state on not found Azure table grain storage returns inconsistent state if modifying state that does not exist.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6070</IssueLabelID>
    <Title>Switch to System.Text.Json APIs</Title>
    <Description>The new [System.Text.Json](https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis/) API's provide a slight performance boost over Newtonsoft.Json and I believe the gap will get wider with further releases. This boost is even more prevalant if you serialize directly to and from UTF-8 bytes.

Are there any plans to migrate to this as the new default and possible enable the ability to switch between the two formats like in ASP.NET Core?</Description>
    <Title_Description>Switch to System.Text.Json APIs The new [System.Text.Json](https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-apis/) API's provide a slight performance boost over Newtonsoft.Json and I believe the gap will get wider with further releases. This boost is even more prevalant if you serialize directly to and from UTF-8 bytes.

Are there any plans to migrate to this as the new default and possible enable the ability to switch between the two formats like in ASP.NET Core?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6067</IssueLabelID>
    <Title>Nullable warning in generated code.</Title>
    <Description>Hi

I get the following warning in the *.g.cs files:

```
warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
```

Could you disable it? It is enabled for the whole project.</Description>
    <Title_Description>Nullable warning in generated code. Hi

I get the following warning in the *.g.cs files:

```
warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
```

Could you disable it? It is enabled for the whole project.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6065</IssueLabelID>
    <Title>Clean up docs for 3.0</Title>
    <Description>
    </Description>
    <Title_Description>Clean up docs for 3.0 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6060</IssueLabelID>
    <Title>Update README</Title>
    <Description>
    </Description>
    <Title_Description>Update README </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6057</IssueLabelID>
    <Title>Improved activation queue monitoring</Title>
    <Description>- Added load stages to prevent spamming logs under load.
- Added max lifetime and spike high load metrics</Description>
    <Title_Description>Improved activation queue monitoring - Added load stages to prevent spamming logs under load.
- Added max lifetime and spike high load metrics</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6053</IssueLabelID>
    <Title>Added consistent logging for all messages dropped due to expiry</Title>
    <Description>
    </Description>
    <Title_Description>Added consistent logging for all messages dropped due to expiry </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6052</IssueLabelID>
    <Title>sending per grain info to storage system when saving</Title>
    <Description>When I was trying to implement a playfab based storage system for grains and also previously when I wanted to make some settings per grain (not per grain type) in a storage provider to save my data in a different manner the storage system couldn't do that.

Let's say we have a set of player grains.  
Also assume that for saving data for each user in playfab you need the user's ID which the grain has at runtime and it cannot be deduced from grain key how can we send this info to our storage provider when we initialize the grain/when calling WriteStateAsync so the provider can do its job? 

One easy/dirty way of solving it is to have an object argument for WriteStateAsync and ReadStateAsync but probably it can be done better.

@sergeybykov  @ReubenBond  I saw you were looking for feedback for Orleans 3 probably this is late for that but I hope still is useful</Description>
    <Title_Description>sending per grain info to storage system when saving When I was trying to implement a playfab based storage system for grains and also previously when I wanted to make some settings per grain (not per grain type) in a storage provider to save my data in a different manner the storage system couldn't do that.

Let's say we have a set of player grains.  
Also assume that for saving data for each user in playfab you need the user's ID which the grain has at runtime and it cannot be deduced from grain key how can we send this info to our storage provider when we initialize the grain/when calling WriteStateAsync so the provider can do its job? 

One easy/dirty way of solving it is to have an object argument for WriteStateAsync and ReadStateAsync but probably it can be done better.

@sergeybykov  @ReubenBond  I saw you were looking for feedback for Orleans 3 probably this is late for that but I hope still is useful</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6051</IssueLabelID>
    <Title>Recommendation on Grain ID creation</Title>
    <Description>We are using Orleans and have a need to map Grains backing storage to a relational table structure that will be ad-hoc queried using SQL. The tables will have auto incremented ID's controlled defined by the table.

My question is how would you recommend creating these grains because GrainFactory.GetGrain&lt;T&gt;(..) requires an ID but we don't know the ID until we have saved the record into the database. </Description>
    <Title_Description>Recommendation on Grain ID creation We are using Orleans and have a need to map Grains backing storage to a relational table structure that will be ad-hoc queried using SQL. The tables will have auto incremented ID's controlled defined by the table.

My question is how would you recommend creating these grains because GrainFactory.GetGrain&lt;T&gt;(..) requires an ID but we don't know the ID until we have saved the record into the database. </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6050</IssueLabelID>
    <Title>Update change log for 3.0.0-rc2</Title>
    <Description>
    </Description>
    <Title_Description>Update change log for 3.0.0-rc2 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6049</IssueLabelID>
    <Title>Remove SQL scripts from AdoNet NuGet packages</Title>
    <Description>Based on the discussion in #4867 this PR is a replacement for #6044. It removes SQL scripts from the AdoNet provider packages. The prevailing opinion is that we shouldn't have them pollute the AdoNet packages and that we don't even want a readme.md there.

We can separately decide how to let developers know where to find the scripts.</Description>
    <Title_Description>Remove SQL scripts from AdoNet NuGet packages Based on the discussion in #4867 this PR is a replacement for #6044. It removes SQL scripts from the AdoNet provider packages. The prevailing opinion is that we shouldn't have them pollute the AdoNet packages and that we don't even want a readme.md there.

We can separately decide how to let developers know where to find the scripts.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6047</IssueLabelID>
    <Title>Transactions: support larger state sizes in Azure Table Storage</Title>
    <Description>This implementation retains backwards compatibility with existing stored data while adding support for states which are too large to fit into a single Azure Table Storage column (which holds a maximum of 32 * 1024 chars)</Description>
    <Title_Description>Transactions: support larger state sizes in Azure Table Storage This implementation retains backwards compatibility with existing stored data while adding support for states which are too large to fit into a single Azure Table Storage column (which holds a maximum of 32 * 1024 chars)</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6046</IssueLabelID>
    <Title>Add separate SiloMessagingOptions.SystemResponseTimeout option</Title>
    <Description>This PR adds an option to set the response timeout for `SystemTarget` messages sent from a silo. The default value is 30s but in future that may be changed to a lower value such as 2s.</Description>
    <Title_Description>Add separate SiloMessagingOptions.SystemResponseTimeout option This PR adds an option to set the response timeout for `SystemTarget` messages sent from a silo. The default value is 30s but in future that may be changed to a lower value such as 2s.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6045</IssueLabelID>
    <Title>Added structured logging</Title>
    <Description>Implemented structured logging (see #5865) for the project OrleansProviders. Doing it project by project makes it a bit more manageable than to do the whole lot in one changeset.</Description>
    <Title_Description>Added structured logging Implemented structured logging (see #5865) for the project OrleansProviders. Doing it project by project makes it a bit more manageable than to do the whole lot in one changeset.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6041</IssueLabelID>
    <Title>Add warning message at startup</Title>
    <Description>Adding warning message at startup if debug level logging is set and recommends setting log level to info for production.

Addresses #5873 </Description>
    <Title_Description>Add warning message at startup Adding warning message at startup if debug level logging is set and recommends setting log level to info for production.

Addresses #5873 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6040</IssueLabelID>
    <Title>Orleans + ASP.NET co-hosting can cause NullReferenceException in ASP.NET</Title>
    <Description>This is specific to Orleans 3.0-rc1.

Currently both Orleans &amp; Kestrel register an implementation for `IConnectionListenerFactory`. Both have different requirements of the created ConnectionContexts however and so when they are both configured on the same `IHostBuilder`/container we can observe `NullReferenceException`s from ASP.NET. Registering them in the reverse order would likely cause similar issues in Orleans.

Example:

``` C#
Host.CreateDefaultBuilder(args)
    .UseOrleans((context builder) =&gt;
    {
        builder
            .Configure&lt;SiloMessagingOptions&gt;(opts =&gt;
            {
                opts.PropagateActivityId = true;
            })
            .UseLocalhostClustering()
            .AddMemoryGrainStorageAsDefault();
    })
    .ConfigureWebHostDefaults(webBuilder =&gt;
    {
        webBuilder.UseStartup&lt;Startup&gt;();
    });
```

Kestrel registers an implementation here: https://github.com/aspnet/AspNetCore/blob/00e0b97466a3aa7e535b1e34fb04c11f5970fb28/src/Servers/Kestrel/Kestrel/src/WebHostBuilderKestrelExtensions.cs#L32

Orleans registers an implementation here: https://github.com/dotnet/orleans/blob/e816f02f12df34e9e554ae2b898528c42d9d87a4/src/Orleans.Runtime/Hosting/DefaultSiloServices.cs#L355

We can change our registration to disambiguate it from Kestrel's but issues may occur with other users of these abstractions. I imagine the problem would also exist with `IConnectionFactory` (eg maybe Orleans + SignalR).

cc @davidfowl</Description>
    <Title_Description>Orleans + ASP.NET co-hosting can cause NullReferenceException in ASP.NET This is specific to Orleans 3.0-rc1.

Currently both Orleans &amp; Kestrel register an implementation for `IConnectionListenerFactory`. Both have different requirements of the created ConnectionContexts however and so when they are both configured on the same `IHostBuilder`/container we can observe `NullReferenceException`s from ASP.NET. Registering them in the reverse order would likely cause similar issues in Orleans.

Example:

``` C#
Host.CreateDefaultBuilder(args)
    .UseOrleans((context builder) =&gt;
    {
        builder
            .Configure&lt;SiloMessagingOptions&gt;(opts =&gt;
            {
                opts.PropagateActivityId = true;
            })
            .UseLocalhostClustering()
            .AddMemoryGrainStorageAsDefault();
    })
    .ConfigureWebHostDefaults(webBuilder =&gt;
    {
        webBuilder.UseStartup&lt;Startup&gt;();
    });
```

Kestrel registers an implementation here: https://github.com/aspnet/AspNetCore/blob/00e0b97466a3aa7e535b1e34fb04c11f5970fb28/src/Servers/Kestrel/Kestrel/src/WebHostBuilderKestrelExtensions.cs#L32

Orleans registers an implementation here: https://github.com/dotnet/orleans/blob/e816f02f12df34e9e554ae2b898528c42d9d87a4/src/Orleans.Runtime/Hosting/DefaultSiloServices.cs#L355

We can change our registration to disambiguate it from Kestrel's but issues may occur with other users of these abstractions. I imagine the problem would also exist with `IConnectionFactory` (eg maybe Orleans + SignalR).

cc @davidfowl</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6038</IssueLabelID>
    <Title> Response did not arrive on time in 00:00:30 for message:System.TimeoutException</Title>
    <Description>Recently I have upgraded orleans from 1.5 to 2.4.1 and after that I have started seeing the exceptions related to TimeOut. 
Response did not arrive on time in 00:00:30 for message: Request *cli/413a36bd@01e05ea7-&gt;S:30000:308414169*grn/8A760B57/afd82dad #15058: . Target History is: &lt;S:30000:308414169:*grn/8A760B57/afd82dad:&gt;. 

Full StackTrace:

&gt;System.TimeoutException:
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.OrleansTaskExtentions+&lt;&lt;ToTypedTask&gt;g__ConvertAsync|4_0&gt;d`1.MoveNext (Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=nullOrleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null: D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.csOrleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null: 101)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Threading.Tasks.TaskHelpersExtensions+&lt;CastToObject&gt;d__3`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Tracing.ITraceWriterExtensions+&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ApiControllerActionInvoker+&lt;InvokeActionAsyncCore&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Tracing.ITraceWriterExtensions+&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ActionFilterResult+&lt;ExecuteAsync&gt;d__2.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.AuthorizationFilterAttribute+&lt;ExecuteAuthorizationFilterAsyncCore&gt;d__2.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ExceptionFilterResult+&lt;ExecuteAsync&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
</Description>
    <Title_Description> Response did not arrive on time in 00:00:30 for message:System.TimeoutException Recently I have upgraded orleans from 1.5 to 2.4.1 and after that I have started seeing the exceptions related to TimeOut. 
Response did not arrive on time in 00:00:30 for message: Request *cli/413a36bd@01e05ea7-&gt;S:30000:308414169*grn/8A760B57/afd82dad #15058: . Target History is: &lt;S:30000:308414169:*grn/8A760B57/afd82dad:&gt;. 

Full StackTrace:

&gt;System.TimeoutException:
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.OrleansTaskExtentions+&lt;&lt;ToTypedTask&gt;g__ConvertAsync|4_0&gt;d`1.MoveNext (Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=nullOrleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null: D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.csOrleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null: 101)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Threading.Tasks.TaskHelpersExtensions+&lt;CastToObject&gt;d__3`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Tracing.ITraceWriterExtensions+&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ApiControllerActionInvoker+&lt;InvokeActionAsyncCore&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Tracing.ITraceWriterExtensions+&lt;TraceBeginEndAsyncCore&gt;d__18`1.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;CallOnActionExecutedAsync&gt;d__5.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.ActionFilterAttribute+&lt;ExecuteActionFilterAsyncCore&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ActionFilterResult+&lt;ExecuteAsync&gt;d__2.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Filters.AuthorizationFilterAttribute+&lt;ExecuteAuthorizationFilterAsyncCore&gt;d__2.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Web.Http.Controllers.ExceptionFilterResult+&lt;ExecuteAsync&gt;d__0.MoveNext (System.Web.Http Version=5.2.3.0 Culture=neutral PublicKeyToken=31bf3856ad364e35)
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6036</IssueLabelID>
    <Title>NullReferenceException when calling GetReminder or GetReminders</Title>
    <Description>### Environment
**Affects:** 3.0.0-rc1
**Worked in:** 2.x
**Additional:** Uses the AdoNet reminder provider

### Reproduction:
1. Create a `Grain` who has the following:
```csharp
public override async Task OnActivateAsync()
        {   
            var reminder = await this.GetReminder(this.GetPrimaryKeyString());

            if (reminder == default)
            {
                await this.RegisterOrUpdateReminder(
                        this.GetPrimaryKeyString()
                        TimeSpan.FromMinutes(1)
                        TimeSpan.FromMinutes(5);
            }

            await base.OnActivateAsync();
        }
```
2. Create a `StartUpTask` that kicks the grain

### Expected:
Silo starts up with no problems reminder is created in the table.

### Actual:
Silo fails to start up with the following stack trace:
```
fail: Orleans.Runtime.Silo[100439]
      Exception during Silo.Start
System.NullReferenceException: Object reference not set to an instance of an object.

Server stack trace:
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.ReadRow(GrainReference grainRef String reminderName)
   at Orleans.Runtime.ReminderService.LocalReminderService.&lt;GetReminder&gt;d__20.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
&lt;snip/&gt;
```

Even with a reminder in the database there's still a `NullReferenceException` thrown:

ServiceId|GrainId|ReminderName|StartTime|Period|GrainHash|Version
----------|--------|-----------------|-----------|-------|-----------|--------
ClusterSample|GrainReference=00000000000000000000000000000000060000005ef5182d+Supervisor|Supervisor|2019-10-10 18:29:54.790|60000|1504553235|0

### Workaround
Changing the code so that it doesn't check for an existing reminder with `GetReminder` or `GetReminders` and instead calls `RegisterOrUpdateReminder` every time works without issue.</Description>
    <Title_Description>NullReferenceException when calling GetReminder or GetReminders ### Environment
**Affects:** 3.0.0-rc1
**Worked in:** 2.x
**Additional:** Uses the AdoNet reminder provider

### Reproduction:
1. Create a `Grain` who has the following:
```csharp
public override async Task OnActivateAsync()
        {   
            var reminder = await this.GetReminder(this.GetPrimaryKeyString());

            if (reminder == default)
            {
                await this.RegisterOrUpdateReminder(
                        this.GetPrimaryKeyString()
                        TimeSpan.FromMinutes(1)
                        TimeSpan.FromMinutes(5);
            }

            await base.OnActivateAsync();
        }
```
2. Create a `StartUpTask` that kicks the grain

### Expected:
Silo starts up with no problems reminder is created in the table.

### Actual:
Silo fails to start up with the following stack trace:
```
fail: Orleans.Runtime.Silo[100439]
      Exception during Silo.Start
System.NullReferenceException: Object reference not set to an instance of an object.

Server stack trace:
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.ReadRow(GrainReference grainRef String reminderName)
   at Orleans.Runtime.ReminderService.LocalReminderService.&lt;GetReminder&gt;d__20.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
&lt;snip/&gt;
```

Even with a reminder in the database there's still a `NullReferenceException` thrown:

ServiceId|GrainId|ReminderName|StartTime|Period|GrainHash|Version
----------|--------|-----------------|-----------|-------|-----------|--------
ClusterSample|GrainReference=00000000000000000000000000000000060000005ef5182d+Supervisor|Supervisor|2019-10-10 18:29:54.790|60000|1504553235|0

### Workaround
Changing the code so that it doesn't check for an existing reminder with `GetReminder` or `GetReminders` and instead calls `RegisterOrUpdateReminder` every time works without issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6033</IssueLabelID>
    <Title>Timeout exception using SMS as streaming provider</Title>
    <Description>Hi there

I am writing a turn-based game I have a GameGrain PlayerGrain and LiveUpdateGrain the GameGrain I use `RegisterTimer` to check game status for every seconds and the method will call all PlayerGrain to get latest player's state. LiveUpdateGrain is an `ImplicitStreamSubscription` to consume and also produce new events from same stream.

pseudo code:

```c#
public class GameGrain : Grain&lt;GameState&gt; IGameGrain {

    public override async Task OnActivateAsync() {
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(State.StreamId Constants.GameEventStreamNameSpace);
        players = GetUsers().Select(x =&gt; GrainFactory.GetGrain&lt;IPlayerGrain&gt;(x));
        await Task.WhenAll(players.Select(x =&gt; x.BindToStream(stream.Guid)));
        await CheckGameStatus();
        RegisterTimer(CheckGameStateTimer null TimeSpan.FromSeconds(1) TimeSpan.FromSeconds(1));
    }

    private async Task CheckGameStateTimer(object _)
    {
        await Task.Run(() =&gt; this.AsReference&lt;IGameGrain&gt;().CheckGameState());
    }

    public async Task CheckGameState()
    {
        var results = await Task.WhenAll(players.Select(x =&gt; x.IsCompleted()));
        State.Completed = results.All(x =&gt; x);
        await WriteStateAsync();
        if (State.Completed)
        {
            var playerStates = await Task.WhenAll(players.Select(x =&gt; x.GetState()));
            stream.OnNextAsync(new Completed { PlayerStates = playerStates }).Ignore();
        }
    }
}

public class PlayerGrain : Grain&lt;PlayerState&gt; IPlayerGrain {

    public async Task BindToStream(Guid streamId)
    {
        State.StreamId = streamId;
        await WriteStateAsync();
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(streamId Constants.GameEventStreamNameSpace);
    }

    public Task&lt;bool&gt; IsCompleted() {
        return Task.FromResult(State.IsCompleted);
    }

    public Task&lt;PlayerState&gt; GetState() {
        return Task.FromResult(PlayerState);
    }

    // Call from client directly
    public Task SomeAction() {
        stream.OnNextAsync(new SomeAction{ PlayerId = PlayerState.Id });
    }
}

[ImplicitStreamSubscription(Constants.GameEventStreamNameSpace)]
public class LiveUpdateGrain : Grain ILiveUpdateGrain
{
    public override async Task OnActivateAsync()
    {
        var streamId = this.GetPrimaryKey();
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(streamId Constants.GameEventStreamNameSpace);
        subscription = await stream.SubscribeAsync(OnNext OnError OnCompleted);
        RegisterTimer(UpdateGameState null TimeSpan.FromSeconds(1) TimeSpan.FromSeconds(1));
    }

    private Task UpdateGameState(object arg)
    {
        if (!state.IsCompleted)
        {
            // just some live update data
            stream.OnNextAsync(new LiveUpdate {  }).Ignore();
        }
        return Task.CompletedTask;
    }

    public override async Task OnDeactivateAsync()
    {
        await subscription.UnsubscribeAsync();
    }

    private Task OnCompleted()
    { return Task.CompletedTask; }

    private Task OnError(Exception ex)
    { return Task.CompletedTask; }

    private async Task OnNext(IEvent evt StreamSequenceToken token = null)
    {
        // some logic to handle game events
    }
}

```

WebApi + Signalr Hub
```c#
public override async Task OnConnectedAsync()
{
    var stream = streamProvider.GetStream&lt;IEvent&gt;(streamId NameSpace);
    var subscriptionHandles = await stream.GetAllSubscriptionHandles();
    if (subscriptionHandles != null &amp;&amp; subscriptionHandles.Any())
    {
        foreach (var x in subscriptionHandles)
        {
            await x.ResumeAsync(CreateEventObserver());
        }
    } else {
        var subscription = await stream.SubscribeAsync(CreateEventObserver());
        Context.Items.Add("subscription" subscription);   
    }
    await base.OnConnectedAsync();
}

public override async Task OnDisconnectedAsync(Exception exception)
{
    if (Context.Items.TryGetValue("subscription" out var subscription))
    {
        await (subscription as StreamSubscriptionHandle&lt;IEvent&gt;).UnsubscribeAsync();
    }
    await base.OnDisconnectedAsync(exception);
}
```

somehow I encounter timeout exception
message
```
Response did not arrive on time in 00:00:30 for message: Request S172.21.0.3:10000:308151601*grn/424C7040/00000000+4@@@2@df6c3e8a-&gt;S172.21.0.3:10000:308151601*grn/716E8E94/853792b5+GameEventStreamProvider@0fb6f3ab #7035583: . Target History is: &lt;S172.21.0.3:10000:308151601:*grn/716E8E94/853792b5+GameEventStreamProvider:@0fb6f3ab&gt;.
```

failed method
```
Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1+&lt;Cleanup&gt;d__29.MoveNext
```

formatted message
```
Ignoring unhandled exception during PubSub.UnregisterProducer
```

category
```
Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer
```

Call stack
```
System.TimeoutException:
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamPr
```

Do I have something wrong in the code?



</Description>
    <Title_Description>Timeout exception using SMS as streaming provider Hi there

I am writing a turn-based game I have a GameGrain PlayerGrain and LiveUpdateGrain the GameGrain I use `RegisterTimer` to check game status for every seconds and the method will call all PlayerGrain to get latest player's state. LiveUpdateGrain is an `ImplicitStreamSubscription` to consume and also produce new events from same stream.

pseudo code:

```c#
public class GameGrain : Grain&lt;GameState&gt; IGameGrain {

    public override async Task OnActivateAsync() {
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(State.StreamId Constants.GameEventStreamNameSpace);
        players = GetUsers().Select(x =&gt; GrainFactory.GetGrain&lt;IPlayerGrain&gt;(x));
        await Task.WhenAll(players.Select(x =&gt; x.BindToStream(stream.Guid)));
        await CheckGameStatus();
        RegisterTimer(CheckGameStateTimer null TimeSpan.FromSeconds(1) TimeSpan.FromSeconds(1));
    }

    private async Task CheckGameStateTimer(object _)
    {
        await Task.Run(() =&gt; this.AsReference&lt;IGameGrain&gt;().CheckGameState());
    }

    public async Task CheckGameState()
    {
        var results = await Task.WhenAll(players.Select(x =&gt; x.IsCompleted()));
        State.Completed = results.All(x =&gt; x);
        await WriteStateAsync();
        if (State.Completed)
        {
            var playerStates = await Task.WhenAll(players.Select(x =&gt; x.GetState()));
            stream.OnNextAsync(new Completed { PlayerStates = playerStates }).Ignore();
        }
    }
}

public class PlayerGrain : Grain&lt;PlayerState&gt; IPlayerGrain {

    public async Task BindToStream(Guid streamId)
    {
        State.StreamId = streamId;
        await WriteStateAsync();
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(streamId Constants.GameEventStreamNameSpace);
    }

    public Task&lt;bool&gt; IsCompleted() {
        return Task.FromResult(State.IsCompleted);
    }

    public Task&lt;PlayerState&gt; GetState() {
        return Task.FromResult(PlayerState);
    }

    // Call from client directly
    public Task SomeAction() {
        stream.OnNextAsync(new SomeAction{ PlayerId = PlayerState.Id });
    }
}

[ImplicitStreamSubscription(Constants.GameEventStreamNameSpace)]
public class LiveUpdateGrain : Grain ILiveUpdateGrain
{
    public override async Task OnActivateAsync()
    {
        var streamId = this.GetPrimaryKey();
        var streamProvider = GetStreamProvider(Constants.GameEventStreamProvider);
        stream = streamProvider.GetStream&lt;IEvent&gt;(streamId Constants.GameEventStreamNameSpace);
        subscription = await stream.SubscribeAsync(OnNext OnError OnCompleted);
        RegisterTimer(UpdateGameState null TimeSpan.FromSeconds(1) TimeSpan.FromSeconds(1));
    }

    private Task UpdateGameState(object arg)
    {
        if (!state.IsCompleted)
        {
            // just some live update data
            stream.OnNextAsync(new LiveUpdate {  }).Ignore();
        }
        return Task.CompletedTask;
    }

    public override async Task OnDeactivateAsync()
    {
        await subscription.UnsubscribeAsync();
    }

    private Task OnCompleted()
    { return Task.CompletedTask; }

    private Task OnError(Exception ex)
    { return Task.CompletedTask; }

    private async Task OnNext(IEvent evt StreamSequenceToken token = null)
    {
        // some logic to handle game events
    }
}

```

WebApi + Signalr Hub
```c#
public override async Task OnConnectedAsync()
{
    var stream = streamProvider.GetStream&lt;IEvent&gt;(streamId NameSpace);
    var subscriptionHandles = await stream.GetAllSubscriptionHandles();
    if (subscriptionHandles != null &amp;&amp; subscriptionHandles.Any())
    {
        foreach (var x in subscriptionHandles)
        {
            await x.ResumeAsync(CreateEventObserver());
        }
    } else {
        var subscription = await stream.SubscribeAsync(CreateEventObserver());
        Context.Items.Add("subscription" subscription);   
    }
    await base.OnConnectedAsync();
}

public override async Task OnDisconnectedAsync(Exception exception)
{
    if (Context.Items.TryGetValue("subscription" out var subscription))
    {
        await (subscription as StreamSubscriptionHandle&lt;IEvent&gt;).UnsubscribeAsync();
    }
    await base.OnDisconnectedAsync(exception);
}
```

somehow I encounter timeout exception
message
```
Response did not arrive on time in 00:00:30 for message: Request S172.21.0.3:10000:308151601*grn/424C7040/00000000+4@@@2@df6c3e8a-&gt;S172.21.0.3:10000:308151601*grn/716E8E94/853792b5+GameEventStreamProvider@0fb6f3ab #7035583: . Target History is: &lt;S172.21.0.3:10000:308151601:*grn/716E8E94/853792b5+GameEventStreamProvider:@0fb6f3ab&gt;.
```

failed method
```
Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1+&lt;Cleanup&gt;d__29.MoveNext
```

formatted message
```
Ignoring unhandled exception during PubSub.UnregisterProducer
```

category
```
Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer
```

Call stack
```
System.TimeoutException:
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamPr
```

Do I have something wrong in the code?



</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6029</IssueLabelID>
    <Title>Cherry-picked fixes from master for 2.4.3</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked fixes from master for 2.4.3 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6028</IssueLabelID>
    <Title>Could not load file or assembly 'Microsoft.Bcl.AsyncInterfaces Dependency missing in Orleans 3.0 RC1?</Title>
    <Description>I might be a bit quick to jump the gun but i wanted to try out orelans-3.0.0-RC1 after it got released. going from 3.0.0-Beta1 broke to me seems like Microsoft.Bcl.AsyncInterfaces is missing. 
got this error: 
```
Exception has occurred: CLR/System.IO.FileNotFoundException
An exception of type 'System.IO.FileNotFoundException' occurred in Orleans.Runtime.dll but was not handled in user code: 'Could not load file or assembly 'Microsoft.Bcl.AsyncInterfaces Version=1.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Det går inte att hitta filen.'
   at Orleans.Hosting.DefaultSiloServices.AddDefaultServices(IApplicationPartManager applicationPartManager IServiceCollection services)
   at Orleans.Hosting.CoreHostingExtensions.&lt;&gt;c.&lt;ConfigureDefaults&gt;b__6_0(HostBuilderContext context IServiceCollection services)
   at Orleans.Hosting.SiloBuilder.Build(HostBuilderContext context IServiceCollection serviceCollection)
   at Microsoft.Extensions.Hosting.GenericHostExtensions.&lt;&gt;c__DisplayClass0_0.&lt;UseOrleans&gt;b__0(HostBuilderContext context IServiceCollection services)
   at Microsoft.Extensions.Hosting.HostBuilder.CreateServiceProvider()
   at Microsoft.Extensions.Hosting.HostBuilder.Build()
   at TestOrleans.ServiceHost.Program.&lt;Main&gt;d__0.MoveNext() in E:\dev\orleans\TestOrleans.ServiceHost\Program.cs:line 18
```
installing it made it work however. Wanted to drop the info somewhere in case it got missing somewhere. Saw no info in the release notes about this</Description>
    <Title_Description>Could not load file or assembly 'Microsoft.Bcl.AsyncInterfaces, Dependency missing in Orleans 3.0 RC1? I might be a bit quick to jump the gun but i wanted to try out orelans-3.0.0-RC1 after it got released. going from 3.0.0-Beta1 broke to me seems like Microsoft.Bcl.AsyncInterfaces is missing. 
got this error: 
```
Exception has occurred: CLR/System.IO.FileNotFoundException
An exception of type 'System.IO.FileNotFoundException' occurred in Orleans.Runtime.dll but was not handled in user code: 'Could not load file or assembly 'Microsoft.Bcl.AsyncInterfaces Version=1.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Det går inte att hitta filen.'
   at Orleans.Hosting.DefaultSiloServices.AddDefaultServices(IApplicationPartManager applicationPartManager IServiceCollection services)
   at Orleans.Hosting.CoreHostingExtensions.&lt;&gt;c.&lt;ConfigureDefaults&gt;b__6_0(HostBuilderContext context IServiceCollection services)
   at Orleans.Hosting.SiloBuilder.Build(HostBuilderContext context IServiceCollection serviceCollection)
   at Microsoft.Extensions.Hosting.GenericHostExtensions.&lt;&gt;c__DisplayClass0_0.&lt;UseOrleans&gt;b__0(HostBuilderContext context IServiceCollection services)
   at Microsoft.Extensions.Hosting.HostBuilder.CreateServiceProvider()
   at Microsoft.Extensions.Hosting.HostBuilder.Build()
   at TestOrleans.ServiceHost.Program.&lt;Main&gt;d__0.MoveNext() in E:\dev\orleans\TestOrleans.ServiceHost\Program.cs:line 18
```
installing it made it work however. Wanted to drop the info somewhere in case it got missing somewhere. Saw no info in the release notes about this</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6027</IssueLabelID>
    <Title>Update release notes for 3.0.0-rc1</Title>
    <Description>
    </Description>
    <Title_Description>Update release notes for 3.0.0-rc1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6019</IssueLabelID>
    <Title>Fix AzureGossip_ConfigGossip to use UTC DateTime instead of local</Title>
    <Description>
    </Description>
    <Title_Description>Fix AzureGossip_ConfigGossip to use UTC DateTime instead of local </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6011</IssueLabelID>
    <Title>Configure task scheduler?</Title>
    <Description>Hi

is it possible to configure the task scheduler somehow? 

The problem is that under high load the system can become unresponsive but some of the tasks would have a higher priority than others e.g. the health checks have a high priority.

Then the application can be restarted due to unresponsive health checks.</Description>
    <Title_Description>Configure task scheduler? Hi

is it possible to configure the task scheduler somehow? 

The problem is that under high load the system can become unresponsive but some of the tasks would have a higher priority than others e.g. the health checks have a high priority.

Then the application can be restarted due to unresponsive health checks.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6007</IssueLabelID>
    <Title>Avoid generating duplicate method id switch labels</Title>
    <Description>Fixes #5818

Fixes #5295</Description>
    <Title_Description>Avoid generating duplicate method id switch labels Fixes #5818

Fixes #5295</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>3/10/2019 4:37:54 PM +00:00</CreatedAt>
    <ClosedAt>3/10/2019 11:15:23 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6005</IssueLabelID>
    <Title>Use MemFree when MemAvailable is not present</Title>
    <Description>On Windows WSL1 there is no MemAvailable line in meminfo file.
Use MemFree which gives similiar information.</Description>
    <Title_Description>Use MemFree when MemAvailable is not present On Windows WSL1 there is no MemAvailable line in meminfo file.
Use MemFree which gives similiar information.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6001</IssueLabelID>
    <Title>Fix UTF8 encoding settings that appear to break execution of tests</Title>
    <Description>
    </Description>
    <Title_Description>Fix UTF8 encoding settings that appear to break execution of tests </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>6000</IssueLabelID>
    <Title>Remove InternalsVisibleTo set for extensions by making necessary internal types public</Title>
    <Description>Fixes #4477.</Description>
    <Title_Description>Remove InternalsVisibleTo set for extensions by making necessary internal types public Fixes #4477.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5996</IssueLabelID>
    <Title>Support either Length or number of read bytes for IBinaryTokenStreamReader</Title>
    <Description>Hi

in 2.X I have written a custom stream as a wrapper around a IBinaryTokenStreamReader for a custom JSON.NET serializer.

https://github.com/Squidex/squidex/blob/master/src/Squidex.Infrastructure/Orleans/StreamReaderWrapper.cs#L59

The Length property has gone and therefore it is not possible to implement the Read method anymore.

I would either need:

1. A Length property in `IBinaryTokenStreamReader`

or 

2. `ReadByteArray` should return the number of read bytes if count is too large.</Description>
    <Title_Description>Support either Length or number of read bytes for IBinaryTokenStreamReader Hi

in 2.X I have written a custom stream as a wrapper around a IBinaryTokenStreamReader for a custom JSON.NET serializer.

https://github.com/Squidex/squidex/blob/master/src/Squidex.Infrastructure/Orleans/StreamReaderWrapper.cs#L59

The Length property has gone and therefore it is not possible to implement the Read method anymore.

I would either need:

1. A Length property in `IBinaryTokenStreamReader`

or 

2. `ReadByteArray` should return the number of read bytes if count is too large.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5995</IssueLabelID>
    <Title>Make TestClusterBuilder.AddSiloBuilderConfigurator and TestClusterBuilder.AddClientBuilderConfigurator fluent style APIs</Title>
    <Description>Fixes #5617.</Description>
    <Title_Description>Make TestClusterBuilder.AddSiloBuilderConfigurator and TestClusterBuilder.AddClientBuilderConfigurator fluent style APIs Fixes #5617.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5993</IssueLabelID>
    <Title>Typecode not supported in cluster</Title>
    <Description>We recently updated to Orleans 2.4.2 + update SignalR.Orleans as well and in certain cases we are getting error such as `TypeCode $1903070868 not supported in the cluster`

![image](https://user-images.githubusercontent.com/3908723/65983209-4f0fef00-e47d-11e9-8fb2-b4489ecaa00a.png)

We should only have 1 cluster and all silos are all the same build and we dont use grain versioning either; Seeing slightly the code thats why it seems to be thrown if im correct however in our case it shouldn't be the case

</Description>
    <Title_Description>Typecode not supported in cluster We recently updated to Orleans 2.4.2 + update SignalR.Orleans as well and in certain cases we are getting error such as `TypeCode $1903070868 not supported in the cluster`

![image](https://user-images.githubusercontent.com/3908723/65983209-4f0fef00-e47d-11e9-8fb2-b4489ecaa00a.png)

We should only have 1 cluster and all silos are all the same build and we dont use grain versioning either; Seeing slightly the code thats why it seems to be thrown if im correct however in our case it shouldn't be the case

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5985</IssueLabelID>
    <Title>Remove IMembershipOracle</Title>
    <Description>`IMembershipOracle` is no longer used as it has been split up into smaller parts which are each responsible for less. We should remove it for 3.0

Fixes #5847</Description>
    <Title_Description>Remove IMembershipOracle `IMembershipOracle` is no longer used as it has been split up into smaller parts which are each responsible for less. We should remove it for 3.0

Fixes #5847</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5982</IssueLabelID>
    <Title>Checkpointing is not happening when using eventhub Orleans stream.</Title>
    <Description>Hi Team

We are using Orleans 2.2.4. We were trying out Azure Eventhub based Orleans stream. 

1. Although we are able to send and receive the messages to and from stream we noticed that checkpointing is not happening at configured timespan. If we stop the silo in between and re-run it we still see the old messages are pulled from eventhub. There are checkpoints created in Azure table when Silo starts but doesn't update in configured time span.
Attaching the sample code which produces this issue. Stream configuration is done in `OrleansSiloBuilder.ConfigureStreamProviders` method. `EventSenderGrain` sends events to stream and `StreamDataRecieverGrain` subscribe to stream using implicit subscription.

2. If we use `UseDynamicClusterConfigDeploymentBalancer()` we are not receiving any messages from stream at all hence using `UseConsistentRingQueueBalancer()`.

Can you please help with the configuration if we are missing something? We mostly did the configurations based on the tests written in Orleans code.
[Code to reproduce the issue](https://github.com/dotnet/orleans/files/3663200/OrleansStreamSample.zip)
</Description>
    <Title_Description>Checkpointing is not happening when using eventhub Orleans stream. Hi Team

We are using Orleans 2.2.4. We were trying out Azure Eventhub based Orleans stream. 

1. Although we are able to send and receive the messages to and from stream we noticed that checkpointing is not happening at configured timespan. If we stop the silo in between and re-run it we still see the old messages are pulled from eventhub. There are checkpoints created in Azure table when Silo starts but doesn't update in configured time span.
Attaching the sample code which produces this issue. Stream configuration is done in `OrleansSiloBuilder.ConfigureStreamProviders` method. `EventSenderGrain` sends events to stream and `StreamDataRecieverGrain` subscribe to stream using implicit subscription.

2. If we use `UseDynamicClusterConfigDeploymentBalancer()` we are not receiving any messages from stream at all hence using `UseConsistentRingQueueBalancer()`.

Can you please help with the configuration if we are missing something? We mostly did the configurations based on the tests written in Orleans code.
[Code to reproduce the issue](https://github.com/dotnet/orleans/files/3663200/OrleansStreamSample.zip)
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5981</IssueLabelID>
    <Title>Documentation for Stream balancers</Title>
    <Description>I am looking for documentation on eventhub stream's options `UseConsistentRingQueueBalancer` `UseDynamicClusterConfigDeploymentBalancer`. Please can you point me to that. 

Thanks.</Description>
    <Title_Description>Documentation for Stream balancers I am looking for documentation on eventhub stream's options `UseConsistentRingQueueBalancer` `UseDynamicClusterConfigDeploymentBalancer`. Please can you point me to that. 

Thanks.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5979</IssueLabelID>
    <Title>The client supports other languages</Title>
    <Description>
    </Description>
    <Title_Description>The client supports other languages </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5978</IssueLabelID>
    <Title>Exception deserialization failure</Title>
    <Description>When the client does not refer to the server's Exception type Client will fail and timeout error will be raised.I think there should be a general approach.</Description>
    <Title_Description>Exception deserialization failure When the client does not refer to the server's Exception type Client will fail and timeout error will be raised.I think there should be a general approach.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5977</IssueLabelID>
    <Title>Add information about Task.Factory.StartNew gotchas in the docs</Title>
    <Description>The current documentation about running tasks inside a grain (https://dotnet.github.io/orleans/Documentation/grains/external_tasks_and_grains.html) suggests to use `Task.Factory.StartNew()` but there are some issues regarding this and it would be nice if those were pointed out in the doc.

Specifically it should be stated that `Task.Factory.StartNew()` does not natively support async delegates and so it should be used as `Task.Factory.StartNew(MyMethodAsync).Unwrap()` in this case.</Description>
    <Title_Description>Add information about Task.Factory.StartNew gotchas in the docs The current documentation about running tasks inside a grain (https://dotnet.github.io/orleans/Documentation/grains/external_tasks_and_grains.html) suggests to use `Task.Factory.StartNew()` but there are some issues regarding this and it would be nice if those were pointed out in the doc.

Specifically it should be stated that `Task.Factory.StartNew()` does not natively support async delegates and so it should be used as `Task.Factory.StartNew(MyMethodAsync).Unwrap()` in this case.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5973</IssueLabelID>
    <Title>Update preview dependency packages to final versions</Title>
    <Description>
    </Description>
    <Title_Description>Update preview dependency packages to final versions </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5971</IssueLabelID>
    <Title>Disable analyzer tests</Title>
    <Description>These tests appear to be blocking test execution on a regular basis. Let's disable them for now.</Description>
    <Title_Description>Disable analyzer tests These tests appear to be blocking test execution on a regular basis. Let's disable them for now.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5970</IssueLabelID>
    <Title>Connecting to DynamoDB from Silo</Title>
    <Description>I'm trying to configure AWS DynamoDB for my Silo clustering and I'm always hitting the following exception: 
```
Could not initialize connection to storage table OrleansSilos
Amazon.DynamoDBv2.AmazonDynamoDBException: The security token included in the request is invalid. ---&gt; Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
```

I'm  initializing my silo as follows: 
```
var siloHostBuilder = new SiloHostBuilder();
siloHostBuilder.UseDynamoDBClustering(options =&gt;
                {
                    options.AccessKey = &lt;value_of_AWS_ACCESS_KEY_ID&gt;
                    options.SecretKey = &lt;value_of_AWS_SECRET_ACCESS_KEY&gt;;
                    options.Service = RegionEndpoint.USEast1.SystemName;
                    options.TableName = siloConfiguration.MembershipTableName;
                })
```

I'm able to successfully access the DynamoDB tables using the AWS CLI. 
Am I missing anything here? 
Orleans version: `2.4.2`</Description>
    <Title_Description>Connecting to DynamoDB from Silo I'm trying to configure AWS DynamoDB for my Silo clustering and I'm always hitting the following exception: 
```
Could not initialize connection to storage table OrleansSilos
Amazon.DynamoDBv2.AmazonDynamoDBException: The security token included in the request is invalid. ---&gt; Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
```

I'm  initializing my silo as follows: 
```
var siloHostBuilder = new SiloHostBuilder();
siloHostBuilder.UseDynamoDBClustering(options =&gt;
                {
                    options.AccessKey = &lt;value_of_AWS_ACCESS_KEY_ID&gt;
                    options.SecretKey = &lt;value_of_AWS_SECRET_ACCESS_KEY&gt;;
                    options.Service = RegionEndpoint.USEast1.SystemName;
                    options.TableName = siloConfiguration.MembershipTableName;
                })
```

I'm able to successfully access the DynamoDB tables using the AWS CLI. 
Am I missing anything here? 
Orleans version: `2.4.2`</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5969</IssueLabelID>
    <Title>Is it safe to inject ITimerRegistry using DI?</Title>
    <Description>Hi everyone!

I found out that there is `Orleans.Timers.ITimerRegistry` interface which is injectable as a service using DI.

Suppose we have `FooGrain` `BarService` and `ITimerRegistry`:

```
public class FooGrain : Grain
{
    private readonly BarService _barService;

    public FooGrain(BarService barService)
    {
        _barService = barService;
    }

    public Task DoFoo()
    {
        _barService.DoBar();

        return Task.CompletedTask;
    }
}

public class BarService
{
    private readonly ITimerRegistry _timerRegistry;

    public BarService(ITimerRegistry timerRegistry)
    {
        _timerRegistry = timerRegistry;
    }

    public void DoBar()
    {
        _timerRegistry.RegisterTimer(
            grain: null
            asyncCallback: _ =&gt;
            {
                Console.WriteLine(nameof(DoBar));
                return Task.CompletedTask;
            }
            state: null
            dueTime: TimeSpan.FromSeconds(1)
            period: TimeSpan.FromSeconds(10)
        );
    }
}
```

As you can see I've passed `null` as a `grain` parameter to `ITimerRegistry.RegisterTimer` and it still works the timer does tick.

My question is: is it safe? I AFAIR timers are participants of grain messaging system and are alvays scheduled with Orleans scheduler.

But if I passed `null` as a grain what schedule does they participate? Can I be sure that timers that were created in the way I've shown above are scheduling in the correct way and never run concurrently with other tasks?</Description>
    <Title_Description>Is it safe to inject ITimerRegistry using DI? Hi everyone!

I found out that there is `Orleans.Timers.ITimerRegistry` interface which is injectable as a service using DI.

Suppose we have `FooGrain` `BarService` and `ITimerRegistry`:

```
public class FooGrain : Grain
{
    private readonly BarService _barService;

    public FooGrain(BarService barService)
    {
        _barService = barService;
    }

    public Task DoFoo()
    {
        _barService.DoBar();

        return Task.CompletedTask;
    }
}

public class BarService
{
    private readonly ITimerRegistry _timerRegistry;

    public BarService(ITimerRegistry timerRegistry)
    {
        _timerRegistry = timerRegistry;
    }

    public void DoBar()
    {
        _timerRegistry.RegisterTimer(
            grain: null
            asyncCallback: _ =&gt;
            {
                Console.WriteLine(nameof(DoBar));
                return Task.CompletedTask;
            }
            state: null
            dueTime: TimeSpan.FromSeconds(1)
            period: TimeSpan.FromSeconds(10)
        );
    }
}
```

As you can see I've passed `null` as a `grain` parameter to `ITimerRegistry.RegisterTimer` and it still works the timer does tick.

My question is: is it safe? I AFAIR timers are participants of grain messaging system and are alvays scheduled with Orleans scheduler.

But if I passed `null` as a grain what schedule does they participate? Can I be sure that timers that were created in the way I've shown above are scheduling in the correct way and never run concurrently with other tasks?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5968</IssueLabelID>
    <Title>Possible false-positive error log message</Title>
    <Description>Hi!

I have received the next log messages with `Error` level:

&gt; Work item WorkItem=WorkItemGroup:Name=[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/ffedf592@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.0000024 WorkItemGroup Details: WorkItemGroup:Name=[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/ffedf592@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement]WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=1; Total processed=0; Quantum expirations=0; Executing Task Id=687 Status=Running for 00:00:00.0000417.TaskRunner=ActivationTaskScheduler-10172:Queued=0; Detailed SchedulingContext=&lt;[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/4aa62bf153091ff6f2a3b2ebffedf59203ffffff97db295e-0x730F3BE6@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement State=Activating NonReentrancyQueueSize=1 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=737321.08:49:52.8640362 CollectionAgeLimit=00:05:00]&gt; has been executing for long time

It says that the work item of my `FooGrain` is `Executing for 00:00:00.0000024` i.e. `24 / 10 000 000` of a second.

It doesn't sound like an error especially considering that the default value of `TurnWarningLengthThreshold` hadn't been changed by me and should be equal to 200 ms.

This all sounds to me like a weird bug:
1) the message appears only if the work item is considered frozen:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Threading/ThreadPoolExecutor.cs#L244-L250
2) IsFrozen method says the item is frozen when the time passed after execution start is greater than threshold:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Threading/ThreadPoolExecutor.cs#L349-L352
3) the default value of threshold is 200 ms:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Runtime/Configuration/Options/SchedulingOptions.cs#L46-L50
4) displayed execution time is `00:00:00.0000024` which is less than 200 ms.

I would be very happy if you explain me what is happening here and whether I should worry about this.

Thanks.</Description>
    <Title_Description>Possible false-positive error log message Hi!

I have received the next log messages with `Error` level:

&gt; Work item WorkItem=WorkItemGroup:Name=[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/ffedf592@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.0000024 WorkItemGroup Details: WorkItemGroup:Name=[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/ffedf592@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement]WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=1; Total processed=0; Quantum expirations=0; Executing Task Id=687 Status=Running for 00:00:00.0000417.TaskRunner=ActivationTaskScheduler-10172:Queued=0; Detailed SchedulingContext=&lt;[Activation: S10.0.41.9:11111:306587370*grn/97DB295E/4aa62bf153091ff6f2a3b2ebffedf59203ffffff97db295e-0x730F3BE6@93111980 #GrainType=Some.Namespace.FooGrain Placement=RandomPlacement State=Activating NonReentrancyQueueSize=1 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=737321.08:49:52.8640362 CollectionAgeLimit=00:05:00]&gt; has been executing for long time

It says that the work item of my `FooGrain` is `Executing for 00:00:00.0000024` i.e. `24 / 10 000 000` of a second.

It doesn't sound like an error especially considering that the default value of `TurnWarningLengthThreshold` hadn't been changed by me and should be equal to 200 ms.

This all sounds to me like a weird bug:
1) the message appears only if the work item is considered frozen:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Threading/ThreadPoolExecutor.cs#L244-L250
2) IsFrozen method says the item is frozen when the time passed after execution start is greater than threshold:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Threading/ThreadPoolExecutor.cs#L349-L352
3) the default value of threshold is 200 ms:
https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Runtime/Configuration/Options/SchedulingOptions.cs#L46-L50
4) displayed execution time is `00:00:00.0000024` which is less than 200 ms.

I would be very happy if you explain me what is happening here and whether I should worry about this.

Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5967</IssueLabelID>
    <Title>Add overloads to IBinaryTokenStreamWriter and IBinaryTokenStreamReader</Title>
    <Description>I am trying to incorporate messagepack for my serialization/deserialization but some overloads are missing on the serialization interfaces which would make this nicer:

```
interface IBinaryTokenStreamWriter
{
     void Write(Span&lt;byte&gt; bytes);
}
```

```
interface IBinaryTokenStreamReader
{
    ReadOnlySequence&lt;byte&gt; Sequence { get; }
    Advance(int amount);
    void ReadBytes(in Span&lt;byte&gt; destination)
}
```

The sequence and advance methods are for deserializing directly from the underlying Orleans memory instead of reading the bytes to a local buffer and deserialize from there. It may also be that some of these belong directly on the `ISerializationContext`/`IDeserializationContext`.</Description>
    <Title_Description>Add overloads to IBinaryTokenStreamWriter and IBinaryTokenStreamReader I am trying to incorporate messagepack for my serialization/deserialization but some overloads are missing on the serialization interfaces which would make this nicer:

```
interface IBinaryTokenStreamWriter
{
     void Write(Span&lt;byte&gt; bytes);
}
```

```
interface IBinaryTokenStreamReader
{
    ReadOnlySequence&lt;byte&gt; Sequence { get; }
    Advance(int amount);
    void ReadBytes(in Span&lt;byte&gt; destination)
}
```

The sequence and advance methods are for deserializing directly from the underlying Orleans memory instead of reading the bytes to a local buffer and deserialize from there. It may also be that some of these belong directly on the `ISerializationContext`/`IDeserializationContext`.</Title_Description>
    <Label>serialization</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5966</IssueLabelID>
    <Title>Extension not installed exception not necessary for streams</Title>
    <Description>Now that extensions can be automatically installed from the container at runtime there's no need for stream providers to install them at subscription or production time.  We should add the producer and consumer extensions to the container and remove this logic from the providers.

This both simplifies the provider logic and also removes the requirement for grains to initialize their stream usage at activation time.</Description>
    <Title_Description>Extension not installed exception not necessary for streams Now that extensions can be automatically installed from the container at runtime there's no need for stream providers to install them at subscription or production time.  We should add the producer and consumer extensions to the container and remove this logic from the providers.

This both simplifies the provider logic and also removes the requirement for grains to initialize their stream usage at activation time.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5965</IssueLabelID>
    <Title>[SMSProvider] When multiple subscription handlers throw an exception only the first exception can be caught</Title>
    <Description>Hi I'm using Orleans 2.4.0 and currently playing around with Orleans streams especially with the SMSProvider (FireAndForget - false).
Everything works fine but I'm losing detailed failure results when multiple subscription handlers throw an exception.
```cs
Task result = null;
try
{
    result = stream.OnNextAsync(data);
    await result;
}
catch (Exception ex)
{
    // 'ex' and result.Exception contain only the first exception
}
```
This behavior is propagated from `Task.WhenAll` in [SimpleMessageStreamProducerExtension.cs](https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Streams/SimpleMessageStream/SimpleMessageStreamProducerExtension.cs#L195-L216)
```cs
internal class StreamConsumerExtensionCollection 
{
...
    internal Task DeliverItem(StreamId streamId object item bool fireAndForgetDelivery bool optimizeForImmutableData)
    {
        ...
        return fireAndForgetDelivery ? Task.CompletedTask : Task.WhenAll(tasks);
    }
}
```
but then ```DeliverItem``` is used with async/await in [SimpleMessageStreamProducer.cs](https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Streams/SimpleMessageStream/SimpleMessageStreamProducer.cs#L92-L113)
```cs
internal class SimpleMessageStreamProducer&lt;T&gt; : IInternalAsyncBatchObserver&lt;T&gt;
{
    ...
    public async Task OnNextAsync(T item StreamSequenceToken token)
    {
         ...
         await myExtension.DeliverItem(stream.StreamId item);
     }
}
```
And as a result AggregateException is unwrapped to the first exception and an external code cant affect it in any way.

How to solve this? Looks like an option in the class `SimpleMessageStreamProviderOptions` _UnwrapAggregateExceptions = true|false (default = true current behavior)_</Description>
    <Title_Description>[SMSProvider] When multiple subscription handlers throw an exception, only the first exception can be caught Hi I'm using Orleans 2.4.0 and currently playing around with Orleans streams especially with the SMSProvider (FireAndForget - false).
Everything works fine but I'm losing detailed failure results when multiple subscription handlers throw an exception.
```cs
Task result = null;
try
{
    result = stream.OnNextAsync(data);
    await result;
}
catch (Exception ex)
{
    // 'ex' and result.Exception contain only the first exception
}
```
This behavior is propagated from `Task.WhenAll` in [SimpleMessageStreamProducerExtension.cs](https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Streams/SimpleMessageStream/SimpleMessageStreamProducerExtension.cs#L195-L216)
```cs
internal class StreamConsumerExtensionCollection 
{
...
    internal Task DeliverItem(StreamId streamId object item bool fireAndForgetDelivery bool optimizeForImmutableData)
    {
        ...
        return fireAndForgetDelivery ? Task.CompletedTask : Task.WhenAll(tasks);
    }
}
```
but then ```DeliverItem``` is used with async/await in [SimpleMessageStreamProducer.cs](https://github.com/dotnet/orleans/blob/cc4749c9be837f3f6dd82ece9cb4ed7a9c5dc798/src/Orleans.Core/Streams/SimpleMessageStream/SimpleMessageStreamProducer.cs#L92-L113)
```cs
internal class SimpleMessageStreamProducer&lt;T&gt; : IInternalAsyncBatchObserver&lt;T&gt;
{
    ...
    public async Task OnNextAsync(T item StreamSequenceToken token)
    {
         ...
         await myExtension.DeliverItem(stream.StreamId item);
     }
}
```
And as a result AggregateException is unwrapped to the first exception and an external code cant affect it in any way.

How to solve this? Looks like an option in the class `SimpleMessageStreamProviderOptions` _UnwrapAggregateExceptions = true|false (default = true current behavior)_</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5964</IssueLabelID>
    <Title>Multiple message from  same stream cause  repetitive activation in consumer  </Title>
    <Description>Hi

### Playground:

grain **A**  have a method to send message in `OnNextAsync` of stream **ST** to implicitly subscribed grain **B**  .  

In grain **B** there is initialization that need to perform in `OnActivateAsync()` of  grain **B** also subscription to stream **ST** and a lambda function to perform action on receiving message   .

project setup as 
`&lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;`

` &lt;PackageReference Include="Microsoft.Extensions.Logging.Console" Version="2.2.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Clustering.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansGoogleUtils" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Reminders.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Server" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Transactions" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.9.5" /&gt;
    &lt;PackageReference Include="Orleans.Providers.MongoDB" Version="2.7.0" /&gt;`

host builder setting 

` UseLocalhostClustering(siloPort gatewayPort)
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = Guid.NewGuid().ToString();
                        options.ServiceId = Guid.NewGuid().ToString();
                    })
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(PersonGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ConnectionRegistrarGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(OpmGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(DcGrain).Assembly).WithReferences())
                    .AddMemoryGrainStorageAsDefault()
                    .AddMemoryGrainStorage("MainGrainStorage")
                    .AddMemoryGrainStorage("PubSubStore")
                    .AddSimpleMessageStreamProvider(AcoConstant.GlobalSmsStreamProvider
                    op=&gt; {
                        op.PubSubType = Orleans.Streams.StreamPubSubType.ExplicitGrainBasedAndImplicit;
                        })
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.RegisterDcStreamNameSpace)
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.RequestForDcRegistrationStreamNameSpace)
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.DiscardTheRequestForDcRegistrationStreamNameSpace)
                    .ConfigureLogging(logging =&gt; {
                        logging.AddConsole();
                        logging.SetMinimumLevel(LogLevel.Trace);
                        })
                    .UseInMemoryReminderService();`




### Problem:
When multiple activation of grain **A**  send message  to grain **B** it case repetitive activation in grain **B** without previous saved status of grain **B**  and eventually only  first saved state exist in gran **B** . 
grains primary key and stream namespace already checked in sender and receiver  `AddSimpleMessageStreamProvider ` and  `AddMemoryStreams` used in silo host builder .
after some test found out that changing `OnActivateAsync()`  to non async task case  **e-Tag mismatch in Memory Storage. Stored**   exception  .   
is there any missed config or some other issue that must be considered ?

(next day 22 sep) 
some new discover ;
after trace into source server `Orleans.Storage.InconsistentStateException` appear  on ` WriteStateAsync()` method of `StateStorageBridge&lt;TState&gt;` .

debug output on exception as below 

`Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in OrleansProviders.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.InconsistentStateException' in OrleansProviders.dll
Exception thrown: 'Orleans.Storage.InconsistentStateException' in System.Private.CoreLib.dll
` 

after this error grain deactivated and reactivate for handling next message from stream.
other save process  with call to grain work normally (also first message from stream) .

grain **A** method  is 


 
                
                if (!State.DcCreationRequest.inProcess)
                {
                    State.DcCreationRequest = (dc DateTimeOffset.Now memo true);

                    var a = this.GetPrimaryKey();

                   await _dcRegistrationRequestStream.OnNextAsync(a) ;
                   
                    await WriteStateAsync();

                    return await Task.FromResult(true);
                }

                return await Task.FromResult(false);
            }`


and action in grain **B** subscribe  method is  

```
                     {
                      State.DcCreationRequests.Remove(value);
                 
                        return Task.CompletedTask;
                       } 
```

if it is not miss config then may be there is regression like  #5086 

thank you
</Description>
    <Title_Description>Multiple message from  same stream cause  repetitive activation in consumer   Hi

### Playground:

grain **A**  have a method to send message in `OnNextAsync` of stream **ST** to implicitly subscribed grain **B**  .  

In grain **B** there is initialization that need to perform in `OnActivateAsync()` of  grain **B** also subscription to stream **ST** and a lambda function to perform action on receiving message   .

project setup as 
`&lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;`

` &lt;PackageReference Include="Microsoft.Extensions.Logging.Console" Version="2.2.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Clustering.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansGoogleUtils" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Reminders.AdoNet" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Server" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Transactions" Version="2.4.2" /&gt;
    &lt;PackageReference Include="Microsoft.VisualStudio.Azure.Containers.Tools.Targets" Version="1.9.5" /&gt;
    &lt;PackageReference Include="Orleans.Providers.MongoDB" Version="2.7.0" /&gt;`

host builder setting 

` UseLocalhostClustering(siloPort gatewayPort)
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = Guid.NewGuid().ToString();
                        options.ServiceId = Guid.NewGuid().ToString();
                    })
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(PersonGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ConnectionRegistrarGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(OpmGrain).Assembly).WithReferences())
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(DcGrain).Assembly).WithReferences())
                    .AddMemoryGrainStorageAsDefault()
                    .AddMemoryGrainStorage("MainGrainStorage")
                    .AddMemoryGrainStorage("PubSubStore")
                    .AddSimpleMessageStreamProvider(AcoConstant.GlobalSmsStreamProvider
                    op=&gt; {
                        op.PubSubType = Orleans.Streams.StreamPubSubType.ExplicitGrainBasedAndImplicit;
                        })
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.RegisterDcStreamNameSpace)
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.RequestForDcRegistrationStreamNameSpace)
                    .AddMemoryStreams&lt;DefaultMemoryMessageBodySerializer&gt;(AcoConstant.DiscardTheRequestForDcRegistrationStreamNameSpace)
                    .ConfigureLogging(logging =&gt; {
                        logging.AddConsole();
                        logging.SetMinimumLevel(LogLevel.Trace);
                        })
                    .UseInMemoryReminderService();`




### Problem:
When multiple activation of grain **A**  send message  to grain **B** it case repetitive activation in grain **B** without previous saved status of grain **B**  and eventually only  first saved state exist in gran **B** . 
grains primary key and stream namespace already checked in sender and receiver  `AddSimpleMessageStreamProvider ` and  `AddMemoryStreams` used in silo host builder .
after some test found out that changing `OnActivateAsync()`  to non async task case  **e-Tag mismatch in Memory Storage. Stored**   exception  .   
is there any missed config or some other issue that must be considered ?

(next day 22 sep) 
some new discover ;
after trace into source server `Orleans.Storage.InconsistentStateException` appear  on ` WriteStateAsync()` method of `StateStorageBridge&lt;TState&gt;` .

debug output on exception as below 

`Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in OrleansProviders.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.Internal.MemoryStorageEtagMismatchException' in System.Private.CoreLib.dll
Exception thrown: 'Orleans.Storage.InconsistentStateException' in OrleansProviders.dll
Exception thrown: 'Orleans.Storage.InconsistentStateException' in System.Private.CoreLib.dll
` 

after this error grain deactivated and reactivate for handling next message from stream.
other save process  with call to grain work normally (also first message from stream) .

grain **A** method  is 


 
                
                if (!State.DcCreationRequest.inProcess)
                {
                    State.DcCreationRequest = (dc DateTimeOffset.Now memo true);

                    var a = this.GetPrimaryKey();

                   await _dcRegistrationRequestStream.OnNextAsync(a) ;
                   
                    await WriteStateAsync();

                    return await Task.FromResult(true);
                }

                return await Task.FromResult(false);
            }`


and action in grain **B** subscribe  method is  

```
                     {
                      State.DcCreationRequests.Remove(value);
                 
                        return Task.CompletedTask;
                       } 
```

if it is not miss config then may be there is regression like  #5086 

thank you
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5963</IssueLabelID>
    <Title>Fix Connect blocked when ConnectAsync completed synchronously</Title>
    <Description>Fix for #5158

Acccodring to [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.connectasync?view=netcore-2.2) `ConnectAsync(SocketAsyncEventArgs)` will return bool 

&gt; true if the I/O operation is pending. The Completed event on the e parameter will be raised upon completion of the operation.
&gt; 
&gt; false if the I/O operation completed synchronously. In this case The Completed event on the e parameter will not be raised and the e object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

In windows looks like `ConnectAsync` will alwasy return true (pending) even if operation is done immediately https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L163-L164 . 

But in Linux host the [corefx](https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L14-L33) says:
```csharp
    // The asynchronous socket operations here generally do the following:
    // (1) If the operation queue is Ready (queue is empty) try to perform the operation immediately non-blocking.
    // If this completes (i.e. does not return EWOULDBLOCK) then we return the results immediately
    // for both success (SocketError.Success) or failure.
    // No callback will happen; callers are expected to handle these synchronous completions themselves.
```

That means if operation completed synchronously the Completed callback will be never invoked which will make `AutoResetEvent.WaitOne` keeping waiting until timeout. That's why the server did not receive `Preamble` and timeout [here](https://github.com/dotnet/orleans/blob/v2.4.2/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L207)

I see you plan to rewrite network stack in 3.0.0. I don't if this bug will be solved. But as for 2.x version my possible solution is to change Connect method https://github.com/dotnet/orleans/blob/2.4.3/src/Orleans.Core/Messaging/SocketManager.cs#L196-L209 like 
```csharp
        internal static void Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
        {
            var signal = new AutoResetEvent(false);
            var e = new SocketAsyncEventArgs();
            e.RemoteEndPoint = endPoint;
            e.Completed += (sender eventArgs) =&gt; signal.Set();
            bool pending = s.ConnectAsync(e);

            if (pending &amp;&amp; !signal.WaitOne(connectionTimeout))
                throw new TimeoutException($"Connection to {endPoint} could not be established in {connectionTimeout}");

            if (e.SocketError != SocketError.Success || !s.Connected)
                throw new OrleansException($"Could not connect to {endPoint}: {e.SocketError}");
        }
```</Description>
    <Title_Description>Fix Connect blocked when ConnectAsync completed synchronously Fix for #5158

Acccodring to [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.connectasync?view=netcore-2.2) `ConnectAsync(SocketAsyncEventArgs)` will return bool 

&gt; true if the I/O operation is pending. The Completed event on the e parameter will be raised upon completion of the operation.
&gt; 
&gt; false if the I/O operation completed synchronously. In this case The Completed event on the e parameter will not be raised and the e object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

In windows looks like `ConnectAsync` will alwasy return true (pending) even if operation is done immediately https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L163-L164 . 

But in Linux host the [corefx](https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L14-L33) says:
```csharp
    // The asynchronous socket operations here generally do the following:
    // (1) If the operation queue is Ready (queue is empty) try to perform the operation immediately non-blocking.
    // If this completes (i.e. does not return EWOULDBLOCK) then we return the results immediately
    // for both success (SocketError.Success) or failure.
    // No callback will happen; callers are expected to handle these synchronous completions themselves.
```

That means if operation completed synchronously the Completed callback will be never invoked which will make `AutoResetEvent.WaitOne` keeping waiting until timeout. That's why the server did not receive `Preamble` and timeout [here](https://github.com/dotnet/orleans/blob/v2.4.2/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L207)

I see you plan to rewrite network stack in 3.0.0. I don't if this bug will be solved. But as for 2.x version my possible solution is to change Connect method https://github.com/dotnet/orleans/blob/2.4.3/src/Orleans.Core/Messaging/SocketManager.cs#L196-L209 like 
```csharp
        internal static void Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
        {
            var signal = new AutoResetEvent(false);
            var e = new SocketAsyncEventArgs();
            e.RemoteEndPoint = endPoint;
            e.Completed += (sender eventArgs) =&gt; signal.Set();
            bool pending = s.ConnectAsync(e);

            if (pending &amp;&amp; !signal.WaitOne(connectionTimeout))
                throw new TimeoutException($"Connection to {endPoint} could not be established in {connectionTimeout}");

            if (e.SocketError != SocketError.Success || !s.Connected)
                throw new OrleansException($"Could not connect to {endPoint}: {e.SocketError}");
        }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5962</IssueLabelID>
    <Title>Custom Log Event Store</Title>
    <Description>Hi

I'm looking at implementing a custom storage provider - I would like to be storing the events for a Journaled Grains.  Could you please clarify if i need to implement a custom storage provider as well as the grains implement ICustomStorageInterface.

Also on storage providers whats the difference between IStorageProvider and IGrainStorage - i.e. when is the IProvider implementation of IStorageProvider  used?

I've been going through the documenation just a little confused at the moment. Thanks
Ross</Description>
    <Title_Description>Custom Log Event Store Hi

I'm looking at implementing a custom storage provider - I would like to be storing the events for a Journaled Grains.  Could you please clarify if i need to implement a custom storage provider as well as the grains implement ICustomStorageInterface.

Also on storage providers whats the difference between IStorageProvider and IGrainStorage - i.e. when is the IProvider implementation of IStorageProvider  used?

I've been going through the documenation just a little confused at the moment. Thanks
Ross</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5957</IssueLabelID>
    <Title>Demonstration package My-First-Orleans-Application.md does not compile</Title>
    <Description>I spent an hour trying to get this simple demo application to compile. It seems there is something wrong with the references or packages. Surely having a simple step-by-step demo is a good idea for this project?</Description>
    <Title_Description>Demonstration package My-First-Orleans-Application.md does not compile I spent an hour trying to get this simple demo application to compile. It seems there is something wrong with the references or packages. Surely having a simple step-by-step demo is a good idea for this project?</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/09/2019 10:59:30 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5948</IssueLabelID>
    <Title>WIP - Use opaque sequence token in message cache</Title>
    <Description>We now use opaque streamId sequence token and offsets in stream message cache.

This is intended to address https://github.com/dotnet/orleans/issues/5879
Will also help us move to more robust streamId.

PooledQueueCache is mostly ok but cruft translating opaque cached data to pre-existing types is a bit ick.

Also eviction strategy still has logic that shouldn't be there.

Getting this out for review but want to let the patterns bake for a bit before committing to this path.

@Frank-Krick</Description>
    <Title_Description>WIP - Use opaque sequence token in message cache We now use opaque streamId sequence token and offsets in stream message cache.

This is intended to address https://github.com/dotnet/orleans/issues/5879
Will also help us move to more robust streamId.

PooledQueueCache is mostly ok but cruft translating opaque cached data to pre-existing types is a bit ick.

Also eviction strategy still has logic that shouldn't be there.

Getting this out for review but want to let the patterns bake for a bit before committing to this path.

@Frank-Krick</Title_Description>
    <Label>work-in-progress</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>13/09/2019 12:21:07 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5947</IssueLabelID>
    <Title>Exception thrown from constructor of stateless worker grain eventually freezes grain call</Title>
    <Description>I have found a bug that requires a silo restart to resolve (tested with Orleans versions 1.5.3 and 1.5.9).

You can simply reproduce the bug with the [_HelloWorld_](https://github.com/dotnet/orleans/tree/v1.5.9/Samples/HelloWorld) sample project.

I used the `HelloWorld.SeparateProcess` solution but I think this doesn't make a difference. At first change the `DoClientWork` method in file `Program.cs` of project `OrleansClient` like this:
```csharp
private static async Task DoClientWork()
{
  var friend = GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0);

  while (true)
  {
    try
    {
      // example of calling grains from the initialized client
      var response = await friend.SayHello("Good morning my friend!");
      Console.WriteLine("\n\n{0}\n\n" response);
    }
    catch (Exception exc)
    {
      Console.WriteLine(exc);
    }

    Console.WriteLine("Press RETURN to repeat.");
    Console.ReadLine();
  }
}
```

This will run the grain call in a loop.

Now add a constructor that throws an exception to class `HelloGrain` of project `HelloWorldGrains`:

```csharp
public HelloGrain()
{
  throw new Exception("Intentionally thrown.");
}
```

When running the silo and client everything works as expected: an `OrleansException` which contains the thrown exception as an inner exception is propagated to the client.

So far so good.

Now make the `HelloGrain` a _stateless worker_:

```csharp
[StatelessWorker]
public class HelloGrain : Orleans.Grain IHello
{
  // ...
}
```

When running the silo and client an `OrleansException` is propagated to the client **but only for 4 iterations**. After that the client call `var response = await friend.SayHello("Good morning my friend!");` freezes.

I think the number of 4 has a reason: I run the silo on a Quad Core processor and as far as I know Orleans activates a stateless worker with a specific key on each core. Here the key is `0` which means 4 grain instances of the stateless worker are tried to instantiate and then further tries are blocked.

Of course it is a bad idea to throw an exception from a grain constructor but we had an issue where this was the case and wondered why our services stopped. Even if the condition that raised the bug in the constructor disappeard the grain was never again tried to activate.

**FYI**: I tested the same scenario with the `OnActivateAsync` method (throwing an exception from there) but in this case the bug does not occur. So I don't think this bug is related to https://github.com/dotnet/orleans/issues/4748.</Description>
    <Title_Description>Exception thrown from constructor of stateless worker grain eventually freezes grain call I have found a bug that requires a silo restart to resolve (tested with Orleans versions 1.5.3 and 1.5.9).

You can simply reproduce the bug with the [_HelloWorld_](https://github.com/dotnet/orleans/tree/v1.5.9/Samples/HelloWorld) sample project.

I used the `HelloWorld.SeparateProcess` solution but I think this doesn't make a difference. At first change the `DoClientWork` method in file `Program.cs` of project `OrleansClient` like this:
```csharp
private static async Task DoClientWork()
{
  var friend = GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0);

  while (true)
  {
    try
    {
      // example of calling grains from the initialized client
      var response = await friend.SayHello("Good morning my friend!");
      Console.WriteLine("\n\n{0}\n\n" response);
    }
    catch (Exception exc)
    {
      Console.WriteLine(exc);
    }

    Console.WriteLine("Press RETURN to repeat.");
    Console.ReadLine();
  }
}
```

This will run the grain call in a loop.

Now add a constructor that throws an exception to class `HelloGrain` of project `HelloWorldGrains`:

```csharp
public HelloGrain()
{
  throw new Exception("Intentionally thrown.");
}
```

When running the silo and client everything works as expected: an `OrleansException` which contains the thrown exception as an inner exception is propagated to the client.

So far so good.

Now make the `HelloGrain` a _stateless worker_:

```csharp
[StatelessWorker]
public class HelloGrain : Orleans.Grain IHello
{
  // ...
}
```

When running the silo and client an `OrleansException` is propagated to the client **but only for 4 iterations**. After that the client call `var response = await friend.SayHello("Good morning my friend!");` freezes.

I think the number of 4 has a reason: I run the silo on a Quad Core processor and as far as I know Orleans activates a stateless worker with a specific key on each core. Here the key is `0` which means 4 grain instances of the stateless worker are tried to instantiate and then further tries are blocked.

Of course it is a bad idea to throw an exception from a grain constructor but we had an issue where this was the case and wondered why our services stopped. Even if the condition that raised the bug in the constructor disappeard the grain was never again tried to activate.

**FYI**: I tested the same scenario with the `OnActivateAsync` method (throwing an exception from there) but in this case the bug does not occur. So I don't think this bug is related to https://github.com/dotnet/orleans/issues/4748.</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5941</IssueLabelID>
    <Title>Double serialization/deserialization for exceptions thrown in Grains marked as transactional</Title>
    <Description>When throwing custom exceptions in a transactional grain method the exception gets serialized and deserialized twice and then set as inner exception on a OrleansTransactionAbortedException. Is the double serialization/deserialization of the custom exception by design? Just trying to understand if this is a correct behaviour since this doesn't seem to be the case in a non transactional method.</Description>
    <Title_Description>Double serialization/deserialization for exceptions thrown in Grains marked as transactional When throwing custom exceptions in a transactional grain method the exception gets serialized and deserialized twice and then set as inner exception on a OrleansTransactionAbortedException. Is the double serialization/deserialization of the custom exception by design? Just trying to understand if this is a correct behaviour since this doesn't seem to be the case in a non transactional method.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5940</IssueLabelID>
    <Title>Revert "Bound retries for failed send in ClientMessageCenter and simplify (#5893)"</Title>
    <Description>This PR (#5893) appears to have destabilized our reliability tests. Let's revert and redo it.</Description>
    <Title_Description>Revert "Bound retries for failed send in ClientMessageCenter and simplify (#5893)" This PR (#5893) appears to have destabilized our reliability tests. Let's revert and redo it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5939</IssueLabelID>
    <Title>Retain producer-side stream filtering</Title>
    <Description>**Background**

Producer-side stream filtering is to be removed in an upcoming revision of Orleans (per #5408).
See relevant Gitter excerpts below:
* [August 13 2019 3:04 PM](https://gitter.im/dotnet/orleans?at=5d535e35d03a7c63e62256d5)
* [August 14 2019 7:23 AM](https://gitter.im/dotnet/orleans?at=5d5443ad9507182477d9d6be)
* [August 14 2019 8:04 AM](https://gitter.im/dotnet/orleans?at=5d544d494e17537f522fbd4e)

In short the intent is to remove the feature due to maintainability and design-related concerns in the face of the pub-sub system becoming a public surface.
My understanding is that the primary design concern stems from the way the filter predicate is specified.  In the current implementation the identity of the filter predicate (represented by a class name and method name tuple) is supplied by the subscribing party. In addition to constraining  eligible predicates to  static methods the mechanism used to extract this identity employs delegates and leads to an undesirable dependency whereby the predicate function must be available to both producer and consumer. While this may appear fairly benign in the case in which both the producer and the consumer are grains this requirement becomes harder to justify when consuming streams from an Orleans client. 

**Advocating for retaining producer-side filtering** 

&gt; Please note that the scenarios described below have been significantly simplified for the sake of brevity

We use per-grain streams to publish incremental grain state changes in a variation on event sourcing. Clients subscribe to these streams to render changes to grain state in real time. Upon subscribing a new client receives an optimized version of the change log allowing it to "catch-up" with the current grain state - we are currently using the feature in production to selectively deliver this class of messages to only the newly subscribed client. 

In addition to simple state(s) grains can hold collections - changes to these collections are similarly propagated to clients in real time. Clients can construct queries over these collections the results of which are also updated in real time - we are currently using the feature in production to selectively deliver initial query results to only the client that has made the query. 

Continuing to be able to filter such messages on the producer side is very important to us.

**Possible approaches to retaining producer-side filtering**
 
It appears that allowing arbitrary client-supplied predicates while addressing the coupling concern would require serializing the predicate closure provided by the consumer at subscription time and then deserializing and executing it on the producer side.
While serializers that could be used to implement such behavior exists (e.g. [FsPickler](https://github.com/mbraceproject/FsPickler) [Hyperion](https://github.com/akkadotnet/Hyperion)) It is unclear to me at this point whether the added complexity is warranted and how such complexity would impact the goal of having an easily-maintainable public pub-sub surface.

A more conservative approach would avoid passing predicate identity during subscription altogether and instead rely on the predicate being supplied on the producer side at the time of event emission. A subscriber would continue to be able to attach custom data to the subscription data that could be used on the producer side to affect predicate logic. 
It is of note that this approach while not requiring the subscriber to supply the predicate identity would continue to allow the subscriber to choose a specific predicate logic out of a well-known set of choices available producer-side by means of adequately constructed custom subscription data.

I am proposing adopting the latter approach based on its relative simplicity and on the fact that it allows for a straightforward migration path - please let me know if this would be acceptable in principle. If so I will try to modify the current implementation and tests accordingly and submit a PR

Please also let me know if you would like to discuss any of the above offline I am more than happy to do so.
</Description>
    <Title_Description>Retain producer-side stream filtering **Background**

Producer-side stream filtering is to be removed in an upcoming revision of Orleans (per #5408).
See relevant Gitter excerpts below:
* [August 13 2019 3:04 PM](https://gitter.im/dotnet/orleans?at=5d535e35d03a7c63e62256d5)
* [August 14 2019 7:23 AM](https://gitter.im/dotnet/orleans?at=5d5443ad9507182477d9d6be)
* [August 14 2019 8:04 AM](https://gitter.im/dotnet/orleans?at=5d544d494e17537f522fbd4e)

In short the intent is to remove the feature due to maintainability and design-related concerns in the face of the pub-sub system becoming a public surface.
My understanding is that the primary design concern stems from the way the filter predicate is specified.  In the current implementation the identity of the filter predicate (represented by a class name and method name tuple) is supplied by the subscribing party. In addition to constraining  eligible predicates to  static methods the mechanism used to extract this identity employs delegates and leads to an undesirable dependency whereby the predicate function must be available to both producer and consumer. While this may appear fairly benign in the case in which both the producer and the consumer are grains this requirement becomes harder to justify when consuming streams from an Orleans client. 

**Advocating for retaining producer-side filtering** 

&gt; Please note that the scenarios described below have been significantly simplified for the sake of brevity

We use per-grain streams to publish incremental grain state changes in a variation on event sourcing. Clients subscribe to these streams to render changes to grain state in real time. Upon subscribing a new client receives an optimized version of the change log allowing it to "catch-up" with the current grain state - we are currently using the feature in production to selectively deliver this class of messages to only the newly subscribed client. 

In addition to simple state(s) grains can hold collections - changes to these collections are similarly propagated to clients in real time. Clients can construct queries over these collections the results of which are also updated in real time - we are currently using the feature in production to selectively deliver initial query results to only the client that has made the query. 

Continuing to be able to filter such messages on the producer side is very important to us.

**Possible approaches to retaining producer-side filtering**
 
It appears that allowing arbitrary client-supplied predicates while addressing the coupling concern would require serializing the predicate closure provided by the consumer at subscription time and then deserializing and executing it on the producer side.
While serializers that could be used to implement such behavior exists (e.g. [FsPickler](https://github.com/mbraceproject/FsPickler) [Hyperion](https://github.com/akkadotnet/Hyperion)) It is unclear to me at this point whether the added complexity is warranted and how such complexity would impact the goal of having an easily-maintainable public pub-sub surface.

A more conservative approach would avoid passing predicate identity during subscription altogether and instead rely on the predicate being supplied on the producer side at the time of event emission. A subscriber would continue to be able to attach custom data to the subscription data that could be used on the producer side to affect predicate logic. 
It is of note that this approach while not requiring the subscriber to supply the predicate identity would continue to allow the subscriber to choose a specific predicate logic out of a well-known set of choices available producer-side by means of adequately constructed custom subscription data.

I am proposing adopting the latter approach based on its relative simplicity and on the fact that it allows for a straightforward migration path - please let me know if this would be acceptable in principle. If so I will try to modify the current implementation and tests accordingly and submit a PR

Please also let me know if you would like to discuss any of the above offline I am more than happy to do so.
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5938</IssueLabelID>
    <Title>How to setup connectivity between silo and client if first one lives in docker container and second does not?</Title>
    <Description>Is it possible to setup Orleans cluster the way silos deployed under docker container while Orleans client (service that calls grains) to be a regular Windows service? The problem I experince in the configuration is that silos register themselves under docker subnet ips in a membership table (MongoDb in my case) and then client tries to call gateway (port 11111) with their own docker ips but dockers are not accessible under their own ip from host system at least I do not know how to configure it. Instead the gateway accessible under host machine ip with 11111 port if you map it to a host port when running docker container. However client reads docker container IPs from mongo not their host ips.  Anyone have an idea on how to get around it or set it up properly? Thanks</Description>
    <Title_Description>How to setup connectivity between silo and client, if first one lives in docker container and second does not? Is it possible to setup Orleans cluster the way silos deployed under docker container while Orleans client (service that calls grains) to be a regular Windows service? The problem I experince in the configuration is that silos register themselves under docker subnet ips in a membership table (MongoDb in my case) and then client tries to call gateway (port 11111) with their own docker ips but dockers are not accessible under their own ip from host system at least I do not know how to configure it. Instead the gateway accessible under host machine ip with 11111 port if you map it to a host port when running docker container. However client reads docker container IPs from mongo not their host ips.  Anyone have an idea on how to get around it or set it up properly? Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5937</IssueLabelID>
    <Title>Repro for #5936</Title>
    <Description> See #5936 
Note that this repro results in invalid code being generated and thus breaks the build.</Description>
    <Title_Description>Repro for #5936  See #5936 
Note that this repro results in invalid code being generated and thus breaks the build.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5936</IssueLabelID>
    <Title>Microsoft.Orleans.CodeGenerator.MSBuild generates invalid code for F# interface methods with multiple unnamed arguments</Title>
    <Description>F# interface declarations allow declaring methods without specifying argument names.
`Microsoft.Orleans.CodeGenerator.MSBuild` generates invalid code for F# interface methods that have multiple unnamed arguments.

Note that `Microsoft.Orleans.CodeGenerator.Build` generates valid code in this scenario. 

Repro PR: #5937</Description>
    <Title_Description>Microsoft.Orleans.CodeGenerator.MSBuild generates invalid code for F# interface methods with multiple unnamed arguments F# interface declarations allow declaring methods without specifying argument names.
`Microsoft.Orleans.CodeGenerator.MSBuild` generates invalid code for F# interface methods that have multiple unnamed arguments.

Note that `Microsoft.Orleans.CodeGenerator.Build` generates valid code in this scenario. 

Repro PR: #5937</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5933</IssueLabelID>
    <Title>String grain id interceptor</Title>
    <Description>@ReubenBond Just moving the conversation to here from Gitter. As I mentioned we have the issue where string differences (capitalization extra whitespaces...) in string grain Ids are causing us to activate different grains. 

Right now our team uses `ToUpperInvariant()` any time we use a string id but we may need to have different rules based on the different grain type. Ideally the logic to make the ids conform to the standard would be something that the grain with the string id would define not the grain that is trying to access the grain. The proposed solution is to add an id interceptor that could be added to the silo configuration that would allow a developer to convert the requested string id into a "standardized" string.

I'd love to get some feedback and/or ideas on this before writing the code. If this seems like an idea that has support within the community I can make the changes and open up a PR within the next week or so.</Description>
    <Title_Description>String grain id interceptor @ReubenBond Just moving the conversation to here from Gitter. As I mentioned we have the issue where string differences (capitalization extra whitespaces...) in string grain Ids are causing us to activate different grains. 

Right now our team uses `ToUpperInvariant()` any time we use a string id but we may need to have different rules based on the different grain type. Ideally the logic to make the ids conform to the standard would be something that the grain with the string id would define not the grain that is trying to access the grain. The proposed solution is to add an id interceptor that could be added to the silo configuration that would allow a developer to convert the requested string id into a "standardized" string.

I'd love to get some feedback and/or ideas on this before writing the code. If this seems like an idea that has support within the community I can make the changes and open up a PR within the next week or so.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5932</IssueLabelID>
    <Title>Docs: Update Configuration Guide to show UseOrleans()</Title>
    <Description>As discussed in #5931 

The Configuration Guide shows `new SiloHostBuilder()` which I gather is going away it should be updated for the generic host `UseOrleans()` approach.

Possibly related -- I'm setting up SQL storage for version 2.4.2. It appears the documentation in [Configuring ADO.NET Providers](http://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html) is incorrect. Whether I use the `UseOrleans()` or the `new SiloHostBuilder()` approach ADO.NET configuration entries result in a "call is ambiguous" error for the various extension methods (this happens with the provider reminder and cluster packages).

![image](https://user-images.githubusercontent.com/54578900/64422919-375a6c00-d073-11e9-9938-b083b45cefcb.png)
</Description>
    <Title_Description>Docs: Update Configuration Guide to show UseOrleans() As discussed in #5931 

The Configuration Guide shows `new SiloHostBuilder()` which I gather is going away it should be updated for the generic host `UseOrleans()` approach.

Possibly related -- I'm setting up SQL storage for version 2.4.2. It appears the documentation in [Configuring ADO.NET Providers](http://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/configuring_ADO.NET_providers.html) is incorrect. Whether I use the `UseOrleans()` or the `new SiloHostBuilder()` approach ADO.NET configuration entries result in a "call is ambiguous" error for the various extension methods (this happens with the provider reminder and cluster packages).

![image](https://user-images.githubusercontent.com/54578900/64422919-375a6c00-d073-11e9-9938-b083b45cefcb.png)
</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5926</IssueLabelID>
    <Title>Roslyn code generator fails when Azure Cosmos DB SDK 3.0 is references by a grain</Title>
    <Description>When using Azure Cosmos DB SDK 3.0 inside a grain (even without adding Cosmos SDK types to method declaration) the build fails with error: 

```
2&gt;      Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Azure.Cosmos.Direct Version=3.1.4.0 Culture=neutral PublicKeyToken=31bf3856ad364e35'. The system cannot find the file specified..
2&gt;System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
2&gt;   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
2&gt;   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
2&gt;   at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\23\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 528
2&gt;-- Code Generation FAILED --
2&gt;
2&gt;Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Azure.Cosmos.Direct Version=3.1.4.0 Culture=neutral PublicKeyToken=31bf3856ad364e35'. The system cannot find the file specified.
2&gt;   at System.RuntimeTypeHandle.GetDeclaringType(RuntimeType type)
2&gt;   at System.RuntimeType.RuntimeTypeCache.GetEnclosingType()
2&gt;   at System.RuntimeType.RuntimeTypeCache.GetNameSpace()
2&gt;   at System.RuntimeType.get_Namespace()
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.AddNamespace(StringBuilder builder Type type) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 72
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.Format(StringBuilder builder Type type Boolean isElementType) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 61
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.&lt;&gt;c.&lt;Format&gt;g__FormatType|3_0(Type t) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 36
2&gt;   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
2&gt;   at Orleans.Utilities.CachedReadConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\CachedReadConcurrentDictionary.cs:line 152
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.Format(Type type) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 28
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.AddSerializationTypes(SerializationTypeDescriptions serializationTypes Assembly targetAssembly List`1 assemblies) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 459
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateCode(Assembly targetAssembly List`1 assemblies) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 345
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateSourceForAssembly(Assembly input) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 162
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
2&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
```

I believe the issue is caused by Roslyn code generator trying to load all references assemblies and Microsoft.Azure.Cosmos.Direct package is somehow optional for Cosmos SDK and not always present.

I think Azure Cosmos SDK 3.0 has an issue with async (tasks are hanging when calling SDK from with in a grain - I saw a similar problem in SDK 2.0) and I'm trying to prepare a repro for Cosmos DB Team.

Attached is the repro project.
[Repro.zip](https://github.com/dotnet/orleans/files/3563394/Repro.zip)

cc: @ReubenBond </Description>
    <Title_Description>Roslyn code generator fails when Azure Cosmos DB SDK 3.0 is references by a grain When using Azure Cosmos DB SDK 3.0 inside a grain (even without adding Cosmos SDK types to method declaration) the build fails with error: 

```
2&gt;      Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Azure.Cosmos.Direct Version=3.1.4.0 Culture=neutral PublicKeyToken=31bf3856ad364e35'. The system cannot find the file specified..
2&gt;System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
2&gt;   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
2&gt;   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
2&gt;   at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\23\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 528
2&gt;-- Code Generation FAILED --
2&gt;
2&gt;Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Azure.Cosmos.Direct Version=3.1.4.0 Culture=neutral PublicKeyToken=31bf3856ad364e35'. The system cannot find the file specified.
2&gt;   at System.RuntimeTypeHandle.GetDeclaringType(RuntimeType type)
2&gt;   at System.RuntimeType.RuntimeTypeCache.GetEnclosingType()
2&gt;   at System.RuntimeType.RuntimeTypeCache.GetNameSpace()
2&gt;   at System.RuntimeType.get_Namespace()
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.AddNamespace(StringBuilder builder Type type) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 72
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.Format(StringBuilder builder Type type Boolean isElementType) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 61
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.&lt;&gt;c.&lt;Format&gt;g__FormatType|3_0(Type t) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 36
2&gt;   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
2&gt;   at Orleans.Utilities.CachedReadConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\CachedReadConcurrentDictionary.cs:line 152
2&gt;   at Orleans.Utilities.RuntimeTypeNameFormatter.Format(Type type) in D:\build\agent\_work\23\s\src\Orleans.Core\Utils\RuntimeTypeNameFormatter.cs:line 28
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.AddSerializationTypes(SerializationTypeDescriptions serializationTypes Assembly targetAssembly List`1 assemblies) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 459
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateCode(Assembly targetAssembly List`1 assemblies) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 345
2&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateSourceForAssembly(Assembly input) in D:\build\agent\_work\23\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 162
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
2&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
2&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
```

I believe the issue is caused by Roslyn code generator trying to load all references assemblies and Microsoft.Azure.Cosmos.Direct package is somehow optional for Cosmos SDK and not always present.

I think Azure Cosmos SDK 3.0 has an issue with async (tasks are hanging when calling SDK from with in a grain - I saw a similar problem in SDK 2.0) and I'm trying to prepare a repro for Cosmos DB Team.

Attached is the repro project.
[Repro.zip](https://github.com/dotnet/orleans/files/3563394/Repro.zip)

cc: @ReubenBond </Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5922</IssueLabelID>
    <Title>Exceptions during graceful shutdown</Title>
    <Description>I am getting exceptions after trying to gracefully shutdown one of two silos. And sometimes silo can't shutdown at all and just hangs.

On the silo that being shutdown:
```
warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/PublicationContent/000055ed@f9fbaa9b trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/LinkToPublication/00000000+http://***/Center/news?id=1027267@d565b0a1 trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/PublicationContent/00005253@48188ba0 trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

fail Orleans.Runtime.Dispatcher
     SelectTarget failed with Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/SmiGrain/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/721BE62B/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.

fail Orleans.Runtime.Catalog
     Failed to RegisterActivationInGrainDirectory for [Activation: S127.0.0.1:11112:304870915*grn/PublicationContent/00005254@6f2869a6 #GrainType=OrleansTesting.Grains.Publications.PublicationContent Placement=RandomPlacement State=Invalid].
       ExceptionType System.ArgumentNullException
       ExceptionMessage Value cannot be null.
Parameter name: existingActivationAddress
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.Catalog.RegisterActivationInGrainDirectoryAndValidate(ActivationData activation) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 0
   at Orleans.Runtime.Catalog.InitActivation(ActivationData activation String grainType String genericArguments Dictionary`2 requestContextData) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 546
   
   fail Orleans.Runtime.HostedClient
     RunClientMessagePump has thrown exception
       ExceptionType System.OperationCanceledException
       ExceptionMessage The operation was canceled.
       ExceptionSource System.Collections.Concurrent
       ExceptionStackTrace    at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take(CancellationToken cancellationToken)
   at Orleans.Runtime.HostedClient.RunClientMessagePump() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\HostedClient.cs:line 0
   
   fail Orleans.Runtime.Catalog
     UnregisterManyAsync 84 failed.
       ExceptionType System.InvalidOperationException
       ExceptionMessage Grain directory is stopping
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 563
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 726
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 773
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 995
       ExceptionEntryAssembly OrleansTesting.Silo Version=1.0.0.0 Culture=neutral PublicKeyToken=null

```

On client \ live silo:
```
fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/CBBF4FF4/00000000+baltija.eu (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime

fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/7B5BF3AD/00005223 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime

fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/721BE62B/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime
	   
	   fail Orleans.Runtime.Dispatcher
     SelectTarget failed with Current directory at S127.0.0.1:11111:304875582 is not stable to perform the lookup for grainId *grn/PublicationContent/00005be7 (it maps to S127.0.0.1:11112:304875663 which is not a valid silo). Retry later.
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304875582 is not stable to perform the lookup for grainId *grn/E1CB458F/00005be7 (it maps to S127.0.0.1:11112:304875663 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.LookupAsync(GrainId grainId Int32 hopCount) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 928
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 94
   at Orleans.Runtime.Placement.RandomPlacementDirector.OnSelectActivation(PlacementStrategy strategy GrainId target IPlacementRuntime context) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Placement\RandomPlacementDirector.cs:line 15
   at Orleans.Runtime.Placement.PlacementDirectorsManager.SelectOrAddActivation(ActivationAddress sendingAddress PlacementTarget targetGrain IPlacementRuntime context PlacementStrategy strategy) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Placement\PlacementDirectorsManager.cs:line 97
   at Orleans.Runtime.Dispatcher.AddressMessageAsync(Message message PlacementTarget target PlacementStrategy strategy ActivationAddress targetAddress) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\Dispatcher.cs:line 788
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\Dispatcher.cs:line 704
```

</Description>
    <Title_Description>Exceptions during graceful shutdown I am getting exceptions after trying to gracefully shutdown one of two silos. And sometimes silo can't shutdown at all and just hangs.

On the silo that being shutdown:
```
warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/PublicationContent/000055ed@f9fbaa9b trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/LinkToPublication/00000000+http://***/Center/news?id=1027267@d565b0a1 trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

warn Orleans.Runtime.GrainDirectory.LocalGrainDirectory
     RegisterAsync - It seems we are not the owner of activation S127.0.0.1:11111:304870891*grn/PublicationContent/00005253@48188ba0 trying to forward it to S127.0.0.1:11111:304870891 (hopCount=1)

fail Orleans.Runtime.Dispatcher
     SelectTarget failed with Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/SmiGrain/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/721BE62B/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.

fail Orleans.Runtime.Catalog
     Failed to RegisterActivationInGrainDirectory for [Activation: S127.0.0.1:11112:304870915*grn/PublicationContent/00005254@6f2869a6 #GrainType=OrleansTesting.Grains.Publications.PublicationContent Placement=RandomPlacement State=Invalid].
       ExceptionType System.ArgumentNullException
       ExceptionMessage Value cannot be null.
Parameter name: existingActivationAddress
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.Catalog.RegisterActivationInGrainDirectoryAndValidate(ActivationData activation) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 0
   at Orleans.Runtime.Catalog.InitActivation(ActivationData activation String grainType String genericArguments Dictionary`2 requestContextData) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 546
   
   fail Orleans.Runtime.HostedClient
     RunClientMessagePump has thrown exception
       ExceptionType System.OperationCanceledException
       ExceptionMessage The operation was canceled.
       ExceptionSource System.Collections.Concurrent
       ExceptionStackTrace    at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take(CancellationToken cancellationToken)
   at Orleans.Runtime.HostedClient.RunClientMessagePump() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\HostedClient.cs:line 0
   
   fail Orleans.Runtime.Catalog
     UnregisterManyAsync 84 failed.
       ExceptionType System.InvalidOperationException
       ExceptionMessage Grain directory is stopping
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 563
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 726
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 773
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Catalog\Catalog.cs:line 995
       ExceptionEntryAssembly OrleansTesting.Silo Version=1.0.0.0 Culture=neutral PublicKeyToken=null

```

On client \ live silo:
```
fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/CBBF4FF4/00000000+baltija.eu (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime

fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/7B5BF3AD/00005223 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime

fail 
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304870891 is not stable to perform the lookup for grainId *grn/721BE62B/000002c5 (it maps to S127.0.0.1:11112:304870915 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime
	   
	   fail Orleans.Runtime.Dispatcher
     SelectTarget failed with Current directory at S127.0.0.1:11111:304875582 is not stable to perform the lookup for grainId *grn/PublicationContent/00005be7 (it maps to S127.0.0.1:11112:304875663 which is not a valid silo). Retry later.
       ExceptionType Orleans.Runtime.OrleansException
       ExceptionMessage Current directory at S127.0.0.1:11111:304875582 is not stable to perform the lookup for grainId *grn/E1CB458F/00005be7 (it maps to S127.0.0.1:11112:304875663 which is not a valid silo). Retry later.
       ExceptionSource Orleans.Runtime
       ExceptionStackTrace    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.LookupAsync(GrainId grainId Int32 hopCount) in D:\build\agent\_work\12\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 928
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 94
   at Orleans.Runtime.Placement.RandomPlacementDirector.OnSelectActivation(PlacementStrategy strategy GrainId target IPlacementRuntime context) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Placement\RandomPlacementDirector.cs:line 15
   at Orleans.Runtime.Placement.PlacementDirectorsManager.SelectOrAddActivation(ActivationAddress sendingAddress PlacementTarget targetGrain IPlacementRuntime context PlacementStrategy strategy) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Placement\PlacementDirectorsManager.cs:line 97
   at Orleans.Runtime.Dispatcher.AddressMessageAsync(Message message PlacementTarget target PlacementStrategy strategy ActivationAddress targetAddress) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\Dispatcher.cs:line 788
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\Dispatcher.cs:line 704
```

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5918</IssueLabelID>
    <Title>Exception when deserializing an empty array.</Title>
    <Description>I think that the problem is in the **TryCheckLengthFast** method of the **BinaryTokenStreamReader** class which can return null if argument passed to parameter **n** is 0.

Log message:
```
Exception trying to process 972 bytes from endpoint 10.0.0.16:57786
ExceptionMessage: Value cannot be null. Parameter name: src
```
Stack trace:
```
 at System.Buffer.BlockCopy(Array src Int32 srcOffset Array dst Int32 dstOffset Int32 count)
   at Orleans.Serialization.BinaryTokenStreamReader.ReadBlockInto(Array array Int32 n)
   at Orleans.Serialization.SerializationManager.DeserializeArray(Type resultType IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e)
```

Orleans version: 2.4.1</Description>
    <Title_Description>Exception when deserializing an empty array. I think that the problem is in the **TryCheckLengthFast** method of the **BinaryTokenStreamReader** class which can return null if argument passed to parameter **n** is 0.

Log message:
```
Exception trying to process 972 bytes from endpoint 10.0.0.16:57786
ExceptionMessage: Value cannot be null. Parameter name: src
```
Stack trace:
```
 at System.Buffer.BlockCopy(Array src Int32 srcOffset Array dst Int32 dstOffset Int32 count)
   at Orleans.Serialization.BinaryTokenStreamReader.ReadBlockInto(Array array Int32 n)
   at Orleans.Serialization.SerializationManager.DeserializeArray(Type resultType IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e)
```

Orleans version: 2.4.1</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5917</IssueLabelID>
    <Title>Stateless worker local compatibility check</Title>
    <Description>This changes the placement of stateless workers to not just blindly choose the local silo as the target. Instead we check if the local silo is compatible first if it is then we choose it otherwise we back off to the random logic which we previously used when the silo was shutting down.</Description>
    <Title_Description>Stateless worker local compatibility check This changes the placement of stateless workers to not just blindly choose the local silo as the target. Instead we check if the local silo is compatible first if it is then we choose it otherwise we back off to the random logic which we previously used when the silo was shutting down.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5916</IssueLabelID>
    <Title>[2.4.2] Fix default value for MaxMessageHeaderSize and MaxMessageBodySize</Title>
    <Description>
    </Description>
    <Title_Description>[2.4.2] Fix default value for MaxMessageHeaderSize and MaxMessageBodySize </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5915</IssueLabelID>
    <Title>[@ReubenBond] [2.4.2] Remove SAEA pooling</Title>
    <Description>Remove pooling of `SocketAsyncEventArg`s. We suspect there's a bug there that occasionally leads to corruption of read data.</Description>
    <Title_Description>[@ReubenBond] [2.4.2] Remove SAEA pooling Remove pooling of `SocketAsyncEventArg`s. We suspect there's a bug there that occasionally leads to corruption of read data.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5914</IssueLabelID>
    <Title>Lease based queue balancer refactor.</Title>
    <Description>No longer uses deployment configuration.
Serialize changes to avoid interleaving.
More configuration options.
Conformed configuration patterns to Orleans common patterns including replacing the azure blob lease settings with options.</Description>
    <Title_Description>Lease based queue balancer refactor. No longer uses deployment configuration.
Serialize changes to avoid interleaving.
More configuration options.
Conformed configuration patterns to Orleans common patterns including replacing the azure blob lease settings with options.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5913</IssueLabelID>
    <Title>Code generator: Same type parameter + method name gives duplicated symbols</Title>
    <Description>```c#
namespace Test
{
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Threading.Tasks;
    using Orleans.Runtime;

    public interface ITestExtension : IGrainExtension
    {
        Task Test&lt;T&gt;(IReadOnlyCollection&lt;T&gt; collection);
        Task Test&lt;T&gt;(IImmutableList&lt;T&gt; collection);
    }
}
```

Result:
```c#
[...]

namespace Test
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("OrleansCodeGen" "2.0.0.0") global::Orleans.CodeGeneration.MethodInvokerAttribute(typeof(global::Test.ITestExtension) (int)0x5EA11346) global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
    internal class OrleansCodeGenTestExtensionMethodInvoker : global::Orleans.CodeGeneration.IGrainMethodInvoker global::Orleans.CodeGeneration.IGrainExtensionMethodInvoker
    {
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
        public async global::System.Threading.Tasks.Task&lt;object&gt; Invoke(global::Orleans.Runtime.IAddressable grain global::Orleans.CodeGeneration.InvokeMethodRequest request)
        {
            int interfaceId = request.InterfaceId;
            int methodId = request.MethodId;
            var arguments = request.Arguments;
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    var casted = ((global::Test.ITestExtension)grain);
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return await TestT.Invoke(casted arguments);
                        case unchecked((int)0xB5C8094A):
                            return await TestT.Invoke(casted arguments);
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }

        public int InterfaceId =&gt; (int)0x5EA11346;
        public ushort InterfaceVersion =&gt; 0;
        public async global::System.Threading.Tasks.Task&lt;object&gt; Invoke(global::Orleans.Runtime.IGrainExtension extension global::Orleans.CodeGeneration.InvokeMethodRequest request)
        {
            int interfaceId = request.InterfaceId;
            int methodId = request.MethodId;
            var arguments = request.Arguments;
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    var casted = ((global::Test.ITestExtension)extension);
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return await TestT.Invoke(casted arguments);
                        case unchecked((int)0xB5C8094A):
                            return await TestT.Invoke(casted arguments);
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("OrleansCodeGen" "2.0.0.0") global::System.SerializableAttribute global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute global::Orleans.CodeGeneration.GrainReferenceAttribute(typeof(global::Test.ITestExtension))]
    internal class OrleansCodeGenTestExtensionReference : global::Orleans.Runtime.GrainReference global::Test.ITestExtension
    {
        OrleansCodeGenTestExtensionReference(global::Orleans.Runtime.GrainReference other): base(other)
        {
        }

        OrleansCodeGenTestExtensionReference(global::Orleans.Runtime.GrainReference other global::Orleans.CodeGeneration.InvokeMethodOptions invokeMethodOptions): base(other invokeMethodOptions)
        {
        }

        OrleansCodeGenTestExtensionReference(global::System.Runtime.Serialization.SerializationInfo info global::System.Runtime.Serialization.StreamingContext context): base(info context)
        {
        }

        public override int InterfaceId =&gt; (int)0x5EA11346;
        public override ushort InterfaceVersion =&gt; 0;
        public override string InterfaceName =&gt; "ITestExtension";
        public override bool IsCompatible(int interfaceId) =&gt; interfaceId == (int)0x5EA11346;
        public override string GetMethodName(int interfaceId int methodId)
        {
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return "Test";
                        case unchecked((int)0xB5C8094A):
                            return "Test";
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }

        global::System.Threading.Tasks.Task global::Test.ITestExtension.Test&lt;T&gt;(global::System.Collections.Generic.IReadOnlyCollection&lt;T&gt; collection)
        {
            return base.InvokeMethodAsync&lt;object&gt;((int)0xAD463D3 new object[]{typeof(T) collection});
        }

        global::System.Threading.Tasks.Task global::Test.ITestExtension.Test&lt;T&gt;(global::System.Collections.Immutable.IImmutableList&lt;T&gt; collection)
        {
            return base.InvokeMethodAsync&lt;object&gt;(unchecked((int)0xB5C8094A) new object[]{typeof(T) collection});
        }
    }
}

[...]
```

Note the two exact lines
```c#
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
```

I'm not sure if that's the only generated issue.

Renaming one of the methods or renaming one of the `T`s resolves the issue. I'm doing the latter right now as a workaround since I don't want to change my API naming here.</Description>
    <Title_Description>Code generator: Same type parameter + method name gives duplicated symbols ```c#
namespace Test
{
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Threading.Tasks;
    using Orleans.Runtime;

    public interface ITestExtension : IGrainExtension
    {
        Task Test&lt;T&gt;(IReadOnlyCollection&lt;T&gt; collection);
        Task Test&lt;T&gt;(IImmutableList&lt;T&gt; collection);
    }
}
```

Result:
```c#
[...]

namespace Test
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("OrleansCodeGen" "2.0.0.0") global::Orleans.CodeGeneration.MethodInvokerAttribute(typeof(global::Test.ITestExtension) (int)0x5EA11346) global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
    internal class OrleansCodeGenTestExtensionMethodInvoker : global::Orleans.CodeGeneration.IGrainMethodInvoker global::Orleans.CodeGeneration.IGrainExtensionMethodInvoker
    {
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
        public async global::System.Threading.Tasks.Task&lt;object&gt; Invoke(global::Orleans.Runtime.IAddressable grain global::Orleans.CodeGeneration.InvokeMethodRequest request)
        {
            int interfaceId = request.InterfaceId;
            int methodId = request.MethodId;
            var arguments = request.Arguments;
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    var casted = ((global::Test.ITestExtension)grain);
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return await TestT.Invoke(casted arguments);
                        case unchecked((int)0xB5C8094A):
                            return await TestT.Invoke(casted arguments);
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }

        public int InterfaceId =&gt; (int)0x5EA11346;
        public ushort InterfaceVersion =&gt; 0;
        public async global::System.Threading.Tasks.Task&lt;object&gt; Invoke(global::Orleans.Runtime.IGrainExtension extension global::Orleans.CodeGeneration.InvokeMethodRequest request)
        {
            int interfaceId = request.InterfaceId;
            int methodId = request.MethodId;
            var arguments = request.Arguments;
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    var casted = ((global::Test.ITestExtension)extension);
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return await TestT.Invoke(casted arguments);
                        case unchecked((int)0xB5C8094A):
                            return await TestT.Invoke(casted arguments);
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("OrleansCodeGen" "2.0.0.0") global::System.SerializableAttribute global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute global::Orleans.CodeGeneration.GrainReferenceAttribute(typeof(global::Test.ITestExtension))]
    internal class OrleansCodeGenTestExtensionReference : global::Orleans.Runtime.GrainReference global::Test.ITestExtension
    {
        OrleansCodeGenTestExtensionReference(global::Orleans.Runtime.GrainReference other): base(other)
        {
        }

        OrleansCodeGenTestExtensionReference(global::Orleans.Runtime.GrainReference other global::Orleans.CodeGeneration.InvokeMethodOptions invokeMethodOptions): base(other invokeMethodOptions)
        {
        }

        OrleansCodeGenTestExtensionReference(global::System.Runtime.Serialization.SerializationInfo info global::System.Runtime.Serialization.StreamingContext context): base(info context)
        {
        }

        public override int InterfaceId =&gt; (int)0x5EA11346;
        public override ushort InterfaceVersion =&gt; 0;
        public override string InterfaceName =&gt; "ITestExtension";
        public override bool IsCompatible(int interfaceId) =&gt; interfaceId == (int)0x5EA11346;
        public override string GetMethodName(int interfaceId int methodId)
        {
            switch (interfaceId)
            {
                case (int)0x5EA11346:
                {
                    switch (methodId)
                    {
                        case (int)0xAD463D3:
                            return "Test";
                        case unchecked((int)0xB5C8094A):
                            return "Test";
                        default:
                            ThrowMethodNotImplemented(interfaceId methodId);
                            return null;
                    }
                }

                default:
                    ThrowInterfaceNotImplemented(interfaceId);
                    return null;
            }

            void ThrowInterfaceNotImplemented(int i) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X}");
            void ThrowMethodNotImplemented(int i int m) =&gt; throw new global::System.NotImplementedException($"InterfaceId: 0x{i:X} MethodId: 0x{m:X}");
        }

        global::System.Threading.Tasks.Task global::Test.ITestExtension.Test&lt;T&gt;(global::System.Collections.Generic.IReadOnlyCollection&lt;T&gt; collection)
        {
            return base.InvokeMethodAsync&lt;object&gt;((int)0xAD463D3 new object[]{typeof(T) collection});
        }

        global::System.Threading.Tasks.Task global::Test.ITestExtension.Test&lt;T&gt;(global::System.Collections.Immutable.IImmutableList&lt;T&gt; collection)
        {
            return base.InvokeMethodAsync&lt;object&gt;(unchecked((int)0xB5C8094A) new object[]{typeof(T) collection});
        }
    }
}

[...]
```

Note the two exact lines
```c#
        private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker TestT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Test.ITestExtension) "Test" 1);
```

I'm not sure if that's the only generated issue.

Renaming one of the methods or renaming one of the `T`s resolves the issue. I'm doing the latter right now as a workaround since I don't want to change my API naming here.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5912</IssueLabelID>
    <Title>Add "UseSiloUnobservedExceptionsHandler" extensions to the ISiloBuilder</Title>
    <Description>ISiloBuilder missing "UseSiloUnobservedExceptionsHandler" extensions  this PR fixed it</Description>
    <Title_Description>Add "UseSiloUnobservedExceptionsHandler" extensions to the ISiloBuilder ISiloBuilder missing "UseSiloUnobservedExceptionsHandler" extensions  this PR fixed it</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5906</IssueLabelID>
    <Title>[Question] Is is possible to run Orleans on top of Kestrel?</Title>
    <Description>Is it possible to run Orleans on top of Kestrel given the networking rewrite from 3.0? Is there an example of this or a hint over how I might achieve this (if possible)?

Will this enable scale-out scenarios using Azure App Services? 
</Description>
    <Title_Description>[Question] Is is possible to run Orleans on top of Kestrel? Is it possible to run Orleans on top of Kestrel given the networking rewrite from 3.0? Is there an example of this or a hint over how I might achieve this (if possible)?

Will this enable scale-out scenarios using Azure App Services? 
</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5905</IssueLabelID>
    <Title>Managing grains without subclassing: Getting the IGrainActivationContext?</Title>
    <Description># Summary

I need a `Grain` instance to pass to `IGrainRuntime.DeactivateOnIdle` and other public accessible API - how do I get that without forcing the target grain type to have a reference to a `GrainServiceClient` that then itself can get to the `IGrainActivationContext`?

Should `Grain.Data` be `public` instead of `internal`? Is it a bad idea?

# Issue

How do you handle such things like using the API that is (seemingly) only available to grains themselves? E.g. `RegisterTimer` `DelayDeactivation` and `DeactivateOnIdle`. I want to call such API from some managing grains "from the outside".

## Example

I have some patterns like a grain that should be kept alive. I want to re-use the implementation of that pattern but I don't like having this as a grain superclass to inherit from - composition is really needed here instead as I have various differences in the kinds of grain implementations and we can't have multiple superclasses of course :smile:

What I ended up with are three things basically:
* An interface with a single method `StayActivated` that literally does nothing and just returns `Task.Completed`. (Thanks to C# 8's default interface implementations this is basically just a marker interface and needs no copy-pasta in each implementing grain!)
* A `GrainServiceClient` which any implementing grain gets via constructor injection then keeps a reference and calls `KeepActivated(this)` or `AllowDeactivation(this)` whenever necessary. This client is added as a **scoped** service to ensure client instance gets the correct `IGrainActivationContext`.
* A `GrainService` to keep a list of all grains to repeatedly call `StayActivated` on.

The only reason this works is because I can get to calling the `Grain` instance in the client via `IGrainActivationContext.GrainInstance`. After the client delays the activation it also calls into the `GrainService` as I don't want the scoped client to do the keep-alive logic - it dies with the grain getting deactivated after all AFAIK.

While this allows me to re-use this pattern implementation now by just

* Tagging the grain types with the interface.
* Adding a constructor argument + reference to the `GrainServiceClient`.
* Calling the client's methods.

**I am still having a need to allow "outsiders" to tell the service to keep a different grain activated.**</Description>
    <Title_Description>Managing grains without subclassing: Getting the IGrainActivationContext? # Summary

I need a `Grain` instance to pass to `IGrainRuntime.DeactivateOnIdle` and other public accessible API - how do I get that without forcing the target grain type to have a reference to a `GrainServiceClient` that then itself can get to the `IGrainActivationContext`?

Should `Grain.Data` be `public` instead of `internal`? Is it a bad idea?

# Issue

How do you handle such things like using the API that is (seemingly) only available to grains themselves? E.g. `RegisterTimer` `DelayDeactivation` and `DeactivateOnIdle`. I want to call such API from some managing grains "from the outside".

## Example

I have some patterns like a grain that should be kept alive. I want to re-use the implementation of that pattern but I don't like having this as a grain superclass to inherit from - composition is really needed here instead as I have various differences in the kinds of grain implementations and we can't have multiple superclasses of course :smile:

What I ended up with are three things basically:
* An interface with a single method `StayActivated` that literally does nothing and just returns `Task.Completed`. (Thanks to C# 8's default interface implementations this is basically just a marker interface and needs no copy-pasta in each implementing grain!)
* A `GrainServiceClient` which any implementing grain gets via constructor injection then keeps a reference and calls `KeepActivated(this)` or `AllowDeactivation(this)` whenever necessary. This client is added as a **scoped** service to ensure client instance gets the correct `IGrainActivationContext`.
* A `GrainService` to keep a list of all grains to repeatedly call `StayActivated` on.

The only reason this works is because I can get to calling the `Grain` instance in the client via `IGrainActivationContext.GrainInstance`. After the client delays the activation it also calls into the `GrainService` as I don't want the scoped client to do the keep-alive logic - it dies with the grain getting deactivated after all AFAIK.

While this allows me to re-use this pattern implementation now by just

* Tagging the grain types with the interface.
* Adding a constructor argument + reference to the `GrainServiceClient`.
* Calling the client's methods.

**I am still having a need to allow "outsiders" to tell the service to keep a different grain activated.**</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5903</IssueLabelID>
    <Title>Orleans.GRPC</Title>
    <Description>As described in issue https://github.com/dotnet/orleans/issues/3190 microservices become popular and of most popular solution is using protobuf with GRPC srevices. 
And I think it will be more interesting if use will have choice of using HTTP or GRPC to using Orleans backend. 

So what I propose is generating protobuf models from c# interfaces that could be translated to http\grpc with swagger support.</Description>
    <Title_Description>Orleans.GRPC As described in issue https://github.com/dotnet/orleans/issues/3190 microservices become popular and of most popular solution is using protobuf with GRPC srevices. 
And I think it will be more interesting if use will have choice of using HTTP or GRPC to using Orleans backend. 

So what I propose is generating protobuf models from c# interfaces that could be translated to http\grpc with swagger support.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>24/08/2019 1:07:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5899</IssueLabelID>
    <Title>Close client connection on serialization error.</Title>
    <Description>Close client connection on serialization error to avoid data corruption from client.</Description>
    <Title_Description>Close client connection on serialization error. Close client connection on serialization error to avoid data corruption from client.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5898</IssueLabelID>
    <Title>Force connection close when a silo is failing ping probe</Title>
    <Description>
    </Description>
    <Title_Description>Force connection close when a silo is failing ping probe </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5896</IssueLabelID>
    <Title>Stream batch delivery allows premature purge of cache data</Title>
    <Description>When using persistent streams and StreamPullingAgentOptions.BatchContainerBatchSize is configured to a value greater than 1 messages from cache will be batched together to be sent to consumers.  This logic moves the consumers cursor in the cache to the last message in the batch allowing all previous messages which may not have yet been successfully delivered to the consumer to be eligible to be purged from the cache which should not be the case since the consumer may not have had a chance to successfully process them.

This could result in unexpected DataNotAvailable exceptions.</Description>
    <Title_Description>Stream batch delivery allows premature purge of cache data When using persistent streams and StreamPullingAgentOptions.BatchContainerBatchSize is configured to a value greater than 1 messages from cache will be batched together to be sent to consumers.  This logic moves the consumers cursor in the cache to the last message in the batch allowing all previous messages which may not have yet been successfully delivered to the consumer to be eligible to be purged from the cache which should not be the case since the consumer may not have had a chance to successfully process them.

This could result in unexpected DataNotAvailable exceptions.</Title_Description>
    <Label>bug</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5888</IssueLabelID>
    <Title>Fix NullReferenceException in AQStreamsBatchingTests.Dispose</Title>
    <Description>
    </Description>
    <Title_Description>Fix NullReferenceException in AQStreamsBatchingTests.Dispose </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5887</IssueLabelID>
    <Title>Improve graceful deactivation of grains performing transaction work</Title>
    <Description>This PR is mostly intended to reduce log noise since this behavior is benign. Nevertheless I believe it's worthwhile to clean up the behavior here.

If a grain fails to fully activate and has some transaction processing work which need to be performed then it's possible for the grain to get into a state where the background transaction workers will never terminate.

Additionally when a grain deactivates while it's performing background transaction work we may emit a warning to the effect of `"Enqueuing task {Task} to a work item group which should have terminated. Likely reasons are that the task is not being 'awaited' properly or a TaskScheduler was captured and is being used to schedule tasks after a grain has been deactivated."`
This PR attempts to prevent this situation by blocking deactivation until the background workers are aware of it and can gracefully terminate.</Description>
    <Title_Description>Improve graceful deactivation of grains performing transaction work This PR is mostly intended to reduce log noise since this behavior is benign. Nevertheless I believe it's worthwhile to clean up the behavior here.

If a grain fails to fully activate and has some transaction processing work which need to be performed then it's possible for the grain to get into a state where the background transaction workers will never terminate.

Additionally when a grain deactivates while it's performing background transaction work we may emit a warning to the effect of `"Enqueuing task {Task} to a work item group which should have terminated. Likely reasons are that the task is not being 'awaited' properly or a TaskScheduler was captured and is being used to schedule tasks after a grain has been deactivated."`
This PR attempts to prevent this situation by blocking deactivation until the background workers are aware of it and can gracefully terminate.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5886</IssueLabelID>
    <Title>InterfaceMethod null in call filter</Title>
    <Description>We have a call filter to log errors. After migrating from 2.2 (core) and 2.0 (server) to more recent versions (2.4.1) we noticed that some of these methods are empty. The correct method is still being called though.

We noticed the problem with a method called "Create" but the same name on another grain works just fine. Because it works fine on another grain I don't think we can work on reproduction code easily is there something I can send you (like the generated code) that could help you look into this?

I don't think our call filter itself is very out-of-the-ordinary:

```
public class ErrorHandlingCallFilter : IIncomingGrainCallFilter
{
    public ErrorHandlingCallFilter(ILogger&lt;ErrorHandlingCallFilter&gt; logger) ...

    public async Task Invoke(IIncomingGrainCallContext context)
    {
    	try
    	{
    		await context.Invoke();
    	}
    	catch (Exception exception)
    	{
    		// context.InterfaceMethod is null
    		await logger.Error(context.Grain.GetPrimaryKeyString() context.InterfaceMethod?.Name exception);
    	}
    }
}
```</Description>
    <Title_Description>InterfaceMethod null in call filter We have a call filter to log errors. After migrating from 2.2 (core) and 2.0 (server) to more recent versions (2.4.1) we noticed that some of these methods are empty. The correct method is still being called though.

We noticed the problem with a method called "Create" but the same name on another grain works just fine. Because it works fine on another grain I don't think we can work on reproduction code easily is there something I can send you (like the generated code) that could help you look into this?

I don't think our call filter itself is very out-of-the-ordinary:

```
public class ErrorHandlingCallFilter : IIncomingGrainCallFilter
{
    public ErrorHandlingCallFilter(ILogger&lt;ErrorHandlingCallFilter&gt; logger) ...

    public async Task Invoke(IIncomingGrainCallContext context)
    {
    	try
    	{
    		await context.Invoke();
    	}
    	catch (Exception exception)
    	{
    		// context.InterfaceMethod is null
    		await logger.Error(context.Grain.GetPrimaryKeyString() context.InterfaceMethod?.Name exception);
    	}
    }
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5885</IssueLabelID>
    <Title>Race condition with streams when AllowCallChainReentrancy is enabled.</Title>
    <Description>When A sends a message through a stream to B1 and B2 and both of them calls A in the event handler the calls B1-&gt;A and B2-&gt;A interleave.

```
      /-------&gt; B1 -------------\
     / (Stream)    (Direct call) \
A ---                             ---&gt; A
     \ (Stream)    (Direct call) /
      \-------&gt; B2 -------------/
        ^^^^^^
These two arrive at the same time and both are allowed to interleave because of
call chain reentrancy. They should be allowed to interleave individually but not each other.
```</Description>
    <Title_Description>Race condition with streams when AllowCallChainReentrancy is enabled. When A sends a message through a stream to B1 and B2 and both of them calls A in the event handler the calls B1-&gt;A and B2-&gt;A interleave.

```
      /-------&gt; B1 -------------\
     / (Stream)    (Direct call) \
A ---                             ---&gt; A
     \ (Stream)    (Direct call) /
      \-------&gt; B2 -------------/
        ^^^^^^
These two arrive at the same time and both are allowed to interleave because of
call chain reentrancy. They should be allowed to interleave individually but not each other.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5884</IssueLabelID>
    <Title>ActivationCollector found an active activation in it's last bucket</Title>
    <Description>Some Grain  cannot work and cannot be collected
log text:
ActivationCollector found an active activation in it's last bucket. This is violation of ActivationCollector invariants.

seach log text
https://github.com/dotnet/orleans/blob/7a85122752c6b597415e0bc59add762fdf250799/src/Orleans.Runtime/Catalog/ActivationCollector.cs#L222

How to avoid this problem?</Description>
    <Title_Description>ActivationCollector found an active activation in it's last bucket Some Grain  cannot work and cannot be collected
log text:
ActivationCollector found an active activation in it's last bucket. This is violation of ActivationCollector invariants.

seach log text
https://github.com/dotnet/orleans/blob/7a85122752c6b597415e0bc59add762fdf250799/src/Orleans.Runtime/Catalog/ActivationCollector.cs#L222

How to avoid this problem?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5883</IssueLabelID>
    <Title>Improve codegen's .NET Core 3 compatibility 2</Title>
    <Description>fixes #5880 

The fix allows the codegen for dotnet to use a runtime &gt;= 3.0.0 as fallback if the 2.0 runtime cannot be found. This allow code generation in only dotnet 3.0 environments.

The changes are the same as for #5799 for the MSBuild codegenerator.

I also included the codegenerator in Bootstrap so that building Orleans itself is now possible only with a dotnet 3.0 runtime.

It maybe a good idea to do that for the MSBuild codegen in Bootstrap too. Should I include the change in this pull request?

Thanks

Frank</Description>
    <Title_Description>Improve codegen's .NET Core 3 compatibility 2 fixes #5880 

The fix allows the codegen for dotnet to use a runtime &gt;= 3.0.0 as fallback if the 2.0 runtime cannot be found. This allow code generation in only dotnet 3.0 environments.

The changes are the same as for #5799 for the MSBuild codegenerator.

I also included the codegenerator in Bootstrap so that building Orleans itself is now possible only with a dotnet 3.0 runtime.

It maybe a good idea to do that for the MSBuild codegen in Bootstrap too. Should I include the change in this pull request?

Thanks

Frank</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5882</IssueLabelID>
    <Title>Reminders spinning up on silos with different clusterId</Title>
    <Description>Hi I have an orleans setup where we have different silos with different clusterId's (staging dev prod etc). I noticed that every now and then a reminder that was created on staging would spin up in dev silos.

I am using AdoNetReminderService with SQL Server when I looked at the ReminderTable I noticed that it only had ServiceId as the column no reference to ClusterId so I changed all of the silos to have different serviceId's to prevent the issue. However it was brought to my attention that the Orleans documentation recommends keeping all of the ServiceId's of the silos the same. Am I missing anything? Are reminders supposed to be able to distinguish between silos with different clusterId's even with same ServiceId's?</Description>
    <Title_Description>Reminders spinning up on silos with different clusterId Hi I have an orleans setup where we have different silos with different clusterId's (staging dev prod etc). I noticed that every now and then a reminder that was created on staging would spin up in dev silos.

I am using AdoNetReminderService with SQL Server when I looked at the ReminderTable I noticed that it only had ServiceId as the column no reference to ClusterId so I changed all of the silos to have different serviceId's to prevent the issue. However it was brought to my attention that the Orleans documentation recommends keeping all of the ServiceId's of the silos the same. Am I missing anything? Are reminders supposed to be able to distinguish between silos with different clusterId's even with same ServiceId's?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5881</IssueLabelID>
    <Title>Protect ClientState.PendingToSend with lock</Title>
    <Description>
    </Description>
    <Title_Description>Protect ClientState.PendingToSend with lock </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5880</IssueLabelID>
    <Title>Orleans 3.0.0-beta1 Code Generator uses Assemblies for dotnet 2.0 and can't be build in official MS container for dotnet 3.0</Title>
    <Description>The new version Orleans 3.0.0-beta1 still uses assemblies from dotnet 2.0 during code generation. This prevents building the application in the MS docker sdk container `mcr.microsoft.com/dotnet/core/sdk:3.0`.

The generator fails with
```
  It was not possible to find any compatible framework version
  The specified framework 'Microsoft.NETCore.App' version '2.0.0' was not found.
    - The following frameworks were found:
        3.0.0-preview8-28405-07 at [/usr/share/dotnet/shared/Microsoft.NETCore.App]

  You can resolve the problem by installing the specified framework and/or SDK.

  The .NET Core frameworks can be found at:
    - https://aka.ms/dotnet-download
/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/3.0.0-beta1/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(835): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/3.0.0-beta1/build/../tasks/netcoreapp2.0/Orleans.CodeGeneration.Build.dll" "@obj/Debug/netcoreapp3.0/codegen/Eight.Kelvin.GrainInterfaces.orleans.g.args.txt"" exited with code 150. [/root/kelvin-api/src/Eight.Kelvin.GrainInterfaces/Eight.Kelvin.GrainInterfaces.csproj]
```

Installing an older version of dotnet in the container fixes the issue.</Description>
    <Title_Description>Orleans 3.0.0-beta1 Code Generator uses Assemblies for dotnet 2.0 and can't be build in official MS container for dotnet 3.0 The new version Orleans 3.0.0-beta1 still uses assemblies from dotnet 2.0 during code generation. This prevents building the application in the MS docker sdk container `mcr.microsoft.com/dotnet/core/sdk:3.0`.

The generator fails with
```
  It was not possible to find any compatible framework version
  The specified framework 'Microsoft.NETCore.App' version '2.0.0' was not found.
    - The following frameworks were found:
        3.0.0-preview8-28405-07 at [/usr/share/dotnet/shared/Microsoft.NETCore.App]

  You can resolve the problem by installing the specified framework and/or SDK.

  The .NET Core frameworks can be found at:
    - https://aka.ms/dotnet-download
/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/3.0.0-beta1/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(835): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/3.0.0-beta1/build/../tasks/netcoreapp2.0/Orleans.CodeGeneration.Build.dll" "@obj/Debug/netcoreapp3.0/codegen/Eight.Kelvin.GrainInterfaces.orleans.g.args.txt"" exited with code 150. [/root/kelvin-api/src/Eight.Kelvin.GrainInterfaces/Eight.Kelvin.GrainInterfaces.csproj]
```

Installing an older version of dotnet in the container fixes the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5879</IssueLabelID>
    <Title>Kinesis Streams Sequence Number much bigger than attributes in StreamSequenceToken introduced with #5580</Title>
    <Description>We have an implementation of a persistent stream adapter to consume Amazon Kinesis streams which we are using in production for several month now.

Amazon Kinesis streams have a sequence number consisting of 128 digits (186 Bits) which is much bigger than the attributes SequenceNumber and EventIndex defined in StreamSequenceToken. The changes in #5580 therefore break our stream provider implementation.

StreamSequenceToken seems to be very much specific to Azure streams and it is not apparent how an implementation of StreamSequenceToken should be mapped to other persistent stream providers and it seems to be not a very good choice to tie the StreamSequenceToken to closely with stream implementations from a given vendor.</Description>
    <Title_Description>Kinesis Streams Sequence Number much bigger than attributes in StreamSequenceToken introduced with #5580 We have an implementation of a persistent stream adapter to consume Amazon Kinesis streams which we are using in production for several month now.

Amazon Kinesis streams have a sequence number consisting of 128 digits (186 Bits) which is much bigger than the attributes SequenceNumber and EventIndex defined in StreamSequenceToken. The changes in #5580 therefore break our stream provider implementation.

StreamSequenceToken seems to be very much specific to Azure streams and it is not apparent how an implementation of StreamSequenceToken should be mapped to other persistent stream providers and it seems to be not a very good choice to tie the StreamSequenceToken to closely with stream implementations from a given vendor.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5878</IssueLabelID>
    <Title>Cannot find generated GrainReference class for interface</Title>
    <Description>Strange behaviour.
When I registering IClusterClient in Dependncy Injection and use it in other parts of application exception "Cannot find generated GrainReference class for interface" will be raised. 

But if I call GetGrain&lt;&gt; during registration - everything will be ok and no errors. 

What's wrong? </Description>
    <Title_Description>Cannot find generated GrainReference class for interface Strange behaviour.
When I registering IClusterClient in Dependncy Injection and use it in other parts of application exception "Cannot find generated GrainReference class for interface" will be raised. 

But if I call GetGrain&lt;&gt; during registration - everything will be ok and no errors. 

What's wrong? </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5877</IssueLabelID>
    <Title>Codegenerator produces errors in generics</Title>
    <Description>I am using Microsoft.Orleans.CodeGenerator.MSBuild to generate proxies in a netstandard2.0 "contracts" library (shared library among clients to connect to orleans).
I recently updated to the latest stable version 2.4.1 from 2.3.6.

Where it used to generate 
`global::System.Collections.Generic.List&lt;global::Our.Project.Namespace.SomeObject&gt;`
It now generates
`global::System.Collections.Generic.List&lt;SomeObject&gt;`

Which doesn't compile.
Reverting back to 2.3.6 fixes the issue.</Description>
    <Title_Description>Codegenerator produces errors in generics I am using Microsoft.Orleans.CodeGenerator.MSBuild to generate proxies in a netstandard2.0 "contracts" library (shared library among clients to connect to orleans).
I recently updated to the latest stable version 2.4.1 from 2.3.6.

Where it used to generate 
`global::System.Collections.Generic.List&lt;global::Our.Project.Namespace.SomeObject&gt;`
It now generates
`global::System.Collections.Generic.List&lt;SomeObject&gt;`

Which doesn't compile.
Reverting back to 2.3.6 fixes the issue.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5876</IssueLabelID>
    <Title>Serialization manager does not serialize HttpRequestException stack trace </Title>
    <Description>Hi
I noticed that Serialization manager does not serialize HttpRequestException stack trace. 
I don`t see this behavior in other system exceptions is there is any reason for that?

   **✓** OrleansSerialization_ShouldSerialize_Exception(System.Exception)  
   **✓** OrleansSerialization_ShouldSerialize_Exception(System.NullReferenceException)  
   **X** OrleansSerialization_ShouldSerialize_Exception(System.Net.Http.HttpRequestException) Failed:  StackTrace  Expected: "   at  ..... "  But was:  null

```c#
        [TestCase(typeof(Exception))]
        [TestCase(typeof(NullReferenceException))]
        [TestCase(typeof(HttpRequestException))]
        public void OrleansSerialization_ShouldSerialize_Exception(Type type)
        {
            var client = new ClientBuilder()
                .UseLocalhostClustering()
                .Build();

            var serializationManager = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();
            Exception expected;
            try
            {

                throw (Exception)Activator.CreateInstance(type "exception"); 
            }
            catch (Exception ex)
            {
                expected= ex;
            }

            var actual = (Exception)serializationManager.DeepCopy(expected);
            Assert.AreEqual(expected.GetType() actual.GetType());
            Assert.AreEqual(expected.Message actual.Message);
            Assert.AreEqual(expected.StackTrace actual.StackTrace);

            var actualRoundTrip = serializationManager.RoundTripSerializationForTesting(expected);
            Assert.AreEqual(expected.GetType() actualRoundTrip.GetType());
            Assert.AreEqual(expected.Message actualRoundTrip.Message);
            Assert.AreEqual(expected.StackTrace actualRoundTrip.StackTrace);
        }   
```
Thanks
Eran</Description>
    <Title_Description>Serialization manager does not serialize HttpRequestException stack trace  Hi
I noticed that Serialization manager does not serialize HttpRequestException stack trace. 
I don`t see this behavior in other system exceptions is there is any reason for that?

   **✓** OrleansSerialization_ShouldSerialize_Exception(System.Exception)  
   **✓** OrleansSerialization_ShouldSerialize_Exception(System.NullReferenceException)  
   **X** OrleansSerialization_ShouldSerialize_Exception(System.Net.Http.HttpRequestException) Failed:  StackTrace  Expected: "   at  ..... "  But was:  null

```c#
        [TestCase(typeof(Exception))]
        [TestCase(typeof(NullReferenceException))]
        [TestCase(typeof(HttpRequestException))]
        public void OrleansSerialization_ShouldSerialize_Exception(Type type)
        {
            var client = new ClientBuilder()
                .UseLocalhostClustering()
                .Build();

            var serializationManager = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();
            Exception expected;
            try
            {

                throw (Exception)Activator.CreateInstance(type "exception"); 
            }
            catch (Exception ex)
            {
                expected= ex;
            }

            var actual = (Exception)serializationManager.DeepCopy(expected);
            Assert.AreEqual(expected.GetType() actual.GetType());
            Assert.AreEqual(expected.Message actual.Message);
            Assert.AreEqual(expected.StackTrace actual.StackTrace);

            var actualRoundTrip = serializationManager.RoundTripSerializationForTesting(expected);
            Assert.AreEqual(expected.GetType() actualRoundTrip.GetType());
            Assert.AreEqual(expected.Message actualRoundTrip.Message);
            Assert.AreEqual(expected.StackTrace actualRoundTrip.StackTrace);
        }   
```
Thanks
Eran</Title_Description>
    <Label>serialization</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5875</IssueLabelID>
    <Title>provide more meaningful details when not able to find grain implementation for stream subscription</Title>
    <Description>im using orleans 2.3.6 and i got this exception:

'Unexpected: Cannot find an implementation class for grain interface 953247292'

digging down the stack with a debugger I got to PersistentStreamPullingAgent.

It would be VERY helpful if the exception could include the StreamId that is causing the issue so one could find the issue from the logfiles without needing a debugger.

</Description>
    <Title_Description>provide more meaningful details when not able to find grain implementation for stream subscription im using orleans 2.3.6 and i got this exception:

'Unexpected: Cannot find an implementation class for grain interface 953247292'

digging down the stack with a debugger I got to PersistentStreamPullingAgent.

It would be VERY helpful if the exception could include the StreamId that is causing the issue so one could find the issue from the logfiles without needing a debugger.

</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5873</IssueLabelID>
    <Title>Add a warning about runtime running with trace level higher than Info</Title>
    <Description>This was suggested by @EranOfer in https://github.com/dotnet/orleans/issues/5851#issuecomment-520709746</Description>
    <Title_Description>Add a warning about runtime running with trace level higher than Info This was suggested by @EranOfer in https://github.com/dotnet/orleans/issues/5851#issuecomment-520709746</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/08/2019 8:19:31 PM +00:00</CreatedAt>
    <ClosedAt>15/10/2019 4:24:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5871</IssueLabelID>
    <Title>Handling very specific exceptions on the client</Title>
    <Description>Hello to all! Thanks for the great job! I have the following question:

What is the best way to handle this situation: one of the grains throws a very specific exception (for example related to the database driver). Further this exception "flies" and reaches the client where it cannot be deserialized (because the client does not know anything about working with the database all of these libraries are not loaded in the client).

What is the best way to solve such problems?

Here is an example of this kind of deserialization error:

```
Could not load file or assembly 'MongoDB.Driver Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.

 at System.Reflection.RuntimeAssembly.nLoad(AssemblyName fileName String codeBase RuntimeAssembly locationHint StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound IntPtr ptrLoadContextBinder)
 at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef RuntimeAssembly reqAssembly StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound IntPtr ptrLoadContextBinder)
 at System.Reflection.Assembly.Load(AssemblyName assemblyRef)
 at Orleans.Runtime.CachedTypeResolver.&lt;&gt;c__DisplayClass7_0.&lt;TryPerformUncachedTypeResolution&gt;g__ResolveAssembly|0(AssemblyName assemblyName)
 at System.TypeNameParser.ResolveAssembly(String asmName Func`2 assemblyResolver Boolean throwOnError StackCrawlMark&amp; stackMark)
 at System.TypeNameParser.ConstructType(Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError Boolean ignoreCase StackCrawlMark&amp; stackMark)
 at System.TypeNameParser.GetType(String typeName Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError Boolean ignoreCase StackCrawlMark&amp; stackMark)
 at System.Type.GetType(String typeName Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError)
 at Orleans.Runtime.CachedTypeResolver.TryPerformUncachedTypeResolution(String fullName Type&amp; type Assembly[] assemblies)
 at Orleans.Runtime.CachedTypeResolver.TryPerformUncachedTypeResolution(String name Type&amp; type)
 at Orleans.Runtime.CachedTypeResolver.TryResolveType(String name Type&amp; type)
 at Orleans.Serialization.TypeSerializer.GetTypeFromName(String assemblyQualifiedTypeName Boolean throwOnError)
 at Orleans.Serialization.TypeSerializer.GetTypeFromTypeKey(TypeKey key Boolean throwOnError)
 at Orleans.Serialization.ILBasedExceptionSerializer.Deserialize(Type expectedType IDeserializationContext outerContext)
 at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context)
 at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
 at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
 at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
 at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
 at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
 at Orleans.Runtime.SharedCallbackData.ResponseCallback(Message message TaskCompletionSource`1 context) --- End of stack trace from previous location where exception was thrown ---
 at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
 at Path.To.The.Place.Where.Cluster.Client.Is.Calling.The.Grain.Method() in /path/to/my/File.cs:line 42
```</Description>
    <Title_Description>Handling very specific exceptions on the client Hello to all! Thanks for the great job! I have the following question:

What is the best way to handle this situation: one of the grains throws a very specific exception (for example related to the database driver). Further this exception "flies" and reaches the client where it cannot be deserialized (because the client does not know anything about working with the database all of these libraries are not loaded in the client).

What is the best way to solve such problems?

Here is an example of this kind of deserialization error:

```
Could not load file or assembly 'MongoDB.Driver Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.

 at System.Reflection.RuntimeAssembly.nLoad(AssemblyName fileName String codeBase RuntimeAssembly locationHint StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound IntPtr ptrLoadContextBinder)
 at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef RuntimeAssembly reqAssembly StackCrawlMark&amp; stackMark IntPtr pPrivHostBinder Boolean throwOnFileNotFound IntPtr ptrLoadContextBinder)
 at System.Reflection.Assembly.Load(AssemblyName assemblyRef)
 at Orleans.Runtime.CachedTypeResolver.&lt;&gt;c__DisplayClass7_0.&lt;TryPerformUncachedTypeResolution&gt;g__ResolveAssembly|0(AssemblyName assemblyName)
 at System.TypeNameParser.ResolveAssembly(String asmName Func`2 assemblyResolver Boolean throwOnError StackCrawlMark&amp; stackMark)
 at System.TypeNameParser.ConstructType(Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError Boolean ignoreCase StackCrawlMark&amp; stackMark)
 at System.TypeNameParser.GetType(String typeName Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError Boolean ignoreCase StackCrawlMark&amp; stackMark)
 at System.Type.GetType(String typeName Func`2 assemblyResolver Func`4 typeResolver Boolean throwOnError)
 at Orleans.Runtime.CachedTypeResolver.TryPerformUncachedTypeResolution(String fullName Type&amp; type Assembly[] assemblies)
 at Orleans.Runtime.CachedTypeResolver.TryPerformUncachedTypeResolution(String name Type&amp; type)
 at Orleans.Runtime.CachedTypeResolver.TryResolveType(String name Type&amp; type)
 at Orleans.Serialization.TypeSerializer.GetTypeFromName(String assemblyQualifiedTypeName Boolean throwOnError)
 at Orleans.Serialization.TypeSerializer.GetTypeFromTypeKey(TypeKey key Boolean throwOnError)
 at Orleans.Serialization.ILBasedExceptionSerializer.Deserialize(Type expectedType IDeserializationContext outerContext)
 at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context)
 at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
 at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
 at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader)
 at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
 at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
 at Orleans.Runtime.SharedCallbackData.ResponseCallback(Message message TaskCompletionSource`1 context) --- End of stack trace from previous location where exception was thrown ---
 at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
 at Path.To.The.Place.Where.Cluster.Client.Is.Calling.The.Grain.Method() in /path/to/my/File.cs:line 42
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5870</IssueLabelID>
    <Title>ConfigureFileLogging hangs/crashes TestCluster</Title>
    <Description>With the master branch of Orleans and netcore sdk 3.0.100-preview9-013803 
Having ```TestClusterBuilder.Options.ConfigureFileLogging == true```  the ```TestCluster``` will  hang or crash  ```TestClusterBuilder.Deploy()``` or ```TestClusterBuilder.DeployAsync()``` with 

```
Could not load type 'Microsoft.Extensions.Logging.Abstractions.Internal.NullScope' from assembly 'Microsoft.Extensions.Logging.Abstractions Version=3.0.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'
```


rich</Description>
    <Title_Description>ConfigureFileLogging hangs/crashes TestCluster With the master branch of Orleans and netcore sdk 3.0.100-preview9-013803 
Having ```TestClusterBuilder.Options.ConfigureFileLogging == true```  the ```TestCluster``` will  hang or crash  ```TestClusterBuilder.Deploy()``` or ```TestClusterBuilder.DeployAsync()``` with 

```
Could not load type 'Microsoft.Extensions.Logging.Abstractions.Internal.NullScope' from assembly 'Microsoft.Extensions.Logging.Abstractions Version=3.0.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'
```


rich</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5869</IssueLabelID>
    <Title>how to call outside method  in grains?</Title>
    <Description>I have netty as frontend. the msg from device can pass throuth netty then we have a cluster to handler the msg. but how to send response  through netty to device?

I do got some method to do the job without orleans. but I 'd like to know the  orleans' way.</Description>
    <Title_Description>how to call outside method  in grains? I have netty as frontend. the msg from device can pass throuth netty then we have a cluster to handler the msg. but how to send response  through netty to device?

I do got some method to do the job without orleans. but I 'd like to know the  orleans' way.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5868</IssueLabelID>
    <Title>Could not find silo entry for silo ... in the table</Title>
    <Description>Orleans version: 2.2
Errors
```log

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100651]


      TryToSuspectOrKill failed


System.AggregateException: One or more errors occurred. (-Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.) ---&gt; System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   --- End of inner exception stack trace ---


---&gt; (Inner Exception #0) System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)&lt;---




fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.
```
Some code in source
```cs
            if (!table.Contains(silo))
            {
                // this should not happen ...
                var str = String.Format("-Could not find silo entry for silo {0} in the table." silo.ToLongString());
                logger.Error(ErrorCode.MembershipFailedToReadSilo str);
                throw new KeyNotFoundException(str);
            }
```
It seems the silo hoped to delete is already deleted in my membershipTableProvider.
Why soli don't update it's probedSilos？
I checked the source code  the  already deleted (in membershipTableProvider) probedSilo will be dead only after delete in membershipTableProvider But I am not sureI will check the higher version
</Description>
    <Title_Description>Could not find silo entry for silo ... in the table Orleans version: 2.2
Errors
```log

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100651]


      TryToSuspectOrKill failed


System.AggregateException: One or more errors occurred. (-Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.) ---&gt; System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   --- End of inner exception stack trace ---


---&gt; (Inner Exception #0) System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)&lt;---




fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.125:11111:300894698 in the table.
```
Some code in source
```cs
            if (!table.Contains(silo))
            {
                // this should not happen ...
                var str = String.Format("-Could not find silo entry for silo {0} in the table." silo.ToLongString());
                logger.Error(ErrorCode.MembershipFailedToReadSilo str);
                throw new KeyNotFoundException(str);
            }
```
It seems the silo hoped to delete is already deleted in my membershipTableProvider.
Why soli don't update it's probedSilos？
I checked the source code  the  already deleted (in membershipTableProvider) probedSilo will be dead only after delete in membershipTableProvider But I am not sureI will check the higher version
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5866</IssueLabelID>
    <Title>Is there an example for AzureQueue streams in Orleans?</Title>
    <Description>
    </Description>
    <Title_Description>Is there an example for AzureQueue streams in Orleans? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5865</IssueLabelID>
    <Title>Log parameter names improvement for structured loggers</Title>
    <Description>A lot of log messages use the "old" String.Format syntax with `{0}`  style parameters 

    Log.Info("Starting AsyncAgent {0} on managed thread {1}" Name Thread.CurrentThread.ManagedThreadId)

When you use a structured logger it results in 2 parameters named `0` and `1` which is not a really useful information.

It can also cause indexation errors if you index the log messages. In my case I use Graylog to manage my logs and I see a lot of indexing errors because the same parameter with name `0` is not always of the same type. (int string ...)

This could be replaced by something like

    Log.Info("Starting AsyncAgent {AgentName} on managed thread {ThreadId}" Name Thread.CurrentThread.ManagedThreadId)

The goal is maybe not to change it everywhere but at least to improve the most common log messages in a first time and to improve the other logs over time.</Description>
    <Title_Description>Log parameter names improvement for structured loggers A lot of log messages use the "old" String.Format syntax with `{0}`  style parameters 

    Log.Info("Starting AsyncAgent {0} on managed thread {1}" Name Thread.CurrentThread.ManagedThreadId)

When you use a structured logger it results in 2 parameters named `0` and `1` which is not a really useful information.

It can also cause indexation errors if you index the log messages. In my case I use Graylog to manage my logs and I see a lot of indexing errors because the same parameter with name `0` is not always of the same type. (int string ...)

This could be replaced by something like

    Log.Info("Starting AsyncAgent {AgentName} on managed thread {ThreadId}" Name Thread.CurrentThread.ManagedThreadId)

The goal is maybe not to change it everywhere but at least to improve the most common log messages in a first time and to improve the other logs over time.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>14/08/2019 11:39:13 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5864</IssueLabelID>
    <Title>Resubmit #5862 (Cherry-pick #5859 and #5863 for 2.4.1)</Title>
    <Description>Log options on silo and client startup (#5859)
Handle the case where the clustering provider does not support TableVersion (#5863)</Description>
    <Title_Description>Resubmit #5862 (Cherry-pick #5859 and #5863 for 2.4.1) Log options on silo and client startup (#5859)
Handle the case where the clustering provider does not support TableVersion (#5863)</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5863</IssueLabelID>
    <Title>Fix for Clustering providers that does not implement extended Membership Protocol</Title>
    <Description>Fix for #5857 </Description>
    <Title_Description>Fix for Clustering providers that does not implement extended Membership Protocol Fix for #5857 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5862</IssueLabelID>
    <Title>Cherry-pick #5859 and #5863 for 2.4.1</Title>
    <Description>Log options on silo and client startup (#5859)
Handle the case where the clustering provider does not support TableVersion (#5863)</Description>
    <Title_Description>Cherry-pick #5859 and #5863 for 2.4.1 Log options on silo and client startup (#5859)
Handle the case where the clustering provider does not support TableVersion (#5863)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5860</IssueLabelID>
    <Title>[WIP] Support ConnectionOptions.OpenConnectionTimeout</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Support ConnectionOptions.OpenConnectionTimeout </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5858</IssueLabelID>
    <Title>How to deploy a new version of GrainService?</Title>
    <Description>Since a GrainService runs on the silo from startup to shutdown what is the best strategy to deploy a new version on the same cluster?</Description>
    <Title_Description>How to deploy a new version of GrainService? Since a GrainService runs on the silo from startup to shutdown what is the best strategy to deploy a new version on the same cluster?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5857</IssueLabelID>
    <Title>ManagementGrain.GetTotalActivationCount() does not return a result with 2.4.0</Title>
    <Description>Hi

I updated my application to 2.4.0 and with a real membership provider like MongoDB I see a few behaviors:

1. The dashboard does not show any results.

2. GetTotalActivationCount() returns 0

3. GetTotalActivationCount() something throws an exception:

```
message:  "Object reference not set to an instance of an object."    
   stackTrace:  "   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.ReadAll()
   at Orleans.Runtime.MembershipService.MembershipTableManager.RefreshInternal(Boolean requireCleanup)
   at Orleans.Runtime.MembershipService.MembershipTableManager.Refresh()
   at Orleans.Runtime.Management.ManagementGrain.GetHosts(Boolean onlyActive)
   at Orleans.Runtime.Management.ManagementGrain.GetTotalActivationCount()
   at Orleans.Runtime.OrleansCodeGenManagementGrainMethodInvoker.Invoke(IAddressable grain InvokeMethodRequest request)
   at Orleans.Runtime.GrainMethodInvoker.Invoke()
   at OrleansDashboard.Metrics.GrainProfilerFilter.Invoke(IIncomingGrainCallContext context)
   at Orleans.Runtime.GrainMethodInvoker.Invoke()
   at Squidex.Infrastructure.Orleans.LoggingFilter.Invoke(IIncomingGrainCallContext context) in /src/src/Squidex.Infrastructure/Orleans/LoggingFilter.cs:line 30"    
   type:  "System.NullReferenceException"    
```

I have pushed a small example to: https://github.com/OrleansContrib/OrleansDashboard/tree/mongo-example/Tests/TestHosts/TestHostWithMongoClustering</Description>
    <Title_Description>ManagementGrain.GetTotalActivationCount() does not return a result with 2.4.0 Hi

I updated my application to 2.4.0 and with a real membership provider like MongoDB I see a few behaviors:

1. The dashboard does not show any results.

2. GetTotalActivationCount() returns 0

3. GetTotalActivationCount() something throws an exception:

```
message:  "Object reference not set to an instance of an object."    
   stackTrace:  "   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.ReadAll()
   at Orleans.Runtime.MembershipService.MembershipTableManager.RefreshInternal(Boolean requireCleanup)
   at Orleans.Runtime.MembershipService.MembershipTableManager.Refresh()
   at Orleans.Runtime.Management.ManagementGrain.GetHosts(Boolean onlyActive)
   at Orleans.Runtime.Management.ManagementGrain.GetTotalActivationCount()
   at Orleans.Runtime.OrleansCodeGenManagementGrainMethodInvoker.Invoke(IAddressable grain InvokeMethodRequest request)
   at Orleans.Runtime.GrainMethodInvoker.Invoke()
   at OrleansDashboard.Metrics.GrainProfilerFilter.Invoke(IIncomingGrainCallContext context)
   at Orleans.Runtime.GrainMethodInvoker.Invoke()
   at Squidex.Infrastructure.Orleans.LoggingFilter.Invoke(IIncomingGrainCallContext context) in /src/src/Squidex.Infrastructure/Orleans/LoggingFilter.cs:line 30"    
   type:  "System.NullReferenceException"    
```

I have pushed a small example to: https://github.com/OrleansContrib/OrleansDashboard/tree/mongo-example/Tests/TestHosts/TestHostWithMongoClustering</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5855</IssueLabelID>
    <Title>Cherry-pick #5838 for 2.4.1</Title>
    <Description>Added ClientMessagingOptions.LocalAddress to ignore ConfigUtilities.GetLocalIPAddress that automatic pickups network interfaces. (#5838)
</Description>
    <Title_Description>Cherry-pick #5838 for 2.4.1 Added ClientMessagingOptions.LocalAddress to ignore ConfigUtilities.GetLocalIPAddress that automatic pickups network interfaces. (#5838)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5854</IssueLabelID>
    <Title>Cherry-picked fixes for 2.4.1</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked fixes for 2.4.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5851</IssueLabelID>
    <Title>Massive GC when log debug is enabled</Title>
    <Description>We performing a load testing on Orleans 2.3.4 with 500000 unique grains.
We enabled log **level debug** after we stopped the load the silo suffer from high rate of GC that never stop.

Profiling the issue we saw 

![image](https://user-images.githubusercontent.com/13414515/62870447-5559d880-bd22-11e9-8055-b50df1f86bae.png)

I think it came from ```tostrings```
![image](https://user-images.githubusercontent.com/13414515/62870872-0bbdbd80-bd23-11e9-9de7-6db1d0478a25.png)



![image](https://user-images.githubusercontent.com/13414515/62870891-15dfbc00-bd23-11e9-812b-10452ad97002.png)



</Description>
    <Title_Description>Massive GC when log debug is enabled We performing a load testing on Orleans 2.3.4 with 500000 unique grains.
We enabled log **level debug** after we stopped the load the silo suffer from high rate of GC that never stop.

Profiling the issue we saw 

![image](https://user-images.githubusercontent.com/13414515/62870447-5559d880-bd22-11e9-8055-b50df1f86bae.png)

I think it came from ```tostrings```
![image](https://user-images.githubusercontent.com/13414515/62870872-0bbdbd80-bd23-11e9-9de7-6db1d0478a25.png)



![image](https://user-images.githubusercontent.com/13414515/62870891-15dfbc00-bd23-11e9-812b-10452ad97002.png)



</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5849</IssueLabelID>
    <Title>[Question] How do I access the GrainService in the specified Silo?</Title>
    <Description>I have many silos with their own GrainService in my scenario. How do I access the GrainService in the specified Silo? So i can polling every GrainService in my clusters.

Any recommendations suggestions etc would be much appreciated.</Description>
    <Title_Description>[Question] How do I access the GrainService in the specified Silo? I have many silos with their own GrainService in my scenario. How do I access the GrainService in the specified Silo? So i can polling every GrainService in my clusters.

Any recommendations suggestions etc would be much appreciated.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5847</IssueLabelID>
    <Title>IMembershipOracle not added to services in 2.4.0?</Title>
    <Description>Doing a test-run upgrade to 2.4.0 and my health-check hosted service which is modeled partially off of the one in Samples\2.3 fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans` crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable&lt;IHealthCheckParticipant&gt;` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?</Description>
    <Title_Description>IMembershipOracle not added to services in 2.4.0? Doing a test-run upgrade to 2.4.0 and my health-check hosted service which is modeled partially off of the one in Samples\2.3 fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans` crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable&lt;IHealthCheckParticipant&gt;` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5846</IssueLabelID>
    <Title>Orleans doesn't build on Mac</Title>
    <Description>at commit c9fe1b4a5b9542b31922aa46709d4055e0c8a556 (latest) I cloned cd'ed to the dir and then brought in:
Microsoft.Orleans.Core.Abstractions
Microsoft.Orleans.CodeGenerator.MSBuild
Microsoft.Orleans.Server
Microsoft.Orleans.Client
...using nuget.
I then used "nuget restore OrleansCrossPlatform.sln" and then "dotnet build OrleansCrossPlatform.sln" - I get this error:

/usr/local/share/dotnet/sdk/2.2.300/NuGet.targets(2655): error MSB3202: The project file "/Users/john/orleans/orleans/src/Azure/OrleansAzureUtils/OrleansAzureUtils.csproj" was not found. [/Users/john/orleans/orleans/OrleansCrossPlatform.sln]

The error message speaks the truth - that file does not exist. How can I encourage it to show up? Did I not import something or is it a bad reference? How does one compile Orleans on a Mac?</Description>
    <Title_Description>Orleans doesn't build on Mac at commit c9fe1b4a5b9542b31922aa46709d4055e0c8a556 (latest) I cloned cd'ed to the dir and then brought in:
Microsoft.Orleans.Core.Abstractions
Microsoft.Orleans.CodeGenerator.MSBuild
Microsoft.Orleans.Server
Microsoft.Orleans.Client
...using nuget.
I then used "nuget restore OrleansCrossPlatform.sln" and then "dotnet build OrleansCrossPlatform.sln" - I get this error:

/usr/local/share/dotnet/sdk/2.2.300/NuGet.targets(2655): error MSB3202: The project file "/Users/john/orleans/orleans/src/Azure/OrleansAzureUtils/OrleansAzureUtils.csproj" was not found. [/Users/john/orleans/orleans/OrleansCrossPlatform.sln]

The error message speaks the truth - that file does not exist. How can I encourage it to show up? Did I not import something or is it a bad reference? How does one compile Orleans on a Mac?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5845</IssueLabelID>
    <Title>Fixes packaging of analyzers</Title>
    <Description>Fixes packaging of analyzers. Tested locally and works now.
![image](https://user-images.githubusercontent.com/7863439/62806758-645f4180-bafc-11e9-8e96-9477e9a6db0f.png)

Trick is to add assemblies in `analyzers\dotnet\cs` as per https://roslyn-analyzers.readthedocs.io/en/latest/create-nuget-package.html. Also made the package a development dependency. This will make sure it `&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;` is added when installed via package manager.

//cc @ReubenBond @bddckr
</Description>
    <Title_Description>Fixes packaging of analyzers Fixes packaging of analyzers. Tested locally and works now.
![image](https://user-images.githubusercontent.com/7863439/62806758-645f4180-bafc-11e9-8e96-9477e9a6db0f.png)

Trick is to add assemblies in `analyzers\dotnet\cs` as per https://roslyn-analyzers.readthedocs.io/en/latest/create-nuget-package.html. Also made the package a development dependency. This will make sure it `&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;` is added when installed via package manager.

//cc @ReubenBond @bddckr
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5844</IssueLabelID>
    <Title>Fix potential deadlock between Catalog and LocalGrainDirectory</Title>
    <Description>We've identified a potential silo deadlock:
* `LocalGrainDirectory.RemoveServer` (called on membership change) **locks** `membershipCache` and calls into the catalog which deactivates grains (taking a **lock** on each activation it's deactivating)
* `Catalog.RecoverFailedInitActivation` (called when a new activation cannot be added to the directory eg because that silo just shut down) is executed under the activation's **lock** and calls into `LocalGrainDirectory.CalculateGrainDirectoryPartition` which tries to **lock** `membershipCache`

This PR is an attempt to fix that.</Description>
    <Title_Description>Fix potential deadlock between Catalog and LocalGrainDirectory We've identified a potential silo deadlock:
* `LocalGrainDirectory.RemoveServer` (called on membership change) **locks** `membershipCache` and calls into the catalog which deactivates grains (taking a **lock** on each activation it's deactivating)
* `Catalog.RecoverFailedInitActivation` (called when a new activation cannot be added to the directory eg because that silo just shut down) is executed under the activation's **lock** and calls into `LocalGrainDirectory.CalculateGrainDirectoryPartition` which tries to **lock** `membershipCache`

This PR is an attempt to fix that.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5843</IssueLabelID>
    <Title>not support on dotnet core 2.2?</Title>
    <Description>I make a demo  target platform dotnet core 2.2 but not build successfully. so I try the hello word  sample on 2.0it runs OK.but if I change the  target framework to 2.2 it  also build failed.
![image](https://user-images.githubusercontent.com/1329895/62770211-1bdc5f80-bacd-11e9-81fd-b699f99db7c1.png)


and I read sample there are  1.x2.02.12.3 but not get 2.2. so is that reason?</Description>
    <Title_Description>not support on dotnet core 2.2? I make a demo  target platform dotnet core 2.2 but not build successfully. so I try the hello word  sample on 2.0it runs OK.but if I change the  target framework to 2.2 it  also build failed.
![image](https://user-images.githubusercontent.com/1329895/62770211-1bdc5f80-bacd-11e9-81fd-b699f99db7c1.png)


and I read sample there are  1.x2.02.12.3 but not get 2.2. so is that reason?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5842</IssueLabelID>
    <Title>Call ProcessTableUpdate before GossipToOthers</Title>
    <Description>
    </Description>
    <Title_Description>Call ProcessTableUpdate before GossipToOthers </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5840</IssueLabelID>
    <Title>NATS streaming provider</Title>
    <Description>Are there any implemantations of streaming provider for Orleans and NATS ?
</Description>
    <Title_Description>NATS streaming provider Are there any implemantations of streaming provider for Orleans and NATS ?
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5839</IssueLabelID>
    <Title>Firing same type of event from multiple streams with different providers does not respect fire and forget settings.</Title>
    <Description>I am trying to broadcast the same event to multiple streams that have different `FireAndForgetDelivery` properties using SMS.
For the first stream I want to be sure that the event is handled correctly and I will take necessary actions if an exception is thrown. The other stream will notify the UI and I don't care about the exceptions it throws.

The actual behavior I see is that both streams act like the same as far as `FireAndForgetDelivery` is considered. Which stream fires the first determines the `FireAndForgetDelivery` behavior for the other. This causes deadlocks when UI code calls the grain inside subscription callback.

The problem can be reproduced with the code below:

``` c#
public interface ITestGrain : IGrainWithGuidKey
{
	Task Test();
	Task Deadlock();
}

public class TestEvent
{
}

public class TestGrain : Grain ITestGrain
{
	private IAsyncStream&lt;TestEvent&gt; _interGrainStream;
	private IAsyncStream&lt;TestEvent&gt; _notificationStream;

	public override Task OnActivateAsync()
	{
		_interGrainStream = GetStreamProvider("Provider1").GetStream&lt;TestEvent&gt;(this.GetPrimaryKey() "Test");
		_notificationStream = GetStreamProvider("Provider2").GetStream&lt;TestEvent&gt;(this.GetPrimaryKey() "Test.Notification");

		return Task.CompletedTask;
	}

	public async Task Test()
	{
		TestEvent testEvent = new TestEvent();
		
		await _interGrainStream.OnNextAsync(testEvent);
		await _notificationStream.OnNextAsync(testEvent);
	}
	
	public Task Deadlock()
	{
		return Task.CompletedTask;
	}
}
```

Host code:
``` c#
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Orleans.Grains;
using Orleans.Hosting;

namespace Orleans.Host
{
	public class Program
	{
		public static async Task Main(string[] args)
		{
            IHost host = new HostBuilder()
                .UseOrleans((context siloBuilder) =&gt;
                {
                    siloBuilder
                        .UseLocalhostClustering()
                        .AddMemoryGrainStorage("PubSubStore")
                        .AddSimpleMessageStreamProvider("Provider1" x =&gt;
                        {
                            x.FireAndForgetDelivery = false;
                        })
                        .AddSimpleMessageStreamProvider("Provider2" x =&gt;
                        {
                            x.FireAndForgetDelivery = true;
                        })
                        .ConfigureApplicationParts(x =&gt;
                        {
                            x.AddApplicationPart(typeof(TestGrain).Assembly).WithReferences();
                        });
                })
                .Build();

            await host.RunAsync();
        }
    }
}
```

Client code:
``` c#
using System;
using System.Threading.Tasks;
using Orleans.Hosting;
using Orleans.Interface;
using Orleans.Streams;

namespace Orleans.Client
{
	public class Program
	{
		public static async Task Main(string[] args)
		{
			IClusterClient clusterClient = new ClientBuilder()
				.UseLocalhostClustering()
				.AddSimpleMessageStreamProvider("Provider1")
				.AddSimpleMessageStreamProvider("Provider2")
				.Build();

			await clusterClient.Connect(x =&gt;
			{
				Console.WriteLine("Could not connect to server retrying.");
				return Task.FromResult(true);
			});

			ITestGrain grain = clusterClient.GetGrain&lt;ITestGrain&gt;(Guid.NewGuid());

			await clusterClient
				.GetStreamProvider("Provider1")
				.GetStream&lt;TestEvent&gt;(grain.GetPrimaryKey() "Test")
				.SubscribeAsync(async (x _) =&gt;
				{
					// await grain.Deadlock();
				});

			await clusterClient
				.GetStreamProvider("Provider2")
				.GetStream&lt;TestEvent&gt;(grain.GetPrimaryKey() "Test.Notification")
				.SubscribeAsync(async (x _) =&gt;
				{
					await grain.Deadlock();
				});

			await grain.Test();

			await Task.Delay(TimeSpan.FromDays(1));
		}
	}
}
```

If you change the order of `OnNextAsync` calls and uncomment the `// await grain.Deadlock();` line there will be no deadlock even though the uncommented line should cause a deadlock.

What I found is that in `SimpleMessageStreamProducer&lt;T&gt;.RegisterProducer` method provider name is not considered while fetching the extension class. So the extension class for the first one is cached and used for all other streams.</Description>
    <Title_Description>Firing same type of event from multiple streams with different providers does not respect fire and forget settings. I am trying to broadcast the same event to multiple streams that have different `FireAndForgetDelivery` properties using SMS.
For the first stream I want to be sure that the event is handled correctly and I will take necessary actions if an exception is thrown. The other stream will notify the UI and I don't care about the exceptions it throws.

The actual behavior I see is that both streams act like the same as far as `FireAndForgetDelivery` is considered. Which stream fires the first determines the `FireAndForgetDelivery` behavior for the other. This causes deadlocks when UI code calls the grain inside subscription callback.

The problem can be reproduced with the code below:

``` c#
public interface ITestGrain : IGrainWithGuidKey
{
	Task Test();
	Task Deadlock();
}

public class TestEvent
{
}

public class TestGrain : Grain ITestGrain
{
	private IAsyncStream&lt;TestEvent&gt; _interGrainStream;
	private IAsyncStream&lt;TestEvent&gt; _notificationStream;

	public override Task OnActivateAsync()
	{
		_interGrainStream = GetStreamProvider("Provider1").GetStream&lt;TestEvent&gt;(this.GetPrimaryKey() "Test");
		_notificationStream = GetStreamProvider("Provider2").GetStream&lt;TestEvent&gt;(this.GetPrimaryKey() "Test.Notification");

		return Task.CompletedTask;
	}

	public async Task Test()
	{
		TestEvent testEvent = new TestEvent();
		
		await _interGrainStream.OnNextAsync(testEvent);
		await _notificationStream.OnNextAsync(testEvent);
	}
	
	public Task Deadlock()
	{
		return Task.CompletedTask;
	}
}
```

Host code:
``` c#
using System.Threading.Tasks;
using Microsoft.Extensions.Hosting;
using Orleans.Grains;
using Orleans.Hosting;

namespace Orleans.Host
{
	public class Program
	{
		public static async Task Main(string[] args)
		{
            IHost host = new HostBuilder()
                .UseOrleans((context siloBuilder) =&gt;
                {
                    siloBuilder
                        .UseLocalhostClustering()
                        .AddMemoryGrainStorage("PubSubStore")
                        .AddSimpleMessageStreamProvider("Provider1" x =&gt;
                        {
                            x.FireAndForgetDelivery = false;
                        })
                        .AddSimpleMessageStreamProvider("Provider2" x =&gt;
                        {
                            x.FireAndForgetDelivery = true;
                        })
                        .ConfigureApplicationParts(x =&gt;
                        {
                            x.AddApplicationPart(typeof(TestGrain).Assembly).WithReferences();
                        });
                })
                .Build();

            await host.RunAsync();
        }
    }
}
```

Client code:
``` c#
using System;
using System.Threading.Tasks;
using Orleans.Hosting;
using Orleans.Interface;
using Orleans.Streams;

namespace Orleans.Client
{
	public class Program
	{
		public static async Task Main(string[] args)
		{
			IClusterClient clusterClient = new ClientBuilder()
				.UseLocalhostClustering()
				.AddSimpleMessageStreamProvider("Provider1")
				.AddSimpleMessageStreamProvider("Provider2")
				.Build();

			await clusterClient.Connect(x =&gt;
			{
				Console.WriteLine("Could not connect to server retrying.");
				return Task.FromResult(true);
			});

			ITestGrain grain = clusterClient.GetGrain&lt;ITestGrain&gt;(Guid.NewGuid());

			await clusterClient
				.GetStreamProvider("Provider1")
				.GetStream&lt;TestEvent&gt;(grain.GetPrimaryKey() "Test")
				.SubscribeAsync(async (x _) =&gt;
				{
					// await grain.Deadlock();
				});

			await clusterClient
				.GetStreamProvider("Provider2")
				.GetStream&lt;TestEvent&gt;(grain.GetPrimaryKey() "Test.Notification")
				.SubscribeAsync(async (x _) =&gt;
				{
					await grain.Deadlock();
				});

			await grain.Test();

			await Task.Delay(TimeSpan.FromDays(1));
		}
	}
}
```

If you change the order of `OnNextAsync` calls and uncomment the `// await grain.Deadlock();` line there will be no deadlock even though the uncommented line should cause a deadlock.

What I found is that in `SimpleMessageStreamProducer&lt;T&gt;.RegisterProducer` method provider name is not considered while fetching the extension class. So the extension class for the first one is cached and used for all other streams.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5837</IssueLabelID>
    <Title>Cherry-pick #5691 (Add core tracing events) for 2.4.0</Title>
    <Description>(cherry picked from commit a8abc360d572246a794cb14ff594656c275fe0e1)</Description>
    <Title_Description>Cherry-pick #5691 (Add core tracing events) for 2.4.0 (cherry picked from commit a8abc360d572246a794cb14ff594656c275fe0e1)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5835</IssueLabelID>
    <Title>Cherry-picked three more commits for 2.4.0</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked three more commits for 2.4.0 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5833</IssueLabelID>
    <Title>Always log stack trace when a Task is enqueued for an invalid activation</Title>
    <Description>
    </Description>
    <Title_Description>Always log stack trace when a Task is enqueued for an invalid activation </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5832</IssueLabelID>
    <Title>Stop background transaction processing when a grain deactivates</Title>
    <Description>Several parts of the transaction processing system rely on background workers for transaction servicing. For example there is a storage worker a lock worker and a confirmation worker.

When an activation terminates these workers must be made aware so that they can also gracefully terminate.

This PR is a follow-up to #5821 extending the termination to the storage worker &amp; lock worker</Description>
    <Title_Description>Stop background transaction processing when a grain deactivates Several parts of the transaction processing system rely on background workers for transaction servicing. For example there is a storage worker a lock worker and a confirmation worker.

When an activation terminates these workers must be made aware so that they can also gracefully terminate.

This PR is a follow-up to #5821 extending the termination to the storage worker &amp; lock worker</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5831</IssueLabelID>
    <Title>Use simple await in Connection</Title>
    <Description>Simple is best :)</Description>
    <Title_Description>Use simple await in Connection Simple is best :)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5830</IssueLabelID>
    <Title>Use simple await in HostedClient.RunClientMessagePump</Title>
    <Description>driveby</Description>
    <Title_Description>Use simple await in HostedClient.RunClientMessagePump driveby</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5829</IssueLabelID>
    <Title>Nulleble enum not serialized/deserialized (default serializer)</Title>
    <Description>When contract which is returned from other silo has any nullable enum property deserialization fails in calling silo grain.

We have property 
`public BetSlipEditTypes? BetSlipEditTypeId { get; set; } `

```
Exception stack trace:
 Orleans.Runtime.Messaging.IncomingMessageAcceptor[101017]
      Exception trying to process 4519 bytes from endpoint ****
System.TypeAccessException: Named type "BL.Domain.Enum.BetSlipEditTypes" is invalid: Type string "BL.Domain.Enum.BetSlipEditTypes" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader[TReader](TReader this SerializationManager serializationManager) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 423
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1270
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.DeserializationContext.DeserializeInner(Type expected) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\DeserializationContext.cs:line 77
   at OrleansGeneratedCode73FC44B9.OrleansCodeGenBL_Domain_Billing_BetSlipContractMinSerializer.Deserializer(Type expected IDeserializationContext context) in C:\TFS_New\BL.Sport\src\Grains\BL.Billing.Grains.BLL\obj\Debug\BL.Billing.Grains.BLL.orleans.g.cs:line 1521
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeKeyValuePair[KV](Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 1725
   at Orleans.Serialization.BuiltInTypes.DeserializeGenericKeyValuePair(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 1706
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeList[T](Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 134
   at Orleans.Serialization.BuiltInTypes.DeserializeGenericList(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 104
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.DeserializationContext.DeserializeInner(Type expected) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\DeserializationContext.cs:line 77
   at OrleansGeneratedCode73FC44B9.OrleansCodeGenBL_Domain_Billing_PlaceBetSlipsResultContractSerializer.Deserializer(Type expected IDeserializationContext context) in C:\TFS_New\BL.Sport\src\Grains\BL.Billing.Grains.BLL\obj\Debug\BL.Billing.Grains.BLL.orleans.g.cs:line 1299
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 2128
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1188
   at Orleans.Serialization.SerializationManager.Deserialize(IBinaryTokenStreamReader stream) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1155
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\Message.cs:line 434
   at Orleans.Runtime.Message.DeserializeBodyObject(SerializationManager serializationManager List`1 body) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\Message.cs:line 462
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 192
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\25\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 677
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101027]
```


What I found out in **BinaryTokenStreamReaderExtensinons** class method **ReadSpecifiedTypeHeader** does not have specified cast for nullable enum.

Orleans version 2.3.6.

</Description>
    <Title_Description>Nulleble enum not serialized/deserialized (default serializer) When contract which is returned from other silo has any nullable enum property deserialization fails in calling silo grain.

We have property 
`public BetSlipEditTypes? BetSlipEditTypeId { get; set; } `

```
Exception stack trace:
 Orleans.Runtime.Messaging.IncomingMessageAcceptor[101017]
      Exception trying to process 4519 bytes from endpoint ****
System.TypeAccessException: Named type "BL.Domain.Enum.BetSlipEditTypes" is invalid: Type string "BL.Domain.Enum.BetSlipEditTypes" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader[TReader](TReader this SerializationManager serializationManager) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 423
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1270
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.DeserializationContext.DeserializeInner(Type expected) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\DeserializationContext.cs:line 77
   at OrleansGeneratedCode73FC44B9.OrleansCodeGenBL_Domain_Billing_BetSlipContractMinSerializer.Deserializer(Type expected IDeserializationContext context) in C:\TFS_New\BL.Sport\src\Grains\BL.Billing.Grains.BLL\obj\Debug\BL.Billing.Grains.BLL.orleans.g.cs:line 1521
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeKeyValuePair[KV](Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 1725
   at Orleans.Serialization.BuiltInTypes.DeserializeGenericKeyValuePair(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 1706
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeList[T](Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 134
   at Orleans.Serialization.BuiltInTypes.DeserializeGenericList(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 104
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.DeserializationContext.DeserializeInner(Type expected) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\DeserializationContext.cs:line 77
   at OrleansGeneratedCode73FC44B9.OrleansCodeGenBL_Domain_Billing_PlaceBetSlipsResultContractSerializer.Deserializer(Type expected IDeserializationContext context) in C:\TFS_New\BL.Sport\src\Grains\BL.Billing.Grains.BLL\obj\Debug\BL.Billing.Grains.BLL.orleans.g.cs:line 1299
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 2128
   at Orleans.Serialization.SerializationManager.DeserializeInner[TContextTReader](SerializationManager sm Type expected TContext context TReader reader) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1318
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1218
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1188
   at Orleans.Serialization.SerializationManager.Deserialize(IBinaryTokenStreamReader stream) in D:\build\agent\_work\25\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1155
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\Message.cs:line 434
   at Orleans.Runtime.Message.DeserializeBodyObject(SerializationManager serializationManager List`1 body) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\Message.cs:line 462
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\25\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 192
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\25\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 677
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101027]
```


What I found out in **BinaryTokenStreamReaderExtensinons** class method **ReadSpecifiedTypeHeader** does not have specified cast for nullable enum.

Orleans version 2.3.6.

</Title_Description>
    <Label>serialization</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5828</IssueLabelID>
    <Title>Do not log warnings for OneWay CacheInvalidation Rejection messages</Title>
    <Description>We send `Rejection` responses to `[OneWay]` messages which target an invalid activation (eg one which was deactivated) with the `CacheInvalidation` header set in order to invalidate the cache.

Currently we will still log `No target activation &lt;activation&gt; for response message: &lt;mesage&gt;` messages at Warning level in that situation. This is just noise and we should not log these at such a high level. Consider `Debug` instead.</Description>
    <Title_Description>Do not log warnings for OneWay CacheInvalidation Rejection messages We send `Rejection` responses to `[OneWay]` messages which target an invalid activation (eg one which was deactivated) with the `CacheInvalidation` header set in order to invalidate the cache.

Currently we will still log `No target activation &lt;activation&gt; for response message: &lt;mesage&gt;` messages at Warning level in that situation. This is just noise and we should not log these at such a high level. Consider `Debug` instead.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5827</IssueLabelID>
    <Title>There are unresolved conflicts between different versions</Title>
    <Description>3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Configuration.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.DependencyInjection.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Hosting.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Logging”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Logging.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Options”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。</Description>
    <Title_Description>There are unresolved conflicts between different versions 3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Configuration.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.DependencyInjection.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Hosting.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Logging”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Logging.Abstractions”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。
3&gt;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets(21065): warning MSB3277: 发现“Microsoft.Extensions.Options”的不同版本间存在无法解决的冲突。当日志详细信息设置为“详细”时，这些引用冲突将会在生成日志中列出。</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5826</IssueLabelID>
    <Title>Is there an API-level document？</Title>
    <Description>Hope to provide API-level documentation</Description>
    <Title_Description>Is there an API-level document？ Hope to provide API-level documentation</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5825</IssueLabelID>
    <Title>Reject failed activations and fix possible race condition</Title>
    <Description>- Add another terminal state for activation to reject messages when `OnActivateAsync`failed
- Unregister failed activation from the directory before marking it as `Invalid` to avoid forwarding messages to the same activation
- Do not forward messages if the activation is in the `Deactivating` state. All pending messages will be forwarded after the activation has been unregistered from the directory</Description>
    <Title_Description>Reject failed activations and fix possible race condition - Add another terminal state for activation to reject messages when `OnActivateAsync`failed
- Unregister failed activation from the directory before marking it as `Invalid` to avoid forwarding messages to the same activation
- Do not forward messages if the activation is in the `Deactivating` state. All pending messages will be forwarded after the activation has been unregistered from the directory</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5824</IssueLabelID>
    <Title>Support custom SiloAddress to Endpoint mapping</Title>
    <Description>Currently we determine the endpoint to connect to for a given SiloAddress by looking at its Endpoint property.

With the introduction of new networking APIs (Bedrock) we will support custom transports. Some of these transports may not use IPEndpoint (the type of SiloAddress.Endpoint). For example a transport may use Named Pipes or some other IPC mechanism or HTTPS or something built from a connection string.

Bedrock transports accept an endpoint using the abstract System.Net.Endpoint type. The idea behind this was that users could create any kind of transport and implement a custom Endpoint implementation for their application.

In order to ensure we can leverage an ecosystem of transports and connection middleware we should consider a customisation point for users to provide a translation between SiloAddress and the particular Endpoint type used by their transport.

I think it could be as simple as this:

```c#
public interface IEndpointResolver
{
  ValueTask&lt;System.Net.Endpoint&gt; Resolve(SiloAddress address);
}
```</Description>
    <Title_Description>Support custom SiloAddress to Endpoint mapping Currently we determine the endpoint to connect to for a given SiloAddress by looking at its Endpoint property.

With the introduction of new networking APIs (Bedrock) we will support custom transports. Some of these transports may not use IPEndpoint (the type of SiloAddress.Endpoint). For example a transport may use Named Pipes or some other IPC mechanism or HTTPS or something built from a connection string.

Bedrock transports accept an endpoint using the abstract System.Net.Endpoint type. The idea behind this was that users could create any kind of transport and implement a custom Endpoint implementation for their application.

In order to ensure we can leverage an ecosystem of transports and connection middleware we should consider a customisation point for users to provide a translation between SiloAddress and the particular Endpoint type used by their transport.

I think it could be as simple as this:

```c#
public interface IEndpointResolver
{
  ValueTask&lt;System.Net.Endpoint&gt; Resolve(SiloAddress address);
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5822</IssueLabelID>
    <Title>Unable to invoke GrainService from Filter</Title>
    <Description>Hello!

From a a `IIncomingGrainCallFilter` implementation I'm able a `IGrainServiceClient` implementation.

However if I try to invoke any methods on the client I get this NRE:

```
Exception has occurred: CLR/Orleans.Runtime.OrleansLifecycleCanceledException
An exception of type 'Orleans.Runtime.OrleansLifecycleCanceledException' occurred in System.Private.CoreLib.dll but was not handled in user code: 'Lifecycle start canceled due to errors at stage 8000'
 Inner exceptions found see $exception in variables window for more details.
 Innermost exception 	 System.NullReferenceException : Object reference not set to an instance of an object.
   at Orleans.Runtime.Services.GrainServiceClient`1.MapGrainReferenceToSiloRing(GrainReference grainRef)
   at Orleans.Runtime.Services.GrainServiceClient`1.get_GrainService()
   at Orleans.Dashboard.AgentServiceClient.ReportProfile() in /Users/guto/dev/repos/OrleansContrib/Orleans.Dashboard/src/Orleans.Dashboard.Agent/AgentServiceClient.cs:line 13
   at Orleans.Dashboard.ProfileGrainInvocationFilter.&lt;Invoke&gt;d__3.MoveNext() in /Users/guto/dev/repos/OrleansContrib/Orleans.Dashboard/src/Orleans.Dashboard.Agent/Profiling/ProfileGrainInvocationFilter.cs:line 22
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__62.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync|4_0&gt;d`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__19`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;WaitForTableGrainToInit&gt;d__6.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;GetMembershipTable&gt;d__5.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;InitializeMembershipTable&gt;d__4.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.MembershipService.MembershipOracle.&lt;Start&gt;d__32.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__18.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;&gt;c__DisplayClass72_0.&lt;&lt;OnRuntimeGrainServicesStart&gt;g__StartMembershipOracle|1&gt;d.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__70.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;OnRuntimeGrainServicesStart&gt;d__72.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()
```

Can someone tell me if it is supported to invoke grain services from a filter? I know we can invoke grains but idk about grain services.

Thanks!</Description>
    <Title_Description>Unable to invoke GrainService from Filter Hello!

From a a `IIncomingGrainCallFilter` implementation I'm able a `IGrainServiceClient` implementation.

However if I try to invoke any methods on the client I get this NRE:

```
Exception has occurred: CLR/Orleans.Runtime.OrleansLifecycleCanceledException
An exception of type 'Orleans.Runtime.OrleansLifecycleCanceledException' occurred in System.Private.CoreLib.dll but was not handled in user code: 'Lifecycle start canceled due to errors at stage 8000'
 Inner exceptions found see $exception in variables window for more details.
 Innermost exception 	 System.NullReferenceException : Object reference not set to an instance of an object.
   at Orleans.Runtime.Services.GrainServiceClient`1.MapGrainReferenceToSiloRing(GrainReference grainRef)
   at Orleans.Runtime.Services.GrainServiceClient`1.get_GrainService()
   at Orleans.Dashboard.AgentServiceClient.ReportProfile() in /Users/guto/dev/repos/OrleansContrib/Orleans.Dashboard/src/Orleans.Dashboard.Agent/AgentServiceClient.cs:line 13
   at Orleans.Dashboard.ProfileGrainInvocationFilter.&lt;Invoke&gt;d__3.MoveNext() in /Users/guto/dev/repos/OrleansContrib/Orleans.Dashboard/src/Orleans.Dashboard.Agent/Profiling/ProfileGrainInvocationFilter.cs:line 22
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__62.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync|4_0&gt;d`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__19`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;WaitForTableGrainToInit&gt;d__6.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;GetMembershipTable&gt;d__5.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable.&lt;InitializeMembershipTable&gt;d__4.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.MembershipService.MembershipOracle.&lt;Start&gt;d__32.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__18.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;&gt;c__DisplayClass72_0.&lt;&lt;OnRuntimeGrainServicesStart&gt;g__StartMembershipOracle|1&gt;d.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__70.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.Silo.&lt;OnRuntimeGrainServicesStart&gt;d__72.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()
```

Can someone tell me if it is supported to invoke grain services from a filter? I know we can invoke grains but idk about grain services.

Thanks!</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5821</IssueLabelID>
    <Title>Terminate ConfirmationWorker loop on deactivation</Title>
    <Description>An implicit assumption in the ConfirmationWorker (part of Transactions) was that async tasks would stop executing when a grain was deactivated. However since #5588 we are continuing to execute Tasks scheduled against deactivated grains.

This resulted in tasks continually being scheduled against a deactivated grain causing a significant amount of log noise.</Description>
    <Title_Description>Terminate ConfirmationWorker loop on deactivation An implicit assumption in the ConfirmationWorker (part of Transactions) was that async tasks would stop executing when a grain was deactivated. However since #5588 we are continuing to execute Tasks scheduled against deactivated grains.

This resulted in tasks continually being scheduled against a deactivated grain causing a significant amount of log noise.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5820</IssueLabelID>
    <Title>Cherry-picked simple fixes and improvements for 2.3.7</Title>
    <Description>Improvement to cluster membership gossip aren't included here. They will be backported and submitted as a separate PR.</Description>
    <Title_Description>Cherry-picked simple fixes and improvements for 2.3.7 Improvement to cluster membership gossip aren't included here. They will be backported and submitted as a separate PR.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5819</IssueLabelID>
    <Title>RegexStreamNamespacePredicate is not serializable</Title>
    <Description>When using RegexImplicitStreamSubscriptionAttribute I experienced the following exception  in RegexStreamNamespacePredicate:

```
Unhandled Exception: System.Runtime.Serialization.SerializationException: Type 'System.Text.RegularExpressions.RegexReplacement' in Assembly 'System.Text.RegularExpressions Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
   at Orleans.OutsideRuntimeClient.StreamingInitialize()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at Orleankka.DemoExtensions.Connect(ISiloHost host Action`1 configure) in C:\Work\test\Orleankka\Samples\CSharp\Shared.cs:line 77
   at Example.Program.Main() in C:\Work\test\Orleankka\Samples\CSharp\EventSourcing\Idiomatic\Program.cs:line 28
   at Example.Program.&lt;Main&gt;()
```

Initially reported here: https://github.com/OrleansContrib/Orleankka/issues/159 but tracked down to Orleans codebase.</Description>
    <Title_Description>RegexStreamNamespacePredicate is not serializable When using RegexImplicitStreamSubscriptionAttribute I experienced the following exception  in RegexStreamNamespacePredicate:

```
Unhandled Exception: System.Runtime.Serialization.SerializationException: Type 'System.Text.RegularExpressions.RegexReplacement' in Assembly 'System.Text.RegularExpressions Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
   at Orleans.OutsideRuntimeClient.StreamingInitialize()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at Orleankka.DemoExtensions.Connect(ISiloHost host Action`1 configure) in C:\Work\test\Orleankka\Samples\CSharp\Shared.cs:line 77
   at Example.Program.Main() in C:\Work\test\Orleankka\Samples\CSharp\EventSourcing\Idiomatic\Program.cs:line 28
   at Example.Program.&lt;Main&gt;()
```

Initially reported here: https://github.com/OrleansContrib/Orleankka/issues/159 but tracked down to Orleans codebase.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5818</IssueLabelID>
    <Title>Implementing a method in an interface which hides a method in a base interface will cause codegen errors which don't easily give in to human understanding</Title>
    <Description>kidding but having an interface like 

```csharp
interface BaseFoo : IGrainWithStringKey
{
Task Bar();
}
```

And another

```
interface Foo : BaseFoo
{
new Task Bar();
}
```

Will cause codegen issues using both the `Microsoft.Orleans.CodeGenerator.MSBuild` package and the older one and the error mentions the id of the interface/method being a duplicate but the id cannot be found in codegen however thanks to @ReubenBond  I found that if you look at the line mentioned t he method will be there.

Double clicking in VS 2019 does not bring the codegen file up since it is in obj folder so you should know where it is to find it.

Best is to either have an analyzer not allowing methods hiding parent methods (since this is an error most of the times) or at least show an error with the method names involved. IMHO fixing this to generate correct code for it is not even required since almost always you don't want to do this in your interfaces</Description>
    <Title_Description>Implementing a method in an interface which hides a method in a base interface will cause codegen errors which don't easily give in to human understanding kidding but having an interface like 

```csharp
interface BaseFoo : IGrainWithStringKey
{
Task Bar();
}
```

And another

```
interface Foo : BaseFoo
{
new Task Bar();
}
```

Will cause codegen issues using both the `Microsoft.Orleans.CodeGenerator.MSBuild` package and the older one and the error mentions the id of the interface/method being a duplicate but the id cannot be found in codegen however thanks to @ReubenBond  I found that if you look at the line mentioned t he method will be there.

Double clicking in VS 2019 does not bring the codegen file up since it is in obj folder so you should know where it is to find it.

Best is to either have an analyzer not allowing methods hiding parent methods (since this is an error most of the times) or at least show an error with the method names involved. IMHO fixing this to generate correct code for it is not even required since almost always you don't want to do this in your interfaces</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5804</IssueLabelID>
    <Title>Gossip status change on shutdown for SystemTargetBasedMembershipTable</Title>
    <Description>This helps to improve stability in tests which involve shutdowns. Other membership providers already perform gossip (that's the normal path)</Description>
    <Title_Description>Gossip status change on shutdown for SystemTargetBasedMembershipTable This helps to improve stability in tests which involve shutdowns. Other membership providers already perform gossip (that's the normal path)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5802</IssueLabelID>
    <Title>Support configurable supported roles in transactional state.</Title>
    <Description>
    </Description>
    <Title_Description>Support configurable supported roles in transactional state. </Title_Description>
    <Label>enhancement</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5801</IssueLabelID>
    <Title>SMS streams batch delivered fix</Title>
    <Description>Fixed bug in SMS streams where events were not being delivered to batch observers.</Description>
    <Title_Description>SMS streams batch delivered fix Fixed bug in SMS streams where events were not being delivered to batch observers.</Title_Description>
    <Label>bug</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5800</IssueLabelID>
    <Title>Remove LocalSilo from MembershipTableSnapshot. Detect death in gossip</Title>
    <Description>Follow-up to #5796</Description>
    <Title_Description>Remove LocalSilo from MembershipTableSnapshot. Detect death in gossip Follow-up to #5796</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5799</IssueLabelID>
    <Title>Improve codegen's .NET Core 3 compatibility</Title>
    <Description>Fixes #5793 using @ReubenBond 's instructions.

Successfully compiles a minimal netstandard2.0 project on Linux .NET Core 2.2 3.0 Preview 7 and a combination of the 2.
Previously this would fail on the 3.0 variant.</Description>
    <Title_Description>Improve codegen's .NET Core 3 compatibility Fixes #5793 using @ReubenBond 's instructions.

Successfully compiles a minimal netstandard2.0 project on Linux .NET Core 2.2 3.0 Preview 7 and a combination of the 2.
Previously this would fail on the 3.0 variant.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5797</IssueLabelID>
    <Title>How to structure Grains for fast loading of historical data?</Title>
    <Description>Hello and thanks for building such an incredible framework. I’m beginning the process of sorting out how to leverage Orleans in a major revision of a project that I work on and have several high level questions that I’m hoping to receive some guidance on so I can avoid starting down the wrong path. If there is a better place or way to ask these questions I’d be happy to change venues. Also since I feel that an example application to tie together some of these concepts would help me personally as well as other newcomers in the IoT space I am very interested in contributing an example/quick start once I have a solid path to head down.

The platform that I’m working on handles the dispatching of work to drivers with the complexity that it is a multi-tenant application so we need to ensure each organization’s data is exclusive to their users and tablets. We currently provide this by putting each tenant’s data in their own SQL DB that only their users have access to (every tenant has a connection string to the correct DB). The dispatchers are using a windows desktop back office application with a companion ReactJS web app for viewing realtime/historical locations and the drivers are using an Android tablet app. We currently tie this all together with a blend of RESTish (there’s some RPC endpoints in it too) WebAPI that makes heavy use of Azure Event Hubs for incoming data from the tablets (processing happens in windows services that are subscribed to the hubs something that we want to move to Orleans) uses SignalR for pushing realtime data to the browser and loads most things out of each tenant’s SQL DB (which are not all in the same datacenter as the API).

So now that the “what” of what I’m trying to improve is out of the way where I need help is how we’re going to best utilize Orleans to improve our API. Using Orleans for the basic activity of the application feels really straight forward (although perhaps I’m over simplifying it) in that we can easily assign a Job to a Driver and trigger a push notification to the Device that the driver is using. When data comes in from a Device we can use an Event Hub based stream to queue the processing of its data and push the new location to the web app in realtime with SignalR. The challenging part for me is how to structure all this so that historical data can be easily and quickly retrieved as well as avoid packing too much data into a single Grain.

An example of this is that dispatchers may want to see the path a driver traveled to get to a job. Currently we load that data from the tenant’s DB and I would assume that is still the best way to handle it since loading data for a single driver is relatively quick. Where performance becomes challenging is loading the location of all devices from a particular point in time. Would it be reasonable to have a `ITenantGrain.LoadDeviceLocationAsOf(DateTime time)` that returns a list of all devices with their last known location at that point in time? If so what is the recommendation for implementing something like that? Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)? We currently make this perform reasonably well by constantly building per-minute time windowed data for each tenant that is persisted separately so we can grab the time window that holds the locations we’re looking for. This is expensive from a storage standpoint so we trash the time windows after 7 days and queries for older data become slow. This feels like an area of our application that we should be able to improve with the power of Orleans but I’m struggling to come up with an architecture that feels like a winner (likely because my optics are based in the way we’ve already solved it). If the pre-calculated time windows are still the best bet is there an example out there of how to do this in Orleans (essentially a per-minute list of all the location changes for all devices belonging to a tenant). 

This question is getting too long so I’ll leave it rooted in the historical data persistence and retrieval for now and as I gain a better understanding of the Orleans way of accomplishing some of this I’ll drill into other challenging aspects of the application.

If there’s some documentation that I should be reading to help come up with a solution or an example that I should be referencing instead of asking for help please share and I’ll gladly keep trying to sort this out on my own. Thank you very much for your time!</Description>
    <Title_Description>How to structure Grains for fast loading of historical data? Hello and thanks for building such an incredible framework. I’m beginning the process of sorting out how to leverage Orleans in a major revision of a project that I work on and have several high level questions that I’m hoping to receive some guidance on so I can avoid starting down the wrong path. If there is a better place or way to ask these questions I’d be happy to change venues. Also since I feel that an example application to tie together some of these concepts would help me personally as well as other newcomers in the IoT space I am very interested in contributing an example/quick start once I have a solid path to head down.

The platform that I’m working on handles the dispatching of work to drivers with the complexity that it is a multi-tenant application so we need to ensure each organization’s data is exclusive to their users and tablets. We currently provide this by putting each tenant’s data in their own SQL DB that only their users have access to (every tenant has a connection string to the correct DB). The dispatchers are using a windows desktop back office application with a companion ReactJS web app for viewing realtime/historical locations and the drivers are using an Android tablet app. We currently tie this all together with a blend of RESTish (there’s some RPC endpoints in it too) WebAPI that makes heavy use of Azure Event Hubs for incoming data from the tablets (processing happens in windows services that are subscribed to the hubs something that we want to move to Orleans) uses SignalR for pushing realtime data to the browser and loads most things out of each tenant’s SQL DB (which are not all in the same datacenter as the API).

So now that the “what” of what I’m trying to improve is out of the way where I need help is how we’re going to best utilize Orleans to improve our API. Using Orleans for the basic activity of the application feels really straight forward (although perhaps I’m over simplifying it) in that we can easily assign a Job to a Driver and trigger a push notification to the Device that the driver is using. When data comes in from a Device we can use an Event Hub based stream to queue the processing of its data and push the new location to the web app in realtime with SignalR. The challenging part for me is how to structure all this so that historical data can be easily and quickly retrieved as well as avoid packing too much data into a single Grain.

An example of this is that dispatchers may want to see the path a driver traveled to get to a job. Currently we load that data from the tenant’s DB and I would assume that is still the best way to handle it since loading data for a single driver is relatively quick. Where performance becomes challenging is loading the location of all devices from a particular point in time. Would it be reasonable to have a `ITenantGrain.LoadDeviceLocationAsOf(DateTime time)` that returns a list of all devices with their last known location at that point in time? If so what is the recommendation for implementing something like that? Would it work to asyncly iterate through all the devices asking each of them to figure out where they where (there can be 100 - 1000ish devices per tenant)? We currently make this perform reasonably well by constantly building per-minute time windowed data for each tenant that is persisted separately so we can grab the time window that holds the locations we’re looking for. This is expensive from a storage standpoint so we trash the time windows after 7 days and queries for older data become slow. This feels like an area of our application that we should be able to improve with the power of Orleans but I’m struggling to come up with an architecture that feels like a winner (likely because my optics are based in the way we’ve already solved it). If the pre-calculated time windows are still the best bet is there an example out there of how to do this in Orleans (essentially a per-minute list of all the location changes for all devices belonging to a tenant). 

This question is getting too long so I’ll leave it rooted in the historical data persistence and retrieval for now and as I gain a better understanding of the Orleans way of accomplishing some of this I’ll drill into other challenging aspects of the application.

If there’s some documentation that I should be reading to help come up with a solution or an example that I should be referencing instead of asking for help please share and I’ll gladly keep trying to sort this out on my own. Thank you very much for your time!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5796</IssueLabelID>
    <Title>Send a snapshot of the membership table on gossip</Title>
    <Description>Right now when a silo change a silo entry in the membership table it will "gossip" the new silo/status to other silos in the cluster. Since silos can miss notifications it's not safe for them to infer anything based on this information alone so they have to go to storage and refresh the all table.

In this PR now silo that has modified the membership table will send a full snapshot of it with the version number. This way other silos in the cluster can either ignore the gossip if they are already up-to-date (or ahead) or can simply use it directly without reading in the storage.

This should reduce the time of membership change propagation and reduce contention on the membership table.</Description>
    <Title_Description>Send a snapshot of the membership table on gossip Right now when a silo change a silo entry in the membership table it will "gossip" the new silo/status to other silos in the cluster. Since silos can miss notifications it's not safe for them to infer anything based on this information alone so they have to go to storage and refresh the all table.

In this PR now silo that has modified the membership table will send a full snapshot of it with the version number. This way other silos in the cluster can either ignore the gossip if they are already up-to-date (or ahead) or can simply use it directly without reading in the storage.

This should reduce the time of membership change propagation and reduce contention on the membership table.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5795</IssueLabelID>
    <Title>Calling Grain from StreamProvider throws Serialization Exception</Title>
    <Description>I am invoking a grain from within my stream provider to track incoming messages. This is working fine locally but _sometimes_ fails then running on multiple silos with the following errors:

```
System.Runtime.Serialization.SerializationException: Type 'System.Net.Http.HttpConnectionPoolManager' in Assembly 'System.Net.Http Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.    at System.Runtime.Serialization.FormatterServices.InternalGetSerializableMembers(Type type)    at System.Runtime.Serialization.FormatterServices.&lt;&gt;c.&lt;GetSerializableMembers&gt;b__5_0(MemberHolder mh)    at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)    at System.Runtime.Serialization.FormatterServices.GetSerializableMembers(Type type StreamingContext context)    at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitMemberInfo()    at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
--

```

This is is where I'm using it: https://github.com/jonathansant/Orleans.Streams.Kafka/blob/d67a72f722055daa834d435138cb9c44ed731a3b/Orleans.Streams.Kafka/Core/KafkaAdapterReceiver.cs#L163

Please note that the call to the `MessageTrackingGrain` is `OneWay`

The Message tracking grain:
https://github.com/jonathansant/Orleans.Streams.Utils/blob/master/Orleans.Streams.Utils/MessageTracking/MessageTrackingGrain.cs

I not doing any grain calls with HttpConnectionPoolManager so I'm not sure why it's trying to serialize an HttpConnectionPoolManager</Description>
    <Title_Description>Calling Grain from StreamProvider throws Serialization Exception I am invoking a grain from within my stream provider to track incoming messages. This is working fine locally but _sometimes_ fails then running on multiple silos with the following errors:

```
System.Runtime.Serialization.SerializationException: Type 'System.Net.Http.HttpConnectionPoolManager' in Assembly 'System.Net.Http Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.    at System.Runtime.Serialization.FormatterServices.InternalGetSerializableMembers(Type type)    at System.Runtime.Serialization.FormatterServices.&lt;&gt;c.&lt;GetSerializableMembers&gt;b__5_0(MemberHolder mh)    at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)    at System.Runtime.Serialization.FormatterServices.GetSerializableMembers(Type type StreamingContext context)    at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitMemberInfo()    at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
--

```

This is is where I'm using it: https://github.com/jonathansant/Orleans.Streams.Kafka/blob/d67a72f722055daa834d435138cb9c44ed731a3b/Orleans.Streams.Kafka/Core/KafkaAdapterReceiver.cs#L163

Please note that the call to the `MessageTrackingGrain` is `OneWay`

The Message tracking grain:
https://github.com/jonathansant/Orleans.Streams.Utils/blob/master/Orleans.Streams.Utils/MessageTracking/MessageTrackingGrain.cs

I not doing any grain calls with HttpConnectionPoolManager so I'm not sure why it's trying to serialize an HttpConnectionPoolManager</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5793</IssueLabelID>
    <Title>MSBuild codegen failing when only .NET Core 3 preview SDK is available</Title>
    <Description>It would appear something is causing `Microsoft.Orleans.CodeGenerator.MSBuild` to fall back to trying to use .NET Core 2.0.0 SDK when only .NET Core 3 Preview7 is available.

When using only 3.0 I'm getting the following message when attempting to build a .net standard 2.0 library containing a grain:

```
  It was not possible to find any compatible framework version
  The specified framework 'Microsoft.NETCore.App' version '2.0.0' was not found.
    - The following frameworks were found:
        3.0.0-preview7-27912-14 at [/usr/share/dotnet/shared/Microsoft.NETCore.App]

  You can resolve the problem by installing the specified framework and/or SDK.

  The .NET Core frameworks can be found at:
    - https://aka.ms/dotnet-download
```

I've setup a reproduction case at https://github.com/Vhab/OrleansCodegenNetCore3

It's using docker as it's the easiest way to get a clean environment to test in.

It contains 3 images one with .NET Core 22 one with 3.0p7 and one with both.
The first and last one build fine but the one with only 3.0 fails.

The repo includes a readme with how to run the reproduction cases.</Description>
    <Title_Description>MSBuild codegen failing when only .NET Core 3 preview SDK is available It would appear something is causing `Microsoft.Orleans.CodeGenerator.MSBuild` to fall back to trying to use .NET Core 2.0.0 SDK when only .NET Core 3 Preview7 is available.

When using only 3.0 I'm getting the following message when attempting to build a .net standard 2.0 library containing a grain:

```
  It was not possible to find any compatible framework version
  The specified framework 'Microsoft.NETCore.App' version '2.0.0' was not found.
    - The following frameworks were found:
        3.0.0-preview7-27912-14 at [/usr/share/dotnet/shared/Microsoft.NETCore.App]

  You can resolve the problem by installing the specified framework and/or SDK.

  The .NET Core frameworks can be found at:
    - https://aka.ms/dotnet-download
```

I've setup a reproduction case at https://github.com/Vhab/OrleansCodegenNetCore3

It's using docker as it's the easiest way to get a clean environment to test in.

It contains 3 images one with .NET Core 22 one with 3.0p7 and one with both.
The first and last one build fine but the one with only 3.0 fails.

The repo includes a readme with how to run the reproduction cases.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5789</IssueLabelID>
    <Title>Mechanism to fetch all states from a grain (Like Select * from table)</Title>
    <Description>
    </Description>
    <Title_Description>Mechanism to fetch all states from a grain (Like Select * from table) </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5782</IssueLabelID>
    <Title>Missing UsePerfCounterEnvironmentStatistics for SiloBuilder</Title>
    <Description>There is currently no extension method `UsePerfCounterEnvironmentStatistics` for `ISiloBuilder` (only `ISiloHostBuilder`) but a corresponding `UseLinuxEnvironmentStatistics` was added for `ISiloBuilder`. Is there a plan to add this method or a workaround? I can simulate with reflection but I'd rather not.</Description>
    <Title_Description>Missing UsePerfCounterEnvironmentStatistics for SiloBuilder There is currently no extension method `UsePerfCounterEnvironmentStatistics` for `ISiloBuilder` (only `ISiloHostBuilder`) but a corresponding `UseLinuxEnvironmentStatistics` was added for `ISiloBuilder`. Is there a plan to add this method or a workaround? I can simulate with reflection but I'd rather not.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5781</IssueLabelID>
    <Title>Silo fail to start if have other active silos in membership table</Title>
    <Description>We've detected some unwanted behavior with single silo start after whole cluster fail unexpectedly.
We use SQL membership Provider and here is sample reproduce code:

```csharp
            var host = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "dev";
                })
                .ConfigureEndpoints(11111 30000)
                .UseAdoNetClustering(options =&gt;
                {
                    options.Invariant = "System.Data.SqlClient";
                    options.ConnectionString = "Data Source=localhost;Initial Catalog=OrleansTest;Integrated Security=true";
                })
                .Build();

            try
            {
                await host.StartAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }

           await host.StopAsync();
```

And suppose we have 3 silos before crash occured:

```sql
insert into OrleansMembershipTable (DeploymentId Address Port Generation SiloName HostName Status ProxyPort StartTime IAmAliveTime)
values
    ('dev' '192.168.18.113' 11111 301637233 'Silo_11111' 'siloserver1' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
   ('dev' '192.168.18.114' 11111 301637233 'Silo_11112' 'siloserver2' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
   ('dev' '192.168.18.115' 11111 301637233 'Silo_11113' 'siloserver3' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
```

Then we start silo only at **siloserver1**.
We expect that this silo will drop all others and start succesfully but we get timeout at `host.StartAsync();`.

I am aware of some similar issues #5463 #3009 and the behavior implemented in #3261 
But the problem is we cannot start other nodes - cluster should be self aware and self healing in this scenario. Also with this in mind we do now want to get unexpected errors when some silo got network split from other silos (but not the database).

Can you provide help with that? Can MembershipTable handle this OR we should implement it in our way?</Description>
    <Title_Description>Silo fail to start if have other active silos in membership table We've detected some unwanted behavior with single silo start after whole cluster fail unexpectedly.
We use SQL membership Provider and here is sample reproduce code:

```csharp
            var host = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "dev";
                })
                .ConfigureEndpoints(11111 30000)
                .UseAdoNetClustering(options =&gt;
                {
                    options.Invariant = "System.Data.SqlClient";
                    options.ConnectionString = "Data Source=localhost;Initial Catalog=OrleansTest;Integrated Security=true";
                })
                .Build();

            try
            {
                await host.StartAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }

           await host.StopAsync();
```

And suppose we have 3 silos before crash occured:

```sql
insert into OrleansMembershipTable (DeploymentId Address Port Generation SiloName HostName Status ProxyPort StartTime IAmAliveTime)
values
    ('dev' '192.168.18.113' 11111 301637233 'Silo_11111' 'siloserver1' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
   ('dev' '192.168.18.114' 11111 301637233 'Silo_11112' 'siloserver2' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
   ('dev' '192.168.18.115' 11111 301637233 'Silo_11113' 'siloserver3' 3 30000 DATEADD(MINUTE -10 SYSUTCDATETIME()) DATEADD(MINUTE -1 SYSUTCDATETIME()))
```

Then we start silo only at **siloserver1**.
We expect that this silo will drop all others and start succesfully but we get timeout at `host.StartAsync();`.

I am aware of some similar issues #5463 #3009 and the behavior implemented in #3261 
But the problem is we cannot start other nodes - cluster should be self aware and self healing in this scenario. Also with this in mind we do now want to get unexpected errors when some silo got network split from other silos (but not the database).

Can you provide help with that? Can MembershipTable handle this OR we should implement it in our way?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5778</IssueLabelID>
    <Title>Heterogeneous Silo and "Cannot find an implementation class" error</Title>
    <Description>Hello
can't figure out what is wrong with my Orleans based solution. Please advise.
I have four projects:
1. ClientApi - webapi application references Orleans nugets and grain interfaces project;
2. GrainInterface - grains interfaces
3. Coordinator - silo references Orleans MSBuild nuget and grain interfaces project. Contains grains implementation.
4. DataAccessor - silo references Orleans MSBuild nuget and grain interfaces project. Contains grains implementation.
Now from the controller i'm getting grain reference for the grain which is hosted in Coordinator silo. It gets called. From withing that grain i'm trying to get grain reference (using GrainsFactory property) which is hosted in DataAccessor silo. And here i'm getting exception "cannot find an implementation class...". 

I've read all documentation and it seems that i don't need to do some additional configuration for this to work. All my silos configured with the code similar to this:
```
                .UseOrleans((context builder) =&gt;
                {
                    builder
                        .UseLocalhostClustering()
                        .Configure&lt;ClusterOptions&gt;(options =&gt;
                        {
                            options.ClusterId = "ClusterId";
                            options.ServiceId = "UniqueServiceId";
                        })
                        .ConfigureApplicationParts(parts =&gt;
                        {
                            parts.AddApplicationPart(executingAssembly).WithReferences();
                        });
                })
```
Here executingAssembly is the assembly of my console project with the grain implementations.</Description>
    <Title_Description>Heterogeneous Silo and "Cannot find an implementation class" error Hello
can't figure out what is wrong with my Orleans based solution. Please advise.
I have four projects:
1. ClientApi - webapi application references Orleans nugets and grain interfaces project;
2. GrainInterface - grains interfaces
3. Coordinator - silo references Orleans MSBuild nuget and grain interfaces project. Contains grains implementation.
4. DataAccessor - silo references Orleans MSBuild nuget and grain interfaces project. Contains grains implementation.
Now from the controller i'm getting grain reference for the grain which is hosted in Coordinator silo. It gets called. From withing that grain i'm trying to get grain reference (using GrainsFactory property) which is hosted in DataAccessor silo. And here i'm getting exception "cannot find an implementation class...". 

I've read all documentation and it seems that i don't need to do some additional configuration for this to work. All my silos configured with the code similar to this:
```
                .UseOrleans((context builder) =&gt;
                {
                    builder
                        .UseLocalhostClustering()
                        .Configure&lt;ClusterOptions&gt;(options =&gt;
                        {
                            options.ClusterId = "ClusterId";
                            options.ServiceId = "UniqueServiceId";
                        })
                        .ConfigureApplicationParts(parts =&gt;
                        {
                            parts.AddApplicationPart(executingAssembly).WithReferences();
                        });
                })
```
Here executingAssembly is the assembly of my console project with the grain implementations.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5774</IssueLabelID>
    <Title>[Question] There is a way to call another Grain without waiting for the Task?</Title>
    <Description>For example I have to send SMS messages and I want to just call the sending method and without waiting for it to finish (and the result) continue to execute my code in the Grain process.
Is it possible to do?

``` cs
....
var grain1 = GrainFactory.GetGrain&lt;IGrain&gt;(1);
_ = grain1.DoSome(); //skip await
var x = 1;
.....

</Description>
    <Title_Description>[Question] There is a way to call another Grain without waiting for the Task? For example I have to send SMS messages and I want to just call the sending method and without waiting for it to finish (and the result) continue to execute my code in the Grain process.
Is it possible to do?

``` cs
....
var grain1 = GrainFactory.GetGrain&lt;IGrain&gt;(1);
_ = grain1.DoSome(); //skip await
var x = 1;
.....

</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5772</IssueLabelID>
    <Title>F# support - discussion</Title>
    <Description>Following our discussion in #38 I've been thinking of possible problems we'll run into along the way. Here's a list (I'll elaborate on each one further below):

1. Orleans grains are defined via interfaces and classes. While F# supports OO-style code it's not what we love F# for. We'll need a functional way of creating grains. This should be the single most important goal of this effort IMO: no OO code in grains and as little as possible in other places.
2. Orleans uses constructor dependency injection. No OO means no constructors which means we need a functional way to inject dependencies.
3. The `Grain` class includes some common functionality such as timers and reminders. We need a way to make the same functionality available.
4. Grains use fields on the grain class as temporary storage. We some place to store transient data between calls to the same grain.
5. We need compile-time F# code generation.
6. We need a (functional) way to actually call the grains from the client side.
7. We need to pass functions as arguments. Higher order functions are a fundamental building block of functional programming.
8. …?

# 1. Functional interface to grains

This is a rather challenging design choice. I can think of three ways to implement it detailed below. We'd probably use some special grain class which can call into these.

## Messages as DU with single handler method

This is almost exactly what Orleankka does. Each grain will be defined as a DU containing the messages to it and a single handler function. Personally I don't like really long functions but the F# `function` keyword will be helpful here:

```
type HelloGrainMessages =
    | SetName of name: string
    | SayHello

let helloGrainHandler = function
    | SetName name -&gt; myname &lt;- name // Assuming myname is a transient field
    | SayHello -&gt; sprintf "Hello %s!" myname
```

Pros: 
* Function arguments can be named.
* Very easy to split into "interface" and "implementation" just put the DU in the interface binary and the handler in the implementation binary.
* If we need to pass additional parameters to the "grain methods" we'll only need to specify them once per grain.

Cons:
* No return types so can't be fully type-safe. This is a very important drawback.
* The async part has to be hidden and handled by the framework so optimizations such as `return WriteStateAsync();` are impossible.

## Messages as record containing function signatures

Similar to [Bolero's remoting feature](https://fsbolero.io/docs/Remoting) there will be a record type per grain. This record type will include function fields which will then be implemented as a value:

```
type HelloGrain = {
    SetName: string -&gt; unit
    SayHello: unit -&gt; string
    }

let helloGrain = {
    SetName = fun name -&gt; myname &lt;- name
    SayHello = fun () -&gt; sprintf "Hello %s!" myname
}
```

Pros:
* Also very easy to split into interface and implementation. The type goes in the interface binary the value goes in the implementation binary.
* Fully type-safe including return types.

Cons:
* No argument names in the type meaning clients don't get good intellisense.
* The syntax doesn't feel... natural to me. I'm used to `let f x = ...` over `fun x -&gt; ...`
* It's unclear how we can pass additional parameters to the functions. They certainly can't be in the function arguments since those are visible to clients.

## Messages as module functions

Each grain will be a module containing functions which will represent grain methods:

```
module HelloGrain
let SetName name = myname &lt;- name
let SayHello = sprintf "Hello %s!" myname
```

Pros:
* This is as idiomatic as it gets. 'Nuff said.

Cons:
* I don't know how (or indeed if) such code can be split into interface and implementation binaries. It *may* be possible to codegen the entire client interface to produce a mock copy of the module but we'd need to compile it *across binaries* which also means we'd need to have a mapping of implementation to interface binaries; not to mention making the interface dependent on the implementation. If it gets to that we may as well just leave the interface out of the source and codegen the entire thing for clients to use.
* Also unclear how we can pass additional parameters to the functions.

# 2. Dependency injection

The grains will need a way to declare the services they need. I'm guessing they can introduce a record type containing the services they require which will be created at runtime and passed to each invocation of each function.

We would still need a type-safe way to introduce the record the framework and still use it in the functions.

# 3. Grain class functionality

This is rather simple. We could just create a module with the equivalent functions for "grains" to call. However we'd need a way to pass the grain's identity to those functions. Grain identity can probably be obtained via our dependency injection mechanism or a mechanism similar to it. For example we could have something like this:

```
type RequiredStuffForGrains&lt;'TServices&gt; = {
    identity: GrainIdentity
    services: 'TServices
    ...
    }
```

# 4. Transient storage

This is probably simple: We could inject an `ITransientData&lt;'TData&gt;` into the grains and use that.

# 5. Code-gen

I haven't looked at the codegen sources yet but if my guess is right and it reads the compiled binaries this should be (relatively) simple to implement.

# 6. Calling grains

This really depends on the details of how grains are implemented so I'll leave it out for now.

# 7. Higher order functions

IIRC F# compiles each "function" to many subclasses of FSharpFunc one for each argument. We may very well be able to just serialize the resulting objects like any other POCO.

However careful thought must be given to this matter because any POCO's that travel over the wire need serialization code generated for them. We could generate code for all subclasses of FSharpFunc but I think it'll lead to an unacceptable increase in binary size specially since F# generates so many of them.

----------------

I'd love to know what everybody thinks about all of this.</Description>
    <Title_Description>F# support - discussion Following our discussion in #38 I've been thinking of possible problems we'll run into along the way. Here's a list (I'll elaborate on each one further below):

1. Orleans grains are defined via interfaces and classes. While F# supports OO-style code it's not what we love F# for. We'll need a functional way of creating grains. This should be the single most important goal of this effort IMO: no OO code in grains and as little as possible in other places.
2. Orleans uses constructor dependency injection. No OO means no constructors which means we need a functional way to inject dependencies.
3. The `Grain` class includes some common functionality such as timers and reminders. We need a way to make the same functionality available.
4. Grains use fields on the grain class as temporary storage. We some place to store transient data between calls to the same grain.
5. We need compile-time F# code generation.
6. We need a (functional) way to actually call the grains from the client side.
7. We need to pass functions as arguments. Higher order functions are a fundamental building block of functional programming.
8. …?

# 1. Functional interface to grains

This is a rather challenging design choice. I can think of three ways to implement it detailed below. We'd probably use some special grain class which can call into these.

## Messages as DU with single handler method

This is almost exactly what Orleankka does. Each grain will be defined as a DU containing the messages to it and a single handler function. Personally I don't like really long functions but the F# `function` keyword will be helpful here:

```
type HelloGrainMessages =
    | SetName of name: string
    | SayHello

let helloGrainHandler = function
    | SetName name -&gt; myname &lt;- name // Assuming myname is a transient field
    | SayHello -&gt; sprintf "Hello %s!" myname
```

Pros: 
* Function arguments can be named.
* Very easy to split into "interface" and "implementation" just put the DU in the interface binary and the handler in the implementation binary.
* If we need to pass additional parameters to the "grain methods" we'll only need to specify them once per grain.

Cons:
* No return types so can't be fully type-safe. This is a very important drawback.
* The async part has to be hidden and handled by the framework so optimizations such as `return WriteStateAsync();` are impossible.

## Messages as record containing function signatures

Similar to [Bolero's remoting feature](https://fsbolero.io/docs/Remoting) there will be a record type per grain. This record type will include function fields which will then be implemented as a value:

```
type HelloGrain = {
    SetName: string -&gt; unit
    SayHello: unit -&gt; string
    }

let helloGrain = {
    SetName = fun name -&gt; myname &lt;- name
    SayHello = fun () -&gt; sprintf "Hello %s!" myname
}
```

Pros:
* Also very easy to split into interface and implementation. The type goes in the interface binary the value goes in the implementation binary.
* Fully type-safe including return types.

Cons:
* No argument names in the type meaning clients don't get good intellisense.
* The syntax doesn't feel... natural to me. I'm used to `let f x = ...` over `fun x -&gt; ...`
* It's unclear how we can pass additional parameters to the functions. They certainly can't be in the function arguments since those are visible to clients.

## Messages as module functions

Each grain will be a module containing functions which will represent grain methods:

```
module HelloGrain
let SetName name = myname &lt;- name
let SayHello = sprintf "Hello %s!" myname
```

Pros:
* This is as idiomatic as it gets. 'Nuff said.

Cons:
* I don't know how (or indeed if) such code can be split into interface and implementation binaries. It *may* be possible to codegen the entire client interface to produce a mock copy of the module but we'd need to compile it *across binaries* which also means we'd need to have a mapping of implementation to interface binaries; not to mention making the interface dependent on the implementation. If it gets to that we may as well just leave the interface out of the source and codegen the entire thing for clients to use.
* Also unclear how we can pass additional parameters to the functions.

# 2. Dependency injection

The grains will need a way to declare the services they need. I'm guessing they can introduce a record type containing the services they require which will be created at runtime and passed to each invocation of each function.

We would still need a type-safe way to introduce the record the framework and still use it in the functions.

# 3. Grain class functionality

This is rather simple. We could just create a module with the equivalent functions for "grains" to call. However we'd need a way to pass the grain's identity to those functions. Grain identity can probably be obtained via our dependency injection mechanism or a mechanism similar to it. For example we could have something like this:

```
type RequiredStuffForGrains&lt;'TServices&gt; = {
    identity: GrainIdentity
    services: 'TServices
    ...
    }
```

# 4. Transient storage

This is probably simple: We could inject an `ITransientData&lt;'TData&gt;` into the grains and use that.

# 5. Code-gen

I haven't looked at the codegen sources yet but if my guess is right and it reads the compiled binaries this should be (relatively) simple to implement.

# 6. Calling grains

This really depends on the details of how grains are implemented so I'll leave it out for now.

# 7. Higher order functions

IIRC F# compiles each "function" to many subclasses of FSharpFunc one for each argument. We may very well be able to just serialize the resulting objects like any other POCO.

However careful thought must be given to this matter because any POCO's that travel over the wire need serialization code generated for them. We could generate code for all subclasses of FSharpFunc but I think it'll lead to an unacceptable increase in binary size specially since F# generates so many of them.

----------------

I'd love to know what everybody thinks about all of this.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5771</IssueLabelID>
    <Title>Upgrade System.Net.Http to 4.3.4</Title>
    <Description>
    </Description>
    <Title_Description>Upgrade System.Net.Http to 4.3.4 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5770</IssueLabelID>
    <Title>Remove options and logic for automatic resending of messages</Title>
    <Description>Resolves #5667.

Automatic message resend was a bad idea. We forgot to remove the logic in 2.0.</Description>
    <Title_Description>Remove options and logic for automatic resending of messages Resolves #5667.

Automatic message resend was a bad idea. We forgot to remove the logic in 2.0.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5769</IssueLabelID>
    <Title>Fix OnCompleteAsync &amp; OnErrorAsync in StreamImpl</Title>
    <Description>Fixes #5697.
Fix NullRreferenceException thrown in OnCompletedAsync &amp; OnErrorAsync.</Description>
    <Title_Description>Fix OnCompleteAsync &amp; OnErrorAsync in StreamImpl Fixes #5697.
Fix NullRreferenceException thrown in OnCompletedAsync &amp; OnErrorAsync.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5768</IssueLabelID>
    <Title>[Question]: Silo connection via bus.</Title>
    <Description>Hello tell me please is there a way to connect Silo nodes to a bus like Redis or Azure Queue?
I tried to use Azure AppService as hosting my .net core webapi application which also contains Silo but the AppService does not allow opening a private endpoint for Silo connections. 
And I wondered if it was possible to connect the nodes without a direct connection.</Description>
    <Title_Description>[Question]: Silo connection via bus. Hello tell me please is there a way to connect Silo nodes to a bus like Redis or Azure Queue?
I tried to use Azure AppService as hosting my .net core webapi application which also contains Silo but the AppService does not allow opening a private endpoint for Silo connections. 
And I wondered if it was possible to connect the nodes without a direct connection.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5767</IssueLabelID>
    <Title>Passing an IEnumerable&lt;Claim&gt; to a grain method gives TypeAccessException</Title>
    <Description>I'm trying to store Identity user claims in a grain state. I'm passing it in as `List&lt;Claim&gt;` but when I do so it gives a `Message: System.TypeAccessException : Named type "Claim" is invalid: Type string "Claim" cannot be resolved.` I'm not sure if this is intended if I'm doing something wrong or if this is a bug.

The following is the method for the grain `UserClaimsGrain : Grain&lt;List&lt;Claim&gt;&gt; IUserClaimGrain`
```csharp
public async Task AddClaimsAsync(List&lt;Claim&gt; claims User user)
{
    foreach (Claim claim in claims)
    {
        if (State.Contains(claim)) continue;
        State.Add(claim);
        await GrainFactory.GetGrain&lt;IUsersOfClaimGrain&gt;(claim.Value).AddUser(user);
    }
    await WriteStateAsync();
    return;
}
```

This is the xUnit test I have for it. I'm currently using Orleans.TestingHost to setup a TestCluster with xUnit's IClassFixture.
```csharp
[Fact]
public async Task AddClaims_AddingClaims_ReturnSuccess()
{
    // Arrange
    var user = new User()
    {
        Id = Guid.NewGuid()
    };

    var claims = new List&lt;Claim&gt;()
    {
        new Claim(ClaimTypes.NameIdentifier user.Id.ToString())
    };

    var userClaimsGrain = _Client.GetGrain&lt;IUserClaimsGrain&gt;(user.Id);

    // Act
    await userClaimsGrain.AddClaimsAsync(claims user);
    List&lt;Claim&gt; retrievedClaims = await userClaimsGrain.GetClaimsAsync();

    // Assert
    for(var i=0; i&lt;claims.Count; i++)
    {
        Assert.Equal(claims[i].Type retrievedClaims[i].Type);
        Assert.Equal(claims[i].Value retrievedClaims[i].Value);
    }            
}
```
I've tried changing `List&lt;Claim&gt;` to some other object such as `List&lt;User&gt;` and that works fine. I also notice that simply passing in `Claim` works but it is when I pass in `List&lt;Claim&gt;` that it throws an error. I'd rather not pass each `Claim` one at a time however as that would cause the application to invoke WriteStateAsync() multiple times. Even if that were a work around it wouldn't matter as returning the `List&lt;Claim&gt;` state also throws the same error.

![image](https://user-images.githubusercontent.com/10301859/61506072-cdd4b000-a995-11e9-992c-a1be4787ba78.png)
</Description>
    <Title_Description>Passing an IEnumerable&lt;Claim&gt; to a grain method gives TypeAccessException I'm trying to store Identity user claims in a grain state. I'm passing it in as `List&lt;Claim&gt;` but when I do so it gives a `Message: System.TypeAccessException : Named type "Claim" is invalid: Type string "Claim" cannot be resolved.` I'm not sure if this is intended if I'm doing something wrong or if this is a bug.

The following is the method for the grain `UserClaimsGrain : Grain&lt;List&lt;Claim&gt;&gt; IUserClaimGrain`
```csharp
public async Task AddClaimsAsync(List&lt;Claim&gt; claims User user)
{
    foreach (Claim claim in claims)
    {
        if (State.Contains(claim)) continue;
        State.Add(claim);
        await GrainFactory.GetGrain&lt;IUsersOfClaimGrain&gt;(claim.Value).AddUser(user);
    }
    await WriteStateAsync();
    return;
}
```

This is the xUnit test I have for it. I'm currently using Orleans.TestingHost to setup a TestCluster with xUnit's IClassFixture.
```csharp
[Fact]
public async Task AddClaims_AddingClaims_ReturnSuccess()
{
    // Arrange
    var user = new User()
    {
        Id = Guid.NewGuid()
    };

    var claims = new List&lt;Claim&gt;()
    {
        new Claim(ClaimTypes.NameIdentifier user.Id.ToString())
    };

    var userClaimsGrain = _Client.GetGrain&lt;IUserClaimsGrain&gt;(user.Id);

    // Act
    await userClaimsGrain.AddClaimsAsync(claims user);
    List&lt;Claim&gt; retrievedClaims = await userClaimsGrain.GetClaimsAsync();

    // Assert
    for(var i=0; i&lt;claims.Count; i++)
    {
        Assert.Equal(claims[i].Type retrievedClaims[i].Type);
        Assert.Equal(claims[i].Value retrievedClaims[i].Value);
    }            
}
```
I've tried changing `List&lt;Claim&gt;` to some other object such as `List&lt;User&gt;` and that works fine. I also notice that simply passing in `Claim` works but it is when I pass in `List&lt;Claim&gt;` that it throws an error. I'd rather not pass each `Claim` one at a time however as that would cause the application to invoke WriteStateAsync() multiple times. Even if that were a work around it wouldn't matter as returning the `List&lt;Claim&gt;` state also throws the same error.

![image](https://user-images.githubusercontent.com/10301859/61506072-cdd4b000-a995-11e9-992c-a1be4787ba78.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5765</IssueLabelID>
    <Title>Add locking support similar to Azure durable functions 2.0</Title>
    <Description>Add locking support similar to one described here https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-preview#locking-entities-from-orchestrations that I copy &amp; pasted below

This would be really helpful for avoiding raced conditions and should scale better that going through single grain to achieve the same.

&gt; Locking entities from orchestrations
Orchestrations can lock entities. This capability provides a simple way to prevent unwanted races by using critical sections.
&gt;
&gt; The context object provides the following methods:
&gt;
&gt; LockAsync: acquires locks on one or more entities.
IsLocked: returns true if currently in a critical section false otherwise.
The critical section ends and all locks are released when the orchestration ends. In .NET LockAsync returns an IDisposable that ends the critical section when disposed which can be used together with a using clause to get a syntactic representation of the critical section.
&gt;
&gt; For example consider an orchestration that needs to test whether two players are available and then assign them both to a game. This task can be implemented using a critical section as follows:

```csharp
[FunctionName("Orchestrator")]
public static async Task RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext ctx)
{
    EntityId player1 = /* ... */;
    EntityId player2 = /* ... */;

    using (await ctx.LockAsync(player1 player2))
    {
        bool available1 = await ctx.CallEntityAsync&lt;bool&gt;(player1 "is-available");
        bool available2 = await ctx.CallEntityAsync&lt;bool&gt;(player2 "is-available");

        if (available1 &amp;&amp; available2)
        {
            Guid gameId = ctx.NewGuid();

            await ctx.CallEntityAsync(player1 "assign-game" gameId);
            await ctx.CallEntityAsync(player2 "assign-game" gameId);
        }
    }
}
```
&gt; Within the critical section both player entities are locked which means they are not executing any operations other than the ones that are called from within the critical section). This behavior prevents races with conflicting operations such as players being assigned to a different game or signing off.
&gt;
&gt; We impose several restrictions on how critical sections can be used. These restrictions serve to prevent deadlocks and reentrancy.
&gt;
&gt; Critical sections cannot be nested.
&gt; Critical sections cannot create suborchestrations.
&gt; Critical sections can call only entities they have locked.
&gt; Critical sections cannot call the same entity using multiple parallel calls.
&gt; Critical sections can signal only entities they have not locked.
</Description>
    <Title_Description>Add locking support similar to Azure durable functions 2.0 Add locking support similar to one described here https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-preview#locking-entities-from-orchestrations that I copy &amp; pasted below

This would be really helpful for avoiding raced conditions and should scale better that going through single grain to achieve the same.

&gt; Locking entities from orchestrations
Orchestrations can lock entities. This capability provides a simple way to prevent unwanted races by using critical sections.
&gt;
&gt; The context object provides the following methods:
&gt;
&gt; LockAsync: acquires locks on one or more entities.
IsLocked: returns true if currently in a critical section false otherwise.
The critical section ends and all locks are released when the orchestration ends. In .NET LockAsync returns an IDisposable that ends the critical section when disposed which can be used together with a using clause to get a syntactic representation of the critical section.
&gt;
&gt; For example consider an orchestration that needs to test whether two players are available and then assign them both to a game. This task can be implemented using a critical section as follows:

```csharp
[FunctionName("Orchestrator")]
public static async Task RunOrchestrator(
    [OrchestrationTrigger] IDurableOrchestrationContext ctx)
{
    EntityId player1 = /* ... */;
    EntityId player2 = /* ... */;

    using (await ctx.LockAsync(player1 player2))
    {
        bool available1 = await ctx.CallEntityAsync&lt;bool&gt;(player1 "is-available");
        bool available2 = await ctx.CallEntityAsync&lt;bool&gt;(player2 "is-available");

        if (available1 &amp;&amp; available2)
        {
            Guid gameId = ctx.NewGuid();

            await ctx.CallEntityAsync(player1 "assign-game" gameId);
            await ctx.CallEntityAsync(player2 "assign-game" gameId);
        }
    }
}
```
&gt; Within the critical section both player entities are locked which means they are not executing any operations other than the ones that are called from within the critical section). This behavior prevents races with conflicting operations such as players being assigned to a different game or signing off.
&gt;
&gt; We impose several restrictions on how critical sections can be used. These restrictions serve to prevent deadlocks and reentrancy.
&gt;
&gt; Critical sections cannot be nested.
&gt; Critical sections cannot create suborchestrations.
&gt; Critical sections can call only entities they have locked.
&gt; Critical sections cannot call the same entity using multiple parallel calls.
&gt; Critical sections can signal only entities they have not locked.
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5760</IssueLabelID>
    <Title>Orleans.Client.Hosting - client integration into .net core generic hosting and controller DI</Title>
    <Description>With this on a IServiceCollection you can:

```
   services.AddOrleansClient(options =&gt;
            {
                options.Gateways = new int[2] { 30000 30001 };
            });
```

And then in any controller (or class using standard DI):


```
public  OrleansExampleController(
              IOrleansClientAccessor clientAccessor)
        {
            this.clientAccessor = clientAccessor;
            }
```

And then use the client:

```
this.clientAccessor.Client.GetGrain&lt;MyGrain&gt;()
```</Description>
    <Title_Description>Orleans.Client.Hosting - client integration into .net core generic hosting and controller DI With this on a IServiceCollection you can:

```
   services.AddOrleansClient(options =&gt;
            {
                options.Gateways = new int[2] { 30000 30001 };
            });
```

And then in any controller (or class using standard DI):


```
public  OrleansExampleController(
              IOrleansClientAccessor clientAccessor)
        {
            this.clientAccessor = clientAccessor;
            }
```

And then use the client:

```
this.clientAccessor.Client.GetGrain&lt;MyGrain&gt;()
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5758</IssueLabelID>
    <Title>Client only with Generic Host Builder is asp.net core 3.0</Title>
    <Description>When using asp.net core 3.0 web api whats the best way to use the orleans builders for a client only to connect to a remote cluster - with DI etc on the Controller APIs for access? Is there something in the builder to configure just as a client?

   ```
 public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                })
            
                .UseOrleans(builder =&gt;
                {
                   **IsThereARunAsClientOptionHere????**
                });
```</Description>
    <Title_Description>Client only with Generic Host Builder is asp.net core 3.0 When using asp.net core 3.0 web api whats the best way to use the orleans builders for a client only to connect to a remote cluster - with DI etc on the Controller APIs for access? Is there something in the builder to configure just as a client?

   ```
 public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                })
            
                .UseOrleans(builder =&gt;
                {
                   **IsThereARunAsClientOptionHere????**
                });
```</Title_Description>
    <Label>enhancement</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5756</IssueLabelID>
    <Title>System.TimeoutException: Response did not arrive on time in 00:00:30 for message</Title>
    <Description>I Have 5 silo in a cluster .

the Error log
```log
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.0.2.88:11111:300480702*stg/13/0000000d@S0000000d-&gt;S10.0.2.86:11111:300480703*stg/10/0000000a@S0000000a #13639713: . Target History is: &lt;S10.0.2.86:11111:300480703:*stg/10/0000000a:@S0000000a&gt;. at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message)
```

It seems the request from 88 to 86 is timeout. And I  saw som warning about membership
```log
-Did not get ping response for ping #123682 from S10.0.2.88:11111:300480702. Reason = Original Exc Type: System.TimeoutException Message:Response did not arrive on time in 00:00:30 for message: Request S10.0.2.86:11111:300480703*stg/15/0000000f@S0000000f-&gt;S10.0.2.88:11111:300480702*stg/15/0000000f@S0000000f #2993755: . Target History is: &lt;S10.0.2.88:11111:300480702:*stg/15/0000000f:@S0000000f&gt;. 
```
It seems the ping request from 86 to 88 is timeout And I saw a vote in  silo 88 membership Entry . the option of NumVotesForDeathDeclaration is 2 So the silo 88 would not be killed. 

 The member ping request from 86 to 88 is timeout  and  the request from 88 to 86 is timeout.  Other membership validations are normal . What happened to my orleans cluster ？
</Description>
    <Title_Description>System.TimeoutException: Response did not arrive on time in 00:00:30 for message I Have 5 silo in a cluster .

the Error log
```log
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.0.2.88:11111:300480702*stg/13/0000000d@S0000000d-&gt;S10.0.2.86:11111:300480703*stg/10/0000000a@S0000000a #13639713: . Target History is: &lt;S10.0.2.86:11111:300480703:*stg/10/0000000a:@S0000000a&gt;. at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message)
```

It seems the request from 88 to 86 is timeout. And I  saw som warning about membership
```log
-Did not get ping response for ping #123682 from S10.0.2.88:11111:300480702. Reason = Original Exc Type: System.TimeoutException Message:Response did not arrive on time in 00:00:30 for message: Request S10.0.2.86:11111:300480703*stg/15/0000000f@S0000000f-&gt;S10.0.2.88:11111:300480702*stg/15/0000000f@S0000000f #2993755: . Target History is: &lt;S10.0.2.88:11111:300480702:*stg/15/0000000f:@S0000000f&gt;. 
```
It seems the ping request from 86 to 88 is timeout And I saw a vote in  silo 88 membership Entry . the option of NumVotesForDeathDeclaration is 2 So the silo 88 would not be killed. 

 The member ping request from 86 to 88 is timeout  and  the request from 88 to 86 is timeout.  Other membership validations are normal . What happened to my orleans cluster ？
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5755</IssueLabelID>
    <Title>Stream nullref exception on shutdown</Title>
    <Description>Orleans.Streams.*stg/4614814381842400150/de148396.EventHubStreamProvider arg2 (eventId): 103312 arg3 (eventName):  exception: System.NullReferenceException: Object reference not set to an instance of an object. at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.&lt;GetQueueMessagesAsync&gt;d__22.MoveNext()</Description>
    <Title_Description>Stream nullref exception on shutdown Orleans.Streams.*stg/4614814381842400150/de148396.EventHubStreamProvider arg2 (eventId): 103312 arg3 (eventName):  exception: System.NullReferenceException: Object reference not set to an instance of an object. at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.&lt;GetQueueMessagesAsync&gt;d__22.MoveNext()</Title_Description>
    <Label>bug</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5753</IssueLabelID>
    <Title>【Request Help】Orleans Error，there will be a small part of Grain can not request。</Title>
    <Description>Orleans  version：`v 2.3.5`
Deployment environment：`K8S`

Orleans has this error there will be a small part of Grain can not request。
I guess This error is grain loop request。

Orleans fail info：
![HN19MR@RU1) K776))2Y3UV](https://user-images.githubusercontent.com/28291464/61184643-c609c880-a682-11e9-8f2d-26577a522838.png)
</Description>
    <Title_Description>【Request Help】Orleans Error，there will be a small part of Grain can not request。 Orleans  version：`v 2.3.5`
Deployment environment：`K8S`

Orleans has this error there will be a small part of Grain can not request。
I guess This error is grain loop request。

Orleans fail info：
![HN19MR@RU1) K776))2Y3UV](https://user-images.githubusercontent.com/28291464/61184643-c609c880-a682-11e9-8f2d-26577a522838.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5752</IssueLabelID>
    <Title>Stream queue balancing should not rely on silo names</Title>
    <Description>Silo names should only be used for display purposes</Description>
    <Title_Description>Stream queue balancing should not rely on silo names Silo names should only be used for display purposes</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5750</IssueLabelID>
    <Title>Get Guid of IGrainWithGuidCompoundKey in Grain</Title>
    <Description>In the grain implementation code how can you get the actual Guid part of the key when using IGrainWithGuidCompoundKey?</Description>
    <Title_Description>Get Guid of IGrainWithGuidCompoundKey in Grain In the grain implementation code how can you get the actual Guid part of the key when using IGrainWithGuidCompoundKey?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5748</IssueLabelID>
    <Title>[Question] Seems resource leak in StreamDictionary</Title>
    <Description>All `IAsyncStream&lt;T&gt;` reference would be cached in StreamDictionary.allStreams. The only method to release the resource was `StreamDictionary.Clear` but I can't see any reference on it.

https://github.com/dotnet/orleans/blob/a8abc360d572246a794cb14ff594656c275fe0e1/src/Orleans.Core/Streams/Internal/StreamDirectory.cs#L50

Did I miss something?</Description>
    <Title_Description>[Question] Seems resource leak in StreamDictionary All `IAsyncStream&lt;T&gt;` reference would be cached in StreamDictionary.allStreams. The only method to release the resource was `StreamDictionary.Clear` but I can't see any reference on it.

https://github.com/dotnet/orleans/blob/a8abc360d572246a794cb14ff594656c275fe0e1/src/Orleans.Core/Streams/Internal/StreamDirectory.cs#L50

Did I miss something?</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5745</IssueLabelID>
    <Title>HostedClient - use a slim IClusterClient implementation</Title>
    <Description>Instead of re-using `ClusterClient` use a purpose-built `IClusterClient` implementation on silos.

This simplifies behavior by avoiding `ClusterClient` which was intended for use with external clients &amp; performs a bunch of work which is not needed on the silo (eg connect/disconnect from the cluster).</Description>
    <Title_Description>HostedClient - use a slim IClusterClient implementation Instead of re-using `ClusterClient` use a purpose-built `IClusterClient` implementation on silos.

This simplifies behavior by avoiding `ClusterClient` which was intended for use with external clients &amp; performs a bunch of work which is not needed on the silo (eg connect/disconnect from the cluster).</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5740</IssueLabelID>
    <Title>WIP - Silo Service Placement</Title>
    <Description>Add placement strategy to place services on specific silos using grains.  Should be able to replace system targets.</Description>
    <Title_Description>WIP - Silo Service Placement Add placement strategy to place services on specific silos using grains.  Should be able to replace system targets.</Title_Description>
    <Label>work-in-progress</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>9/07/2019 12:35:43 AM +00:00</CreatedAt>
    <ClosedAt>23/07/2019 5:24:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5738</IssueLabelID>
    <Title>Is it possible to use cockroachdb as grain storage?</Title>
    <Description>We are trying to evaluate if we could use Cockroachdb (https://www.cockroachlabs.com/) as persistence storage for grainstate. Followed the link https://dotnet.github.io/orleans/Documentation/grains/grain_persistence/index.html#configuring-igrainstorage-providers to set up the storage provider for Cockroach as postgresql. As per the instruction when I tried to execute the postgresql statements from https://github.com/dotnet/orleans/blob/master/src/AdoNet/Orleans.Persistence.AdoNet/PostgreSQL-Persistence.sql I am getting an error while creating Function. It appears that cockroachdb does not support creating custom Functions. 
Are there any workarounds? Is using cockroachdb as grain persistence feasible? Has anybody tried doing this? </Description>
    <Title_Description>Is it possible to use cockroachdb as grain storage? We are trying to evaluate if we could use Cockroachdb (https://www.cockroachlabs.com/) as persistence storage for grainstate. Followed the link https://dotnet.github.io/orleans/Documentation/grains/grain_persistence/index.html#configuring-igrainstorage-providers to set up the storage provider for Cockroach as postgresql. As per the instruction when I tried to execute the postgresql statements from https://github.com/dotnet/orleans/blob/master/src/AdoNet/Orleans.Persistence.AdoNet/PostgreSQL-Persistence.sql I am getting an error while creating Function. It appears that cockroachdb does not support creating custom Functions. 
Are there any workarounds? Is using cockroachdb as grain persistence feasible? Has anybody tried doing this? </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5736</IssueLabelID>
    <Title>TimeoutException when OnDeactivateAsync call other deactivating grain</Title>
    <Description>There is an issue in our production system. When a grain is deactivating we want to call other grain to do its operations. But if the other grain is in deactivation state at the same time it seems the code came in deadlock (or something) and we got a timeout exception.
With the attached minimal sample code the issue can be reproduce.
[sample.zip](https://github.com/dotnet/orleans/files/3363091/sample.zip)
Our workaround is shift the collection ages' the grains.

Is it a bug or is there a better solution? 

Enviroment:
ubuntu 16.04
dotnet sdk 2.2.300
orleans 2.3.5
</Description>
    <Title_Description>TimeoutException when OnDeactivateAsync call other deactivating grain There is an issue in our production system. When a grain is deactivating we want to call other grain to do its operations. But if the other grain is in deactivation state at the same time it seems the code came in deadlock (or something) and we got a timeout exception.
With the attached minimal sample code the issue can be reproduce.
[sample.zip](https://github.com/dotnet/orleans/files/3363091/sample.zip)
Our workaround is shift the collection ages' the grains.

Is it a bug or is there a better solution? 

Enviroment:
ubuntu 16.04
dotnet sdk 2.2.300
orleans 2.3.5
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5735</IssueLabelID>
    <Title>Use nameof instead of magic string</Title>
    <Description>
    </Description>
    <Title_Description>Use nameof instead of magic string </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5733</IssueLabelID>
    <Title>Enable membership table cleanup by default</Title>
    <Description>
    </Description>
    <Title_Description>Enable membership table cleanup by default </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5732</IssueLabelID>
    <Title>Could not find silo entry for silo xxxxxx in the table</Title>
    <Description>```
fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100651]


      TryToSuspectOrKill failed

&#x1;&#x1;


ggregateException: One or more errors occurred. (-Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.) ---&gt; System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   --- End of inner exception stack trace ---


---&gt; (Inner Exception #0) System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)&lt;---




fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.
```</Description>
    <Title_Description>Could not find silo entry for silo xxxxxx in the table ```
fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100651]


      TryToSuspectOrKill failed

&#x1;&#x1;


ggregateException: One or more errors occurred. (-Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.) ---&gt; System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   --- End of inner exception stack trace ---


---&gt; (Inner Exception #0) System.Collections.Generic.KeyNotFoundException: -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


   at Orleans.Runtime.MembershipService.MembershipOracle.TryToSuspectOrKill(SiloAddress silo)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)


   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff)&lt;---




fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.


fail: Orleans.Runtime.MembershipService.MembershipOracleData[100623]


      -Could not find silo entry for silo S10.0.2.84:11111:298744684 in the table.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5731</IssueLabelID>
    <Title>Fix race introduced in membership</Title>
    <Description>
    </Description>
    <Title_Description>Fix race introduced in membership </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5729</IssueLabelID>
    <Title>Disable ILBasedSerializer by default</Title>
    <Description>In preparation for deletion in 3.0 (#5728). It's been deprecated for some time already.</Description>
    <Title_Description>Disable ILBasedSerializer by default In preparation for deletion in 3.0 (#5728). It's been deprecated for some time already.</Title_Description>
    <Label>serialization</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5728</IssueLabelID>
    <Title>Remove ILBasedSerializer</Title>
    <Description>* [ ] Remove `ILBasedSerializer`
* [ ] Update documentation</Description>
    <Title_Description>Remove ILBasedSerializer * [ ] Remove `ILBasedSerializer`
* [ ] Update documentation</Title_Description>
    <Label>serialization</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5726</IssueLabelID>
    <Title>TestCluster.Deploy - OrleansMessageRejectionException : Target silo S127.0.0.1:41081:0 is unavailable</Title>
    <Description>We have an issue where a test sometimes (~30% of the time) fails when deploying the TestCluster.

It only seems to happen on Linux (not on Windows).

```
16:27:59  ----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------
16:27:59  Done initializing cluster
16:27:59  Initializing Cluster Client
16:27:59  Exception Uninitializing grain client: System.NullReferenceException: Object reference not set to an instance of an object.
16:27:59     at Orleans.TestingHost.TestCluster.StopClusterClientAsync()
16:27:59  
16:27:59  [xUnit.net 00:00:14.15]     SomeTestThatWeHave [FAIL]
16:27:59  Failed   SomeTestThatWeHave
16:27:59  Error Message:
16:27:59   Orleans.Runtime.OrleansMessageRejectionException : Target silo S127.0.0.1:41081:0 is unavailable
16:27:59  Stack Trace:
16:27:59     at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
16:27:59     at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext()
16:27:59  --- End of stack trace from previous location where exception was thrown ---
16:27:59     at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry)
16:27:59     at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
16:27:59     at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
16:27:59     at Orleans.ClusterClient.Connect(Func`2 retryFilter)
16:27:59     at Orleans.TestingHost.TestCluster.InitializeClient()
16:27:59     at Orleans.TestingHost.TestCluster.InitializeAsync()
16:27:59     at Orleans.TestingHost.TestCluster.DeployAsync()
16:27:59     at Orleans.TestingHost.TestCluster.DeployAsync()
16:27:59     at Orleans.TestingHost.TestCluster.Deploy()
             --- ommitted for gitter ---
16:27:59  --- End of stack trace from previous location where exception was thrown ---
16:28:55  
16:28:55  Total tests: 4. Passed: 3. Failed: 1. Skipped: 0.
16:28:55  Test Run Failed.
```

Any idea what could cause this?</Description>
    <Title_Description>TestCluster.Deploy - OrleansMessageRejectionException : Target silo S127.0.0.1:41081:0 is unavailable We have an issue where a test sometimes (~30% of the time) fails when deploying the TestCluster.

It only seems to happen on Linux (not on Windows).

```
16:27:59  ----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------
16:27:59  Done initializing cluster
16:27:59  Initializing Cluster Client
16:27:59  Exception Uninitializing grain client: System.NullReferenceException: Object reference not set to an instance of an object.
16:27:59     at Orleans.TestingHost.TestCluster.StopClusterClientAsync()
16:27:59  
16:27:59  [xUnit.net 00:00:14.15]     SomeTestThatWeHave [FAIL]
16:27:59  Failed   SomeTestThatWeHave
16:27:59  Error Message:
16:27:59   Orleans.Runtime.OrleansMessageRejectionException : Target silo S127.0.0.1:41081:0 is unavailable
16:27:59  Stack Trace:
16:27:59     at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
16:27:59     at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext()
16:27:59  --- End of stack trace from previous location where exception was thrown ---
16:27:59     at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry)
16:27:59     at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
16:27:59     at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
16:27:59     at Orleans.ClusterClient.Connect(Func`2 retryFilter)
16:27:59     at Orleans.TestingHost.TestCluster.InitializeClient()
16:27:59     at Orleans.TestingHost.TestCluster.InitializeAsync()
16:27:59     at Orleans.TestingHost.TestCluster.DeployAsync()
16:27:59     at Orleans.TestingHost.TestCluster.DeployAsync()
16:27:59     at Orleans.TestingHost.TestCluster.Deploy()
             --- ommitted for gitter ---
16:27:59  --- End of stack trace from previous location where exception was thrown ---
16:28:55  
16:28:55  Total tests: 4. Passed: 3. Failed: 1. Skipped: 0.
16:28:55  Test Run Failed.
```

Any idea what could cause this?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5725</IssueLabelID>
    <Title>hot grain best way to do?</Title>
    <Description>The grain is designed to obtain the tenant token. The token is from a third party and will be refreshed and updated every 2 hours. But there are more customers who visit a tenant token at the same time and may reach thousands. Is this hot grain? If so how to avoid it. Note that the token is not related to the customer and is only relevant to the tenant.</Description>
    <Title_Description>hot grain best way to do? The grain is designed to obtain the tenant token. The token is from a third party and will be refreshed and updated every 2 hours. But there are more customers who visit a tenant token at the same time and may reach thousands. Is this hot grain? If so how to avoid it. Note that the token is not related to the customer and is only relevant to the tenant.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5724</IssueLabelID>
    <Title>DeploymentLoadPublisher: use silo lifecycle</Title>
    <Description>Moving more components out of Silo.cs</Description>
    <Title_Description>DeploymentLoadPublisher: use silo lifecycle Moving more components out of Silo.cs</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5723</IssueLabelID>
    <Title>Start ClusterHealthMonitor in Active instead of BecomeActive</Title>
    <Description>
    </Description>
    <Title_Description>Start ClusterHealthMonitor in Active instead of BecomeActive </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5722</IssueLabelID>
    <Title>Start MembershipTableCleanupAgent in Active instead of RuntimeGrainServices</Title>
    <Description>
    </Description>
    <Title_Description>Start MembershipTableCleanupAgent in Active instead of RuntimeGrainServices </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5721</IssueLabelID>
    <Title>Add validator for DevelopmentClusterMembershipOptions</Title>
    <Description>
    </Description>
    <Title_Description>Add validator for DevelopmentClusterMembershipOptions </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5720</IssueLabelID>
    <Title>Fix exception in LatestVersionSelector when there are no deployed versions of a grain</Title>
    <Description>Also throw in GrainVersionStore when versioning is not enabled.</Description>
    <Title_Description>Fix exception in LatestVersionSelector when there are no deployed versions of a grain Also throw in GrainVersionStore when versioning is not enabled.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5719</IssueLabelID>
    <Title>Skip flaky MessageTest_TtlUpdatedOnSerialization test</Title>
    <Description>Opened #5718 to track</Description>
    <Title_Description>Skip flaky MessageTest_TtlUpdatedOnSerialization test Opened #5718 to track</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5718</IssueLabelID>
    <Title>Flaky test: MessageTest_TtlUpdatedOnSerialization</Title>
    <Description>
    </Description>
    <Title_Description>Flaky test: MessageTest_TtlUpdatedOnSerialization </Title_Description>
    <Label>test-issue</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>26/06/2019 5:17:56 PM +00:00</CreatedAt>
    <ClosedAt>31/07/2019 3:24:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5717</IssueLabelID>
    <Title>Fix AgentTests</Title>
    <Description>I'm not sure how this test was passing but `TryAddSingleton` for a type which is supposed to have many registrations like `ILifecycleParticipant&lt;T&gt;` isn't right.</Description>
    <Title_Description>Fix AgentTests I'm not sure how this test was passing but `TryAddSingleton` for a type which is supposed to have many registrations like `ILifecycleParticipant&lt;T&gt;` isn't right.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5715</IssueLabelID>
    <Title>Dispose TestCluster after tests</Title>
    <Description>
    </Description>
    <Title_Description>Dispose TestCluster after tests </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5714</IssueLabelID>
    <Title>Grain-based reminders: separate IReminderTable &amp; IReminderTableGrain</Title>
    <Description>Currently grain-based reminders implementation does not have separation between the grain &amp; `IReminderTable` implementation.

This can cause issues during startup/shutdown when grain calls are not available.

This PR separates the two &amp; adds checks to ensure that the implementation doesn't try to make grain calls until the silo is ready.</Description>
    <Title_Description>Grain-based reminders: separate IReminderTable &amp; IReminderTableGrain Currently grain-based reminders implementation does not have separation between the grain &amp; `IReminderTable` implementation.

This can cause issues during startup/shutdown when grain calls are not available.

This PR separates the two &amp; adds checks to ensure that the implementation doesn't try to make grain calls until the silo is ready.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5713</IssueLabelID>
    <Title>Remove concurrency cap for Xunit</Title>
    <Description>I noticed in some stack traces that Xunit was running tests under a `MaxConcurrencySynchronizationContext`.

Tests may behave differently (eg potentially hitting a deadlock) so this PR removes the limit by setting it to -1 for all test assemblies</Description>
    <Title_Description>Remove concurrency cap for Xunit I noticed in some stack traces that Xunit was running tests under a `MaxConcurrencySynchronizationContext`.

Tests may behave differently (eg potentially hitting a deadlock) so this PR removes the limit by setting it to -1 for all test assemblies</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5712</IssueLabelID>
    <Title>Minor client/silo teardown tweaks</Title>
    <Description>* Check for `OutsideRuntimeClient` in `ClusterClient` before calling Dispose (which arguably should be removed anyway...)
* Pulse `incomingMessages` queue to give `HostedClient` to gracefully terminate
* Avoid Dispose in `Silo` (it exists in `SiloWrapper`)
* Capture a weal reference to `Silo` in `AppDomain.CurrentDomain.ProcessExit` to fix memory leak (apparent during long test runs)
* Don't await Terminated/Stopped tasks during shutdown (doing so could cause deadlocks)
</Description>
    <Title_Description>Minor client/silo teardown tweaks * Check for `OutsideRuntimeClient` in `ClusterClient` before calling Dispose (which arguably should be removed anyway...)
* Pulse `incomingMessages` queue to give `HostedClient` to gracefully terminate
* Avoid Dispose in `Silo` (it exists in `SiloWrapper`)
* Capture a weal reference to `Silo` in `AppDomain.CurrentDomain.ProcessExit` to fix memory leak (apparent during long test runs)
* Don't await Terminated/Stopped tasks during shutdown (doing so could cause deadlocks)
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5711</IssueLabelID>
    <Title>Improve lifecycle logging</Title>
    <Description>Log lifecycle levels using stage names rather than numeric values.
Use structured logging</Description>
    <Title_Description>Improve lifecycle logging Log lifecycle levels using stage names rather than numeric values.
Use structured logging</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5710</IssueLabelID>
    <Title>Fix CategoryDiscoverer first-chance exception while debugging</Title>
    <Description>
    </Description>
    <Title_Description>Fix CategoryDiscoverer first-chance exception while debugging </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5709</IssueLabelID>
    <Title>I need to make the Orleans public but I was intercepted by the Orleans Gateway.</Title>
    <Description>I need to make the Orleans public but I was intercepted by the Orleans Gateway.
I am deploying with Kubernetes.

ERROR:
```
Gateway received unexpected non-proxied connection from *sgn/01111111-1111-1111-1111-111111111111/11111111 at source address 172.18.76.51:36931
```

silo  configuration：

![image](https://user-images.githubusercontent.com/28291464/60160726-8e002a00-9828-11e9-9928-627ead842dce.png)

client config:
```
s.UseStaticClustering(new IPEndPoint(IPAddress.Parse("172.18.76.56") 30000));
```

Is it my legacy configuration or other issues?</Description>
    <Title_Description>I need to make the Orleans public, but I was intercepted by the Orleans Gateway. I need to make the Orleans public but I was intercepted by the Orleans Gateway.
I am deploying with Kubernetes.

ERROR:
```
Gateway received unexpected non-proxied connection from *sgn/01111111-1111-1111-1111-111111111111/11111111 at source address 172.18.76.51:36931
```

silo  configuration：

![image](https://user-images.githubusercontent.com/28291464/60160726-8e002a00-9828-11e9-9928-627ead842dce.png)

client config:
```
s.UseStaticClustering(new IPEndPoint(IPAddress.Parse("172.18.76.56") 30000));
```

Is it my legacy configuration or other issues?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5706</IssueLabelID>
    <Title>Tests should have one category of BVT SlowBVT &amp; Functional</Title>
    <Description>Currently there are at least 400 tests which are in both BVT &amp; Functional categories. There is no need for an overlap: it just slows down test runs

Note: check to make sure no coverage is lost in Azure DevOps (i.e that build settings are correct to ensure all tests are being run once)</Description>
    <Title_Description>Tests should have one category of BVT, SlowBVT, &amp; Functional Currently there are at least 400 tests which are in both BVT &amp; Functional categories. There is no need for an overlap: it just slows down test runs

Note: check to make sure no coverage is lost in Azure DevOps (i.e that build settings are correct to ensure all tests are being run once)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5705</IssueLabelID>
    <Title>Remove FileLoggerProvider etc</Title>
    <Description>We should rely on an existing providers for tests (eg [`Serilog.Extensions.Logging.File`](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) or at least move it out of `Orleans.Core`.</Description>
    <Title_Description>Remove FileLoggerProvider etc We should rely on an existing providers for tests (eg [`Serilog.Extensions.Logging.File`](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) or at least move it out of `Orleans.Core`.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5704</IssueLabelID>
    <Title>Add Analyzer/CodeGen error for invalid grain interface signatures</Title>
    <Description>Grain interfaces do not support parameter modifiers such as `out`/`ref`/`in`.

We should add clear error messages via the Orleans.Analyzers package and codegen to notify users when they attempt to use an unsupported modifier.

See #5670 &amp; #5530

An analyzer was added in https://github.com/dotnet/orleans/pull/5589 - it could be extended

(note: support for `in` could be added to the code generator too)</Description>
    <Title_Description>Add Analyzer/CodeGen error for invalid grain interface signatures Grain interfaces do not support parameter modifiers such as `out`/`ref`/`in`.

We should add clear error messages via the Orleans.Analyzers package and codegen to notify users when they attempt to use an unsupported modifier.

See #5670 &amp; #5530

An analyzer was added in https://github.com/dotnet/orleans/pull/5589 - it could be extended

(note: support for `in` could be added to the code generator too)</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5702</IssueLabelID>
    <Title>Remove ExpectedClusterSize &amp; add MaxOperationBackoffTime</Title>
    <Description>
    </Description>
    <Title_Description>Remove ExpectedClusterSize &amp; add MaxOperationBackoffTime </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5701</IssueLabelID>
    <Title>LocalGrainDirectory: use membership snapshots</Title>
    <Description>
    </Description>
    <Title_Description>LocalGrainDirectory: use membership snapshots </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5700</IssueLabelID>
    <Title>Remove MarshalByRefObject base classes</Title>
    <Description>We do not need any of our types to subclass `MarshalByRefObject`. We should remove it.</Description>
    <Title_Description>Remove MarshalByRefObject base classes We do not need any of our types to subclass `MarshalByRefObject`. We should remove it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5698</IssueLabelID>
    <Title>OrleansMessageRejectionException after several days of operation</Title>
    <Description>Hi

I am getting the following exception during communication with the silos after days/weeks of operation:

```
OrleansMessageRejectionException: The target silo is no longer active: target was S10.244.1.154:11111:298559580 but this silo is S10.244.1.154:11111:298610721. The rejected message is Request S10.244.1.154:11111:298610721*cli/6e93b0a7@7df7fe8a-&amp;gt;S10.244.1.154:11111:298559580*grn/436D1357/00000000&amp;#x2B;klejtrup~klejtrupvand/9999-12-31T23:59:59&amp;#x2B;00:00@3eeca186 #782747
```

I am running Orleans 2.3.1 with the Kubernetes membership provider. As far as I can tell the membership table looks fine. See the following output from the Kubernetes membership table:

&lt;details&gt;
&lt;summary&gt;Output from http://localhost:8001/apis/orleans.dot.net/v1/namespaces/utiliread/silos&lt;/summary&gt;
&lt;code&gt;
{
apiVersion: "orleans.dot.net/v1"
items: [
{
address: "10.244.0.234"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953238
hostname: "samplestoresilo-789685bbf8-jr82w"
iAmAliveTime: "2019-06-11T12:51:22.85686+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:24Z"
generation: 5
name: "10.244.0.234-11111-297953238"
namespace: "utiliread"
resourceVersion: "12864801"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.234-11111-297953238"
uid: "0fcf6520-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_98af8"
startTime: "2019-06-11T12:47:19.705448+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.234:11111@297953238"
]
suspectingTimes: [
"2019-06-11 12:51:22.856 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204570
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T03:21:22.93462+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:21Z"
generation: 205
name: "10.244.0.31-11111-298204570"
namespace: "utiliread"
resourceVersion: "13511808"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298204570"
uid: "405ba26a-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f66b5"
startTime: "2019-06-14T10:36:11.8352878+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298265127"
]
suspectingTimes: [
"2019-06-15 03:25:39.923 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298265127
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T06:55:41.8285384+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T03:25:41Z"
generation: 46
name: "10.244.0.31-11111-298265127"
namespace: "utiliread"
resourceVersion: "13538472"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298265127"
uid: "40ad2eda-8f1d-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7f143"
startTime: "2019-06-15T03:25:27.9318099+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298278017"
]
suspectingTimes: [
"2019-06-15 07:00:24.162 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298278017
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T05:30:27.35304+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T07:00:25Z"
generation: 562
name: "10.244.0.31-11111-298278017"
namespace: "utiliread"
resourceVersion: "13886747"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298278017"
uid: "40480627-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_9d6f1"
startTime: "2019-06-15T07:00:18.8193208+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 05:34:17.329 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445646
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T06:21:58.2439994+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:34:18Z"
generation: 14
name: "10.244.0.31-11111-298445646"
namespace: "utiliread"
resourceVersion: "13893211"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298445646"
uid: "8d69e5fb-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_2a786"
startTime: "2019-06-17T05:34:07.112329+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 06:21:58.243 GMT"
]
}
{
address: "10.244.0.34"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448522
hostname: "samplestoresilo-789685bbf8-pgqwk"
iAmAliveTime: "2019-06-17T06:35:17.2805579+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:08Z"
generation: 7
name: "10.244.0.34-11111-298448522"
namespace: "utiliread"
resourceVersion: "13894934"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.34-11111-298448522"
uid: "3bcd18f3-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e353f"
startTime: "2019-06-17T06:22:03.5232614+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.34:11111@298448522"
]
suspectingTimes: [
"2019-06-17 06:35:17.280 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-17T10:00:23.0799904+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:22Z"
generation: 45
name: "10.244.1.154-11111-298449319"
namespace: "utiliread"
resourceVersion: "13920813"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298449319"
uid: "152d490b-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4c64b"
startTime: "2019-06-17T06:35:19.9434331+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 10:02:06.953 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298461715
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T03:22:08.9199231+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T10:02:08Z"
generation: 212
name: "10.244.1.154-11111-298461715"
namespace: "utiliread"
resourceVersion: "14050880"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298461715"
uid: "f78dfc21-90e6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_54a84"
startTime: "2019-06-17T10:01:56.2362073+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298524328"
]
suspectingTimes: [
"2019-06-18 03:25:36.779 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524328
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T05:55:38.677627+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:25:38Z"
generation: 34
name: "10.244.1.154-11111-298524328"
namespace: "utiliread"
resourceVersion: "14070212"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298524328"
uid: "be0ba56a-9178-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_88ef9"
startTime: "2019-06-18T03:25:29.5819737+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298533621"
]
suspectingTimes: [
"2019-06-18 06:00:26.021 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533621
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:10:27.8475709+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:00:27Z"
generation: 6
name: "10.244.1.154-11111-298533621"
namespace: "utiliread"
resourceVersion: "14071597"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298533621"
uid: "5ec89b7c-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_bb5f9"
startTime: "2019-06-18T06:00:23.2734568+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534256"
]
suspectingTimes: [
"2019-06-18 06:11:07.146 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534256
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:11:09.0933573+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:11:08Z"
generation: 4
name: "10.244.1.154-11111-298534256"
namespace: "utiliread"
resourceVersion: "14071951"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534256"
uid: "dcf5da2a-918f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b3a69"
startTime: "2019-06-18T06:10:57.1670382+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 06:13:29.317 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534403
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T13:08:31.0284391+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:13:30Z"
generation: 87
name: "10.244.1.154-11111-298534403"
namespace: "utiliread"
resourceVersion: "14124653"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534403"
uid: "31a50780-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7663d"
startTime: "2019-06-18T06:13:23.8449261+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298559580"
]
suspectingTimes: [
"2019-06-18 13:13:07.031 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559580
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T03:23:08.9800777+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:13:08Z"
generation: 174
name: "10.244.1.154-11111-298559580"
namespace: "utiliread"
resourceVersion: "14230789"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298559580"
uid: "d0c4bdf8-91ca-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_006be"
startTime: "2019-06-18T13:13:01.7666038+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 03:25:25.821 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298610721
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T14:40:27.7322395+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T03:25:27Z"
generation: 138
name: "10.244.1.154-11111-298610721"
namespace: "utiliread"
resourceVersion: "14314879"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298610721"
uid: "e1e3c381-9241-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c9bcf"
startTime: "2019-06-19T03:25:22.0894214+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
{
address: "10.244.1.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953233
hostname: "samplestoresilo-789685bbf8-dn7hn"
iAmAliveTime: "2019-06-11T12:51:22.1600234+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:18Z"
generation: 5
name: "10.244.1.49-11111-297953233"
namespace: "utiliread"
resourceVersion: "12864798"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.49-11111-297953233"
uid: "0bf6c32e-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_3a67b"
startTime: "2019-06-11T12:47:14.5381316+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.49:11111@297953233"
]
suspectingTimes: [
"2019-06-11 12:51:22.160 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953492
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-12T03:21:47.0337972+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:46Z"
generation: 178
name: "10.244.1.50-11111-297953492"
namespace: "utiliread"
resourceVersion: "12973466"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-297953492"
uid: "abccfa35-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e0cf7"
startTime: "2019-06-11T12:51:34.1855359+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298005922"
]
suspectingTimes: [
"2019-06-12 03:25:34.570 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298005922
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-13T05:50:36.4884219+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-12T03:25:35Z"
generation: 320
name: "10.244.1.50-11111-298005922"
namespace: "utiliread"
resourceVersion: "13170881"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298005922"
uid: "be260353-8cc1-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_deb91"
startTime: "2019-06-12T03:25:23.0783201+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298101067"
]
suspectingTimes: [
"2019-06-13 05:51:18.571 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101067
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:46:20.5745259+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:19Z"
generation: 291
name: "10.244.1.50-11111-298101067"
namespace: "utiliread"
resourceVersion: "13350149"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298101067"
uid: "4465a4b0-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_37922"
startTime: "2019-06-13T05:51:08.5638001+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187359"
]
suspectingTimes: [
"2019-06-14 05:49:28.260 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187359
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:49:30.0761174+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:49:29Z"
generation: 4
name: "10.244.1.50-11111-298187359"
namespace: "utiliread"
resourceVersion: "13350467"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187359"
uid: "2d0bdd5e-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_5d535"
startTime: "2019-06-14T05:49:20.4465402+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187509"
]
suspectingTimes: [
"2019-06-14 05:51:54.323 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187509
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T08:56:56.4780532+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:51:55Z"
generation: 41
name: "10.244.1.50-11111-298187509"
namespace: "utiliread"
resourceVersion: "13374129"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187509"
uid: "84282e9c-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_aeb25"
startTime: "2019-06-14T05:51:50.2501753+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 09:00:06.726 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199055
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T10:36:05.5577063+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:04:22Z"
generation: 23
name: "10.244.1.50-11111-298199055"
namespace: "utiliread"
resourceVersion: "13386257"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298199055"
uid: "66792743-8e83-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_89d37"
startTime: "2019-06-14T09:04:18.5051592+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 10:36:05.557 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204573
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-15T06:56:20.0694468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:19Z"
generation: 248
name: "10.244.1.65-11111-298204573"
namespace: "utiliread"
resourceVersion: "13538262"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298204573"
uid: "3eed6091-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_58e43"
startTime: "2019-06-14T10:36:14.5063276+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298277926"
]
suspectingTimes: [
"2019-06-15 06:58:58.343 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298277926
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-16T03:24:00.3776894+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T06:58:59Z"
generation: 249
name: "10.244.1.65-11111-298277926"
namespace: "utiliread"
resourceVersion: "13690932"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298277926"
uid: "0d1cd86c-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b1981"
startTime: "2019-06-15T06:58:46.8443562+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298351523"
]
suspectingTimes: [
"2019-06-16 03:25:28.541 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298351523
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T03:25:30.5223938+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-16T03:25:29Z"
generation: 292
name: "10.244.1.65-11111-298351523"
namespace: "utiliread"
resourceVersion: "13870685"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298351523"
uid: "6441284c-8fe6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1197b"
startTime: "2019-06-16T03:25:23.7745601+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298437952"
]
suspectingTimes: [
"2019-06-17 03:26:05.642 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298437952
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T05:36:08.9606268+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T03:26:07Z"
generation: 30
name: "10.244.1.65-11111-298437952"
namespace: "utiliread"
resourceVersion: "13887109"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298437952"
uid: "a4dc70bb-90af-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_17bfd"
startTime: "2019-06-17T03:25:54.123374+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 05:37:04.302 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445814
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T06:21:57.3225468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:37:05Z"
generation: 13
name: "10.244.1.65-11111-298445814"
namespace: "utiliread"
resourceVersion: "13893205"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298445814"
uid: "f0ecb190-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b631b"
startTime: "2019-06-17T05:36:55.1450547+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 06:21:57.322 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297809187
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:16:33.5759148+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-09T20:46:32Z"
generation: 478
name: "10.244.3.138-11111-297809187"
namespace: "utiliread"
resourceVersion: "12860746"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297809187"
uid: "a9fdeca5-8af7-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_605a9"
startTime: "2019-06-09T20:46:27.9033132+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:19:58.197 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297951594
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:46:58.2604768+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:20:05Z"
generation: 10
name: "10.244.3.138-11111-297951594"
namespace: "utiliread"
resourceVersion: "12864181"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297951594"
uid: "3ed5b53c-8c43-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7a1e3"
startTime: "2019-06-11T12:19:55.2682603+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.138:11111@297951594"
]
suspectingTimes: [
"2019-06-11 12:46:58.260 GMT"
]
}
{
address: "10.244.3.139"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297945020
hostname: "samplestoresilo-789685bbf8-j79vv"
iAmAliveTime: "2019-06-11T12:46:58.602482+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T10:30:33Z"
generation: 32
name: "10.244.3.139-11111-297945020"
namespace: "utiliread"
resourceVersion: "12864183"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.139-11111-297945020"
uid: "f17119d8-8c33-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_731a8"
startTime: "2019-06-11T10:30:20.9634992+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:46:58.602 GMT"
]
}
{
address: "10.244.3.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448521
hostname: "samplestoresilo-789685bbf8-qhx5k"
iAmAliveTime: "2019-06-17T06:35:15.7397908+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:09Z"
generation: 7
name: "10.244.3.49-11111-298448521"
namespace: "utiliread"
resourceVersion: "13894927"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.49-11111-298448521"
uid: "3c465769-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1d4d7"
startTime: "2019-06-17T06:22:02.2849513+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.49:11111@298448521"
]
suspectingTimes: [
"2019-06-17 06:35:15.739 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953490
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-13T05:46:36.0470946+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:34Z"
generation: 494
name: "10.244.3.5-11111-297953490"
namespace: "utiliread"
resourceVersion: "13170890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-297953490"
uid: "a4d924e0-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e3235"
startTime: "2019-06-11T12:51:31.744242+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298101071"
]
suspectingTimes: [
"2019-06-13 05:51:20.012 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101071
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T05:46:22.2347732+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:21Z"
generation: 291
name: "10.244.3.5-11111-298101071"
namespace: "utiliread"
resourceVersion: "13350001"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298101071"
uid: "453b9e26-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_a7115"
startTime: "2019-06-13T05:51:12.6455421+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298187298"
]
suspectingTimes: [
"2019-06-14 05:48:24.687 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187298
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T06:18:26.3476543+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:48:25Z"
generation: 10
name: "10.244.3.5-11111-298187298"
namespace: "utiliread"
resourceVersion: "13354392"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298187298"
uid: "072c41ff-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4e118"
startTime: "2019-06-14T05:48:19.4318135+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 06:23:13.835 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298189383
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T09:13:15.5674791+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T06:23:15Z"
generation: 38
name: "10.244.3.5-11111-298189383"
namespace: "utiliread"
resourceVersion: "13376471"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298189383"
uid: "e46cd148-8e6c-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_0c820"
startTime: "2019-06-14T06:23:04.6723504+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 09:17:59.646 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199872
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T10:36:05.2727163+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:18:03Z"
generation: 20
name: "10.244.3.5-11111-298199872"
namespace: "utiliread"
resourceVersion: "13386255"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298199872"
uid: "502eb758-8e85-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c3772"
startTime: "2019-06-14T09:17:53.6756759+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298199872"
]
suspectingTimes: [
"2019-06-14 10:36:05.272 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:45:23.9149361+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:23Z"
generation: 78
name: "10.244.3.50-11111-298449319"
namespace: "utiliread"
resourceVersion: "13941238"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298449319"
uid: "15bd49a5-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_18763"
startTime: "2019-06-17T06:35:19.779006+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298471558"
]
suspectingTimes: [
"2019-06-17 12:46:07.108 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471558
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:46:08.9262019+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:08Z"
generation: 4
name: "10.244.3.50-11111-298471558"
namespace: "utiliread"
resourceVersion: "13941350"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471558"
uid: "e0c353a1-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_231cb"
startTime: "2019-06-17T12:45:59.625527+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 12:46:52.007 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471601
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T03:26:54.8059909+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:54Z"
generation: 179
name: "10.244.3.50-11111-298471601"
namespace: "utiliread"
resourceVersion: "14051496"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471601"
uid: "fc15eacd-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_cfc3b"
startTime: "2019-06-17T12:46:42.4281823+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298524614"
]
suspectingTimes: [
"2019-06-18 03:30:25.254 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524614
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:00:26.9274781+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:30:26Z"
generation: 34
name: "10.244.3.50-11111-298524614"
namespace: "utiliread"
resourceVersion: "14070512"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298524614"
uid: "69e21b32-9179-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_10846"
startTime: "2019-06-18T03:30:15.3304391+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298533755"
]
suspectingTimes: [
"2019-06-18 06:02:38.895 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533755
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:07:40.6013731+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:02:40Z"
generation: 5
name: "10.244.3.50-11111-298533755"
namespace: "utiliread"
resourceVersion: "14071796"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298533755"
uid: "ae023bd6-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_da2c7"
startTime: "2019-06-18T06:02:36.4165997+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534345"
]
suspectingTimes: [
"2019-06-18 06:12:28.624 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534345
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:12:30.5140926+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:12:29Z"
generation: 4
name: "10.244.3.50-11111-298534345"
namespace: "utiliread"
resourceVersion: "14072036"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534345"
uid: "0d79be8c-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c6383"
startTime: "2019-06-18T06:12:26.1622084+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534433"
]
suspectingTimes: [
"2019-06-18 06:14:00.960 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534433
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T13:04:02.7106446+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:14:02Z"
generation: 86
name: "10.244.3.50-11111-298534433"
namespace: "utiliread"
resourceVersion: "14123741"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534433"
uid: "447cb2a9-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_33f55"
startTime: "2019-06-18T06:13:54.0935096+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 13:06:08.353 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559171
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T16:16:19.9360389+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:06:19Z"
generation: 42
name: "10.244.3.50-11111-298559171"
namespace: "utiliread"
resourceVersion: "14147952"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298559171"
uid: "dd0b98df-91c9-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7d7a5"
startTime: "2019-06-18T13:06:12.4847577+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-18 16:20:30.154 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298570827
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-19T14:40:32.2742356+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T16:20:31Z"
generation: 271
name: "10.244.3.50-11111-298570827"
namespace: "utiliread"
resourceVersion: "14314890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298570827"
uid: "fe3bbb48-91e4-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f0920"
startTime: "2019-06-18T16:20:28.0531226+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
]
kind: "OrleansSiloList"
metadata: {
continue: ""
resourceVersion: "14315332"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos"
}
}
&lt;/code&gt;
&lt;/details&gt;

It shows that 10.244.1.154:11111@298559580 has the suspecting silo 10.244.1.154:11111@298610721 which seems correct?

Restarting the silos resolved the problem...

&lt;details&gt;
&lt;summary&gt;
Here is the table after the restart of the two silos
&lt;/summary&gt;
&lt;code&gt;
{
apiVersion: "orleans.dot.net/v1"
items: [
{
address: "10.244.0.100"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298652479
hostname: "samplestoresilo-789685bbf8-mnfrl"
iAmAliveTime: "2019-06-19T15:36:25.0837066+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T15:01:24Z"
generation: 10
name: "10.244.0.100-11111-298652479"
namespace: "utiliread"
resourceVersion: "14321924"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.100-11111-298652479"
uid: "1b4fdf33-92a3-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f6c63"
startTime: "2019-06-19T15:01:20.1597054+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
{
address: "10.244.0.234"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953238
hostname: "samplestoresilo-789685bbf8-jr82w"
iAmAliveTime: "2019-06-11T12:51:22.85686+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:24Z"
generation: 5
name: "10.244.0.234-11111-297953238"
namespace: "utiliread"
resourceVersion: "12864801"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.234-11111-297953238"
uid: "0fcf6520-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_98af8"
startTime: "2019-06-11T12:47:19.705448+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.234:11111@297953238"
]
suspectingTimes: [
"2019-06-11 12:51:22.856 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204570
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T03:21:22.93462+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:21Z"
generation: 205
name: "10.244.0.31-11111-298204570"
namespace: "utiliread"
resourceVersion: "13511808"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298204570"
uid: "405ba26a-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f66b5"
startTime: "2019-06-14T10:36:11.8352878+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298265127"
]
suspectingTimes: [
"2019-06-15 03:25:39.923 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298265127
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T06:55:41.8285384+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T03:25:41Z"
generation: 46
name: "10.244.0.31-11111-298265127"
namespace: "utiliread"
resourceVersion: "13538472"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298265127"
uid: "40ad2eda-8f1d-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7f143"
startTime: "2019-06-15T03:25:27.9318099+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298278017"
]
suspectingTimes: [
"2019-06-15 07:00:24.162 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298278017
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T05:30:27.35304+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T07:00:25Z"
generation: 562
name: "10.244.0.31-11111-298278017"
namespace: "utiliread"
resourceVersion: "13886747"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298278017"
uid: "40480627-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_9d6f1"
startTime: "2019-06-15T07:00:18.8193208+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 05:34:17.329 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445646
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T06:21:58.2439994+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:34:18Z"
generation: 14
name: "10.244.0.31-11111-298445646"
namespace: "utiliread"
resourceVersion: "13893211"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298445646"
uid: "8d69e5fb-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_2a786"
startTime: "2019-06-17T05:34:07.112329+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 06:21:58.243 GMT"
]
}
{
address: "10.244.0.34"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448522
hostname: "samplestoresilo-789685bbf8-pgqwk"
iAmAliveTime: "2019-06-17T06:35:17.2805579+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:08Z"
generation: 7
name: "10.244.0.34-11111-298448522"
namespace: "utiliread"
resourceVersion: "13894934"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.34-11111-298448522"
uid: "3bcd18f3-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e353f"
startTime: "2019-06-17T06:22:03.5232614+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.34:11111@298448522"
]
suspectingTimes: [
"2019-06-17 06:35:17.280 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-17T10:00:23.0799904+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:22Z"
generation: 45
name: "10.244.1.154-11111-298449319"
namespace: "utiliread"
resourceVersion: "13920813"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298449319"
uid: "152d490b-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4c64b"
startTime: "2019-06-17T06:35:19.9434331+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 10:02:06.953 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298461715
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T03:22:08.9199231+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T10:02:08Z"
generation: 212
name: "10.244.1.154-11111-298461715"
namespace: "utiliread"
resourceVersion: "14050880"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298461715"
uid: "f78dfc21-90e6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_54a84"
startTime: "2019-06-17T10:01:56.2362073+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298524328"
]
suspectingTimes: [
"2019-06-18 03:25:36.779 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524328
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T05:55:38.677627+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:25:38Z"
generation: 34
name: "10.244.1.154-11111-298524328"
namespace: "utiliread"
resourceVersion: "14070212"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298524328"
uid: "be0ba56a-9178-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_88ef9"
startTime: "2019-06-18T03:25:29.5819737+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298533621"
]
suspectingTimes: [
"2019-06-18 06:00:26.021 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533621
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:10:27.8475709+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:00:27Z"
generation: 6
name: "10.244.1.154-11111-298533621"
namespace: "utiliread"
resourceVersion: "14071597"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298533621"
uid: "5ec89b7c-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_bb5f9"
startTime: "2019-06-18T06:00:23.2734568+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534256"
]
suspectingTimes: [
"2019-06-18 06:11:07.146 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534256
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:11:09.0933573+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:11:08Z"
generation: 4
name: "10.244.1.154-11111-298534256"
namespace: "utiliread"
resourceVersion: "14071951"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534256"
uid: "dcf5da2a-918f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b3a69"
startTime: "2019-06-18T06:10:57.1670382+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 06:13:29.317 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534403
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T13:08:31.0284391+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:13:30Z"
generation: 87
name: "10.244.1.154-11111-298534403"
namespace: "utiliread"
resourceVersion: "14124653"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534403"
uid: "31a50780-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7663d"
startTime: "2019-06-18T06:13:23.8449261+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298559580"
]
suspectingTimes: [
"2019-06-18 13:13:07.031 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559580
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T03:23:08.9800777+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:13:08Z"
generation: 174
name: "10.244.1.154-11111-298559580"
namespace: "utiliread"
resourceVersion: "14230789"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298559580"
uid: "d0c4bdf8-91ca-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_006be"
startTime: "2019-06-18T13:13:01.7666038+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 03:25:25.821 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298610721
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T15:01:02.9969027+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T03:25:27Z"
generation: 144
name: "10.244.1.154-11111-298610721"
namespace: "utiliread"
resourceVersion: "14317483"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298610721"
uid: "e1e3c381-9241-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c9bcf"
startTime: "2019-06-19T03:25:22.0894214+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 15:01:02.996 GMT"
]
}
{
address: "10.244.1.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953233
hostname: "samplestoresilo-789685bbf8-dn7hn"
iAmAliveTime: "2019-06-11T12:51:22.1600234+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:18Z"
generation: 5
name: "10.244.1.49-11111-297953233"
namespace: "utiliread"
resourceVersion: "12864798"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.49-11111-297953233"
uid: "0bf6c32e-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_3a67b"
startTime: "2019-06-11T12:47:14.5381316+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.49:11111@297953233"
]
suspectingTimes: [
"2019-06-11 12:51:22.160 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953492
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-12T03:21:47.0337972+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:46Z"
generation: 178
name: "10.244.1.50-11111-297953492"
namespace: "utiliread"
resourceVersion: "12973466"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-297953492"
uid: "abccfa35-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e0cf7"
startTime: "2019-06-11T12:51:34.1855359+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298005922"
]
suspectingTimes: [
"2019-06-12 03:25:34.570 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298005922
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-13T05:50:36.4884219+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-12T03:25:35Z"
generation: 320
name: "10.244.1.50-11111-298005922"
namespace: "utiliread"
resourceVersion: "13170881"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298005922"
uid: "be260353-8cc1-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_deb91"
startTime: "2019-06-12T03:25:23.0783201+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298101067"
]
suspectingTimes: [
"2019-06-13 05:51:18.571 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101067
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:46:20.5745259+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:19Z"
generation: 291
name: "10.244.1.50-11111-298101067"
namespace: "utiliread"
resourceVersion: "13350149"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298101067"
uid: "4465a4b0-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_37922"
startTime: "2019-06-13T05:51:08.5638001+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187359"
]
suspectingTimes: [
"2019-06-14 05:49:28.260 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187359
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:49:30.0761174+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:49:29Z"
generation: 4
name: "10.244.1.50-11111-298187359"
namespace: "utiliread"
resourceVersion: "13350467"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187359"
uid: "2d0bdd5e-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_5d535"
startTime: "2019-06-14T05:49:20.4465402+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187509"
]
suspectingTimes: [
"2019-06-14 05:51:54.323 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187509
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T08:56:56.4780532+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:51:55Z"
generation: 41
name: "10.244.1.50-11111-298187509"
namespace: "utiliread"
resourceVersion: "13374129"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187509"
uid: "84282e9c-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_aeb25"
startTime: "2019-06-14T05:51:50.2501753+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 09:00:06.726 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199055
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T10:36:05.5577063+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:04:22Z"
generation: 23
name: "10.244.1.50-11111-298199055"
namespace: "utiliread"
resourceVersion: "13386257"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298199055"
uid: "66792743-8e83-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_89d37"
startTime: "2019-06-14T09:04:18.5051592+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 10:36:05.557 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204573
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-15T06:56:20.0694468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:19Z"
generation: 248
name: "10.244.1.65-11111-298204573"
namespace: "utiliread"
resourceVersion: "13538262"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298204573"
uid: "3eed6091-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_58e43"
startTime: "2019-06-14T10:36:14.5063276+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298277926"
]
suspectingTimes: [
"2019-06-15 06:58:58.343 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298277926
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-16T03:24:00.3776894+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T06:58:59Z"
generation: 249
name: "10.244.1.65-11111-298277926"
namespace: "utiliread"
resourceVersion: "13690932"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298277926"
uid: "0d1cd86c-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b1981"
startTime: "2019-06-15T06:58:46.8443562+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298351523"
]
suspectingTimes: [
"2019-06-16 03:25:28.541 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298351523
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T03:25:30.5223938+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-16T03:25:29Z"
generation: 292
name: "10.244.1.65-11111-298351523"
namespace: "utiliread"
resourceVersion: "13870685"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298351523"
uid: "6441284c-8fe6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1197b"
startTime: "2019-06-16T03:25:23.7745601+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298437952"
]
suspectingTimes: [
"2019-06-17 03:26:05.642 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298437952
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T05:36:08.9606268+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T03:26:07Z"
generation: 30
name: "10.244.1.65-11111-298437952"
namespace: "utiliread"
resourceVersion: "13887109"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298437952"
uid: "a4dc70bb-90af-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_17bfd"
startTime: "2019-06-17T03:25:54.123374+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 05:37:04.302 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445814
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T06:21:57.3225468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:37:05Z"
generation: 13
name: "10.244.1.65-11111-298445814"
namespace: "utiliread"
resourceVersion: "13893205"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298445814"
uid: "f0ecb190-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b631b"
startTime: "2019-06-17T05:36:55.1450547+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 06:21:57.322 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297809187
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:16:33.5759148+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-09T20:46:32Z"
generation: 478
name: "10.244.3.138-11111-297809187"
namespace: "utiliread"
resourceVersion: "12860746"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297809187"
uid: "a9fdeca5-8af7-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_605a9"
startTime: "2019-06-09T20:46:27.9033132+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:19:58.197 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297951594
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:46:58.2604768+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:20:05Z"
generation: 10
name: "10.244.3.138-11111-297951594"
namespace: "utiliread"
resourceVersion: "12864181"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297951594"
uid: "3ed5b53c-8c43-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7a1e3"
startTime: "2019-06-11T12:19:55.2682603+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.138:11111@297951594"
]
suspectingTimes: [
"2019-06-11 12:46:58.260 GMT"
]
}
{
address: "10.244.3.139"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297945020
hostname: "samplestoresilo-789685bbf8-j79vv"
iAmAliveTime: "2019-06-11T12:46:58.602482+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T10:30:33Z"
generation: 32
name: "10.244.3.139-11111-297945020"
namespace: "utiliread"
resourceVersion: "12864183"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.139-11111-297945020"
uid: "f17119d8-8c33-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_731a8"
startTime: "2019-06-11T10:30:20.9634992+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:46:58.602 GMT"
]
}
{
address: "10.244.3.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448521
hostname: "samplestoresilo-789685bbf8-qhx5k"
iAmAliveTime: "2019-06-17T06:35:15.7397908+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:09Z"
generation: 7
name: "10.244.3.49-11111-298448521"
namespace: "utiliread"
resourceVersion: "13894927"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.49-11111-298448521"
uid: "3c465769-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1d4d7"
startTime: "2019-06-17T06:22:02.2849513+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.49:11111@298448521"
]
suspectingTimes: [
"2019-06-17 06:35:15.739 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953490
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-13T05:46:36.0470946+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:34Z"
generation: 494
name: "10.244.3.5-11111-297953490"
namespace: "utiliread"
resourceVersion: "13170890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-297953490"
uid: "a4d924e0-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e3235"
startTime: "2019-06-11T12:51:31.744242+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298101071"
]
suspectingTimes: [
"2019-06-13 05:51:20.012 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101071
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T05:46:22.2347732+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:21Z"
generation: 291
name: "10.244.3.5-11111-298101071"
namespace: "utiliread"
resourceVersion: "13350001"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298101071"
uid: "453b9e26-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_a7115"
startTime: "2019-06-13T05:51:12.6455421+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298187298"
]
suspectingTimes: [
"2019-06-14 05:48:24.687 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187298
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T06:18:26.3476543+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:48:25Z"
generation: 10
name: "10.244.3.5-11111-298187298"
namespace: "utiliread"
resourceVersion: "13354392"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298187298"
uid: "072c41ff-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4e118"
startTime: "2019-06-14T05:48:19.4318135+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 06:23:13.835 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298189383
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T09:13:15.5674791+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T06:23:15Z"
generation: 38
name: "10.244.3.5-11111-298189383"
namespace: "utiliread"
resourceVersion: "13376471"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298189383"
uid: "e46cd148-8e6c-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_0c820"
startTime: "2019-06-14T06:23:04.6723504+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 09:17:59.646 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199872
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T10:36:05.2727163+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:18:03Z"
generation: 20
name: "10.244.3.5-11111-298199872"
namespace: "utiliread"
resourceVersion: "13386255"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298199872"
uid: "502eb758-8e85-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c3772"
startTime: "2019-06-14T09:17:53.6756759+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298199872"
]
suspectingTimes: [
"2019-06-14 10:36:05.272 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:45:23.9149361+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:23Z"
generation: 78
name: "10.244.3.50-11111-298449319"
namespace: "utiliread"
resourceVersion: "13941238"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298449319"
uid: "15bd49a5-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_18763"
startTime: "2019-06-17T06:35:19.779006+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298471558"
]
suspectingTimes: [
"2019-06-17 12:46:07.108 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471558
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:46:08.9262019+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:08Z"
generation: 4
name: "10.244.3.50-11111-298471558"
namespace: "utiliread"
resourceVersion: "13941350"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471558"
uid: "e0c353a1-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_231cb"
startTime: "2019-06-17T12:45:59.625527+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 12:46:52.007 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471601
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T03:26:54.8059909+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:54Z"
generation: 179
name: "10.244.3.50-11111-298471601"
namespace: "utiliread"
resourceVersion: "14051496"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471601"
uid: "fc15eacd-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_cfc3b"
startTime: "2019-06-17T12:46:42.4281823+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298524614"
]
suspectingTimes: [
"2019-06-18 03:30:25.254 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524614
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:00:26.9274781+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:30:26Z"
generation: 34
name: "10.244.3.50-11111-298524614"
namespace: "utiliread"
resourceVersion: "14070512"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298524614"
uid: "69e21b32-9179-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_10846"
startTime: "2019-06-18T03:30:15.3304391+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298533755"
]
suspectingTimes: [
"2019-06-18 06:02:38.895 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533755
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:07:40.6013731+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:02:40Z"
generation: 5
name: "10.244.3.50-11111-298533755"
namespace: "utiliread"
resourceVersion: "14071796"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298533755"
uid: "ae023bd6-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_da2c7"
startTime: "2019-06-18T06:02:36.4165997+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534345"
]
suspectingTimes: [
"2019-06-18 06:12:28.624 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534345
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:12:30.5140926+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:12:29Z"
generation: 4
name: "10.244.3.50-11111-298534345"
namespace: "utiliread"
resourceVersion: "14072036"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534345"
uid: "0d79be8c-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c6383"
startTime: "2019-06-18T06:12:26.1622084+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534433"
]
suspectingTimes: [
"2019-06-18 06:14:00.960 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534433
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T13:04:02.7106446+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:14:02Z"
generation: 86
name: "10.244.3.50-11111-298534433"
namespace: "utiliread"
resourceVersion: "14123741"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534433"
uid: "447cb2a9-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_33f55"
startTime: "2019-06-18T06:13:54.0935096+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 13:06:08.353 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559171
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T16:16:19.9360389+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:06:19Z"
generation: 42
name: "10.244.3.50-11111-298559171"
namespace: "utiliread"
resourceVersion: "14147952"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298559171"
uid: "dd0b98df-91c9-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7d7a5"
startTime: "2019-06-18T13:06:12.4847577+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-18 16:20:30.154 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298570827
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-19T15:01:13.0824828+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T16:20:31Z"
generation: 277
name: "10.244.3.50-11111-298570827"
namespace: "utiliread"
resourceVersion: "14317523"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298570827"
uid: "fe3bbb48-91e4-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f0920"
startTime: "2019-06-18T16:20:28.0531226+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-19 15:01:13.082 GMT"
]
}
{
address: "10.244.3.51"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298652477
hostname: "samplestoresilo-789685bbf8-sdnkz"
iAmAliveTime: "2019-06-19T15:36:24.8351334+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T15:01:24Z"
generation: 10
name: "10.244.3.51-11111-298652477"
namespace: "utiliread"
resourceVersion: "14321922"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.51-11111-298652477"
uid: "1b1aeeb5-92a3-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_02a0e"
startTime: "2019-06-19T15:01:18.6450301+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
]
kind: "OrleansSiloList"
metadata: {
continue: ""
resourceVersion: "14322185"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos"
}
}
&lt;/code&gt;
</Description>
    <Title_Description>OrleansMessageRejectionException after several days of operation Hi

I am getting the following exception during communication with the silos after days/weeks of operation:

```
OrleansMessageRejectionException: The target silo is no longer active: target was S10.244.1.154:11111:298559580 but this silo is S10.244.1.154:11111:298610721. The rejected message is Request S10.244.1.154:11111:298610721*cli/6e93b0a7@7df7fe8a-&amp;gt;S10.244.1.154:11111:298559580*grn/436D1357/00000000&amp;#x2B;klejtrup~klejtrupvand/9999-12-31T23:59:59&amp;#x2B;00:00@3eeca186 #782747
```

I am running Orleans 2.3.1 with the Kubernetes membership provider. As far as I can tell the membership table looks fine. See the following output from the Kubernetes membership table:

&lt;details&gt;
&lt;summary&gt;Output from http://localhost:8001/apis/orleans.dot.net/v1/namespaces/utiliread/silos&lt;/summary&gt;
&lt;code&gt;
{
apiVersion: "orleans.dot.net/v1"
items: [
{
address: "10.244.0.234"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953238
hostname: "samplestoresilo-789685bbf8-jr82w"
iAmAliveTime: "2019-06-11T12:51:22.85686+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:24Z"
generation: 5
name: "10.244.0.234-11111-297953238"
namespace: "utiliread"
resourceVersion: "12864801"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.234-11111-297953238"
uid: "0fcf6520-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_98af8"
startTime: "2019-06-11T12:47:19.705448+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.234:11111@297953238"
]
suspectingTimes: [
"2019-06-11 12:51:22.856 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204570
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T03:21:22.93462+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:21Z"
generation: 205
name: "10.244.0.31-11111-298204570"
namespace: "utiliread"
resourceVersion: "13511808"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298204570"
uid: "405ba26a-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f66b5"
startTime: "2019-06-14T10:36:11.8352878+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298265127"
]
suspectingTimes: [
"2019-06-15 03:25:39.923 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298265127
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T06:55:41.8285384+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T03:25:41Z"
generation: 46
name: "10.244.0.31-11111-298265127"
namespace: "utiliread"
resourceVersion: "13538472"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298265127"
uid: "40ad2eda-8f1d-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7f143"
startTime: "2019-06-15T03:25:27.9318099+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298278017"
]
suspectingTimes: [
"2019-06-15 07:00:24.162 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298278017
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T05:30:27.35304+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T07:00:25Z"
generation: 562
name: "10.244.0.31-11111-298278017"
namespace: "utiliread"
resourceVersion: "13886747"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298278017"
uid: "40480627-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_9d6f1"
startTime: "2019-06-15T07:00:18.8193208+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 05:34:17.329 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445646
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T06:21:58.2439994+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:34:18Z"
generation: 14
name: "10.244.0.31-11111-298445646"
namespace: "utiliread"
resourceVersion: "13893211"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298445646"
uid: "8d69e5fb-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_2a786"
startTime: "2019-06-17T05:34:07.112329+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 06:21:58.243 GMT"
]
}
{
address: "10.244.0.34"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448522
hostname: "samplestoresilo-789685bbf8-pgqwk"
iAmAliveTime: "2019-06-17T06:35:17.2805579+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:08Z"
generation: 7
name: "10.244.0.34-11111-298448522"
namespace: "utiliread"
resourceVersion: "13894934"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.34-11111-298448522"
uid: "3bcd18f3-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e353f"
startTime: "2019-06-17T06:22:03.5232614+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.34:11111@298448522"
]
suspectingTimes: [
"2019-06-17 06:35:17.280 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-17T10:00:23.0799904+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:22Z"
generation: 45
name: "10.244.1.154-11111-298449319"
namespace: "utiliread"
resourceVersion: "13920813"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298449319"
uid: "152d490b-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4c64b"
startTime: "2019-06-17T06:35:19.9434331+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 10:02:06.953 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298461715
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T03:22:08.9199231+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T10:02:08Z"
generation: 212
name: "10.244.1.154-11111-298461715"
namespace: "utiliread"
resourceVersion: "14050880"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298461715"
uid: "f78dfc21-90e6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_54a84"
startTime: "2019-06-17T10:01:56.2362073+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298524328"
]
suspectingTimes: [
"2019-06-18 03:25:36.779 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524328
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T05:55:38.677627+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:25:38Z"
generation: 34
name: "10.244.1.154-11111-298524328"
namespace: "utiliread"
resourceVersion: "14070212"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298524328"
uid: "be0ba56a-9178-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_88ef9"
startTime: "2019-06-18T03:25:29.5819737+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298533621"
]
suspectingTimes: [
"2019-06-18 06:00:26.021 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533621
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:10:27.8475709+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:00:27Z"
generation: 6
name: "10.244.1.154-11111-298533621"
namespace: "utiliread"
resourceVersion: "14071597"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298533621"
uid: "5ec89b7c-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_bb5f9"
startTime: "2019-06-18T06:00:23.2734568+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534256"
]
suspectingTimes: [
"2019-06-18 06:11:07.146 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534256
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:11:09.0933573+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:11:08Z"
generation: 4
name: "10.244.1.154-11111-298534256"
namespace: "utiliread"
resourceVersion: "14071951"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534256"
uid: "dcf5da2a-918f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b3a69"
startTime: "2019-06-18T06:10:57.1670382+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 06:13:29.317 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534403
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T13:08:31.0284391+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:13:30Z"
generation: 87
name: "10.244.1.154-11111-298534403"
namespace: "utiliread"
resourceVersion: "14124653"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534403"
uid: "31a50780-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7663d"
startTime: "2019-06-18T06:13:23.8449261+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298559580"
]
suspectingTimes: [
"2019-06-18 13:13:07.031 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559580
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T03:23:08.9800777+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:13:08Z"
generation: 174
name: "10.244.1.154-11111-298559580"
namespace: "utiliread"
resourceVersion: "14230789"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298559580"
uid: "d0c4bdf8-91ca-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_006be"
startTime: "2019-06-18T13:13:01.7666038+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 03:25:25.821 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298610721
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T14:40:27.7322395+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T03:25:27Z"
generation: 138
name: "10.244.1.154-11111-298610721"
namespace: "utiliread"
resourceVersion: "14314879"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298610721"
uid: "e1e3c381-9241-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c9bcf"
startTime: "2019-06-19T03:25:22.0894214+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
{
address: "10.244.1.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953233
hostname: "samplestoresilo-789685bbf8-dn7hn"
iAmAliveTime: "2019-06-11T12:51:22.1600234+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:18Z"
generation: 5
name: "10.244.1.49-11111-297953233"
namespace: "utiliread"
resourceVersion: "12864798"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.49-11111-297953233"
uid: "0bf6c32e-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_3a67b"
startTime: "2019-06-11T12:47:14.5381316+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.49:11111@297953233"
]
suspectingTimes: [
"2019-06-11 12:51:22.160 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953492
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-12T03:21:47.0337972+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:46Z"
generation: 178
name: "10.244.1.50-11111-297953492"
namespace: "utiliread"
resourceVersion: "12973466"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-297953492"
uid: "abccfa35-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e0cf7"
startTime: "2019-06-11T12:51:34.1855359+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298005922"
]
suspectingTimes: [
"2019-06-12 03:25:34.570 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298005922
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-13T05:50:36.4884219+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-12T03:25:35Z"
generation: 320
name: "10.244.1.50-11111-298005922"
namespace: "utiliread"
resourceVersion: "13170881"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298005922"
uid: "be260353-8cc1-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_deb91"
startTime: "2019-06-12T03:25:23.0783201+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298101067"
]
suspectingTimes: [
"2019-06-13 05:51:18.571 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101067
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:46:20.5745259+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:19Z"
generation: 291
name: "10.244.1.50-11111-298101067"
namespace: "utiliread"
resourceVersion: "13350149"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298101067"
uid: "4465a4b0-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_37922"
startTime: "2019-06-13T05:51:08.5638001+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187359"
]
suspectingTimes: [
"2019-06-14 05:49:28.260 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187359
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:49:30.0761174+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:49:29Z"
generation: 4
name: "10.244.1.50-11111-298187359"
namespace: "utiliread"
resourceVersion: "13350467"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187359"
uid: "2d0bdd5e-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_5d535"
startTime: "2019-06-14T05:49:20.4465402+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187509"
]
suspectingTimes: [
"2019-06-14 05:51:54.323 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187509
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T08:56:56.4780532+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:51:55Z"
generation: 41
name: "10.244.1.50-11111-298187509"
namespace: "utiliread"
resourceVersion: "13374129"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187509"
uid: "84282e9c-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_aeb25"
startTime: "2019-06-14T05:51:50.2501753+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 09:00:06.726 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199055
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T10:36:05.5577063+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:04:22Z"
generation: 23
name: "10.244.1.50-11111-298199055"
namespace: "utiliread"
resourceVersion: "13386257"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298199055"
uid: "66792743-8e83-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_89d37"
startTime: "2019-06-14T09:04:18.5051592+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 10:36:05.557 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204573
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-15T06:56:20.0694468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:19Z"
generation: 248
name: "10.244.1.65-11111-298204573"
namespace: "utiliread"
resourceVersion: "13538262"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298204573"
uid: "3eed6091-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_58e43"
startTime: "2019-06-14T10:36:14.5063276+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298277926"
]
suspectingTimes: [
"2019-06-15 06:58:58.343 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298277926
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-16T03:24:00.3776894+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T06:58:59Z"
generation: 249
name: "10.244.1.65-11111-298277926"
namespace: "utiliread"
resourceVersion: "13690932"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298277926"
uid: "0d1cd86c-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b1981"
startTime: "2019-06-15T06:58:46.8443562+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298351523"
]
suspectingTimes: [
"2019-06-16 03:25:28.541 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298351523
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T03:25:30.5223938+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-16T03:25:29Z"
generation: 292
name: "10.244.1.65-11111-298351523"
namespace: "utiliread"
resourceVersion: "13870685"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298351523"
uid: "6441284c-8fe6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1197b"
startTime: "2019-06-16T03:25:23.7745601+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298437952"
]
suspectingTimes: [
"2019-06-17 03:26:05.642 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298437952
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T05:36:08.9606268+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T03:26:07Z"
generation: 30
name: "10.244.1.65-11111-298437952"
namespace: "utiliread"
resourceVersion: "13887109"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298437952"
uid: "a4dc70bb-90af-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_17bfd"
startTime: "2019-06-17T03:25:54.123374+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 05:37:04.302 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445814
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T06:21:57.3225468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:37:05Z"
generation: 13
name: "10.244.1.65-11111-298445814"
namespace: "utiliread"
resourceVersion: "13893205"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298445814"
uid: "f0ecb190-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b631b"
startTime: "2019-06-17T05:36:55.1450547+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 06:21:57.322 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297809187
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:16:33.5759148+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-09T20:46:32Z"
generation: 478
name: "10.244.3.138-11111-297809187"
namespace: "utiliread"
resourceVersion: "12860746"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297809187"
uid: "a9fdeca5-8af7-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_605a9"
startTime: "2019-06-09T20:46:27.9033132+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:19:58.197 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297951594
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:46:58.2604768+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:20:05Z"
generation: 10
name: "10.244.3.138-11111-297951594"
namespace: "utiliread"
resourceVersion: "12864181"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297951594"
uid: "3ed5b53c-8c43-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7a1e3"
startTime: "2019-06-11T12:19:55.2682603+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.138:11111@297951594"
]
suspectingTimes: [
"2019-06-11 12:46:58.260 GMT"
]
}
{
address: "10.244.3.139"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297945020
hostname: "samplestoresilo-789685bbf8-j79vv"
iAmAliveTime: "2019-06-11T12:46:58.602482+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T10:30:33Z"
generation: 32
name: "10.244.3.139-11111-297945020"
namespace: "utiliread"
resourceVersion: "12864183"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.139-11111-297945020"
uid: "f17119d8-8c33-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_731a8"
startTime: "2019-06-11T10:30:20.9634992+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:46:58.602 GMT"
]
}
{
address: "10.244.3.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448521
hostname: "samplestoresilo-789685bbf8-qhx5k"
iAmAliveTime: "2019-06-17T06:35:15.7397908+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:09Z"
generation: 7
name: "10.244.3.49-11111-298448521"
namespace: "utiliread"
resourceVersion: "13894927"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.49-11111-298448521"
uid: "3c465769-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1d4d7"
startTime: "2019-06-17T06:22:02.2849513+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.49:11111@298448521"
]
suspectingTimes: [
"2019-06-17 06:35:15.739 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953490
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-13T05:46:36.0470946+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:34Z"
generation: 494
name: "10.244.3.5-11111-297953490"
namespace: "utiliread"
resourceVersion: "13170890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-297953490"
uid: "a4d924e0-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e3235"
startTime: "2019-06-11T12:51:31.744242+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298101071"
]
suspectingTimes: [
"2019-06-13 05:51:20.012 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101071
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T05:46:22.2347732+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:21Z"
generation: 291
name: "10.244.3.5-11111-298101071"
namespace: "utiliread"
resourceVersion: "13350001"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298101071"
uid: "453b9e26-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_a7115"
startTime: "2019-06-13T05:51:12.6455421+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298187298"
]
suspectingTimes: [
"2019-06-14 05:48:24.687 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187298
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T06:18:26.3476543+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:48:25Z"
generation: 10
name: "10.244.3.5-11111-298187298"
namespace: "utiliread"
resourceVersion: "13354392"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298187298"
uid: "072c41ff-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4e118"
startTime: "2019-06-14T05:48:19.4318135+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 06:23:13.835 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298189383
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T09:13:15.5674791+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T06:23:15Z"
generation: 38
name: "10.244.3.5-11111-298189383"
namespace: "utiliread"
resourceVersion: "13376471"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298189383"
uid: "e46cd148-8e6c-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_0c820"
startTime: "2019-06-14T06:23:04.6723504+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 09:17:59.646 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199872
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T10:36:05.2727163+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:18:03Z"
generation: 20
name: "10.244.3.5-11111-298199872"
namespace: "utiliread"
resourceVersion: "13386255"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298199872"
uid: "502eb758-8e85-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c3772"
startTime: "2019-06-14T09:17:53.6756759+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298199872"
]
suspectingTimes: [
"2019-06-14 10:36:05.272 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:45:23.9149361+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:23Z"
generation: 78
name: "10.244.3.50-11111-298449319"
namespace: "utiliread"
resourceVersion: "13941238"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298449319"
uid: "15bd49a5-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_18763"
startTime: "2019-06-17T06:35:19.779006+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298471558"
]
suspectingTimes: [
"2019-06-17 12:46:07.108 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471558
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:46:08.9262019+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:08Z"
generation: 4
name: "10.244.3.50-11111-298471558"
namespace: "utiliread"
resourceVersion: "13941350"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471558"
uid: "e0c353a1-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_231cb"
startTime: "2019-06-17T12:45:59.625527+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 12:46:52.007 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471601
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T03:26:54.8059909+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:54Z"
generation: 179
name: "10.244.3.50-11111-298471601"
namespace: "utiliread"
resourceVersion: "14051496"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471601"
uid: "fc15eacd-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_cfc3b"
startTime: "2019-06-17T12:46:42.4281823+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298524614"
]
suspectingTimes: [
"2019-06-18 03:30:25.254 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524614
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:00:26.9274781+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:30:26Z"
generation: 34
name: "10.244.3.50-11111-298524614"
namespace: "utiliread"
resourceVersion: "14070512"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298524614"
uid: "69e21b32-9179-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_10846"
startTime: "2019-06-18T03:30:15.3304391+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298533755"
]
suspectingTimes: [
"2019-06-18 06:02:38.895 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533755
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:07:40.6013731+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:02:40Z"
generation: 5
name: "10.244.3.50-11111-298533755"
namespace: "utiliread"
resourceVersion: "14071796"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298533755"
uid: "ae023bd6-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_da2c7"
startTime: "2019-06-18T06:02:36.4165997+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534345"
]
suspectingTimes: [
"2019-06-18 06:12:28.624 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534345
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:12:30.5140926+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:12:29Z"
generation: 4
name: "10.244.3.50-11111-298534345"
namespace: "utiliread"
resourceVersion: "14072036"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534345"
uid: "0d79be8c-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c6383"
startTime: "2019-06-18T06:12:26.1622084+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534433"
]
suspectingTimes: [
"2019-06-18 06:14:00.960 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534433
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T13:04:02.7106446+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:14:02Z"
generation: 86
name: "10.244.3.50-11111-298534433"
namespace: "utiliread"
resourceVersion: "14123741"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534433"
uid: "447cb2a9-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_33f55"
startTime: "2019-06-18T06:13:54.0935096+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 13:06:08.353 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559171
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T16:16:19.9360389+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:06:19Z"
generation: 42
name: "10.244.3.50-11111-298559171"
namespace: "utiliread"
resourceVersion: "14147952"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298559171"
uid: "dd0b98df-91c9-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7d7a5"
startTime: "2019-06-18T13:06:12.4847577+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-18 16:20:30.154 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298570827
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-19T14:40:32.2742356+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T16:20:31Z"
generation: 271
name: "10.244.3.50-11111-298570827"
namespace: "utiliread"
resourceVersion: "14314890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298570827"
uid: "fe3bbb48-91e4-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f0920"
startTime: "2019-06-18T16:20:28.0531226+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
]
kind: "OrleansSiloList"
metadata: {
continue: ""
resourceVersion: "14315332"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos"
}
}
&lt;/code&gt;
&lt;/details&gt;

It shows that 10.244.1.154:11111@298559580 has the suspecting silo 10.244.1.154:11111@298610721 which seems correct?

Restarting the silos resolved the problem...

&lt;details&gt;
&lt;summary&gt;
Here is the table after the restart of the two silos
&lt;/summary&gt;
&lt;code&gt;
{
apiVersion: "orleans.dot.net/v1"
items: [
{
address: "10.244.0.100"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298652479
hostname: "samplestoresilo-789685bbf8-mnfrl"
iAmAliveTime: "2019-06-19T15:36:25.0837066+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T15:01:24Z"
generation: 10
name: "10.244.0.100-11111-298652479"
namespace: "utiliread"
resourceVersion: "14321924"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.100-11111-298652479"
uid: "1b4fdf33-92a3-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f6c63"
startTime: "2019-06-19T15:01:20.1597054+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
{
address: "10.244.0.234"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953238
hostname: "samplestoresilo-789685bbf8-jr82w"
iAmAliveTime: "2019-06-11T12:51:22.85686+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:24Z"
generation: 5
name: "10.244.0.234-11111-297953238"
namespace: "utiliread"
resourceVersion: "12864801"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.234-11111-297953238"
uid: "0fcf6520-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_98af8"
startTime: "2019-06-11T12:47:19.705448+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.234:11111@297953238"
]
suspectingTimes: [
"2019-06-11 12:51:22.856 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204570
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T03:21:22.93462+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:21Z"
generation: 205
name: "10.244.0.31-11111-298204570"
namespace: "utiliread"
resourceVersion: "13511808"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298204570"
uid: "405ba26a-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f66b5"
startTime: "2019-06-14T10:36:11.8352878+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298265127"
]
suspectingTimes: [
"2019-06-15 03:25:39.923 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298265127
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-15T06:55:41.8285384+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T03:25:41Z"
generation: 46
name: "10.244.0.31-11111-298265127"
namespace: "utiliread"
resourceVersion: "13538472"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298265127"
uid: "40ad2eda-8f1d-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7f143"
startTime: "2019-06-15T03:25:27.9318099+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298278017"
]
suspectingTimes: [
"2019-06-15 07:00:24.162 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298278017
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T05:30:27.35304+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T07:00:25Z"
generation: 562
name: "10.244.0.31-11111-298278017"
namespace: "utiliread"
resourceVersion: "13886747"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298278017"
uid: "40480627-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_9d6f1"
startTime: "2019-06-15T07:00:18.8193208+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 05:34:17.329 GMT"
]
}
{
address: "10.244.0.31"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445646
hostname: "samplestoresilo-789685bbf8-lfsfh"
iAmAliveTime: "2019-06-17T06:21:58.2439994+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:34:18Z"
generation: 14
name: "10.244.0.31-11111-298445646"
namespace: "utiliread"
resourceVersion: "13893211"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.31-11111-298445646"
uid: "8d69e5fb-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_2a786"
startTime: "2019-06-17T05:34:07.112329+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.31:11111@298445646"
]
suspectingTimes: [
"2019-06-17 06:21:58.243 GMT"
]
}
{
address: "10.244.0.34"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448522
hostname: "samplestoresilo-789685bbf8-pgqwk"
iAmAliveTime: "2019-06-17T06:35:17.2805579+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:08Z"
generation: 7
name: "10.244.0.34-11111-298448522"
namespace: "utiliread"
resourceVersion: "13894934"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.0.34-11111-298448522"
uid: "3bcd18f3-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e353f"
startTime: "2019-06-17T06:22:03.5232614+00:00"
status: "dead"
suspectingSilos: [
"10.244.0.34:11111@298448522"
]
suspectingTimes: [
"2019-06-17 06:35:17.280 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-17T10:00:23.0799904+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:22Z"
generation: 45
name: "10.244.1.154-11111-298449319"
namespace: "utiliread"
resourceVersion: "13920813"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298449319"
uid: "152d490b-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4c64b"
startTime: "2019-06-17T06:35:19.9434331+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 10:02:06.953 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298461715
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T03:22:08.9199231+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T10:02:08Z"
generation: 212
name: "10.244.1.154-11111-298461715"
namespace: "utiliread"
resourceVersion: "14050880"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298461715"
uid: "f78dfc21-90e6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_54a84"
startTime: "2019-06-17T10:01:56.2362073+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298524328"
]
suspectingTimes: [
"2019-06-18 03:25:36.779 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524328
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T05:55:38.677627+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:25:38Z"
generation: 34
name: "10.244.1.154-11111-298524328"
namespace: "utiliread"
resourceVersion: "14070212"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298524328"
uid: "be0ba56a-9178-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_88ef9"
startTime: "2019-06-18T03:25:29.5819737+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298533621"
]
suspectingTimes: [
"2019-06-18 06:00:26.021 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533621
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:10:27.8475709+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:00:27Z"
generation: 6
name: "10.244.1.154-11111-298533621"
namespace: "utiliread"
resourceVersion: "14071597"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298533621"
uid: "5ec89b7c-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_bb5f9"
startTime: "2019-06-18T06:00:23.2734568+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534256"
]
suspectingTimes: [
"2019-06-18 06:11:07.146 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534256
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T06:11:09.0933573+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:11:08Z"
generation: 4
name: "10.244.1.154-11111-298534256"
namespace: "utiliread"
resourceVersion: "14071951"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534256"
uid: "dcf5da2a-918f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b3a69"
startTime: "2019-06-18T06:10:57.1670382+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 06:13:29.317 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534403
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-18T13:08:31.0284391+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:13:30Z"
generation: 87
name: "10.244.1.154-11111-298534403"
namespace: "utiliread"
resourceVersion: "14124653"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298534403"
uid: "31a50780-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7663d"
startTime: "2019-06-18T06:13:23.8449261+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298559580"
]
suspectingTimes: [
"2019-06-18 13:13:07.031 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559580
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T03:23:08.9800777+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:13:08Z"
generation: 174
name: "10.244.1.154-11111-298559580"
namespace: "utiliread"
resourceVersion: "14230789"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298559580"
uid: "d0c4bdf8-91ca-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_006be"
startTime: "2019-06-18T13:13:01.7666038+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 03:25:25.821 GMT"
]
}
{
address: "10.244.1.154"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298610721
hostname: "samplestoresilo-789685bbf8-ndjw2"
iAmAliveTime: "2019-06-19T15:01:02.9969027+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T03:25:27Z"
generation: 144
name: "10.244.1.154-11111-298610721"
namespace: "utiliread"
resourceVersion: "14317483"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.154-11111-298610721"
uid: "e1e3c381-9241-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c9bcf"
startTime: "2019-06-19T03:25:22.0894214+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298610721"
]
suspectingTimes: [
"2019-06-19 15:01:02.996 GMT"
]
}
{
address: "10.244.1.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953233
hostname: "samplestoresilo-789685bbf8-dn7hn"
iAmAliveTime: "2019-06-11T12:51:22.1600234+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:47:18Z"
generation: 5
name: "10.244.1.49-11111-297953233"
namespace: "utiliread"
resourceVersion: "12864798"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.49-11111-297953233"
uid: "0bf6c32e-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_3a67b"
startTime: "2019-06-11T12:47:14.5381316+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.49:11111@297953233"
]
suspectingTimes: [
"2019-06-11 12:51:22.160 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953492
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-12T03:21:47.0337972+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:46Z"
generation: 178
name: "10.244.1.50-11111-297953492"
namespace: "utiliread"
resourceVersion: "12973466"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-297953492"
uid: "abccfa35-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e0cf7"
startTime: "2019-06-11T12:51:34.1855359+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298005922"
]
suspectingTimes: [
"2019-06-12 03:25:34.570 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298005922
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-13T05:50:36.4884219+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-12T03:25:35Z"
generation: 320
name: "10.244.1.50-11111-298005922"
namespace: "utiliread"
resourceVersion: "13170881"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298005922"
uid: "be260353-8cc1-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_deb91"
startTime: "2019-06-12T03:25:23.0783201+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298101067"
]
suspectingTimes: [
"2019-06-13 05:51:18.571 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101067
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:46:20.5745259+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:19Z"
generation: 291
name: "10.244.1.50-11111-298101067"
namespace: "utiliread"
resourceVersion: "13350149"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298101067"
uid: "4465a4b0-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_37922"
startTime: "2019-06-13T05:51:08.5638001+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187359"
]
suspectingTimes: [
"2019-06-14 05:49:28.260 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187359
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T05:49:30.0761174+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:49:29Z"
generation: 4
name: "10.244.1.50-11111-298187359"
namespace: "utiliread"
resourceVersion: "13350467"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187359"
uid: "2d0bdd5e-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_5d535"
startTime: "2019-06-14T05:49:20.4465402+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298187509"
]
suspectingTimes: [
"2019-06-14 05:51:54.323 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187509
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T08:56:56.4780532+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:51:55Z"
generation: 41
name: "10.244.1.50-11111-298187509"
namespace: "utiliread"
resourceVersion: "13374129"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298187509"
uid: "84282e9c-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_aeb25"
startTime: "2019-06-14T05:51:50.2501753+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 09:00:06.726 GMT"
]
}
{
address: "10.244.1.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199055
hostname: "samplestoresilo-789685bbf8-lnl8r"
iAmAliveTime: "2019-06-14T10:36:05.5577063+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:04:22Z"
generation: 23
name: "10.244.1.50-11111-298199055"
namespace: "utiliread"
resourceVersion: "13386257"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.50-11111-298199055"
uid: "66792743-8e83-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_89d37"
startTime: "2019-06-14T09:04:18.5051592+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 10:36:05.557 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298204573
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-15T06:56:20.0694468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T10:36:19Z"
generation: 248
name: "10.244.1.65-11111-298204573"
namespace: "utiliread"
resourceVersion: "13538262"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298204573"
uid: "3eed6091-8e90-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_58e43"
startTime: "2019-06-14T10:36:14.5063276+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298277926"
]
suspectingTimes: [
"2019-06-15 06:58:58.343 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298277926
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-16T03:24:00.3776894+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-15T06:58:59Z"
generation: 249
name: "10.244.1.65-11111-298277926"
namespace: "utiliread"
resourceVersion: "13690932"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298277926"
uid: "0d1cd86c-8f3b-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b1981"
startTime: "2019-06-15T06:58:46.8443562+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298351523"
]
suspectingTimes: [
"2019-06-16 03:25:28.541 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298351523
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T03:25:30.5223938+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-16T03:25:29Z"
generation: 292
name: "10.244.1.65-11111-298351523"
namespace: "utiliread"
resourceVersion: "13870685"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298351523"
uid: "6441284c-8fe6-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1197b"
startTime: "2019-06-16T03:25:23.7745601+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298437952"
]
suspectingTimes: [
"2019-06-17 03:26:05.642 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298437952
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T05:36:08.9606268+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T03:26:07Z"
generation: 30
name: "10.244.1.65-11111-298437952"
namespace: "utiliread"
resourceVersion: "13887109"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298437952"
uid: "a4dc70bb-90af-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_17bfd"
startTime: "2019-06-17T03:25:54.123374+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 05:37:04.302 GMT"
]
}
{
address: "10.244.1.65"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298445814
hostname: "samplestoresilo-789685bbf8-hwvqz"
iAmAliveTime: "2019-06-17T06:21:57.3225468+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T05:37:05Z"
generation: 13
name: "10.244.1.65-11111-298445814"
namespace: "utiliread"
resourceVersion: "13893205"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.1.65-11111-298445814"
uid: "f0ecb190-90c1-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_b631b"
startTime: "2019-06-17T05:36:55.1450547+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.65:11111@298445814"
]
suspectingTimes: [
"2019-06-17 06:21:57.322 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297809187
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:16:33.5759148+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-09T20:46:32Z"
generation: 478
name: "10.244.3.138-11111-297809187"
namespace: "utiliread"
resourceVersion: "12860746"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297809187"
uid: "a9fdeca5-8af7-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_605a9"
startTime: "2019-06-09T20:46:27.9033132+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:19:58.197 GMT"
]
}
{
address: "10.244.3.138"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297951594
hostname: "samplestoresilo-789685bbf8-vpn2j"
iAmAliveTime: "2019-06-11T12:46:58.2604768+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:20:05Z"
generation: 10
name: "10.244.3.138-11111-297951594"
namespace: "utiliread"
resourceVersion: "12864181"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.138-11111-297951594"
uid: "3ed5b53c-8c43-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7a1e3"
startTime: "2019-06-11T12:19:55.2682603+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.138:11111@297951594"
]
suspectingTimes: [
"2019-06-11 12:46:58.260 GMT"
]
}
{
address: "10.244.3.139"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297945020
hostname: "samplestoresilo-789685bbf8-j79vv"
iAmAliveTime: "2019-06-11T12:46:58.602482+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T10:30:33Z"
generation: 32
name: "10.244.3.139-11111-297945020"
namespace: "utiliread"
resourceVersion: "12864183"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.139-11111-297945020"
uid: "f17119d8-8c33-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_731a8"
startTime: "2019-06-11T10:30:20.9634992+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.139:11111@297945020"
]
suspectingTimes: [
"2019-06-11 12:46:58.602 GMT"
]
}
{
address: "10.244.3.49"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298448521
hostname: "samplestoresilo-789685bbf8-qhx5k"
iAmAliveTime: "2019-06-17T06:35:15.7397908+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:22:09Z"
generation: 7
name: "10.244.3.49-11111-298448521"
namespace: "utiliread"
resourceVersion: "13894927"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.49-11111-298448521"
uid: "3c465769-90c8-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_1d4d7"
startTime: "2019-06-17T06:22:02.2849513+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.49:11111@298448521"
]
suspectingTimes: [
"2019-06-17 06:35:15.739 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 297953490
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-13T05:46:36.0470946+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-11T12:51:34Z"
generation: 494
name: "10.244.3.5-11111-297953490"
namespace: "utiliread"
resourceVersion: "13170890"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-297953490"
uid: "a4d924e0-8c47-11e9-b397-36480728ca93"
}
port: 11111
proxyPort: 30000
siloName: "Silo_e3235"
startTime: "2019-06-11T12:51:31.744242+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298101071"
]
suspectingTimes: [
"2019-06-13 05:51:20.012 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298101071
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T05:46:22.2347732+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-13T05:51:21Z"
generation: 291
name: "10.244.3.5-11111-298101071"
namespace: "utiliread"
resourceVersion: "13350001"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298101071"
uid: "453b9e26-8d9f-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_a7115"
startTime: "2019-06-13T05:51:12.6455421+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298187298"
]
suspectingTimes: [
"2019-06-14 05:48:24.687 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298187298
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T06:18:26.3476543+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T05:48:25Z"
generation: 10
name: "10.244.3.5-11111-298187298"
namespace: "utiliread"
resourceVersion: "13354392"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298187298"
uid: "072c41ff-8e68-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_4e118"
startTime: "2019-06-14T05:48:19.4318135+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298189383"
]
suspectingTimes: [
"2019-06-14 06:23:13.835 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298189383
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T09:13:15.5674791+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T06:23:15Z"
generation: 38
name: "10.244.3.5-11111-298189383"
namespace: "utiliread"
resourceVersion: "13376471"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298189383"
uid: "e46cd148-8e6c-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_0c820"
startTime: "2019-06-14T06:23:04.6723504+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.50:11111@298199055"
]
suspectingTimes: [
"2019-06-14 09:17:59.646 GMT"
]
}
{
address: "10.244.3.5"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298199872
hostname: "samplestoresilo-789685bbf8-mg6kv"
iAmAliveTime: "2019-06-14T10:36:05.2727163+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-14T09:18:03Z"
generation: 20
name: "10.244.3.5-11111-298199872"
namespace: "utiliread"
resourceVersion: "13386255"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.5-11111-298199872"
uid: "502eb758-8e85-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c3772"
startTime: "2019-06-14T09:17:53.6756759+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.5:11111@298199872"
]
suspectingTimes: [
"2019-06-14 10:36:05.272 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298449319
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:45:23.9149361+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T06:35:23Z"
generation: 78
name: "10.244.3.50-11111-298449319"
namespace: "utiliread"
resourceVersion: "13941238"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298449319"
uid: "15bd49a5-90ca-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_18763"
startTime: "2019-06-17T06:35:19.779006+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298471558"
]
suspectingTimes: [
"2019-06-17 12:46:07.108 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471558
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-17T12:46:08.9262019+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:08Z"
generation: 4
name: "10.244.3.50-11111-298471558"
namespace: "utiliread"
resourceVersion: "13941350"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471558"
uid: "e0c353a1-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_231cb"
startTime: "2019-06-17T12:45:59.625527+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298461715"
]
suspectingTimes: [
"2019-06-17 12:46:52.007 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298471601
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T03:26:54.8059909+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-17T12:46:54Z"
generation: 179
name: "10.244.3.50-11111-298471601"
namespace: "utiliread"
resourceVersion: "14051496"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298471601"
uid: "fc15eacd-90fd-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_cfc3b"
startTime: "2019-06-17T12:46:42.4281823+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298524614"
]
suspectingTimes: [
"2019-06-18 03:30:25.254 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298524614
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:00:26.9274781+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T03:30:26Z"
generation: 34
name: "10.244.3.50-11111-298524614"
namespace: "utiliread"
resourceVersion: "14070512"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298524614"
uid: "69e21b32-9179-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_10846"
startTime: "2019-06-18T03:30:15.3304391+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298533755"
]
suspectingTimes: [
"2019-06-18 06:02:38.895 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298533755
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:07:40.6013731+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:02:40Z"
generation: 5
name: "10.244.3.50-11111-298533755"
namespace: "utiliread"
resourceVersion: "14071796"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298533755"
uid: "ae023bd6-918e-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_da2c7"
startTime: "2019-06-18T06:02:36.4165997+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534345"
]
suspectingTimes: [
"2019-06-18 06:12:28.624 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534345
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T06:12:30.5140926+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:12:29Z"
generation: 4
name: "10.244.3.50-11111-298534345"
namespace: "utiliread"
resourceVersion: "14072036"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534345"
uid: "0d79be8c-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_c6383"
startTime: "2019-06-18T06:12:26.1622084+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298534433"
]
suspectingTimes: [
"2019-06-18 06:14:00.960 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298534433
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T13:04:02.7106446+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T06:14:02Z"
generation: 86
name: "10.244.3.50-11111-298534433"
namespace: "utiliread"
resourceVersion: "14123741"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298534433"
uid: "447cb2a9-9190-11e9-979b-b60b76c42098"
}
port: 11111
proxyPort: 30000
siloName: "Silo_33f55"
startTime: "2019-06-18T06:13:54.0935096+00:00"
status: "dead"
suspectingSilos: [
"10.244.1.154:11111@298534403"
]
suspectingTimes: [
"2019-06-18 13:06:08.353 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298559171
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-18T16:16:19.9360389+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T13:06:19Z"
generation: 42
name: "10.244.3.50-11111-298559171"
namespace: "utiliread"
resourceVersion: "14147952"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298559171"
uid: "dd0b98df-91c9-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_7d7a5"
startTime: "2019-06-18T13:06:12.4847577+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-18 16:20:30.154 GMT"
]
}
{
address: "10.244.3.50"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298570827
hostname: "samplestoresilo-789685bbf8-gxqxc"
iAmAliveTime: "2019-06-19T15:01:13.0824828+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-18T16:20:31Z"
generation: 277
name: "10.244.3.50-11111-298570827"
namespace: "utiliread"
resourceVersion: "14317523"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.50-11111-298570827"
uid: "fe3bbb48-91e4-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_f0920"
startTime: "2019-06-18T16:20:28.0531226+00:00"
status: "dead"
suspectingSilos: [
"10.244.3.50:11111@298570827"
]
suspectingTimes: [
"2019-06-19 15:01:13.082 GMT"
]
}
{
address: "10.244.3.51"
apiVersion: "orleans.dot.net/v1"
clusterId: "samplestore"
generation: 298652477
hostname: "samplestoresilo-789685bbf8-sdnkz"
iAmAliveTime: "2019-06-19T15:36:24.8351334+00:00"
kind: "OrleansSilo"
metadata: {
creationTimestamp: "2019-06-19T15:01:24Z"
generation: 10
name: "10.244.3.51-11111-298652477"
namespace: "utiliread"
resourceVersion: "14321922"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos/10.244.3.51-11111-298652477"
uid: "1b1aeeb5-92a3-11e9-aa92-b624a6412b81"
}
port: 11111
proxyPort: 30000
siloName: "Silo_02a0e"
startTime: "2019-06-19T15:01:18.6450301+00:00"
status: "active"
suspectingSilos: [ ]
suspectingTimes: [ ]
}
]
kind: "OrleansSiloList"
metadata: {
continue: ""
resourceVersion: "14322185"
selfLink: "/apis/orleans.dot.net/v1/namespaces/utiliread/silos"
}
}
&lt;/code&gt;
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5697</IssueLabelID>
    <Title>NullReferenceException on Stream Client when Calling OnCompletedAsync</Title>
    <Description>When a Stream client calls `OnCompletedAsync` I get a NullReferenceException.  A minimal repro is provided in the attached zip
[OrleansSample.zip](https://github.com/dotnet/orleans/files/3306576/OrleansSample.zip)
</Description>
    <Title_Description>NullReferenceException on Stream Client when Calling OnCompletedAsync When a Stream client calls `OnCompletedAsync` I get a NullReferenceException.  A minimal repro is provided in the attached zip
[OrleansSample.zip](https://github.com/dotnet/orleans/files/3306576/OrleansSample.zip)
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5696</IssueLabelID>
    <Title>What does the ClusterOption.ServiceId actually do?</Title>
    <Description>I have one cluster with two silo services (A and B). I build a client with options.ServiceId= "A". With this client I find I can get the grain in the Service B to invoke the services B's method.
So is that the right behavior? If that what does serviceid option actually do? 
I read the doc and source code but I still cannot get through.  
Anyone can help to give an clear explanation? Thanks very much.


&gt;Orleans clustering information
    [...]
    // Clustering information
    .Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = "my-first-cluster";
        options.ServiceId = "AspNetSampleApp";
    })
    [...]
&gt;Here we do two things:
Set the ClusterId to "my-first-cluster": this is a unique ID for the Orleans cluster. All clients and silos that use this ID will be able to talk directly to each other. You can choose to use a different ClusterId for different deployments though.
Set the ServiceId to "AspNetSampleApp": this is a unique ID for your application that will be used by some providers such as persistence providers. This ID should remain stable and not change across deployments.

*PS: English is not my native language; please excuse typing errors.*
</Description>
    <Title_Description>What does the ClusterOption.ServiceId actually do? I have one cluster with two silo services (A and B). I build a client with options.ServiceId= "A". With this client I find I can get the grain in the Service B to invoke the services B's method.
So is that the right behavior? If that what does serviceid option actually do? 
I read the doc and source code but I still cannot get through.  
Anyone can help to give an clear explanation? Thanks very much.


&gt;Orleans clustering information
    [...]
    // Clustering information
    .Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = "my-first-cluster";
        options.ServiceId = "AspNetSampleApp";
    })
    [...]
&gt;Here we do two things:
Set the ClusterId to "my-first-cluster": this is a unique ID for the Orleans cluster. All clients and silos that use this ID will be able to talk directly to each other. You can choose to use a different ClusterId for different deployments though.
Set the ServiceId to "AspNetSampleApp": this is a unique ID for your application that will be used by some providers such as persistence providers. This ID should remain stable and not change across deployments.

*PS: English is not my native language; please excuse typing errors.*
</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5694</IssueLabelID>
    <Title>ClusterClient: only call IRuntimeClient.Reset for OutsideRuntimeClient</Title>
    <Description>Fixes some benign exceptions during shutdown now that ClusterClient is also used on silos</Description>
    <Title_Description>ClusterClient: only call IRuntimeClient.Reset for OutsideRuntimeClient Fixes some benign exceptions during shutdown now that ClusterClient is also used on silos</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5692</IssueLabelID>
    <Title>Is Orleans Transactions ready for production?</Title>
    <Description>So far after using it full scale for 4 weeks it feels like Orleans transactions still have ways to go and it's not ready for production. We have been getting constant issues as described in #5644 and even after designing our implementation away from "multiple calls to the same grain within the same transaction" we are still getting issues with broken lock exceptions.
In fact while running tests the failure seems to cascade to other transactions as well causing all the tests to fail. It will be good to perhaps document the limitations of transactions as well as techniques to prevent broken lock exceptions or deadlocks</Description>
    <Title_Description>Is Orleans Transactions ready for production? So far after using it full scale for 4 weeks it feels like Orleans transactions still have ways to go and it's not ready for production. We have been getting constant issues as described in #5644 and even after designing our implementation away from "multiple calls to the same grain within the same transaction" we are still getting issues with broken lock exceptions.
In fact while running tests the failure seems to cascade to other transactions as well causing all the tests to fail. It will be good to perhaps document the limitations of transactions as well as techniques to prevent broken lock exceptions or deadlocks</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5691</IssueLabelID>
    <Title>Add core tracing events</Title>
    <Description>Adding core tracing events for application layer grain requests. </Description>
    <Title_Description>Add core tracing events Adding core tracing events for application layer grain requests. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5690</IssueLabelID>
    <Title>Cherry-pick #5473 for 2.3.5</Title>
    <Description>Fix #5473 - codegen fails on recursively defined types (#5688)</Description>
    <Title_Description>Cherry-pick #5473 for 2.3.5 Fix #5473 - codegen fails on recursively defined types (#5688)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5689</IssueLabelID>
    <Title>CodeGenerator: skip empty projects</Title>
    <Description>Fixes #5678</Description>
    <Title_Description>CodeGenerator: skip empty projects Fixes #5678</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5687</IssueLabelID>
    <Title>When shutting down a silo new grain is activated on another silo before the old has finished deactivating.</Title>
    <Description>Setup:

3 silos running on separate EC2 instances in docker
3 frontend servers

Load test client generating a minor load (~100 grains per silo ~1-2 messages per second)

Grain is activated on Silo1
Silo1 is shut down

Log message timestamps (filtered by the id of this player's grain):

17:15:48.770 silo-2 message indicating the grain has been activated (error message that indicates that the state is not what we expect it to be meaning this state is out of date)
17:15:49.575 silo-1 message indicating grain is being shut down
17:15:49.585 silo-1 message indicating state is written to the database
17:15:52.831 silo-1 message indicating the graceful shutdown of the silohost has completed

The occurence rate is about 1-2% of grains under mild load. This is obviously a massive issue because the state gets corrupted as the flush in silo-1 doesn't complete before silo-2 claims ownership of the data.

Is there any potential setup error that can cause this? 
</Description>
    <Title_Description>When shutting down a silo, new grain is activated on another silo before the old has finished deactivating. Setup:

3 silos running on separate EC2 instances in docker
3 frontend servers

Load test client generating a minor load (~100 grains per silo ~1-2 messages per second)

Grain is activated on Silo1
Silo1 is shut down

Log message timestamps (filtered by the id of this player's grain):

17:15:48.770 silo-2 message indicating the grain has been activated (error message that indicates that the state is not what we expect it to be meaning this state is out of date)
17:15:49.575 silo-1 message indicating grain is being shut down
17:15:49.585 silo-1 message indicating state is written to the database
17:15:52.831 silo-1 message indicating the graceful shutdown of the silohost has completed

The occurence rate is about 1-2% of grains under mild load. This is obviously a massive issue because the state gets corrupted as the flush in silo-1 doesn't complete before silo-2 claims ownership of the data.

Is there any potential setup error that can cause this? 
</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5686</IssueLabelID>
    <Title>Json serialization references wrong ordering</Title>
    <Description>Using Json serialization when you have multiple references to the same object usually creates a graph such that the first time an object is encountered it has the properties and an `$id` which identifies that instance. Thereafter in the JSON a `$ref` property is used to identify that pre-defined object and a reference is inserted.

I have a situation where the `$ref` comes _before_ the definition of the object which means that is being deserialized to `null`. 

This is a real headscratcher because I cant reproduce the same problem in isolation using a simpler object graph and JSON.NET. Butmy fairly complex grain state exhibits the problem _every time_.

Has anyone ever experienced this? 

Below is a (snipped) copy of my JSON demonstrating the problem. You'll notice 2 `"$ref" : "5"` that come before the definition of `"$id": "5"`:

```
{
  "$id": "1"
  "$type": "Redacted.GrainSTateTypeName Redacted.GrainAssembly"
  "Block": {
    "$id": "2"
    "$type": "Redacted.TypeName Redacted.Assembly"
    "Terms": {
      "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
      "$values": [
        {
          "$ref": "5"
        }
      ]
    }
    "Action": "Transition"
    "Driver": {
      "$id": "27"
      "$type": "Redacted.OtherTypeName Redacted.Assembly"
      "Terms": {
        "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
        "$values": [
          {
            "$ref": "5"
          }
        ]
      }
     [....snip...]
    "currentStateRecord": {
      "$id": "4"
      "$type": "Redected.TypeName.StateTypeName Redacted.Assembly"
      "State": 1
      "Terms": {
        "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
        "$values": [
          {
            "$id": "5"
            "Name": "qty"
            "$type": "Redacted.TypeName.SubTypeName Redacted.Assembly"
            "value": 10
          }
        ]
      }
   [...snip...]
   }
}
```</Description>
    <Title_Description>Json serialization, references, wrong ordering Using Json serialization when you have multiple references to the same object usually creates a graph such that the first time an object is encountered it has the properties and an `$id` which identifies that instance. Thereafter in the JSON a `$ref` property is used to identify that pre-defined object and a reference is inserted.

I have a situation where the `$ref` comes _before_ the definition of the object which means that is being deserialized to `null`. 

This is a real headscratcher because I cant reproduce the same problem in isolation using a simpler object graph and JSON.NET. Butmy fairly complex grain state exhibits the problem _every time_.

Has anyone ever experienced this? 

Below is a (snipped) copy of my JSON demonstrating the problem. You'll notice 2 `"$ref" : "5"` that come before the definition of `"$id": "5"`:

```
{
  "$id": "1"
  "$type": "Redacted.GrainSTateTypeName Redacted.GrainAssembly"
  "Block": {
    "$id": "2"
    "$type": "Redacted.TypeName Redacted.Assembly"
    "Terms": {
      "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
      "$values": [
        {
          "$ref": "5"
        }
      ]
    }
    "Action": "Transition"
    "Driver": {
      "$id": "27"
      "$type": "Redacted.OtherTypeName Redacted.Assembly"
      "Terms": {
        "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
        "$values": [
          {
            "$ref": "5"
          }
        ]
      }
     [....snip...]
    "currentStateRecord": {
      "$id": "4"
      "$type": "Redected.TypeName.StateTypeName Redacted.Assembly"
      "State": 1
      "Terms": {
        "$type": "Redacted.TypeName.SubTypeName[] Redacted.Assembly"
        "$values": [
          {
            "$id": "5"
            "Name": "qty"
            "$type": "Redacted.TypeName.SubTypeName Redacted.Assembly"
            "value": 10
          }
        ]
      }
   [...snip...]
   }
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5685</IssueLabelID>
    <Title>Microsoft.Extensions.Hosting.IHostBuilder and Orleans.Hosting.ISiloHostBuilder merge</Title>
    <Description>Microsoft.Extensions.Hosting.IHostBuilder and Orleans.Hosting.ISiloHostBuilder now have many of the same places.
example:
Microsoft.Extensions.Hosting.HostBuilderContext and Orleans.Hosting.HostBuilderContext
Microsoft.Extensions.Hosting.IHostingEnvironment and Orleans.Hosting.IHostingEnvironment

Can these be merged or all use Microsoft.Extensions.Hosting?</Description>
    <Title_Description>Microsoft.Extensions.Hosting.IHostBuilder and Orleans.Hosting.ISiloHostBuilder merge Microsoft.Extensions.Hosting.IHostBuilder and Orleans.Hosting.ISiloHostBuilder now have many of the same places.
example:
Microsoft.Extensions.Hosting.HostBuilderContext and Orleans.Hosting.HostBuilderContext
Microsoft.Extensions.Hosting.IHostingEnvironment and Orleans.Hosting.IHostingEnvironment

Can these be merged or all use Microsoft.Extensions.Hosting?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5683</IssueLabelID>
    <Title>[Question] ClientBuilder and GenericHost</Title>
    <Description>Hello I was looking at new GenericHost sample and it seems now Host and SiloBuilder share same ServiceProvider as (if I am not mistaken) SiloBuilder actually populates Host's service collection. But that is still not true with ClientBuilder. Are there any plans on making ClientBuilder sit on top of generic host as well? I realize there is no need for injection usually in ClientBuilder but still it has ConfigureServices method and thus the question.</Description>
    <Title_Description>[Question] ClientBuilder and GenericHost Hello I was looking at new GenericHost sample and it seems now Host and SiloBuilder share same ServiceProvider as (if I am not mistaken) SiloBuilder actually populates Host's service collection. But that is still not true with ClientBuilder. Are there any plans on making ClientBuilder sit on top of generic host as well? I realize there is no need for injection usually in ClientBuilder but still it has ConfigureServices method and thus the question.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5682</IssueLabelID>
    <Title>Support using shared .NET ThreadPool instead of dedicated thread pool</Title>
    <Description>Orleans currently schedules work onto a dedicated fixed-size thread pool. In some situations it may be preferable to schedule on .NET's ThreadPool instead.

For performance reasons we may want to wait until Orleans is multi-targeted before supporting this. That way we have access to the `ThreadPool.UnsafeQueueUserWorkItem` overload with `preferLocal` the parameter.

Benefits include:
* Thread injection
* Less overhead in co-hosting (i.e Orleans will be a better neighbor)
* Potentially improved data locality &amp; reduced context switches

There are some risks (potential downsides) including potential chance of scheduler starvation.</Description>
    <Title_Description>Support using shared .NET ThreadPool instead of dedicated thread pool Orleans currently schedules work onto a dedicated fixed-size thread pool. In some situations it may be preferable to schedule on .NET's ThreadPool instead.

For performance reasons we may want to wait until Orleans is multi-targeted before supporting this. That way we have access to the `ThreadPool.UnsafeQueueUserWorkItem` overload with `preferLocal` the parameter.

Benefits include:
* Thread injection
* Less overhead in co-hosting (i.e Orleans will be a better neighbor)
* Potentially improved data locality &amp; reduced context switches

There are some risks (potential downsides) including potential chance of scheduler starvation.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5679</IssueLabelID>
    <Title>Create Custom Placement Strategy Sample</Title>
    <Description>This often comes around will be nice to have something to show for it.</Description>
    <Title_Description>Create Custom Placement Strategy Sample This often comes around will be nice to have something to show for it.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5678</IssueLabelID>
    <Title>Code generator fails on empty projects</Title>
    <Description>```
-- Code Generation FAILED --

Exc level 0: System.InvalidOperationException: Compilation has no syntax trees.
   at Orleans.CodeGenerator.CodeGenerator..ctor(Compilation compilation ILogger log) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator\CodeGenerator.cs:line 37
   at Orleans.CodeGenerator.MSBuild.CodeGeneratorCommand.Execute(CancellationToken cancellationToken) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\CodeGeneratorCommand.cs:line 129
   at Microsoft.Orleans.CodeGenerator.MSBuild.Program.SourceToSource(String[] args) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\Program.cs:line 126
   at Microsoft.Orleans.CodeGenerator.MSBuild.Program.Main(String[] args) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\Program.cs:line 16
```

This should probably be handled as you don't want the compilation of solutions to fail if you just added a new project that you've yet to add anything to.</Description>
    <Title_Description>Code generator fails on empty projects ```
-- Code Generation FAILED --

Exc level 0: System.InvalidOperationException: Compilation has no syntax trees.
   at Orleans.CodeGenerator.CodeGenerator..ctor(Compilation compilation ILogger log) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator\CodeGenerator.cs:line 37
   at Orleans.CodeGenerator.MSBuild.CodeGeneratorCommand.Execute(CancellationToken cancellationToken) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\CodeGeneratorCommand.cs:line 129
   at Microsoft.Orleans.CodeGenerator.MSBuild.Program.SourceToSource(String[] args) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\Program.cs:line 126
   at Microsoft.Orleans.CodeGenerator.MSBuild.Program.Main(String[] args) in D:\build\agent\_work\7\s\src\Orleans.CodeGenerator.MSBuild\Program.cs:line 16
```

This should probably be handled as you don't want the compilation of solutions to fail if you just added a new project that you've yet to add anything to.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5676</IssueLabelID>
    <Title>Journaling grain and event sourcing</Title>
    <Description>Hello

First of all I want to give my appreciation to the team and contributors to Orleans it's a great solution for distributed computing. I've been working with it for awhile now and I'm very pleased with both functionality and how nicely it fits with modern architecture and design.

This issue is more about the documentation and somewhat about events with journaled grains in the context of event sourcing. Let me give my observations.

At the heart of event sourcing is the statement that an event signals that a state has changed meaning that any subscriber to the event can rest assure that the state is consistent with the event. The journaled grain however uses the event as to signal that the state should change e.g. with this event persist update to storage.

This is a typical call chain with Orleans.EventSourcing.CustomStorage (never mind the ReadStateFromStorage that might or not happen before the chain described):

1. RaiseEvent tells the provider that an event is to be fired
2. ApplyUpdatesToStorage is called to persist the event to storage
3. Apply (or TransitionState) is called to update aggregate state

As I understand it and see from other event sourcing solutions the chain maybe should be this:

1. ApplyUpdatesToStorage (to change the domain state meaning persist event(s))
2. RaiseEvent tells the provider that domain state has changed
3. Apply (or TransitionState) is called to update aggregate state

It's kind of backwards in the implementation of Orleans with the semantics of events in the context of event sourcing. This initially caused me confusion and I had to try to figure out what was going on before I finally realized the mechanics. I don't propose to do anything rather maybe in the documentation try to highlight if needed the difference.

Kind regards
//Jan
</Description>
    <Title_Description>Journaling grain and event sourcing Hello

First of all I want to give my appreciation to the team and contributors to Orleans it's a great solution for distributed computing. I've been working with it for awhile now and I'm very pleased with both functionality and how nicely it fits with modern architecture and design.

This issue is more about the documentation and somewhat about events with journaled grains in the context of event sourcing. Let me give my observations.

At the heart of event sourcing is the statement that an event signals that a state has changed meaning that any subscriber to the event can rest assure that the state is consistent with the event. The journaled grain however uses the event as to signal that the state should change e.g. with this event persist update to storage.

This is a typical call chain with Orleans.EventSourcing.CustomStorage (never mind the ReadStateFromStorage that might or not happen before the chain described):

1. RaiseEvent tells the provider that an event is to be fired
2. ApplyUpdatesToStorage is called to persist the event to storage
3. Apply (or TransitionState) is called to update aggregate state

As I understand it and see from other event sourcing solutions the chain maybe should be this:

1. ApplyUpdatesToStorage (to change the domain state meaning persist event(s))
2. RaiseEvent tells the provider that domain state has changed
3. Apply (or TransitionState) is called to update aggregate state

It's kind of backwards in the implementation of Orleans with the semantics of events in the context of event sourcing. This initially caused me confusion and I had to try to figure out what was going on before I finally realized the mechanics. I don't propose to do anything rather maybe in the documentation try to highlight if needed the difference.

Kind regards
//Jan
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5674</IssueLabelID>
    <Title>Changes to Orleans runtime to enable building Indexing as a NuGet package</Title>
    <Description>
    </Description>
    <Title_Description>Changes to Orleans runtime to enable building Indexing as a NuGet package </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5672</IssueLabelID>
    <Title>add package ado report service fabric error</Title>
    <Description>1 dotnet add xxx.csproj package Microsoft.Orleans.Persistence.AdoNet

report error:
。。
“C:\Program Files\Microsoft SDKs\Service Fabric\packages” not exists

this library is dependency service fabric sdk ?				
</Description>
    <Title_Description>add package ado report service fabric error 1 dotnet add xxx.csproj package Microsoft.Orleans.Persistence.AdoNet

report error:
。。
“C:\Program Files\Microsoft SDKs\Service Fabric\packages” not exists

this library is dependency service fabric sdk ?				
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5671</IssueLabelID>
    <Title>not support ISiloBuilder.AddIncomingGrainCallFilter </Title>
    <Description>Cannot use the `AddIncomingGrainCallFilter` function when using `Microsoft.Extensions.Hosting`

idea：
1. support `ISiloBuilder.AddIncomingGrainCallFilter `
2. `IServiceCollection.AddIncomingGrainCallFilter`  open public</Description>
    <Title_Description>not support ISiloBuilder.AddIncomingGrainCallFilter  Cannot use the `AddIncomingGrainCallFilter` function when using `Microsoft.Extensions.Hosting`

idea：
1. support `ISiloBuilder.AddIncomingGrainCallFilter `
2. `IServiceCollection.AddIncomingGrainCallFilter`  open public</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5670</IssueLabelID>
    <Title>Interface does not support output parameters?</Title>
    <Description>I want to page through some entities and return the total number that meets the criteria so I defined this interface:
`
Task&lt;List&lt;TestEntity&gt;&gt; GetEntitysByAge(int age int pageindex int pagesize out int total);
`
But compile time error: OrleansCodeGenTestServiceReference Do not implement interface ITestService.Search(int intint out int)

This is the code generated at compile time(X.XX.IService.orleans.g.cs).
global::System.Threading.Tasks.Task&lt;global::System.Collections.Generic.Listglobal::X.XX.XXX.TestEntity&gt; global::X.XX.XXX.ITestService.Search(int age int pageindex int pagesizeint total)
{
return base.InvokeMethodAsync&lt;global::System.Collections.Generic.Listglobal::X.XX.XXX.TestEntity&gt;(unchecked((int)0xBC81583A) new object[]{age  pageindex  pagesize  total});
}
No ‘out’ keyword

What should I do?</Description>
    <Title_Description>Interface does not support output parameters? I want to page through some entities and return the total number that meets the criteria so I defined this interface:
`
Task&lt;List&lt;TestEntity&gt;&gt; GetEntitysByAge(int age int pageindex int pagesize out int total);
`
But compile time error: OrleansCodeGenTestServiceReference Do not implement interface ITestService.Search(int intint out int)

This is the code generated at compile time(X.XX.IService.orleans.g.cs).
global::System.Threading.Tasks.Task&lt;global::System.Collections.Generic.Listglobal::X.XX.XXX.TestEntity&gt; global::X.XX.XXX.ITestService.Search(int age int pageindex int pagesizeint total)
{
return base.InvokeMethodAsync&lt;global::System.Collections.Generic.Listglobal::X.XX.XXX.TestEntity&gt;(unchecked((int)0xBC81583A) new object[]{age  pageindex  pagesize  total});
}
No ‘out’ keyword

What should I do?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5667</IssueLabelID>
    <Title>Remove message retry functionality</Title>
    <Description>It is a bad idea to blindly retry messages that fail to process/deliver. Because of that the default retry count is set to zero. We need to remove this code altogether to simplify the codebase and prevent the potential confusion. We should have done that as part of 2.0 effort.</Description>
    <Title_Description>Remove message retry functionality It is a bad idea to blindly retry messages that fail to process/deliver. Because of that the default retry count is set to zero. We need to remove this code altogether to simplify the codebase and prevent the potential confusion. We should have done that as part of 2.0 effort.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5662</IssueLabelID>
    <Title>Add ConfigureJsonSerializerSettings delegate to storage providers</Title>
    <Description>…pertyHandling to serializer settings</Description>
    <Title_Description>Add ConfigureJsonSerializerSettings delegate to storage providers …pertyHandling to serializer settings</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5660</IssueLabelID>
    <Title>Expected result of type System.Nullable`1[System.Int64] but encountered a null value.</Title>
    <Description>after upgrade to v2.3.3 the grain method return `Nullable&lt;T&gt;` was broken.

https://github.com/mkjeff/orleans/blob/9d67a5c4a27cd9392f5d198b495ac90fa8df6ffb/src/Orleans.Core/Async/TaskExtensions.cs#L118</Description>
    <Title_Description>Expected result of type System.Nullable`1[System.Int64] but encountered a null value. after upgrade to v2.3.3 the grain method return `Nullable&lt;T&gt;` was broken.

https://github.com/mkjeff/orleans/blob/9d67a5c4a27cd9392f5d198b495ac90fa8df6ffb/src/Orleans.Core/Async/TaskExtensions.cs#L118</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5659</IssueLabelID>
    <Title>Reminders with long period invoked before their due time</Title>
    <Description>We've encountered cases of reminders are invoked before their due time.

Log example:
"reminder tickStatus:&lt;1/10/2019 12:00:03 AM 1.00:00:00 5/28/2019 11:59:44 PM&gt;"
&lt;FirstTickTime Period CurrentTickTime&gt;

As you can see the period is daily and the reminder should be invoked at time &gt;= 12:00:03 AM but it was invoked at 11:59:44 PM which is almost 20 seconds before its time.

We've seen this in many cases for reminders with periods of hours (usually a day) or multiple days.

I looked at the reminders code and it seems fine. Internally it uses `System.Threading.Timer`. I've tried to stress it on my local workstation with long period timers but couldn't reproduce this behavior yet.
Though our production environment is Google Cloud VM's and maybe it's related (I'll try to stress there too).
We've validated that all the silo's VM's clocks are synchronized with NTP.

Please consider simple defense mechanism of when the timer invoked to validate 'now' against the expected 'dueTime' and if it was invoked ahead of time then reschedule.

Thanks!</Description>
    <Title_Description>Reminders with long period invoked before their due time We've encountered cases of reminders are invoked before their due time.

Log example:
"reminder tickStatus:&lt;1/10/2019 12:00:03 AM 1.00:00:00 5/28/2019 11:59:44 PM&gt;"
&lt;FirstTickTime Period CurrentTickTime&gt;

As you can see the period is daily and the reminder should be invoked at time &gt;= 12:00:03 AM but it was invoked at 11:59:44 PM which is almost 20 seconds before its time.

We've seen this in many cases for reminders with periods of hours (usually a day) or multiple days.

I looked at the reminders code and it seems fine. Internally it uses `System.Threading.Timer`. I've tried to stress it on my local workstation with long period timers but couldn't reproduce this behavior yet.
Though our production environment is Google Cloud VM's and maybe it's related (I'll try to stress there too).
We've validated that all the silo's VM's clocks are synchronized with NTP.

Please consider simple defense mechanism of when the timer invoked to validate 'now' against the expected 'dueTime' and if it was invoked ahead of time then reschedule.

Thanks!</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5652</IssueLabelID>
    <Title>Skip more intermittently failing tests</Title>
    <Description>EHMultipleSubscriptionTest_AddRemove AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains
SingleSendBatchConsume
StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism
Grain_AzureBlobStore_SiloRestart</Description>
    <Title_Description>Skip more intermittently failing tests EHMultipleSubscriptionTest_AddRemove AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains
SingleSendBatchConsume
StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism
Grain_AzureBlobStore_SiloRestart</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5651</IssueLabelID>
    <Title>Grain_AzureBlobStore_SiloRestart failing intermittently</Title>
    <Description>&gt;Error message
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 20000\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message Request S127.0.0.1:25559:296864291*stg/0/00000000@S00000000-&gt;S127.0.0.1:25559:296864291*grn/FCB3F509/00003039@c732078f #5589[ForwardCount=3]: for 3 times after Non-existent activation to invalid activation. Rejecting now. 
Stack trace
at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__65.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Silo\Silo.cs:line 270
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Hosting.SiloWrapper.&lt;StartAsync&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Hosting\Generic\SiloWrapper.cs:line 36
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.InProcessSiloHandle.&lt;CreateAsync&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 37
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.TestCluster.&lt;StartSiloAsync&gt;d__61.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\TestCluster.cs:line 552
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.TestCluster.&lt;RestartSiloAsync&gt;d__53.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\TestCluster.cs:line 450
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at TestExtensions.Runners.GrainPersistenceTestsRunner.&lt;Grain_GrainStorage_SiloRestart&gt;d__21.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\TestRunners\GrainPersistenceTestRunner.cs:line 311
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.Persistence.PersistenceGrainTests_AzureBlobStore.&lt;Grain_AzureBlobStore_SiloRestart&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceGrainTests_AzureBlobStore.cs:line 139
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous l</Description>
    <Title_Description>Grain_AzureBlobStore_SiloRestart failing intermittently &gt;Error message
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 20000\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message Request S127.0.0.1:25559:296864291*stg/0/00000000@S00000000-&gt;S127.0.0.1:25559:296864291*grn/FCB3F509/00003039@c732078f #5589[ForwardCount=3]: for 3 times after Non-existent activation to invalid activation. Rejecting now. 
Stack trace
at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__65.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Silo\Silo.cs:line 270
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Hosting.SiloWrapper.&lt;StartAsync&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Runtime\Hosting\Generic\SiloWrapper.cs:line 36
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.InProcessSiloHandle.&lt;CreateAsync&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 37
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.TestCluster.&lt;StartSiloAsync&gt;d__61.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\TestCluster.cs:line 552
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.TestCluster.&lt;RestartSiloAsync&gt;d__53.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\TestCluster.cs:line 450
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at TestExtensions.Runners.GrainPersistenceTestsRunner.&lt;Grain_GrainStorage_SiloRestart&gt;d__21.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\TestRunners\GrainPersistenceTestRunner.cs:line 311
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.Persistence.PersistenceGrainTests_AzureBlobStore.&lt;Grain_AzureBlobStore_SiloRestart&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceGrainTests_AzureBlobStore.cs:line 139
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous l</Title_Description>
    <Label>test-issue</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5650</IssueLabelID>
    <Title>StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 29\r\nActual: 27
Stack trace
at Tester.StreamingTests.ProgrammaticSubcribeTestsRunner.&lt;CheckCounters&gt;d__14.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\ProgrammaticSubcribeTestsRunner.cs:line 289
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ProgrammaticSubscribeTests.SubscriptionObserverWithImplicitSubscribingTestRunner.&lt;StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\SubscriptionObserverWithImplicitSubscribingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 29\r\nActual: 27
Stack trace
at Tester.StreamingTests.ProgrammaticSubcribeTestsRunner.&lt;CheckCounters&gt;d__14.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\ProgrammaticSubcribeTestsRunner.cs:line 289
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ProgrammaticSubscribeTests.SubscriptionObserverWithImplicitSubscribingTestRunner.&lt;StreamingTests_Consumer_Producer_SubscribeToTwoStream_MessageWithPolymorphism&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\SubscriptionObserverWithImplicitSubscribingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5649</IssueLabelID>
    <Title>SingleSendBatchConsume test failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 30\r\nActual: 29
Stack trace
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;CheckCounters&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;SingleSendBatchConsume&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 39
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>SingleSendBatchConsume test failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 30\r\nActual: 29
Stack trace
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;CheckCounters&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;SingleSendBatchConsume&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 39
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5648</IssueLabelID>
    <Title>AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 90\r\nActual: 89
Stack trace
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;CheckCounters&gt;d__39.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 473
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;BasicTestAsync&gt;d__37.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 440
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;StreamTest_07_ManyDifferent_ManyProducerClientsManyConsumerGrains&gt;d__22.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 144
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.Streaming.AQStreamingTests.&lt;AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains&gt;d__15.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\TesterAzureUtils\Streaming\AQStreamingTests.cs:line 134
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 90\r\nActual: 89
Stack trace
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;CheckCounters&gt;d__39.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 473
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;BasicTestAsync&gt;d__37.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 440
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SingleStreamTestRunner.&lt;StreamTest_07_ManyDifferent_ManyProducerClientsManyConsumerGrains&gt;d__22.MoveNext() in D:\build\agent\_work\23\s\test\TesterInternal\StreamingTests\SingleStreamTestRunner.cs:line 144
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.Streaming.AQStreamingTests.&lt;AQ_07_ManyDifferent_ManyProducerClientsManyConsumerGrains&gt;d__15.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\TesterAzureUtils\Streaming\AQStreamingTests.cs:line 134
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5647</IssueLabelID>
    <Title>EHMultipleSubscriptionTest_AddRemove failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 9\r\nActual: 3
Stack trace
at UnitTests.StreamingTests.SubscriptionMultiplicityTestRunner.&lt;CheckCounters&gt;d__13.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\SubscriptionMultiplicityTestRunner.cs:line 346
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SubscriptionMultiplicityTestRunner.&lt;MultipleSubscriptionTest_AddRemove&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\SubscriptionMultiplicityTestRunner.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHSubscriptionMultiplicityTests.&lt;EHMultipleSubscriptionTest_AddRemove&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHSubscriptionMultiplicityTests.cs:line 82
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>EHMultipleSubscriptionTest_AddRemove failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 9\r\nActual: 3
Stack trace
at UnitTests.StreamingTests.SubscriptionMultiplicityTestRunner.&lt;CheckCounters&gt;d__13.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\SubscriptionMultiplicityTestRunner.cs:line 346
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.SubscriptionMultiplicityTestRunner.&lt;MultipleSubscriptionTest_AddRemove&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\SubscriptionMultiplicityTestRunner.cs:line 113
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHSubscriptionMultiplicityTests.&lt;EHMultipleSubscriptionTest_AddRemove&gt;d__10.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHSubscriptionMultiplicityTests.cs:line 82
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>30/05/2019 11:32:52 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5645</IssueLabelID>
    <Title>Port Pr 5354 and 5372 to 1.5.8</Title>
    <Description>Please manually compare diff in https://github.com/dotnet/orleans/pull/5354/files
and https://github.com/dotnet/orleans/pull/5372/files
to see if I made the right change</Description>
    <Title_Description>Port Pr 5354 and 5372 to 1.5.8 Please manually compare diff in https://github.com/dotnet/orleans/pull/5354/files
and https://github.com/dotnet/orleans/pull/5372/files
to see if I made the right change</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5643</IssueLabelID>
    <Title>Port Pr 5354 and 5372 to 1.5.8</Title>
    <Description>Please manually compare diff in https://github.com/dotnet/orleans/pull/5354/files
and https://github.com/dotnet/orleans/pull/5372/files
 to see if I made the right change
</Description>
    <Title_Description>Port Pr 5354 and 5372 to 1.5.8 Please manually compare diff in https://github.com/dotnet/orleans/pull/5354/files
and https://github.com/dotnet/orleans/pull/5372/files
 to see if I made the right change
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5642</IssueLabelID>
    <Title>Revert "Rebuild when files are added or removed from a project (#5594)</Title>
    <Description>Revert the build change for now because it is breaking code signing. We'll bring it back in when it works properly with code signing.

This reverts commit 74cdce26cf46afa358c8ce5646fae8c83ccfa1c8.</Description>
    <Title_Description>Revert "Rebuild when files are added or removed from a project (#5594) Revert the build change for now because it is breaking code signing. We'll bring it back in when it works properly with code signing.

This reverts commit 74cdce26cf46afa358c8ce5646fae8c83ccfa1c8.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5641</IssueLabelID>
    <Title>Add null check in MessageCenter.TryDeliverToProxy</Title>
    <Description>
    </Description>
    <Title_Description>Add null check in MessageCenter.TryDeliverToProxy </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5639</IssueLabelID>
    <Title>AQStreamProducerOnDroppedClientTest failing intermittently</Title>
    <Description>&gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Microsoft.WindowsAzure.Storage.StorageException : The remote server returned an error: (409) Conflict.\r\n-------- System.Net.WebException : The remote server returned an error: (409) Conflict.
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at Tester.AzureUtils.Streaming.AQClientStreamTests.Dispose() in D:\build\agent\_work\6\s\test\Extensions\TesterAzureUtils\Streaming\AQClientStreamTests.cs:line 88
at ReflectionAbstractionExtensions.DisposeTestClass(ITest test Object testClass IMessageBus messageBus ExecutionTimer timer CancellationTokenSource cancellationTokenSource)
----- Inner Stack Trace -----
at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result)
at Microsoft.WindowsAzure.Storage.Table.CloudTable.EndCreateIfNotExists(IAsyncResult asyncResult)
at Microsoft.WindowsAzure.Storage.Core.Util.AsyncExtensions.&lt;&gt;c__DisplayClass1`1.&lt;CreateCallback&gt;b__0(IAsyncResult ar)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.&lt;InitTableAsync&gt;d__17.MoveNext() in D:\build\agent\_work\6\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 99
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.TestStreamProviders.TestAzureTableStorageStreamFailureHandler.&lt;DeleteAll&gt;d__5.MoveNext() in D:\build\agent\_work\6\s\test\Tester\TestStreamProviders\TestAzureTableStorageStreamFailureHandler.cs:line 46
----- Inner Stack Trace -----
at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpResponseParsers.TableOperationPreProcess(TableResult result TableOperation operation HttpWebResponse resp Exception ex)
at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult)</Description>
    <Title_Description>AQStreamProducerOnDroppedClientTest failing intermittently &gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Microsoft.WindowsAzure.Storage.StorageException : The remote server returned an error: (409) Conflict.\r\n-------- System.Net.WebException : The remote server returned an error: (409) Conflict.
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at Tester.AzureUtils.Streaming.AQClientStreamTests.Dispose() in D:\build\agent\_work\6\s\test\Extensions\TesterAzureUtils\Streaming\AQClientStreamTests.cs:line 88
at ReflectionAbstractionExtensions.DisposeTestClass(ITest test Object testClass IMessageBus messageBus ExecutionTimer timer CancellationTokenSource cancellationTokenSource)
----- Inner Stack Trace -----
at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result)
at Microsoft.WindowsAzure.Storage.Table.CloudTable.EndCreateIfNotExists(IAsyncResult asyncResult)
at Microsoft.WindowsAzure.Storage.Core.Util.AsyncExtensions.&lt;&gt;c__DisplayClass1`1.&lt;CreateCallback&gt;b__0(IAsyncResult ar)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.&lt;InitTableAsync&gt;d__17.MoveNext() in D:\build\agent\_work\6\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 99
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.TestStreamProviders.TestAzureTableStorageStreamFailureHandler.&lt;DeleteAll&gt;d__5.MoveNext() in D:\build\agent\_work\6\s\test\Tester\TestStreamProviders\TestAzureTableStorageStreamFailureHandler.cs:line 46
----- Inner Stack Trace -----
at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpResponseParsers.TableOperationPreProcess(TableResult result TableOperation operation HttpWebResponse resp Exception ex)
at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5638</IssueLabelID>
    <Title>Recoverable100EventStreamsWith1NonTransientErrorTest failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 4\r\nActual: 12
Stack trace
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;CheckCounters&gt;d__5.MoveNext() in D:\build\agent\_work\6\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 61
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\6\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\6\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;Recoverable100EventStreamsWith1NonTransientError&gt;d__4.MoveNext() in D:\build\agent\_work\6\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 43
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHImplicitSubscriptionStreamRecoveryTests.&lt;Recoverable100EventStreamsWith1NonTransientErrorTest&gt;d__8.MoveNext() in D:\build\agent\_work\6\s\test\Extensions\ServiceBus.Tests\Streaming\EHImplicitSubscriptionStreamRecoveryTests.cs:line 101
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Recoverable100EventStreamsWith1NonTransientErrorTest failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 4\r\nActual: 12
Stack trace
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;CheckCounters&gt;d__5.MoveNext() in D:\build\agent\_work\6\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 61
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\6\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\6\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;Recoverable100EventStreamsWith1NonTransientError&gt;d__4.MoveNext() in D:\build\agent\_work\6\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 43
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHImplicitSubscriptionStreamRecoveryTests.&lt;Recoverable100EventStreamsWith1NonTransientErrorTest&gt;d__8.MoveNext() in D:\build\agent\_work\6\s\test\Extensions\ServiceBus.Tests\Streaming\EHImplicitSubscriptionStreamRecoveryTests.cs:line 101
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/05/2019 2:19:02 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5635</IssueLabelID>
    <Title>StreamingTests_Consumer_Producer_UnSubscribe test failing intermittently</Title>
    <Description>&gt;Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False
Stack trace
at Tester.StreamingTests.ProgrammaticSubcribeTestsRunner.&lt;StreamingTests_Consumer_Producer_UnSubscribe&gt;d__7.MoveNext() in D:\build\agent\_work\25\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\ProgrammaticSubcribeTestsRunner.cs:line 103
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>StreamingTests_Consumer_Producer_UnSubscribe test failing intermittently &gt;Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False
Stack trace
at Tester.StreamingTests.ProgrammaticSubcribeTestsRunner.&lt;StreamingTests_Consumer_Producer_UnSubscribe&gt;d__7.MoveNext() in D:\build\agent\_work\25\s\test\Tester\StreamingTests\ProgrammaticSubscribeTests\ProgrammaticSubcribeTestsRunner.cs:line 103
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/05/2019 7:32:44 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5634</IssueLabelID>
    <Title>EHStreamConsumerOnDroppedClientTest failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 1\r\nActual: 0
Stack trace
at Tester.StreamingTests.ClientStreamTestRunner.&lt;CheckCounters&gt;d__9.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ClientStreamTestRunner.cs:line 150
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ClientStreamTestRunner.&lt;StreamConsumerOnDroppedClientTest&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ClientStreamTestRunner.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHClientStreamTests.&lt;EHStreamConsumerOnDroppedClientTest&gt;d__11.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHClientStreamTests.cs:line 104
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>EHStreamConsumerOnDroppedClientTest failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 1\r\nActual: 0
Stack trace
at Tester.StreamingTests.ClientStreamTestRunner.&lt;CheckCounters&gt;d__9.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ClientStreamTestRunner.cs:line 150
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ClientStreamTestRunner.&lt;StreamConsumerOnDroppedClientTest&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ClientStreamTestRunner.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHClientStreamTests.&lt;EHStreamConsumerOnDroppedClientTest&gt;d__11.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHClientStreamTests.cs:line 104
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/05/2019 7:27:02 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5633</IssueLabelID>
    <Title>Recoverable100EventStreamsWithTransientErrorsTest test failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 100\r\nActual: 99
Stack trace
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;CheckCounters&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 61
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;Recoverable100EventStreamsWithTransientErrors&gt;d__3.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 28
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHImplicitSubscriptionStreamRecoveryTests.&lt;Recoverable100EventStreamsWithTransientErrorsTest&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHImplicitSubscriptionStreamRecoveryTests.cs:line 94
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Recoverable100EventStreamsWithTransientErrorsTest test failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 100\r\nActual: 99
Stack trace
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;CheckCounters&gt;d__5.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 61
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.ImplicitSubscritionRecoverableStreamTestRunner.&lt;Recoverable100EventStreamsWithTransientErrors&gt;d__3.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\ImplicitSubscritionRecoverableStreamTestRunner.cs:line 28
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at ServiceBus.Tests.StreamingTests.EHImplicitSubscriptionStreamRecoveryTests.&lt;Recoverable100EventStreamsWithTransientErrorsTest&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Extensions\ServiceBus.Tests\Streaming\EHImplicitSubscriptionStreamRecoveryTests.cs:line 94
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/05/2019 7:24:04 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5632</IssueLabelID>
    <Title>BatchSendBatchConsume test failing intermittently</Title>
    <Description>&gt;Error message
Assert.Equal() Failure\r\nExpected: 30\r\nActual: 20
Stack trace
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;CheckCounters&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;BatchSendBatchConsume&gt;d__6.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 75
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>BatchSendBatchConsume test failing intermittently &gt;Error message
Assert.Equal() Failure\r\nExpected: 30\r\nActual: 20
Stack trace
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;CheckCounters&gt;d__7.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 84
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 95
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 108
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.StreamingTests.StreamBatchingTestRunner.&lt;BatchSendBatchConsume&gt;d__6.MoveNext() in D:\build\agent\_work\23\s\test\Tester\StreamingTests\StreamBatchingTestRunner.cs:line 75
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>test-issue</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5631</IssueLabelID>
    <Title>Catalog and Directory Grains failing to communicate - Select Activation Timeouts</Title>
    <Description>Hi

We are having issues in our cluster with select activation timeouts between the catalog and directory grains - Issue below.

`System.TimeoutException: Response did not arrive on time in 00:01:00 for message: Request S10.210.0.191:11111:296756057*stg/14/0000000e@S0000000e-&gt;S10.210.1.70:11111:296756073*stg/10/0000000a@S0000000a #14780: . Target History is: &lt;S10.210.1.70:11111:296756073:*stg/10/0000000a:@S0000000a&gt;.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.LookupAsync(GrainId grainId Int32 hopCount)
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.Execute()
   at Orleans.Runtime.Placement.RandomPlacementDirector.OnSelectActivation(PlacementStrategy strategy GrainId target IPlacementRuntime context)
   at Orleans.Runtime.Placement.PlacementDirectorsManager.SelectOrAddActivation(ActivationAddress sendingAddress PlacementTarget targetGrain IPlacementRuntime context PlacementStrategy strategy)
   at Orleans.Runtime.Dispatcher.AddressMessageAsync(Message message PlacementTarget target PlacementStrategy strategy ActivationAddress targetAddress)
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()`

Once this error starts it never recovers and that source silo seems to stop doing much useful work.  We have struggled to nail down when it happens.

Is it possible to move those system grains away from silos that run our grains so we can rule out our interaction with the silo which I am sure it is what we are doing on there

Can you effectively segment the cluster to allow system grains on one half and custom grains on the other ?

Thanks</Description>
    <Title_Description>Catalog and Directory Grains failing to communicate - Select Activation Timeouts Hi

We are having issues in our cluster with select activation timeouts between the catalog and directory grains - Issue below.

`System.TimeoutException: Response did not arrive on time in 00:01:00 for message: Request S10.210.0.191:11111:296756057*stg/14/0000000e@S0000000e-&gt;S10.210.1.70:11111:296756073*stg/10/0000000a@S0000000a #14780: . Target History is: &lt;S10.210.1.70:11111:296756073:*stg/10/0000000a:@S0000000a&gt;.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.LookupAsync(GrainId grainId Int32 hopCount)
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.Execute()
   at Orleans.Runtime.Placement.RandomPlacementDirector.OnSelectActivation(PlacementStrategy strategy GrainId target IPlacementRuntime context)
   at Orleans.Runtime.Placement.PlacementDirectorsManager.SelectOrAddActivation(ActivationAddress sendingAddress PlacementTarget targetGrain IPlacementRuntime context PlacementStrategy strategy)
   at Orleans.Runtime.Dispatcher.AddressMessageAsync(Message message PlacementTarget target PlacementStrategy strategy ActivationAddress targetAddress)
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()`

Once this error starts it never recovers and that source silo seems to stop doing much useful work.  We have struggled to nail down when it happens.

Is it possible to move those system grains away from silos that run our grains so we can rule out our interaction with the silo which I am sure it is what we are doing on there

Can you effectively segment the cluster to allow system grains on one half and custom grains on the other ?

Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5630</IssueLabelID>
    <Title>[Question] Deadlock in streams handling</Title>
    <Description>Hello 

I am trying to implement some kind of RPC using Orleans 2.0 streams.

In grain method grain awaits publishing to CommandStream and then observes response from CommandResponseStream awaiting the result 

remote service (another process) observes incoming command from CommandStream and then handles the command and awaits publishing result back to CommandResponseStream.

Looks like this setup gets deadlocked somehow in the internals of Orleans after remote service handles the command and publishes the response. I assume due to custom scheduler used. As if I mark the grain as `[Reentrant]` everything works as expected looks like [Reentrancy within a call chain](https://dotnet.github.io/orleans/Documentation/grains/reentrancy.html#reentrancy-within-a-call-chain) does not work in this case. Maybe it would if instead of two streams I had used GrainObserver + CommandResponseStream.

So for now the only workaround I see is to use predicate to control reentrancy as in general I do not want my code to be reentrant but is that the right way of implementing such calls? 

Thanks in advance.</Description>
    <Title_Description>[Question] Deadlock in streams handling Hello 

I am trying to implement some kind of RPC using Orleans 2.0 streams.

In grain method grain awaits publishing to CommandStream and then observes response from CommandResponseStream awaiting the result 

remote service (another process) observes incoming command from CommandStream and then handles the command and awaits publishing result back to CommandResponseStream.

Looks like this setup gets deadlocked somehow in the internals of Orleans after remote service handles the command and publishes the response. I assume due to custom scheduler used. As if I mark the grain as `[Reentrant]` everything works as expected looks like [Reentrancy within a call chain](https://dotnet.github.io/orleans/Documentation/grains/reentrancy.html#reentrancy-within-a-call-chain) does not work in this case. Maybe it would if instead of two streams I had used GrainObserver + CommandResponseStream.

So for now the only workaround I see is to use predicate to control reentrancy as in general I do not want my code to be reentrant but is that the right way of implementing such calls? 

Thanks in advance.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5629</IssueLabelID>
    <Title>[Question] EventHub stream not all consumers receiving events instantly</Title>
    <Description>We have a stream per order with some (10+) consumers all marked with ImplicitStreamSubscription attribute. Sometimes we see in logs that after event were sent to stream only few consumers receive it instantly. Others are hung until next event comes.
Something like this:

13:07:02.251 event 'First' sent to stream
13:07:02.258 event 'First' received by Grain**A**
...
13:32:23.054 event 'Second' sent to stream
13:32:23.200 event 'First' received by Grain**B**
13:32:23.200 event 'Second' received by Grain**A**
13:32:23.283 event 'Second' received by Grain**B**

So **25 minutes** passed since GrainA received event from stream without any impact on GrainB. And only when new event (Second) was sent - GrainB was triggered and received both these events.
How could that happen? That's not a throttling because event's message already read from stream provider parsed but delivered only to one of consumers.
The confusing part here is that 'Second' event is delivered to GrainA **same millisecond** as 'First' delivered to GrainB. Like if GranB were to trigger for 'Second' event but found 'First' in queue ahead forgotten for some reason and triggered now by FIFO principle.
Logs shows that grains are instatiated on different silos. GrainA lives on same silo where producer ran.
</Description>
    <Title_Description>[Question] EventHub stream not all consumers receiving events instantly We have a stream per order with some (10+) consumers all marked with ImplicitStreamSubscription attribute. Sometimes we see in logs that after event were sent to stream only few consumers receive it instantly. Others are hung until next event comes.
Something like this:

13:07:02.251 event 'First' sent to stream
13:07:02.258 event 'First' received by Grain**A**
...
13:32:23.054 event 'Second' sent to stream
13:32:23.200 event 'First' received by Grain**B**
13:32:23.200 event 'Second' received by Grain**A**
13:32:23.283 event 'Second' received by Grain**B**

So **25 minutes** passed since GrainA received event from stream without any impact on GrainB. And only when new event (Second) was sent - GrainB was triggered and received both these events.
How could that happen? That's not a throttling because event's message already read from stream provider parsed but delivered only to one of consumers.
The confusing part here is that 'Second' event is delivered to GrainA **same millisecond** as 'First' delivered to GrainB. Like if GranB were to trigger for 'Second' event but found 'First' in queue ahead forgotten for some reason and triggered now by FIFO principle.
Logs shows that grains are instatiated on different silos. GrainA lives on same silo where producer ran.
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5628</IssueLabelID>
    <Title>[QUESTION] How to marshal a task into an ActivationTaskScheduler context</Title>
    <Description>Version: Orleans 1.5.3

I have some code that runs inside a silo but not in Orleans task scheduler (`ActivationTaskScheduler`). In order to access the grain factory and call a grain's method code must be executed in context of the Orleans task scheduler otherwise an exception is thrown.

I did the following to switch to Orleans task scheduler context:

In a bootstrap provider I write `TaskScheduler.Current` and the `providerRuntime.GrainFactory` into static variables (`MyBootstrapProvider.GrainFactory` and `MyBootstrapProvider.OrleansScheduler`).

From the code which is running on thread pool taskscheduler (default) I marshal into the Orleans task scheduler context with the following code:

```csharp
var result = await await Task.Factory.StartNew(() =&gt;
  MyBootstrapProvider.GrainFactory.GetGrain&lt;IMyGrain&gt;(0).MyGrainMethod()
  CancellationToken.None TaskCreationOptions.None MyBootstrapProvider.OrleansScheduler);
```

This works okay. But I figured that Orleans creates more than one `ActivationTaskScheduler` instance not a singleton. So my questions are:

- Is my code okay in all circumstances? It uses one single task scheduler which has been saved from the bootstrap provider.

- Is `GrainFactory` a singleton? Is it okay to save it from the bootstrap provider and use it later?

What about Orleans 2.x? Will this work there too? (I know the bootstrap provider stuff has been replaced with a different architecture.)

Or the other way round: What is the best way to get back into Orleans context from code which runs outside of it?</Description>
    <Title_Description>[QUESTION] How to marshal a task into an ActivationTaskScheduler context Version: Orleans 1.5.3

I have some code that runs inside a silo but not in Orleans task scheduler (`ActivationTaskScheduler`). In order to access the grain factory and call a grain's method code must be executed in context of the Orleans task scheduler otherwise an exception is thrown.

I did the following to switch to Orleans task scheduler context:

In a bootstrap provider I write `TaskScheduler.Current` and the `providerRuntime.GrainFactory` into static variables (`MyBootstrapProvider.GrainFactory` and `MyBootstrapProvider.OrleansScheduler`).

From the code which is running on thread pool taskscheduler (default) I marshal into the Orleans task scheduler context with the following code:

```csharp
var result = await await Task.Factory.StartNew(() =&gt;
  MyBootstrapProvider.GrainFactory.GetGrain&lt;IMyGrain&gt;(0).MyGrainMethod()
  CancellationToken.None TaskCreationOptions.None MyBootstrapProvider.OrleansScheduler);
```

This works okay. But I figured that Orleans creates more than one `ActivationTaskScheduler` instance not a singleton. So my questions are:

- Is my code okay in all circumstances? It uses one single task scheduler which has been saved from the bootstrap provider.

- Is `GrainFactory` a singleton? Is it okay to save it from the bootstrap provider and use it later?

What about Orleans 2.x? Will this work there too? (I know the bootstrap provider stuff has been replaced with a different architecture.)

Or the other way round: What is the best way to get back into Orleans context from code which runs outside of it?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5627</IssueLabelID>
    <Title>GrainMethodInvoker.GetMethodEntry can throw InvalidOperationException</Title>
    <Description>The dashboard uses a grain call filter which tries to grab the name of the method being invoked. It does this by calling `IIncomingGrainCallContext.ImplementationMethod` which concretely calls `GrainMethodInvoker.GetMethodEntry`. For certain grain calls that we have this results in an `InvalidOperationException`.

I'm pretty sure this is the result of the particular grain structure we have...
The method being invoked is `IMessageHandler.HandleMessage(IMessage message ...)`
Hierarchy:
```csharp
interface IMessageHandler : IGrainWithIntegerKey
{
    HandleMessage(IMessage message ...)
}

interface IMessageHandler&lt;in T&gt; : IMessageHandler where T : IMessage
{
    HandleMessage(T message ...)
}

abstract class BaseMessageHandler&lt;T&gt; : Grain IMessageHandler&lt;T&gt; where T : IMessage
{
    HandleMessage(IMessage message ...)
    {
        if (message is T typedMessage) return HandleMessage(typedMessage ...);
    }

    abstract HandleMessage(T message ...)
}

class AThingHandler : BaseMessageHandler&lt;AThing&gt;
{
    override HandleMessage(AThing message ...){...}
}

```

Partial trace
```csharp
System.InvalidOperationException: Type Server.Grains.Handlers.AThingHandler does not implement interface with id -1767514446 (96A5DEB2).
   at Orleans.InterfaceToImplementationMappingCache.GetOrCreate(Type implementationType Int32 interfaceId) in D:\build\agent\_work\12\s\src\Orleans.Core\Core\InterfaceToImplementationMappingCache.cs:line 56
   at Orleans.Runtime.GrainMethodInvoker.GetMethodEntry() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 124
   at Orleans.Runtime.GrainMethodInvoker.get_ImplementationMethod() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 52
```

And from type mapping
```
Server.Grains.Handlers.BaseMessageHandler&lt;T&gt; [-1425476372 (0xAB08F4EC)] from ServerGrains.dll implementing interfaces: Server.Grains.IMessageHandler&lt;T&gt; [-1767514446 (0x96A5DEB2)] Server.Grains.IMessageHandler [896328416 (0x356CE2E0)]

Grain class Server.Grains.Handlers.Server.Grains.Handlers.AThingHandler [175942383 (0xA7CAAEF)] from ServerGrains.dll implementing interfaces: Server.Grains.IMessageHandler&lt;AThing&gt; [
354762693 (0x15253FC5)] Server.Grains.IMessageHandler [896328416 (0x356CE2E0)]
```</Description>
    <Title_Description>GrainMethodInvoker.GetMethodEntry can throw InvalidOperationException The dashboard uses a grain call filter which tries to grab the name of the method being invoked. It does this by calling `IIncomingGrainCallContext.ImplementationMethod` which concretely calls `GrainMethodInvoker.GetMethodEntry`. For certain grain calls that we have this results in an `InvalidOperationException`.

I'm pretty sure this is the result of the particular grain structure we have...
The method being invoked is `IMessageHandler.HandleMessage(IMessage message ...)`
Hierarchy:
```csharp
interface IMessageHandler : IGrainWithIntegerKey
{
    HandleMessage(IMessage message ...)
}

interface IMessageHandler&lt;in T&gt; : IMessageHandler where T : IMessage
{
    HandleMessage(T message ...)
}

abstract class BaseMessageHandler&lt;T&gt; : Grain IMessageHandler&lt;T&gt; where T : IMessage
{
    HandleMessage(IMessage message ...)
    {
        if (message is T typedMessage) return HandleMessage(typedMessage ...);
    }

    abstract HandleMessage(T message ...)
}

class AThingHandler : BaseMessageHandler&lt;AThing&gt;
{
    override HandleMessage(AThing message ...){...}
}

```

Partial trace
```csharp
System.InvalidOperationException: Type Server.Grains.Handlers.AThingHandler does not implement interface with id -1767514446 (96A5DEB2).
   at Orleans.InterfaceToImplementationMappingCache.GetOrCreate(Type implementationType Int32 interfaceId) in D:\build\agent\_work\12\s\src\Orleans.Core\Core\InterfaceToImplementationMappingCache.cs:line 56
   at Orleans.Runtime.GrainMethodInvoker.GetMethodEntry() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 124
   at Orleans.Runtime.GrainMethodInvoker.get_ImplementationMethod() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 52
```

And from type mapping
```
Server.Grains.Handlers.BaseMessageHandler&lt;T&gt; [-1425476372 (0xAB08F4EC)] from ServerGrains.dll implementing interfaces: Server.Grains.IMessageHandler&lt;T&gt; [-1767514446 (0x96A5DEB2)] Server.Grains.IMessageHandler [896328416 (0x356CE2E0)]

Grain class Server.Grains.Handlers.Server.Grains.Handlers.AThingHandler [175942383 (0xA7CAAEF)] from ServerGrains.dll implementing interfaces: Server.Grains.IMessageHandler&lt;AThing&gt; [
354762693 (0x15253FC5)] Server.Grains.IMessageHandler [896328416 (0x356CE2E0)]
```</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5626</IssueLabelID>
    <Title>Unit Testing Sample</Title>
    <Description>This is a new unit testing sample showcasing ways to mock Orleans services.</Description>
    <Title_Description>Unit Testing Sample This is a new unit testing sample showcasing ways to mock Orleans services.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5625</IssueLabelID>
    <Title>Performance issues using Streams as backchannels to Frontend Servers</Title>
    <Description>We are currently load testing our Orleans cluster and are experiencing some performance issues with streams. The general architecture is split into three major components: Mobile Clients Frontend Servers and Silohosts.

Mobile clients connect to Frontend Servers with a TCP socket. Each client has one PlayerGrain in the Silohost containing the state of the player. Each player may belong to up to one Guild which are represented by a GuildGrain. Once a Mobile Client opens a TCP connection to Frontend a PlayerConnection object is created in the FrontEnd which then calls SubscribeAsync on a stream (SimpleMessageStreamProvider) in the Player namespace and a stream in the Guild namespace. These streams are then used by PlayerGrains and GuildGrains to push data to the mobile clients. Once the PlayerConnection object is disposed we call Unsubscribe with the stream handles.

In the load test we are creating mock mobile clients that register a new player join a guild and start sending chat messages every ~5 seconds. When the guild grain receives the message it pushes it down to the guild stream and all subscribed PlayerConnections push it down to the mobile clients via the TCP socket. 

The weird behaviour is exhibited when we change the number of players per guild between 30 and 10 players. The performance of the Silohost drops drastically (approximately a 50% drop in concurrently online player capability) if we increase the players per guild to 30. The only effect this has is that now each chat message is sent 3x as many subscribers on the FrontEnd all other variables should be the same. The FrontEndServer's performance doesn't seem to suffer much. 

Is this possibly caused by the fact that the FrontEndServer has 10 (or 30) separate subscriptions to the same Guild stream and if so how can it be shared without building some kind of a Hub that holds the subscriptions? Also what is worrying is if sharing the subscriptions is the answer then at a very large scale when players in a guild are load balanced to different FrontEndServers the I assume the problem will reappear.

One other performance-related issue we've seen with streams is in scenarios where a large number of PlayerGrains are deactivated (around 600 or so) we can see very large latencies (~300ms) for the UnregisterProducer method in the Dashboard causing massive CPU spikes in the Silohost.

Do any of these symptoms sound like we have somehow incorrectly implemented streams and/or is there any specific diagnostic data we could provide to help investigate?</Description>
    <Title_Description>Performance issues using Streams as backchannels to Frontend Servers We are currently load testing our Orleans cluster and are experiencing some performance issues with streams. The general architecture is split into three major components: Mobile Clients Frontend Servers and Silohosts.

Mobile clients connect to Frontend Servers with a TCP socket. Each client has one PlayerGrain in the Silohost containing the state of the player. Each player may belong to up to one Guild which are represented by a GuildGrain. Once a Mobile Client opens a TCP connection to Frontend a PlayerConnection object is created in the FrontEnd which then calls SubscribeAsync on a stream (SimpleMessageStreamProvider) in the Player namespace and a stream in the Guild namespace. These streams are then used by PlayerGrains and GuildGrains to push data to the mobile clients. Once the PlayerConnection object is disposed we call Unsubscribe with the stream handles.

In the load test we are creating mock mobile clients that register a new player join a guild and start sending chat messages every ~5 seconds. When the guild grain receives the message it pushes it down to the guild stream and all subscribed PlayerConnections push it down to the mobile clients via the TCP socket. 

The weird behaviour is exhibited when we change the number of players per guild between 30 and 10 players. The performance of the Silohost drops drastically (approximately a 50% drop in concurrently online player capability) if we increase the players per guild to 30. The only effect this has is that now each chat message is sent 3x as many subscribers on the FrontEnd all other variables should be the same. The FrontEndServer's performance doesn't seem to suffer much. 

Is this possibly caused by the fact that the FrontEndServer has 10 (or 30) separate subscriptions to the same Guild stream and if so how can it be shared without building some kind of a Hub that holds the subscriptions? Also what is worrying is if sharing the subscriptions is the answer then at a very large scale when players in a guild are load balanced to different FrontEndServers the I assume the problem will reappear.

One other performance-related issue we've seen with streams is in scenarios where a large number of PlayerGrains are deactivated (around 600 or so) we can see very large latencies (~300ms) for the UnregisterProducer method in the Dashboard causing massive CPU spikes in the Silohost.

Do any of these symptoms sound like we have somehow incorrectly implemented streams and/or is there any specific diagnostic data we could provide to help investigate?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5624</IssueLabelID>
    <Title>NullReferenceException in SafeTimer</Title>
    <Description>Hi

this is a support request because i feel a little bit stupid right now.

From time to time I get a lof of exceptions like this:

```
"exception": {
	"type": "System.NullReferenceException"
	"message": "Object reference not set to an instance of an object."
	"stackTrace": "   at Orleans.Runtime.InsideRuntimeClient.OnCallbackExpiryTick(Object state)\n   at Orleans.Runtime.SafeTimerBase.HandleSyncTimerCallback(Object state)"
}
```

Which is strange because...

1. I have disabled the logs for this category: https://github.com/Squidex/squidex/blob/master/src/Squidex/Config/Logging.cs#L26

2. I don't see how it can happen because there is nothing in your code and this stack trace that could be null.

Usually everything works fine and I just restart the node to get rid of the log entries but I have no idea how it can happen.</Description>
    <Title_Description>NullReferenceException in SafeTimer Hi

this is a support request because i feel a little bit stupid right now.

From time to time I get a lof of exceptions like this:

```
"exception": {
	"type": "System.NullReferenceException"
	"message": "Object reference not set to an instance of an object."
	"stackTrace": "   at Orleans.Runtime.InsideRuntimeClient.OnCallbackExpiryTick(Object state)\n   at Orleans.Runtime.SafeTimerBase.HandleSyncTimerCallback(Object state)"
}
```

Which is strange because...

1. I have disabled the logs for this category: https://github.com/Squidex/squidex/blob/master/src/Squidex/Config/Logging.cs#L26

2. I don't see how it can happen because there is nothing in your code and this stack trace that could be null.

Usually everything works fine and I just restart the node to get rid of the log entries but I have no idea how it can happen.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5623</IssueLabelID>
    <Title>How to implement Property Injection</Title>
    <Description>according to the autofac documentation the configuration of property injection has been done but I find that property injection does not work. Is it something I missed? can you tell me how to implement it?</Description>
    <Title_Description>How to implement Property Injection according to the autofac documentation the configuration of property injection has been done but I find that property injection does not work. Is it something I missed? can you tell me how to implement it?</Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5622</IssueLabelID>
    <Title>LinuxEnvironmentStatistics Couldn't read 'MemAvailable' line from '/proc/meminfo'</Title>
    <Description>when use UseLinuxEnvironmentStatistics  get a Warn **Couldn't read 'MemAvailable' line from '/proc/meminfo'**
run command  `cat /proc/meminfo | grep MemAvailable`，get `MemAvailable:    2587936 kB`

OS:  ubuntu 1804
OrleansVersion: 2.3.2

</Description>
    <Title_Description>LinuxEnvironmentStatistics Couldn't read 'MemAvailable' line from '/proc/meminfo' when use UseLinuxEnvironmentStatistics  get a Warn **Couldn't read 'MemAvailable' line from '/proc/meminfo'**
run command  `cat /proc/meminfo | grep MemAvailable`，get `MemAvailable:    2587936 kB`

OS:  ubuntu 1804
OrleansVersion: 2.3.2

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5621</IssueLabelID>
    <Title>Apply Dashboard Custom Profiling to the Reactive Caching Sample</Title>
    <Description>Apply https://github.com/OrleansContrib/OrleansDashboard/pull/228 (see https://github.com/OrleansContrib/OrleansDashboard/issues/227) to the Reactive Caching Sample to demonstrate how to fix inflated metrics from reactive poll methods. To do upon the next release of the Dashboard. Feel free to assign this to me.</Description>
    <Title_Description>Apply Dashboard Custom Profiling to the Reactive Caching Sample Apply https://github.com/OrleansContrib/OrleansDashboard/pull/228 (see https://github.com/OrleansContrib/OrleansDashboard/issues/227) to the Reactive Caching Sample to demonstrate how to fix inflated metrics from reactive poll methods. To do upon the next release of the Dashboard. Feel free to assign this to me.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5620</IssueLabelID>
    <Title>Cannot connect client to remote silo hosted on Windows Azure VM using Azure table membership</Title>
    <Description>Hi all 
just trying to figure out how to configure correctly silo membership using Azure tables on an Azure hosted VM which has a public ip (the one used for the membership) and ports 11111 and 30000 opened on the Azure Firewall... I verified that I'm able to access that IP from outside and also see Dashboard published on the default port 8080 but not able to connect the client to the cluster since the silo seems to be registered correctly on the Azure Table since has the correct IP and is marked as 'Active' can you help me to understand what's wrong? 

Here's the client log: 
`
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on WIN-9E3M0JHUQ6J at 10.0.2.15 Client Id = *cli/5afa9bbe ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.3.2. Commit Hash: 9d67a5c4a27cd9392f5d198b495ac90fa8df6ffb (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=DevelopmentClient&gt;
info: Orleans.Clustering.AzureStorage.AzureTableDataManager[100801]
      Attached to Azure storage table OrleansSiloInstances
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://13.68.143.198:30000/296061839]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:24
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:29
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:34
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 2 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:43
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:48
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 3 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:57
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:02
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 4 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:11
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:16
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:24
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 5 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:25
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 6 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:39
Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 283
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 260
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 201
   at Orleans.ClusterClient.Connect(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Core\ClusterClient.cs:line 120
   at DevelopmentClient.Program.Main(String[] args) in C:\QueueMatchingAPI\Cluster\Environment\DevelopmentClient\Program.cs:line 36`

Here's the Silo implementation: 
`  
      static Task Main(string[] args)
        {
            return new HostBuilder()
                .UseOrleans(builder =&gt;
                {
                    //TODO: use UseAdoNetClustering ?
                    builder.Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "prod"; // Can change based on deployments
                        options.ServiceId = "MatchingApp"; // Must remail stable
                    })
                    .Configure&lt;EndpointOptions&gt;(options =&gt;
                    {
                        // Port to use for Silo-to-Silo
                        options.SiloPort = 11111;
                        // Port to use for the gateway
                        options.GatewayPort = 30000;
                        // IP Address to advertise in the cluster
                        options.AdvertisedIPAddress = IPAddress.Parse("13.68.143.198");
                        // The socket used for silo-to-silo will bind to this endpoint
                        options.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any 40000);
                        // The socket used by the gateway will bind to this endpoint
                        options.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any 50000);
                    })

                    .UseInMemoryReminderService() // reminders storage    
                    .UseAzureStorageClustering(options =&gt; options.ConnectionString = AzureStorageClusteringConnectionString)
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ServiceBusManagerImplementation).Assembly).WithReferences())
                    .UseDashboard();
                })
                .ConfigureLogging(builder =&gt;
                {
                    builder.SetMinimumLevel(LogLevel.Warning).AddConsole();
                })
                .ConfigureServices(services =&gt;
                {
                    services.AddDbContext&lt;CloudQueueMatchingContext&gt;(options =&gt; options.UseSqlServer(CloudQueueMatchingConnectionString) 
                        contextLifetime:ServiceLifetime.Transient optionsLifetime: ServiceLifetime.Singleton);

                    services.AddDbContext&lt;dciColorDBContext&gt;(options =&gt; options.UseSqlServer(ColorDBConnectionString)
                        contextLifetime: ServiceLifetime.Transient optionsLifetime: ServiceLifetime.Singleton);

                    services.AddTransient&lt;PigmentDatabaseService&gt;();
                })
                .RunConsoleAsync();
        }`

And the client one: 

` 
       static async Task&lt;int&gt; Main(string[] args)
        {
            try
            {
               var client = new ClientBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "prod"; // Can change based on deployments
                        options.ServiceId = "MatchingApp"; // Must remail stable
                    })
                    .UseAzureStorageClustering(options =&gt; options.ConnectionString = AzureStorageClusteringConnectionString)
                    .ConfigureLogging(logging =&gt; logging.AddConsole())
                    .Build();

                await client.Connect(CreateRetryFilter());

                Console.WriteLine("Client successfully connect to silo host");

                ICloudQueueManager cloudQueueManager = client.GetGrain&lt;ICloudQueueManager&gt;(Guid.Empty);
                var combinedQueues = await cloudQueueManager.GetCloudQueuesAsync();

                var cloudQueue = combinedQueues.First();

                await cloudQueueManager.StartCloudQueue(cloudQueue.Id);              
                await Task.Delay(TimeSpan.FromMinutes(1));
                await cloudQueueManager.PauseCloudQueue(cloudQueue.Id);

                Console.ReadKey();
                return 0;
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                Console.ReadKey();
                return 1;
            }
        }
`


Orleans version used is 2.3.2 running on .net core 2.2</Description>
    <Title_Description>Cannot connect client to remote silo hosted on Windows Azure VM using Azure table membership Hi all 
just trying to figure out how to configure correctly silo membership using Azure tables on an Azure hosted VM which has a public ip (the one used for the membership) and ports 11111 and 30000 opened on the Azure Firewall... I verified that I'm able to access that IP from outside and also see Dashboard published on the default port 8080 but not able to connect the client to the cluster since the silo seems to be registered correctly on the Azure Table since has the correct IP and is marked as 'Active' can you help me to understand what's wrong? 

Here's the client log: 
`
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on WIN-9E3M0JHUQ6J at 10.0.2.15 Client Id = *cli/5afa9bbe ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.3.2. Commit Hash: 9d67a5c4a27cd9392f5d198b495ac90fa8df6ffb (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=DevelopmentClient&gt;
info: Orleans.Clustering.AzureStorage.AzureTableDataManager[100801]
      Attached to Azure storage table OrleansSiloInstances
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://13.68.143.198:30000/296061839]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:24
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:29
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:34
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 2 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:43
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:48
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 3 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:28:57
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:02
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 4 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:11
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:16
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:24
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 5 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:25
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 0 (Exception: Connection to 13.68.143.198:30000 could not be established in 00:00:05)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100178]
      Unable to connect to gateway at address gwy.tcp://13.68.143.198:30000/296061839 on trial 1 (Exception: Could not connect to 13.68.143.198:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100913]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Disconnected
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://13.68.143.198:30000/296061839[100912]
      Marking gateway at address gwy.tcp://13.68.143.198:30000/296061839 as Dead in my client local gateway list.
Cluster client attempt 6 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
info: Orleans.AzureUtils.OrleansSiloInstanceManager[100278]
      Found 1 active Gateway Silos for deployment prod.
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://13.68.143.198:30000/296061839]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://13.68.143.198:30000/296061839]. Previous refresh time was = 05/20/2019 15:29:39
Orleans.Runtime.OrleansMessageRejectionException: Target silo S13.68.143.198:30000:296061839 is unavailable
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.OutsideRuntimeClient.&lt;&gt;c__DisplayClass56_0.&lt;&lt;StartInternal&gt;b__2&gt;d.MoveNext() in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 257
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 277
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries|56_3(Func`1 task Func`2 shouldRetry) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 283
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 260
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 201
   at Orleans.ClusterClient.Connect(Func`2 retryFilter) in D:\build\agent\_work\23\s\src\Orleans.Core\Core\ClusterClient.cs:line 120
   at DevelopmentClient.Program.Main(String[] args) in C:\QueueMatchingAPI\Cluster\Environment\DevelopmentClient\Program.cs:line 36`

Here's the Silo implementation: 
`  
      static Task Main(string[] args)
        {
            return new HostBuilder()
                .UseOrleans(builder =&gt;
                {
                    //TODO: use UseAdoNetClustering ?
                    builder.Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "prod"; // Can change based on deployments
                        options.ServiceId = "MatchingApp"; // Must remail stable
                    })
                    .Configure&lt;EndpointOptions&gt;(options =&gt;
                    {
                        // Port to use for Silo-to-Silo
                        options.SiloPort = 11111;
                        // Port to use for the gateway
                        options.GatewayPort = 30000;
                        // IP Address to advertise in the cluster
                        options.AdvertisedIPAddress = IPAddress.Parse("13.68.143.198");
                        // The socket used for silo-to-silo will bind to this endpoint
                        options.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any 40000);
                        // The socket used by the gateway will bind to this endpoint
                        options.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any 50000);
                    })

                    .UseInMemoryReminderService() // reminders storage    
                    .UseAzureStorageClustering(options =&gt; options.ConnectionString = AzureStorageClusteringConnectionString)
                    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ServiceBusManagerImplementation).Assembly).WithReferences())
                    .UseDashboard();
                })
                .ConfigureLogging(builder =&gt;
                {
                    builder.SetMinimumLevel(LogLevel.Warning).AddConsole();
                })
                .ConfigureServices(services =&gt;
                {
                    services.AddDbContext&lt;CloudQueueMatchingContext&gt;(options =&gt; options.UseSqlServer(CloudQueueMatchingConnectionString) 
                        contextLifetime:ServiceLifetime.Transient optionsLifetime: ServiceLifetime.Singleton);

                    services.AddDbContext&lt;dciColorDBContext&gt;(options =&gt; options.UseSqlServer(ColorDBConnectionString)
                        contextLifetime: ServiceLifetime.Transient optionsLifetime: ServiceLifetime.Singleton);

                    services.AddTransient&lt;PigmentDatabaseService&gt;();
                })
                .RunConsoleAsync();
        }`

And the client one: 

` 
       static async Task&lt;int&gt; Main(string[] args)
        {
            try
            {
               var client = new ClientBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "prod"; // Can change based on deployments
                        options.ServiceId = "MatchingApp"; // Must remail stable
                    })
                    .UseAzureStorageClustering(options =&gt; options.ConnectionString = AzureStorageClusteringConnectionString)
                    .ConfigureLogging(logging =&gt; logging.AddConsole())
                    .Build();

                await client.Connect(CreateRetryFilter());

                Console.WriteLine("Client successfully connect to silo host");

                ICloudQueueManager cloudQueueManager = client.GetGrain&lt;ICloudQueueManager&gt;(Guid.Empty);
                var combinedQueues = await cloudQueueManager.GetCloudQueuesAsync();

                var cloudQueue = combinedQueues.First();

                await cloudQueueManager.StartCloudQueue(cloudQueue.Id);              
                await Task.Delay(TimeSpan.FromMinutes(1));
                await cloudQueueManager.PauseCloudQueue(cloudQueue.Id);

                Console.ReadKey();
                return 0;
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                Console.ReadKey();
                return 1;
            }
        }
`


Orleans version used is 2.3.2 running on .net core 2.2</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5619</IssueLabelID>
    <Title>Create GrainReferenceKeyInfo</Title>
    <Description>Create new type GrainReferenceKeyInfo and methods for getting key info from a GrainReference and getting a GrainReference form the key info. This enables serializers not part of orleans to serialize/deserialize GrainReferences into more space compact representations than the GetKeyString() format.

Resolves #3810.</Description>
    <Title_Description>Create GrainReferenceKeyInfo Create new type GrainReferenceKeyInfo and methods for getting key info from a GrainReference and getting a GrainReference form the key info. This enables serializers not part of orleans to serialize/deserialize GrainReferences into more space compact representations than the GetKeyString() format.

Resolves #3810.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5617</IssueLabelID>
    <Title>Add fluent support to TestClusterBuilder</Title>
    <Description>The TestClusterBuilder should support fluent method chaining so we can do the following

```
return new TestClusterBuilder()
    .AddClientBuilderConfigurator&lt;TestClientBuilderConfigurator&gt;
    .AddSiloBuilderConfigurator&lt;TestSiloBuilderConfigurator&gt;()
    .Build();
```
</Description>
    <Title_Description>Add fluent support to TestClusterBuilder The TestClusterBuilder should support fluent method chaining so we can do the following

```
return new TestClusterBuilder()
    .AddClientBuilderConfigurator&lt;TestClientBuilderConfigurator&gt;
    .AddSiloBuilderConfigurator&lt;TestSiloBuilderConfigurator&gt;()
    .Build();
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5616</IssueLabelID>
    <Title>Add IHostApplicationLifetime support</Title>
    <Description>I think it would be a good idea to add IHostApplicationLifetime to TestCluster so that it can be monitored from outside rather than using the ILifecycleObservable startup tasks.

when testing a service fixture we can do the following before returning the client service provider to the test:
```
var t = Task.Run(() =&gt; testCluster.Deploy());
var lifetime = serverHost.ServiceProvider.GetService&lt;IHostApplicationLifetime&gt;();
if (lifetime != null)
{
    // This only happens once per fixture so we can afford to wait a little bit on it.
    if (!lifetime.ApplicationStarted.WaitHandle.WaitOne(TimeSpan.FromSeconds(20)))
    {
        ///t probably faulted
        if (t.IsFaulted)
        {
            throw t.Exception.InnerException;
        }
        throw new TimeoutException(
            $"Timed out waiting for client application to start.{Environment.NewLine}Startup Logs:{Environment.NewLine}");
    }
}
```
</Description>
    <Title_Description>Add IHostApplicationLifetime support I think it would be a good idea to add IHostApplicationLifetime to TestCluster so that it can be monitored from outside rather than using the ILifecycleObservable startup tasks.

when testing a service fixture we can do the following before returning the client service provider to the test:
```
var t = Task.Run(() =&gt; testCluster.Deploy());
var lifetime = serverHost.ServiceProvider.GetService&lt;IHostApplicationLifetime&gt;();
if (lifetime != null)
{
    // This only happens once per fixture so we can afford to wait a little bit on it.
    if (!lifetime.ApplicationStarted.WaitHandle.WaitOne(TimeSpan.FromSeconds(20)))
    {
        ///t probably faulted
        if (t.IsFaulted)
        {
            throw t.Exception.InnerException;
        }
        throw new TimeoutException(
            $"Timed out waiting for client application to start.{Environment.NewLine}Startup Logs:{Environment.NewLine}");
    }
}
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5615</IssueLabelID>
    <Title>Fix tx test</Title>
    <Description>
    </Description>
    <Title_Description>Fix tx test </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5614</IssueLabelID>
    <Title>Azure App Service (Web API) cannot connect to Orleans Cloud Service Silo as Worker Role</Title>
    <Description>Hi Team

We have hosted Orleans Client as API as Windows App Service and and Orleans Silo as Azure Worker Role as Cloud Services but we not able to connect web api to silo. Below are the error we get when trying to access the sites.

Silo Error :
Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironment.StartRoleInternal() at Microsoft.WindowsAzure.ServiceRuntime.Implementation.Loader.RoleRuntimeBridge.&lt;StartRole&gt;b__2() at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx) at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx) at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state) at System.Threading.ThreadHelper.ThreadStart() Inner Exception: No such host is known at System.Net.Dns.GetAddrInfo(String name) at System.Net.Dns.InternalGetHostByName(String hostName Boolean includeIPv6) at System.Net.Dns.GetHostEntry(String hostNameOrAddress) at Silo.WorkerRole.&lt;&gt;c__DisplayClass6_0.&lt;StartSilo&gt;b__3(EndpointOptions opt) in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line 108 at Microsoft.Extensions.Options.ConfigureNamedOptions`1.Configure(String name TOptions options) at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name) at System.Lazy`1.CreateValue() at System.Lazy`1.LazyInitValue() at Orleans.Configuration.EndpointOptionsValidator.ValidateConfiguration() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Configuration\Validators\EndpointOptionsValidator.cs:line 25 at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 159 at Orleans.Hosting.SiloHostBuilder.Build() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 43 at Silo.WorkerRole.&lt;StartSilo&gt;d__6.MoveNext() in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line 152 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Silo.WorkerRole.&lt;RunAsync&gt;d__5.MoveNext() in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line</Description>
    <Title_Description>Azure App Service (Web API) cannot connect to Orleans Cloud Service Silo as Worker Role Hi Team

We have hosted Orleans Client as API as Windows App Service and and Orleans Silo as Azure Worker Role as Cloud Services but we not able to connect web api to silo. Below are the error we get when trying to access the sites.

Silo Error :
Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironment.StartRoleInternal() at Microsoft.WindowsAzure.ServiceRuntime.Implementation.Loader.RoleRuntimeBridge.&lt;StartRole&gt;b__2() at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx) at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx) at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state) at System.Threading.ThreadHelper.ThreadStart() Inner Exception: No such host is known at System.Net.Dns.GetAddrInfo(String name) at System.Net.Dns.InternalGetHostByName(String hostName Boolean includeIPv6) at System.Net.Dns.GetHostEntry(String hostNameOrAddress) at Silo.WorkerRole.&lt;&gt;c__DisplayClass6_0.&lt;StartSilo&gt;b__3(EndpointOptions opt) in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line 108 at Microsoft.Extensions.Options.ConfigureNamedOptions`1.Configure(String name TOptions options) at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name) at System.Lazy`1.CreateValue() at System.Lazy`1.LazyInitValue() at Orleans.Configuration.EndpointOptionsValidator.ValidateConfiguration() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Configuration\Validators\EndpointOptionsValidator.cs:line 25 at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 159 at Orleans.Hosting.SiloHostBuilder.Build() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 43 at Silo.WorkerRole.&lt;StartSilo&gt;d__6.MoveNext() in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line 152 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Silo.WorkerRole.&lt;RunAsync&gt;d__5.MoveNext() in E:\Aniketh\Experimental Projects\Zipped Projects\OrleansPOC\Orleans-Azure-POC\src\Silo\WorkerRole.cs:line</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5613</IssueLabelID>
    <Title>What is the Relaese date for Microsoft Orleans which can support service fabric?</Title>
    <Description>Hi Team 

We are planning to introduce Microsoft Orleans to our Service Fabric Cluster but we observed some limitation in existing Orleans as per few documentation Microsoft.Orleans.Clustering.ServiceFabric is not available since the release of orleans 2.0. 
So can we know by when a new version will be released which is capable to host in Service Fabric? 

We believe the new version supports both .NET Core and .NET Framework. 

Thanks Sandeep.
</Description>
    <Title_Description>What is the Relaese date for Microsoft Orleans which can support service fabric? Hi Team 

We are planning to introduce Microsoft Orleans to our Service Fabric Cluster but we observed some limitation in existing Orleans as per few documentation Microsoft.Orleans.Clustering.ServiceFabric is not available since the release of orleans 2.0. 
So can we know by when a new version will be released which is capable to host in Service Fabric? 

We believe the new version supports both .NET Core and .NET Framework. 

Thanks Sandeep.
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5612</IssueLabelID>
    <Title>Memory  increased by 10%  since Orleans upgraded from 2.2.4 to 2.3.2</Title>
    <Description>Memory usage has doubled since Orleans upgraded from 2.2.4 to 2.3.2</Description>
    <Title_Description>Memory  increased by 10%  since Orleans upgraded from 2.2.4 to 2.3.2 Memory usage has doubled since Orleans upgraded from 2.2.4 to 2.3.2</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5611</IssueLabelID>
    <Title>Exceptions when using aspnetcore preview 5</Title>
    <Description>Hello

I just made the simplest app possible with orleans and aspnetcore preview 5

``` C#
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;
using Orleans.Hosting;

namespace WebApplication6
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); })
                .UseOrleans(x =&gt;
                {
                    x.UseLocalhostClustering();
                });
    }
}
```

it threw this when I started it:

`System.AggregateException: 'Some services are not able to be constructed (Error while validating the service descriptor 'ServiceType: Orleans.Streams.Core.IStreamSubscriptionHandleFactory Lifetime: Singleton ImplementationType: Orleans.Streams.StreamSubscriptionHandlerFactory': Unable to resolve service for type 'Orleans.Streams.IStreamProvider' while attempting to activate 'Orleans.Streams.StreamSubscriptionHandlerFactory'.)`</Description>
    <Title_Description>Exceptions when using aspnetcore preview 5 Hello

I just made the simplest app possible with orleans and aspnetcore preview 5

``` C#
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;
using Orleans.Hosting;

namespace WebApplication6
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); })
                .UseOrleans(x =&gt;
                {
                    x.UseLocalhostClustering();
                });
    }
}
```

it threw this when I started it:

`System.AggregateException: 'Some services are not able to be constructed (Error while validating the service descriptor 'ServiceType: Orleans.Streams.Core.IStreamSubscriptionHandleFactory Lifetime: Singleton ImplementationType: Orleans.Streams.StreamSubscriptionHandlerFactory': Unable to resolve service for type 'Orleans.Streams.IStreamProvider' while attempting to activate 'Orleans.Streams.StreamSubscriptionHandlerFactory'.)`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5609</IssueLabelID>
    <Title>Document [OneWay] attribute</Title>
    <Description>Couldn't find any information about `[OneWay]` attribute from http://dotnet.github.io/orleans/Documentation. But found pull request and tests now I know I need to add it to interface and method there.</Description>
    <Title_Description>Document [OneWay] attribute Couldn't find any information about `[OneWay]` attribute from http://dotnet.github.io/orleans/Documentation. But found pull request and tests now I know I need to add it to interface and method there.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/05/2019 11:24:58 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5607</IssueLabelID>
    <Title>Implement TaskScheduler.GetScheduledTasks() for debuggers</Title>
    <Description>Currently we have two implementations of `TaskScheduler`:
* `ActivationTaskScheduler` of which there is one per grain activation
* `OrleansTaskScheduler` of which there is one

In both cases we are not implementing [`TaskScheduler.GetScheduledTasks()`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.getscheduledtasks?view=netframework-4.8) faithfully: our implementations return an empty array instead of a collection of currently scheduled tasks.

This doesn't affect behavior at runtime but can affect the debugging experience. For example the Tasks &amp; Parallel Stacks (Tasks) views may not work correctly.</Description>
    <Title_Description>Implement TaskScheduler.GetScheduledTasks() for debuggers Currently we have two implementations of `TaskScheduler`:
* `ActivationTaskScheduler` of which there is one per grain activation
* `OrleansTaskScheduler` of which there is one

In both cases we are not implementing [`TaskScheduler.GetScheduledTasks()`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.getscheduledtasks?view=netframework-4.8) faithfully: our implementations return an empty array instead of a collection of currently scheduled tasks.

This doesn't affect behavior at runtime but can affect the debugging experience. For example the Tasks &amp; Parallel Stacks (Tasks) views may not work correctly.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5606</IssueLabelID>
    <Title>Remove legacy packages</Title>
    <Description>Removes legacy configuration (`ClusterConfiguration` `GlobalConfiguration` `ClientConfiguration` `NodeConfiguration`) and all dependent types/packages
Removes all ".Legacy" packages.
Removes `OrleansCounterControl` `OrleansManager` `Orleans.PowerShell` (doesn't work without legacy config)
Removes `AzureClient` `AzureSilo` `ProviderConfiguration`</Description>
    <Title_Description>Remove legacy packages Removes legacy configuration (`ClusterConfiguration` `GlobalConfiguration` `ClientConfiguration` `NodeConfiguration`) and all dependent types/packages
Removes all ".Legacy" packages.
Removes `OrleansCounterControl` `OrleansManager` `Orleans.PowerShell` (doesn't work without legacy config)
Removes `AzureClient` `AzureSilo` `ProviderConfiguration`</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5605</IssueLabelID>
    <Title>Test reliability: AccountWithLog</Title>
    <Description>I've seen this fail frequently in recent times.

```
Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False

Stack trace
   at Tester.EventSourcingTests.AccountGrainTests.&lt;TestSequence&gt;d__2.MoveNext() in C:\agent\_work\2\s\test\Tester\EventSourcingTests\AccountGrainTests.cs:line 54
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Tester.EventSourcingTests.AccountGrainTests.&lt;AccountWithLog&gt;d__3.MoveNext() in C:\agent\_work\2\s\test\Tester\EventSourcingTests\AccountGrainTests.cs:line 66
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```

Eg: https://orleans.visualstudio.com/GitHub%20-%20PR%20Builds/_build/results?buildId=20181&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=1010344&amp;resultId=101116&amp;paneView=debug</Description>
    <Title_Description>Test reliability: AccountWithLog I've seen this fail frequently in recent times.

```
Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False

Stack trace
   at Tester.EventSourcingTests.AccountGrainTests.&lt;TestSequence&gt;d__2.MoveNext() in C:\agent\_work\2\s\test\Tester\EventSourcingTests\AccountGrainTests.cs:line 54
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Tester.EventSourcingTests.AccountGrainTests.&lt;AccountWithLog&gt;d__3.MoveNext() in C:\agent\_work\2\s\test\Tester\EventSourcingTests\AccountGrainTests.cs:line 66
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```

Eg: https://orleans.visualstudio.com/GitHub%20-%20PR%20Builds/_build/results?buildId=20181&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=1010344&amp;resultId=101116&amp;paneView=debug</Title_Description>
    <Label>test-issue</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>10/05/2019 1:53:23 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5603</IssueLabelID>
    <Title>Feedback: Simplify the Streaming Interfaces</Title>
    <Description>I've been working on #5527 and trying to understand a lot of how the stream provider works and I wanted to provide some constructive feedback on it. My perspective coming into this is that I'm looking to implement a mostly pure-AMQP stream provider (RabbitMQ) and add it to the project. It's entirely possible that I missed the intent of some of the existing interfaces they aren't documented well and the formal documentation isn't much more helpful. I wanted to see how far I could get before providing feedback.

Right now with how many design decisions the stream interfaces forces me to make I've been considering just adding a stream consumer middleware in my system and then each message received will just call a grain. Personally I'm on the fence with the streaming provider's readiness for a production workload but I'm hoping some of the feedback can start to guide the streaming interfaces in the right way.

### Design Decisions

From the outside looking in the idea of having an internal stream provider which arbitrates on behalf of stream providers is a great idea and I think that was definitely a great decision. However I think the current implementation forces too many decisions on a given external provider and it forces extension devs to implement things strictly which isn't that great. I think the big forcing design decisions are `StreamSequenceTokens` and `QueueMapper`.

#### Stream Sequencing

Kafka (to my knowledge) and RabbitMQ don't have support for stream sequencing out of the box so all messages are FIFO which should be the normal way of going about things. Stream sequencing is helpful but not an AMQP trait and definitely a design decision that came from Event Hub. I think stream sequencing should be a provider-internal implementation detail that has no effect on the overall stream message delivery to either the consumer or the cache provider. Especially with RabbitMQ if I want stream sequencing without a lot of customization I can't have any type of sharding or partitioning I get one queue and that's it. That's not entirely ideal so requiring extension devs to either explicitly opt out or ignore the feature feels clunky.

#### Cache Provider

I think the cache provider is about halfway done. I would like to see the cache provider have a more CRUD-style interface that has optional overloads for message acknowledgement (key AMQP feature). I think CRUD is the right interface style because it allows a stream provider to perform basic `GET` message to send to a consumer `UPDATE` (think `basic-ack` from AMQP) where the cache can tell the provider there was a status change on the message (if the provider has support for that) and `DELETE` meaning a message was read by the consumer.

#### Namespaces and Guids

I think this design decision comes too much from Event Hub and forces design decisions onto stream providers. It seems like there should be one or the other but not both. Namespaces are hard to map to AMQP I think they would be topics and I'm not sure how to map a stream guid (I think it's designed to be a queue?).

I think there should be either namespaces or guids but I think the right path forward should be guids. I think the stream provider interface should specify a stream guid and then it's up to the provider to implement it as they see fit. A stream guid means that consumer can get messages from a specific stream guid and then the provider can map that quid to one or more queues but the interface shouldn't influence that design.

### Message Wrappers

It definitely feels like there should be a very simple message wrapper like `IMessageWrapper` or something like that. It's only job should be to serialized and deserialize the message to and from ways the provider understands how to handle. `IBatchContainer` seems to handle that a bit but it seems clunky.

### `IQueueAdapter`

```csharp
    public interface IQueueAdapter
    {
        string Name { get; }
        Task QueueMessageBatchAsync&lt;T&gt;(Guid streamGuid String streamNamespace IEnumerable&lt;T&gt; events StreamSequenceToken token Dictionary&lt;string object&gt; requestContext);
        IQueueAdapterReceiver CreateReceiver(QueueId queueId);
        bool IsRewindable { get; }
        StreamProviderDirection Direction { get; }
    }
```

On this interface I think the biggest pain point is `QueueMessageBatchAsync`. Not only are the method's parameters undocumented but it's too heavy. It should provide only the stream guid a single event payload instead of a enumerable of events and that's it. The `StreamSequenceToken` forces a provider to handle it (or ignore it which isn't good either) and the request context likely isn't helpful to the provider. Personally I'm in favor of dropping both of those arguments and leaving it up to the provider to handle.

`IsRewindable` also feels like a design decision driven by Event Hub. AMQP streams generally aren't designed to be rewindable as they are FIFO but potentially can be rewindable with a cache. I would argue that should be a function of the cache and not the stream provider.

### `IQueueAdapterFactory`

```csharp
    public interface IQueueAdapterFactory
    {
        Task&lt;IQueueAdapter&gt; CreateAdapter();
        IQueueAdapterCache GetQueueAdapterCache();
        IStreamQueueMapper GetStreamQueueMapper();
        Task&lt;IStreamFailureHandler&gt; GetDeliveryFailureHandler(QueueId queueId);
    }
```

This one is a bit frustrating as it either requires a stream provider to implement a cache or force them to opt out with `GetQueueCacheAdapter`. A big pain point here is `GetStreamQueueMapper` because it shouldn't matter how a provider handles the mapping so long as the provider can handle it.

### `IStreamQueueMapper`

```csharp
    public interface IStreamQueueMapper
    {
        IEnumerable&lt;QueueId&gt; GetAllQueues();
        QueueId GetQueueForStream(Guid streamGuid String streamNamespace);
    }
```

I appreciate the intent of this interface is to allow a provider to map a stream to a queue but it feels like too much interference with the stream provider. I think the stream provider should maintain a mapping and be responsible for the implementation details. Maybe I missed why the Orleans runtime needs this but it definitely feels like it's interfering with how a provider handles the mappings. A provider should receive a message from a stream guid and then it's up to the provider to implement it in their own way.

### Example Desired Interfaces

From my perspective I want an interface that is very simple and leaves a lot of the details up the stream provider. I'm thinking something like what's below. I think there's a happy medium between what I see as nice to have and then what exists today.

#### `IStreamMessage`

This interface is really just a wrapper that let's a provider implement a wrapper between how Orleans handles messages and how the provider understands messages. I think anything more than very basic serialization methods on this interface forces too many implementation details onto a provider.

```
    public interface IStreamMessage
    {
        object DeserializeMessage();
        object SerializeMessage();
    }
```

#### `IStreamPublisher`

This should be a very basic provider interface which handles the instantiation of the provider and ensuring there are publisher and/or subscriber interfaces attached to it.

```csharp
public interface IStreamProvider
{
    IStreamProvider CreateStreamProvider(object options);
    IPublisher CreatePublisher(object options);
    ISubscriber CreateSubscriber(string streamGuid string topic);
    IPublisher PublishMessageAsync(string streamGuid IStreamMessage message);
    IStreamMessage ReceiveMessage(string streamGuid);
}
```

#### `IPublisher`

This interface should be fairly simple as well being mostly around publishing to a stream guid with a message associated with it.

```csharp
    public interface IPublisher
    {
        void CreateNewStreamGuid(string streamGuid);
        void PublishMessage(IStreamMessage message string streamNamespace);
        Task PublishMessageAsync(IStreamMessage message string streamNamespace);
    }
```

#### `ISubscriber`

This interface would be focused squarely on reading from a given stream guid either with pull or push methods via callbacks/events.

    public interface ISubscriber
    {
        List&lt;IStreamMessage&gt; GetMessages(int maxCount string streamNamespace);
        Task&lt;List&lt;IStreamMessage&gt;&gt; GetMessagesAsync(int maxCount string streamNamespace);
        event IStreamMessage Consume(string streamGuid);
    }
```</Description>
    <Title_Description>Feedback: Simplify the Streaming Interfaces I've been working on #5527 and trying to understand a lot of how the stream provider works and I wanted to provide some constructive feedback on it. My perspective coming into this is that I'm looking to implement a mostly pure-AMQP stream provider (RabbitMQ) and add it to the project. It's entirely possible that I missed the intent of some of the existing interfaces they aren't documented well and the formal documentation isn't much more helpful. I wanted to see how far I could get before providing feedback.

Right now with how many design decisions the stream interfaces forces me to make I've been considering just adding a stream consumer middleware in my system and then each message received will just call a grain. Personally I'm on the fence with the streaming provider's readiness for a production workload but I'm hoping some of the feedback can start to guide the streaming interfaces in the right way.

### Design Decisions

From the outside looking in the idea of having an internal stream provider which arbitrates on behalf of stream providers is a great idea and I think that was definitely a great decision. However I think the current implementation forces too many decisions on a given external provider and it forces extension devs to implement things strictly which isn't that great. I think the big forcing design decisions are `StreamSequenceTokens` and `QueueMapper`.

#### Stream Sequencing

Kafka (to my knowledge) and RabbitMQ don't have support for stream sequencing out of the box so all messages are FIFO which should be the normal way of going about things. Stream sequencing is helpful but not an AMQP trait and definitely a design decision that came from Event Hub. I think stream sequencing should be a provider-internal implementation detail that has no effect on the overall stream message delivery to either the consumer or the cache provider. Especially with RabbitMQ if I want stream sequencing without a lot of customization I can't have any type of sharding or partitioning I get one queue and that's it. That's not entirely ideal so requiring extension devs to either explicitly opt out or ignore the feature feels clunky.

#### Cache Provider

I think the cache provider is about halfway done. I would like to see the cache provider have a more CRUD-style interface that has optional overloads for message acknowledgement (key AMQP feature). I think CRUD is the right interface style because it allows a stream provider to perform basic `GET` message to send to a consumer `UPDATE` (think `basic-ack` from AMQP) where the cache can tell the provider there was a status change on the message (if the provider has support for that) and `DELETE` meaning a message was read by the consumer.

#### Namespaces and Guids

I think this design decision comes too much from Event Hub and forces design decisions onto stream providers. It seems like there should be one or the other but not both. Namespaces are hard to map to AMQP I think they would be topics and I'm not sure how to map a stream guid (I think it's designed to be a queue?).

I think there should be either namespaces or guids but I think the right path forward should be guids. I think the stream provider interface should specify a stream guid and then it's up to the provider to implement it as they see fit. A stream guid means that consumer can get messages from a specific stream guid and then the provider can map that quid to one or more queues but the interface shouldn't influence that design.

### Message Wrappers

It definitely feels like there should be a very simple message wrapper like `IMessageWrapper` or something like that. It's only job should be to serialized and deserialize the message to and from ways the provider understands how to handle. `IBatchContainer` seems to handle that a bit but it seems clunky.

### `IQueueAdapter`

```csharp
    public interface IQueueAdapter
    {
        string Name { get; }
        Task QueueMessageBatchAsync&lt;T&gt;(Guid streamGuid String streamNamespace IEnumerable&lt;T&gt; events StreamSequenceToken token Dictionary&lt;string object&gt; requestContext);
        IQueueAdapterReceiver CreateReceiver(QueueId queueId);
        bool IsRewindable { get; }
        StreamProviderDirection Direction { get; }
    }
```

On this interface I think the biggest pain point is `QueueMessageBatchAsync`. Not only are the method's parameters undocumented but it's too heavy. It should provide only the stream guid a single event payload instead of a enumerable of events and that's it. The `StreamSequenceToken` forces a provider to handle it (or ignore it which isn't good either) and the request context likely isn't helpful to the provider. Personally I'm in favor of dropping both of those arguments and leaving it up to the provider to handle.

`IsRewindable` also feels like a design decision driven by Event Hub. AMQP streams generally aren't designed to be rewindable as they are FIFO but potentially can be rewindable with a cache. I would argue that should be a function of the cache and not the stream provider.

### `IQueueAdapterFactory`

```csharp
    public interface IQueueAdapterFactory
    {
        Task&lt;IQueueAdapter&gt; CreateAdapter();
        IQueueAdapterCache GetQueueAdapterCache();
        IStreamQueueMapper GetStreamQueueMapper();
        Task&lt;IStreamFailureHandler&gt; GetDeliveryFailureHandler(QueueId queueId);
    }
```

This one is a bit frustrating as it either requires a stream provider to implement a cache or force them to opt out with `GetQueueCacheAdapter`. A big pain point here is `GetStreamQueueMapper` because it shouldn't matter how a provider handles the mapping so long as the provider can handle it.

### `IStreamQueueMapper`

```csharp
    public interface IStreamQueueMapper
    {
        IEnumerable&lt;QueueId&gt; GetAllQueues();
        QueueId GetQueueForStream(Guid streamGuid String streamNamespace);
    }
```

I appreciate the intent of this interface is to allow a provider to map a stream to a queue but it feels like too much interference with the stream provider. I think the stream provider should maintain a mapping and be responsible for the implementation details. Maybe I missed why the Orleans runtime needs this but it definitely feels like it's interfering with how a provider handles the mappings. A provider should receive a message from a stream guid and then it's up to the provider to implement it in their own way.

### Example Desired Interfaces

From my perspective I want an interface that is very simple and leaves a lot of the details up the stream provider. I'm thinking something like what's below. I think there's a happy medium between what I see as nice to have and then what exists today.

#### `IStreamMessage`

This interface is really just a wrapper that let's a provider implement a wrapper between how Orleans handles messages and how the provider understands messages. I think anything more than very basic serialization methods on this interface forces too many implementation details onto a provider.

```
    public interface IStreamMessage
    {
        object DeserializeMessage();
        object SerializeMessage();
    }
```

#### `IStreamPublisher`

This should be a very basic provider interface which handles the instantiation of the provider and ensuring there are publisher and/or subscriber interfaces attached to it.

```csharp
public interface IStreamProvider
{
    IStreamProvider CreateStreamProvider(object options);
    IPublisher CreatePublisher(object options);
    ISubscriber CreateSubscriber(string streamGuid string topic);
    IPublisher PublishMessageAsync(string streamGuid IStreamMessage message);
    IStreamMessage ReceiveMessage(string streamGuid);
}
```

#### `IPublisher`

This interface should be fairly simple as well being mostly around publishing to a stream guid with a message associated with it.

```csharp
    public interface IPublisher
    {
        void CreateNewStreamGuid(string streamGuid);
        void PublishMessage(IStreamMessage message string streamNamespace);
        Task PublishMessageAsync(IStreamMessage message string streamNamespace);
    }
```

#### `ISubscriber`

This interface would be focused squarely on reading from a given stream guid either with pull or push methods via callbacks/events.

    public interface ISubscriber
    {
        List&lt;IStreamMessage&gt; GetMessages(int maxCount string streamNamespace);
        Task&lt;List&lt;IStreamMessage&gt;&gt; GetMessagesAsync(int maxCount string streamNamespace);
        event IStreamMessage Consume(string streamGuid);
    }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5601</IssueLabelID>
    <Title>Support runtime code generation in source analysis code generator</Title>
    <Description>Currently the `Microsoft.Orleans.CodeGenerator` code generation package does not support runtime code generation. The older `Microsoft.Orleans.OrleansCodeGenerator` code generation package does.

Add support for runtime code generation to `Microsoft.Orleans.CodeGenerator`</Description>
    <Title_Description>Support runtime code generation in source analysis code generator Currently the `Microsoft.Orleans.CodeGenerator` code generation package does not support runtime code generation. The older `Microsoft.Orleans.OrleansCodeGenerator` code generation package does.

Add support for runtime code generation to `Microsoft.Orleans.CodeGenerator`</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5597</IssueLabelID>
    <Title>Fix potential NullReferenceException in PersistentStreamProvider</Title>
    <Description>
    </Description>
    <Title_Description>Fix potential NullReferenceException in PersistentStreamProvider </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5593</IssueLabelID>
    <Title> The given key 'ReminderService' was not present in the dictionary</Title>
    <Description>1. Create  a  ReminderGrain 
public class ReminderGrain : GrainBase IReminderGrain
    {
        public async Task&lt;IGrainReminder&gt; StartReminderAsync(string reminderName TimeSpan dueTime TimeSpan period)
        {
            return await RegisterOrUpdateReminder(reminderName dueTime period);
        }

        public Task ReceiveReminder(string reminderName TickStatus status)
        {
            Console.WriteLine($"我是定时器{reminderName}，自动执行首次执行时间：{status.FirstTickTime.ToString()}；当前执行时间{status.CurrentTickTime.ToString()}");
            return Task.CompletedTask;
        }
    }
2. Create a database by executing the MySQL-Reminders.sql file.
3. In Program UseAdoNetReminderService
 var builder = new SiloHostBuilder()
                // Membership
                .UseAdoNetClustering(options =&gt;
                {
                    options.Invariant = configurationRoot["OrleansSetting:AdoNetClustering:Invariant"];
                    options.ConnectionString = configurationRoot["OrleansSetting:AdoNetClustering:ConnectionString"];
                })
                .UseAdoNetReminderService(options =&gt;
                {
                    options.Invariant = configurationRoot["OrleansSetting:AdoNetReminderService:Invariant"];
                    options.ConnectionString = configurationRoot["OrleansSetting:AdoNetReminderService:ConnectionString"];
                })

3. Start SiloHost Throw Exception：
Exception during Silo.Start
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; System.Collections.Generic.KeyNotFoundException: The given key 'ReminderService' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage..ctor(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 208
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage.CreateInstance(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 98
   at Orleans.Reminders.AdoNet.Storage.RelationalOrleansQueries.CreateInstance(String invariantName String connectionString IGrainReferenceConverter grainReferenceConverter) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalOrleansQueries.cs:line 0
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.Init() in D:\build\agent\_work\12\s\src\AdoNet\Orleans.Reminders.AdoNet\ReminderService\AdoNetReminderTable.cs:line 27
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 206
   at Orleans.Runtime.ReminderService.LocalReminderService.Start() in D:\build\agent\_work\12\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
   at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;g__StartReminderService|74_0() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 541
   at Orleans.Runtime.Silo.StartAsyncTaskWithPerfAnalysis(String taskName Func`1 task Stopwatch stopWatch) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 391
   at Orleans.Runtime.Silo.OnActiveStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 544
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 75
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Silo.StartAsync(CancellationToken cancellationToken) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 265
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; System.Collections.Generic.KeyNotFoundException: The given key 'ReminderService' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage..ctor(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 208
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage.CreateInstance(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 98
   at Orleans.Reminders.AdoNet.Storage.RelationalOrleansQueries.CreateInstance(String invariantName String connectionString IGrainReferenceConverter grainReferenceConverter) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalOrleansQueries.cs:line 0
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.Init() in D:\build\agent\_work\12\s\src\AdoNet\Orleans.Reminders.AdoNet\ReminderService\AdoNetReminderTable.cs:line 27
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 206
   at Orleans.Runtime.ReminderService.LocalReminderService.Start() in D:\build\agent\_work\12\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
   at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;g__StartReminderService|74_0() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 541
   at Orleans.Runtime.Silo.StartAsyncTaskWithPerfAnalysis(String taskName Func`1 task Stopwatch stopWatch) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 391
   at Orleans.Runtime.Silo.OnActiveStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 544
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 75
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Silo.StartAsync(CancellationToken cancellationToken) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 265
</Description>
    <Title_Description> The given key 'ReminderService' was not present in the dictionary 1. Create  a  ReminderGrain 
public class ReminderGrain : GrainBase IReminderGrain
    {
        public async Task&lt;IGrainReminder&gt; StartReminderAsync(string reminderName TimeSpan dueTime TimeSpan period)
        {
            return await RegisterOrUpdateReminder(reminderName dueTime period);
        }

        public Task ReceiveReminder(string reminderName TickStatus status)
        {
            Console.WriteLine($"我是定时器{reminderName}，自动执行首次执行时间：{status.FirstTickTime.ToString()}；当前执行时间{status.CurrentTickTime.ToString()}");
            return Task.CompletedTask;
        }
    }
2. Create a database by executing the MySQL-Reminders.sql file.
3. In Program UseAdoNetReminderService
 var builder = new SiloHostBuilder()
                // Membership
                .UseAdoNetClustering(options =&gt;
                {
                    options.Invariant = configurationRoot["OrleansSetting:AdoNetClustering:Invariant"];
                    options.ConnectionString = configurationRoot["OrleansSetting:AdoNetClustering:ConnectionString"];
                })
                .UseAdoNetReminderService(options =&gt;
                {
                    options.Invariant = configurationRoot["OrleansSetting:AdoNetReminderService:Invariant"];
                    options.ConnectionString = configurationRoot["OrleansSetting:AdoNetReminderService:ConnectionString"];
                })

3. Start SiloHost Throw Exception：
Exception during Silo.Start
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; System.Collections.Generic.KeyNotFoundException: The given key 'ReminderService' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage..ctor(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 208
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage.CreateInstance(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 98
   at Orleans.Reminders.AdoNet.Storage.RelationalOrleansQueries.CreateInstance(String invariantName String connectionString IGrainReferenceConverter grainReferenceConverter) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalOrleansQueries.cs:line 0
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.Init() in D:\build\agent\_work\12\s\src\AdoNet\Orleans.Reminders.AdoNet\ReminderService\AdoNetReminderTable.cs:line 27
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 206
   at Orleans.Runtime.ReminderService.LocalReminderService.Start() in D:\build\agent\_work\12\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
   at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;g__StartReminderService|74_0() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 541
   at Orleans.Runtime.Silo.StartAsyncTaskWithPerfAnalysis(String taskName Func`1 task Stopwatch stopWatch) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 391
   at Orleans.Runtime.Silo.OnActiveStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 544
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 75
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Silo.StartAsync(CancellationToken cancellationToken) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 265
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; System.Collections.Generic.KeyNotFoundException: The given key 'ReminderService' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage..ctor(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 208
   at Orleans.Reminders.AdoNet.Storage.RelationalStorage.CreateInstance(String invariantName String connectionString) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalStorage.cs:line 98
   at Orleans.Reminders.AdoNet.Storage.RelationalOrleansQueries.CreateInstance(String invariantName String connectionString IGrainReferenceConverter grainReferenceConverter) in D:\build\agent\_work\12\s\src\AdoNet\Shared\Storage\RelationalOrleansQueries.cs:line 0
   at Orleans.Runtime.ReminderService.AdoNetReminderTable.Init() in D:\build\agent\_work\12\s\src\AdoNet\Orleans.Reminders.AdoNet\ReminderService\AdoNetReminderTable.cs:line 27
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 206
   at Orleans.Runtime.ReminderService.LocalReminderService.Start() in D:\build\agent\_work\12\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.OrleansTaskExtentions.WithTimeout(Task taskToComplete TimeSpan timeout String exceptionMessage) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
   at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;g__StartReminderService|74_0() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 541
   at Orleans.Runtime.Silo.StartAsyncTaskWithPerfAnalysis(String taskName Func`1 task Stopwatch stopWatch) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 391
   at Orleans.Runtime.Silo.OnActiveStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 544
   at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 75
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\12\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Silo.StartAsync(CancellationToken cancellationToken) in D:\build\agent\_work\12\s\src\Orleans.Runtime\Silo\Silo.cs:line 265
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5591</IssueLabelID>
    <Title>Question on TransactionOptions</Title>
    <Description>Which TransactionOption should i use when i just want to read the committed state of the grain via the ITransactionalState facet without participating in a transaction? I just want to retrieve a "snapshot" of the currently committed state of the transaction. Will the TransactionOption.Suppress work?</Description>
    <Title_Description>Question on TransactionOptions Which TransactionOption should i use when i just want to read the committed state of the grain via the ITransactionalState facet without participating in a transaction? I just want to retrieve a "snapshot" of the currently committed state of the transaction. Will the TransactionOption.Suppress work?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5590</IssueLabelID>
    <Title>Documentation | Unit Testing</Title>
    <Description>- [ ] https://dotnet.github.io/orleans/1.5/Tutorials/Unit-Testing-Grains.html missing old version **warning-banner**
- [ ] https://dotnet.github.io/orleans/Documentation/tutorials_and_samples/testing.html outdated?

The code specified in that document
```cs
var cluster = new TestCluster();
```
Results

&gt; ERROR: There is no argument given that corresponds to the required formal parameter **options**.

</Description>
    <Title_Description>Documentation | Unit Testing - [ ] https://dotnet.github.io/orleans/1.5/Tutorials/Unit-Testing-Grains.html missing old version **warning-banner**
- [ ] https://dotnet.github.io/orleans/Documentation/tutorials_and_samples/testing.html outdated?

The code specified in that document
```cs
var cluster = new TestCluster();
```
Results

&gt; ERROR: There is no argument given that corresponds to the required formal parameter **options**.

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>9/05/2019 8:26:42 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5589</IssueLabelID>
    <Title>Add Analyzers to Orleans</Title>
    <Description>- Setup basic Analyzer project
- Setup basic Tests project
- Create analyzer for AlwaysInterleaveAttribute</Description>
    <Title_Description>Add Analyzers to Orleans - Setup basic Analyzer project
- Setup basic Tests project
- Create analyzer for AlwaysInterleaveAttribute</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5588</IssueLabelID>
    <Title>Execute tasks scheduled against defunct activations</Title>
    <Description>Currently `Task`s which are scheduled against an activation's `TaskScheduler` will be ignored if that activation has become defunct. This is generally not a problem and ignoring these tasks is fine (eg it could be a non-awaited task from a grain method call). However there are some cases where not executing these tasks can lead to larger issues. For example we have encountered a library which captures an activation's `TaskScheduler` and use it for servicing a work queue.

This PR changes the behavior of `WorkItemGroup` so that `Task`s scheduled after an activation has terminated are still executed.

A warning will still be emitted and that warning will be upgraded to an error after 1 minute (configurable via `SchedulingOptions.StoppedWorkItemGroupWarningInterval`). The error will then be logged at most once per minute per activation.

This allows systems to continue functioning when a library misbehaves and gives the application developer more tools to find the misbehaving code.

Since this allows grain code to continue executing after being deactivated (eg due to an end-user programming error) this PR also adds additional runtime checks so that invalid activations cannot access runtime services as easily.</Description>
    <Title_Description>Execute tasks scheduled against defunct activations Currently `Task`s which are scheduled against an activation's `TaskScheduler` will be ignored if that activation has become defunct. This is generally not a problem and ignoring these tasks is fine (eg it could be a non-awaited task from a grain method call). However there are some cases where not executing these tasks can lead to larger issues. For example we have encountered a library which captures an activation's `TaskScheduler` and use it for servicing a work queue.

This PR changes the behavior of `WorkItemGroup` so that `Task`s scheduled after an activation has terminated are still executed.

A warning will still be emitted and that warning will be upgraded to an error after 1 minute (configurable via `SchedulingOptions.StoppedWorkItemGroupWarningInterval`). The error will then be logged at most once per minute per activation.

This allows systems to continue functioning when a library misbehaves and gives the application developer more tools to find the misbehaving code.

Since this allows grain code to continue executing after being deactivated (eg due to an end-user programming error) this PR also adds additional runtime checks so that invalid activations cannot access runtime services as easily.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5586</IssueLabelID>
    <Title>Implement IApplicationLifetime for ClientBuilder/SiloHostBuilder</Title>
    <Description>This is a pre-requisite for #5436 which uses `IApplicationLifetime` (from shared Hosting package) to ensure all connections are closed during shutdown.

This aligns `ClusterClient` and `SiloHostBuilder` more closely with the generic `HostBuilder` from `Microsoft.Extensions.Hosting`.</Description>
    <Title_Description>Implement IApplicationLifetime for ClientBuilder/SiloHostBuilder This is a pre-requisite for #5436 which uses `IApplicationLifetime` (from shared Hosting package) to ensure all connections are closed during shutdown.

This aligns `ClusterClient` and `SiloHostBuilder` more closely with the generic `HostBuilder` from `Microsoft.Extensions.Hosting`.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5585</IssueLabelID>
    <Title>Groundwork for span-friendly serialization</Title>
    <Description>This is a pre-requisite for #5436 and lays some groundwork for a more span-friendly serializer (networking replat is based on pipes which use Span&lt;byte&gt;/Memory&lt;byte&gt;)</Description>
    <Title_Description>Groundwork for span-friendly serialization This is a pre-requisite for #5436 and lays some groundwork for a more span-friendly serializer (networking replat is based on pipes which use Span&lt;byte&gt;/Memory&lt;byte&gt;)</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5584</IssueLabelID>
    <Title>Provide separate options for worker &amp; IO pool min thread counts</Title>
    <Description>Set defaults to 0 (no minimum set)

During development of #5436 the default value for these thread pools was found to be a detrimental to throughput.

It is better to avoid setting a minimum and instead allow users to follow general .NET guidance on setting thread pool limits.</Description>
    <Title_Description>Provide separate options for worker &amp; IO pool min thread counts Set defaults to 0 (no minimum set)

During development of #5436 the default value for these thread pools was found to be a detrimental to throughput.

It is better to avoid setting a minimum and instead allow users to follow general .NET guidance on setting thread pool limits.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5583</IssueLabelID>
    <Title>Fix packaging warning in Orleans.CodeGenerator.MSBuild</Title>
    <Description>The `.Tasks.*` files are already included and including them multiple times causes a packaging warning</Description>
    <Title_Description>Fix packaging warning in Orleans.CodeGenerator.MSBuild The `.Tasks.*` files are already included and including them multiple times causes a packaging warning</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5580</IssueLabelID>
    <Title>Refactor EventHubDataAdapter to be plugable</Title>
    <Description>Attempting to address "Stream data adapter #4621" for EventHub streams.
EventHubDataAdapter is now pluggable.  It can now be configured without customizing queue adapter or cache.

Other changes:
- Simplified pooled cache to only use CachedMessage
- Simplified eviction strategy to only use CachedMessage
- Removed the need for custom comparer logic.
- Added interned stream namespace to CachedMessage to prevent the need to encode it into pooled memory segment.
- Refactored IQueueDataAdapter to support common send behaviors.

Overall pooled cache pattern is much cleaner and maintainable at the cost of some customizability.</Description>
    <Title_Description>Refactor EventHubDataAdapter to be plugable Attempting to address "Stream data adapter #4621" for EventHub streams.
EventHubDataAdapter is now pluggable.  It can now be configured without customizing queue adapter or cache.

Other changes:
- Simplified pooled cache to only use CachedMessage
- Simplified eviction strategy to only use CachedMessage
- Removed the need for custom comparer logic.
- Added interned stream namespace to CachedMessage to prevent the need to encode it into pooled memory segment.
- Refactored IQueueDataAdapter to support common send behaviors.

Overall pooled cache pattern is much cleaner and maintainable at the cost of some customizability.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5579</IssueLabelID>
    <Title>Health Check Sample</Title>
    <Description>Orleans Health Check Sample

Targets:
* .NET Core 2.2
* Orleans 2.3.1
* ASP.NET Core 2.2

Based on prior art from [ReubenBond](https://github.com/dotnet/orleans/issues/4843#issuecomment-478055180) and [DarkCow](https://github.com/dotnet/orleans/issues/4843#issuecomment-479576394).

In addition to the code I would appreciate a review of the readme file for technical correctness. Some bits are to the best of my current knowledge and may be wrong or outdated. Thanks in advance.

Closes #5486 </Description>
    <Title_Description>Health Check Sample Orleans Health Check Sample

Targets:
* .NET Core 2.2
* Orleans 2.3.1
* ASP.NET Core 2.2

Based on prior art from [ReubenBond](https://github.com/dotnet/orleans/issues/4843#issuecomment-478055180) and [DarkCow](https://github.com/dotnet/orleans/issues/4843#issuecomment-479576394).

In addition to the code I would appreciate a review of the readme file for technical correctness. Some bits are to the best of my current knowledge and may be wrong or outdated. Thanks in advance.

Closes #5486 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5578</IssueLabelID>
    <Title>Documentation | Graceful shutdown - Docker app</Title>
    <Description>In [Shutting down Orleans | Microsoft Orleans Documentation](https://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html) `Graceful shutdown - Docker app` mentioned as **To be completed**.

Putting at least a reference to [orleans/Samples/2.0/docker-aspnet-core/Silo/Program.cs](https://github.com/dotnet/orleans/blob/master/Samples/2.0/docker-aspnet-core/Silo/Program.cs) would be good.

The doc for the same can be found here - [shutting_down_orleans.md](https://github.com/dotnet/orleans/blob/docs/src/Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.md/#L1)</Description>
    <Title_Description>Documentation | Graceful shutdown - Docker app In [Shutting down Orleans | Microsoft Orleans Documentation](https://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.html) `Graceful shutdown - Docker app` mentioned as **To be completed**.

Putting at least a reference to [orleans/Samples/2.0/docker-aspnet-core/Silo/Program.cs](https://github.com/dotnet/orleans/blob/master/Samples/2.0/docker-aspnet-core/Silo/Program.cs) would be good.

The doc for the same can be found here - [shutting_down_orleans.md](https://github.com/dotnet/orleans/blob/docs/src/Documentation/clusters_and_clients/configuration_guide/shutting_down_orleans.md/#L1)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5577</IssueLabelID>
    <Title>NoOp delete when ETag is null in AzureTableStorage provider</Title>
    <Description>This is to prevent exceptions from Azure Storage SDK when Delete is called with `Etag=null` i.e. when state for that grain hasn't been written to the storage.

Closes #5219 </Description>
    <Title_Description>NoOp delete when ETag is null in AzureTableStorage provider This is to prevent exceptions from Azure Storage SDK when Delete is called with `Etag=null` i.e. when state for that grain hasn't been written to the storage.

Closes #5219 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5576</IssueLabelID>
    <Title>Cherry-pick #5570 and #5575 for 2.3.2</Title>
    <Description>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt; (#5570)
Accommodate existing RequestContext.PropagateActivityId value in ClusterClient (#5575)</Description>
    <Title_Description>Cherry-pick #5570 and #5575 for 2.3.2 Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt; (#5570)
Accommodate existing RequestContext.PropagateActivityId value in ClusterClient (#5575)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5574</IssueLabelID>
    <Title>[WIP] Remove base class from [ClientSilo]MessagingOptions</Title>
    <Description>This separates the `MessagingOptions` base class from `ClientMessagingOptions` and `SiloMessagingOptions`.

This is a breaking change: users may have to fix some code so that their application continues to compile.

Effectively subsumes #4753.</Description>
    <Title_Description>[WIP] Remove base class from [Client,Silo]MessagingOptions This separates the `MessagingOptions` base class from `ClientMessagingOptions` and `SiloMessagingOptions`.

This is a breaking change: users may have to fix some code so that their application continues to compile.

Effectively subsumes #4753.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5573</IssueLabelID>
    <Title>Cherry-pick #5561 for 2.3.2</Title>
    <Description>On the client close gateway connection to dead silos (#5561)</Description>
    <Title_Description>Cherry-pick #5561 for 2.3.2 On the client close gateway connection to dead silos (#5561)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5572</IssueLabelID>
    <Title>I need someone who can write a customized version of the msbuild task</Title>
    <Description>This is off-topic from Orleans issues but I'll put it out there.

I have a solution that is built up from an interface based meta-model.

It outputs CSharp C++ Typescript/JavaScript &amp; Go client proxies as well as a socket gateway handler used to communicate with the Orleans cluster(s). 

To date I have used reflection with a post build task but would like to migrate it to a build task using code analysis the same way Orleans does.

My ask is simple. Is there anyone out there with the time and experience to do the work?

rich</Description>
    <Title_Description>I need someone who can write a customized version of the msbuild task This is off-topic from Orleans issues but I'll put it out there.

I have a solution that is built up from an interface based meta-model.

It outputs CSharp C++ Typescript/JavaScript &amp; Go client proxies as well as a socket gateway handler used to communicate with the Orleans cluster(s). 

To date I have used reflection with a post build task but would like to migrate it to a build task using code analysis the same way Orleans does.

My ask is simple. Is there anyone out there with the time and experience to do the work?

rich</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5571</IssueLabelID>
    <Title>Tutorial.Minimal building errors</Title>
    <Description>I have downloaded the Orleans.master and tryed to build the Tutorial.Minimal sample in VS2017.
But
1. There are yellow mark on Orleans.CodeGeneration.Build.Bootstrap in the GrainInterfaces and GrainCollection 
2. During the building I receive
```
Severity	Code	Description	Project	File	Line	Suppression State
Error		The command """ "@obj\Debug\GrainInterfaces.codegen.args.txt"" exited with code 9009.	GrainInterfaces			
Error		The command """ "@obj\Debug\GrainCollection.codegen.args.txt"" exited with code 9009.	GrainCollection	
```		

What can I fix?
</Description>
    <Title_Description>Tutorial.Minimal building errors I have downloaded the Orleans.master and tryed to build the Tutorial.Minimal sample in VS2017.
But
1. There are yellow mark on Orleans.CodeGeneration.Build.Bootstrap in the GrainInterfaces and GrainCollection 
2. During the building I receive
```
Severity	Code	Description	Project	File	Line	Suppression State
Error		The command """ "@obj\Debug\GrainInterfaces.codegen.args.txt"" exited with code 9009.	GrainInterfaces			
Error		The command """ "@obj\Debug\GrainCollection.codegen.args.txt"" exited with code 9009.	GrainCollection	
```		

What can I fix?
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5570</IssueLabelID>
    <Title>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt;</Title>
    <Description>Fixes #5569 

The change has been tested in a real cluster.</Description>
    <Title_Description>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt; Fixes #5569 

The change has been tested in a real cluster.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5569</IssueLabelID>
    <Title>Possible NullReferenceException in AzureTableStorage.ReadStateAsync for Grain&lt;Nullable&lt;T&gt;&gt;</Title>
    <Description>If `Nullable&lt;T&gt;` is used for grain state type the following line will throw a NullReference Exception: https://github.com/dotnet/orleans/blob/v2.3.1/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs#L83

This would happen as `StateStorageBridge&lt;TState&gt;` instantiates it as `new GrainState&lt;TState&gt;(new TState())` and when `TState` is e.g. `int?` then `(new int?()) == null)`.

I'm going to submit a PR that fixes that shortly.</Description>
    <Title_Description>Possible NullReferenceException in AzureTableStorage.ReadStateAsync for Grain&lt;Nullable&lt;T&gt;&gt; If `Nullable&lt;T&gt;` is used for grain state type the following line will throw a NullReference Exception: https://github.com/dotnet/orleans/blob/v2.3.1/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs#L83

This would happen as `StateStorageBridge&lt;TState&gt;` instantiates it as `new GrainState&lt;TState&gt;(new TState())` and when `TState` is e.g. `int?` then `(new int?()) == null)`.

I'm going to submit a PR that fixes that shortly.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5568</IssueLabelID>
    <Title>"Failed to get a local IP address" on Linux with localhost clustering</Title>
    <Description>**OS**: Arch Linux updated 30.04.2019
**Linux kernel**: 5.0.10-arch1-1-ARCH
**Orleans version**: 2.2.0

**What happened**:
I am creating a cluster with UseLocalhostClustering but I cannot connect from a client running on the same machine without having internet connection (or when on a tethered connection).
I suspect this is due to the loopback address having UNKNOWN state.

Related to #5097.

Stacktrace of the error:
```
Unhandled Exception: System.AggregateException: One or more errors occurred. (Failed to get a local IP address.) ---&gt; 
Orleans.Runtime.OrleansException: Failed to get a local IP address.
    at Orleans.Runtime.Configuration.ConfigUtilities.GetLocalIPAddress(AddressFamily family String interfaceName)
    at Orleans.OutsideRuntimeClient.ConsumeServices(IServiceProvider services)
    at Orleans.ClientBuilder.Build()
    at … (non-orleans code)
```

`ip addr list` output (when on a tethered connection from an andorid phone):
```
1: lo: &lt;LOOPBACKUPLOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: wlp3s0: &lt;NO-CARRIERBROADCASTMULTICASTUP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 56:2f:10:d5:d9:f7 brd ff:ff:ff:ff:ff:ff
3: enp0s20u3: &lt;BROADCASTMULTICASTUPLOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000
    link/ether 8a:10:9e:df:40:22 brd ff:ff:ff:ff:ff:ff
    inet 192.168.42.135/24 brd 192.168.42.255 scope global dynamic noprefixroute enp0s20u3
       valid_lft 3511sec preferred_lft 3511sec
    inet6 …/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

`ip addr list` when not connected to the internet:
```
1: lo: &lt;LOOPBACKUPLOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: wlp3s0: &lt;NO-CARRIERBROADCASTMULTICASTUP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 60:36:dd:8e:d7:f3 brd ff:ff:ff:ff:ff:ff
    inet 192.168.43.228/24 brd 192.168.43.255 scope global dynamic noprefixroute wlp3s0
       valid_lft 2304sec preferred_lft 2304sec
    inet6 …/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

**Expected behaviour**:
I would expect Orleans to connect automagically since this is a local (development) cluster. I shouldn't need a wifi or ethernet connection just to run something locally.

Alternatively I would expect it to work when forcing the use of the `"lo"` network interface like this:
```csharp
new ClientBuilder()
…
.Configure&lt;ClientMessagingOptions&gt;(options =&gt;
{
    options.NetworkInterfaceName = "lo";
})
…
```

Finally it would be nice if there was an option for forcing a custom IP address and bypassing automatic IP address selection.
</Description>
    <Title_Description>"Failed to get a local IP address" on Linux with localhost clustering **OS**: Arch Linux updated 30.04.2019
**Linux kernel**: 5.0.10-arch1-1-ARCH
**Orleans version**: 2.2.0

**What happened**:
I am creating a cluster with UseLocalhostClustering but I cannot connect from a client running on the same machine without having internet connection (or when on a tethered connection).
I suspect this is due to the loopback address having UNKNOWN state.

Related to #5097.

Stacktrace of the error:
```
Unhandled Exception: System.AggregateException: One or more errors occurred. (Failed to get a local IP address.) ---&gt; 
Orleans.Runtime.OrleansException: Failed to get a local IP address.
    at Orleans.Runtime.Configuration.ConfigUtilities.GetLocalIPAddress(AddressFamily family String interfaceName)
    at Orleans.OutsideRuntimeClient.ConsumeServices(IServiceProvider services)
    at Orleans.ClientBuilder.Build()
    at … (non-orleans code)
```

`ip addr list` output (when on a tethered connection from an andorid phone):
```
1: lo: &lt;LOOPBACKUPLOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: wlp3s0: &lt;NO-CARRIERBROADCASTMULTICASTUP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 56:2f:10:d5:d9:f7 brd ff:ff:ff:ff:ff:ff
3: enp0s20u3: &lt;BROADCASTMULTICASTUPLOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 1000
    link/ether 8a:10:9e:df:40:22 brd ff:ff:ff:ff:ff:ff
    inet 192.168.42.135/24 brd 192.168.42.255 scope global dynamic noprefixroute enp0s20u3
       valid_lft 3511sec preferred_lft 3511sec
    inet6 …/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

`ip addr list` when not connected to the internet:
```
1: lo: &lt;LOOPBACKUPLOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: wlp3s0: &lt;NO-CARRIERBROADCASTMULTICASTUP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 60:36:dd:8e:d7:f3 brd ff:ff:ff:ff:ff:ff
    inet 192.168.43.228/24 brd 192.168.43.255 scope global dynamic noprefixroute wlp3s0
       valid_lft 2304sec preferred_lft 2304sec
    inet6 …/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

**Expected behaviour**:
I would expect Orleans to connect automagically since this is a local (development) cluster. I shouldn't need a wifi or ethernet connection just to run something locally.

Alternatively I would expect it to work when forcing the use of the `"lo"` network interface like this:
```csharp
new ClientBuilder()
…
.Configure&lt;ClientMessagingOptions&gt;(options =&gt;
{
    options.NetworkInterfaceName = "lo";
})
…
```

Finally it would be nice if there was an option for forcing a custom IP address and bypassing automatic IP address selection.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5565</IssueLabelID>
    <Title>NullReferenceException when you catch exceptions</Title>
    <Description>Hi
when you just catch execptions with a filter like:

```
    public sealed class LoggingFilter : IIncomingGrainCallFilter
    {
        private readonly ILogger&lt;LoggingFilter&gt; log;

        public LoggingFilter(ILogger&lt;LoggingFilter&gt; log)
        {
            this.log = log;
        }

        public async Task Invoke(IIncomingGrainCallContext context)
        {
            try
            {
                await context.Invoke();
            }
            catch (Exception ex)
            {
                log.LogError(ex "foo");
            }
        }
    }
```

you get a NullReferenceException. I think such a filter should be allowed for grains that void result (Task).
</Description>
    <Title_Description>NullReferenceException when you catch exceptions Hi
when you just catch execptions with a filter like:

```
    public sealed class LoggingFilter : IIncomingGrainCallFilter
    {
        private readonly ILogger&lt;LoggingFilter&gt; log;

        public LoggingFilter(ILogger&lt;LoggingFilter&gt; log)
        {
            this.log = log;
        }

        public async Task Invoke(IIncomingGrainCallContext context)
        {
            try
            {
                await context.Invoke();
            }
            catch (Exception ex)
            {
                log.LogError(ex "foo");
            }
        }
    }
```

you get a NullReferenceException. I think such a filter should be allowed for grains that void result (Task).
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5563</IssueLabelID>
    <Title>AsyncLocal values flow into timer callbacks and stream observers</Title>
    <Description>The values of AsyncLocals will flow into timer callbacks and stream observers from their registration point. RequestContext uses an AsyncLocal to manage properties which is probably why they are like this but it shouldn't affect all AsyncLocals.

This is quite unintuitive for me because I would only expect these to flow whenever I call an async method.

In my project `Trace.Begin` will initialize an AsyncLocal and disposing it will set it back to null.  `$1` is the grain instance and `$2` is the value that was stored in the AsyncLocal (which has been cleared to null).
![](https://files.gitter.im/dotnet/orleans/Kc98/image.png)

When the timer callback is called I see the AsyncLocal value from the point of registration.
![](https://files.gitter.im/dotnet/orleans/n3hk/image.png)

Wrapping the timer registration with the following prevents the values from flowing through:
```csharp
using (ExecutionContext.SuppressFlow())
{
    // register things here ...
}
```</Description>
    <Title_Description>AsyncLocal values flow into timer callbacks and stream observers The values of AsyncLocals will flow into timer callbacks and stream observers from their registration point. RequestContext uses an AsyncLocal to manage properties which is probably why they are like this but it shouldn't affect all AsyncLocals.

This is quite unintuitive for me because I would only expect these to flow whenever I call an async method.

In my project `Trace.Begin` will initialize an AsyncLocal and disposing it will set it back to null.  `$1` is the grain instance and `$2` is the value that was stored in the AsyncLocal (which has been cleared to null).
![](https://files.gitter.im/dotnet/orleans/Kc98/image.png)

When the timer callback is called I see the AsyncLocal value from the point of registration.
![](https://files.gitter.im/dotnet/orleans/n3hk/image.png)

Wrapping the timer registration with the following prevents the values from flowing through:
```csharp
using (ExecutionContext.SuppressFlow())
{
    // register things here ...
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5562</IssueLabelID>
    <Title>request to add Chinese documents</Title>
    <Description>request to add Chinese documents</Description>
    <Title_Description>request to add Chinese documents request to add Chinese documents</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/04/2019 6:42:16 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5561</IssueLabelID>
    <Title>On the client close gateway connection to dead silos</Title>
    <Description>Fix for #5560 </Description>
    <Title_Description>On the client, close gateway connection to dead silos Fix for #5560 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5560</IssueLabelID>
    <Title>Client does not close connection to a dead Silo</Title>
    <Description>If a Silo stop responding to other silos for some reason it will be voted `Dead`. The silo in question will then shutdown itself closing all sockets.

Clients does not check for this status and instead just get the list of active gateways on a regular basis. If a silo has been voted `Dead` but for some reason its socket are still open clients will continue to send message to this faulty silo.</Description>
    <Title_Description>Client does not close connection to a dead Silo If a Silo stop responding to other silos for some reason it will be voted `Dead`. The silo in question will then shutdown itself closing all sockets.

Clients does not check for this status and instead just get the list of active gateways on a regular basis. If a silo has been voted `Dead` but for some reason its socket are still open clients will continue to send message to this faulty silo.</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5559</IssueLabelID>
    <Title>Update changelog for 2.3.1</Title>
    <Description>
    </Description>
    <Title_Description>Update changelog for 2.3.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5558</IssueLabelID>
    <Title>Hosting Silo as Azure App Service Throws Error</Title>
    <Description>I am facing issues when deploying Silo as Azure App Service it throws error when i request from client.</Description>
    <Title_Description>Hosting Silo as Azure App Service Throws Error I am facing issues when deploying Silo as Azure App Service it throws error when i request from client.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5557</IssueLabelID>
    <Title>implicit subscription not working on heterogeneous silos</Title>
    <Description>I have a heterogeneous silos environment. 
Silo1: GrainA class with an implicit subscription on the namespace 'topic'
Silo2: without GrainA

When the associated queue's pull-agent was activated on Silo2 the pull-agent can't obtain the GrainA information to complete `implicitPubSub.RegisterConsumer` and seems `ImplicitStreamSubscriberTable` was not transferred between silos. 

I'm also wondering that is it possible to make `ImplicitStreamSubscriptionAttribute` be able to apply to the grain interface? 
</Description>
    <Title_Description>implicit subscription not working on heterogeneous silos I have a heterogeneous silos environment. 
Silo1: GrainA class with an implicit subscription on the namespace 'topic'
Silo2: without GrainA

When the associated queue's pull-agent was activated on Silo2 the pull-agent can't obtain the GrainA information to complete `implicitPubSub.RegisterConsumer` and seems `ImplicitStreamSubscriberTable` was not transferred between silos. 

I'm also wondering that is it possible to make `ImplicitStreamSubscriptionAttribute` be able to apply to the grain interface? 
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5556</IssueLabelID>
    <Title>Specify Bond Serializer for the MsBuildTask</Title>
    <Description>Question...
How do I tell the MsBuildTask to use the Bond Serializer?

regards
rich</Description>
    <Title_Description>Specify Bond Serializer for the MsBuildTask Question...
How do I tell the MsBuildTask to use the Bond Serializer?

regards
rich</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5554</IssueLabelID>
    <Title>Cherry-picked fixes for 2.3.1</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked fixes for 2.3.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5553</IssueLabelID>
    <Title>Provide a Direct Client Example</Title>
    <Description>According to a comment to [a question of mine in SO](https://stackoverflow.com/questions/55832345/can-i-use-orleans-for-in-process-actors-grains?noredirect=1#comment98346266_55832345)

&gt; Yes it's possible out of the box in Orleans 2.3. They have a "hosted client" (sometimes referred to as a "direct client") in the service container by default. Unfortunately there are no docs for it yet. Additionally it looks like you're using Orleankka. I haven't looked at that library in detail so I'm not sure how configuration of the silo with a hosted client differs (if at all) from vanilla Orleans. 

Would be it possible to provide a simple example where two grains communicate with each other with that sort of direct client and the simplest silo possible ever I just want something to startup (note: not using Orleankka).</Description>
    <Title_Description>Provide a Direct Client Example According to a comment to [a question of mine in SO](https://stackoverflow.com/questions/55832345/can-i-use-orleans-for-in-process-actors-grains?noredirect=1#comment98346266_55832345)

&gt; Yes it's possible out of the box in Orleans 2.3. They have a "hosted client" (sometimes referred to as a "direct client") in the service container by default. Unfortunately there are no docs for it yet. Additionally it looks like you're using Orleankka. I haven't looked at that library in detail so I'm not sure how configuration of the silo with a hosted client differs (if at all) from vanilla Orleans. 

Would be it possible to provide a simple example where two grains communicate with each other with that sort of direct client and the simplest silo possible ever I just want something to startup (note: not using Orleankka).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5548</IssueLabelID>
    <Title>System.Collections.Generic.KeyNotFoundException: Type System.Collections.Generic.IList&lt;ZLHP.Message.Contract.Dtos.MessageDto&gt; does not have a member of kind Microsoft.CodeAnalysis.IMethodSymbol named GetAwaiter</Title>
    <Description>add a method generate code throw this exception
![image](https://user-images.githubusercontent.com/13807716/56658225-a76fe300-66cc-11e9-873a-24094935ba78.png)

![image](https://user-images.githubusercontent.com/13807716/56658178-8dce9b80-66cc-11e9-8c15-39b5a440a3dc.png)
</Description>
    <Title_Description>System.Collections.Generic.KeyNotFoundException: Type System.Collections.Generic.IList&lt;ZLHP.Message.Contract.Dtos.MessageDto&gt; does not have a member of kind Microsoft.CodeAnalysis.IMethodSymbol named GetAwaiter add a method generate code throw this exception
![image](https://user-images.githubusercontent.com/13807716/56658225-a76fe300-66cc-11e9-873a-24094935ba78.png)

![image](https://user-images.githubusercontent.com/13807716/56658178-8dce9b80-66cc-11e9-8c15-39b5a440a3dc.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5546</IssueLabelID>
    <Title>After enabling cleaning of dead entries occour NotImplementedException.</Title>
    <Description>Orleans Version is:2.3.0
Membership:Consul

SiloConfig:
`Configure&lt;ClusterMembershipOptions&gt;(options=&gt; options.DefunctSiloCleanupPeriod=TimeSpan.FromMinutes(3))`

After silo starts it prompts the following error:

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100662]
      DeleteDeadMembershipTableEntries operation is not supported by the current implementation of IMembershipTable. Disabling the timer now.</Description>
    <Title_Description>After enabling cleaning of dead entries occour NotImplementedException. Orleans Version is:2.3.0
Membership:Consul

SiloConfig:
`Configure&lt;ClusterMembershipOptions&gt;(options=&gt; options.DefunctSiloCleanupPeriod=TimeSpan.FromMinutes(3))`

After silo starts it prompts the following error:

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100662]
      DeleteDeadMembershipTableEntries operation is not supported by the current implementation of IMembershipTable. Disabling the timer now.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5544</IssueLabelID>
    <Title>Orleans Core Project - Host Silo or Client Using Azure </Title>
    <Description>Hi

I have created a project using .net core (console) for Silo and .net core (API) for Client. I am able to run using local development with Azure Storage Clustering but is there any helpful resources for deploying to cloud for .net core referenced projects.</Description>
    <Title_Description>Orleans Core Project - Host Silo or Client Using Azure  Hi

I have created a project using .net core (console) for Silo and .net core (API) for Client. I am able to run using local development with Azure Storage Clustering but is there any helpful resources for deploying to cloud for .net core referenced projects.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5542</IssueLabelID>
    <Title>Issues with stateless workers producing SMS stream events</Title>
    <Description>Events produced by stateless worker grains aren't always delivered to consumers for SMS.
Digging into this the problems seems to be related to the `SimpleMessageStreamProducerExtension`. When the worker first produces an event everything works fine. The extension is installed and it is registered with pub sub.
The problem starts when a new consumer is added and the pub sub tried to notify producers about it. Since it is a stateless worker the notification isn't guaranteed to go to the same activation. When it goes to a different one the extension isn't installed there and that causes the producer to become unregistered. This is still sort of ok until the original worker tries to produce a new event. At that point it still has the extension so it thinks it knows all of the consumers but it didn't get the previous notification and thus doesn't send to the new consumer.

If producing to SMS from a stateless worker isn't meant to be supported that is fine (I can workaround it) but from the surface I don't think anyone would expect it to not work.</Description>
    <Title_Description>Issues with stateless workers producing SMS stream events Events produced by stateless worker grains aren't always delivered to consumers for SMS.
Digging into this the problems seems to be related to the `SimpleMessageStreamProducerExtension`. When the worker first produces an event everything works fine. The extension is installed and it is registered with pub sub.
The problem starts when a new consumer is added and the pub sub tried to notify producers about it. Since it is a stateless worker the notification isn't guaranteed to go to the same activation. When it goes to a different one the extension isn't installed there and that causes the producer to become unregistered. This is still sort of ok until the original worker tries to produce a new event. At that point it still has the extension so it thinks it knows all of the consumers but it didn't get the previous notification and thus doesn't send to the new consumer.

If producing to SMS from a stateless worker isn't meant to be supported that is fine (I can workaround it) but from the surface I don't think anyone would expect it to not work.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5541</IssueLabelID>
    <Title>Get Grain from generic grain id through IGrainFactory</Title>
    <Description>I am currently developing an abstract base class for a set of worker grains that operate on a parent grain. I want to create a way to get the parent grain.

Here's a simple exmaple of what I'm doing:
```fs
[&lt;AbstractClass&gt;]
type GrainWorker&lt;'grain when 'grain :&gt; IGrain&gt; () =
    inherit Grain ()

    member this.ParentGrain () = this.GrainFactory.GetGrain&lt;'grain&gt; (this.GetPrimaryKey ())

type IUserGrain =
    inherit IGrainWithGuidKey

type IUserWorkerGrain =
    inherit IGrainWithGuidKey

type UserGrainWorker () =
    inherit GrainWorker&lt;IUserGrain&gt; ()
```
Note that in the scenario above `this.GetPrimaryKey ()` returns a Guid key so GrainWorker would only work for Guid grains. I want to have a way to do this operation in a generic manner without having to duplicate tons of code.

Based off of my minor research it seems like the IInternalGrainFactory methods would be useful in this case but this interface is marked as internal.

As @ReubenBond noted in the Gitter chat issue #1511 is related to this.</Description>
    <Title_Description>Get Grain from generic grain id through IGrainFactory I am currently developing an abstract base class for a set of worker grains that operate on a parent grain. I want to create a way to get the parent grain.

Here's a simple exmaple of what I'm doing:
```fs
[&lt;AbstractClass&gt;]
type GrainWorker&lt;'grain when 'grain :&gt; IGrain&gt; () =
    inherit Grain ()

    member this.ParentGrain () = this.GrainFactory.GetGrain&lt;'grain&gt; (this.GetPrimaryKey ())

type IUserGrain =
    inherit IGrainWithGuidKey

type IUserWorkerGrain =
    inherit IGrainWithGuidKey

type UserGrainWorker () =
    inherit GrainWorker&lt;IUserGrain&gt; ()
```
Note that in the scenario above `this.GetPrimaryKey ()` returns a Guid key so GrainWorker would only work for Guid grains. I want to have a way to do this operation in a generic manner without having to duplicate tons of code.

Based off of my minor research it seems like the IInternalGrainFactory methods would be useful in this case but this interface is marked as internal.

As @ReubenBond noted in the Gitter chat issue #1511 is related to this.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5540</IssueLabelID>
    <Title>Analyzer/CodeGen: block usage of [AlwaysInterleave] on class method</Title>
    <Description>`[AlwaysInterleave]` must only be used on the grain *interface* method and not the grain class method.

Users can accidentally add this attribute (and others) in the wrong place and we currently have no way to warn them or stop them.

Add a misuse error to a new analyzer package (better) or to the code generator (easier since the code generator exists).

See also #2841</Description>
    <Title_Description>Analyzer/CodeGen: block usage of [AlwaysInterleave] on class method `[AlwaysInterleave]` must only be used on the grain *interface* method and not the grain class method.

Users can accidentally add this attribute (and others) in the wrong place and we currently have no way to warn them or stop them.

Add a misuse error to a new analyzer package (better) or to the code generator (easier since the code generator exists).

See also #2841</Title_Description>
    <Label>help wanted</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>17/04/2019 4:46:41 AM +00:00</CreatedAt>
    <ClosedAt>9/05/2019 4:47:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5539</IssueLabelID>
    <Title>Dropped fluent support for Named Service Configurator</Title>
    <Description>Note: this will likely break our load and bc tests.  Working on fixes.</Description>
    <Title_Description>Dropped fluent support for Named Service Configurator Note: this will likely break our load and bc tests.  Working on fixes.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5538</IssueLabelID>
    <Title>Skip Dispose for skipped streaming tests</Title>
    <Description>When a test is skipped due to a precondition check failure there is a `NullReferenceException` thrown in `Dispose` because initialization has not occurred.

This avoids the Dispose logic in some streaming tests when initialization did not occur.</Description>
    <Title_Description>Skip Dispose for skipped streaming tests When a test is skipped due to a precondition check failure there is a `NullReferenceException` thrown in `Dispose` because initialization has not occurred.

This avoids the Dispose logic in some streaming tests when initialization did not occur.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5537</IssueLabelID>
    <Title>Consul cluster problem</Title>
    <Description>An consul was used to do the cluster to start two silo instances: siloA and siloB but when the siloA instance was shut down the entire service access failed and the siloB kept trying to connect to siloA.How to solve?Thank you very much!</Description>
    <Title_Description>Consul cluster problem An consul was used to do the cluster to start two silo instances: siloA and siloB but when the siloA instance was shut down the entire service access failed and the siloB kept trying to connect to siloA.How to solve?Thank you very much!</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5536</IssueLabelID>
    <Title>Bug report. StartupTasks will activate the same Grain multiple times</Title>
    <Description>Some users have confirmed this bug:
start multiple Silos (one adonet cluster) separately their StartupTasks might result in multiple activation of the same Grain instance demo see below.
https://github.com/slango0513/OrleansBugs
It happens about 2 to 3 times every 5 times.

![D0AC9FCEB66868B68E1F5636F7F41243](https://user-images.githubusercontent.com/39337503/56191515-0f845080-605f-11e9-9ba2-2bb68423908c.png)

![F37A4E45334A01045C5540F0E54726D6](https://user-images.githubusercontent.com/39337503/56191524-13b06e00-605f-11e9-81aa-52f2bdbefda8.png)
</Description>
    <Title_Description>Bug report. StartupTasks will activate the same Grain multiple times Some users have confirmed this bug:
start multiple Silos (one adonet cluster) separately their StartupTasks might result in multiple activation of the same Grain instance demo see below.
https://github.com/slango0513/OrleansBugs
It happens about 2 to 3 times every 5 times.

![D0AC9FCEB66868B68E1F5636F7F41243](https://user-images.githubusercontent.com/39337503/56191515-0f845080-605f-11e9-9ba2-2bb68423908c.png)

![F37A4E45334A01045C5540F0E54726D6](https://user-images.githubusercontent.com/39337503/56191524-13b06e00-605f-11e9-81aa-52f2bdbefda8.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5535</IssueLabelID>
    <Title>Fixed build break caused to non-conflicting merge</Title>
    <Description>
    </Description>
    <Title_Description>Fixed build break caused to non-conflicting merge </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5534</IssueLabelID>
    <Title>NullReferenceException in deserialization when mixing serializers</Title>
    <Description>Hi I have a strange case.

I have an EventConsumerGrain that retrieves events from an event sourcing database and calls an IEventConsumer.

One of these consumers throws a NullReferenceException:

```
System.NullReferenceException: Object reference not set to an instance of an object.
   at Squidex.Domain.Apps.Entities.Contents.Text.GrainTextIndexer.On(Envelope`1 event) in /src/src/Squidex.Domain.Apps.Entities/Contents/Text/GrainTextIndexer.cs:line 68
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.DispatchConsumerAsync(Envelope`1 event) in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 232
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.&lt;&gt;c__DisplayClass10_0.&lt;&lt;OnEventAsync&gt;b__0&gt;d.MoveNext() in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.DoAndUpdateStateAsync(Func`1 action String caller) in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 165
```

The code where the exception is thrown:

https://github.com/Squidex/squidex/blob/master/src/Squidex.Domain.Apps.Entities/Contents/Text/GrainTextIndexer.cs#L68

As you can see there is only a reference to the grain. The content event cannot be null because of the pattern matching.

If I scale down the cluster to 1 it works so I guess it has something to do with the remote call. But I do not receive details.

EDIT: I am not sure yet but I would say that it only happens under load e.g. when many requests per second are done (~100)</Description>
    <Title_Description>NullReferenceException in deserialization when mixing serializers Hi I have a strange case.

I have an EventConsumerGrain that retrieves events from an event sourcing database and calls an IEventConsumer.

One of these consumers throws a NullReferenceException:

```
System.NullReferenceException: Object reference not set to an instance of an object.
   at Squidex.Domain.Apps.Entities.Contents.Text.GrainTextIndexer.On(Envelope`1 event) in /src/src/Squidex.Domain.Apps.Entities/Contents/Text/GrainTextIndexer.cs:line 68
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.DispatchConsumerAsync(Envelope`1 event) in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 232
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.&lt;&gt;c__DisplayClass10_0.&lt;&lt;OnEventAsync&gt;b__0&gt;d.MoveNext() in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
   at Squidex.Infrastructure.EventSourcing.Grains.EventConsumerGrain.DoAndUpdateStateAsync(Func`1 action String caller) in /src/src/Squidex.Infrastructure/EventSourcing/Grains/EventConsumerGrain.cs:line 165
```

The code where the exception is thrown:

https://github.com/Squidex/squidex/blob/master/src/Squidex.Domain.Apps.Entities/Contents/Text/GrainTextIndexer.cs#L68

As you can see there is only a reference to the grain. The content event cannot be null because of the pattern matching.

If I scale down the cluster to 1 it works so I guess it has something to do with the remote call. But I do not receive details.

EDIT: I am not sure yet but I would say that it only happens under load e.g. when many requests per second are done (~100)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5532</IssueLabelID>
    <Title>Serialize grains into memory to avoid GC pressure</Title>
    <Description>Serialize grains to native or GC handled memory to avoid GC pressure (long GC pauses). This article provides similar approach
https://www.infoq.com/articles/Big-Memory-Part-1
https://www.infoq.com/articles/Big-Memory-Part-2

It could go something like this
- Serialize grain to memory after inactivity timeout or if there is high amount of live grains
- Deserialize grain if it activates or remove serialized grain from memory after another inactivity timeout
</Description>
    <Title_Description>Serialize grains into memory to avoid GC pressure Serialize grains to native or GC handled memory to avoid GC pressure (long GC pauses). This article provides similar approach
https://www.infoq.com/articles/Big-Memory-Part-1
https://www.infoq.com/articles/Big-Memory-Part-2

It could go something like this
- Serialize grain to memory after inactivity timeout or if there is high amount of live grains
- Deserialize grain if it activates or remove serialized grain from memory after another inactivity timeout
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5531</IssueLabelID>
    <Title>Direct Client Orleans 2.2</Title>
    <Description>Hello 
I‘m trying to get my head around using DirectClient which is mentioned in the 2.1 release notes. Looking into the sources of 2.2 it seems like it is already obsolete again. Is there any replacement or how is this feature meant to use?</Description>
    <Title_Description>Direct Client Orleans 2.2 Hello 
I‘m trying to get my head around using DirectClient which is mentioned in the 2.1 release notes. Looking into the sources of 2.2 it seems like it is already obsolete again. Is there any replacement or how is this feature meant to use?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5530</IssueLabelID>
    <Title>Add codegen error for non-awaitable grain interface methods</Title>
    <Description>
    </Description>
    <Title_Description>Add codegen error for non-awaitable grain interface methods </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5529</IssueLabelID>
    <Title>Can the transaction state provider use other databases or redis? Does the official have any plans for this?</Title>
    <Description>For `.UseTransactions()` to work you need to add a transactional state provider - one that implements `ITransactionalStateStorage&lt;TState&gt;`. `AddAdoNetGrainStorage` doesn't do that. We currently have a provider for Azure Table that you can add with `AddAzureTableTransactionalStateStorage()`. Alternatively you can create and add your own provider.

_Originally posted by @sergeybykov in https://github.com/dotnet/orleans/issues/5125#issuecomment-433463902_

-------------------------------------------------------------------------------------
Can the transaction state provider use other databases or redis? Does the official have any plans for this?
</Description>
    <Title_Description>Can the transaction state provider use other databases or redis? Does the official have any plans for this? For `.UseTransactions()` to work you need to add a transactional state provider - one that implements `ITransactionalStateStorage&lt;TState&gt;`. `AddAdoNetGrainStorage` doesn't do that. We currently have a provider for Azure Table that you can add with `AddAzureTableTransactionalStateStorage()`. Alternatively you can create and add your own provider.

_Originally posted by @sergeybykov in https://github.com/dotnet/orleans/issues/5125#issuecomment-433463902_

-------------------------------------------------------------------------------------
Can the transaction state provider use other databases or redis? Does the official have any plans for this?
</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5528</IssueLabelID>
    <Title>Cleanup pass of named service configurator</Title>
    <Description>- Removed component configurator abstraction as it forced duplication of methods in client and silo.
- Reduced NamedServiceConfigurator to a minimal class and moved all behaviors to extension functions.
- Removed duplicate extention functions for azure queue and eventhub streams (these were causing build breaks do to bugs in tooling.
- Public surfaces of all supported streams unchanged (except they build even with tooling bugs) but direct use of base builders like SiloPersistentStreamConfigurator is more awkward.</Description>
    <Title_Description>Cleanup pass of named service configurator - Removed component configurator abstraction as it forced duplication of methods in client and silo.
- Reduced NamedServiceConfigurator to a minimal class and moved all behaviors to extension functions.
- Removed duplicate extention functions for azure queue and eventhub streams (these were causing build breaks do to bugs in tooling.
- Public surfaces of all supported streams unchanged (except they build even with tooling bugs) but direct use of base builders like SiloPersistentStreamConfigurator is more awkward.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5527</IssueLabelID>
    <Title>Add RabbitMQ as a Stream Provider</Title>
    <Description>This is my first significant PR and I think I got some stuff wrong but I wanted to submit it as a draft and work through the feedback while it's still a WIP.

## RabbitMQ Stream Provider

This implements all of the Stream Provider interfaces for formal RabbitMQ support. My team and I (@zednis et al) have a use case for RabbitMQ and since I were going to implement it for our use cases it seemed better to donate the effort for others.

### TODO

I need to address these items before it's ready for a more formal review. Also please let me know if there's anything major I'm missing that's not covered under the list below.

- [ ] Write tests

I used the GCP PubSub provider as the reference item and I saw the tests in the original PR but they've moved locations and I cannot find them. I will also need a way to require RabbitMQ to be available so the test suite can be run. I would love some advice in this area because I'd like for folks to be able to do local testing. RabbitMQ server is licensed with the Mozilla Public License 1.1 so there should be no distribution concerns when working with the RabbitMQ server binaries.

- [ ] Pull design pattern

The C# RabbitMQ client is designed to be very simple with a totally hidden implementation. As part of that it when I was working through the implementation it felt really clunky and didn't seem to mesh well with the current provider interface designs for Stream Providers. I would love to hear some feedback on the design pattern that I used to make sure it feels _right_ because it feels a bit wrong to me. Some of this is likely because of the RabbitMQ client implementation but I'd love some more constructive feedback on the topic.

- [ ] Pushing API?

Are there any plans for a more asynchronous queue layer? RabbitMQ is a provider that would benefit from that as there is first class support for pushing messages to the client.

- [ ] AMQP Interfaces?

Are there any plans for an interface that's a bit closer to the core AMQP design patterns? It would've been super useful to be able to have backend primitives/interfaces that were much more closely aligned with Exchanges Queues Dead Lettering etc.

- [ ] Nuget Package

I need to make a Nuget package out of this but I'm not sure how that works.

- [ ] Error Codes?

The GCP provider has error codes. I didn't implement any specific error codes is that something I need to do? If so is there guidance on how to go about that?

- [ ] Namespace

I didn't know what to put for the namespace so I put `Orleans.Providers.RabbitMQ.Streams.RabbitMQ`. There's no real reason (from my perspective) you can't use RabbitMQ for cluster membership and health checks so it could be used in other ways. RabbitMQ is owned by my former employer Pivotal but I do not represent them and I didn't feel comfortable with `Orleans.Providers.Pivotal.Streams.RabbitMQ` at the time. I'm happy to fix the namespacing to whatever the group things.

Edit: namespace comments.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Description>
    <Title_Description>Add RabbitMQ as a Stream Provider This is my first significant PR and I think I got some stuff wrong but I wanted to submit it as a draft and work through the feedback while it's still a WIP.

## RabbitMQ Stream Provider

This implements all of the Stream Provider interfaces for formal RabbitMQ support. My team and I (@zednis et al) have a use case for RabbitMQ and since I were going to implement it for our use cases it seemed better to donate the effort for others.

### TODO

I need to address these items before it's ready for a more formal review. Also please let me know if there's anything major I'm missing that's not covered under the list below.

- [ ] Write tests

I used the GCP PubSub provider as the reference item and I saw the tests in the original PR but they've moved locations and I cannot find them. I will also need a way to require RabbitMQ to be available so the test suite can be run. I would love some advice in this area because I'd like for folks to be able to do local testing. RabbitMQ server is licensed with the Mozilla Public License 1.1 so there should be no distribution concerns when working with the RabbitMQ server binaries.

- [ ] Pull design pattern

The C# RabbitMQ client is designed to be very simple with a totally hidden implementation. As part of that it when I was working through the implementation it felt really clunky and didn't seem to mesh well with the current provider interface designs for Stream Providers. I would love to hear some feedback on the design pattern that I used to make sure it feels _right_ because it feels a bit wrong to me. Some of this is likely because of the RabbitMQ client implementation but I'd love some more constructive feedback on the topic.

- [ ] Pushing API?

Are there any plans for a more asynchronous queue layer? RabbitMQ is a provider that would benefit from that as there is first class support for pushing messages to the client.

- [ ] AMQP Interfaces?

Are there any plans for an interface that's a bit closer to the core AMQP design patterns? It would've been super useful to be able to have backend primitives/interfaces that were much more closely aligned with Exchanges Queues Dead Lettering etc.

- [ ] Nuget Package

I need to make a Nuget package out of this but I'm not sure how that works.

- [ ] Error Codes?

The GCP provider has error codes. I didn't implement any specific error codes is that something I need to do? If so is there guidance on how to go about that?

- [ ] Namespace

I didn't know what to put for the namespace so I put `Orleans.Providers.RabbitMQ.Streams.RabbitMQ`. There's no real reason (from my perspective) you can't use RabbitMQ for cluster membership and health checks so it could be used in other ways. RabbitMQ is owned by my former employer Pivotal but I do not represent them and I didn't feel comfortable with `Orleans.Providers.Pivotal.Streams.RabbitMQ` at the time. I'm happy to fix the namespacing to whatever the group things.

Edit: namespace comments.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5526</IssueLabelID>
    <Title>[WIP] Remove catalog activations locking</Title>
    <Description>
    </Description>
    <Title_Description>[WIP] Remove catalog activations locking </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5525</IssueLabelID>
    <Title>Remove locking in LocalGrainDirectory</Title>
    <Description>
    </Description>
    <Title_Description>Remove locking in LocalGrainDirectory </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5524</IssueLabelID>
    <Title>How to know whether a transaction is over or not.</Title>
    <Description>Is there any way to find out a transaction is over or not with transaction id?</Description>
    <Title_Description>How to know whether a transaction is over or not. Is there any way to find out a transaction is over or not with transaction id?</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5523</IssueLabelID>
    <Title>Orleans stalled</Title>
    <Description>Hi
We have a project that use Microsoft Orleans 2.2 in .Net Framework 4.7.1 and SQL server as Storage.
When we load test it it always fails at the 4th day that it stop responding any new requests and CPU usage in almost 0 while the number of threads gets increased heavily.
The failure messages at the log :
[2019-04-10 20:06:29.125 GMT 13	Warning	101215	Orleans.Runtime.Scheduler.WorkItemGroup]	Task [Id=77224074 Status=RanToCompletion] in WorkGroup [Activation: S10.1.0.5:11111:292432306*grn/8C9EE89/000026cf@38040cb6 #GrainType=Softec.FMS.Orleans.Implementation.Grains.RawDataSaverGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.8558401 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:01:19.4272142 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:06:20.726 GMT 00:01:17.7906305 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:05:41.0251127 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:07:38.517 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:09:07.479 GMT 17678	Warning	100157	Orleans.Runtime.CallbackData]	Response did not arrive on time in 00:00:30 for message: Request S10.1.0.5:11111:292432306*grn/7C16CD43/00000000+357454074159300@e982059b-&gt;S10.1.0.5:11111:292432306*grn/7C16CD43/00000000+357454074159300@e982059b #607940229: . Target History is: &lt;S10.1.0.5:11111:292432306:*grn/7C16CD43/00000000+357454074159300:@e982059b&gt;. About to break its promise.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:06:19.4374713 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:06:20.726 GMT 00:06:17.8008876 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:10:41.0353698 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:12:38.527 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:11:19.4845859 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:02:54.5922485 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:15:41.0824844 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:17:38.574 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:16:19.5256852 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:07:54.6333478 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:20:41.1235837 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:22:38.616 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:21:20.4096932 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:12:55.5173558 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:25:42.0075917 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:27:39.500 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:26:20.5445034 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:17:55.6521660 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:30:42.1424019 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:32:39.634 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	


You can kindly find attached the full Log
[Log.zip](https://github.com/dotnet/orleans/files/3066064/Log.zip)

</Description>
    <Title_Description>Orleans stalled Hi
We have a project that use Microsoft Orleans 2.2 in .Net Framework 4.7.1 and SQL server as Storage.
When we load test it it always fails at the 4th day that it stop responding any new requests and CPU usage in almost 0 while the number of threads gets increased heavily.
The failure messages at the log :
[2019-04-10 20:06:29.125 GMT 13	Warning	101215	Orleans.Runtime.Scheduler.WorkItemGroup]	Task [Id=77224074 Status=RanToCompletion] in WorkGroup [Activation: S10.1.0.5:11111:292432306*grn/8C9EE89/000026cf@38040cb6 #GrainType=Softec.FMS.Orleans.Implementation.Grains.RawDataSaverGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.8558401 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:01:19.4272142 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:06:20.726 GMT 00:01:17.7906305 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:07:38.517 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:05:41.0251127 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:07:38.517 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:09:07.479 GMT 17678	Warning	100157	Orleans.Runtime.CallbackData]	Response did not arrive on time in 00:00:30 for message: Request S10.1.0.5:11111:292432306*grn/7C16CD43/00000000+357454074159300@e982059b-&gt;S10.1.0.5:11111:292432306*grn/7C16CD43/00000000+357454074159300@e982059b #607940229: . Target History is: &lt;S10.1.0.5:11111:292432306:*grn/7C16CD43/00000000+357454074159300:@e982059b&gt;. About to break its promise.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:06:19.4374713 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:06:20.726 GMT 00:06:17.8008876 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:12:38.527 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:10:41.0353698 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:12:38.527 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:11:19.4845859 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:02:54.5922485 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:17:38.574 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:15:41.0824844 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:17:38.574 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:16:19.5256852 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:07:54.6333478 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:22:38.616 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:20:41.1235837 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:22:38.616 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:21:20.4096932 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:12:55.5173558 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:27:39.500 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:25:42.0075917 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:27:39.500 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ReadTableTimer did not fire on time. Last fired at 2019-04-10 20:06:19.090 GMT 00:26:20.5445034 since previous fire should have fired after 00:01:00.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. Last fired at 2019-04-10 20:14:43.982 GMT 00:17:55.6521660 since previous fire should have fired after 00:00:10.	
[2019-04-10 20:32:39.634 GMT 37	Error	101412	Orleans.Runtime.GrainTimer]	!!!!!!!!!! Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. Last fired at 2019-04-10 20:01:57.492 GMT 00:30:42.1424019 since previous fire should have fired after 00:05:00.	
[2019-04-10 20:32:39.634 GMT 37	Warning	102603	Orleans.Runtime.Watchdog]	Watchdog had 1 Health Check Failure(s) out of 2 Health Check Participants.	


You can kindly find attached the full Log
[Log.zip](https://github.com/dotnet/orleans/files/3066064/Log.zip)

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5522</IssueLabelID>
    <Title>Fix #5519: use local silo as default primary silo</Title>
    <Description>Fixes #5519</Description>
    <Title_Description>Fix #5519: use local silo as default primary silo Fixes #5519</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5520</IssueLabelID>
    <Title>how to get the dbContext  is always new when call the grain</Title>
    <Description># version info:
Orleans : 2.3.0
EF Core:2.2.3

```csharp
services.AddDbContextPool&lt;TestContext&gt;(options =&gt;
{
	options.UseSqlServer("");
});
```

```csharp
    public class TestGrain : GrainITest
    {
        private  TestContext _testContext;

        public TestGrain(TestContext testContext)
        {
            _testContext = testContext;
        }

        public void Test()
        {
            var testContext = ServiceProvider.GetRequiredService&lt;TestContext&gt;();
        }
    }
```

I used the above 2 ways to get the context I got the context used in the last call not a new context.

</Description>
    <Title_Description>how to get the dbContext  is always new when call the grain # version info:
Orleans : 2.3.0
EF Core:2.2.3

```csharp
services.AddDbContextPool&lt;TestContext&gt;(options =&gt;
{
	options.UseSqlServer("");
});
```

```csharp
    public class TestGrain : GrainITest
    {
        private  TestContext _testContext;

        public TestGrain(TestContext testContext)
        {
            _testContext = testContext;
        }

        public void Test()
        {
            var testContext = ServiceProvider.GetRequiredService&lt;TestContext&gt;();
        }
    }
```

I used the above 2 ways to get the context I got the context used in the last call not a new context.

</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5518</IssueLabelID>
    <Title>Docker setup with local host clustering making a request to localhost</Title>
    <Description>Hi 

I have a setup variation with docker and basically no clustering. I only use the direct client with co-hosting. But some process seems to make a request to localhost and fails. 

	"exception": {
		"type": "System.TimeoutException"
		"message": "Connection to 127.0.0.1:11111 could not be established in 00:00:05"
		"stackTrace": "   at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)\n   at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)\n   at Orleans.Runtime.LRU`2.Get(TKey key)\n   at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)"
	}

I am not sure why this request is done and how to prevent it.

After that I see a lot of these messages:

	"exception": {
		"type": "System.NullReferenceException"
		"message": "Object reference not set to an instance of an object."
		"stackTrace": "   at Orleans.Runtime.InsideRuntimeClient.OnCallbackExpiryTick(Object state)\n   at Orleans.Runtime.SafeTimerBase.HandleSyncTimerCallback(Object state)"
	}

Not sure if they are related but I would like to get rid of them.</Description>
    <Title_Description>Docker setup with local host clustering making a request to localhost Hi 

I have a setup variation with docker and basically no clustering. I only use the direct client with co-hosting. But some process seems to make a request to localhost and fails. 

	"exception": {
		"type": "System.TimeoutException"
		"message": "Connection to 127.0.0.1:11111 could not be established in 00:00:05"
		"stackTrace": "   at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)\n   at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)\n   at Orleans.Runtime.LRU`2.Get(TKey key)\n   at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)"
	}

I am not sure why this request is done and how to prevent it.

After that I see a lot of these messages:

	"exception": {
		"type": "System.NullReferenceException"
		"message": "Object reference not set to an instance of an object."
		"stackTrace": "   at Orleans.Runtime.InsideRuntimeClient.OnCallbackExpiryTick(Object state)\n   at Orleans.Runtime.SafeTimerBase.HandleSyncTimerCallback(Object state)"
	}

Not sure if they are related but I would like to get rid of them.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5517</IssueLabelID>
    <Title>Orleans silo windows service Log</Title>
    <Description>hi 
how to configure Orleans silo to Log its error and Trace its problem ?</Description>
    <Title_Description>Orleans silo windows service Log hi 
how to configure Orleans silo to Log its error and Trace its problem ?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5516</IssueLabelID>
    <Title>Event Sourcing does not work in calling grain within a grain</Title>
    <Description>Hi
I have a problem with event sourcing. when i call grains in client it works well and save data in db such as this (in mu code):
```csharp
var command = new CountryUpdateCommand { Id = model.Id Name = model.Name };
var countryGrain = _client.GetGrain&lt;ICountryEventSourceCommandService&gt;(OrleansConstants.CountryGrainId);
await countryGrain.SendCommand&lt;Country CountryUpdated&gt;(command);
```
but when i call this grain in another grains it does not work and call events such as:
```csharp
public async Task&lt;StateProvince&gt; Handle(StateProvinceInsertCommand request CancellationToken cancellationToken)
{
            var entity = request.ToEntity&lt;StateProvince&gt;();
            await _stateProvinceRepository.InsertAndSaveChangesAsync(entity);
            request.Id = entity.Id;


            var countryGrain = _grainFactory.GetGrain&lt;IGrainCountryService&gt;(OrleansConstants.CountryGrainId);
            var country = await countryGrain.GetByIdAsync(request.CountryId);

            //convert to command
            var countryCmd = country.ToCommand&lt;CountryUpdateCommand&gt;();
            countryCmd.DisplayOrder = countryCmd.DisplayOrder + 1;

            var countryCqlrsGrain = _grainFactory.GetGrain&lt;ICountryEventSourceCommandService&gt;(Guid.NewGuid());
            await countryCqlrsGrain.SendCommand(countryCmd cancellationToken);

            return entity;
}
```
how can i call the CountryGrain in this code to use event sourcing and save states?
Thanks</Description>
    <Title_Description>Event Sourcing does not work in calling grain within a grain Hi
I have a problem with event sourcing. when i call grains in client it works well and save data in db such as this (in mu code):
```csharp
var command = new CountryUpdateCommand { Id = model.Id Name = model.Name };
var countryGrain = _client.GetGrain&lt;ICountryEventSourceCommandService&gt;(OrleansConstants.CountryGrainId);
await countryGrain.SendCommand&lt;Country CountryUpdated&gt;(command);
```
but when i call this grain in another grains it does not work and call events such as:
```csharp
public async Task&lt;StateProvince&gt; Handle(StateProvinceInsertCommand request CancellationToken cancellationToken)
{
            var entity = request.ToEntity&lt;StateProvince&gt;();
            await _stateProvinceRepository.InsertAndSaveChangesAsync(entity);
            request.Id = entity.Id;


            var countryGrain = _grainFactory.GetGrain&lt;IGrainCountryService&gt;(OrleansConstants.CountryGrainId);
            var country = await countryGrain.GetByIdAsync(request.CountryId);

            //convert to command
            var countryCmd = country.ToCommand&lt;CountryUpdateCommand&gt;();
            countryCmd.DisplayOrder = countryCmd.DisplayOrder + 1;

            var countryCqlrsGrain = _grainFactory.GetGrain&lt;ICountryEventSourceCommandService&gt;(Guid.NewGuid());
            await countryCqlrsGrain.SendCommand(countryCmd cancellationToken);

            return entity;
}
```
how can i call the CountryGrain in this code to use event sourcing and save states?
Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5514</IssueLabelID>
    <Title>Enable TransactionalStateStorageTestRunner to test with custom type</Title>
    <Description>TransactionalStateStorageTestRunner was hard coded to test manipulating integer state only. This PR enable it to test with any type as long as the type is a reference type and implements `IEquatable`. To use this users must do followings
- The custom type must implement `IEquatable` and user should inject the custom type's validation logic through `IEquatable`. 
- the `Func&lt;TState&gt; stateFactory` feeded to `TransactionalStateStorageTestRunner ` constructor should return a different value each time to ensure test coverage. </Description>
    <Title_Description>Enable TransactionalStateStorageTestRunner to test with custom type TransactionalStateStorageTestRunner was hard coded to test manipulating integer state only. This PR enable it to test with any type as long as the type is a reference type and implements `IEquatable`. To use this users must do followings
- The custom type must implement `IEquatable` and user should inject the custom type's validation logic through `IEquatable`. 
- the `Func&lt;TState&gt; stateFactory` feeded to `TransactionalStateStorageTestRunner ` constructor should return a different value each time to ensure test coverage. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5513</IssueLabelID>
    <Title>Design pattern for starting and not blocking on long running task but notified of completion</Title>
    <Description>Hello

I have a use case where a Grain may want to kick off a long running operation and I want to be notified of its completion but don’t want to block (even via await’ing a thread pool task) the long running operation so the Grain can continue to respond to other messages.

I’m thinking I need to have this Grain maybe queue a message in a regular job/service bus queue with the Id of the Grain who asked for the long running task to be performed have a non-Orleans worker process do that task.

When the task is complete send a message back to the Grain.

Am I on the right track?</Description>
    <Title_Description>Design pattern for starting and not blocking on long running task, but notified of completion Hello

I have a use case where a Grain may want to kick off a long running operation and I want to be notified of its completion but don’t want to block (even via await’ing a thread pool task) the long running operation so the Grain can continue to respond to other messages.

I’m thinking I need to have this Grain maybe queue a message in a regular job/service bus queue with the Id of the Grain who asked for the long running task to be performed have a non-Orleans worker process do that task.

When the task is complete send a message back to the Grain.

Am I on the right track?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5512</IssueLabelID>
    <Title>AzureTableClusteringExtensions does not provide access to the HostBuilderContext</Title>
    <Description>When initializing my silo under ServiceFabric I am doing the following:
```
            var listener = OrleansServiceListener.CreateStateless(

                (fabricServiceContext builder) =&gt;
                {
                    builder.Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ServiceId = fabricServiceContext.ServiceName.ToString();
                        options.ClusterId = "development";
                    });


                    builder.UseAzureStorageClustering(options =&gt; options.ConnectionString = "UseDevelopmentStorage=true");
                    builder.ConfigureLogging(ConfigureLogging);
                    builder.ConfigureAppConfiguration(ConfigureAppConfiguration);
                    builder.ConfigureServices(ConfigureServices);
                    var activation = fabricServiceContext.CodePackageActivationContext;
                    var endpoints = activation.GetEndpoints();
                    var siloEndpoint = endpoints["OrleansSiloEndpoint"];
                    var gatewayEndpoint = endpoints["OrleansProxyEndpoint"];
                    var hostname = fabricServiceContext.NodeContext.IPAddressOrFQDN;
                    builder.ConfigureEndpoints(hostname siloEndpoint.Port gatewayEndpoint.Port);

                    builder.ConfigureApplicationParts(parts =&gt;
                    {
                        parts.AddApplicationPart(typeof(Application).Assembly).WithReferences();
                    });

                });
```
```ConfigureAppConfiguration``` initializes an ```IConfiguration``` which I can access from the ```HostBuilderContext``` for a number of functions such as ```ConfigureServices```. Unfortunately ```UseAzureStorageClustering``` does not have the context and I cannot access my connection string coming off the ```IConfiguration``` unless I double build the configuration and store it in a variable (which sucks).

Does anyone have any insights into how I can maintain a clean initialization sequence without requiring extraneous variables?

rich</Description>
    <Title_Description>AzureTableClusteringExtensions does not provide access to the HostBuilderContext When initializing my silo under ServiceFabric I am doing the following:
```
            var listener = OrleansServiceListener.CreateStateless(

                (fabricServiceContext builder) =&gt;
                {
                    builder.Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ServiceId = fabricServiceContext.ServiceName.ToString();
                        options.ClusterId = "development";
                    });


                    builder.UseAzureStorageClustering(options =&gt; options.ConnectionString = "UseDevelopmentStorage=true");
                    builder.ConfigureLogging(ConfigureLogging);
                    builder.ConfigureAppConfiguration(ConfigureAppConfiguration);
                    builder.ConfigureServices(ConfigureServices);
                    var activation = fabricServiceContext.CodePackageActivationContext;
                    var endpoints = activation.GetEndpoints();
                    var siloEndpoint = endpoints["OrleansSiloEndpoint"];
                    var gatewayEndpoint = endpoints["OrleansProxyEndpoint"];
                    var hostname = fabricServiceContext.NodeContext.IPAddressOrFQDN;
                    builder.ConfigureEndpoints(hostname siloEndpoint.Port gatewayEndpoint.Port);

                    builder.ConfigureApplicationParts(parts =&gt;
                    {
                        parts.AddApplicationPart(typeof(Application).Assembly).WithReferences();
                    });

                });
```
```ConfigureAppConfiguration``` initializes an ```IConfiguration``` which I can access from the ```HostBuilderContext``` for a number of functions such as ```ConfigureServices```. Unfortunately ```UseAzureStorageClustering``` does not have the context and I cannot access my connection string coming off the ```IConfiguration``` unless I double build the configuration and store it in a variable (which sucks).

Does anyone have any insights into how I can maintain a clean initialization sequence without requiring extraneous variables?

rich</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5510</IssueLabelID>
    <Title>Stream messages not reaching all client-based subscribers</Title>
    <Description>I have a problem whereby some stream subscribers are not receiving messages published to that stream.

Our system is set up with Web API REST endpoints which use an Orleans IClusterClient to access boundary grains.  These grains hand off the process to internal grains some of which are stateless workers and eventually this will result in a message being published to a Simple Message Provider stream.  When invoked the Web API controllers subscribe to this stream via a singleton IClusterClient and the handler for this subscription returns the result back to the caller.  We pass a correlation Id (Guid) into the Orleans.RequestContext and check this in the stream handler to confirm we're processing the correct message.  All streams use the same Guid (Guid.Empty) as their Id but the namespace of the stream will change based on the request being made.  When the controller is disposed it unsubscribes from the stream.

The problem occurs when multiple concurrent requests are sent to our Web API.  What we see is when the system is started up from cold the first set of concurrent requests all succeed.  Messages are published received by the controllers and responses are returned to the callers.  However from that point on each subsequent set of concurrent requests see some of the requests timeout because the messages being published are not being handled by the controllers.  The number of requests that fail is variable.  Sometimes only one is successful sometimes only one fails and every point in between but there is always at least one success and one failure in each batch.

I have (I think) verified that the messages are being published correctly by subscribing to the same stream within a grain that is invoked as part of the call chain.  Our logs show that the messages are always being handled by this grain.

After a period of rest (sorry I haven't ascertained exactly how long this is) the system seems to go back to its initial state and a batch of requests work correctly but from there on in it's as it was before.

For the time being we have got around this problem by using a distinct Guid (the correlation Id) for each request but this is not ideal.

I'm mostly confused as to why it all works the first time and only subsequent sets of requests fail.

Is there anything else we can investigate to see what may be the root cause of this?

We're using v2.1.2 of Orleans.

Many thanks
Mark</Description>
    <Title_Description>Stream messages not reaching all client-based subscribers I have a problem whereby some stream subscribers are not receiving messages published to that stream.

Our system is set up with Web API REST endpoints which use an Orleans IClusterClient to access boundary grains.  These grains hand off the process to internal grains some of which are stateless workers and eventually this will result in a message being published to a Simple Message Provider stream.  When invoked the Web API controllers subscribe to this stream via a singleton IClusterClient and the handler for this subscription returns the result back to the caller.  We pass a correlation Id (Guid) into the Orleans.RequestContext and check this in the stream handler to confirm we're processing the correct message.  All streams use the same Guid (Guid.Empty) as their Id but the namespace of the stream will change based on the request being made.  When the controller is disposed it unsubscribes from the stream.

The problem occurs when multiple concurrent requests are sent to our Web API.  What we see is when the system is started up from cold the first set of concurrent requests all succeed.  Messages are published received by the controllers and responses are returned to the callers.  However from that point on each subsequent set of concurrent requests see some of the requests timeout because the messages being published are not being handled by the controllers.  The number of requests that fail is variable.  Sometimes only one is successful sometimes only one fails and every point in between but there is always at least one success and one failure in each batch.

I have (I think) verified that the messages are being published correctly by subscribing to the same stream within a grain that is invoked as part of the call chain.  Our logs show that the messages are always being handled by this grain.

After a period of rest (sorry I haven't ascertained exactly how long this is) the system seems to go back to its initial state and a batch of requests work correctly but from there on in it's as it was before.

For the time being we have got around this problem by using a distinct Guid (the correlation Id) for each request but this is not ideal.

I'm mostly confused as to why it all works the first time and only subsequent sets of requests fail.

Is there anything else we can investigate to see what may be the root cause of this?

We're using v2.1.2 of Orleans.

Many thanks
Mark</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5508</IssueLabelID>
    <Title>what is the best way to  transmit request from grainA to grainB.</Title>
    <Description>I don`t know how many IGrainB silos in the clusterit is scaled.
If I use  GrainFactory.GetGrain&lt;IGrainB&gt;(0) it is inefficient.Only one grainB busy. 
If I use  GrainFactory.GetGrain&lt;IGrainB&gt;(randomid) it means per request creates per grain.Im afraid It will  create amount of Gains there. 
How should I do it? Thanks.</Description>
    <Title_Description>what is the best way to  transmit request from grainA to grainB. I don`t know how many IGrainB silos in the clusterit is scaled.
If I use  GrainFactory.GetGrain&lt;IGrainB&gt;(0) it is inefficient.Only one grainB busy. 
If I use  GrainFactory.GetGrain&lt;IGrainB&gt;(randomid) it means per request creates per grain.Im afraid It will  create amount of Gains there. 
How should I do it? Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/04/2019 11:57:32 AM +00:00</CreatedAt>
    <ClosedAt>5/04/2019 2:53:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5506</IssueLabelID>
    <Title>IDeserializationContext.DeserializeInner deserialization bug</Title>
    <Description>In generated code something senseless happen time to time (around 50% of running)
The returned class has three fields: int int bool.

    public class AnalysisStatus
    {
        public bool UpdateInProgress { get; set; }

        public int Total { get; set; }

        public int Processed { get; set; }
    }

In the generated code DeserializeInner takes the rigth type as input (**int**) for unknow reason returns a **bool** and obviously the cast to **int** fails badly

![ORLEAN BUG](https://user-images.githubusercontent.com/130935/55506731-76b10680-5656-11e9-90de-238cf36cadd1.PNG)
</Description>
    <Title_Description>IDeserializationContext.DeserializeInner deserialization bug In generated code something senseless happen time to time (around 50% of running)
The returned class has three fields: int int bool.

    public class AnalysisStatus
    {
        public bool UpdateInProgress { get; set; }

        public int Total { get; set; }

        public int Processed { get; set; }
    }

In the generated code DeserializeInner takes the rigth type as input (**int**) for unknow reason returns a **bool** and obviously the cast to **int** fails badly

![ORLEAN BUG](https://user-images.githubusercontent.com/130935/55506731-76b10680-5656-11e9-90de-238cf36cadd1.PNG)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5505</IssueLabelID>
    <Title>Get the calling grain reference from a custom IReminderRegistry</Title>
    <Description>I'm working on unit testing some grains that make use of reminders (using `TestClusterBuilder`/`TestCluster`). I've created a fake `IReminderRegistry` and added it to the silo's DI container. Everything appears to be working great for this use case but there's one annoyance: the `IReminderRegistry` methods do not get passed a grain reference/instance/etc..

The built-in `ReminderRegistry` uses this magic from its base class (`GrainServiceClient`):

```cs
protected GrainReference CallingGrainReference =&gt;
    (RuntimeContext.Current?.ActivationContext as SchedulingContext)?.Activation?.GrainReference;
```

My fake registry currently extends `Object` so I don't have this property. Additionally `RuntimeContext` is internal so I can't simply duplicate this property.

Is it possible to get the grain reference in my fake registry? Should I extend `GrainServiceClient` simply to gain access to the above magic? Would extending `GrainServiceClient` work even if I never register an `IReminderService` (I've successfully avoided having the silo create the `LocalReminderService` since it's unnecessary for all of our unit tests)?</Description>
    <Title_Description>Get the calling grain reference from a custom IReminderRegistry I'm working on unit testing some grains that make use of reminders (using `TestClusterBuilder`/`TestCluster`). I've created a fake `IReminderRegistry` and added it to the silo's DI container. Everything appears to be working great for this use case but there's one annoyance: the `IReminderRegistry` methods do not get passed a grain reference/instance/etc..

The built-in `ReminderRegistry` uses this magic from its base class (`GrainServiceClient`):

```cs
protected GrainReference CallingGrainReference =&gt;
    (RuntimeContext.Current?.ActivationContext as SchedulingContext)?.Activation?.GrainReference;
```

My fake registry currently extends `Object` so I don't have this property. Additionally `RuntimeContext` is internal so I can't simply duplicate this property.

Is it possible to get the grain reference in my fake registry? Should I extend `GrainServiceClient` simply to gain access to the above magic? Would extending `GrainServiceClient` work even if I never register an `IReminderService` (I've successfully avoided having the silo create the `LocalReminderService` since it's unnecessary for all of our unit tests)?</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5504</IssueLabelID>
    <Title>Issue w/client stream reconnect</Title>
    <Description>It seems when a client disconnect and reconnects the client will hang when publishing to the stream.

I encountered this in my own project and was able to reproduce in a sample project:
1) Open ChatRoom.sln (Samples/2.0/ChatRoom)
2) Start OrleansServer
3) Start OrleansClient instance 1 join channel: /j random
4) Start OrleansClient instance 2 join channel: /j random
5) Close OrleansClient instance 2
6) Start OrleansClient instance 2 join channel /j random
7) OrleansClient instance 2 is now hung</Description>
    <Title_Description>Issue w/client stream reconnect It seems when a client disconnect and reconnects the client will hang when publishing to the stream.

I encountered this in my own project and was able to reproduce in a sample project:
1) Open ChatRoom.sln (Samples/2.0/ChatRoom)
2) Start OrleansServer
3) Start OrleansClient instance 1 join channel: /j random
4) Start OrleansClient instance 2 join channel: /j random
5) Close OrleansClient instance 2
6) Start OrleansClient instance 2 join channel /j random
7) OrleansClient instance 2 is now hung</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5503</IssueLabelID>
    <Title>Added batch stream production back in.</Title>
    <Description>-Added testing for batch behaviors for EH AQ Memory and SMS.  Works for all but SMS.
-SMS tests skipped until we fix.
Surfaces are asymmetric though.  Will discuss with team before merging.</Description>
    <Title_Description>Added batch stream production back in. -Added testing for batch behaviors for EH AQ Memory and SMS.  Works for all but SMS.
-SMS tests skipped until we fix.
Surfaces are asymmetric though.  Will discuss with team before merging.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5502</IssueLabelID>
    <Title>Subscription handle extensions for batch consumption</Title>
    <Description>Updated stream subscription handle extension functions to handle batch consumption complerable to what is supported for subscribe.</Description>
    <Title_Description>Subscription handle extensions for batch consumption Updated stream subscription handle extension functions to handle batch consumption complerable to what is supported for subscribe.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5501</IssueLabelID>
    <Title>(Attempt To) Create Integration Sample w/ ML.NET</Title>
    <Description>[ML.NET](https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet) @ [GitHub](https://github.com/dotnet/machinelearning) in the new shiny tech on the .NET space.

Though our own use cases are still a ways off I think showing how this can integrate with Orleans for work distribution and most importantly *cached state* distribution could help raise the profile of Orleans itself. Compute is cheap it's *moving data* that kills performance something that machine learning solutions suffer a lot from. Sharding state and moving it efficiently is something Orleans is very good at and I can therefore see these two technologies working well especially if we're able to add something like [Apache Arrow](https://arrow.apache.org/) on top to compress data on the move *and* at rest without the overhead of transforming said data for processing. Anyway these are all in the air right now. This issue is here in case anyone wants to have fun with it. Otherwise I'll come back to this at some point just for kicks.</Description>
    <Title_Description>(Attempt To) Create Integration Sample w/ ML.NET [ML.NET](https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet) @ [GitHub](https://github.com/dotnet/machinelearning) in the new shiny tech on the .NET space.

Though our own use cases are still a ways off I think showing how this can integrate with Orleans for work distribution and most importantly *cached state* distribution could help raise the profile of Orleans itself. Compute is cheap it's *moving data* that kills performance something that machine learning solutions suffer a lot from. Sharding state and moving it efficiently is something Orleans is very good at and I can therefore see these two technologies working well especially if we're able to add something like [Apache Arrow](https://arrow.apache.org/) on top to compress data on the move *and* at rest without the overhead of transforming said data for processing. Anyway these are all in the air right now. This issue is here in case anyone wants to have fun with it. Otherwise I'll come back to this at some point just for kicks.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5500</IssueLabelID>
    <Title>(Attempt To) Create Integration Sample /w Trill</Title>
    <Description>&gt; Trill is a high-performance open-source in-memory incremental analytics library. It can handle both real-time and offline data and is based on a temporal data and query model. Trill can be used as a streaming engine a lightweight in-memory relational engine and as a progressive query processor (for early query results on partial data).

See [Microsoft Research Website](https://www.microsoft.com/en-us/research/project/trill/) and [GitHub](https://github.com/Microsoft/Trill).

It also looks very cool. We're bound to build a prototype of this at some point in the context of a CQRS-style real-time data aggregation and projection engine running on Orleans so I'm putting this here in case some wants to have fun building a sample for it. Otherwise I'll get to this at some point.</Description>
    <Title_Description>(Attempt To) Create Integration Sample /w Trill &gt; Trill is a high-performance open-source in-memory incremental analytics library. It can handle both real-time and offline data and is based on a temporal data and query model. Trill can be used as a streaming engine a lightweight in-memory relational engine and as a progressive query processor (for early query results on partial data).

See [Microsoft Research Website](https://www.microsoft.com/en-us/research/project/trill/) and [GitHub](https://github.com/Microsoft/Trill).

It also looks very cool. We're bound to build a prototype of this at some point in the context of a CQRS-style real-time data aggregation and projection engine running on Orleans so I'm putting this here in case some wants to have fun building a sample for it. Otherwise I'll get to this at some point.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5499</IssueLabelID>
    <Title>The question of using AddMemoryGrainStorage ("PubSubStore") when subscribing to StreamProvider on the client side</Title>
    <Description>The client needs to subscribe to the StreamProvider to get the message pushed by the Silo side. Because of the need for PubSubStore AddMemoryGrainStorage ("PubSubStore") is used.
Because you need to ensure that the client can get the push message you can't cancel the subscription but this will cause a serious problem.
When I generate Guid different PubSubRendezvousGrain generates a lot of data.
How to clear up old subscription data?
If the client restarts will the old data of the PubSubRendezvousGrain in the silo be clear?</Description>
    <Title_Description>The question of using AddMemoryGrainStorage ("PubSubStore") when subscribing to StreamProvider on the client side The client needs to subscribe to the StreamProvider to get the message pushed by the Silo side. Because of the need for PubSubStore AddMemoryGrainStorage ("PubSubStore") is used.
Because you need to ensure that the client can get the push message you can't cancel the subscription but this will cause a serious problem.
When I generate Guid different PubSubRendezvousGrain generates a lot of data.
How to clear up old subscription data?
If the client restarts will the old data of the PubSubRendezvousGrain in the silo be clear?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5498</IssueLabelID>
    <Title>Add UseLinuxEnvironmentStatistics method for ISiloBuilder</Title>
    <Description>Fixes #5497.</Description>
    <Title_Description>Add UseLinuxEnvironmentStatistics method for ISiloBuilder Fixes #5497.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5494</IssueLabelID>
    <Title>does GrainServiceClient   accessing the GrainService is load balanced？</Title>
    <Description>
    </Description>
    <Title_Description>does GrainServiceClient   accessing the GrainService is load balanced？ </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5493</IssueLabelID>
    <Title>Add Kubernetes support to Docker sample</Title>
    <Description>This is a WIP PR to add support for Kubernetes on the Docker sample. I played with the sample myself wrote a simple Makefile to test and I thought of PR'ing it to get some feedback whether you want something like that. E.g. want the Kubernetes sample combined with the Docker one or maybe we should create a separate Kubernetes sample? I'm open to suggestions :)

Btw whereas deployment works (tested locally with Docker for Windows and remotely using Azure Kubernetes Service) I'm getting an Exception after some time and the silo dies. Any hints?

```
orleans-silo-6988656b9-jh5wz orleans-silo Silo started
orleans-silo-6988656b9-jh5wz orleans-silo warn: Orleans.Runtime.MembershipService.MembershipOracleData[100618]
orleans-silo-6988656b9-jh5wz orleans-silo       I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
orleans-silo-6988656b9-jh5wz orleans-silo fail: Orleans.Runtime.MembershipService.MembershipOracleData[100627]
orleans-silo-6988656b9-jh5wz orleans-silo       I have been told I am dead so this silo will stop! I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
orleans-silo-6988656b9-jh5wz orleans-silo fail: Orleans.Runtime.MembershipService.MembershipOracleData[100627]
orleans-silo-6988656b9-jh5wz orleans-silo       INTERNAL FAILURE! About to crash! Fail message is: I have been told I am dead so this silo will stop! I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
```

Btw I'm pretty new to Orleans so apologies in advance if I missed something.</Description>
    <Title_Description>Add Kubernetes support to Docker sample This is a WIP PR to add support for Kubernetes on the Docker sample. I played with the sample myself wrote a simple Makefile to test and I thought of PR'ing it to get some feedback whether you want something like that. E.g. want the Kubernetes sample combined with the Docker one or maybe we should create a separate Kubernetes sample? I'm open to suggestions :)

Btw whereas deployment works (tested locally with Docker for Windows and remotely using Azure Kubernetes Service) I'm getting an Exception after some time and the silo dies. Any hints?

```
orleans-silo-6988656b9-jh5wz orleans-silo Silo started
orleans-silo-6988656b9-jh5wz orleans-silo warn: Orleans.Runtime.MembershipService.MembershipOracleData[100618]
orleans-silo-6988656b9-jh5wz orleans-silo       I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
orleans-silo-6988656b9-jh5wz orleans-silo fail: Orleans.Runtime.MembershipService.MembershipOracleData[100627]
orleans-silo-6988656b9-jh5wz orleans-silo       I have been told I am dead so this silo will stop! I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
orleans-silo-6988656b9-jh5wz orleans-silo fail: Orleans.Runtime.MembershipService.MembershipOracleData[100627]
orleans-silo-6988656b9-jh5wz orleans-silo       INTERNAL FAILURE! About to crash! Fail message is: I have been told I am dead so this silo will stop! I should be Dead according to membership table (in CleanupTableEntries): entry = SiloAddress=S10.244.0.62:11111:291805778 SiloName=Silo_98c6d Status=Dead.
```

Btw I'm pretty new to Orleans so apologies in advance if I missed something.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5489</IssueLabelID>
    <Title>(Attempt To) Create Integration Sample w/ Apache Arrow</Title>
    <Description>[Apache Arrow](https://arrow.apache.org/) is another edge technology we have on the to-look-at list in order to improve performance of certain workloads within Orleans. As [Microsoft FASTER](https://github.com/Microsoft/FASTER) in #5488 it's also a young project but it shows very promising potential as a columnar storage solution for large collections that support analytical workloads. I'm also bound to build a prototype of this at some point so I'm creating this issue here in case anyone wants to have a go at it in the mean time. Otherwise feel free to assign this to me.</Description>
    <Title_Description>(Attempt To) Create Integration Sample w/ Apache Arrow [Apache Arrow](https://arrow.apache.org/) is another edge technology we have on the to-look-at list in order to improve performance of certain workloads within Orleans. As [Microsoft FASTER](https://github.com/Microsoft/FASTER) in #5488 it's also a young project but it shows very promising potential as a columnar storage solution for large collections that support analytical workloads. I'm also bound to build a prototype of this at some point so I'm creating this issue here in case anyone wants to have a go at it in the mean time. Otherwise feel free to assign this to me.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5488</IssueLabelID>
    <Title>(Attempt To) Create Integration Sample w/ Microsoft FASTER</Title>
    <Description>[Microsoft FASTER](https://github.com/Microsoft/FASTER) is one edge technology we have on the to-look-at list in order to improve performance of certain workloads within Orleans. It's a young project and still in a rough shape but it shows very promising potential as a hybrid storage solution for large dictionary-style collections especially if it gets at least a basic iteration story off the ground. I'm bound to build a prototype of this at some point so I'm creating this issue here in case anyone wants to have a go at it in the mean time. Otherwise feel free to assign this to me.</Description>
    <Title_Description>(Attempt To) Create Integration Sample w/ Microsoft FASTER [Microsoft FASTER](https://github.com/Microsoft/FASTER) is one edge technology we have on the to-look-at list in order to improve performance of certain workloads within Orleans. It's a young project and still in a rough shape but it shows very promising potential as a hybrid storage solution for large dictionary-style collections especially if it gets at least a basic iteration story off the ground. I'm bound to build a prototype of this at some point so I'm creating this issue here in case anyone wants to have a go at it in the mean time. Otherwise feel free to assign this to me.</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5487</IssueLabelID>
    <Title>Reactive Caching Sample Leftovers</Title>
    <Description>Here are the rest of the changes for now. If #5485 surfaces a better approach I'll come back to this.

Not super happy with [this commit](https://github.com/dotnet/orleans/commit/54ab4c1abae8e9b2a8d0f3266bd8777e9108bead) though. Is there any way we can disable the timeout warnings only for specific calls?

Also very grateful for the tips on the previous PR! 👍 </Description>
    <Title_Description>Reactive Caching Sample Leftovers Here are the rest of the changes for now. If #5485 surfaces a better approach I'll come back to this.

Not super happy with [this commit](https://github.com/dotnet/orleans/commit/54ab4c1abae8e9b2a8d0f3266bd8777e9108bead) though. Is there any way we can disable the timeout warnings only for specific calls?

Also very grateful for the tips on the previous PR! 👍 </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5486</IssueLabelID>
    <Title>Create HealthCheck Sample</Title>
    <Description>As described. Feel free to assign this to me unless someone else wants to have a go at it. #4843</Description>
    <Title_Description>Create HealthCheck Sample As described. Feel free to assign this to me unless someone else wants to have a go at it. #4843</Title_Description>
    <Label>
    </Label>
    <Assignee>JorgeCandeias</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5485</IssueLabelID>
    <Title>Question: How can one access the IReminderRegistry from a static Grain extension method.</Title>
    <Description>I'm attempting to write a static extension method for the `Grain` type which in addition to other things also registers a timer.

The easiest way would be to call `RegisterTimer()` from the grain however that method is protected and hence not available to a static extension method.

I'd like to avoid weird stuff like creating an extension `.UseSomething()` method on `IHostBuilder` to expose the timer registry to some static variable.

Is there some nice way to reach the `ITimerRegistry` in this context?</Description>
    <Title_Description>Question: How can one access the IReminderRegistry from a static Grain extension method. I'm attempting to write a static extension method for the `Grain` type which in addition to other things also registers a timer.

The easiest way would be to call `RegisterTimer()` from the grain however that method is protected and hence not available to a static extension method.

I'd like to avoid weird stuff like creating an extension `.UseSomething()` method on `IHostBuilder` to expose the timer registry to some static variable.

Is there some nice way to reach the `ITimerRegistry` in this context?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5484</IssueLabelID>
    <Title>Strange activation exception. Am I missing some registration ? </Title>
    <Description>Hi we are getting some strange exception on activation 

`An exception was thrown while activating λ:Orleans.IGrainFactory -&gt; λ:Orleans.GrainFactory -&gt; Orleans.Runtime.InsideRuntimeClient -&gt; Orleans.Runtime.GrainTypeManager -&gt; λ:Orleans.Serialization.SerializationManager`

from what I understand - Orleans can't resolve `SerializationManager` for the chain of dependencies to activate an instance of IGrainFactory. I'm using AutofacServiceProvider here to wrap and re-register all the types from Microsoft.Extensions DI container.
I'm not sure why the error appear as I'd assume Orleans must register all internal types correctly. Searching in the gitter channel shows only one [similar case here](https://gitter.im/dotnet/orleans?at=5ae320d7270d7d3708113193). But skimming through the conversation and #4524 - it looks like the symptom is similar but not the root case.

Some stats about the setup:
Orleans is latest 2.3 migrating from 1.5.4
Cloud Services for hosting new project formats everywhere where we can (ccproj is not - so need some binding redirects.)
Full framework 4.7.2 iirc.
I'm trying to do a cleanup with this migration so i'm not using legacy nugets but building everything from docs and from scratch.

PS:
Nested stack is even more confusing:
```
Autofac.Core.DependencyResolutionException
  HResult=0x80131500
  Message=An exception was thrown while activating λ:Orleans.IGrainFactory -&gt; λ:Orleans.GrainFactory -&gt; Orleans.Runtime.InsideRuntimeClient -&gt; Orleans.Runtime.GrainTypeManager -&gt; λ:Orleans.Serialization.SerializationManager.
  Source=Autofac
  StackTrace:
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters Object&amp; decoratorTarget)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveOptionalService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance[T](IServiceProvider provider Object[] parameters)
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at Orleans.Runtime.KeyedServiceCollection`2.GetService(IServiceProvider services TKey key)
   at Orleans.Runtime.KeyedServiceCollectionExtensions.GetServiceByKey[TKeyTService](IServiceProvider services TKey key)
   at Orleans.Streams.PersistentStreamStorageConfigurationValidator.ValidateConfiguration()
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
   at Orleans.Hosting.SiloHostBuilder.Build()
   at DBCloud.ActorsHost.WorkerRole.Run() in C:\Projects\bullclip-backend\DBCloud.ActorsHost\WorkerRole.cs:line 37
   at Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironment.StartRoleInternal()
   at Microsoft.WindowsAzure.ServiceRuntime.Implementation.Loader.RoleRuntimeBridge.&lt;StartRole&gt;b__2()
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.ThreadHelper.ThreadStart()

Inner Exception 1:
TargetInvocationException: Exception has been thrown by the target of an invocation.

Inner Exception 2:
TypeInitializationException: The type initializer for 'Orleans.Runtime.Constants' threw an exception.

Inner Exception 3:
BadImageFormatException: Could not load file or assembly 'System.Memory Version=4.0.1.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)

Inner Exception 4:
BadImageFormatException: Cannot load a reference assembly for execution.

```</Description>
    <Title_Description>Strange activation exception. Am I missing some registration ?  Hi we are getting some strange exception on activation 

`An exception was thrown while activating λ:Orleans.IGrainFactory -&gt; λ:Orleans.GrainFactory -&gt; Orleans.Runtime.InsideRuntimeClient -&gt; Orleans.Runtime.GrainTypeManager -&gt; λ:Orleans.Serialization.SerializationManager`

from what I understand - Orleans can't resolve `SerializationManager` for the chain of dependencies to activate an instance of IGrainFactory. I'm using AutofacServiceProvider here to wrap and re-register all the types from Microsoft.Extensions DI container.
I'm not sure why the error appear as I'd assume Orleans must register all internal types correctly. Searching in the gitter channel shows only one [similar case here](https://gitter.im/dotnet/orleans?at=5ae320d7270d7d3708113193). But skimming through the conversation and #4524 - it looks like the symptom is similar but not the root case.

Some stats about the setup:
Orleans is latest 2.3 migrating from 1.5.4
Cloud Services for hosting new project formats everywhere where we can (ccproj is not - so need some binding redirects.)
Full framework 4.7.2 iirc.
I'm trying to do a cleanup with this migration so i'm not using legacy nugets but building everything from docs and from scratch.

PS:
Nested stack is even more confusing:
```
Autofac.Core.DependencyResolutionException
  HResult=0x80131500
  Message=An exception was thrown while activating λ:Orleans.IGrainFactory -&gt; λ:Orleans.GrainFactory -&gt; Orleans.Runtime.InsideRuntimeClient -&gt; Orleans.Runtime.GrainTypeManager -&gt; λ:Orleans.Serialization.SerializationManager.
  Source=Autofac
  StackTrace:
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters Object&amp; decoratorTarget)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveOptionalService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance[T](IServiceProvider provider Object[] parameters)
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at Orleans.Runtime.KeyedServiceCollection`2.GetService(IServiceProvider services TKey key)
   at Orleans.Runtime.KeyedServiceCollectionExtensions.GetServiceByKey[TKeyTService](IServiceProvider services TKey key)
   at Orleans.Streams.PersistentStreamStorageConfigurationValidator.ValidateConfiguration()
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
   at Orleans.Hosting.SiloHostBuilder.Build()
   at DBCloud.ActorsHost.WorkerRole.Run() in C:\Projects\bullclip-backend\DBCloud.ActorsHost\WorkerRole.cs:line 37
   at Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironment.StartRoleInternal()
   at Microsoft.WindowsAzure.ServiceRuntime.Implementation.Loader.RoleRuntimeBridge.&lt;StartRole&gt;b__2()
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext ContextCallback callback Object state)
   at System.Threading.ThreadHelper.ThreadStart()

Inner Exception 1:
TargetInvocationException: Exception has been thrown by the target of an invocation.

Inner Exception 2:
TypeInitializationException: The type initializer for 'Orleans.Runtime.Constants' threw an exception.

Inner Exception 3:
BadImageFormatException: Could not load file or assembly 'System.Memory Version=4.0.1.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)

Inner Exception 4:
BadImageFormatException: Cannot load a reference assembly for execution.

```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5483</IssueLabelID>
    <Title>Azure Table Storage Provider Throughput</Title>
    <Description>A long time ago I remember reading somewhere that you should use the `ShardedStorageProvider` with multiple Azure Table Storage providers if you thought that one Azure Table Storage account would not give you enough throughput. I also remember reading that you should predict what your max throughput is going to be because you can't change it later on.

I can't seem to find this information in the docs or issues. Does this still even hold with the latest version of Orleans and Azure Table Storage? If it does what is the max throughput of a single Azure Table Storage account?</Description>
    <Title_Description>Azure Table Storage Provider Throughput A long time ago I remember reading somewhere that you should use the `ShardedStorageProvider` with multiple Azure Table Storage providers if you thought that one Azure Table Storage account would not give you enough throughput. I also remember reading that you should predict what your max throughput is going to be because you can't change it later on.

I can't seem to find this information in the docs or issues. Does this still even hold with the latest version of Orleans and Azure Table Storage? If it does what is the max throughput of a single Azure Table Storage account?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5482</IssueLabelID>
    <Title>Microsoft.Orleans.CodeGenerator.MSBuild - Issues with GrainState being of generic type</Title>
    <Description>Hi we observed some differences between the `Microsoft.Orleans.OrleansCodeGenerator.Build` (works) and `Microsoft.Orleans.CodeGenerator.MSBuild` (fails) code generator.
Where we're having intermittent issues (while running the same test without rebuild) that produces the exception below.

We have a grain with a state of a generic type. This works fine with `Build` but fails with `MSBuild`. Changing the generic state to a concrete implementation solves the problem in the `MSBuild`-case.

```
public class MyGrain : Grain&lt;StateHolder&lt;SomeState&gt;&gt; IMyGrain
```

```
Error Message:
 Orleans.Runtime.OrleansException : Error from storage provider MemoryGrainStorage.Project.Grains.Project.Grains.MyGrain during WriteState for grain Type=Project.Grains.Project.Grains.MyGrain Pk=*grn/D8F31C2F/0000000000000000000000000000000103ffffffd8f31c2f-0xD695DE71 Id=GrainReference:*grn/D8F31C2F/00000001 Error=

Exc level 0: System.TypeAccessException: Named type "Orleans.GrainState`1&lt;Project.Grains.StateHolder`1&lt;Project.Grains.SomeState&gt;&gt;" is invalid: Type string "Project.Grains.StateHolder`1'1" cannot be resolved.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.Storage.MemoryGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\12\s\src\OrleansProviders\Storage\MemoryStorage.cs:line 97
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
---- System.TypeAccessException : Named type "Orleans.GrainState`1&lt;Project.Grains.StateHolder`1&lt;Project.Grains.SomeState&gt;&gt;" is invalid: Type string "Project.Grains.StateHolder`1'1" cannot be resolved.
Stack Trace:
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Project.Tests.Can_get_grain() in ...\Tests.cs
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.Storage.MemoryGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\12\s\src\OrleansProviders\Storage\MemoryStorage.cs:line 97
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
```

Codegen output:
```
// Microsoft.Orleans.CodeGenerator.MSBuild
feature.AddKnownType("Project.Grains.StateHolder`1Project.Grains" "Project.Grains.StateHolder'1");

// Microsoft.Orleans.OrleansCodeGenerator.Build
feature.AddKnownType("Project.Grains.StateHolder`1Project.Grains" "Project.Grains.StateHolder`'1");

```

At the moment we don't have time to do a repro. Hopefully this can help i some way.</Description>
    <Title_Description>Microsoft.Orleans.CodeGenerator.MSBuild - Issues with GrainState being of generic type Hi we observed some differences between the `Microsoft.Orleans.OrleansCodeGenerator.Build` (works) and `Microsoft.Orleans.CodeGenerator.MSBuild` (fails) code generator.
Where we're having intermittent issues (while running the same test without rebuild) that produces the exception below.

We have a grain with a state of a generic type. This works fine with `Build` but fails with `MSBuild`. Changing the generic state to a concrete implementation solves the problem in the `MSBuild`-case.

```
public class MyGrain : Grain&lt;StateHolder&lt;SomeState&gt;&gt; IMyGrain
```

```
Error Message:
 Orleans.Runtime.OrleansException : Error from storage provider MemoryGrainStorage.Project.Grains.Project.Grains.MyGrain during WriteState for grain Type=Project.Grains.Project.Grains.MyGrain Pk=*grn/D8F31C2F/0000000000000000000000000000000103ffffffd8f31c2f-0xD695DE71 Id=GrainReference:*grn/D8F31C2F/00000001 Error=

Exc level 0: System.TypeAccessException: Named type "Orleans.GrainState`1&lt;Project.Grains.StateHolder`1&lt;Project.Grains.SomeState&gt;&gt;" is invalid: Type string "Project.Grains.StateHolder`1'1" cannot be resolved.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.Storage.MemoryGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\12\s\src\OrleansProviders\Storage\MemoryStorage.cs:line 97
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
---- System.TypeAccessException : Named type "Orleans.GrainState`1&lt;Project.Grains.StateHolder`1&lt;Project.Grains.SomeState&gt;&gt;" is invalid: Type string "Project.Grains.StateHolder`1'1" cannot be resolved.
Stack Trace:
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Project.Tests.Can_get_grain() in ...\Tests.cs
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\12\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Orleans.Storage.MemoryGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\12\s\src\OrleansProviders\Storage\MemoryStorage.cs:line 97
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\12\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
```

Codegen output:
```
// Microsoft.Orleans.CodeGenerator.MSBuild
feature.AddKnownType("Project.Grains.StateHolder`1Project.Grains" "Project.Grains.StateHolder'1");

// Microsoft.Orleans.OrleansCodeGenerator.Build
feature.AddKnownType("Project.Grains.StateHolder`1Project.Grains" "Project.Grains.StateHolder`'1");

```

At the moment we don't have time to do a repro. Hopefully this can help i some way.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5479</IssueLabelID>
    <Title>Update Azure Storage libraries</Title>
    <Description>We keep experiencing the issue described in #5003. The fix in the upstream repo was rejected as the Azure Table storage service/API/SDKs were being transferred from the Azure Storage team to the Cosmos DB team.

The Cosmos DB team has released a new [SDK for Azure Table storage](https://docs.microsoft.com/en-us/azure/cosmos-db/table-sdk-dotnet-standard) with support for .NET Standard. Interestingly the team chose to release this under a _new_ package ID [Microsoft.Azure.Cosmos.Table](https://www.nuget.org/packages/Microsoft.Azure.Cosmos.Table) as opposed to updating their existing Microsoft.Azure.CosmosDB.Table package.

Additionally the Azure Storage SDK has since been broken out into separate packages. We now have:

- [Microsoft.Azure.Storage.Blob](https://www.nuget.org/packages/Microsoft.Azure.Storage.Blob/)
- [Microsoft.Azure.Storage.Common](https://www.nuget.org/packages/Microsoft.Azure.Storage.Common/)
- [Microsoft.Azure.Storage.File](https://www.nuget.org/packages/Microsoft.Azure.Storage.File/)
- [Microsoft.Azure.Storage.Queue](https://www.nuget.org/packages/Microsoft.Azure.Storage.Queue/)

The new Common library contains `CloudStorageAccount` `StorageException` retry policies etc..

I [took a stab](https://github.com/seniorquico/orleans/tree/update-azure-storage) at updating the package references in the Orleans solution hoping this will bring a fix to our issue. Unfortunately I encountered several problems.

First the new refactored Azure Storage SDKs have picked up a transitive dependency on Microsoft.Azure.KeyVault.Core with a specified version of "&gt;=1.0.0". NuGet restores the lowest applicable version 1.0.0. Unfortunately that particular version does not provide a library under a TFM for .NET Standard. This causes NuGet errors like the following:

&gt; error NU1701: Package 'Microsoft.Azure.KeyVault.Core 1.0.0' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETStandardVersion=v2.0'. This package may not be fully compatible with your project.

I had to promote Microsoft.Azure.KeyVault.Core to an explicit dependency to get an updated version with a library under a TFM for .NET Standard. Is there another option besides adding an explicit dependency? If not is it preferred to specify the oldest or newest version in the new explicit dependency?

Next while the Microsoft.Azure.Cosmos.Table library keeps a mostly consistent API with prior versions of WindowsAzure.Storage all of the "common" classes were duplicated and the namespaces updated. This is problematic for example in shared classes like `AzureStorageUtils` where `CloudStorageAccount` and `StorageException` now exist in both the `Microsoft.Azure.Cosmos.Table`
and `Microsoft.WindowsAzure.Storage` namespaces and lead to ambiguous references. I noticed that the Microsoft.Azure.CosmosDB.Table package (which only supports NetFx) was recently updated to take a dependency on Microsoft.Azure.Storage.Common (thus reusing `CloudStorageAccount` `StorageException` etc.). I reached out to the Cosmos DB team to see if a similar future is in store for Microsoft.Azure.Cosmos.Table.

Next the classes `NameValidator` and `StorageErrorCodeStrings` were changed to an `internal` visibility in Microsoft.Azure.Cosmos.Table (they remain `public` in Microsoft.Azure.Storage.Common).

Finally even though the NuGet package indicates `Microsoft.Azure.Cosmos.Table` is released under an MIT license the source code is not yet available. I also reached out to the Cosmos DB team for guidance.

So how to proceed? Should the Blob/Queue code get separated from the Table code? That sounds undesirable _if_ there's some confirmation the Microsoft.Azure.Cosmos.Table library will end up taking on a Microsoft.Azure.Storage.Common dependency. While waiting for a Cosmos DB team response the refactored Azure Storage SDKs are getting new bug fixes for Blob and Queue. WindowsAzure.Storage appears to be frozen.</Description>
    <Title_Description>Update Azure Storage libraries We keep experiencing the issue described in #5003. The fix in the upstream repo was rejected as the Azure Table storage service/API/SDKs were being transferred from the Azure Storage team to the Cosmos DB team.

The Cosmos DB team has released a new [SDK for Azure Table storage](https://docs.microsoft.com/en-us/azure/cosmos-db/table-sdk-dotnet-standard) with support for .NET Standard. Interestingly the team chose to release this under a _new_ package ID [Microsoft.Azure.Cosmos.Table](https://www.nuget.org/packages/Microsoft.Azure.Cosmos.Table) as opposed to updating their existing Microsoft.Azure.CosmosDB.Table package.

Additionally the Azure Storage SDK has since been broken out into separate packages. We now have:

- [Microsoft.Azure.Storage.Blob](https://www.nuget.org/packages/Microsoft.Azure.Storage.Blob/)
- [Microsoft.Azure.Storage.Common](https://www.nuget.org/packages/Microsoft.Azure.Storage.Common/)
- [Microsoft.Azure.Storage.File](https://www.nuget.org/packages/Microsoft.Azure.Storage.File/)
- [Microsoft.Azure.Storage.Queue](https://www.nuget.org/packages/Microsoft.Azure.Storage.Queue/)

The new Common library contains `CloudStorageAccount` `StorageException` retry policies etc..

I [took a stab](https://github.com/seniorquico/orleans/tree/update-azure-storage) at updating the package references in the Orleans solution hoping this will bring a fix to our issue. Unfortunately I encountered several problems.

First the new refactored Azure Storage SDKs have picked up a transitive dependency on Microsoft.Azure.KeyVault.Core with a specified version of "&gt;=1.0.0". NuGet restores the lowest applicable version 1.0.0. Unfortunately that particular version does not provide a library under a TFM for .NET Standard. This causes NuGet errors like the following:

&gt; error NU1701: Package 'Microsoft.Azure.KeyVault.Core 1.0.0' was restored using '.NETFrameworkVersion=v4.6.1' instead of the project target framework '.NETStandardVersion=v2.0'. This package may not be fully compatible with your project.

I had to promote Microsoft.Azure.KeyVault.Core to an explicit dependency to get an updated version with a library under a TFM for .NET Standard. Is there another option besides adding an explicit dependency? If not is it preferred to specify the oldest or newest version in the new explicit dependency?

Next while the Microsoft.Azure.Cosmos.Table library keeps a mostly consistent API with prior versions of WindowsAzure.Storage all of the "common" classes were duplicated and the namespaces updated. This is problematic for example in shared classes like `AzureStorageUtils` where `CloudStorageAccount` and `StorageException` now exist in both the `Microsoft.Azure.Cosmos.Table`
and `Microsoft.WindowsAzure.Storage` namespaces and lead to ambiguous references. I noticed that the Microsoft.Azure.CosmosDB.Table package (which only supports NetFx) was recently updated to take a dependency on Microsoft.Azure.Storage.Common (thus reusing `CloudStorageAccount` `StorageException` etc.). I reached out to the Cosmos DB team to see if a similar future is in store for Microsoft.Azure.Cosmos.Table.

Next the classes `NameValidator` and `StorageErrorCodeStrings` were changed to an `internal` visibility in Microsoft.Azure.Cosmos.Table (they remain `public` in Microsoft.Azure.Storage.Common).

Finally even though the NuGet package indicates `Microsoft.Azure.Cosmos.Table` is released under an MIT license the source code is not yet available. I also reached out to the Cosmos DB team for guidance.

So how to proceed? Should the Blob/Queue code get separated from the Table code? That sounds undesirable _if_ there's some confirmation the Microsoft.Azure.Cosmos.Table library will end up taking on a Microsoft.Azure.Storage.Common dependency. While waiting for a Cosmos DB team response the refactored Azure Storage SDKs are getting new bug fixes for Blob and Queue. WindowsAzure.Storage appears to be frozen.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5478</IssueLabelID>
    <Title>Question about registered reminders and cluster id</Title>
    <Description>We have a lot of errors like this one:
```
Could not deliver reminder tick for [Default GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E 00:30:00 2019-02-03 20:15:18.833 GMT W/"datetime'2019-02-03T20%3A15%3A19.0436877Z'" 34 Ticking] next 3/27/2019 6:15:21 PM.

```
I checked the reminders table and found that following reminder has been renamed and has cluster id that already not in use . We increment the cluster id during devops. This is like zombie record. Is this expected?

Full error
```
Could not deliver reminder tick for [Default GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E 00:30:00 2019-02-03 20:15:18.833 GMT W/"datetime'2019-02-03T20%3A15%3A19.0436877Z'" 34 Ticking] next 3/27/2019 6:15:21 PM.

Orleans.OrleansCodeGenRemindableMethodInvoker+&lt;Invoke&gt;d__0.MoveNext

System.InvalidCastException:
   at Orleans.OrleansCodeGenRemindableMethodInvoker+&lt;Invoke&gt;d__0.MoveNext (Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.GrainMethodInvoker+&lt;Invoke&gt;d__21.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.InsideRuntimeClient+&lt;Invoke&gt;d__62.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.ReminderService.LocalReminderService+LocalReminderData+&lt;OnTimerTick&gt;d__20.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)

```
</Description>
    <Title_Description>Question about registered reminders and cluster id We have a lot of errors like this one:
```
Could not deliver reminder tick for [Default GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E 00:30:00 2019-02-03 20:15:18.833 GMT W/"datetime'2019-02-03T20%3A15%3A19.0436877Z'" 34 Ticking] next 3/27/2019 6:15:21 PM.

```
I checked the reminders table and found that following reminder has been renamed and has cluster id that already not in use . We increment the cluster id during devops. This is like zombie record. Is this expected?

Full error
```
Could not deliver reminder tick for [Default GrainReference:*grn/9827AB60/0000000000000000000000000000000006ffffff9827ab60+Default-0x0BF7DC4E 00:30:00 2019-02-03 20:15:18.833 GMT W/"datetime'2019-02-03T20%3A15%3A19.0436877Z'" 34 Ticking] next 3/27/2019 6:15:21 PM.

Orleans.OrleansCodeGenRemindableMethodInvoker+&lt;Invoke&gt;d__0.MoveNext

System.InvalidCastException:
   at Orleans.OrleansCodeGenRemindableMethodInvoker+&lt;Invoke&gt;d__0.MoveNext (Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.GrainMethodInvoker+&lt;Invoke&gt;d__21.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.InsideRuntimeClient+&lt;Invoke&gt;d__62.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089)
   at Orleans.Runtime.ReminderService.LocalReminderService+LocalReminderData+&lt;OnTimerTick&gt;d__20.MoveNext (Orleans.Runtime Version=2.0.0.0 Culture=neutral PublicKeyToken=null)

```
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5475</IssueLabelID>
    <Title>Observers have been Replaced with Streams</Title>
    <Description>I'm new to Orleans. This page threw me off until I read somewhere that Streams had replaced this functionality. If there is docs for older versions then this document should go there.</Description>
    <Title_Description>Observers have been Replaced with Streams I'm new to Orleans. This page threw me off until I read somewhere that Streams had replaced this functionality. If there is docs for older versions then this document should go there.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5474</IssueLabelID>
    <Title>Should require many grains one time or multiple time?</Title>
    <Description>If there are many tasks and each task should create a grains. Should create those grains one time ? 
I think Orleans know its work load can cache all tasks(grains) required by client and then dispatch tasks to soils intelligently. If not what is strategy? Should client cache all tasks and then require grains in batch ? but how much should require one time for client don't know work load of Orleans and soil?

Furthermore Can Orleans scale in and out automatically according work load with something like K8t Swarm?

Thanks</Description>
    <Title_Description>Should require many grains one time or multiple time? If there are many tasks and each task should create a grains. Should create those grains one time ? 
I think Orleans know its work load can cache all tasks(grains) required by client and then dispatch tasks to soils intelligently. If not what is strategy? Should client cache all tasks and then require grains in batch ? but how much should require one time for client don't know work load of Orleans and soil?

Furthermore Can Orleans scale in and out automatically according work load with something like K8t Swarm?

Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5473</IssueLabelID>
    <Title>Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop</Title>
    <Description>The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code it hangs after generating `..orleans.g.args.txt`

this is the exit error message:
```
Orleans.CodeGenerator - command-line = SourceToSource /code/GrainInterfaces/obj/Debug/netstandard2.0/GrainInterfaces.orleans.g.args.txt
&lt;...hangs for a long time...&gt;
         Process is terminating due to StackOverflowException.
```

This code compiles without problem with `Microsoft.Orleans.OrleansCodeGenerator.Build` `2.2.4`

GrainInterface.cs

```
    public interface IFoo : IGrainWithGuidKey
    {
        Task Bar(Complex request);
    }
```

Complex.cs
```
    public class Complex : Simple&lt;Complex&gt;
    {    
    }
    
    public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;
    {
        public T DoSomething(T input)
        {
            // do something to input
            return input;
        }
    }
```

It is probably this line `public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;` that is causing the infinite loop.</Description>
    <Title_Description>Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code it hangs after generating `..orleans.g.args.txt`

this is the exit error message:
```
Orleans.CodeGenerator - command-line = SourceToSource /code/GrainInterfaces/obj/Debug/netstandard2.0/GrainInterfaces.orleans.g.args.txt
&lt;...hangs for a long time...&gt;
         Process is terminating due to StackOverflowException.
```

This code compiles without problem with `Microsoft.Orleans.OrleansCodeGenerator.Build` `2.2.4`

GrainInterface.cs

```
    public interface IFoo : IGrainWithGuidKey
    {
        Task Bar(Complex request);
    }
```

Complex.cs
```
    public class Complex : Simple&lt;Complex&gt;
    {    
    }
    
    public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;
    {
        public T DoSomething(T input)
        {
            // do something to input
            return input;
        }
    }
```

It is probably this line `public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;` that is causing the infinite loop.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5472</IssueLabelID>
    <Title>Recommended way to Handle Collections of Grains</Title>
    <Description>I'm new to Orleans and am trying to work out how to deal with collections of grains e.g. A `UserGrain` may contain many `BlogPostGrain`'s and this requires filtering sorting and paging etc. What is the recommended approach?

For small collections I suppose I could just use a `List&lt;T&gt;` but what about for larger collections? Also how big does the collection need to get before I need to think about stopping the use of `List&lt;T&gt;`? If I'm using Azure Table Storage I have a maximum state size constraint which is what I'm guessing is my limit in this scenario.

I've seen two projects that seem to have some promise but they are supposedly not ready for production:

- https://github.com/OrleansContrib/OrleansV2.Fork.Indexing (pre-production = beta?)
- https://github.com/OrleansContrib/Orleans.Containers (pre-alpha)</Description>
    <Title_Description>Recommended way to Handle Collections of Grains I'm new to Orleans and am trying to work out how to deal with collections of grains e.g. A `UserGrain` may contain many `BlogPostGrain`'s and this requires filtering sorting and paging etc. What is the recommended approach?

For small collections I suppose I could just use a `List&lt;T&gt;` but what about for larger collections? Also how big does the collection need to get before I need to think about stopping the use of `List&lt;T&gt;`? If I'm using Azure Table Storage I have a maximum state size constraint which is what I'm guessing is my limit in this scenario.

I've seen two projects that seem to have some promise but they are supposedly not ready for production:

- https://github.com/OrleansContrib/OrleansV2.Fork.Indexing (pre-production = beta?)
- https://github.com/OrleansContrib/Orleans.Containers (pre-alpha)</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5470</IssueLabelID>
    <Title>HashSet grain method argument makes empty filter context with new Codegenerator.MSBuild</Title>
    <Description>Assuming the code:
```
    public interface IHashGrain : IGrainWithIntegerKey
    {
        Task Create(HashSet&lt;Guid&gt; data);
        Task CreateIEnumerable(IEnumerable&lt;Guid&gt; data);
    }

    public class HashGrain : Grain IHashGrain IIncomingGrainCallFilter
    {
        public Task Create(HashSet&lt;Guid&gt; data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
            return Task.CompletedTask;
        }

        public Task CreateIEnumerable(IEnumerable&lt;Guid&gt; data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
            return Task.CompletedTask;
        }

        public Task Invoke(IIncomingGrainCallContext context)
        {
            if (context.InterfaceMethod == null)
                throw new ArgumentNullException("InterfaceMethod");

            return context.Invoke();
        }
    }
```

If built using `Microsoft.Orleans.OrleansCodeGenerator.Build` version 2.3.0 everything works fine.
But using new `Microsoft.Orleans.CodeGenerator.MSBuild` 2.30 the method with `HashSet&lt;Guid&gt;` argument has half-empty `IIncomingGrainCallContext` model:
![image](https://user-images.githubusercontent.com/4157587/54872186-40ab9100-4dd1-11e9-80d1-f9aa6464a933.png)
While `IEumerable` version still works fine.

Since older `Microsoft.Orleans.OrleansCodeGenerator.Build` now fails in `dotnet run` scenario and we're forced to update to MSBuild package - this behavior is pretty frustrating.</Description>
    <Title_Description>HashSet grain method argument makes empty filter context with new Codegenerator.MSBuild Assuming the code:
```
    public interface IHashGrain : IGrainWithIntegerKey
    {
        Task Create(HashSet&lt;Guid&gt; data);
        Task CreateIEnumerable(IEnumerable&lt;Guid&gt; data);
    }

    public class HashGrain : Grain IHashGrain IIncomingGrainCallFilter
    {
        public Task Create(HashSet&lt;Guid&gt; data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
            return Task.CompletedTask;
        }

        public Task CreateIEnumerable(IEnumerable&lt;Guid&gt; data)
        {
            if (data == null)
                throw new ArgumentNullException(nameof(data));
            return Task.CompletedTask;
        }

        public Task Invoke(IIncomingGrainCallContext context)
        {
            if (context.InterfaceMethod == null)
                throw new ArgumentNullException("InterfaceMethod");

            return context.Invoke();
        }
    }
```

If built using `Microsoft.Orleans.OrleansCodeGenerator.Build` version 2.3.0 everything works fine.
But using new `Microsoft.Orleans.CodeGenerator.MSBuild` 2.30 the method with `HashSet&lt;Guid&gt;` argument has half-empty `IIncomingGrainCallContext` model:
![image](https://user-images.githubusercontent.com/4157587/54872186-40ab9100-4dd1-11e9-80d1-f9aa6464a933.png)
While `IEumerable` version still works fine.

Since older `Microsoft.Orleans.OrleansCodeGenerator.Build` now fails in `dotnet run` scenario and we're forced to update to MSBuild package - this behavior is pretty frustrating.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5466</IssueLabelID>
    <Title>Add Incoming grain call filter extensions for ISiloBuilder</Title>
    <Description>Following the changes in 2.3.0 ISiloBuilder had no extension methods to add incoming grain filters.</Description>
    <Title_Description>Add Incoming grain call filter extensions for ISiloBuilder Following the changes in 2.3.0 ISiloBuilder had no extension methods to add incoming grain filters.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5465</IssueLabelID>
    <Title>Add configuration support for ISiloBuilder to TestClusterBuilder</Title>
    <Description>Hi in order to configure common options for a "test silo" and a "real silo" -- it would be great if there was some way to configure a `ISiloBuilder` in the same way as `TestClusterBuilder.AddSiloBuilderConfigurator&lt;T&gt;()` is working today.</Description>
    <Title_Description>Add configuration support for ISiloBuilder to TestClusterBuilder Hi in order to configure common options for a "test silo" and a "real silo" -- it would be great if there was some way to configure a `ISiloBuilder` in the same way as `TestClusterBuilder.AddSiloBuilderConfigurator&lt;T&gt;()` is working today.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5464</IssueLabelID>
    <Title>Sending messages on the initiative of the silo?</Title>
    <Description>Hello! I successfully use Orleans for request-response but did not find in the documentation is it possible to send messages on the initiative of the silo? Is it possible Is there a sample code or other documentation?</Description>
    <Title_Description>Sending messages on the initiative of the silo? Hello! I successfully use Orleans for request-response but did not find in the documentation is it possible to send messages on the initiative of the silo? Is it possible Is there a sample code or other documentation?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5463</IssueLabelID>
    <Title>-Failed to get ping responses from all 1 silos that are currently listed as Active in the Membership table</Title>
    <Description>Orleans.Runtime.MembershipService.MembershipOracleData[100661]
      -Failed to get ping responses from all 1 silos that are currently listed as Active in the Membership table. Newly joining silos validate connectivity with all pre-existing silos that are listed as Active in the table and have written I Am Alive in the table in the last 00:10:00 period before they are allowed to join the cluster. Active silos are: [[SiloAddress=S10.0.75.1:11111:290933742 SiloName=Silo_048a5 Status=Active HostName=LiBo ProxyPort=30000 RoleName= UpdateZone=0 FaultZone=0 StartTime = 2019-03-22 06:55:43.000 GMT IAmAliveTime = 2019-03-22 07:00:51.000 GMT  ]]
warn: Orleans.Runtime.Scheduler *stg/15/0000000f.WorkItemGroup[101215]
      Task [Id=1653 Status=Faulted] in WorkGroup [SystemTarget: S172.19.227.65:11111:290933946*stg/15/0000000f@S0000000f] took elapsed time 0:00:00.2714147 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread</Description>
    <Title_Description>-Failed to get ping responses from all 1 silos that are currently listed as Active in the Membership table Orleans.Runtime.MembershipService.MembershipOracleData[100661]
      -Failed to get ping responses from all 1 silos that are currently listed as Active in the Membership table. Newly joining silos validate connectivity with all pre-existing silos that are listed as Active in the table and have written I Am Alive in the table in the last 00:10:00 period before they are allowed to join the cluster. Active silos are: [[SiloAddress=S10.0.75.1:11111:290933742 SiloName=Silo_048a5 Status=Active HostName=LiBo ProxyPort=30000 RoleName= UpdateZone=0 FaultZone=0 StartTime = 2019-03-22 06:55:43.000 GMT IAmAliveTime = 2019-03-22 07:00:51.000 GMT  ]]
warn: Orleans.Runtime.Scheduler *stg/15/0000000f.WorkItemGroup[101215]
      Task [Id=1653 Status=Faulted] in WorkGroup [SystemTarget: S172.19.227.65:11111:290933946*stg/15/0000000f@S0000000f] took elapsed time 0:00:00.2714147 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5462</IssueLabelID>
    <Title>Update changelog with 2.3.0 changes</Title>
    <Description>
    </Description>
    <Title_Description>Update changelog with 2.3.0 changes </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5459</IssueLabelID>
    <Title>How to clear JournaledGrain's state or events</Title>
    <Description>I have some JournaledGrains that never activate later. So i need to clear these grains state/events In order to  reduce grain state storage space used. But i can't find **ClearStateAsync()** method in JournaledGrain class.  

So my question is: How to clear JournaledGrain state or events?</Description>
    <Title_Description>How to clear JournaledGrain's state or events I have some JournaledGrains that never activate later. So i need to clear these grains state/events In order to  reduce grain state storage space used. But i can't find **ClearStateAsync()** method in JournaledGrain class.  

So my question is: How to clear JournaledGrain state or events?</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5458</IssueLabelID>
    <Title>Component configurator function order independant</Title>
    <Description>Modified component configurator extension functions so order of configuration no longer matters.

With component specialization via interfaces as IAAA : IAA: IA extension functions on the more specialized (IAAA) interfaces had to be used first as the extension functions on the less specific interface (IA) would return the less specific interface limiting all future extension functions to that limited surface.

Example from streams the following would work:

    .AddEventHubStreams(StreamProviderName b=&gt;b
        .ConfigureEventHub(ob=&gt;ob.Configure(
            options =&gt;
            {
                options.ConnectionString = TestDefaultConfiguration.EventHubConnectionString;
                options.ConsumerGroup = EHConsumerGroup;
                options.Path = EHPath;
            }))
        .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly));

but this wouldn't

    .AddEventHubStreams(StreamProviderName b=&gt;b
        .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly)
        .ConfigureEventHub(ob=&gt;ob.Configure(
            options =&gt;
            {
                options.ConnectionString = TestDefaultConfiguration.EventHubConnectionString;
                options.ConsumerGroup = EHConsumerGroup;
                options.Path = EHPath;
            })));

Because the ConfigureEventHub extension function was hung on a more specialized interface than ConfigureEventHub so it needed to be used first.

With this change they both work.</Description>
    <Title_Description>Component configurator function order independant Modified component configurator extension functions so order of configuration no longer matters.

With component specialization via interfaces as IAAA : IAA: IA extension functions on the more specialized (IAAA) interfaces had to be used first as the extension functions on the less specific interface (IA) would return the less specific interface limiting all future extension functions to that limited surface.

Example from streams the following would work:

    .AddEventHubStreams(StreamProviderName b=&gt;b
        .ConfigureEventHub(ob=&gt;ob.Configure(
            options =&gt;
            {
                options.ConnectionString = TestDefaultConfiguration.EventHubConnectionString;
                options.ConsumerGroup = EHConsumerGroup;
                options.Path = EHPath;
            }))
        .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly));

but this wouldn't

    .AddEventHubStreams(StreamProviderName b=&gt;b
        .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly)
        .ConfigureEventHub(ob=&gt;ob.Configure(
            options =&gt;
            {
                options.ConnectionString = TestDefaultConfiguration.EventHubConnectionString;
                options.ConsumerGroup = EHConsumerGroup;
                options.Path = EHPath;
            })));

Because the ConfigureEventHub extension function was hung on a more specialized interface than ConfigureEventHub so it needed to be used first.

With this change they both work.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5457</IssueLabelID>
    <Title>Made stream fault handler a plugable component.</Title>
    <Description>
    </Description>
    <Title_Description>Made stream fault handler a plugable component. </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5456</IssueLabelID>
    <Title>Simple call chain reentrancy deadlock A-&gt;B-&gt;C-&gt;A (with repro)</Title>
    <Description>There is call chain reentrancy deadlock with simple call flow A -&gt; B -&gt; C -&gt; A.

[Grains.zip](https://github.com/dotnet/orleans/files/2979656/Grains.zip)

UPD:  Not reproducing on 2.1.0 version.</Description>
    <Title_Description>Simple call chain reentrancy deadlock A-&gt;B-&gt;C-&gt;A (with repro) There is call chain reentrancy deadlock with simple call flow A -&gt; B -&gt; C -&gt; A.

[Grains.zip](https://github.com/dotnet/orleans/files/2979656/Grains.zip)

UPD:  Not reproducing on 2.1.0 version.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5452</IssueLabelID>
    <Title>Registration based on interface name</Title>
    <Description>To do an early cluster based on zookeeper or consul Orleans supports registration based on interface names? such as **Alibaba RPC high performance framework-DUBBO** .</Description>
    <Title_Description>Registration based on interface name To do an early cluster based on zookeeper or consul Orleans supports registration based on interface names? such as **Alibaba RPC high performance framework-DUBBO** .</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5451</IssueLabelID>
    <Title>Revert "Stop packing *.symbols.nupkg packages"</Title>
    <Description>Reverts dotnet/orleans#5441

For some reason it seems to break our code signing infra...</Description>
    <Title_Description>Revert "Stop packing *.symbols.nupkg packages" Reverts dotnet/orleans#5441

For some reason it seems to break our code signing infra...</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5450</IssueLabelID>
    <Title>Added IQueueData adapter for persistent streams.</Title>
    <Description>- Updated AzureQueueStream to use IQueueDataAdapter replacing IAzureQueueDataAdapter.
- Cleaned up azure queue stream provider configuration to support IQueueDataAdapter as a configurable component.</Description>
    <Title_Description>Added IQueueData adapter for persistent streams. - Updated AzureQueueStream to use IQueueDataAdapter replacing IAzureQueueDataAdapter.
- Cleaned up azure queue stream provider configuration to support IQueueDataAdapter as a configurable component.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5448</IssueLabelID>
    <Title>[Feature Request] "Delete" a grain with transactional state</Title>
    <Description>We have a couple cases where we would like to have a grain with transactional state that gets deleted after some amount of time. With a normal stateful grain you can call `ClearStateAsync` which with the right storage parameters will cause the grain state to get removed from storage. With transactional state there isn't currently such an option. It is possible to manually reset the state but it still remains in storage. There isn't really a great way to know that it is safe to delete from storage manually either.

It does seem possible (though tricky) to implement the feature. Once all pending transactions are fully resolved it should be safe to delete. Could possibly delete in the "second phase" of the commit but may not want to take that risk. Would also likely want to fail any new transactions that try to access state that is pending deletion.</Description>
    <Title_Description>[Feature Request] "Delete" a grain with transactional state We have a couple cases where we would like to have a grain with transactional state that gets deleted after some amount of time. With a normal stateful grain you can call `ClearStateAsync` which with the right storage parameters will cause the grain state to get removed from storage. With transactional state there isn't currently such an option. It is possible to manually reset the state but it still remains in storage. There isn't really a great way to know that it is safe to delete from storage manually either.

It does seem possible (though tricky) to implement the feature. Once all pending transactions are fully resolved it should be safe to delete. Could possibly delete in the "second phase" of the commit but may not want to take that risk. Would also likely want to fail any new transactions that try to access state that is pending deletion.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5447</IssueLabelID>
    <Title>Errors when deactivating a grain with transactional state</Title>
    <Description>Putting `DeactivateOnIdle` in a grain method that is part of a transaction causes `Orleans.Transactions.OrleansBrokenTransactionLockException: Transaction &lt;ID&gt; aborted because a broken lock was detected before prepare`. This mostly makes sense since a transaction lives beyond the normal concept of grain idle.

Trying to delay the deactivation even further also causes issues:
```c#
deactivationTimer = RegisterTimer(_ =&gt;
{
	deactivationTimer.Dispose();
	deactivationTimer = null;
	DeactivateOnIdle();
	return Task.CompletedTask;
} null TimeSpan.FromSeconds(2) TimeSpan.MaxValue);
```
Does lead to a successful deactivation; however the following is printed in the logs 5 times:
`Enqueuing task System.Threading.Tasks.Task to a stopped work item group. Going to ignore and not execute it. The likely reason is that the task is not being 'awaited' properly. WorkItemGroup:Name=[Activation: S127.0.0.1:22222:290365980*grn/445E9F
94/551a5bb0@c22ca4a8 #GrainType=&lt;GrainType&gt; Placement=RandomPlacement]WorkGroupStatus=Shutdown. Currently QueuedWorkItems=0; Total EnQueued=62; Total processed=62; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-4
9:Queued=0; Detailed SchedulingContext=&lt;[Activation: S127.0.0.1:22222:290365980*grn/445E9F94/4d9c9fd49aae6b67e56b7bb9551a5bb003000000445e9f94-0x59D33406@c22ca4a8 #GrainType=&lt;GrainType&gt; Placement=RandomPlacement State=Invalid
 NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:19.9822280 CollectionAgeLimit=02:00:00]&gt;`</Description>
    <Title_Description>Errors when deactivating a grain with transactional state Putting `DeactivateOnIdle` in a grain method that is part of a transaction causes `Orleans.Transactions.OrleansBrokenTransactionLockException: Transaction &lt;ID&gt; aborted because a broken lock was detected before prepare`. This mostly makes sense since a transaction lives beyond the normal concept of grain idle.

Trying to delay the deactivation even further also causes issues:
```c#
deactivationTimer = RegisterTimer(_ =&gt;
{
	deactivationTimer.Dispose();
	deactivationTimer = null;
	DeactivateOnIdle();
	return Task.CompletedTask;
} null TimeSpan.FromSeconds(2) TimeSpan.MaxValue);
```
Does lead to a successful deactivation; however the following is printed in the logs 5 times:
`Enqueuing task System.Threading.Tasks.Task to a stopped work item group. Going to ignore and not execute it. The likely reason is that the task is not being 'awaited' properly. WorkItemGroup:Name=[Activation: S127.0.0.1:22222:290365980*grn/445E9F
94/551a5bb0@c22ca4a8 #GrainType=&lt;GrainType&gt; Placement=RandomPlacement]WorkGroupStatus=Shutdown. Currently QueuedWorkItems=0; Total EnQueued=62; Total processed=62; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-4
9:Queued=0; Detailed SchedulingContext=&lt;[Activation: S127.0.0.1:22222:290365980*grn/445E9F94/4d9c9fd49aae6b67e56b7bb9551a5bb003000000445e9f94-0x59D33406@c22ca4a8 #GrainType=&lt;GrainType&gt; Placement=RandomPlacement State=Invalid
 NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:19.9822280 CollectionAgeLimit=02:00:00]&gt;`</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5446</IssueLabelID>
    <Title>Protected property in base class being changed by another grain at the same millisecond execution time</Title>
    <Description>Suppose we have the following class:

```
protected abstract class PersonBase : Grain IGrainWithGuidKey
{
public abstract string SetFullName(string fullname);
public abstract string DisplayFullName();
  protected string FullName {get;set;}
}

public class PersonGrain : PersonBase
{

public async Task SetFullName(string fullname)
{
await this.LogDebugAsync("Calling SetFullName").ConfigureAwait(false);
 this.FullName = fullname;
return Task.FormResult(null);
}

public async Task&lt;string&gt; DisplayFullName()
{
await this.LogDebugAsync("Calling DisplayFullName").ConfigureAwait(false);
return this.FullName;
}
}

```
If two grains (say PersonGrainA and PersonGrainB) being executed at the same millisecond execution time either PersonGrainA takes PersonGrainB's 'FullName' value or vice versa.

This is known issue within our prod env.  The work around we have now is to have FullName property in the actual class rather than in base class

```
protected abstract class PersonBase : Grain IGrainWithGuidKey
{
  
}

public class PersonGrain : PersonBase
{
public string FullName {get;set;}
}

```

We have parallel for each when calling the grain
`
Parallel.ForEach(grainIds (grainId) =&gt; { var person = client.GetGrain&lt;PersonGrain&gt;(grainId); person.SetFullName(someRandomName);  person.WriteLine(person.GetFullName());}`

Please note the grainIds is list collection with more 10K+ (the more the better chance to reproduce the behaviour) records all the time</Description>
    <Title_Description>Protected property in base class being changed by another grain at the same millisecond execution time Suppose we have the following class:

```
protected abstract class PersonBase : Grain IGrainWithGuidKey
{
public abstract string SetFullName(string fullname);
public abstract string DisplayFullName();
  protected string FullName {get;set;}
}

public class PersonGrain : PersonBase
{

public async Task SetFullName(string fullname)
{
await this.LogDebugAsync("Calling SetFullName").ConfigureAwait(false);
 this.FullName = fullname;
return Task.FormResult(null);
}

public async Task&lt;string&gt; DisplayFullName()
{
await this.LogDebugAsync("Calling DisplayFullName").ConfigureAwait(false);
return this.FullName;
}
}

```
If two grains (say PersonGrainA and PersonGrainB) being executed at the same millisecond execution time either PersonGrainA takes PersonGrainB's 'FullName' value or vice versa.

This is known issue within our prod env.  The work around we have now is to have FullName property in the actual class rather than in base class

```
protected abstract class PersonBase : Grain IGrainWithGuidKey
{
  
}

public class PersonGrain : PersonBase
{
public string FullName {get;set;}
}

```

We have parallel for each when calling the grain
`
Parallel.ForEach(grainIds (grainId) =&gt; { var person = client.GetGrain&lt;PersonGrain&gt;(grainId); person.SetFullName(someRandomName);  person.WriteLine(person.GetFullName());}`

Please note the grainIds is list collection with more 10K+ (the more the better chance to reproduce the behaviour) records all the time</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5445</IssueLabelID>
    <Title>Grain extensions are now available on system targets and Grain services</Title>
    <Description>
    </Description>
    <Title_Description>Grain extensions are now available on system targets and Grain services </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5444</IssueLabelID>
    <Title>Stream subscription from startup task doesn't quite work</Title>
    <Description>https://github.com/dotnet/orleans/issues/587 indicated that it should be possible to access streams from a startup task when using the direct client. This is sort of true but still has some issues.
For example:
```c#
await subscribe to stream
```
done directly from `IStartupTask.Execute` results in `InvalidOperationException("Attempting to GetCurrentActivationData when not in an activation scope")`.

However doing:
```c#
await Task.Run(async () =&gt; await subscribe to stream);
```
works just fine.

The issue appears to be caused by https://github.com/dotnet/orleans/blob/65405fdfc5dff5c1722f1391d29fe2fed17ddb33/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L758
since the startup task is running in an Orleans context and pushing to the thread pool breaks out and allows the `HostedClient` to be used.

After subscribing in the workaround manor the stream does seem to work as expected.</Description>
    <Title_Description>Stream subscription from startup task doesn't quite work https://github.com/dotnet/orleans/issues/587 indicated that it should be possible to access streams from a startup task when using the direct client. This is sort of true but still has some issues.
For example:
```c#
await subscribe to stream
```
done directly from `IStartupTask.Execute` results in `InvalidOperationException("Attempting to GetCurrentActivationData when not in an activation scope")`.

However doing:
```c#
await Task.Run(async () =&gt; await subscribe to stream);
```
works just fine.

The issue appears to be caused by https://github.com/dotnet/orleans/blob/65405fdfc5dff5c1722f1391d29fe2fed17ddb33/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L758
since the startup task is running in an Orleans context and pushing to the thread pool breaks out and allows the `HostedClient` to be used.

After subscribing in the workaround manor the stream does seem to work as expected.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5443</IssueLabelID>
    <Title>Fix a code typo in migration guide</Title>
    <Description>Trying to fill some gaps that I found trying to follow migration guides and pages.</Description>
    <Title_Description>Fix a code typo in migration guide Trying to fill some gaps that I found trying to follow migration guides and pages.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5442</IssueLabelID>
    <Title>Changelog for 2.3.0-rc2</Title>
    <Description>
    </Description>
    <Title_Description>Changelog for 2.3.0-rc2 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5441</IssueLabelID>
    <Title>Stop packing *.symbols.nupkg packages</Title>
    <Description>
    </Description>
    <Title_Description>Stop packing *.symbols.nupkg packages </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5439</IssueLabelID>
    <Title>Create many grains and detect that all grains are finished?</Title>
    <Description>Hello distributed computing framework is rare with .Net Orleans is excellent.

Our situation is that in Front-end user click a button to start a computing task(it is not Task in .Net) which is split into many sub-tasks and each sub-task or several sub-tasks is a grains the code may like below
```
// the count may be million here use 10000 as example
for(int ii = 0; ii &lt; 10000;ii++)
 {
    var elementCalculator = client.GetGrain&lt;IElementCalculator&gt;(ii);
    if (null == elementCalculator)
    {
        continue;
    }
    elementCalculator.Calculate("Good morning Hello Grain!");
}
```

the question are:
1. Whether it is suitable to create so many grains. I‘m afraid so many will take soil down or reduce performance
2. How to detect all grains are finished job. After all sub-tasks are finished then calculate summary value from values of sub-tasks. Is it suitable to waitall with so many Task?
3. Method "Calculate" of grains "IElementCalculator" may take long time to finish job Should use external task like Task.Run?

Thanks</Description>
    <Title_Description>Create many grains and detect that all grains are finished? Hello distributed computing framework is rare with .Net Orleans is excellent.

Our situation is that in Front-end user click a button to start a computing task(it is not Task in .Net) which is split into many sub-tasks and each sub-task or several sub-tasks is a grains the code may like below
```
// the count may be million here use 10000 as example
for(int ii = 0; ii &lt; 10000;ii++)
 {
    var elementCalculator = client.GetGrain&lt;IElementCalculator&gt;(ii);
    if (null == elementCalculator)
    {
        continue;
    }
    elementCalculator.Calculate("Good morning Hello Grain!");
}
```

the question are:
1. Whether it is suitable to create so many grains. I‘m afraid so many will take soil down or reduce performance
2. How to detect all grains are finished job. After all sub-tasks are finished then calculate summary value from values of sub-tasks. Is it suitable to waitall with so many Task?
3. Method "Calculate" of grains "IElementCalculator" may take long time to finish job Should use external task like Task.Run?

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5438</IssueLabelID>
    <Title>How to use consul to implement cluster</Title>
    <Description>How to use consul to implement cluster?
Is there relevant source code?
thx</Description>
    <Title_Description>How to use consul to implement cluster How to use consul to implement cluster?
Is there relevant source code?
thx</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5437</IssueLabelID>
    <Title>Introduced general component configurator pattern.</Title>
    <Description>- Added IComponentConfigurator as a general configurator for components with subcomponents.and/or multiple options.
- Added NamesServiceConfigurator base class for configuring named services with subcomponents and/or multiple options.
- Refactors stream configurators to use names service configurator configurator pattern.</Description>
    <Title_Description>Introduced general component configurator pattern. - Added IComponentConfigurator as a general configurator for components with subcomponents.and/or multiple options.
- Added NamesServiceConfigurator base class for configuring named services with subcomponents and/or multiple options.
- Refactors stream configurators to use names service configurator configurator pattern.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5432</IssueLabelID>
    <Title>Concerns regarding lack of separation between indexing and storage</Title>
    <Description>During our work on the CosmosDB provider we've found some concerns regarding the implementation of indexing and the lack of separation from the storage provider. 

The tl;dr should probably be something in the lines of "storage and indexing is different and in most cases will require different implementations backing them" there fore it should not be implemented by the same interface. 

A bit longer version:

1. Indexing is implicit in the write state async call the storage provider must be aware of how to enable indexing of selected paths or able to extract these from the state. 

According to code comments CosmosDB is currently the only provider supporting this and some providers such as Blob or table storage will have a hard time supporting it without companion service. 

Services not able to apply indexing directly on the state (Se also 3. on CosmosDB) will have to extract the indexed fields from state them self and store them properly. This seems to require a bit of duplicated and possible complex code in each provider which could be avoided using the defined methods DirectApplyIndexUpdate and DirectApplyIndexUpdateBatch defined in IIndexInterface and then call to an interface implemented by a (storage- or) Index-Provider. 

The index read query does not read state data it only returns GrainReference thus the index besides searching has no use of the state it self. 

2. Reading from index is done via dynamic without a defined interface although commented with "TODO: define IOrleansIndexingStorageProvider?"

If one are to implement an IndexingStorageProvider it would make even more sense to implement write this way as well.

3. The current implementation in CosmosDB effectively limits a grain type to at most 10GB of data as GrainType is used as partition key. 

The current CosmosDB implementatione queries using stored procedures which cannot be used in cross partition queries. As partitioning and querying is done by GrainType this limits the amount of data for a single grain type to 10GB. 

A pull request to allow [custom partitioning based on GrainReference](https://github.com/OrleansContrib/Orleans.CosmosDB/pull/26) solves this propblem for general state storage but does not address indexing. Indexing can still work with this pull request if the CosmosDB provided is change from a stored procedure query to a SQL query  `var query = 'SELECT * FROM c WHERE c.GrainType = "' + grainType + '" AND c.State.' + indexedField + ' = ' + key;`  with feed options set to allow cross partition queries. This will come at a potentially significant cost in terms of request charge on the CosmosDB and it may be that it will be better to store index data for CosmosDB separately with only the indexed data and grain reference partitioned by the grain type while letting the state it self follow custom partition key logic. Implementation of a separate index storage in CosmosDB based on calls from DirectApplyIndexUpdate seems doable. </Description>
    <Title_Description>Concerns regarding lack of separation between indexing and storage During our work on the CosmosDB provider we've found some concerns regarding the implementation of indexing and the lack of separation from the storage provider. 

The tl;dr should probably be something in the lines of "storage and indexing is different and in most cases will require different implementations backing them" there fore it should not be implemented by the same interface. 

A bit longer version:

1. Indexing is implicit in the write state async call the storage provider must be aware of how to enable indexing of selected paths or able to extract these from the state. 

According to code comments CosmosDB is currently the only provider supporting this and some providers such as Blob or table storage will have a hard time supporting it without companion service. 

Services not able to apply indexing directly on the state (Se also 3. on CosmosDB) will have to extract the indexed fields from state them self and store them properly. This seems to require a bit of duplicated and possible complex code in each provider which could be avoided using the defined methods DirectApplyIndexUpdate and DirectApplyIndexUpdateBatch defined in IIndexInterface and then call to an interface implemented by a (storage- or) Index-Provider. 

The index read query does not read state data it only returns GrainReference thus the index besides searching has no use of the state it self. 

2. Reading from index is done via dynamic without a defined interface although commented with "TODO: define IOrleansIndexingStorageProvider?"

If one are to implement an IndexingStorageProvider it would make even more sense to implement write this way as well.

3. The current implementation in CosmosDB effectively limits a grain type to at most 10GB of data as GrainType is used as partition key. 

The current CosmosDB implementatione queries using stored procedures which cannot be used in cross partition queries. As partitioning and querying is done by GrainType this limits the amount of data for a single grain type to 10GB. 

A pull request to allow [custom partitioning based on GrainReference](https://github.com/OrleansContrib/Orleans.CosmosDB/pull/26) solves this propblem for general state storage but does not address indexing. Indexing can still work with this pull request if the CosmosDB provided is change from a stored procedure query to a SQL query  `var query = 'SELECT * FROM c WHERE c.GrainType = "' + grainType + '" AND c.State.' + indexedField + ' = ' + key;`  with feed options set to allow cross partition queries. This will come at a potentially significant cost in terms of request charge on the CosmosDB and it may be that it will be better to store index data for CosmosDB separately with only the indexed data and grain reference partitioned by the grain type while letting the state it self follow custom partition key logic. Implementation of a separate index storage in CosmosDB based on calls from DirectApplyIndexUpdate seems doable. </Title_Description>
    <Label>design-review</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>11/03/2019 1:41:49 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5431</IssueLabelID>
    <Title>Orleans 2.3.0-rc1 and ASP.NET Core 3.0-preview3 co-hosting doesn't work</Title>
    <Description>Copying the problem from Gitter for better tracking.
Using the code like this:
```
    public class Program
    {
        public static void Main(string[] args)
        {
            var host = CreateHostBuilder(args).Build();
            host.Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                })
                .UseOrleans(builder =&gt;
                {
                    builder.UseLocalhostClustering();
                });
    }
```
app crashes at startup on row `host.Run()` with exception: `System.MissingMethodException: 'Method not found: 'Microsoft.Extensions.Hosting.IHostingEnvironment Microsoft.Extensions.Hosting.HostBuilderContext.get_HostingEnvironment()'.'`
It seems that due to https://github.com/aspnet/Announcements/issues/344 `HostBuilderContext.HostingEnvironment` now returns `IHostEnvironment` while Orleans expect `IHostingEnvironment`. I have updated `Microsoft.Extenstions.*` dependencies to 3.0.0-preview3.19153.1 and rebuilt Orleans and it worked.
Will it be fixed\released in Orleans or we should wait until ASP.NET Core 3.0 release?</Description>
    <Title_Description>Orleans 2.3.0-rc1 and ASP.NET Core 3.0-preview3 co-hosting doesn't work Copying the problem from Gitter for better tracking.
Using the code like this:
```
    public class Program
    {
        public static void Main(string[] args)
        {
            var host = CreateHostBuilder(args).Build();
            host.Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt;
                {
                    webBuilder.UseStartup&lt;Startup&gt;();
                })
                .UseOrleans(builder =&gt;
                {
                    builder.UseLocalhostClustering();
                });
    }
```
app crashes at startup on row `host.Run()` with exception: `System.MissingMethodException: 'Method not found: 'Microsoft.Extensions.Hosting.IHostingEnvironment Microsoft.Extensions.Hosting.HostBuilderContext.get_HostingEnvironment()'.'`
It seems that due to https://github.com/aspnet/Announcements/issues/344 `HostBuilderContext.HostingEnvironment` now returns `IHostEnvironment` while Orleans expect `IHostingEnvironment`. I have updated `Microsoft.Extenstions.*` dependencies to 3.0.0-preview3.19153.1 and rebuilt Orleans and it worked.
Will it be fixed\released in Orleans or we should wait until ASP.NET Core 3.0 release?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5427</IssueLabelID>
    <Title>Question: implement custom read-only stream provider</Title>
    <Description>Hi

We have a global event-log in our system (implemented using [SQLStreamStore](https://github.com/SQLStreamStore/SQLStreamStore)).

The system is based on JournalledGrains which write (produce) events to the log. 

After an event is sucessfully written it is published onto an orleans stream with a fixed namespace and a fixed id so essentially there is one large stream.

Eventprocessors are implemented using Implicit Subscriptions on the global stream.

Currently we're using the Azure storage queue streamprovider which is not optimal for our use-case. We're facing several problems:

1 a slow eventprocessor impact all event processing (because we use a single streamid/streamnamespace)
2 we can not rewind (start at a specific position) per eventprocessor
3 latency of eventprocessing is suboptimal because of dispatching the event to azure storage

We've discussed this internally and come up with 2 possible solutions:

**Drop orleans streams and subscribe directly to global event-log**

In this solution our eventprocessors each have an own cursor to the event-log this let's them work at their own pace without impacting other eventprocessors. They each poll the event-log for new messages after their last-processed event.

Challenges in this solution are
* Database overload.  
Because each eventprocessor is polling the database in short intervals this could overload the db. Solution would could to cache this per silo where each eventprocessor subscribes to the cache where it is activated challenges with this caching strategy are how to handle slow consumers
* Always-on eventprocessors
Eventprocessors have to be kept alive this could be implemented by some sort of watchdog-grain which invokes the eventprocessors at timed intervals to keep them alive. (we previously relied on implicit subscriptions for this).

**Hybrid solution implementing custom readonly-streamprovider**

Because our event-log is basically a stream we could implement our own (readonly) streamprovider for it. I've looked at the azure storage queue and the AWS implementations. Implementing something like that is fairly straightforward. But I have a few questions:
* how to make them rewindable
* how to implement this so each streamconsumer (on one single stream) does not impact each other.
* can orleans streaming be adapted so it is feasible to use with 1 stream and many subscribers








</Description>
    <Title_Description>Question: implement custom read-only stream provider Hi

We have a global event-log in our system (implemented using [SQLStreamStore](https://github.com/SQLStreamStore/SQLStreamStore)).

The system is based on JournalledGrains which write (produce) events to the log. 

After an event is sucessfully written it is published onto an orleans stream with a fixed namespace and a fixed id so essentially there is one large stream.

Eventprocessors are implemented using Implicit Subscriptions on the global stream.

Currently we're using the Azure storage queue streamprovider which is not optimal for our use-case. We're facing several problems:

1 a slow eventprocessor impact all event processing (because we use a single streamid/streamnamespace)
2 we can not rewind (start at a specific position) per eventprocessor
3 latency of eventprocessing is suboptimal because of dispatching the event to azure storage

We've discussed this internally and come up with 2 possible solutions:

**Drop orleans streams and subscribe directly to global event-log**

In this solution our eventprocessors each have an own cursor to the event-log this let's them work at their own pace without impacting other eventprocessors. They each poll the event-log for new messages after their last-processed event.

Challenges in this solution are
* Database overload.  
Because each eventprocessor is polling the database in short intervals this could overload the db. Solution would could to cache this per silo where each eventprocessor subscribes to the cache where it is activated challenges with this caching strategy are how to handle slow consumers
* Always-on eventprocessors
Eventprocessors have to be kept alive this could be implemented by some sort of watchdog-grain which invokes the eventprocessors at timed intervals to keep them alive. (we previously relied on implicit subscriptions for this).

**Hybrid solution implementing custom readonly-streamprovider**

Because our event-log is basically a stream we could implement our own (readonly) streamprovider for it. I've looked at the azure storage queue and the AWS implementations. Implementing something like that is fairly straightforward. But I have a few questions:
* how to make them rewindable
* how to implement this so each streamconsumer (on one single stream) does not impact each other.
* can orleans streaming be adapted so it is feasible to use with 1 stream and many subscribers








</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5426</IssueLabelID>
    <Title>IHostEnvironmentStatistics and runtime statistics improvements</Title>
    <Description>Working on this for Linux: #5423 

Todays implementation only considers stats on the host level so it accounts for everything running on server including other services. Now that docker and k8s is becoming increasingly common and Orleans being more suitable for microservices scenarios due to lower idle usage in recent versions it would be beneficial to change the `IHostEnvironmentStatistics` and related API's.

The interface covers
* Host CPU usage percentage
* Host total physical memory in bytes
* Host available memory in bytes

We could also get these stats for the silo/client process using perf counters for Windows and `/proc/{pid}/` for Linux
* Process CPU usage percentage
* Process memory usage in bytes

There's also all the `FloatValueStatistic/IntValueStatistic` things that store various runtime stats. 
I see now that `LoadShedQueueFlowController` uses the `StatisticNames.RUNTIME_CPUUSAGE` statistic so I would need to add to that statistic for loadshedding to work I'm assuming. So the abstraction here feels kind of messy but maybe it's ok. Just want to open the discussion.

As for our specific scenario we're at the end of finally migrating all our Windows IIS/Services stuff to Linux and .NET Core. So currently we are deploying all our services to 3 different vm's in an availability set. So there will be 4+ containers running on every vm and we use OrleansDashboard everywhere there's Orleans so having a process-specific graph for CPU/memory would be nice. Since Linux etc is pretty new to us we haven't yet decided on how to do monitoring and alerting but recognize that Prometheus + Grafana seems to be the "cloud native" choice. I've been thinking about writing a Prometheus exporter for Orleans stats but CPU/memory usage you could get from cgroup-exporter so don't know if that's worth it. But there are lots of other runtime `StatisticName`'s that look interesting for exporting.</Description>
    <Title_Description>IHostEnvironmentStatistics and runtime statistics improvements Working on this for Linux: #5423 

Todays implementation only considers stats on the host level so it accounts for everything running on server including other services. Now that docker and k8s is becoming increasingly common and Orleans being more suitable for microservices scenarios due to lower idle usage in recent versions it would be beneficial to change the `IHostEnvironmentStatistics` and related API's.

The interface covers
* Host CPU usage percentage
* Host total physical memory in bytes
* Host available memory in bytes

We could also get these stats for the silo/client process using perf counters for Windows and `/proc/{pid}/` for Linux
* Process CPU usage percentage
* Process memory usage in bytes

There's also all the `FloatValueStatistic/IntValueStatistic` things that store various runtime stats. 
I see now that `LoadShedQueueFlowController` uses the `StatisticNames.RUNTIME_CPUUSAGE` statistic so I would need to add to that statistic for loadshedding to work I'm assuming. So the abstraction here feels kind of messy but maybe it's ok. Just want to open the discussion.

As for our specific scenario we're at the end of finally migrating all our Windows IIS/Services stuff to Linux and .NET Core. So currently we are deploying all our services to 3 different vm's in an availability set. So there will be 4+ containers running on every vm and we use OrleansDashboard everywhere there's Orleans so having a process-specific graph for CPU/memory would be nice. Since Linux etc is pretty new to us we haven't yet decided on how to do monitoring and alerting but recognize that Prometheus + Grafana seems to be the "cloud native" choice. I've been thinking about writing a Prometheus exporter for Orleans stats but CPU/memory usage you could get from cgroup-exporter so don't know if that's worth it. But there are lots of other runtime `StatisticName`'s that look interesting for exporting.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5425</IssueLabelID>
    <Title>Refactored stream batch behaviors to support batch consumption.</Title>
    <Description>Only supported by persistent streams.</Description>
    <Title_Description>Refactored stream batch behaviors to support batch consumption. Only supported by persistent streams.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5424</IssueLabelID>
    <Title>Improve activation &amp; directory convergence</Title>
    <Description>Rebasing and fixing comments from #4344 </Description>
    <Title_Description>Improve activation &amp; directory convergence Rebasing and fixing comments from #4344 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5423</IssueLabelID>
    <Title>Linux version of IHostEnvironmentStatistics</Title>
    <Description>Started work on an implementation for `IHostEnvironmentStatistics` for Linux. Currently only one implementation for perf counters. 

Would like to have unit tests for these would like some suggestions on how to accomplish that. There are libraries for mocking filesystem but not sure if that dependency is wanted maybe there's another way? Doesn't look like there's any tests for the perfcounters one.

Haven't implemented anything for the `FloatValueStatistic` for CPU GC etc. Should I? I see from .NET Core 2.2 we can get some events from CoreCLR ETW provider.

Is it wanted/possible to consolidate this with the perfcounter one so that Orleans can inject the right instance based on `System.Environment.OSVersion`?</Description>
    <Title_Description>Linux version of IHostEnvironmentStatistics Started work on an implementation for `IHostEnvironmentStatistics` for Linux. Currently only one implementation for perf counters. 

Would like to have unit tests for these would like some suggestions on how to accomplish that. There are libraries for mocking filesystem but not sure if that dependency is wanted maybe there's another way? Doesn't look like there's any tests for the perfcounters one.

Haven't implemented anything for the `FloatValueStatistic` for CPU GC etc. Should I? I see from .NET Core 2.2 we can get some events from CoreCLR ETW provider.

Is it wanted/possible to consolidate this with the perfcounter one so that Orleans can inject the right instance based on `System.Environment.OSVersion`?</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5422</IssueLabelID>
    <Title>Update changelog up to 2.3.0-rc1</Title>
    <Description>
    </Description>
    <Title_Description>Update changelog up to 2.3.0-rc1 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5421</IssueLabelID>
    <Title>Co-hosting Orleans and ASP.NET in the same process - performance recommendations</Title>
    <Description>As requested on Gitter this is an open-ended thread to discuss what are the general performance benefits and drawbacks regarding co-hosting an ASP.NET Front-end (e.g. a RESTful API over Kestrel on ASP.NET Core) in the same process (and by consequence physical host) of an Orleans silo. This question takes special aim at Orleans' use of its own cooperative scheduler vs ASP.NET's use of the Thread Pool and how they would compete for host resources.

Specifically what are the engineering team's thoughts regarding:
- CPU expenditure on thread context switching.
- CPU cache use and possible trashing.
- Scalability benefits and drawbacks.
- Performance benefits and drawbacks.
- Memory contention and possible virtual memory trashing.
- Benefit/drawback relationship as cluster size increases.

The idea is to have some good practice pointers for Orleans users like me to decide when/if it is a good idea to host ASP.NET and Orleans together in the same process (and thereby physical host) or to keep them separate in a client-silo relationship across separate processes (and also machines via the wire) and in what conditions.

If there is already some official documentation regarding this then apologies for raising the issue and "preemptive" thanks for redirecting me to it. If not then happy to gather relevant input and PR the docs.</Description>
    <Title_Description>Co-hosting Orleans and ASP.NET in the same process - performance recommendations As requested on Gitter this is an open-ended thread to discuss what are the general performance benefits and drawbacks regarding co-hosting an ASP.NET Front-end (e.g. a RESTful API over Kestrel on ASP.NET Core) in the same process (and by consequence physical host) of an Orleans silo. This question takes special aim at Orleans' use of its own cooperative scheduler vs ASP.NET's use of the Thread Pool and how they would compete for host resources.

Specifically what are the engineering team's thoughts regarding:
- CPU expenditure on thread context switching.
- CPU cache use and possible trashing.
- Scalability benefits and drawbacks.
- Performance benefits and drawbacks.
- Memory contention and possible virtual memory trashing.
- Benefit/drawback relationship as cluster size increases.

The idea is to have some good practice pointers for Orleans users like me to decide when/if it is a good idea to host ASP.NET and Orleans together in the same process (and thereby physical host) or to keep them separate in a client-silo relationship across separate processes (and also machines via the wire) and in what conditions.

If there is already some official documentation regarding this then apologies for raising the issue and "preemptive" thanks for redirecting me to it. If not then happy to gather relevant input and PR the docs.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5419</IssueLabelID>
    <Title>Orleans Streaming - sparse streams scenario</Title>
    <Description>Hi! In our company we are trying to use Orleans for IoT scenario. We using IoT Hub/EventHub.
I did a significant amount of research around how to do this properly using available possibilities in Orleans. It turned out that we cannot use Streaming with modified EventHub provider as current implementation has problems with huge number of sparse streams (if we would like to use Stream per Device). Each device can send relatively small amount of data in not so short period like one minute for example. But we can have them really huge number like half millions. That in average can give us around 8k messages per second to the system but for each device - one message per minute. 
Currently using Orleans that way (Stream per Device) turns out really quickly to be inefficient (around 10-20k streams). For that reason we choose hosting EPH along with the silo (as GrainService) and just pass messages directly to the "device" grain. That easily could handle 500k grains (if machine RAM was enough). 
I did some time ago discussion about that with @jason-bragg and eventually possibilities of implementing/improving current Streams to handle sparse streams. 
Now i have a time to do more investigation on that and would like to play with it a bit. I wonder if we could have discussion here how this could be handled inside Orleans runtime - some guidance from you guys so i could know where to start looking at. </Description>
    <Title_Description>Orleans Streaming - sparse streams scenario Hi! In our company we are trying to use Orleans for IoT scenario. We using IoT Hub/EventHub.
I did a significant amount of research around how to do this properly using available possibilities in Orleans. It turned out that we cannot use Streaming with modified EventHub provider as current implementation has problems with huge number of sparse streams (if we would like to use Stream per Device). Each device can send relatively small amount of data in not so short period like one minute for example. But we can have them really huge number like half millions. That in average can give us around 8k messages per second to the system but for each device - one message per minute. 
Currently using Orleans that way (Stream per Device) turns out really quickly to be inefficient (around 10-20k streams). For that reason we choose hosting EPH along with the silo (as GrainService) and just pass messages directly to the "device" grain. That easily could handle 500k grains (if machine RAM was enough). 
I did some time ago discussion about that with @jason-bragg and eventually possibilities of implementing/improving current Streams to handle sparse streams. 
Now i have a time to do more investigation on that and would like to play with it a bit. I wonder if we could have discussion here how this could be handled inside Orleans runtime - some guidance from you guys so i could know where to start looking at. </Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5418</IssueLabelID>
    <Title>NPE on parsing the partition of an IOT Event Hub endpoint</Title>
    <Description>I've spent some time on trying to get the AddEventHubStreams to put from the IOT Hubs default endpoint and I'm running into the same issues that @andrew-laughlin is reporting here (https://github.com/dotnet/orleans/issues/4572#issue-321329955) ... @jason-bragg I noticed that much of this code was written by you so I'm hoping you can help as I may just be doing something wrong.  Here is what I've got -- and I'm hoping I am just doing something stupid and don't need to extend all the classes as Andrew did.

```
private static async Task&lt;ISiloHost&gt; StartSilo()
{
    // define the cluster configuration
    var builder = new SiloHostBuilder()
        .UseLocalhostClustering()
        .Configure&lt;ClusterOptions&gt;(options =&gt;
        {
            options.ClusterId = "dev";
            options.ServiceId = "HelloWorldApp";
        })
        .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
        .AddMemoryGrainStorage("PubSubStore")
        .AddEventHubStreams("Source.AntEvents" (SiloEventHubStreamConfigurator c) =&gt; {
            c.ConfigureEventHub((opts) =&gt;
            {
                opts.Configure(options =&gt;
                {
                    options.ConnectionString = "Endpoint=sb://iothub-ns-**********.servicebus.windows.net/;SharedAccessKeyName=&lt;owner&gt;;SharedAccessKey=&lt;key&gt;;EntityPath=ao-iot-dev-1";
                    options.ConsumerGroup = "OrleansSiloHost";
                    options.Path = "ao-iot-dev-1";
                });
            })
            .UseEventHubCheckpointer(opts =&gt; opts.Configure(options =&gt;
            {
                options.ConnectionString = &lt;connection string&gt;;
                options.TableName = "orleanspubsubtbl";
                options.PersistInterval = TimeSpan.FromSeconds(1);
            }))
            .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly);
        })
        .ConfigureLogging(logging =&gt; logging.AddConsole());

    var host = builder.Build();
    await host.StartAsync();
    return host;
}
```

Here is my Implicit Receiver Grain:
```
[ImplicitStreamSubscription("iothub-ns-**********")]
    public class EventHubSubscriber : Grain IEventHubSubscriber IAsyncObserver&lt;string&gt;
    {
        public async override Task OnActivateAsync()
        {
            var streamProvider = GetStreamProvider(SiloHostProviders.AntPlusStreamingProvider);
            var stream = streamProvider.GetStream&lt;string&gt;(this.GetPrimaryKey() "iothub-ns-**********");
            await stream.SubscribeAsync(this);
        }

        public Task OnCompletedAsync()
        {
            Console.WriteLine("Completed.");
            return Task.CompletedTask;
        }

        public Task OnErrorAsync(Exception ex)
        {
            Console.WriteLine("ERROR: " + ex.Message);
            return Task.CompletedTask;
        }

        public Task OnNextAsync(string item StreamSequenceToken token = null)
        {
            Console.WriteLine("Received: " + item);
            return Task.CompletedTask;
        }
    }
```

And here is the error output.  Line 252 is where it is trying to parse the partition ID; however the partitions are showing in the logging as 0 and 1 which are hooked up to Queues.

```
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103502]
      Init.
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103503]
      Initialize: I am now responsible for 2 queues: [source.antevents-0 source.antevents-1].
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103517]
      Starting agents for 2 queues: [source.antevents-0 source.antevents-1]
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103301]
      Created PersistentStreamPullingAgent *stg/1515185665224622770/4e5cba2a2274a31c15070555b07a42b201000000000000ff-0x26156FA1 for Stream Provider Source.AntEvents on silo S127.0.0.1:11111:289281871 for Queue source.antevents-0-0x00000000.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103301]
      Created PersistentStreamPullingAgent *stg/3261463326979622579/42fdbe1d2be353442d430b9dac9586b301000000000000ff-0xD22CAFD5 for Stream Provider Source.AntEvents on silo S127.0.0.1:11111:289281871 for Queue source.antevents-1-0x80000001.
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103302]
      Init of PersistentStreamPullingAgent *stg/1515185665224622770/4e5cba2a2274a31c15070555b07a42b201000000000000ff-0x26156FA1 on silo S127.0.0.1:11111:289281871 for queue source.antevents-0-0x00000000.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103302]
      Init of PersistentStreamPullingAgent *stg/3261463326979622579/42fdbe1d2be353442d430b9dac9586b301000000000000ff-0xD22CAFD5 on silo S127.0.0.1:11111:289281871 for queue source.antevents-1-0x80000001.
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.0[0]
      Initializing EventHub partition ao-iot-dev-1-0.
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.1[0]
      Initializing EventHub partition ao-iot-dev-1-1.
info: Orleans.ServiceBus.Providers.EventHubCheckpointer[0]
      Creating EventHub checkpointer for partition 1 of stream provider Source.AntEvents with serviceId HelloWorldApp.
info: Orleans.ServiceBus.Providers.EventHubCheckpointer[0]
      Creating EventHub checkpointer for partition 0 of stream provider Source.AntEvents with serviceId HelloWorldApp.
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103304]
      Taking queue source.antevents-0-0x00000000 under my responsibility.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103304]
      Taking queue source.antevents-1-0x80000001 under my responsibility.
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103508]
      Added 2 new queues: [source.antevents-0 source.antevents-1]. Now own total of 2 queues: [source.antevents-0 source.antevents-1]
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103519]
      Started agents.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-Source.AntEvents started in stage 20000 which took 156 Milliseconds.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Starting lifecycle stage 20000 took 156.4409 Milliseconds
info: Orleans.Streaming.EventHubs.AzureTableDataManager[100801]
      Attached to Azure storage table orleanspubsubtbl
info: Orleans.Streaming.EventHubs.AzureTableDataManager[100801]
      Attached to Azure storage table orleanspubsubtbl
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.0[0]
      Starting to read latest messages from EventHub partition ao-iot-dev-1-0 at offset -1
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.1[0]
      Starting to read latest messages from EventHub partition ao-iot-dev-1-1 at offset 105560
      ...........
      ...........
      ...........
info: Orleans.Runtime.Catalog[100507]
      Before collection#2: memory=9MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
info: Orleans.Runtime.Catalog[100508]
      After collection#2: memory=9MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0019287.
warn: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103312]
      Exception while retrying the 0th time reading from queue source.antevents-1
System.ArgumentNullException: Value cannot be null.
Parameter name: input
   at System.Guid.Parse(String input)
   at Orleans.ServiceBus.Providers.EventHubDataAdapter.GetStreamPosition(EventData queueMessage) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubDataAdapter.cs:line 252
   at Orleans.ServiceBus.Providers.EventHubDataAdapter.QueueMessageToCachedMessage(CachedEventHubMessage&amp; cachedMessage EventData queueMessage DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubDataAdapter.cs:line 205
   at Orleans.Providers.Streams.Common.CachedMessageBlock`1.Add[TQueueMessage](TQueueMessage queueMessage DateTime dequeueTimeUtc ICacheDataAdapter`2 dataAdapter) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\CachedMessageBlock.cs:line 118
   at Orleans.Providers.Streams.Common.CachedMessagePool`2.AllocateMessage(TQueueMessage queueMessage DateTime dequeueTimeUtc StreamPosition&amp; streamPosition) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\CachedMessagePool.cs:line 42
   at Orleans.Providers.Streams.Common.PooledQueueCache`2.Add(TQueueMessage message DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\PooledQueueCache.cs:line 330
   at Orleans.Providers.Streams.Common.PooledQueueCache`2.Add(List`1 messages DateTime dequeueTime) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\PooledQueueCache.cs:line 312
   at Orleans.ServiceBus.Providers.EventHubQueueCache`1.Add(List`1 messages DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubQueueCache.cs:line 136
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetQueueMessagesAsync(Int32 maxCount) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 190
   at Orleans.Streams.PersistentStreamPullingAgent.ReadFromQueue(QueueId myQueueId IQueueAdapterReceiver rcvr Int32 maxCacheAddCount) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 435
   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\AsyncExecutorWithRetries.cs:line 143
```
</Description>
    <Title_Description>NPE on parsing the partition of an IOT Event Hub endpoint I've spent some time on trying to get the AddEventHubStreams to put from the IOT Hubs default endpoint and I'm running into the same issues that @andrew-laughlin is reporting here (https://github.com/dotnet/orleans/issues/4572#issue-321329955) ... @jason-bragg I noticed that much of this code was written by you so I'm hoping you can help as I may just be doing something wrong.  Here is what I've got -- and I'm hoping I am just doing something stupid and don't need to extend all the classes as Andrew did.

```
private static async Task&lt;ISiloHost&gt; StartSilo()
{
    // define the cluster configuration
    var builder = new SiloHostBuilder()
        .UseLocalhostClustering()
        .Configure&lt;ClusterOptions&gt;(options =&gt;
        {
            options.ClusterId = "dev";
            options.ServiceId = "HelloWorldApp";
        })
        .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
        .AddMemoryGrainStorage("PubSubStore")
        .AddEventHubStreams("Source.AntEvents" (SiloEventHubStreamConfigurator c) =&gt; {
            c.ConfigureEventHub((opts) =&gt;
            {
                opts.Configure(options =&gt;
                {
                    options.ConnectionString = "Endpoint=sb://iothub-ns-**********.servicebus.windows.net/;SharedAccessKeyName=&lt;owner&gt;;SharedAccessKey=&lt;key&gt;;EntityPath=ao-iot-dev-1";
                    options.ConsumerGroup = "OrleansSiloHost";
                    options.Path = "ao-iot-dev-1";
                });
            })
            .UseEventHubCheckpointer(opts =&gt; opts.Configure(options =&gt;
            {
                options.ConnectionString = &lt;connection string&gt;;
                options.TableName = "orleanspubsubtbl";
                options.PersistInterval = TimeSpan.FromSeconds(1);
            }))
            .ConfigureStreamPubSub(StreamPubSubType.ImplicitOnly);
        })
        .ConfigureLogging(logging =&gt; logging.AddConsole());

    var host = builder.Build();
    await host.StartAsync();
    return host;
}
```

Here is my Implicit Receiver Grain:
```
[ImplicitStreamSubscription("iothub-ns-**********")]
    public class EventHubSubscriber : Grain IEventHubSubscriber IAsyncObserver&lt;string&gt;
    {
        public async override Task OnActivateAsync()
        {
            var streamProvider = GetStreamProvider(SiloHostProviders.AntPlusStreamingProvider);
            var stream = streamProvider.GetStream&lt;string&gt;(this.GetPrimaryKey() "iothub-ns-**********");
            await stream.SubscribeAsync(this);
        }

        public Task OnCompletedAsync()
        {
            Console.WriteLine("Completed.");
            return Task.CompletedTask;
        }

        public Task OnErrorAsync(Exception ex)
        {
            Console.WriteLine("ERROR: " + ex.Message);
            return Task.CompletedTask;
        }

        public Task OnNextAsync(string item StreamSequenceToken token = null)
        {
            Console.WriteLine("Received: " + item);
            return Task.CompletedTask;
        }
    }
```

And here is the error output.  Line 252 is where it is trying to parse the partition ID; however the partitions are showing in the logging as 0 and 1 which are hooked up to Queues.

```
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103502]
      Init.
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103503]
      Initialize: I am now responsible for 2 queues: [source.antevents-0 source.antevents-1].
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103517]
      Starting agents for 2 queues: [source.antevents-0 source.antevents-1]
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103301]
      Created PersistentStreamPullingAgent *stg/1515185665224622770/4e5cba2a2274a31c15070555b07a42b201000000000000ff-0x26156FA1 for Stream Provider Source.AntEvents on silo S127.0.0.1:11111:289281871 for Queue source.antevents-0-0x00000000.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103301]
      Created PersistentStreamPullingAgent *stg/3261463326979622579/42fdbe1d2be353442d430b9dac9586b301000000000000ff-0xD22CAFD5 for Stream Provider Source.AntEvents on silo S127.0.0.1:11111:289281871 for Queue source.antevents-1-0x80000001.
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103302]
      Init of PersistentStreamPullingAgent *stg/1515185665224622770/4e5cba2a2274a31c15070555b07a42b201000000000000ff-0x26156FA1 on silo S127.0.0.1:11111:289281871 for queue source.antevents-0-0x00000000.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103302]
      Init of PersistentStreamPullingAgent *stg/3261463326979622579/42fdbe1d2be353442d430b9dac9586b301000000000000ff-0xD22CAFD5 on silo S127.0.0.1:11111:289281871 for queue source.antevents-1-0x80000001.
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.0[0]
      Initializing EventHub partition ao-iot-dev-1-0.
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.1[0]
      Initializing EventHub partition ao-iot-dev-1-1.
info: Orleans.ServiceBus.Providers.EventHubCheckpointer[0]
      Creating EventHub checkpointer for partition 1 of stream provider Source.AntEvents with serviceId HelloWorldApp.
info: Orleans.ServiceBus.Providers.EventHubCheckpointer[0]
      Creating EventHub checkpointer for partition 0 of stream provider Source.AntEvents with serviceId HelloWorldApp.
info: Orleans.Streams.*stg/1515185665224622770/b07a42b2.Source.AntEvents[103304]
      Taking queue source.antevents-0-0x00000000 under my responsibility.
info: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103304]
      Taking queue source.antevents-1-0x80000001 under my responsibility.
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103508]
      Added 2 new queues: [source.antevents-0 source.antevents-1]. Now own total of 2 queues: [source.antevents-0 source.antevents-1]
info: Orleans.Streams.PersistentStreamPullingManager-Source.AntEvents[103519]
      Started agents.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-Source.AntEvents started in stage 20000 which took 156 Milliseconds.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Starting lifecycle stage 20000 took 156.4409 Milliseconds
info: Orleans.Streaming.EventHubs.AzureTableDataManager[100801]
      Attached to Azure storage table orleanspubsubtbl
info: Orleans.Streaming.EventHubs.AzureTableDataManager[100801]
      Attached to Azure storage table orleanspubsubtbl
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.0[0]
      Starting to read latest messages from EventHub partition ao-iot-dev-1-0 at offset -1
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.ao-iot-dev-1.1[0]
      Starting to read latest messages from EventHub partition ao-iot-dev-1-1 at offset 105560
      ...........
      ...........
      ...........
info: Orleans.Runtime.Catalog[100507]
      Before collection#2: memory=9MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
info: Orleans.Runtime.Catalog[100508]
      After collection#2: memory=9MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0019287.
warn: Orleans.Streams.*stg/3261463326979622579/ac9586b3.Source.AntEvents[103312]
      Exception while retrying the 0th time reading from queue source.antevents-1
System.ArgumentNullException: Value cannot be null.
Parameter name: input
   at System.Guid.Parse(String input)
   at Orleans.ServiceBus.Providers.EventHubDataAdapter.GetStreamPosition(EventData queueMessage) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubDataAdapter.cs:line 252
   at Orleans.ServiceBus.Providers.EventHubDataAdapter.QueueMessageToCachedMessage(CachedEventHubMessage&amp; cachedMessage EventData queueMessage DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubDataAdapter.cs:line 205
   at Orleans.Providers.Streams.Common.CachedMessageBlock`1.Add[TQueueMessage](TQueueMessage queueMessage DateTime dequeueTimeUtc ICacheDataAdapter`2 dataAdapter) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\CachedMessageBlock.cs:line 118
   at Orleans.Providers.Streams.Common.CachedMessagePool`2.AllocateMessage(TQueueMessage queueMessage DateTime dequeueTimeUtc StreamPosition&amp; streamPosition) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\CachedMessagePool.cs:line 42
   at Orleans.Providers.Streams.Common.PooledQueueCache`2.Add(TQueueMessage message DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\PooledQueueCache.cs:line 330
   at Orleans.Providers.Streams.Common.PooledQueueCache`2.Add(List`1 messages DateTime dequeueTime) in D:\build\agent\_work\24\s\src\OrleansProviders\Streams\Common\PooledCache\PooledQueueCache.cs:line 312
   at Orleans.ServiceBus.Providers.EventHubQueueCache`1.Add(List`1 messages DateTime dequeueTimeUtc) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubQueueCache.cs:line 136
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetQueueMessagesAsync(Int32 maxCount) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 190
   at Orleans.Streams.PersistentStreamPullingAgent.ReadFromQueue(QueueId myQueueId IQueueAdapterReceiver rcvr Int32 maxCacheAddCount) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 435
   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\AsyncExecutorWithRetries.cs:line 143
```
</Title_Description>
    <Label>duplicate</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5415</IssueLabelID>
    <Title>Question/Feature request LoadShedding</Title>
    <Description>I'm not positive on this but @sergeybykov said to put in an issue to research/investigate possibilities:

@Kritner:
&gt; it seems like utilizing LoadShedding would prevent new clients from connecting in times of overloading... is there a way to disable *that* particular portion of load shedding?

@sergeybykov:
&gt; When load shedding kicks in it starts rejecting client requests. I wonder if what you are seeing is not rejection of a client connection per se but of it's first call to retrieve the grain type map. Could you open an issue on that please. Maybe we should consider special treatment of those calls (if my guess is correct).

I can try to put together a repro at some point but from what I can recall I set my `LoadSheddingLimit` value to a low amount - low enough that the silo would *always* be overloaded in my local testing.   With the single silo cluster running (using development clustering) I was not successfully connecting to the silo from with a client.  Once disabling `LoadShedding` or setting my threshold higher connections went through w/o issue.

I guess if it's not the client connection failing but the call @sergeybykov referenced about retrieving a grain type map then that could complicate things a bit.  I guess I was hoping that client connections (and everything that a connection entails) would be kept separate from the load shedding.</Description>
    <Title_Description>Question/Feature request LoadShedding I'm not positive on this but @sergeybykov said to put in an issue to research/investigate possibilities:

@Kritner:
&gt; it seems like utilizing LoadShedding would prevent new clients from connecting in times of overloading... is there a way to disable *that* particular portion of load shedding?

@sergeybykov:
&gt; When load shedding kicks in it starts rejecting client requests. I wonder if what you are seeing is not rejection of a client connection per se but of it's first call to retrieve the grain type map. Could you open an issue on that please. Maybe we should consider special treatment of those calls (if my guess is correct).

I can try to put together a repro at some point but from what I can recall I set my `LoadSheddingLimit` value to a low amount - low enough that the silo would *always* be overloaded in my local testing.   With the single silo cluster running (using development clustering) I was not successfully connecting to the silo from with a client.  Once disabling `LoadShedding` or setting my threshold higher connections went through w/o issue.

I guess if it's not the client connection failing but the call @sergeybykov referenced about retrieving a grain type map then that could complicate things a bit.  I guess I was hoping that client connections (and everything that a connection entails) would be kept separate from the load shedding.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5414</IssueLabelID>
    <Title>Revert "Migrate src subdirectory to new codegen (#5365)"</Title>
    <Description>#5365 broke our code signing pipeline. We can revert it for now and remerge it back when we update the signing process.</Description>
    <Title_Description>Revert "Migrate src subdirectory to new codegen (#5365)" #5365 broke our code signing pipeline. We can revert it for now and remerge it back when we update the signing process.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5411</IssueLabelID>
    <Title>Test Reliability: Timeout_LongMethod</Title>
    <Description>The `UnitTests.TimeoutTests.Timeout_LongMethod` test is flaky. 
Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2612/testReport/junit/UnitTests/TimeoutTests/Timeout_LongMethod/

```
MESSAGE:
Waited longer than 00:00:02. Waited 00:00:02.0031156\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at UnitTests.TimeoutTests.Timeout_LongMethod() in D:\j\workspace\functional_pr---83d31c72
\test\TesterInternal\TimeoutTests.cs:line 67
```</Description>
    <Title_Description>Test Reliability: Timeout_LongMethod The `UnitTests.TimeoutTests.Timeout_LongMethod` test is flaky. 
Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2612/testReport/junit/UnitTests/TimeoutTests/Timeout_LongMethod/

```
MESSAGE:
Waited longer than 00:00:02. Waited 00:00:02.0031156\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at UnitTests.TimeoutTests.Timeout_LongMethod() in D:\j\workspace\functional_pr---83d31c72
\test\TesterInternal\TimeoutTests.cs:line 67
```</Title_Description>
    <Label>test-issue</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>28/02/2019 3:10:35 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5409</IssueLabelID>
    <Title>Minor serialization perf &amp; cleanliness improvements</Title>
    <Description>Minor serializer perf fixes. Can hold until after 2.3.0 is tagged.

Fixes #4443

Also see comment: https://github.com/dotnet/orleans/pull/5210#issuecomment-443859708</Description>
    <Title_Description>Minor serialization perf &amp; cleanliness improvements Minor serializer perf fixes. Can hold until after 2.3.0 is tagged.

Fixes #4443

Also see comment: https://github.com/dotnet/orleans/pull/5210#issuecomment-443859708</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5408</IssueLabelID>
    <Title>Removed filtering from streaming infrastructure</Title>
    <Description>Breaking changes to core.abstractions so this is at earliest a 3.0 change</Description>
    <Title_Description>Removed filtering from streaming infrastructure Breaking changes to core.abstractions so this is at earliest a 3.0 change</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5405</IssueLabelID>
    <Title>hack to allow physical file provider to be serialized using json</Title>
    <Description>
    </Description>
    <Title_Description>hack to allow physical file provider to be serialized using json </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5404</IssueLabelID>
    <Title>Backport PRs #3974 and #5184 to 1.5.7</Title>
    <Description> #3974 (Fixes for Multi-Cluster Support).
#5184 (Add GSI cache maintenance and tests).</Description>
    <Title_Description>Backport PRs #3974 and #5184 to 1.5.7  #3974 (Fixes for Multi-Cluster Support).
#5184 (Add GSI cache maintenance and tests).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5403</IssueLabelID>
    <Title>got an item for subscription  but I don't have any subscriber for that stream. Dropping on the floor. while pushing message from external service</Title>
    <Description>
    </Description>
    <Title_Description>got an item for subscription , but I don't have any subscriber for that stream. Dropping on the floor. while pushing message from external service </Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5402</IssueLabelID>
    <Title>Fixed function persistence tests</Title>
    <Description>Fixed function persistence tests broken when IPersistentState facet was introduced.</Description>
    <Title_Description>Fixed function persistence tests Fixed function persistence tests broken when IPersistentState facet was introduced.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5401</IssueLabelID>
    <Title>Fix OneWay cache invalidation</Title>
    <Description>Fixes #4896

When a OneWay message is destined for a defunct activation send a rejection response for the purpose of cache invalidation. This rejection is sent even though the message may be forwarded on to a new activation simultaneously. The rejection is ignored by the receiver after the cache invalidation headers have been inspected.</Description>
    <Title_Description>Fix OneWay cache invalidation Fixes #4896

When a OneWay message is destined for a defunct activation send a rejection response for the purpose of cache invalidation. This rejection is sent even though the message may be forwarded on to a new activation simultaneously. The rejection is ignored by the receiver after the cache invalidation headers have been inspected.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5400</IssueLabelID>
    <Title>Adds a LoadSheddingValidator class</Title>
    <Description>- Adds as a default validator within `DefaultSiloServices`
- Should only validate `LoadSheddingOptions` when not null
- Checks LoadSheddingLimit not more than 100% CPU
- Ensures a non default and non null implementation of `IHostEnvironmentStatistics` has been registered.
- Fixes #4389

I did not see (at a glance) any test classes for validator classes... this seems like it should work... maybe?</Description>
    <Title_Description>Adds a LoadSheddingValidator class - Adds as a default validator within `DefaultSiloServices`
- Should only validate `LoadSheddingOptions` when not null
- Checks LoadSheddingLimit not more than 100% CPU
- Ensures a non default and non null implementation of `IHostEnvironmentStatistics` has been registered.
- Fixes #4389

I did not see (at a glance) any test classes for validator classes... this seems like it should work... maybe?</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5399</IssueLabelID>
    <Title>Upgraded Microsoft.Azure.EventHubs package to 3.0.0.</Title>
    <Description>The `Microsoft.Azure.EventHubs` package was upgraded to `2.2.1` to resolve #5369. 

A `3.0.0` version of this package has recently been released. 

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/3.0.0

This PR extends the upgrade to `3.0.0` and takes advantage of the `EventData.SystemProperties` being made public to remove reflection based helpers.</Description>
    <Title_Description>Upgraded Microsoft.Azure.EventHubs package to 3.0.0. The `Microsoft.Azure.EventHubs` package was upgraded to `2.2.1` to resolve #5369. 

A `3.0.0` version of this package has recently been released. 

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/3.0.0

This PR extends the upgrade to `3.0.0` and takes advantage of the `EventData.SystemProperties` being made public to remove reflection based helpers.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5398</IssueLabelID>
    <Title>System.Reflection.AmbiguousMatchException: 'Multiple custom attributes of the same type found.'</Title>
    <Description>Hi

When I used the Dashboard v2.2.0 with Orleans.Server v2.2.4 the following exception throws:

```
Unhandled Exception: System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found.
   at System.Attribute.GetCustomAttribute(Assembly element Type attributeType Boolean inherit)
   at System.Reflection.CustomAttributeExtensions.GetCustomAttribute[T](Assembly element)
   at Orleans.CodeGenerator.RoslynCodeGenerator.ShouldGenerateCodeForAssembly(Assembly assembly) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 653
   at System.Linq.Enumerable.WhereListIterator`1.ToList()
   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)
   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateAndLoadForAssemblies(IEnumerable`1 assemblies) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 109
   at Orleans.Hosting.ApplicationPartManagerCodeGenExtensions.WithCodeGeneration(IApplicationPartManagerWithAssemblies manager ILoggerFactory loggerFactory) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\ApplicationPartManagerCodeGenExtensions.cs:line 46
   at Orleans.ServiceCollectionExtensions.&lt;&gt;c.&lt;UseDashboard&gt;b__0_0(IApplicationPartManager appParts)
   at Orleans.Hosting.SiloHostBuilderExtensions.ConfigureApplicationParts(ISiloHostBuilder builder Action`1 configure) in D:\build\agent\_work\24\s\src\Orleans.Runtime.Abstractions\Hosting\Generic\SiloHostBuilderExtensions.cs:line 153
   at Orleans.ServiceCollectionExtensions.UseDashboard(ISiloHostBuilder builder Action`1 configurator)
```
The workaround is to downgrade Microsoft.Orleans.Server to v2.2.0 and just worked again... but would be nice if latest verions can be used. 
</Description>
    <Title_Description>System.Reflection.AmbiguousMatchException: 'Multiple custom attributes of the same type found.' Hi

When I used the Dashboard v2.2.0 with Orleans.Server v2.2.4 the following exception throws:

```
Unhandled Exception: System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found.
   at System.Attribute.GetCustomAttribute(Assembly element Type attributeType Boolean inherit)
   at System.Reflection.CustomAttributeExtensions.GetCustomAttribute[T](Assembly element)
   at Orleans.CodeGenerator.RoslynCodeGenerator.ShouldGenerateCodeForAssembly(Assembly assembly) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 653
   at System.Linq.Enumerable.WhereListIterator`1.ToList()
   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)
   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateAndLoadForAssemblies(IEnumerable`1 assemblies) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 109
   at Orleans.Hosting.ApplicationPartManagerCodeGenExtensions.WithCodeGeneration(IApplicationPartManagerWithAssemblies manager ILoggerFactory loggerFactory) in D:\build\agent\_work\25\s\src\Orleans.CodeGeneration\ApplicationPartManagerCodeGenExtensions.cs:line 46
   at Orleans.ServiceCollectionExtensions.&lt;&gt;c.&lt;UseDashboard&gt;b__0_0(IApplicationPartManager appParts)
   at Orleans.Hosting.SiloHostBuilderExtensions.ConfigureApplicationParts(ISiloHostBuilder builder Action`1 configure) in D:\build\agent\_work\24\s\src\Orleans.Runtime.Abstractions\Hosting\Generic\SiloHostBuilderExtensions.cs:line 153
   at Orleans.ServiceCollectionExtensions.UseDashboard(ISiloHostBuilder builder Action`1 configurator)
```
The workaround is to downgrade Microsoft.Orleans.Server to v2.2.0 and just worked again... but would be nice if latest verions can be used. 
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5397</IssueLabelID>
    <Title>Test Reliability: ExceptionPropagation_ClientToGrain_SerializationFailure</Title>
    <Description>UnitTests.General.ExceptionPropagationTests.ExceptionPropagation_ClientToGrain_SerializationFailure is flaky. Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2578/testReport/junit/UnitTests.General/ExceptionPropagationTests/ExceptionPropagation_ClientToGrain_SerializationFailure/

```
Stacktrace

MESSAGE:
Assert.Throws() Failure\r\nExpected: typeof(System.NotSupportedException)\r\nActual: 
typeof(System.TimeoutException): Response did not arrive on time in 00:00:30 for message: Request 
*cli/1770639c@44a482a6-&gt;S127.0.0.1:42555:0*grn/415DDB74/41aaf750 #5478: . Target History is: 
&lt;S127.0.0.1:42555:0:*grn/415DDB74/41aaf750:&gt;.

+++++++++++++++++++
STACK TRACE:
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at 
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```</Description>
    <Title_Description>Test Reliability: ExceptionPropagation_ClientToGrain_SerializationFailure UnitTests.General.ExceptionPropagationTests.ExceptionPropagation_ClientToGrain_SerializationFailure is flaky. Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2578/testReport/junit/UnitTests.General/ExceptionPropagationTests/ExceptionPropagation_ClientToGrain_SerializationFailure/

```
Stacktrace

MESSAGE:
Assert.Throws() Failure\r\nExpected: typeof(System.NotSupportedException)\r\nActual: 
typeof(System.TimeoutException): Response did not arrive on time in 00:00:30 for message: Request 
*cli/1770639c@44a482a6-&gt;S127.0.0.1:42555:0*grn/415DDB74/41aaf750 #5478: . Target History is: 
&lt;S127.0.0.1:42555:0:*grn/415DDB74/41aaf750:&gt;.

+++++++++++++++++++
STACK TRACE:
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at 
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
```</Title_Description>
    <Label>test-issue</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5395</IssueLabelID>
    <Title>Enable HostedClient by default</Title>
    <Description>Fixes #5337</Description>
    <Title_Description>Enable HostedClient by default Fixes #5337</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5394</IssueLabelID>
    <Title>Azure Storage Streaming poison handling when message batch can not be deserialized</Title>
    <Description>Hi

Using the azure storage streaming provider with the default serializer causes an infinite retry loop of message batches serialized with the previous version.

The problem is most likely in https://github.com/dotnet/orleans/blob/bdaf800326b90c5e0950be6b0a8568add56f3b2c/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueAdapterReceiver.cs#L92

The batchcontainer can not be deserialized and should be considered as `poison` but instead it keeps trying to read the same batch of events until Expiration Time is reached (which is 7 days by default in azure storage queues).

This situation can be reproduced using the following steps:

1. publish batch of message on a stream
2. shutdown silo (check if message is still in queue)
3. add property to the message
4. start silo with new message format

result is `AzureQueueAdapterReceiver` throwing at https://github.com/dotnet/orleans/blob/bdaf800326b90c5e0950be6b0a8568add56f3b2c/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueAdapterReceiver.cs#L85

which in turn will throw at https://github.com/dotnet/orleans/blob/fd7375eebabd66e3826cd77710b1df13d9c0d3be/src/Orleans.Runtime/Streams/PersistentStream/PersistentStreamPullingAgent.cs#L435

which will trigger the retry from ` AsyncExecutorWithRetries` 
In the next try the previous batch is still invisible (due to InvisibilityTimeout set when retrieving the faulty batch) so it will succeed. 

Eventually our silo was only reading faulty batches and not processing any new messages.

We know that we shouldn't break contracts and that the default Orleans serializer is not version tolerant. We try to avoid making breaking changes but missed one. It should not have broken down the entire silo I think
</Description>
    <Title_Description>Azure Storage Streaming, poison handling when message batch can not be deserialized Hi

Using the azure storage streaming provider with the default serializer causes an infinite retry loop of message batches serialized with the previous version.

The problem is most likely in https://github.com/dotnet/orleans/blob/bdaf800326b90c5e0950be6b0a8568add56f3b2c/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueAdapterReceiver.cs#L92

The batchcontainer can not be deserialized and should be considered as `poison` but instead it keeps trying to read the same batch of events until Expiration Time is reached (which is 7 days by default in azure storage queues).

This situation can be reproduced using the following steps:

1. publish batch of message on a stream
2. shutdown silo (check if message is still in queue)
3. add property to the message
4. start silo with new message format

result is `AzureQueueAdapterReceiver` throwing at https://github.com/dotnet/orleans/blob/bdaf800326b90c5e0950be6b0a8568add56f3b2c/src/Azure/Orleans.Streaming.AzureStorage/Providers/Streams/AzureQueue/AzureQueueAdapterReceiver.cs#L85

which in turn will throw at https://github.com/dotnet/orleans/blob/fd7375eebabd66e3826cd77710b1df13d9c0d3be/src/Orleans.Runtime/Streams/PersistentStream/PersistentStreamPullingAgent.cs#L435

which will trigger the retry from ` AsyncExecutorWithRetries` 
In the next try the previous batch is still invisible (due to InvisibilityTimeout set when retrieving the faulty batch) so it will succeed. 

Eventually our silo was only reading faulty batches and not processing any new messages.

We know that we shouldn't break contracts and that the default Orleans serializer is not version tolerant. We try to avoid making breaking changes but missed one. It should not have broken down the entire silo I think
</Title_Description>
    <Label>bug</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5392</IssueLabelID>
    <Title>Reentrant timer issue when AllowCallChainReentrancy = true (default)</Title>
    <Description>As mentioned in https://github.com/dotnet/orleans/issues/2574 it would be great if Timer callbacks respected the reentrancy of grains. There's been a trick people could use to achieve the desired behavior:
``` c#
TimerAsyncCallback(...)
{
    var grainReference = this.AsReference&lt;IHelloGrain&gt;();
    grainReference.SayHello();
}
```
Unfortunately that trick doesn't work anymore because of call chain reentrancy.

Example: Client calls DoLongRunningThing which runs for 10 seconds. The timer callback triggers after 2 seconds and calls Hello while DoLongRunningThing is still running.
Desired behavior: Hello is enqueued and invoked after DoLongRunningThing finishes.
Observed behavior: Hello is immediately invoked and does not wait until DoLongRunningThing has ended.

Using Orleans 2.2.0 in its default configuration.

``` c#
public class HelloGrain : Grain IHelloGrain
{
	private readonly ILogger logger;

	public HelloGrain(ILogger&lt;HelloGrain&gt; logger)
	{
		this.logger = logger;
	}

	override public async Task OnActivateAsync()
	{
		await base.OnActivateAsync();
		logger.LogWarning("OnActivateAsync: RegisterTimer (callback in 2s)");
		RegisterTimer(TimerAsyncCallback null TimeSpan.FromSeconds(2.0) TimeSpan.FromSeconds(999));
	}

	private Task TimerAsyncCallback(object arg)
	{
		logger.LogWarning("TimerAsyncCallback (calling Hello on grain reference)");
		var grainReference = this.AsReference&lt;IHelloGrain&gt;();
		return grainReference.SayHello();
	}

	public async Task DoLongRunningThing()
	{
		logger.LogWarning("DoLongRunningThing start (runs for 10s)");
		await Task.Delay(10 * 1000);
		logger.LogWarning("DoLongRunningThing end");
	}

	public Task SayHello()
	{
		logger.LogWarning("Hello");
		return Task.CompletedTask;
	}
}
```
[OrleansTimerReentrancyIssue.zip](https://github.com/dotnet/orleans/files/2896697/OrleansTimerReentrancyIssue.zip)

Disabling AllowCallChainReentrancy results in the desired behavior in this case but our code has come to rely on call chain reentrancy (it is the default after all).

**Are there any workarounds?** Ultimately it would be greatly beneficial if the timer could respect grain reentrancy as outlined in https://github.com/dotnet/orleans/issues/2574.</Description>
    <Title_Description>Reentrant timer issue when AllowCallChainReentrancy = true (default) As mentioned in https://github.com/dotnet/orleans/issues/2574 it would be great if Timer callbacks respected the reentrancy of grains. There's been a trick people could use to achieve the desired behavior:
``` c#
TimerAsyncCallback(...)
{
    var grainReference = this.AsReference&lt;IHelloGrain&gt;();
    grainReference.SayHello();
}
```
Unfortunately that trick doesn't work anymore because of call chain reentrancy.

Example: Client calls DoLongRunningThing which runs for 10 seconds. The timer callback triggers after 2 seconds and calls Hello while DoLongRunningThing is still running.
Desired behavior: Hello is enqueued and invoked after DoLongRunningThing finishes.
Observed behavior: Hello is immediately invoked and does not wait until DoLongRunningThing has ended.

Using Orleans 2.2.0 in its default configuration.

``` c#
public class HelloGrain : Grain IHelloGrain
{
	private readonly ILogger logger;

	public HelloGrain(ILogger&lt;HelloGrain&gt; logger)
	{
		this.logger = logger;
	}

	override public async Task OnActivateAsync()
	{
		await base.OnActivateAsync();
		logger.LogWarning("OnActivateAsync: RegisterTimer (callback in 2s)");
		RegisterTimer(TimerAsyncCallback null TimeSpan.FromSeconds(2.0) TimeSpan.FromSeconds(999));
	}

	private Task TimerAsyncCallback(object arg)
	{
		logger.LogWarning("TimerAsyncCallback (calling Hello on grain reference)");
		var grainReference = this.AsReference&lt;IHelloGrain&gt;();
		return grainReference.SayHello();
	}

	public async Task DoLongRunningThing()
	{
		logger.LogWarning("DoLongRunningThing start (runs for 10s)");
		await Task.Delay(10 * 1000);
		logger.LogWarning("DoLongRunningThing end");
	}

	public Task SayHello()
	{
		logger.LogWarning("Hello");
		return Task.CompletedTask;
	}
}
```
[OrleansTimerReentrancyIssue.zip](https://github.com/dotnet/orleans/files/2896697/OrleansTimerReentrancyIssue.zip)

Disabling AllowCallChainReentrancy results in the desired behavior in this case but our code has come to rely on call chain reentrancy (it is the default after all).

**Are there any workarounds?** Ultimately it would be greatly beneficial if the timer could respect grain reentrancy as outlined in https://github.com/dotnet/orleans/issues/2574.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5391</IssueLabelID>
    <Title>Mark ILBasedSerializer et al as [Obsolete]</Title>
    <Description>We created this serializer for cases where BinaryFormatter would otherwise be used since BF was not going to be made available on .NET Core/.NET Standard. Since it is available there is no need for it.</Description>
    <Title_Description>Mark ILBasedSerializer et al as [Obsolete] We created this serializer for cases where BinaryFormatter would otherwise be used since BF was not going to be made available on .NET Core/.NET Standard. Since it is available there is no need for it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5390</IssueLabelID>
    <Title>Cherry-picked fixes for 2.2.4</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked fixes for 2.2.4 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5389</IssueLabelID>
    <Title>Enable "cleaning" of all dead entries in the membership table</Title>
    <Description>Right now we don't delete old entries in the membership table and that can be an issue since it will grow forever. 

This PR enable deleting old silo entries and implement it in the azure membership provider. Other providers still need to implement this logic.</Description>
    <Title_Description>Enable "cleaning" of all dead entries in the membership table Right now we don't delete old entries in the membership table and that can be an issue since it will grow forever. 

This PR enable deleting old silo entries and implement it in the azure membership provider. Other providers still need to implement this logic.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5388</IssueLabelID>
    <Title>Downgrade Benchmark to target netcoreapp2.1 instead of 2.2</Title>
    <Description>No need to target 2.2 at this point as that increases friction with compiling sources.</Description>
    <Title_Description>Downgrade Benchmark to target netcoreapp2.1 instead of 2.2 No need to target 2.2 at this point as that increases friction with compiling sources.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5385</IssueLabelID>
    <Title>Update to Microsoft.Extensions.Options 2.1.1 and remove duplicated classes</Title>
    <Description>for #4703 </Description>
    <Title_Description>Update to Microsoft.Extensions.Options 2.1.1 and remove duplicated classes for #4703 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5384</IssueLabelID>
    <Title>Upgade to eventhub 2.2.1</Title>
    <Description>
    </Description>
    <Title_Description>Upgade to eventhub 2.2.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5383</IssueLabelID>
    <Title>How to access Orleans inside Service Fabric from outside? </Title>
    <Description>Hi I'm trying to deploy Orleans Silo to a Service Fabric cluster. I need my Orleans client to be outside of the SF cluster. With the sample code the address saved in the Membership table is the internal SF ip.
How can I properly configure Orleans Silo to expose the external addresses for the client to use?
Or maybe there is a way to use Static clustering to connect to the service fabric service?</Description>
    <Title_Description>How to access Orleans inside Service Fabric from outside?  Hi I'm trying to deploy Orleans Silo to a Service Fabric cluster. I need my Orleans client to be outside of the SF cluster. With the sample code the address saved in the Membership table is the internal SF ip.
How can I properly configure Orleans Silo to expose the external addresses for the client to use?
Or maybe there is a way to use Static clustering to connect to the service fabric service?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5382</IssueLabelID>
    <Title>Update statement about rewindable stream providers</Title>
    <Description>
    </Description>
    <Title_Description>Update statement about rewindable stream providers </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>21/02/2019 2:05:37 AM +00:00</CreatedAt>
    <ClosedAt>21/02/2019 11:27:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5381</IssueLabelID>
    <Title>Remove new() requirement from persistent state facet and Grain&lt;T&gt;</Title>
    <Description>Note: This change introduced interface changes in core.abstractions.  We may not want to do this at this time.</Description>
    <Title_Description>Remove new() requirement from persistent state facet and Grain&lt;T&gt; Note: This change introduced interface changes in core.abstractions.  We may not want to do this at this time.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5380</IssueLabelID>
    <Title>Enable tx test kit pkg</Title>
    <Description>
    </Description>
    <Title_Description>Enable tx test kit pkg </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5379</IssueLabelID>
    <Title>ConvertJsonToFromStorageFormatWithCustomJsonProperties test fix</Title>
    <Description>- made is skippable</Description>
    <Title_Description>ConvertJsonToFromStorageFormatWithCustomJsonProperties test fix - made is skippable</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5376</IssueLabelID>
    <Title>Client disposal on failed connection in Orleans v2.0 and later</Title>
    <Description>According to [1.5 documentation](https://dotnet.github.io/orleans/1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html):
&gt; If the connection attempt fails the client instance must be disposed.

However I haven't found anything similar in 2.0 documentation.

I'm implementing [connection retries](https://github.com/dotnet/orleans/pull/4161/files) but I'm wondering if the client disposal part should remain in my code:

```c#
while (!connected)
{
    try
    {
        client = new ClientBuilder()
            .ConfigureOrleansClient(configuration)
            .AddSimpleMessageStreamProvider(/*...*/)
            .AddClusterConnectionLostHandler((sender s) =&gt;
            {
                Console.WriteLine($"Connection Lost"); // TODO - implement reconnect
            })
            .Build();

        await client.Connect(RetryConnectionExceptionFilter()).ConfigureAwait(true);

        connected = true;

        Console.WriteLine("Client successfully connected to cluster");
    }
    catch (Exception e)
    {
        // If the connection attempt fails the client instance must be disposed according to 1.5 documentation
        client?.Dispose();

        // Moved reconnection logic (i.e. number of reconnection attempts and delays between them) to RetryConnectionExceptionFilter
    }
}

private static int _connectionAttempt;

private static Func&lt;Exception Task&lt;bool&gt;&gt; RetryConnectionExceptionFilter()
{
    return async exception =&gt;
    {
        _connectionAttempt = (_connectionAttempt + 1) % int.MaxValue;

        Console.WriteLine($"Failed to initialize Orleans client {_connectionAttempt}/1000: {exception.Message}");

        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(true);
        return _connectionAttempt &lt; 1000;
    };
}
```</Description>
    <Title_Description>Client disposal on failed connection in Orleans v2.0 and later According to [1.5 documentation](https://dotnet.github.io/orleans/1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html):
&gt; If the connection attempt fails the client instance must be disposed.

However I haven't found anything similar in 2.0 documentation.

I'm implementing [connection retries](https://github.com/dotnet/orleans/pull/4161/files) but I'm wondering if the client disposal part should remain in my code:

```c#
while (!connected)
{
    try
    {
        client = new ClientBuilder()
            .ConfigureOrleansClient(configuration)
            .AddSimpleMessageStreamProvider(/*...*/)
            .AddClusterConnectionLostHandler((sender s) =&gt;
            {
                Console.WriteLine($"Connection Lost"); // TODO - implement reconnect
            })
            .Build();

        await client.Connect(RetryConnectionExceptionFilter()).ConfigureAwait(true);

        connected = true;

        Console.WriteLine("Client successfully connected to cluster");
    }
    catch (Exception e)
    {
        // If the connection attempt fails the client instance must be disposed according to 1.5 documentation
        client?.Dispose();

        // Moved reconnection logic (i.e. number of reconnection attempts and delays between them) to RetryConnectionExceptionFilter
    }
}

private static int _connectionAttempt;

private static Func&lt;Exception Task&lt;bool&gt;&gt; RetryConnectionExceptionFilter()
{
    return async exception =&gt;
    {
        _connectionAttempt = (_connectionAttempt + 1) % int.MaxValue;

        Console.WriteLine($"Failed to initialize Orleans client {_connectionAttempt}/1000: {exception.Message}");

        await Task.Delay(TimeSpan.FromSeconds(2)).ConfigureAwait(true);
        return _connectionAttempt &lt; 1000;
    };
}
```</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5375</IssueLabelID>
    <Title>can i get more than then thousand streams?  any limit or side effect in large count stream?</Title>
    <Description>i am building mqtt server broker cluster by orleans. 

one stream named cluster stream  to share mqtt packet between brokers in cluster
each broker has it`s own stream named broker stream.
broker grain subscribe from cluster stream  or publish mqtt packet to cluster stream.
client connect to one broker publish or subscribe mqtt packet in broker.

my question is
should i get a stream for each client(over ten thousand clients) route mqtt packet at grain side.
or just one stream one broker only process mqtt packet at grain client side and route to mqtt client.

can anyone give me some suggestions? 
</Description>
    <Title_Description>can i get more than then thousand streams?  any limit or side effect in large count stream? i am building mqtt server broker cluster by orleans. 

one stream named cluster stream  to share mqtt packet between brokers in cluster
each broker has it`s own stream named broker stream.
broker grain subscribe from cluster stream  or publish mqtt packet to cluster stream.
client connect to one broker publish or subscribe mqtt packet in broker.

my question is
should i get a stream for each client(over ten thousand clients) route mqtt packet at grain side.
or just one stream one broker only process mqtt packet at grain client side and route to mqtt client.

can anyone give me some suggestions? 
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5374</IssueLabelID>
    <Title>Confusing behavior with ResponseTimeout properties</Title>
    <Description>So I tried to do this:
```csharp
options.ResponseTimeout = TimeSpan.FromSeconds(5);
options.ResponseTimeoutWithDebugger = options.ResponseTimeout;
```
Which looks like it should be fine but when debugging `ResponseTimeoutWithDebugger` will not be changed because the `ResponseTimeout` property returns `ResponseTimeoutWithDebugger`.

It might be worth having a separate (getter only) property for the timeout value it will be using or at least some more hints in documentation.</Description>
    <Title_Description>Confusing behavior with ResponseTimeout properties So I tried to do this:
```csharp
options.ResponseTimeout = TimeSpan.FromSeconds(5);
options.ResponseTimeoutWithDebugger = options.ResponseTimeout;
```
Which looks like it should be fine but when debugging `ResponseTimeoutWithDebugger` will not be changed because the `ResponseTimeout` property returns `ResponseTimeoutWithDebugger`.

It might be worth having a separate (getter only) property for the timeout value it will be using or at least some more hints in documentation.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5373</IssueLabelID>
    <Title>Persistent state facet</Title>
    <Description>This change Introduces a storage facet IPersistentState&lt;T&gt; which allows grains to define state which can be stored in using the existing IGrainStorage implementations.</Description>
    <Title_Description>Persistent state facet This change Introduces a storage facet IPersistentState&lt;T&gt; which allows grains to define state which can be stored in using the existing IGrainStorage implementations.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5372</IssueLabelID>
    <Title>Pulling agent losing subscriptions fix</Title>
    <Description>Pulling agent could lose subscriptions if a subscription was added after the subscription cache was cleared.  We now always go to the pubsub system for subscriptions and only add new ones if the stream is active and in the pubsub cache.</Description>
    <Title_Description>Pulling agent losing subscriptions fix Pulling agent could lose subscriptions if a subscription was added after the subscription cache was cleared.  We now always go to the pubsub system for subscriptions and only add new ones if the stream is active and in the pubsub cache.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5371</IssueLabelID>
    <Title>Fix link to blog in readme.md.</Title>
    <Description>
    </Description>
    <Title_Description>Fix link to blog in readme.md. </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5370</IssueLabelID>
    <Title>Orleans Blog Link Broken</Title>
    <Description>The Orleans Blog link leads to a nonexistent page. 

![image](https://user-images.githubusercontent.com/6845982/52853626-2f23f900-3142-11e9-95b4-05efcbad532c.png)
</Description>
    <Title_Description>Orleans Blog Link Broken The Orleans Blog link leads to a nonexistent page. 

![image](https://user-images.githubusercontent.com/6845982/52853626-2f23f900-3142-11e9-95b4-05efcbad532c.png)
</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5369</IssueLabelID>
    <Title>Unable to use Microsoft.Azure.EventHubs package greater than 1.0.3 with Microsoft.Orleans.OrleansServiceBus</Title>
    <Description>It is not possible to use a version of `Microsoft.Azure.EventHubs` greater than `1.0.3` in the same application as Orleans if the EventHubs stream provider is being used.

The `Microsoft.Orleans.OrleansServiceBus` package depends on version `1.0.3` of `Microsoft.Azure.EventHubs` (released Aug 23 2017) and breaking changes have been made in later releases.

Even though it is not called out specifically in the release notes for `1.1.0` the `EventHubClient.CreateReceiver` method signature was changed to include an optional `ReceiverOptions` parameter.

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/1.1.0

A `MissingMethodException` is thrown when the `EventHubAdapterReceiver` attempts to create the `PartitionReceiver` due to the additional parameter that was added to the overload being used.

```
System.MissingMethodException: Method not found: 'Microsoft.Azure.EventHubs.PartitionReceiver Microsoft.Azure.EventHubs.EventHubClient.CreateReceiver(System.String System.String System.String Boolean)'.
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.CreateReceiver(EventHubPartitionSettings partitionSettings String offset ILogger logger ITelemetryProducer telemetryProducer)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.CreateReceiver(EventHubPartitionSettings partitionSettings String offset ILogger logger ITelemetryProducer telemetryProducer)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize()
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetQueueMessagesAsync(Int32 maxCount)
   at Orleans.Streams.PersistentStreamPullingAgent.ReadFromQueue(QueueId myQueueId IQueueAdapterReceiver rcvr Int32 maxCacheAddCount)
   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff) 
```

A further breaking change was introduced to `Microsoft.Azure.EventHubs` in `2.0.0` and is mentioned in the release notes. Removal of the `Microsoft.Azure.EventHubs.PartitionReceiver.StartOfStream` property which is currently referenced by `Orleans.ServiceBus.Providers.EventHubConstants.StartOfStream` results in a `TypeInitializationException`.

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/v2.0.0

The inner `MissingFieldException` is a result of the property removal.

```
System.TypeInitializationException: The type initializer for 'Orleans.ServiceBus.Providers.EventHubConstants' threw an exception. ---&gt; System.MissingFieldException: Field not found: 'Microsoft.Azure.EventHubs.PartitionReceiver.StartOfStream'.
   at Orleans.ServiceBus.Providers.EventHubConstants..cctor()
   --- End of inner exception stack trace ---
   at Orleans.ServiceBus.Providers.EventHubPartitionCheckpointEntity.Create(String streamProviderName String serviceId String partition) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubPartitionCheckpointEntity.cs:line 17
   at Orleans.ServiceBus.Providers.EventHubCheckpointer..ctor(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 92
   at Orleans.ServiceBus.Providers.EventHubCheckpointer.Create(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 70
   at Orleans.ServiceBus.Providers.EventHubCheckpointer..ctor(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 92
   at Orleans.ServiceBus.Providers.EventHubCheckpointer.Create(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 70
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.Streams.PersistentStreamPullingAgent.AsyncTimerCallback(Object state) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 348
   at Orleans.Streams.PersistentStreamPullingAgent.AsyncTimerCallback(Object state) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 348
```

It appears that the constant value `"-1"` has been moved to an internal property of the `EventPosition` class.

https://github.com/Azure/azure-event-hubs-dotnet/blob/8aae6b6ec1af44de69326288854f5811985db539/src/Microsoft.Azure.EventHubs/EventPosition.cs#L21

I have investigated the changes required to upgrade `Microsoft.Azure.EventHubs` in a fork.

- Modify `Directory.Build.props` to update `Microsoft.Azure.EventHubs` package to `2.2.1` and `System.Net.Http` to `4.3.3` (to prevent downgrade in other projects).
- The `EventHubConstants.StartOfStream` property can be replaced with the constant `"-1"` leaving the value as a `string`.
- `EventPosition` is only required when creating the `PartitionReceiver` which is done inside the `EventHubAdapterReceiver.CreateReceiver` method where the offset (`string`) and inclusive flag (`bool`) are already available.
- Update reflection based code in `EventHubUtils` to cater for internal changes to `EventData`. Reflection is no longer required for setting the `Offset` `SequenceNumber` `EnqueuedTime` and `PartitionKey` properties but is still required to initialize `SystemProperties` with a new `SystemPropertiesCollection` when `null`.

The unit tests are passing with the exception of `EHBatchedSubscriptionMultiplicityTests.EHBatchedMultipleLinearSubscriptionTest`. This fixture contains integration style tests that I had to point at my own EventHub and Storage Table to get working. I wasn't sure if this failure was related to the upgrade so I ran the same test without the upgrade and it still fails for me locally. I assume there is a difference between my setup and the one used in your build system.

I would be happy to put together a PR with these changes if you are interested.</Description>
    <Title_Description>Unable to use Microsoft.Azure.EventHubs package greater than 1.0.3 with Microsoft.Orleans.OrleansServiceBus It is not possible to use a version of `Microsoft.Azure.EventHubs` greater than `1.0.3` in the same application as Orleans if the EventHubs stream provider is being used.

The `Microsoft.Orleans.OrleansServiceBus` package depends on version `1.0.3` of `Microsoft.Azure.EventHubs` (released Aug 23 2017) and breaking changes have been made in later releases.

Even though it is not called out specifically in the release notes for `1.1.0` the `EventHubClient.CreateReceiver` method signature was changed to include an optional `ReceiverOptions` parameter.

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/1.1.0

A `MissingMethodException` is thrown when the `EventHubAdapterReceiver` attempts to create the `PartitionReceiver` due to the additional parameter that was added to the overload being used.

```
System.MissingMethodException: Method not found: 'Microsoft.Azure.EventHubs.PartitionReceiver Microsoft.Azure.EventHubs.EventHubClient.CreateReceiver(System.String System.String System.String Boolean)'.
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.CreateReceiver(EventHubPartitionSettings partitionSettings String offset ILogger logger ITelemetryProducer telemetryProducer)
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.CreateReceiver(EventHubPartitionSettings partitionSettings String offset ILogger logger ITelemetryProducer telemetryProducer)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize()
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetQueueMessagesAsync(Int32 maxCount)
   at Orleans.Streams.PersistentStreamPullingAgent.ReadFromQueue(QueueId myQueueId IQueueAdapterReceiver rcvr Int32 maxCacheAddCount)
   at Orleans.AsyncExecutorWithRetries.ExecuteWithRetriesHelper[T](Func`2 function Int32 callCounter Int32 maxNumSuccessTries Int32 maxNumErrorTries TimeSpan maxExecutionTime DateTime startExecutionTime Func`3 retryValueFilter Func`3 retryExceptionFilter IBackoffProvider onSuccessBackOff IBackoffProvider onErrorBackOff) 
```

A further breaking change was introduced to `Microsoft.Azure.EventHubs` in `2.0.0` and is mentioned in the release notes. Removal of the `Microsoft.Azure.EventHubs.PartitionReceiver.StartOfStream` property which is currently referenced by `Orleans.ServiceBus.Providers.EventHubConstants.StartOfStream` results in a `TypeInitializationException`.

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/v2.0.0

The inner `MissingFieldException` is a result of the property removal.

```
System.TypeInitializationException: The type initializer for 'Orleans.ServiceBus.Providers.EventHubConstants' threw an exception. ---&gt; System.MissingFieldException: Field not found: 'Microsoft.Azure.EventHubs.PartitionReceiver.StartOfStream'.
   at Orleans.ServiceBus.Providers.EventHubConstants..cctor()
   --- End of inner exception stack trace ---
   at Orleans.ServiceBus.Providers.EventHubPartitionCheckpointEntity.Create(String streamProviderName String serviceId String partition) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubPartitionCheckpointEntity.cs:line 17
   at Orleans.ServiceBus.Providers.EventHubCheckpointer..ctor(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 92
   at Orleans.ServiceBus.Providers.EventHubCheckpointer.Create(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 70
   at Orleans.ServiceBus.Providers.EventHubCheckpointer..ctor(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 92
   at Orleans.ServiceBus.Providers.EventHubCheckpointer.Create(AzureTableStreamCheckpointerOptions options String streamProviderName String partition String serviceId ILoggerFactory loggerFactory) in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubCheckpointer.cs:line 70
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.Initialize() in D:\build\agent\_work\24\s\src\Azure\Orleans.Streaming.EventHubs\Providers\Streams\EventHub\EventHubAdapterReceiver.cs:line 115
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.SafeExecute(Func`1 action) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 151
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in D:\build\agent\_work\24\s\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.Streams.PersistentStreamPullingAgent.AsyncTimerCallback(Object state) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 348
   at Orleans.Streams.PersistentStreamPullingAgent.AsyncTimerCallback(Object state) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Streams\PersistentStream\PersistentStreamPullingAgent.cs:line 348
```

It appears that the constant value `"-1"` has been moved to an internal property of the `EventPosition` class.

https://github.com/Azure/azure-event-hubs-dotnet/blob/8aae6b6ec1af44de69326288854f5811985db539/src/Microsoft.Azure.EventHubs/EventPosition.cs#L21

I have investigated the changes required to upgrade `Microsoft.Azure.EventHubs` in a fork.

- Modify `Directory.Build.props` to update `Microsoft.Azure.EventHubs` package to `2.2.1` and `System.Net.Http` to `4.3.3` (to prevent downgrade in other projects).
- The `EventHubConstants.StartOfStream` property can be replaced with the constant `"-1"` leaving the value as a `string`.
- `EventPosition` is only required when creating the `PartitionReceiver` which is done inside the `EventHubAdapterReceiver.CreateReceiver` method where the offset (`string`) and inclusive flag (`bool`) are already available.
- Update reflection based code in `EventHubUtils` to cater for internal changes to `EventData`. Reflection is no longer required for setting the `Offset` `SequenceNumber` `EnqueuedTime` and `PartitionKey` properties but is still required to initialize `SystemProperties` with a new `SystemPropertiesCollection` when `null`.

The unit tests are passing with the exception of `EHBatchedSubscriptionMultiplicityTests.EHBatchedMultipleLinearSubscriptionTest`. This fixture contains integration style tests that I had to point at my own EventHub and Storage Table to get working. I wasn't sure if this failure was related to the upgrade so I ran the same test without the upgrade and it still fails for me locally. I assume there is a difference between my setup and the one used in your build system.

I would be happy to put together a PR with these changes if you are interested.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5368</IssueLabelID>
    <Title>Firewall: Silo nodes do not allow incoming TCP connections. Allow inter-Silo communication via a proxy.</Title>
    <Description>Silo node communication depends on **incoming** TCP connections. Sometimes this is not possible due to firewalls or other constraints. In these situations it would be beneficial when Silo nodes on startup initiate a bi-directional socket to a proxy via which inter-Silo communication is routed.</Description>
    <Title_Description>Firewall: Silo nodes do not allow incoming TCP connections. Allow inter-Silo communication via a proxy. Silo node communication depends on **incoming** TCP connections. Sometimes this is not possible due to firewalls or other constraints. In these situations it would be beneficial when Silo nodes on startup initiate a bi-directional socket to a proxy via which inter-Silo communication is routed.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5367</IssueLabelID>
    <Title>OMG DDS vs Orleans</Title>
    <Description>
    </Description>
    <Title_Description>OMG DDS vs Orleans </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5366</IssueLabelID>
    <Title>Question about Transaction</Title>
    <Description>I need some advice on using Orleans.Transaction.

To use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.
It means that if you make a method that can be called in or not in Transaction you have to double it.

So I thought this way would be easier to use this way.
```csharp
await wallet.PerformUpdate(balance =&gt; balance.Pop(100));
 
 
var inventoryGrain = GetGrain&lt;InventoryGrain&gt;(userId TransactionOption.Join);
await inventoryGrain.AddItem("Healing Potion");
```
Like the code above I thought it would be nice if a transaction starts when requester wants to.
This way there's no way to find out the method's TransactionOption on the declaration.

```csharp
public interface ISomeGrain : IGrainWithStringKey
{
    [Transaction(TransactionOption.Create)]     
    Task&lt;TReturn&gt; NoneTransactionalRequest&lt;TReturn&gt;(MethodInfo mi params object[] parameters);

    [Transaction(TransactionOption.Join)]
    Task&lt;TReturn&gt; TransactionalRequest&lt;TReturn&gt;(MethodInfo mi params object[] parameters);
}
```
So we made a custom layer and call it `Service` layer.
A Service is matched with a Grain.
When a Service request something to another Service It sends through Grain.
And at Grain level we decide which way to go NoneTransactionalRequest or TransactionalRequest.

If the request is NoneTransactionalRequest create a new transaction.
if the request is TransactionalRequest join the current transaction.

Here are the questions.
First I want to know how you think of this way.
Second Is this way of using Orleans.Transaction is too much?


</Description>
    <Title_Description>Question about Transaction I need some advice on using Orleans.Transaction.

To use Orleans.Transaction it is required to declare TransactionOption on the Grain interface.
It means that if you make a method that can be called in or not in Transaction you have to double it.

So I thought this way would be easier to use this way.
```csharp
await wallet.PerformUpdate(balance =&gt; balance.Pop(100));
 
 
var inventoryGrain = GetGrain&lt;InventoryGrain&gt;(userId TransactionOption.Join);
await inventoryGrain.AddItem("Healing Potion");
```
Like the code above I thought it would be nice if a transaction starts when requester wants to.
This way there's no way to find out the method's TransactionOption on the declaration.

```csharp
public interface ISomeGrain : IGrainWithStringKey
{
    [Transaction(TransactionOption.Create)]     
    Task&lt;TReturn&gt; NoneTransactionalRequest&lt;TReturn&gt;(MethodInfo mi params object[] parameters);

    [Transaction(TransactionOption.Join)]
    Task&lt;TReturn&gt; TransactionalRequest&lt;TReturn&gt;(MethodInfo mi params object[] parameters);
}
```
So we made a custom layer and call it `Service` layer.
A Service is matched with a Grain.
When a Service request something to another Service It sends through Grain.
And at Grain level we decide which way to go NoneTransactionalRequest or TransactionalRequest.

If the request is NoneTransactionalRequest create a new transaction.
if the request is TransactionalRequest join the current transaction.

Here are the questions.
First I want to know how you think of this way.
Second Is this way of using Orleans.Transaction is too much?


</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5364</IssueLabelID>
    <Title>Serialization?</Title>
    <Description>Is not an Issue only a question about the used (binary) serialization. 
In his speech here: [https://youtu.be/vMaqXCq52l8](url) Roger Johansson from akka.net talks about his implementation of message object serialization.
Exists there also somewhere something to compare the numbers? </Description>
    <Title_Description>Serialization? Is not an Issue only a question about the used (binary) serialization. 
In his speech here: [https://youtu.be/vMaqXCq52l8](url) Roger Johansson from akka.net talks about his implementation of message object serialization.
Exists there also somewhere something to compare the numbers? </Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5363</IssueLabelID>
    <Title>Is GrainService support StorageProvider attribute?</Title>
    <Description>i tried to use GrainServices as documentation code.
StorageProvider  only described used for Grain class can i use it like this?
and if StorageProvider not support how supposed i use storage in GrainService? thans

```
 [Reentrant]
 [StorageProvider(ProviderName = "PubSubStore")]
 public class LightstreamerDataService : GrainService IDataService {
    readonly IGrainFactory GrainFactory;

    public LightstreamerDataService(IServiceProvider services IGrainIdentity id Silo silo ILoggerFactory
         loggerFactory IGrainFactory grainFactory) : base(id silo loggerFactory) {
        GrainFactory = grainFactory;
    }
    public Task MyMethod() {
    }
 }
```</Description>
    <Title_Description>Is GrainService support StorageProvider attribute? i tried to use GrainServices as documentation code.
StorageProvider  only described used for Grain class can i use it like this?
and if StorageProvider not support how supposed i use storage in GrainService? thans

```
 [Reentrant]
 [StorageProvider(ProviderName = "PubSubStore")]
 public class LightstreamerDataService : GrainService IDataService {
    readonly IGrainFactory GrainFactory;

    public LightstreamerDataService(IServiceProvider services IGrainIdentity id Silo silo ILoggerFactory
         loggerFactory IGrainFactory grainFactory) : base(id silo loggerFactory) {
        GrainFactory = grainFactory;
    }
    public Task MyMethod() {
    }
 }
```</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5362</IssueLabelID>
    <Title>AzureQueues stops being processed when large and growing number of streams uses it</Title>
    <Description>I test Orleans for the use case when large number of independant messages should be processed in the fastest and scalable way. My first approach was to send each message to unique stream in the same namespace. So if message has id = GUID then it is sent to stream &lt;GUID "Namespace"&gt;. On the processing side I used implicit subscription grain ProcessingGrain with attr [ImplicitStreamSubscription("Namespace")]. So as many there are messages to process that many streams and grains are created. After message GUID is processed stream &lt;GUID "Namespace"&gt; and  ProcessingGrain &lt;GUID&gt; is not needed anymore so I configured ProcessingGrain to be Deactivated after 5 minutes. Not active streams are cleared from Orleans after StreamPullingAgentOptions.StreamInactivityPeriod that was left with the default value = 10 min.
Stream: AzureQueueStreamProvider
Clustering: AzureStorageClustering
Monitoring: Orleans Dashboard 2.2.0

I tried these load scenarios:
- 100-1000 msgs/sec
- 1-2 silos
- 1-8 queues in Azure Queue

Enviroment:
- Orleans 2.2.3
- Windows 10 or Windows Server 2016 Datacenter both x64
- .Net Core 2.2.0

and in all scenarios real Azure Queues were stopped being processed after 10-40 minutes of work. So pulling agents just don't pull messages anymore. Logs show that PubSubCacheSize grows all the time and at value 250-400k mentioned fail occurs. 
Old Grains are successfully deactivated and streams too but after fail occurs streams are not cleared. So value of PubSubCacheSize goes up and down but then on value of 250-400k it is not cleared anymore. At the same time all processing grains are eventually deactivated.

After chatting on gitter I understood that I need to try a solution of pool of streams with fixed number of them to avoid this situation of unbounded number of streams. 

- But anyway I think it is an issue that system just stops process streams with even no message in logs. It looks like everything is fine but messages just accumulate in Azure Queue. 
- Also I don't understand why if inactive streams are cleared after StreamInactivityPeriod and all grains are deactivated the described pattern of 1stream\msg is not working one? It seems to me that up to some load the system should feel fine. New messages create new objects in the system but at that time old objects (streams system info and grains) have been cleared already.

Besides of my (actually not recommended in the docs) scenario please consider another one:
The system creates a group of grains per some event e.g. conference. These grains use persistant stream like AzureQueue for some communication. Conferences should not know about each other so each conference=group of grains uses its own stream Id = Conference Id. The frequency of new conferences creation can be high comparable with my test 100-500/sec. Here each stream is used many times but like in my test when the conference ends stream is not needed anymore. It will never be used again. So number of streams in system can slowly grow. So now it looks similar to my test. 
And I'm afraid that on some load Orleans will stop process streams and create new ones because of some reason. May be because it can't handle situation when speed of new streams creation is more than speed of clearing inactive streams?

Thanks!</Description>
    <Title_Description>AzureQueues stops being processed when large and growing number of streams uses it I test Orleans for the use case when large number of independant messages should be processed in the fastest and scalable way. My first approach was to send each message to unique stream in the same namespace. So if message has id = GUID then it is sent to stream &lt;GUID "Namespace"&gt;. On the processing side I used implicit subscription grain ProcessingGrain with attr [ImplicitStreamSubscription("Namespace")]. So as many there are messages to process that many streams and grains are created. After message GUID is processed stream &lt;GUID "Namespace"&gt; and  ProcessingGrain &lt;GUID&gt; is not needed anymore so I configured ProcessingGrain to be Deactivated after 5 minutes. Not active streams are cleared from Orleans after StreamPullingAgentOptions.StreamInactivityPeriod that was left with the default value = 10 min.
Stream: AzureQueueStreamProvider
Clustering: AzureStorageClustering
Monitoring: Orleans Dashboard 2.2.0

I tried these load scenarios:
- 100-1000 msgs/sec
- 1-2 silos
- 1-8 queues in Azure Queue

Enviroment:
- Orleans 2.2.3
- Windows 10 or Windows Server 2016 Datacenter both x64
- .Net Core 2.2.0

and in all scenarios real Azure Queues were stopped being processed after 10-40 minutes of work. So pulling agents just don't pull messages anymore. Logs show that PubSubCacheSize grows all the time and at value 250-400k mentioned fail occurs. 
Old Grains are successfully deactivated and streams too but after fail occurs streams are not cleared. So value of PubSubCacheSize goes up and down but then on value of 250-400k it is not cleared anymore. At the same time all processing grains are eventually deactivated.

After chatting on gitter I understood that I need to try a solution of pool of streams with fixed number of them to avoid this situation of unbounded number of streams. 

- But anyway I think it is an issue that system just stops process streams with even no message in logs. It looks like everything is fine but messages just accumulate in Azure Queue. 
- Also I don't understand why if inactive streams are cleared after StreamInactivityPeriod and all grains are deactivated the described pattern of 1stream\msg is not working one? It seems to me that up to some load the system should feel fine. New messages create new objects in the system but at that time old objects (streams system info and grains) have been cleared already.

Besides of my (actually not recommended in the docs) scenario please consider another one:
The system creates a group of grains per some event e.g. conference. These grains use persistant stream like AzureQueue for some communication. Conferences should not know about each other so each conference=group of grains uses its own stream Id = Conference Id. The frequency of new conferences creation can be high comparable with my test 100-500/sec. Here each stream is used many times but like in my test when the conference ends stream is not needed anymore. It will never be used again. So number of streams in system can slowly grow. So now it looks similar to my test. 
And I'm afraid that on some load Orleans will stop process streams and create new ones because of some reason. May be because it can't handle situation when speed of new streams creation is more than speed of clearing inactive streams?

Thanks!</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5359</IssueLabelID>
    <Title>MySQL membership failed to start </Title>
    <Description>Hi All

Configured my Silo  with ADO net clustering to use MySQL as the storage provider. Executed the MySQL scripts which are in OrleansAdoNetContent and created the tables OrleansQuery orleansmembershiptable and orleansmembershipversiontable. But when running the SiloHost it gives the following error and fails. 

![mysql error- orleans](https://user-images.githubusercontent.com/4996419/52545829-a2f69680-2e0e-11e9-849d-d3e134233f76.jpg)


This is my Code for Silo Configuration 



![silo_code](https://user-images.githubusercontent.com/4996419/52545922-77c07700-2e0f-11e9-92ed-a35cf351942c.PNG)


All the packages are uptodate (V 2.2.3)


Thanks in advance 
</Description>
    <Title_Description>MySQL membership failed to start  Hi All

Configured my Silo  with ADO net clustering to use MySQL as the storage provider. Executed the MySQL scripts which are in OrleansAdoNetContent and created the tables OrleansQuery orleansmembershiptable and orleansmembershipversiontable. But when running the SiloHost it gives the following error and fails. 

![mysql error- orleans](https://user-images.githubusercontent.com/4996419/52545829-a2f69680-2e0e-11e9-849d-d3e134233f76.jpg)


This is my Code for Silo Configuration 



![silo_code](https://user-images.githubusercontent.com/4996419/52545922-77c07700-2e0f-11e9-92ed-a35cf351942c.PNG)


All the packages are uptodate (V 2.2.3)


Thanks in advance 
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5354</IssueLabelID>
    <Title>Add handling when pulling agent fails RegisterAsProducer to pubsub</Title>
    <Description>
    </Description>
    <Title_Description>Add handling when pulling agent fails RegisterAsProducer to pubsub </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5351</IssueLabelID>
    <Title>Persistent Grain super slow after having more than 5 active</Title>
    <Description>I recently converted all my grains to be persistent grains that hold grain state. After starting to do load testing however I'm noticing that beyond a threshold of 5 grains being active (single silo) it takes a long long time for me to get another grain and have it kick off to doing work. Does anyone have any thoughts as to why this would happen?

Here is the workflow.

POST to web api to create a factory (FactoryGrain)
POST to web api a bunch of orders to be worked on by the factory.

Factory spawns WorkerGrains to work on each order and then report back when they finish.

If I have 2 factories with 3 worker each another POST to create a factory times out with more than 30 second response time. 

During POST Factory I set up a FactoryGrain set an instance int variable and have it subscribe it to 2 streams. When it's timing out it hangs at setting the instance variable. </Description>
    <Title_Description>Persistent Grain super slow after having more than 5 active I recently converted all my grains to be persistent grains that hold grain state. After starting to do load testing however I'm noticing that beyond a threshold of 5 grains being active (single silo) it takes a long long time for me to get another grain and have it kick off to doing work. Does anyone have any thoughts as to why this would happen?

Here is the workflow.

POST to web api to create a factory (FactoryGrain)
POST to web api a bunch of orders to be worked on by the factory.

Factory spawns WorkerGrains to work on each order and then report back when they finish.

If I have 2 factories with 3 worker each another POST to create a factory times out with more than 30 second response time. 

During POST Factory I set up a FactoryGrain set an instance int variable and have it subscribe it to 2 streams. When it's timing out it hangs at setting the instance variable. </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5350</IssueLabelID>
    <Title>Migrate blog content from shut down MSDN blogs to docs</Title>
    <Description>We can later mirror the content on some blogging engine if we want. For now at least it'll be available as part of our docs.

You can see a preview on http://sergeybykov.github.io/orleans/Blog/index.html.</Description>
    <Title_Description>Migrate blog content from shut down MSDN blogs to docs We can later mirror the content on some blogging engine if we want. For now at least it'll be available as part of our docs.

You can see a preview on http://sergeybykov.github.io/orleans/Blog/index.html.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>5/02/2019 7:07:33 PM +00:00</CreatedAt>
    <ClosedAt>5/02/2019 11:04:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5349</IssueLabelID>
    <Title>Skip TestMultiClusterConf_3_3 test until it is fixed to pass reliably</Title>
    <Description>
    </Description>
    <Title_Description>Skip TestMultiClusterConf_3_3 test until it is fixed to pass reliably </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5348</IssueLabelID>
    <Title>Large message send hang</Title>
    <Description>Today we've met some strange crash. It started with these messages in log (you can see `ArraySegments=31` repeated 3 times)
```
2019-02-03 15:20:42.431 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=107222 HeaderLength=182 BodyLength=107032 #ArraySegments=30. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:45.301 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111750 HeaderLength=391 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:46.929 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111737 HeaderLength=378 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:48.094 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111737 HeaderLength=378 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:48.107 | Orleans.Runtime.CallbackData
"Response did not arrive on time in 00:00:30 for message: Request S10.111.0.200:1000:286884793*stg/14/0000000e@S0000000e-&gt;S10.111.0.107:1000:286884928*stg/10/0000000a@S0000000a #5685603: . Target History is: &lt;S10.111.0.107:1000:286884928:*stg/10/0000000a:@S0000000a&gt;." About to break its promise.
```
the there was some thousands of timeouts and finally this
```
2019-02-03 15:21:17.440 | Orleans.Runtime.MembershipService.MembershipOracleData
I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead.

2019-02-03 15:21:17.442 | Orleans.Runtime.MembershipService.MembershipOracleData
I have been told I am dead so this silo will stop! I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead.

2019-02-03 15:21:17.454 | Orleans.Threading.ThreadPoolThread
Stopping Thread "Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0" on managed thread 31

2019-02-03 15:21:17.461 | Orleans.Runtime.MembershipService.MembershipOracleData
INTERNAL FAILURE! About to crash! Fail message is: I have been told I am dead so this silo will stop! I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead...

2019-02-03 15:21:17.461 | Orleans.Runtime.MembershipService.MembershipOracleData
INTERNAL FAILURE! Process crashing!
```
So a silo became suddenly stopped responding and other nodes marked it as Dead in membership table.

Is there any way to track sources of this problem and maybe better way to catch it / monitor without waiting for so much calls to be dropped by timeout?</Description>
    <Title_Description>Large message send hang Today we've met some strange crash. It started with these messages in log (you can see `ArraySegments=31` repeated 3 times)
```
2019-02-03 15:20:42.431 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=107222 HeaderLength=182 BodyLength=107032 #ArraySegments=30. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:45.301 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111750 HeaderLength=391 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:46.929 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111737 HeaderLength=378 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:48.094 | Runtime.Messaging.SiloMessageSender/AppMsgsSender_1
Preparing to send large message Size=111737 HeaderLength=378 BodyLength=111351 #ArraySegments=31. Msg="Runtime.Messaging.SiloMessageSender/AppMsgsSender_1"

2019-02-03 15:20:48.107 | Orleans.Runtime.CallbackData
"Response did not arrive on time in 00:00:30 for message: Request S10.111.0.200:1000:286884793*stg/14/0000000e@S0000000e-&gt;S10.111.0.107:1000:286884928*stg/10/0000000a@S0000000a #5685603: . Target History is: &lt;S10.111.0.107:1000:286884928:*stg/10/0000000a:@S0000000a&gt;." About to break its promise.
```
the there was some thousands of timeouts and finally this
```
2019-02-03 15:21:17.440 | Orleans.Runtime.MembershipService.MembershipOracleData
I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead.

2019-02-03 15:21:17.442 | Orleans.Runtime.MembershipService.MembershipOracleData
I have been told I am dead so this silo will stop! I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead.

2019-02-03 15:21:17.454 | Orleans.Threading.ThreadPoolThread
Stopping Thread "Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0" on managed thread 31

2019-02-03 15:21:17.461 | Orleans.Runtime.MembershipService.MembershipOracleData
INTERNAL FAILURE! About to crash! Fail message is: I have been told I am dead so this silo will stop! I should be Dead according to membership table (in TryToSuspectOrKill): entry = SiloAddress=S10.111.0.200:1000:286884793 SiloName=Silo_f188d Status=Dead...

2019-02-03 15:21:17.461 | Orleans.Runtime.MembershipService.MembershipOracleData
INTERNAL FAILURE! Process crashing!
```
So a silo became suddenly stopped responding and other nodes marked it as Dead in membership table.

Is there any way to track sources of this problem and maybe better way to catch it / monitor without waiting for so much calls to be dropped by timeout?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5347</IssueLabelID>
    <Title>Jil Serializer breaks Orleans</Title>
    <Description>Sometimes when i reboot my server Web docker container can't connect to Silo container with this errors:

```
System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime.InteropServices.PInvoke Version=4.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.

File name: 'System.Runtime.InteropServices.PInvoke Version=4.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'
   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes)
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
   at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
   at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature)
   at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
   at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager)
   at Orleans.Serialization.SerializationManager.RegisterSerializers(IApplicationPartManager applicationPartManager)
   at Orleans.ClientBuilder.Build()
   at xxxx.Web.Application.ServiceRegistration.&lt;AddOrleans&gt;g__CreateOrleansClient|2_0(&lt;&gt;c__DisplayClass2_0&amp; ) in /app/src/xxx.Web/Application/Registration.cs:line 72
```

When i make docker restart for my Web container it's connect and everything is ok. 
But this error very annoying.

Docker image: microsoft/dotnet:2.2-aspnetcore-runtime (but i see these errors at v2.1 )
Tiered compilation if off

Web connect code looks like standard (i agree that it looks like khm .... ):

```
private static void AddOrleans(this IServiceCollection services ApplicationSettings settings)
        {
            services.AddSingleton(CreateOrleansClient());

            IClusterClient CreateOrleansClient()
            {
                while (true)
                {
                    try
                    {
                        var clientBuilder = new ClientBuilder()
                            .UseStaticClustering(new IPEndPoint(IPAddress.Parse(settings.Orleans.ClusterIp) settings.Orleans.GatewayPort))
                            .Configure&lt;ClusterOptions&gt;(options =&gt;
                            {
                                options.ClusterId = "xxx-dev";
                                options.ServiceId = "xxx";
                            }).ConfigureLogging(logging =&gt; logging.AddSerilog());

                        var client = clientBuilder.Build();
                        client.Connect().Wait();

                        return client;
                    }
                    catch (Exception ex)
                    {
                        Thread.Sleep(1000);
                        ///logging
                    }
                }
            }
        }
```
</Description>
    <Title_Description>Jil Serializer breaks Orleans Sometimes when i reboot my server Web docker container can't connect to Silo container with this errors:

```
System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime.InteropServices.PInvoke Version=4.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.

File name: 'System.Runtime.InteropServices.PInvoke Version=4.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'
   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes)
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
   at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
   at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature)
   at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
   at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager)
   at Orleans.Serialization.SerializationManager.RegisterSerializers(IApplicationPartManager applicationPartManager)
   at Orleans.ClientBuilder.Build()
   at xxxx.Web.Application.ServiceRegistration.&lt;AddOrleans&gt;g__CreateOrleansClient|2_0(&lt;&gt;c__DisplayClass2_0&amp; ) in /app/src/xxx.Web/Application/Registration.cs:line 72
```

When i make docker restart for my Web container it's connect and everything is ok. 
But this error very annoying.

Docker image: microsoft/dotnet:2.2-aspnetcore-runtime (but i see these errors at v2.1 )
Tiered compilation if off

Web connect code looks like standard (i agree that it looks like khm .... ):

```
private static void AddOrleans(this IServiceCollection services ApplicationSettings settings)
        {
            services.AddSingleton(CreateOrleansClient());

            IClusterClient CreateOrleansClient()
            {
                while (true)
                {
                    try
                    {
                        var clientBuilder = new ClientBuilder()
                            .UseStaticClustering(new IPEndPoint(IPAddress.Parse(settings.Orleans.ClusterIp) settings.Orleans.GatewayPort))
                            .Configure&lt;ClusterOptions&gt;(options =&gt;
                            {
                                options.ClusterId = "xxx-dev";
                                options.ServiceId = "xxx";
                            }).ConfigureLogging(logging =&gt; logging.AddSerilog());

                        var client = clientBuilder.Build();
                        client.Connect().Wait();

                        return client;
                    }
                    catch (Exception ex)
                    {
                        Thread.Sleep(1000);
                        ///logging
                    }
                }
            }
        }
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5346</IssueLabelID>
    <Title>Receiving Orleans.Storage.InconsistentState Exception while using Streams and Reminders</Title>
    <Description>Hi I recently added Reminders to my project to add fault tolerance. After adding it though and doing some stress testing with increasing load I see errors popping up such as 

"Error from storage provider AdoNetGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState" 

and 

"Failed to register a stream producer."

I've noted that possibly this issue https://github.com/dotnet/orleans/issues/2565 may have been related. However I'm using Reminders and not timers. Do you guys have any thoughts on this?</Description>
    <Title_Description>Receiving Orleans.Storage.InconsistentState Exception while using Streams and Reminders Hi I recently added Reminders to my project to add fault tolerance. After adding it though and doing some stress testing with increasing load I see errors popping up such as 

"Error from storage provider AdoNetGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState" 

and 

"Failed to register a stream producer."

I've noted that possibly this issue https://github.com/dotnet/orleans/issues/2565 may have been related. However I'm using Reminders and not timers. Do you guys have any thoughts on this?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5340</IssueLabelID>
    <Title>Code generation bug with generics</Title>
    <Description>The following interface and implementation cause a compile-time error with Orleans 1.5.6:

``` csharp
public interface IBugWithGenerics : IGrainWithIntegerKey
{
  Task SomeMethod&lt;T&gt;(string argument);
  Task SomeMethod&lt;T&gt;(int argument);
}

public class BugwithGenerics : Grain IBugWithGenerics
{
  public Task SomeMethod&lt;T&gt;(string argument)
  {
    throw new NotImplementedException();
  }

  public Task SomeMethod&lt;T&gt;(int argument)
  {
    throw new NotImplementedException();
  }
}
```

The compile-time error is here:

``` csharp
[global::System.CodeDom.Compiler.GeneratedCodeAttribute(@"Orleans-CodeGenerator" @"1.5.6.0") global::Orleans.CodeGeneration.MethodInvokerAttribute(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) -2136338972) global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
internal class OrleansCodeGenBugWithGenericsMethodInvoker : global::Orleans.CodeGeneration.IGrainMethodInvoker
{
  private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker SomeMethodT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) @"SomeMethod" 1);
  private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker SomeMethodT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) @"SomeMethod" 1);
  public global::System.Threading.Tasks.Task&lt;global::System.Object&gt; @Invoke(global::Orleans.Runtime.IAddressable @grain global::Orleans.CodeGeneration.InvokeMethodRequest @request)
  {
    global::System.Int32 interfaceId = @request.@InterfaceId;
    global::System.Int32 methodId = @request.@MethodId;
    global::System.Object[] arguments = @request.@Arguments;
    if (@grain == null)
      throw new global::System.ArgumentNullException(@"grain");
    switch (interfaceId)
    {
      case -2136338972:
        switch (methodId)
        {
          case 1206537793:
            return SomeMethodT.@Invoke(@grain arguments);
          case 1029784630:
            return SomeMethodT.@Invoke(@grain arguments);
          default:
            throw new global::System.NotImplementedException(@"interfaceId=" + -2136338972 + @"methodId=" + methodId);
        }

      default:
        throw new global::System.NotImplementedException(@"interfaceId=" + interfaceId);
    }
  }

  public global::System.Int32 InterfaceId
  {
    get
    {
      return -2136338972;
    }
  }

  public global::System.UInt16 InterfaceVersion
  {
    get
    {
      return 1;
    }
  }
}
```

There are two generic method invokers named `SomeMethodT` generated which does not compile.</Description>
    <Title_Description>Code generation bug with generics The following interface and implementation cause a compile-time error with Orleans 1.5.6:

``` csharp
public interface IBugWithGenerics : IGrainWithIntegerKey
{
  Task SomeMethod&lt;T&gt;(string argument);
  Task SomeMethod&lt;T&gt;(int argument);
}

public class BugwithGenerics : Grain IBugWithGenerics
{
  public Task SomeMethod&lt;T&gt;(string argument)
  {
    throw new NotImplementedException();
  }

  public Task SomeMethod&lt;T&gt;(int argument)
  {
    throw new NotImplementedException();
  }
}
```

The compile-time error is here:

``` csharp
[global::System.CodeDom.Compiler.GeneratedCodeAttribute(@"Orleans-CodeGenerator" @"1.5.6.0") global::Orleans.CodeGeneration.MethodInvokerAttribute(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) -2136338972) global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
internal class OrleansCodeGenBugWithGenericsMethodInvoker : global::Orleans.CodeGeneration.IGrainMethodInvoker
{
  private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker SomeMethodT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) @"SomeMethod" 1);
  private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker SomeMethodT = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof(global::Implico.WebTemplate.Services.Tests.Faking.DataAccessLayer.MockEvidenceServices.IBugWithGenerics) @"SomeMethod" 1);
  public global::System.Threading.Tasks.Task&lt;global::System.Object&gt; @Invoke(global::Orleans.Runtime.IAddressable @grain global::Orleans.CodeGeneration.InvokeMethodRequest @request)
  {
    global::System.Int32 interfaceId = @request.@InterfaceId;
    global::System.Int32 methodId = @request.@MethodId;
    global::System.Object[] arguments = @request.@Arguments;
    if (@grain == null)
      throw new global::System.ArgumentNullException(@"grain");
    switch (interfaceId)
    {
      case -2136338972:
        switch (methodId)
        {
          case 1206537793:
            return SomeMethodT.@Invoke(@grain arguments);
          case 1029784630:
            return SomeMethodT.@Invoke(@grain arguments);
          default:
            throw new global::System.NotImplementedException(@"interfaceId=" + -2136338972 + @"methodId=" + methodId);
        }

      default:
        throw new global::System.NotImplementedException(@"interfaceId=" + interfaceId);
    }
  }

  public global::System.Int32 InterfaceId
  {
    get
    {
      return -2136338972;
    }
  }

  public global::System.UInt16 InterfaceVersion
  {
    get
    {
      return 1;
    }
  }
}
```

There are two generic method invokers named `SomeMethodT` generated which does not compile.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5339</IssueLabelID>
    <Title>Orleans hangs when one grain gets two request at the same time</Title>
    <Description>I'm trying on TransactionalState and following code does not work.
Can anybody help me?

```
// there are three grains
// Worker Reader Writer

// Reader.read calls Worker.read
// Writer.write calls Worker.write

// Worker has TransactionalState (Uses PerformRead on read PerformUpdate on write)
// Reader.read Writer.write are TransactionOption.Create
// Worker.read Worker.write are TransactionOption.CreateOrJoin

var reader = GetGrain&lt;Reader&gt;(...);
var writer = GetGrain&lt;Writer&gt;(...);

// It works this way
var task1 = writer.write();
await task1;
var task2 = reader.read();
await task2;

// But it's not working this way
var task1 = writer.write();
var task2 = reader.read();
await task1;
await task2; // &lt;-- It hangs when PerformRead is called in Worker grain.
```</Description>
    <Title_Description>Orleans hangs when one grain gets two request at the same time I'm trying on TransactionalState and following code does not work.
Can anybody help me?

```
// there are three grains
// Worker Reader Writer

// Reader.read calls Worker.read
// Writer.write calls Worker.write

// Worker has TransactionalState (Uses PerformRead on read PerformUpdate on write)
// Reader.read Writer.write are TransactionOption.Create
// Worker.read Worker.write are TransactionOption.CreateOrJoin

var reader = GetGrain&lt;Reader&gt;(...);
var writer = GetGrain&lt;Writer&gt;(...);

// It works this way
var task1 = writer.write();
await task1;
var task2 = reader.read();
await task2;

// But it's not working this way
var task1 = writer.write();
var task2 = reader.read();
await task1;
await task2; // &lt;-- It hangs when PerformRead is called in Worker grain.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5337</IssueLabelID>
    <Title>Enable hosted client by default</Title>
    <Description>
    </Description>
    <Title_Description>Enable hosted client by default </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5336</IssueLabelID>
    <Title>Batching batch containers pulling agent retrieves from cache</Title>
    <Description>- This change attempts to add a layer of batching in the PersistentStreamPullingAgent. If configured the 
   PersistentStreamPullingAgent will accumulate several BatchContainers received from a cache and place 
   them in an instance of BatchContainerBatch before delivering.

I'll add tests and fix the white spaces changes that were somehow included in the pull request. Mostly creating this pull request for visibility.
</Description>
    <Title_Description>Batching batch containers pulling agent retrieves from cache - This change attempts to add a layer of batching in the PersistentStreamPullingAgent. If configured the 
   PersistentStreamPullingAgent will accumulate several BatchContainers received from a cache and place 
   them in an instance of BatchContainerBatch before delivering.

I'll add tests and fix the white spaces changes that were somehow included in the pull request. Mostly creating this pull request for visibility.
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5335</IssueLabelID>
    <Title>Is it possible to connect other virtual actor systems in Orleans？</Title>
    <Description>Hi.

Is it possible to connect other virtual actor systems in Orleans? Like [orbit](https://github.com/orbit/orbit)

I think there may be tasks that need to be implemented in other languages so maybe the communication of two different virutal actor systems will become a difficult problem to solve.</Description>
    <Title_Description>Is it possible to connect other virtual actor systems in Orleans？ Hi.

Is it possible to connect other virtual actor systems in Orleans? Like [orbit](https://github.com/orbit/orbit)

I think there may be tasks that need to be implemented in other languages so maybe the communication of two different virutal actor systems will become a difficult problem to solve.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5334</IssueLabelID>
    <Title>added OnActivate reentrancy test</Title>
    <Description>This test fails on recursive call from OnActivateAsync(). This is for #5331</Description>
    <Title_Description>added OnActivate reentrancy test This test fails on recursive call from OnActivateAsync(). This is for #5331</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5332</IssueLabelID>
    <Title>Serialization Exception for ImmutableArray&lt;int&gt; </Title>
    <Description>Hi

Using 1.5.0 (we can't yet upgrade to 2.0)

```
Orleans.Runtime.OrleansMessageRejectionException: System.Runtime.Serialization.SerializationException: Type 'System.Collections.Immutable.ImmutableArray`1[[System.Int32 mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089]]' in Assembly 'System.Collections.Immutable Version=1.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.
   at System.Runtime.Serialization.FormatterServices.InternalGetSerializableMembers(RuntimeType type)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
   at System.Runtime.Serialization.FormatterServices.GetSerializableMembers(Type type StreamingContext context)
   at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitMemberInfo()
   at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Write(WriteObjectInfo objectInfo NameInfo memberNameInfo NameInfo typeNameInfo)
   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph Header[] inHeaders __BinaryWriter serWriter Boolean fCheck)
   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Header[] headers Boolean fCheck)
   at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
   at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.BuiltInTypes.SerializeInvokeMethodRequest(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.Serialize(Object raw BinaryTokenStreamWriter stream)
   at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
   at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Common.Domain.Subscriptions.SubscriptionGrain.&lt;SubscribeToResults&gt;d__22.MoveNext() in C:\BuildAgent\work\afca04fc01ce655a\Application\Common\Domain\Subscriptions\SubscriptionGrain.cs:line 215
```
In many other places we use `ImmutableArray` but with reference types and don't experience any issues but we've found recently that for `ImmutableArray&lt;int&gt;`  the serialization fails (data structure below). I'm guessing other values types would fail but I've not tried this.
```
    [Serializable Immutable]
    public abstract class GroupingSubscriberBase
    {
        protected ImmutableArray&lt;int&gt; AvailableSegements;
        protected ImmutableArray&lt;SegmentDto&gt; SegmentDtos;

        protected readonly bool DoesEmptyStatusNoneMeanActive;

        private Metrics _message;

        protected GroupingSubscriberBase( ImmutableArray&lt;int&gt; availableSegements bool doesEmptyStatusNoneMeanActive ImmutableArray&lt;SegmentDto&gt; segmentDtos )
        {
            AvailableSegements = availableSegements;
            DoesEmptyStatusNoneMeanActive = doesEmptyStatusNoneMeanActive;
            SegmentDtos = segmentDtos;
        }
    }

    [Serializable Immutable]
    public class SpecificGroupingSubscriber : GroupingSubscriberBase
    {
        private IReceiveResults _resultsReceiver; //inherits IAddressable and is created as GrainReference

        public SpecificGroupingSubscriber( ImmutableArray&lt;int&gt; availableSegements
            IReceiveResults receiver
            bool doesEmptyStatusNoneMeanActive ImmutableArray&lt;SegmentDto&gt; segmentDtos )
            : base( availableSegements doesEmptyStatusNoneMeanActive segmentDtos )
        {
            _resultsReceiver = receiver;
        }
    }
```
Thankfully not critical that we use `ImmutableArray` can just suffice with a normal array</Description>
    <Title_Description>Serialization Exception for ImmutableArray&lt;int&gt;  Hi

Using 1.5.0 (we can't yet upgrade to 2.0)

```
Orleans.Runtime.OrleansMessageRejectionException: System.Runtime.Serialization.SerializationException: Type 'System.Collections.Immutable.ImmutableArray`1[[System.Int32 mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089]]' in Assembly 'System.Collections.Immutable Version=1.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.
   at System.Runtime.Serialization.FormatterServices.InternalGetSerializableMembers(RuntimeType type)
   at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
   at System.Runtime.Serialization.FormatterServices.GetSerializableMembers(Type type StreamingContext context)
   at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitMemberInfo()
   at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Write(WriteObjectInfo objectInfo NameInfo memberNameInfo NameInfo typeNameInfo)
   at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph Header[] inHeaders __BinaryWriter serWriter Boolean fCheck)
   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Header[] headers Boolean fCheck)
   at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
   at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.BuiltInTypes.SerializeInvokeMethodRequest(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
   at Orleans.Serialization.SerializationManager.Serialize(Object raw BinaryTokenStreamWriter stream)
   at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
   at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Common.Domain.Subscriptions.SubscriptionGrain.&lt;SubscribeToResults&gt;d__22.MoveNext() in C:\BuildAgent\work\afca04fc01ce655a\Application\Common\Domain\Subscriptions\SubscriptionGrain.cs:line 215
```
In many other places we use `ImmutableArray` but with reference types and don't experience any issues but we've found recently that for `ImmutableArray&lt;int&gt;`  the serialization fails (data structure below). I'm guessing other values types would fail but I've not tried this.
```
    [Serializable Immutable]
    public abstract class GroupingSubscriberBase
    {
        protected ImmutableArray&lt;int&gt; AvailableSegements;
        protected ImmutableArray&lt;SegmentDto&gt; SegmentDtos;

        protected readonly bool DoesEmptyStatusNoneMeanActive;

        private Metrics _message;

        protected GroupingSubscriberBase( ImmutableArray&lt;int&gt; availableSegements bool doesEmptyStatusNoneMeanActive ImmutableArray&lt;SegmentDto&gt; segmentDtos )
        {
            AvailableSegements = availableSegements;
            DoesEmptyStatusNoneMeanActive = doesEmptyStatusNoneMeanActive;
            SegmentDtos = segmentDtos;
        }
    }

    [Serializable Immutable]
    public class SpecificGroupingSubscriber : GroupingSubscriberBase
    {
        private IReceiveResults _resultsReceiver; //inherits IAddressable and is created as GrainReference

        public SpecificGroupingSubscriber( ImmutableArray&lt;int&gt; availableSegements
            IReceiveResults receiver
            bool doesEmptyStatusNoneMeanActive ImmutableArray&lt;SegmentDto&gt; segmentDtos )
            : base( availableSegements doesEmptyStatusNoneMeanActive segmentDtos )
        {
            _resultsReceiver = receiver;
        }
    }
```
Thankfully not critical that we use `ImmutableArray` can just suffice with a normal array</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5331</IssueLabelID>
    <Title>Deadlocks on recursive calls</Title>
    <Description>The #3185 issue was closed a year ago but we're still getting problems with reentrant calls (using orleans 2.2 on netcore/linux).
Assuming interfaces
```
    public interface IGrainA: IGrainWithIntegerKey
    {
        Task&lt;int&gt; Get();
        Task&lt;int&gt; Start(int i);
    }

    public interface IGrainB : IGrainWithIntegerKey
    {
        Task&lt;int&gt; Init();
    }
```
implementation
```
    public class GrainA : Grain IGrainA
    {
        private int _value = 0;

        public Task&lt;int&gt; Get() =&gt;
            Task.FromResult(_value);

        public async Task&lt;int&gt; Start(int i)
        {
            _value = i;
            return await GrainFactory.GetGrain&lt;IGrainB&gt;(this.GetPrimaryKeyLong()).Init();
        }
    }

    public class GrainB : Grain IGrainB
    {
        private int _value;

        public override async Task OnActivateAsync()
        {
            _value = await GrainFactory.GetGrain&lt;IGrainA&gt;(this.GetPrimaryKeyLong()).Get();
        }

        public Task&lt;int&gt; Init() =&gt;
            Task.FromResult(_value);
    }
```
and the call `await cluster.GrainFactory.GetGrain&lt;IGrainA&gt;(1).Start(5)` results in deadlock that fails with timeout.</Description>
    <Title_Description>Deadlocks on recursive calls The #3185 issue was closed a year ago but we're still getting problems with reentrant calls (using orleans 2.2 on netcore/linux).
Assuming interfaces
```
    public interface IGrainA: IGrainWithIntegerKey
    {
        Task&lt;int&gt; Get();
        Task&lt;int&gt; Start(int i);
    }

    public interface IGrainB : IGrainWithIntegerKey
    {
        Task&lt;int&gt; Init();
    }
```
implementation
```
    public class GrainA : Grain IGrainA
    {
        private int _value = 0;

        public Task&lt;int&gt; Get() =&gt;
            Task.FromResult(_value);

        public async Task&lt;int&gt; Start(int i)
        {
            _value = i;
            return await GrainFactory.GetGrain&lt;IGrainB&gt;(this.GetPrimaryKeyLong()).Init();
        }
    }

    public class GrainB : Grain IGrainB
    {
        private int _value;

        public override async Task OnActivateAsync()
        {
            _value = await GrainFactory.GetGrain&lt;IGrainA&gt;(this.GetPrimaryKeyLong()).Get();
        }

        public Task&lt;int&gt; Init() =&gt;
            Task.FromResult(_value);
    }
```
and the call `await cluster.GrainFactory.GetGrain&lt;IGrainA&gt;(1).Start(5)` results in deadlock that fails with timeout.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5330</IssueLabelID>
    <Title>Every call to the grain sends a packet over the network for a request? </Title>
    <Description>Is there a way to get the requested data directly to silo because each time the requested parameter is a complex object it will take some time to make a memory copy and then send it over the network. Assuming my program is only running on one server the above operations will waste a lot of performance.
Thank you for reading。</Description>
    <Title_Description>Every call to the grain sends a packet over the network for a request?  Is there a way to get the requested data directly to silo because each time the requested parameter is a complex object it will take some time to make a memory copy and then send it over the network. Assuming my program is only running on one server the above operations will waste a lot of performance.
Thank you for reading。</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5329</IssueLabelID>
    <Title>Orleans on OpenShift</Title>
    <Description>We are trying to launch _Orleans 2.2_ on [OpenShift](https://www.openshift.com/) platform.
However we do have one important network limitation. We are only allowed to communicate between Orleans silos (Docker containers) through a single gateway address. Our security limitations we cannot allow direct TCP "silo-to-silo" communication. 
If I try to initialize `EndpointOptions.SiloListeningEndpoint = new IPEndPoint(... SiloPort);`  with our gateway address and allowed port Orleans cannot let me launch a second silo on the same IP address. It just deactivates old silo and starts up a new one.
Are there any ways to circumvent that? Or using _Orleans_ on our current infrastructure is not the way to be?</Description>
    <Title_Description>Orleans on OpenShift We are trying to launch _Orleans 2.2_ on [OpenShift](https://www.openshift.com/) platform.
However we do have one important network limitation. We are only allowed to communicate between Orleans silos (Docker containers) through a single gateway address. Our security limitations we cannot allow direct TCP "silo-to-silo" communication. 
If I try to initialize `EndpointOptions.SiloListeningEndpoint = new IPEndPoint(... SiloPort);`  with our gateway address and allowed port Orleans cannot let me launch a second silo on the same IP address. It just deactivates old silo and starts up a new one.
Are there any ways to circumvent that? Or using _Orleans_ on our current infrastructure is not the way to be?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5327</IssueLabelID>
    <Title>Access Grain from Controller in Orleans 2.0</Title>
    <Description>Hi. I'm migrating an MVC project from Orleans 1.5.6 to Orleans 2.0. Previously I would have accessed a Grain from a Controller by doing something like this:

`var player = GrainClient.GrainFactory.GetGrain&lt;IPlayerGrain&gt;("Bob");`

How can I do this in Orleans 2.0?

I've tried creating the Orleans Client itself as part of a Startup.cs class and injecting that as part of a ServiceCollection:

```
var siloConfiguration = new ClusterConfiguration();
siloConfiguration.UseStartupType&lt;Silo.DI.Startup&gt;();

this.builder = new SiloHostBuilder()
                .UseConfiguration(siloConfiguration)
                .Etc
                .Etc
```

But the Startup class seems to be ignore when the Silo starts up. Has Startup class implementation changed in 2.0?

I've also tried injecting the GrainFactory as a dependency in the SiloHostBuilder like this:

`.ConfigureServices(services =&gt; services.AddSingleton&lt;IGrainFactory&gt;());`

But there is no implementation type for GrainFactory that I can access.

Am I missing something obvious here? Feels like there should be a straightforward way to access a Grain from a Controller.
</Description>
    <Title_Description>Access Grain from Controller in Orleans 2.0 Hi. I'm migrating an MVC project from Orleans 1.5.6 to Orleans 2.0. Previously I would have accessed a Grain from a Controller by doing something like this:

`var player = GrainClient.GrainFactory.GetGrain&lt;IPlayerGrain&gt;("Bob");`

How can I do this in Orleans 2.0?

I've tried creating the Orleans Client itself as part of a Startup.cs class and injecting that as part of a ServiceCollection:

```
var siloConfiguration = new ClusterConfiguration();
siloConfiguration.UseStartupType&lt;Silo.DI.Startup&gt;();

this.builder = new SiloHostBuilder()
                .UseConfiguration(siloConfiguration)
                .Etc
                .Etc
```

But the Startup class seems to be ignore when the Silo starts up. Has Startup class implementation changed in 2.0?

I've also tried injecting the GrainFactory as a dependency in the SiloHostBuilder like this:

`.ConfigureServices(services =&gt; services.AddSingleton&lt;IGrainFactory&gt;());`

But there is no implementation type for GrainFactory that I can access.

Am I missing something obvious here? Feels like there should be a straightforward way to access a Grain from a Controller.
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5326</IssueLabelID>
    <Title>SimpleMessageStream performance seems not good enough</Title>
    <Description>According to the [Orleans Streams Documention](https://dotnet.github.io/orleans/Documentation/streaming/index.html) I try to write a chat demo which uses the SimpleMessageStream. I just want to simulate some simple usecases in a chat system such as one-to-one chat. 

The demo looks like:
1. A silo cluster(more than 2 silo servers )
2. Several clients each one simulates hundreds of users(in fact it's a gateway between the silo server and the user's devices. Because Orleans doesn't want to directly exposed the server address to the user right?)  
3. Each user has a unique ID and subscribes a stream which is based on his ID.So other users can publish a message to a user's stream if they know his ID and the user will receive it because he subscribes himself.

I am concerned about the latency in the chat system so I divide the users into two group(A and B). In group A each user will cyclic(now it is 5 second) send a message with a local unix timestamp to several(now it is 10) users in group B. In group B when a user receive a message from group A it would send the same message(the unix timestamp not change) back to the user in group A. When the user in group A receive the response message he could use the local unix timestamp to calculate the latency.

the client side's code looks like that:
```C#

// consumer class to subscribe a stream
public class ClientConsumer : IAsyncObserver&lt;Ping&gt;
{
    public Action&lt;Ping&gt; OnNextCallBack;

    public Task OnCompletedAsync()
    {
        Console.WriteLine("ClientConsumer Complete");
        return Task.CompletedTask;
    }

    public Task OnErrorAsync(Exception ex)
    {
        Console.WriteLine($"ClientConsumer Error:{ex}");
        return Task.CompletedTask;
    }

    public Task OnNextAsync(Ping item StreamSequenceToken token = null)
    {
        OnNextCallBack?.Invoke(item);
        return Task.CompletedTask;
    }
}

public class UserClient
{
    public long selfId;
    private ClientConsumer selfStreamConsumer;
    private Guid selfGuid;

    ...

    public async Task InitAsSender()
    {
        var selfStream = streamProvider.GetStream&lt;Ping&gt;(selfGuid $"PrivateStream_{selfPlayerId}");

        selfStreamConsumer.OnNextCallBack = msg =&gt;
        {
            //caculate the latency and record it
        };
        await selfStream.SubscribeAsync(selfStreamConsumer);
    }

    public async Task InitAsReceiver()
    {
        var selfStream = streamProvider.GetStream&lt;Ping&gt;(selfGuid $"PrivateStream_{selfPlayerId}");

        selfStreamConsumer.OnNextCallBack = msg =&gt;
        {
            //get the sender's stream and send back
        };
        await selfStream.SubscribeAsync(selfStreamConsumer);
    }
}
```

I use the ConsulCluster deploy 2 silo servers and simulate 12000 users to chat. Here is the test result:
```
Unit (ms = milliseconds)
SimpleMessageStream
Max:1134 ms
Mid:137 ms
Min:1 ms
Avg:152 ms

distribution:
99.9% &lt; 1066 ms
99.0% &lt; 860 ms
95.0% &lt; 243 ms
90.0% &lt; 163 ms
```
In order to compare I use a message queue([NATS](https://github.com/nats-io/gnatsd) only a single point no cluster) to simulate the same case. The result is much more better.
```
NATS
Max:218 ms
Mid:37 ms
Min:1 ms
Avg:56 ms

distribution:
99.9% &lt; 168 ms
99.0% &lt; 161 ms
95.0% &lt; 142 ms
90.0% &lt; 127 ms
``` 

The server/client machine's all use CentOS 7 and their cpu(8 cores) usage doesn't reach 100%(in 
 fact the server's usage is only about 40% and the bandwidth is enough. 

Although the average latency seems good but there is 5% latency more than 240 ms and 1%  more than 860 ms. Compare to the NATS's result it is a little bit unacceptable :(

PS:I guess some off-cpu analysis work will be down. I am trying to use bcc tools to do some analysis but have met some problems about the dotnet core symbols.</Description>
    <Title_Description>SimpleMessageStream performance seems not good enough According to the [Orleans Streams Documention](https://dotnet.github.io/orleans/Documentation/streaming/index.html) I try to write a chat demo which uses the SimpleMessageStream. I just want to simulate some simple usecases in a chat system such as one-to-one chat. 

The demo looks like:
1. A silo cluster(more than 2 silo servers )
2. Several clients each one simulates hundreds of users(in fact it's a gateway between the silo server and the user's devices. Because Orleans doesn't want to directly exposed the server address to the user right?)  
3. Each user has a unique ID and subscribes a stream which is based on his ID.So other users can publish a message to a user's stream if they know his ID and the user will receive it because he subscribes himself.

I am concerned about the latency in the chat system so I divide the users into two group(A and B). In group A each user will cyclic(now it is 5 second) send a message with a local unix timestamp to several(now it is 10) users in group B. In group B when a user receive a message from group A it would send the same message(the unix timestamp not change) back to the user in group A. When the user in group A receive the response message he could use the local unix timestamp to calculate the latency.

the client side's code looks like that:
```C#

// consumer class to subscribe a stream
public class ClientConsumer : IAsyncObserver&lt;Ping&gt;
{
    public Action&lt;Ping&gt; OnNextCallBack;

    public Task OnCompletedAsync()
    {
        Console.WriteLine("ClientConsumer Complete");
        return Task.CompletedTask;
    }

    public Task OnErrorAsync(Exception ex)
    {
        Console.WriteLine($"ClientConsumer Error:{ex}");
        return Task.CompletedTask;
    }

    public Task OnNextAsync(Ping item StreamSequenceToken token = null)
    {
        OnNextCallBack?.Invoke(item);
        return Task.CompletedTask;
    }
}

public class UserClient
{
    public long selfId;
    private ClientConsumer selfStreamConsumer;
    private Guid selfGuid;

    ...

    public async Task InitAsSender()
    {
        var selfStream = streamProvider.GetStream&lt;Ping&gt;(selfGuid $"PrivateStream_{selfPlayerId}");

        selfStreamConsumer.OnNextCallBack = msg =&gt;
        {
            //caculate the latency and record it
        };
        await selfStream.SubscribeAsync(selfStreamConsumer);
    }

    public async Task InitAsReceiver()
    {
        var selfStream = streamProvider.GetStream&lt;Ping&gt;(selfGuid $"PrivateStream_{selfPlayerId}");

        selfStreamConsumer.OnNextCallBack = msg =&gt;
        {
            //get the sender's stream and send back
        };
        await selfStream.SubscribeAsync(selfStreamConsumer);
    }
}
```

I use the ConsulCluster deploy 2 silo servers and simulate 12000 users to chat. Here is the test result:
```
Unit (ms = milliseconds)
SimpleMessageStream
Max:1134 ms
Mid:137 ms
Min:1 ms
Avg:152 ms

distribution:
99.9% &lt; 1066 ms
99.0% &lt; 860 ms
95.0% &lt; 243 ms
90.0% &lt; 163 ms
```
In order to compare I use a message queue([NATS](https://github.com/nats-io/gnatsd) only a single point no cluster) to simulate the same case. The result is much more better.
```
NATS
Max:218 ms
Mid:37 ms
Min:1 ms
Avg:56 ms

distribution:
99.9% &lt; 168 ms
99.0% &lt; 161 ms
95.0% &lt; 142 ms
90.0% &lt; 127 ms
``` 

The server/client machine's all use CentOS 7 and their cpu(8 cores) usage doesn't reach 100%(in 
 fact the server's usage is only about 40% and the bandwidth is enough. 

Although the average latency seems good but there is 5% latency more than 240 ms and 1%  more than 860 ms. Compare to the NATS's result it is a little bit unacceptable :(

PS:I guess some off-cpu analysis work will be down. I am trying to use bcc tools to do some analysis but have met some problems about the dotnet core symbols.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5324</IssueLabelID>
    <Title>Performance issue how to read warnings from log</Title>
    <Description>Hello
how to get more details about warnings visible in log ?
I have faced performance issues but I can't find what is the reason.
I will appreciate your help.
Greetings

My logs:
&gt;       Task [Id=8677620 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to
ok elapsed time 0:00:00.3293732 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678501 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1660678162373163416/72803998@S72803998] to
ok elapsed time 0:00:00.2571926 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678514 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t
ook elapsed time 0:00:00.2284598 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678839 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t
ook elapsed time 0:00:00.487768 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678990 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/2892194010405447811/03baa883@S03baa883] to
ok elapsed time 0:00:00.4912624 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8682400 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10139444246793834898/46065192@S46065192] t
ook elapsed time 0:00:00.2345563 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8683635 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to
ok elapsed time 0:00:00.3088771 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684277 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to
ok elapsed time 0:00:00.2059425 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684381 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to
ok elapsed time 0:00:00.2554212 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684605 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/12365399726059551649/417dfba1@S417dfba1] t
ook elapsed time 0:00:00.2144696 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8689909 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.2164671 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8692696 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11452622014448957596/260c789c@S260c789c] t
ook elapsed time 0:00:00.3986481 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8693449 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.356442 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8694469 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/8797984796704637060/12de0084@S12de0084] to
ok elapsed time 0:00:00.2079363 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8694695 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2369492 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8695501 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to
ok elapsed time 0:00:00.8594778 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8697446 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t
ook elapsed time 0:00:00.3273585 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8698355 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t
ook elapsed time 0:00:00.2694442 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8700250 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13037136908939279520/e975bca0@Se975bca0] t
ook elapsed time 0:00:00.3555526 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8700861 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14859631423479171972/c9b54b84@Sc9b54b84] t
ook elapsed time 0:00:00.3161251 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8702632 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.2025749 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8702901 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2669245 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8706348 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to
ok elapsed time 0:00:00.2264682 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8708324 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13205469375169319353/5f4451b9@S5f4451b9] t
ook elapsed time 0:00:00.284403 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8708693 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2148307 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8710148 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to
ok elapsed time 0:00:00.5519002 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8715341 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15952853474205714349/83e347ad@S83e347ad] t
ook elapsed time 0:00:00.5413761 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8715823 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16365102821271470515/56a101b3@S56a101b3] t
ook elapsed time 0:00:00.2770024 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8716471 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to
ok elapsed time 0:00:00.2164933 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717287 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to
ok elapsed time 0:00:00.2459953 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717470 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to
ok elapsed time 0:00:00.3994595 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717819 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t
ook elapsed time 0:00:00.2591515 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717860 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.2349099 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8719159 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/753007251491414656/0a706280@S0a706280] too
k elapsed time 0:00:00.2772202 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8719938 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to
ok elapsed time 0:00:00.3865724 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8720187 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t
ook elapsed time 0:00:00.393994 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8721865 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.2093606 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8722921 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.29118 for execution which is longer than 00:00:00.20000
00. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8723871 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t
ook elapsed time 0:00:00.2281181 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8726620 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/812735807001527226/109103ba@S109103ba] too
k elapsed time 0:00:00.3368624 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727268 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t
ook elapsed time 0:00:00.2351561 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727378 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.2045067 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727801 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10177662558882251144/79f84188@S79f84188] t
ook elapsed time 0:00:00.3269352 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8729143 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/6346276726719776131/16760583@S16760583] to
ok elapsed time 0:00:00.2939532 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8729889 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to
ok elapsed time 0:00:00.2711455 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8731870 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15278920717608221610/0464fbaa@S0464fbaa] t
ook elapsed time 0:00:00.4368154 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8732476 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17144885887817931434/a1fedaaa@Sa1fedaaa] t
ook elapsed time 0:00:00.387365 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736383 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9139807053803530884/3591aa84@S3591aa84] to
ok elapsed time 0:00:00.4033186 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736448 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/404602148764222349/b873838d@Sb873838d] too
k elapsed time 0:00:00.7389245 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736864 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11199281674166864300/a84209ac@Sa84209ac] t
ook elapsed time 0:00:00.2407328 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8737603 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t
ook elapsed time 0:00:00.338192 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8738574 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t
ook elapsed time 0:00:00.2200619 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8739156 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11867948782904102814/f9874f9e@Sf9874f9e] t
ook elapsed time 0:00:00.4196865 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8740236 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.3324778 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8741554 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/8188424151639157946/bcae6cba@Sbcae6cba] to
ok elapsed time 0:00:00.2116091 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8743123 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.3394255 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8743381 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t
ook elapsed time 0:00:00.2190081 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8746322 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t
ook elapsed time 0:00:00.2179242 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8750120 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/18232931148661783190/0a23fa96@S0a23fa96] t
ook elapsed time 0:00:00.3155508 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8750132 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.3163106 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread

&gt; </Description>
    <Title_Description>Performance issue, how to read warnings from log Hello
how to get more details about warnings visible in log ?
I have faced performance issues but I can't find what is the reason.
I will appreciate your help.
Greetings

My logs:
&gt;       Task [Id=8677620 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to
ok elapsed time 0:00:00.3293732 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678501 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1660678162373163416/72803998@S72803998] to
ok elapsed time 0:00:00.2571926 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678514 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t
ook elapsed time 0:00:00.2284598 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678839 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t
ook elapsed time 0:00:00.487768 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8678990 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/2892194010405447811/03baa883@S03baa883] to
ok elapsed time 0:00:00.4912624 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8682400 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10139444246793834898/46065192@S46065192] t
ook elapsed time 0:00:00.2345563 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8683635 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/7480126151777703339/87d1d5ab@S87d1d5ab] to
ok elapsed time 0:00:00.3088771 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684277 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to
ok elapsed time 0:00:00.2059425 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684381 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to
ok elapsed time 0:00:00.2554212 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8684605 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/12365399726059551649/417dfba1@S417dfba1] t
ook elapsed time 0:00:00.2144696 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8689909 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.2164671 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8692696 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11452622014448957596/260c789c@S260c789c] t
ook elapsed time 0:00:00.3986481 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8693449 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.356442 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8694469 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/8797984796704637060/12de0084@S12de0084] to
ok elapsed time 0:00:00.2079363 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8694695 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2369492 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8695501 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to
ok elapsed time 0:00:00.8594778 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8697446 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t
ook elapsed time 0:00:00.3273585 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8698355 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t
ook elapsed time 0:00:00.2694442 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8700250 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13037136908939279520/e975bca0@Se975bca0] t
ook elapsed time 0:00:00.3555526 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8700861 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14859631423479171972/c9b54b84@Sc9b54b84] t
ook elapsed time 0:00:00.3161251 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8702632 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.2025749 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8702901 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2669245 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8706348 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to
ok elapsed time 0:00:00.2264682 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8708324 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13205469375169319353/5f4451b9@S5f4451b9] t
ook elapsed time 0:00:00.284403 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8708693 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.2148307 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8710148 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to
ok elapsed time 0:00:00.5519002 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8715341 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15952853474205714349/83e347ad@S83e347ad] t
ook elapsed time 0:00:00.5413761 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8715823 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16365102821271470515/56a101b3@S56a101b3] t
ook elapsed time 0:00:00.2770024 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8716471 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/4474990208853291151/ac0d308f@Sac0d308f] to
ok elapsed time 0:00:00.2164933 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717287 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3262124382583873155/ad0d5e83@Sad0d5e83] to
ok elapsed time 0:00:00.2459953 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717470 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3971411049396639124/d8591594@Sd8591594] to
ok elapsed time 0:00:00.3994595 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717819 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/13243215104421926820/cf2817a4@Scf2817a4] t
ook elapsed time 0:00:00.2591515 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8717860 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.2349099 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8719159 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/753007251491414656/0a706280@S0a706280] too
k elapsed time 0:00:00.2772202 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8719938 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3070772565396539313/ea79c7b1@Sea79c7b1] to
ok elapsed time 0:00:00.3865724 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8720187 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t
ook elapsed time 0:00:00.393994 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8721865 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.2093606 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8722921 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.29118 for execution which is longer than 00:00:00.20000
00. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8723871 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/16201652576789337278/b5d214be@Sb5d214be] t
ook elapsed time 0:00:00.2281181 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8726620 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/812735807001527226/109103ba@S109103ba] too
k elapsed time 0:00:00.3368624 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727268 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17110226376080873662/34d1d8be@S34d1d8be] t
ook elapsed time 0:00:00.2351561 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727378 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10939458234255134123/e7ffcdab@Se7ffcdab] t
ook elapsed time 0:00:00.2045067 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8727801 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/10177662558882251144/79f84188@S79f84188] t
ook elapsed time 0:00:00.3269352 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8729143 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/6346276726719776131/16760583@S16760583] to
ok elapsed time 0:00:00.2939532 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8729889 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9974504408589424314/948a56ba@S948a56ba] to
ok elapsed time 0:00:00.2711455 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8731870 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15278920717608221610/0464fbaa@S0464fbaa] t
ook elapsed time 0:00:00.4368154 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8732476 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/17144885887817931434/a1fedaaa@Sa1fedaaa] t
ook elapsed time 0:00:00.387365 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736383 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9139807053803530884/3591aa84@S3591aa84] to
ok elapsed time 0:00:00.4033186 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736448 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/404602148764222349/b873838d@Sb873838d] too
k elapsed time 0:00:00.7389245 for execution which is longer than 00:00:00.2000
000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8736864 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11199281674166864300/a84209ac@Sa84209ac] t
ook elapsed time 0:00:00.2407328 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8737603 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t
ook elapsed time 0:00:00.338192 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8738574 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/15212243947186492053/a4a31295@Sa4a31295] t
ook elapsed time 0:00:00.2200619 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8739156 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11867948782904102814/f9874f9e@Sf9874f9e] t
ook elapsed time 0:00:00.4196865 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8740236 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/9962573138966299836/64ef44bc@S64ef44bc] to
ok elapsed time 0:00:00.3324778 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8741554 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/8188424151639157946/bcae6cba@Sbcae6cba] to
ok elapsed time 0:00:00.2116091 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8743123 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/1981981633998696594/8dd73092@S8dd73092] to
ok elapsed time 0:00:00.3394255 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8743381 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/14428427995014467459/fe238f83@Sfe238f83] t
ook elapsed time 0:00:00.2190081 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8746322 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/11444598981775634862/4988b1ae@S4988b1ae] t
ook elapsed time 0:00:00.2179242 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8750120 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/18232931148661783190/0a23fa96@S0a23fa96] t
ook elapsed time 0:00:00.3155508 for execution which is longer than 00:00:00.20
00000. Running on thread System.Threading.Thread
warn: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
      Task [Id=8750132 Status=RanToCompletion] in WorkGroup [LowPrioritySystemT
arget: S127.0.0.1:11111:285768451*stg/3002566311248937147/dc8c40bb@Sdc8c40bb] to
ok elapsed time 0:00:00.3163106 for execution which is longer than 00:00:00.200
0000. Running on thread System.Threading.Thread

&gt; </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5321</IssueLabelID>
    <Title>Message / Request Priority</Title>
    <Description>Hi we are using Orleans as back-end in our IoT project briefly it relies on ConnectionPoint's and Devices. Devices are connected to CP's. Each CP support only one connection in the same time so it's very suitable for CP's to work within single-threaded nature of grains. There are various reminders on CP for each Devices like read device setup read device data heartbeat health-check and some other domain specific operations. CPGrain is not re-entrant and we are using asynchronous socket for communication.

My question is; there is being multiple request by reminders on the CPGrain's mailboxes naturally but we also have some instant request that must be run instantly so expected behavior would be like that even if there are 20 messages in the mailbox cancel current process first (we can handle it with grain cancellation token) and **process instant request before other requests in the mailbox (that is I am asking for) is there a way to do that with Orleans**

Currently we are using priority queue in CPGrain to schedule and prioritize messages/requests but we have to check queue with timer to process. So we are loosing natural flow of Orleans by this custom solution besides lower time interval for that timer would result with high CPU consumption contrary higher time interval would result higher latency. Do you have any suggestion?</Description>
    <Title_Description>Message / Request Priority Hi we are using Orleans as back-end in our IoT project briefly it relies on ConnectionPoint's and Devices. Devices are connected to CP's. Each CP support only one connection in the same time so it's very suitable for CP's to work within single-threaded nature of grains. There are various reminders on CP for each Devices like read device setup read device data heartbeat health-check and some other domain specific operations. CPGrain is not re-entrant and we are using asynchronous socket for communication.

My question is; there is being multiple request by reminders on the CPGrain's mailboxes naturally but we also have some instant request that must be run instantly so expected behavior would be like that even if there are 20 messages in the mailbox cancel current process first (we can handle it with grain cancellation token) and **process instant request before other requests in the mailbox (that is I am asking for) is there a way to do that with Orleans**

Currently we are using priority queue in CPGrain to schedule and prioritize messages/requests but we have to check queue with timer to process. So we are loosing natural flow of Orleans by this custom solution besides lower time interval for that timer would result with high CPU consumption contrary higher time interval would result higher latency. Do you have any suggestion?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5320</IssueLabelID>
    <Title>Some questions about placements / discovery / grain types</Title>
    <Description>Hello there

We are about to run a silo with multiple grain types let's say IA IB IC ... 10 to 15 of them.

They are really distinct domains but we'd like to embed all this little world in the same cluster
- to avoid having to configure multiple IClusterClient and manage them
- and to have aggregated silos statistics all in one on the dashboard.

Those grain are hosted in distinct applications runned in a K8s cluster let's say 3 to 10 replica for each grain type (this way we have the ability to scale each part of the system independendly).

I was a little surprise to see that if I entirely drop a service let's say IZ (it's representing a good 1/3 part of the all system so it's 1/3 silos that are down on the same time) all the clients of the system who are actually never calling Z grains are starting to raise exceptions (mostly TimeOut). Until the cluster is stable again.

My guess is that in fact all silos are responsible for the placement/discovery of any grain of the cluster so the loss of any silo will impact randomly any client in the system depending on the partitions responsiblity ...

Would you say it's an expected behavior ? something that I could avoid somehow ? Is there something I could have greatly missunderstood ?
</Description>
    <Title_Description>Some questions about placements / discovery / grain types Hello there

We are about to run a silo with multiple grain types let's say IA IB IC ... 10 to 15 of them.

They are really distinct domains but we'd like to embed all this little world in the same cluster
- to avoid having to configure multiple IClusterClient and manage them
- and to have aggregated silos statistics all in one on the dashboard.

Those grain are hosted in distinct applications runned in a K8s cluster let's say 3 to 10 replica for each grain type (this way we have the ability to scale each part of the system independendly).

I was a little surprise to see that if I entirely drop a service let's say IZ (it's representing a good 1/3 part of the all system so it's 1/3 silos that are down on the same time) all the clients of the system who are actually never calling Z grains are starting to raise exceptions (mostly TimeOut). Until the cluster is stable again.

My guess is that in fact all silos are responsible for the placement/discovery of any grain of the cluster so the loss of any silo will impact randomly any client in the system depending on the partitions responsiblity ...

Would you say it's an expected behavior ? something that I could avoid somehow ? Is there something I could have greatly missunderstood ?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>18/01/2019 12:18:45 PM +00:00</CreatedAt>
    <ClosedAt>25/01/2019 9:16:39 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5319</IssueLabelID>
    <Title>Fix defensive check in LogConsistentGrain</Title>
    <Description>Found this low hanging fruit around the Orleans.Core project.

The original intent of this code is to have two possible error messages:

1.  `$"Cannot find consistency provider with Name={attr.ProviderName} for grain type {this.GetType().FullName}"`
2.  `$"No consistency provider manager found loading grain type {this.GetType().FullName}";`

However the wrapping `if`statement above that says:

`if (attr != null &amp;&amp; defaultFactory == null)`

...makes the expression below to always fall into the first error message because it evaluates always to `true` thus making impossible for the error message to be the second one.

Furthermore there is another safety check below that ultimately ensures `defaultFactory` is not null and throws an exception if so.
 
</Description>
    <Title_Description>Fix defensive check in LogConsistentGrain Found this low hanging fruit around the Orleans.Core project.

The original intent of this code is to have two possible error messages:

1.  `$"Cannot find consistency provider with Name={attr.ProviderName} for grain type {this.GetType().FullName}"`
2.  `$"No consistency provider manager found loading grain type {this.GetType().FullName}";`

However the wrapping `if`statement above that says:

`if (attr != null &amp;&amp; defaultFactory == null)`

...makes the expression below to always fall into the first error message because it evaluates always to `true` thus making impossible for the error message to be the second one.

Furthermore there is another safety check below that ultimately ensures `defaultFactory` is not null and throws an exception if so.
 
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5317</IssueLabelID>
    <Title>Orleans client takes a long time to close()</Title>
    <Description>Hi I designed a web API endpoint to take in work and distribute that work to various grains. During the API call I have it instantiating a new client to connect to the cluster and then close at the end when it's finished. However it's causing significant lag where the client could take upwards to 30 seconds to close. Do you guys have a recommended way to manage orleans client or simply make the API call not wait for the client to close() before responding back to the consumer? Thanks.</Description>
    <Title_Description>Orleans client takes a long time to close() Hi I designed a web API endpoint to take in work and distribute that work to various grains. During the API call I have it instantiating a new client to connect to the cluster and then close at the end when it's finished. However it's causing significant lag where the client could take upwards to 30 seconds to close. Do you guys have a recommended way to manage orleans client or simply make the API call not wait for the client to close() before responding back to the consumer? Thanks.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5316</IssueLabelID>
    <Title>Is storing state data inside of a grain redundant?</Title>
    <Description>Hi guys.
I'm wondering if it makes any sense to store State data inside a grain.
I'm adding State to a `Foo` grain.

When it was stateless (`Foo : Grain`) having `_bar` did make sense.
Now that a state has been added and persisted Foo's Bar can be accessed though its State so I totally see `_bar` as redundant info but just in case I'm missing something.

```c#
    [StorageProvider(ProviderName = "MyProvider")]
    public class Foo : Grain&lt;Bar&gt;
    {
        private readonly Bar _bar;  // Redundant?
        // ...
    }

    public class Bar
    {
        public int A { get; set; }

        public double B { get; set; }
    }
```

Thanks in advance for your answers!</Description>
    <Title_Description>Is storing state data inside of a grain redundant? Hi guys.
I'm wondering if it makes any sense to store State data inside a grain.
I'm adding State to a `Foo` grain.

When it was stateless (`Foo : Grain`) having `_bar` did make sense.
Now that a state has been added and persisted Foo's Bar can be accessed though its State so I totally see `_bar` as redundant info but just in case I'm missing something.

```c#
    [StorageProvider(ProviderName = "MyProvider")]
    public class Foo : Grain&lt;Bar&gt;
    {
        private readonly Bar _bar;  // Redundant?
        // ...
    }

    public class Bar
    {
        public int A { get; set; }

        public double B { get; set; }
    }
```

Thanks in advance for your answers!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/01/2019 10:33:08 AM +00:00</CreatedAt>
    <ClosedAt>17/01/2019 8:27:25 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5315</IssueLabelID>
    <Title>Need design advice regarding version selection strategy canary testing grains</Title>
    <Description>Hi there im working on an IOT project for a production facility and would like to use orleans

One requirement is that I need to be able to roll out updates for only one / some of the devices.

At first I thought I simply create one grain for each device. But im not sure if this will work.

I read the docs but for me it is not clear if / how I can achive what I want. http://dotnet.github.io/orleans/Documentation/deployment/grain_versioning/version_selector_strategy.html

Lets say I have device A and B both running Grain Version 1. And I want to deploy a new version only for Device A.

From what I understand the version is only chosen for new activations. So if an activation exists with V1 it will not be created in V2.

I think I can overcome this with a programmatic deactivation after deploying the update to one of the cluster nodes and then activating the grain again.

The other issue is that I need some custom version selection strategy so the cluster knows that it should create A as V2 and B as V1. 

Is this possible at all?

One thing I found is IPlacementDirector would that be the correct place to implement the desired behavior?
 </Description>
    <Title_Description>Need design advice regarding version selection strategy canary testing grains Hi there im working on an IOT project for a production facility and would like to use orleans

One requirement is that I need to be able to roll out updates for only one / some of the devices.

At first I thought I simply create one grain for each device. But im not sure if this will work.

I read the docs but for me it is not clear if / how I can achive what I want. http://dotnet.github.io/orleans/Documentation/deployment/grain_versioning/version_selector_strategy.html

Lets say I have device A and B both running Grain Version 1. And I want to deploy a new version only for Device A.

From what I understand the version is only chosen for new activations. So if an activation exists with V1 it will not be created in V2.

I think I can overcome this with a programmatic deactivation after deploying the update to one of the cluster nodes and then activating the grain again.

The other issue is that I need some custom version selection strategy so the cluster knows that it should create A as V2 and B as V1. 

Is this possible at all?

One thing I found is IPlacementDirector would that be the correct place to implement the desired behavior?
 </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5314</IssueLabelID>
    <Title>Cherry-picked commits for 2.2.3</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-picked commits for 2.2.3 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5313</IssueLabelID>
    <Title>Enable EventHub streaming tests</Title>
    <Description>Enable EventHub streaming tests 
- will be skipped on check in 
- will be in run in vso

vso event hub connection string  updated to the new one. </Description>
    <Title_Description>Enable EventHub streaming tests Enable EventHub streaming tests 
- will be skipped on check in 
- will be in run in vso

vso event hub connection string  updated to the new one. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5311</IssueLabelID>
    <Title>Samples/2.1/ServiceFabric/Stateless/StatelessCalculatorApp fails to deploy</Title>
    <Description>I'm having trouble getting the sample "Samples/2.1/ServiceFabric/Stateless/StatelessCalculatorApp" to deploy. I'm using Visual Studio 2017 Community and Windows 10 Pro; OS IDE and Service Fabric tools are all up to date.

I'm able to run a home rolled Service Fabric application/service but just to be sure I reset my cluster and rebooted.

No doubt I'm doing something wrong - any idea what?

Build log:

1&gt;------ Build started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;------ Deploy started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;Started executing script 'GetApplicationExistence'.
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:11.1557189
2&gt;Started executing script 'Set-LocalClusterReady'.
2&gt;powershell -NonInteractive -NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -Command "Import-Module 'C:\Program Files\Microsoft SDKs\Service Fabric\Tools\Scripts\DefaultLocalClusterSetup.psm1'; Set-LocalClusterReady -createOneNodeCluster $true"
2&gt;--------------------------------------------
2&gt;Local Service Fabric Cluster is not running...
2&gt;Please wait while we start the Local Service Fabric Cluster. This may take few minutes...
2&gt;Performing Start-Service on: FabricHostSvc . This may take a few minutes...
2&gt;
2&gt;Waiting for Service Fabric Cluster to be ready. This may take a few minutes...
2&gt;Local Cluster ready status: 4% completed.
2&gt;Local Cluster ready status: 100% completed.
2&gt;
2&gt;Waiting for fabric:/System/NamingService to be ready. This may take a few minutes...
2&gt;fabric:/System/NamingService is ready now...
2&gt;
2&gt;Deploying Addon Service:AzureFilesVolumePlugin in the cluster...
2&gt;
2&gt;
2&gt;    Directory: C:\Users\Steve\AppData\Local\Temp
2&gt;
2&gt;
2&gt;Mode                LastWriteTime         Length Name                                                                  
2&gt;----                -------------         ------ ----                                                                  
2&gt;d-----       11/01/2019     15:30                AzureFilesVolumePlugin                                                
2&gt;Using ImageStoreConnectionString='file:C:\SfDevCluster\Data\ImageStoreShare'
2&gt;Upload to Image Store succeeded
2&gt;Register application type succeeded
2&gt;
2&gt;ApplicationParameters  : {ListenPort InstanceCount}
2&gt;ApplicationName        : fabric:/AzureFilesVolumePlugin
2&gt;ApplicationTypeName    : AzureFilesVolumePluginType
2&gt;ApplicationTypeVersion : 6.4.622.9590
2&gt;MaximumNodes           : 0
2&gt;MinimumNodes           : 0
2&gt;Metrics                : {}
2&gt;
2&gt;
2&gt;Waiting for fabric:/AzureFilesVolumePlugin/Service to be ready. This may take a few minutes...
2&gt;fabric:/AzureFilesVolumePlugin/Service ready status: 8% completed.
2&gt;fabric:/AzureFilesVolumePlugin/Service is ready now...
2&gt;
2&gt;Deploying Addon Service:ServiceFabricVolumeDriver in the cluster...
2&gt;d-----       11/01/2019     15:31                ServiceFabricVolumeDriver                                             
2&gt;Using ImageStoreConnectionString='file:C:\SfDevCluster\Data\ImageStoreShare'
2&gt;Upload to Image Store succeeded
2&gt;Register application type succeeded
2&gt;
2&gt;ApplicationParameters  : {ListenPort InstanceCount}
2&gt;ApplicationName        : fabric:/ServiceFabricVolumeDriver
2&gt;ApplicationTypeName    : ServiceFabricVolumeDriverType
2&gt;ApplicationTypeVersion : 6.4.622.9590
2&gt;MaximumNodes           : 0
2&gt;MinimumNodes           : 0
2&gt;Metrics                : {}
2&gt;
2&gt;
2&gt;Waiting for fabric:/ServiceFabricVolumeDriver/Service to be ready. This may take a few minutes...
2&gt;fabric:/ServiceFabricVolumeDriver/Service ready status: 8% completed.
2&gt;fabric:/ServiceFabricVolumeDriver/Service is ready now...
2&gt;
2&gt;Local Service Fabric Cluster is running now.
2&gt;----------------------------------------
2&gt;Launching Service Fabric Local Cluster Manager...
2&gt;You can use Service Fabric Local Cluster Manager (system tray application) to manage your local dev cluster.
2&gt;
2&gt;
2&gt;Finished executing script 'Set-LocalClusterReady'.
2&gt;Time elapsed: 00:02:30.9555172
2&gt;Started executing script 'GetApplicationExistence'.
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:01.2374216
2&gt;Started executing script 'GetApplicationExistence'.
-------- Package started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:01.0377925
StatelessCalculatorService -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorService\bin\Debug\netcoreapp2.1\StatelessCalculatorService.dll
StatelessCalculatorService -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug\StatelessCalculatorServicePkg\Code\
StatelessCalculatorApp -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug
-------- Package: Project: StatelessCalculatorApp succeeded Time elapsed: 00:00:09.4987049 --------
2&gt;Started executing script 'Deploy-FabricApplication.ps1'.
2&gt;powershell -NonInteractive -NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -Command ". 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\Scripts\Deploy-FabricApplication.ps1' -ApplicationPackagePath 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug' -PublishProfileFile 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\PublishProfiles\Local.1Node.xml' -DeployOnly:$true -ApplicationParameter:@{_WFDebugParams_='[{"""CodePackageName""":"""Code""""""CodePackageLinkFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1""""""ConfigPackageName""":"""Config""""""ConfigPackageLinkFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\PackageRoot\\Config""""""DataPackageName""":null"""DataPackageLinkFolder""":null"""LockFile""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1\\_VS_ServiceFabric_lock.txt""""""WorkingFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService""""""ServiceManifestName""":"""StatelessCalculatorServicePkg""""""EntryPointType""":"""Main""""""DebugExePath""":null"""DebugArguments""":null"""DebugParametersFile""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1\\_VS_ServiceFabric_debug.txt"""}]'} -UnregisterUnusedApplicationVersionsAfterUpgrade $false -OverrideUpgradeBehavior 'None' -OverwriteBehavior 'Always' -SkipPackageValidation:$true -ErrorAction Stop"
2&gt;Copying application to image store...
2&gt;Upload to Image Store succeeded
2&gt;Registering application type...
2&gt;Register application type started. Use Get-ServiceFabricApplicationType to query for status.
2&gt;Running Image Builder process ...
2&gt;Downloading application package from 'StatelessCalculatorApp' ...
2&gt;FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR: The EntryPoint StatelessCalculatorService.exe is not found.
2&gt;FileName: C:\SfDevCluster\Data\ImageBuilderProxy\AppType\a02b2e7b-2148-45e5-a503-34d7abc9c1f0\StatelessCalculatorServicePkg\ServiceManifest.xml
2&gt;Registration of application type failed.
2&gt;At C:\Program Files\Microsoft SDKs\Service 
2&gt;Fabric\Tools\PSModule\ServiceFabricSDK\Publish-NewServiceFabricApplication.ps1:308 char:17
2&gt;+                 throw "Registration of application type failed."
2&gt;+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2&gt;    + CategoryInfo          : OperationStopped: (Registration of application type failed.:String) [] RuntimeException
2&gt;    + FullyQualifiedErrorId : Registration of application type failed.
2&gt; 
2&gt;Finished executing script 'Deploy-FabricApplication.ps1'.
2&gt;Time elapsed: 00:00:08.9462862
2&gt;The PowerShell script failed to execute.
========== Build: 1 succeeded 0 failed 3 up-to-date 0 skipped ==========
========== Deploy: 0 succeeded 1 failed 0 skipped ==========
</Description>
    <Title_Description>Samples/2.1/ServiceFabric/Stateless/StatelessCalculatorApp fails to deploy I'm having trouble getting the sample "Samples/2.1/ServiceFabric/Stateless/StatelessCalculatorApp" to deploy. I'm using Visual Studio 2017 Community and Windows 10 Pro; OS IDE and Service Fabric tools are all up to date.

I'm able to run a home rolled Service Fabric application/service but just to be sure I reset my cluster and rebooted.

No doubt I'm doing something wrong - any idea what?

Build log:

1&gt;------ Build started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;------ Deploy started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;Started executing script 'GetApplicationExistence'.
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:11.1557189
2&gt;Started executing script 'Set-LocalClusterReady'.
2&gt;powershell -NonInteractive -NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -Command "Import-Module 'C:\Program Files\Microsoft SDKs\Service Fabric\Tools\Scripts\DefaultLocalClusterSetup.psm1'; Set-LocalClusterReady -createOneNodeCluster $true"
2&gt;--------------------------------------------
2&gt;Local Service Fabric Cluster is not running...
2&gt;Please wait while we start the Local Service Fabric Cluster. This may take few minutes...
2&gt;Performing Start-Service on: FabricHostSvc . This may take a few minutes...
2&gt;
2&gt;Waiting for Service Fabric Cluster to be ready. This may take a few minutes...
2&gt;Local Cluster ready status: 4% completed.
2&gt;Local Cluster ready status: 100% completed.
2&gt;
2&gt;Waiting for fabric:/System/NamingService to be ready. This may take a few minutes...
2&gt;fabric:/System/NamingService is ready now...
2&gt;
2&gt;Deploying Addon Service:AzureFilesVolumePlugin in the cluster...
2&gt;
2&gt;
2&gt;    Directory: C:\Users\Steve\AppData\Local\Temp
2&gt;
2&gt;
2&gt;Mode                LastWriteTime         Length Name                                                                  
2&gt;----                -------------         ------ ----                                                                  
2&gt;d-----       11/01/2019     15:30                AzureFilesVolumePlugin                                                
2&gt;Using ImageStoreConnectionString='file:C:\SfDevCluster\Data\ImageStoreShare'
2&gt;Upload to Image Store succeeded
2&gt;Register application type succeeded
2&gt;
2&gt;ApplicationParameters  : {ListenPort InstanceCount}
2&gt;ApplicationName        : fabric:/AzureFilesVolumePlugin
2&gt;ApplicationTypeName    : AzureFilesVolumePluginType
2&gt;ApplicationTypeVersion : 6.4.622.9590
2&gt;MaximumNodes           : 0
2&gt;MinimumNodes           : 0
2&gt;Metrics                : {}
2&gt;
2&gt;
2&gt;Waiting for fabric:/AzureFilesVolumePlugin/Service to be ready. This may take a few minutes...
2&gt;fabric:/AzureFilesVolumePlugin/Service ready status: 8% completed.
2&gt;fabric:/AzureFilesVolumePlugin/Service is ready now...
2&gt;
2&gt;Deploying Addon Service:ServiceFabricVolumeDriver in the cluster...
2&gt;d-----       11/01/2019     15:31                ServiceFabricVolumeDriver                                             
2&gt;Using ImageStoreConnectionString='file:C:\SfDevCluster\Data\ImageStoreShare'
2&gt;Upload to Image Store succeeded
2&gt;Register application type succeeded
2&gt;
2&gt;ApplicationParameters  : {ListenPort InstanceCount}
2&gt;ApplicationName        : fabric:/ServiceFabricVolumeDriver
2&gt;ApplicationTypeName    : ServiceFabricVolumeDriverType
2&gt;ApplicationTypeVersion : 6.4.622.9590
2&gt;MaximumNodes           : 0
2&gt;MinimumNodes           : 0
2&gt;Metrics                : {}
2&gt;
2&gt;
2&gt;Waiting for fabric:/ServiceFabricVolumeDriver/Service to be ready. This may take a few minutes...
2&gt;fabric:/ServiceFabricVolumeDriver/Service ready status: 8% completed.
2&gt;fabric:/ServiceFabricVolumeDriver/Service is ready now...
2&gt;
2&gt;Local Service Fabric Cluster is running now.
2&gt;----------------------------------------
2&gt;Launching Service Fabric Local Cluster Manager...
2&gt;You can use Service Fabric Local Cluster Manager (system tray application) to manage your local dev cluster.
2&gt;
2&gt;
2&gt;Finished executing script 'Set-LocalClusterReady'.
2&gt;Time elapsed: 00:02:30.9555172
2&gt;Started executing script 'GetApplicationExistence'.
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:01.2374216
2&gt;Started executing script 'GetApplicationExistence'.
-------- Package started: Project: StatelessCalculatorApp Configuration: Debug x64 ------
2&gt;Finished executing script 'GetApplicationExistence'.
2&gt;Time elapsed: 00:00:01.0377925
StatelessCalculatorService -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorService\bin\Debug\netcoreapp2.1\StatelessCalculatorService.dll
StatelessCalculatorService -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug\StatelessCalculatorServicePkg\Code\
StatelessCalculatorApp -&gt; E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug
-------- Package: Project: StatelessCalculatorApp succeeded Time elapsed: 00:00:09.4987049 --------
2&gt;Started executing script 'Deploy-FabricApplication.ps1'.
2&gt;powershell -NonInteractive -NoProfile -WindowStyle Hidden -ExecutionPolicy Bypass -Command ". 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\Scripts\Deploy-FabricApplication.ps1' -ApplicationPackagePath 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\pkg\Debug' -PublishProfileFile 'E:\Reference source\Orleans\Samples\2.1\ServiceFabric\Stateless\StatelessCalculatorApp\PublishProfiles\Local.1Node.xml' -DeployOnly:$true -ApplicationParameter:@{_WFDebugParams_='[{"""CodePackageName""":"""Code""""""CodePackageLinkFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1""""""ConfigPackageName""":"""Config""""""ConfigPackageLinkFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\PackageRoot\\Config""""""DataPackageName""":null"""DataPackageLinkFolder""":null"""LockFile""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1\\_VS_ServiceFabric_lock.txt""""""WorkingFolder""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService""""""ServiceManifestName""":"""StatelessCalculatorServicePkg""""""EntryPointType""":"""Main""""""DebugExePath""":null"""DebugArguments""":null"""DebugParametersFile""":"""E:\\Reference source\\Orleans\\Samples\\2.1\\ServiceFabric\\Stateless\\StatelessCalculatorService\\bin\\Debug\\netcoreapp2.1\\_VS_ServiceFabric_debug.txt"""}]'} -UnregisterUnusedApplicationVersionsAfterUpgrade $false -OverrideUpgradeBehavior 'None' -OverwriteBehavior 'Always' -SkipPackageValidation:$true -ErrorAction Stop"
2&gt;Copying application to image store...
2&gt;Upload to Image Store succeeded
2&gt;Registering application type...
2&gt;Register application type started. Use Get-ServiceFabricApplicationType to query for status.
2&gt;Running Image Builder process ...
2&gt;Downloading application package from 'StatelessCalculatorApp' ...
2&gt;FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR: The EntryPoint StatelessCalculatorService.exe is not found.
2&gt;FileName: C:\SfDevCluster\Data\ImageBuilderProxy\AppType\a02b2e7b-2148-45e5-a503-34d7abc9c1f0\StatelessCalculatorServicePkg\ServiceManifest.xml
2&gt;Registration of application type failed.
2&gt;At C:\Program Files\Microsoft SDKs\Service 
2&gt;Fabric\Tools\PSModule\ServiceFabricSDK\Publish-NewServiceFabricApplication.ps1:308 char:17
2&gt;+                 throw "Registration of application type failed."
2&gt;+                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2&gt;    + CategoryInfo          : OperationStopped: (Registration of application type failed.:String) [] RuntimeException
2&gt;    + FullyQualifiedErrorId : Registration of application type failed.
2&gt; 
2&gt;Finished executing script 'Deploy-FabricApplication.ps1'.
2&gt;Time elapsed: 00:00:08.9462862
2&gt;The PowerShell script failed to execute.
========== Build: 1 succeeded 0 failed 3 up-to-date 0 skipped ==========
========== Deploy: 0 succeeded 1 failed 0 skipped ==========
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5310</IssueLabelID>
    <Title>Cannot resume stream after silo restart</Title>
    <Description>In my application I use a SMS provider and I have some issues when the silo restarts
The architecture is basically that:
- The system has a single silo and 2 clients.
- I use a single stream with only 1 grain that publish events
- The 2 clients subscribe directly to the stream.

The problem is when the silo restarts I cannot resume the event subscription
- Sometimes after the restart the stream continues working but this is not frequent
- Calling `ResumeAsync()` doesn't change anything. Is it on purpose? Am I missing something?

I made a simplified repro project that isolate and illustrate the issue: https://github.com/srollinet/OrleansStreamIssue

In the real application I use Ado storage and clustering and I call ResumeAsync only when I detect a connection lost. By the way it seems that the ClusterConnectionLostHandler is not systematically called when the silo crashes.

Bonus question: Is there a better / more robust solution to handle this use case? I have seen some examples with observers but I don't know what is the preferred way in this case.</Description>
    <Title_Description>Cannot resume stream after silo restart In my application I use a SMS provider and I have some issues when the silo restarts
The architecture is basically that:
- The system has a single silo and 2 clients.
- I use a single stream with only 1 grain that publish events
- The 2 clients subscribe directly to the stream.

The problem is when the silo restarts I cannot resume the event subscription
- Sometimes after the restart the stream continues working but this is not frequent
- Calling `ResumeAsync()` doesn't change anything. Is it on purpose? Am I missing something?

I made a simplified repro project that isolate and illustrate the issue: https://github.com/srollinet/OrleansStreamIssue

In the real application I use Ado storage and clustering and I call ResumeAsync only when I detect a connection lost. By the way it seems that the ClusterConnectionLostHandler is not systematically called when the silo crashes.

Bonus question: Is there a better / more robust solution to handle this use case? I have seen some examples with observers but I don't know what is the preferred way in this case.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5309</IssueLabelID>
    <Title>ASP.NET Core Identity store implementation</Title>
    <Description>What do you think about ASP.NET Core Identity and Orleans should it be implemented on Front-end project or in Orleans Grains I mean store Users roles tenants and so on? In case if it is decoupled from Orleans Grains how can I reference Orders(Grain) Entity to Users and Tenants from Identity store? Or it would be better to have something like this Microsoft.AspNetCore.Identity.EntityframeworkCore but
Microsoft.AspNetCore.Identity.OrleansStore?</Description>
    <Title_Description>ASP.NET Core Identity store implementation What do you think about ASP.NET Core Identity and Orleans should it be implemented on Front-end project or in Orleans Grains I mean store Users roles tenants and so on? In case if it is decoupled from Orleans Grains how can I reference Orders(Grain) Entity to Users and Tenants from Identity store? Or it would be better to have something like this Microsoft.AspNetCore.Identity.EntityframeworkCore but
Microsoft.AspNetCore.Identity.OrleansStore?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5308</IssueLabelID>
    <Title>Support customizable Actor type name</Title>
    <Description>Hi guys
I have multi tenant system and I would like to see all my Actor types in the same cluster for comfort and convenience.
A multi-tenant system means that the same actor type is deployed with different configuration because he will use different persistence queues etc related to his tenant and the health check will be done based on this tenant configuration.
This solution allows me to isolate the traffic/activity by tenant and to scale a tenant independently to the other on the same K8 cluster.

The registration of the actor is based on the silo/actor type.
For example based on this kind of registration I cannot make the distinction because actor type   HelloWorldType deployed on the tenant A and B on same K8 cluster.

In your book you said "(Orleans is not currently intended for a multi-tenant environment)": https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans-MSR-TR-2014-41.pdf
But @jkonecki succeed to use Orleans on his multi-tenant system: http://gigi.nullneuron.net/gigilabs/microsoft-orleans-use-case-reservations-system/

On ProtoActor we had the Actor kind concept and it's not related to the Actor Class Name it could be anything which is great!...

Source: https://github.com/AsynkronIT/protoactor-dotnet/blob/74d71f0c9eb14925da59ade42cbec4f2e4a2252f/src/Proto.Remote/Remote.cs

Example: https://github.com/AsynkronIT/protoactor-dotnet/blob/74d71f0c9eb14925da59ade42cbec4f2e4a2252f/examples/ClusterHelloWorld/Node2/Program.cs

But now that we moved to Orleans we cannot compute the actor type name...

We think that the solution could be to prefix the actor type name with the tenant name for example: 
- Tenant_A_ActorType_HelloWorldType
- Tenant_B_ActorType_HelloWorldType

It could be great if we can customize the actor type name.

We found the VersionAttribute it's not the same but it's something...
But I would prefer to have a more flexible way to indicate the tenant.

What do you think?
</Description>
    <Title_Description>Support customizable Actor type name Hi guys
I have multi tenant system and I would like to see all my Actor types in the same cluster for comfort and convenience.
A multi-tenant system means that the same actor type is deployed with different configuration because he will use different persistence queues etc related to his tenant and the health check will be done based on this tenant configuration.
This solution allows me to isolate the traffic/activity by tenant and to scale a tenant independently to the other on the same K8 cluster.

The registration of the actor is based on the silo/actor type.
For example based on this kind of registration I cannot make the distinction because actor type   HelloWorldType deployed on the tenant A and B on same K8 cluster.

In your book you said "(Orleans is not currently intended for a multi-tenant environment)": https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans-MSR-TR-2014-41.pdf
But @jkonecki succeed to use Orleans on his multi-tenant system: http://gigi.nullneuron.net/gigilabs/microsoft-orleans-use-case-reservations-system/

On ProtoActor we had the Actor kind concept and it's not related to the Actor Class Name it could be anything which is great!...

Source: https://github.com/AsynkronIT/protoactor-dotnet/blob/74d71f0c9eb14925da59ade42cbec4f2e4a2252f/src/Proto.Remote/Remote.cs

Example: https://github.com/AsynkronIT/protoactor-dotnet/blob/74d71f0c9eb14925da59ade42cbec4f2e4a2252f/examples/ClusterHelloWorld/Node2/Program.cs

But now that we moved to Orleans we cannot compute the actor type name...

We think that the solution could be to prefix the actor type name with the tenant name for example: 
- Tenant_A_ActorType_HelloWorldType
- Tenant_B_ActorType_HelloWorldType

It could be great if we can customize the actor type name.

We found the VersionAttribute it's not the same but it's something...
But I would prefer to have a more flexible way to indicate the tenant.

What do you think?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5307</IssueLabelID>
    <Title>Fix package dependency condition for Microsoft.Orleans.Transactions</Title>
    <Description>
    </Description>
    <Title_Description>Fix package dependency condition for Microsoft.Orleans.Transactions </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5304</IssueLabelID>
    <Title>Improve steps for getting started in readme</Title>
    <Description>Lifting this feedback from #5133.
&gt;Sidenote: even on the Windows machine doing a clean checkout would not work properly as a lot of tests kept failing randomly not sure if there was something wrong with the setup. Would still be nice to have some FAQ on how to setup the project as a new contributor as the steps in the README did not work out of the box and there was a bunch of stuff I had to do to even run a single test.</Description>
    <Title_Description>Improve steps for getting started in readme Lifting this feedback from #5133.
&gt;Sidenote: even on the Windows machine doing a clean checkout would not work properly as a lot of tests kept failing randomly not sure if there was something wrong with the setup. Would still be nice to have some FAQ on how to setup the project as a new contributor as the steps in the README did not work out of the box and there was a bunch of stuff I had to do to even run a single test.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>9/01/2019 10:57:29 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5303</IssueLabelID>
    <Title>Silos cannot ping another silo successfully</Title>
    <Description>I use dotnet core Orleans 2.2.0 (with zookeeper docker containers as the membership provider) there are 3 silos (A B C) in docker containers hosted in 3 azure vms under same azure vnet (and subnet).
I can always find response timeout error even there is no much request load and when it occurs there will be also silo ping timeout. 
More strange thing is even after load decreased to 0 (No any grain method is called) the 2 silos still keep timeout for pinging each other.
The consistent situation is siloA and siloB cannot ping each other but siloC can ping to both A and B in same time when issue occurs. When I restarted siloA container siloA and SiloB turn to ping each other successfully. I also checked netstat seems connection are all right and no send-q recv-q blocked between A and B.
I cannot find clue for now any one can help? Thanks.

Silo Log sample:
Category:Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #1301 from S10.42.183.42:11111:284542315. Reason = Original Exc Type: System.TimeoutException Message:Response did not arrive on time in 00:02:00 for message: Request S10.42.132.31:11111:284542291*stg/15/0000000f@S0000000f-&gt;S10.42.183.42:11111:284542315*stg/15/0000000f@S0000000f #18368: . Target History is: &lt;S10.42.183.42:11111:284542315:*stg/15/0000000f:@S0000000f&gt;.</Description>
    <Title_Description>Silos cannot ping another silo successfully I use dotnet core Orleans 2.2.0 (with zookeeper docker containers as the membership provider) there are 3 silos (A B C) in docker containers hosted in 3 azure vms under same azure vnet (and subnet).
I can always find response timeout error even there is no much request load and when it occurs there will be also silo ping timeout. 
More strange thing is even after load decreased to 0 (No any grain method is called) the 2 silos still keep timeout for pinging each other.
The consistent situation is siloA and siloB cannot ping each other but siloC can ping to both A and B in same time when issue occurs. When I restarted siloA container siloA and SiloB turn to ping each other successfully. I also checked netstat seems connection are all right and no send-q recv-q blocked between A and B.
I cannot find clue for now any one can help? Thanks.

Silo Log sample:
Category:Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #1301 from S10.42.183.42:11111:284542315. Reason = Original Exc Type: System.TimeoutException Message:Response did not arrive on time in 00:02:00 for message: Request S10.42.132.31:11111:284542291*stg/15/0000000f@S0000000f-&gt;S10.42.183.42:11111:284542315*stg/15/0000000f@S0000000f #18368: . Target History is: &lt;S10.42.183.42:11111:284542315:*stg/15/0000000f:@S0000000f&gt;.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5301</IssueLabelID>
    <Title>EventHub Streams - one grain starving another</Title>
    <Description>Hi. I have overrided EventHubDataAdapter to reads external EventHub messages.
I have two grains which are implicit subscribed to this StreamProvider.
One grain have a lot easier work and periodically make writes to Blob storage. Call it: TelemetryCapture
Second do a bit more processing - de-serialize message check some fields values and then write alert to MongoDB. Call it: TelemetryProcessor
I observed that TelemetryCapture process messages around 40k / s while TelemetryProcessor around 1k / s.
I did this testing one single silo cluster.
Machine is around 85% of CPU.
When i launch this grains separately - TelemetryCapture gests 40k /s TelemetryProcessor  around 20k/s. 
Two questions:
- Why performance of TelemetryProcessor is decreased while TelemetryCapture not?
- After a while i see errors on TelemetryProcessor  that "Item not found in cache". That suggest that Orleans remove messages from internal cache before grain start to read it. I thought that throttling mechanism is for that and should prevent such situation. 

Settings of Eviction:
```
  .Configure&lt;StreamCacheEvictionOptions&gt;(ob =&gt; ob.Configure(options =&gt;
                    {
                        options.DataMaxAgeInCache = TimeSpan.FromMinutes(5);
                        options.DataMinTimeInCache = TimeSpan.FromMinutes(2);
                    }))
```
Can you guide me here? 

@sergeybykov @jason-bragg ? :)</Description>
    <Title_Description>EventHub Streams - one grain starving another Hi. I have overrided EventHubDataAdapter to reads external EventHub messages.
I have two grains which are implicit subscribed to this StreamProvider.
One grain have a lot easier work and periodically make writes to Blob storage. Call it: TelemetryCapture
Second do a bit more processing - de-serialize message check some fields values and then write alert to MongoDB. Call it: TelemetryProcessor
I observed that TelemetryCapture process messages around 40k / s while TelemetryProcessor around 1k / s.
I did this testing one single silo cluster.
Machine is around 85% of CPU.
When i launch this grains separately - TelemetryCapture gests 40k /s TelemetryProcessor  around 20k/s. 
Two questions:
- Why performance of TelemetryProcessor is decreased while TelemetryCapture not?
- After a while i see errors on TelemetryProcessor  that "Item not found in cache". That suggest that Orleans remove messages from internal cache before grain start to read it. I thought that throttling mechanism is for that and should prevent such situation. 

Settings of Eviction:
```
  .Configure&lt;StreamCacheEvictionOptions&gt;(ob =&gt; ob.Configure(options =&gt;
                    {
                        options.DataMaxAgeInCache = TimeSpan.FromMinutes(5);
                        options.DataMinTimeInCache = TimeSpan.FromMinutes(2);
                    }))
```
Can you guide me here? 

@sergeybykov @jason-bragg ? :)</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5300</IssueLabelID>
    <Title>Codegen fails for ValueTask&lt;T&gt; with Build but not MSBuild</Title>
    <Description>When trying to build a project containing a grain interface whose method returns a `ValueTask&lt;T&gt;` the code generation fails with the following error when using `Microsoft.Orleans.CodeGenerator.Build 2.2.0`:
```
Error	MSB3073	The command ""dotnet" "C:\Users\Mehmet\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.2.0\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netcoreapp2.2\codegen\NetCoreWithBuild.orleans.g.args.txt"" exited with code 3.	NetCoreWithBuild	C:\Users\Mehmet\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.2.0\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets	82	
```
This behavior happens whether the project targets .NET Core 2.2 or .NET Standard 2.0. (one of the lines changes to `@obj\Debug\netstandard2.0 ...` as expected)

This behavior does not happen if `Microsoft.Orleans.CodeGenerator.MSBuild 2.2.0` is used instead.

Repository below reproduces these results with both `..Build` and `..MSBuild` for both targets:
https://github.com/mehmetakbulut/OrleansValueTaskRepro

Documentation and release notes (as far as I have seen?) does not appear to suggest that the code generation package should determine whether `ValueTask&lt;T&gt;` is a valid return type therefore I'm assuming this is a bug.</Description>
    <Title_Description>Codegen fails for ValueTask&lt;T&gt; with Build but not MSBuild When trying to build a project containing a grain interface whose method returns a `ValueTask&lt;T&gt;` the code generation fails with the following error when using `Microsoft.Orleans.CodeGenerator.Build 2.2.0`:
```
Error	MSB3073	The command ""dotnet" "C:\Users\Mehmet\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.2.0\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netcoreapp2.2\codegen\NetCoreWithBuild.orleans.g.args.txt"" exited with code 3.	NetCoreWithBuild	C:\Users\Mehmet\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.2.0\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets	82	
```
This behavior happens whether the project targets .NET Core 2.2 or .NET Standard 2.0. (one of the lines changes to `@obj\Debug\netstandard2.0 ...` as expected)

This behavior does not happen if `Microsoft.Orleans.CodeGenerator.MSBuild 2.2.0` is used instead.

Repository below reproduces these results with both `..Build` and `..MSBuild` for both targets:
https://github.com/mehmetakbulut/OrleansValueTaskRepro

Documentation and release notes (as far as I have seen?) does not appear to suggest that the code generation package should determine whether `ValueTask&lt;T&gt;` is a valid return type therefore I'm assuming this is a bug.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5299</IssueLabelID>
    <Title>Grain Persistence and GrainCancellationTokenSource</Title>
    <Description>Hi I am creating grain persistence for a master grain that manages the work of other worker grains. I am utilizing GrainCancellationTokenSource so the master grain can cancel all of the worker grains however when I try to use Grain Persistence for the GrainCancellationTokenSource I get an error saying that GrainCancellationTokenSource cannot be deep copied. Do you guys have any recommendations around this error or have any recommendations for managing cancellation of worker grains? Thanks.</Description>
    <Title_Description>Grain Persistence and GrainCancellationTokenSource Hi I am creating grain persistence for a master grain that manages the work of other worker grains. I am utilizing GrainCancellationTokenSource so the master grain can cancel all of the worker grains however when I try to use Grain Persistence for the GrainCancellationTokenSource I get an error saying that GrainCancellationTokenSource cannot be deep copied. Do you guys have any recommendations around this error or have any recommendations for managing cancellation of worker grains? Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5298</IssueLabelID>
    <Title>Support customizable type name formatting</Title>
    <Description>Currently Orleans allows users to customize Type resolution (conversion from some `string` to `Type`) but does not support customization of Type formatting (`Type` -&gt; `string`).

There are occasionally issues with how Orleans formats type names but requirements for backwards compatibility restricts what changes we can make. For example we have seen some issues with nested generics in static types (which is common in F# because of how it expresses modules as CLR types) #4012. Also see #5292 where an F# type is unable to be recovered after serialization.

Type name serialization also plays a significant part in the version-tolerance story since users often like to rename/move types (#2653)

Allowing for customization of type formatting may provide a nice escape hatch for users who experience such problems as well as providing a path for offering more robust defaults in the future (for example by using `RuntimeTypeNameFormatter` instead of our current `OrleansTypeName` impl)</Description>
    <Title_Description>Support customizable type name formatting Currently Orleans allows users to customize Type resolution (conversion from some `string` to `Type`) but does not support customization of Type formatting (`Type` -&gt; `string`).

There are occasionally issues with how Orleans formats type names but requirements for backwards compatibility restricts what changes we can make. For example we have seen some issues with nested generics in static types (which is common in F# because of how it expresses modules as CLR types) #4012. Also see #5292 where an F# type is unable to be recovered after serialization.

Type name serialization also plays a significant part in the version-tolerance story since users often like to rename/move types (#2653)

Allowing for customization of type formatting may provide a nice escape hatch for users who experience such problems as well as providing a path for offering more robust defaults in the future (for example by using `RuntimeTypeNameFormatter` instead of our current `OrleansTypeName` impl)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5297</IssueLabelID>
    <Title>[Question] Orleans transaction deadlocks</Title>
    <Description>I was looking at the Orleans transaction code (as I was trying to implement my own transactions for JournaledGrains) and I noticed some code that will produce deadlocks. I may be wrong but I would like to raise this question anyway (It will help me avoid or resolve deadlocks in my own implementation).

I noticed that [ReaderWriterLock](https://github.com/dotnet/orleans/blob/master/src/Orleans.Transactions/State/ReaderWriterLock.cs) is local to each [TransactionQueue](https://github.com/dotnet/orleans/blob/master/src/Orleans.Transactions/State/TransactionQueue.cs) and a TransactionQueue is instantiated for every TransactionalState.

There is a LockGroup currentGroup in ReaderWriterLock that is a linked list and when a new transaction requires a lock a new group is appended to the back of the linked list. This means that locks are queued in the order they have arrived in right? Doesn't that mean that it is possible that deadlocks can occur?

If there are 2 transactions T1 and T2 both affecting entities E1 and E2 E1 may have its lock group linked list as T1 T2 and E2 may have its lock group as T2 T1.

I would think that the lock groups are ordered by their `priority`.</Description>
    <Title_Description>[Question] Orleans transaction deadlocks I was looking at the Orleans transaction code (as I was trying to implement my own transactions for JournaledGrains) and I noticed some code that will produce deadlocks. I may be wrong but I would like to raise this question anyway (It will help me avoid or resolve deadlocks in my own implementation).

I noticed that [ReaderWriterLock](https://github.com/dotnet/orleans/blob/master/src/Orleans.Transactions/State/ReaderWriterLock.cs) is local to each [TransactionQueue](https://github.com/dotnet/orleans/blob/master/src/Orleans.Transactions/State/TransactionQueue.cs) and a TransactionQueue is instantiated for every TransactionalState.

There is a LockGroup currentGroup in ReaderWriterLock that is a linked list and when a new transaction requires a lock a new group is appended to the back of the linked list. This means that locks are queued in the order they have arrived in right? Doesn't that mean that it is possible that deadlocks can occur?

If there are 2 transactions T1 and T2 both affecting entities E1 and E2 E1 may have its lock group linked list as T1 T2 and E2 may have its lock group as T2 T1.

I would think that the lock groups are ordered by their `priority`.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5296</IssueLabelID>
    <Title>Use AzureClustering to make SiloGracefulShutdown_ForwardPendingRequest pass more consistently</Title>
    <Description>
    </Description>
    <Title_Description>Use AzureClustering to make SiloGracefulShutdown_ForwardPendingRequest pass more consistently </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5295</IssueLabelID>
    <Title>The switch statement contains multiple cases with label value...</Title>
    <Description>Grain interfaces with duplicate/hidden method definitions of a base interface cause invalid code to be generated.

Example:
```C#
public interface IBaseGrain : IGrainWithGuidKey
{
    Task Foo();
}

public interface IFooGrain : IBaseGrain
{
    Task Foo();
}
```

Ends up generating:

```C#
switch (methodId)
{
    case (int)0x6D596ED9:
        return "Foo";
    // ...
    case (int)0x6D596ED9:
        return "Foo";
    // ...
}
```

Normal VS setup does cause a warning on the hidden method but that doesn't break compilation. The generated code does.

I'll see if I can get around to a PR. Not sure I'll have time though. :( Likely either deduping in GrainInterfaceCommon.GenerateGrainInterfaceAndMethodSwitch *or* perhaps more properly accounting for hidden methods during ID generation in OrleansLegacyCompat.GetMethodId...</Description>
    <Title_Description>The switch statement contains multiple cases with label value... Grain interfaces with duplicate/hidden method definitions of a base interface cause invalid code to be generated.

Example:
```C#
public interface IBaseGrain : IGrainWithGuidKey
{
    Task Foo();
}

public interface IFooGrain : IBaseGrain
{
    Task Foo();
}
```

Ends up generating:

```C#
switch (methodId)
{
    case (int)0x6D596ED9:
        return "Foo";
    // ...
    case (int)0x6D596ED9:
        return "Foo";
    // ...
}
```

Normal VS setup does cause a warning on the hidden method but that doesn't break compilation. The generated code does.

I'll see if I can get around to a PR. Not sure I'll have time though. :( Likely either deduping in GrainInterfaceCommon.GenerateGrainInterfaceAndMethodSwitch *or* perhaps more properly accounting for hidden methods during ID generation in OrleansLegacyCompat.GetMethodId...</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5294</IssueLabelID>
    <Title>Release notes for 2.2.1 and some prior releases</Title>
    <Description>
    </Description>
    <Title_Description>Release notes for 2.2.1 and some prior releases </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5292</IssueLabelID>
    <Title>Gettting a System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives</Title>
    <Description>Hi there I am getting a `Gettting a System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives` when I try to work with a FSharp project.

Here is the source code: https://github.com/darting/OrleansTicTacToe

the exception details list as below:
```
System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives+-cctor@2255-2`1[[System.Tuple`2[[System.Int32][System.Int32]]]]FSharp.Core
   at Orleans.Runtime.CachedTypeResolver.ResolveType(String name) in D:\build\agent\_work\23\s\src\Orleans.Core\AssemblyLoader\CachedTypeResolver.cs:line 19
   at Orleans.Serialization.TypeSerializer.GetTypeFromName(String assemblyQualifiedTypeName Boolean throwOnError) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\TypeSerializer.cs:line 104
   at Orleans.Serialization.TypeSerializer.GetTypeFromTypeKey(TypeKey key Boolean throwOnError) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\TypeSerializer.cs:line 75
   at Orleans.Serialization.ILBasedSerializer.ReadType(ILSerializerTypeToken token IDeserializationContext context Type expectedType) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 148
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at FSharpMap`2Deserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at ModelDeserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 2115
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1322
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1201
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\Message.cs:line 407
   at Orleans.Runtime.SharedCallbackData.ResponseCallback(Message message TaskCompletionSource`1 context) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\SharedCallbackData.cs:line 56
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at WebApi.Controllers.GameController.JoinGame(String token String gameId) in C:\Users\Valor\github\valor\OrleansTicTacToe\WebApi\Controllers\GameController.cs:line 46
   at Microsoft.AspNetCore.Mvc.Internal.ActionMethodExecutor.TaskOfIActionResultExecutor.Execute(IActionResultTypeMapper mapper ObjectMethodExecutor executor Object controller Object[] arguments)
   at System.Threading.Tasks.ValueTask`1.get_Result()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeActionMethodAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeNextActionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Rethrow(ActionExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeInnerFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextExceptionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ExceptionContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextResourceFilter()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ResourceExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeFilterPipelineAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeAsync()
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
```
**version info:**
- .Net Core 2.2
- Orleans 2.2.0
- C# 7.3
- FSharp.Core 4.5.2


</Description>
    <Title_Description>Gettting a System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives Hi there I am getting a `Gettting a System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives` when I try to work with a FSharp project.

Here is the source code: https://github.com/darting/OrleansTicTacToe

the exception details list as below:
```
System.TypeAccessException: Unable to find a type named Microsoft.FSharp.Core.LanguagePrimitives+-cctor@2255-2`1[[System.Tuple`2[[System.Int32][System.Int32]]]]FSharp.Core
   at Orleans.Runtime.CachedTypeResolver.ResolveType(String name) in D:\build\agent\_work\23\s\src\Orleans.Core\AssemblyLoader\CachedTypeResolver.cs:line 19
   at Orleans.Serialization.TypeSerializer.GetTypeFromName(String assemblyQualifiedTypeName Boolean throwOnError) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\TypeSerializer.cs:line 104
   at Orleans.Serialization.TypeSerializer.GetTypeFromTypeKey(TypeKey key Boolean throwOnError) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\TypeSerializer.cs:line 75
   at Orleans.Serialization.ILBasedSerializer.ReadType(ILSerializerTypeToken token IDeserializationContext context Type expectedType) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 148
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at FSharpMap`2Deserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at ModelDeserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\ILBasedSerializer.cs:line 112
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1283
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\BuiltInTypes.cs:line 2115
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1322
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream) in D:\build\agent\_work\23\s\src\Orleans.Core\Serialization\SerializationManager.cs:line 1201
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\Message.cs:line 407
   at Orleans.Runtime.SharedCallbackData.ResponseCallback(Message message TaskCompletionSource`1 context) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\SharedCallbackData.cs:line 56
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in D:\build\agent\_work\23\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at WebApi.Controllers.GameController.JoinGame(String token String gameId) in C:\Users\Valor\github\valor\OrleansTicTacToe\WebApi\Controllers\GameController.cs:line 46
   at Microsoft.AspNetCore.Mvc.Internal.ActionMethodExecutor.TaskOfIActionResultExecutor.Execute(IActionResultTypeMapper mapper ObjectMethodExecutor executor Object controller Object[] arguments)
   at System.Threading.Tasks.ValueTask`1.get_Result()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeActionMethodAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeNextActionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Rethrow(ActionExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeInnerFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextExceptionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ExceptionContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextResourceFilter()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ResourceExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeFilterPipelineAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeAsync()
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
```
**version info:**
- .Net Core 2.2
- Orleans 2.2.0
- C# 7.3
- FSharp.Core 4.5.2


</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5291</IssueLabelID>
    <Title>Cherry-pick a couple of fixes to transactions for 2.2.1</Title>
    <Description>
    </Description>
    <Title_Description>Cherry-pick a couple of fixes to transactions for 2.2.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5288</IssueLabelID>
    <Title>SiloHostBuilder.Build() should throw if AddApplicationPart() added no app grain classes</Title>
    <Description>#4785 exposed this gap - if a grain class projects lacks the codegen NuGet package then calling `AddApplicationPart()` on the grain assembly ends up being an no-op due to missing metadata. However `SiloHostBuilder.Build()` executes fine without warning the users about likely missing grain classes. This is an easy to make mistake when learning Orleans.

The proposal is to have `SiloHostBuilder.Build()` throw if no application grain classes were added.</Description>
    <Title_Description>SiloHostBuilder.Build() should throw if AddApplicationPart() added no app grain classes #4785 exposed this gap - if a grain class projects lacks the codegen NuGet package then calling `AddApplicationPart()` on the grain assembly ends up being an no-op due to missing metadata. However `SiloHostBuilder.Build()` executes fine without warning the users about likely missing grain classes. This is an easy to make mistake when learning Orleans.

The proposal is to have `SiloHostBuilder.Build()` throw if no application grain classes were added.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5287</IssueLabelID>
    <Title>How can I get client context? </Title>
    <Description>How can I get client context: client ID client IP address(for logging) maybe message ID connect ID in grain?
Something with which I can make unique sessions and make log.
Have Orleans mechanism for that or any code example of user implementation? </Description>
    <Title_Description>How can I get client context?  How can I get client context: client ID client IP address(for logging) maybe message ID connect ID in grain?
Something with which I can make unique sessions and make log.
Have Orleans mechanism for that or any code example of user implementation? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>2/01/2019 8:21:46 PM +00:00</CreatedAt>
    <ClosedAt>2/01/2019 9:29:45 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5286</IssueLabelID>
    <Title>Grain Persistence and polling</Title>
    <Description>I'm working on a project with a design where individual Grains would make Http calls to poll on web services. My code has it so the grain would do Task.Run() to poll on the web service until it's finished. I'm trying to implement grain persistence and thinking through a scenario where a silo goes down while a grain is polling and I'm not sure how to ensure it will pick back up where it left off. 

Do you guys have a recommended way to do something like that?</Description>
    <Title_Description>Grain Persistence and polling I'm working on a project with a design where individual Grains would make Http calls to poll on web services. My code has it so the grain would do Task.Run() to poll on the web service until it's finished. I'm trying to implement grain persistence and thinking through a scenario where a silo goes down while a grain is polling and I'm not sure how to ensure it will pick back up where it left off. 

Do you guys have a recommended way to do something like that?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5282</IssueLabelID>
    <Title>More sample code????</Title>
    <Description>Can you offer more examples?Google searched and didn't have too many examples of use.Thanks!!!!</Description>
    <Title_Description>More sample code???? Can you offer more examples?Google searched and didn't have too many examples of use.Thanks!!!!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5281</IssueLabelID>
    <Title>How to invoke a grain only if active?</Title>
    <Description>Hi

I've ran into this situation many times before. 
I have grains that sometimes I need to update their state but only if they're active.

These grains are heavy to activate since they're doing SQL queries in their `OnActivateAsync()` (I use my own state management). So I'd rather avoid their activation completely if not necessary.

Some real life examples:
### Scenario 1
Main grains: Player Game Gang (gang of players).
* A Player shared a Game in Gang gang holds this share information in its state including its Views Count.
* Another Player viewed the Game it increases its Views Count and this should update all the Gangs which shared this game. Some of them might not be active. Activating the Gang is quite heavy. I'd like to avoid that.

### Scenario 2
I need to online bulk update many Players state - 100k's of them for a new business requriement or maintenance operation.
* Simplest solution would be to just invoke their grains and update. But very very heavy both on DB and everything.
* Script directly to the DB then sync only the active players (only few 1000's).
Note that I'm not afraid of race-conditions in this case but this is for another discussion because sometimes I do afraid then I need some kind of lock mechanism when updating.


I well aware I can have other grains or any other app mechanism to keep track of which grain is alive i.e. by using timers as @ashkan-saeedi-mazdeh suggested in gitter. I can also keep in the storage a flag if the grain is active. But then I'll have to keep timers actually even reminders for every grain to make it robust enough.
This is very heavy stuff and cumbersome to write and maintain.

I know I can also check it via `ManagementGrain` but it's a singleton grain and it would be a bottleneck to use it in frequent cases.

Note about scenario 1 - I've also thought about using Streams (classic pub/sub solution) but I don't want to keep a stream per each Game and unfortunately in my experience streams are just not reliable enough (a matter for yet another discussion).
About scenario 2 - streams could have been a good fit. In addition in this rare case it could be ok to use the ManagementGrain.

---
So I wish the Orleans framework could expose a built-in mechanism for this purpose.
I'm not sure about the internals. But when you are using the `GrainFactory` to Get a grain it probably checks against the directory if it's active and if not then it should activate it.. ? so in this process can we expose just the first part? wether it's already active?

Many thanks if you read this far :)</Description>
    <Title_Description>How to invoke a grain only if active? Hi

I've ran into this situation many times before. 
I have grains that sometimes I need to update their state but only if they're active.

These grains are heavy to activate since they're doing SQL queries in their `OnActivateAsync()` (I use my own state management). So I'd rather avoid their activation completely if not necessary.

Some real life examples:
### Scenario 1
Main grains: Player Game Gang (gang of players).
* A Player shared a Game in Gang gang holds this share information in its state including its Views Count.
* Another Player viewed the Game it increases its Views Count and this should update all the Gangs which shared this game. Some of them might not be active. Activating the Gang is quite heavy. I'd like to avoid that.

### Scenario 2
I need to online bulk update many Players state - 100k's of them for a new business requriement or maintenance operation.
* Simplest solution would be to just invoke their grains and update. But very very heavy both on DB and everything.
* Script directly to the DB then sync only the active players (only few 1000's).
Note that I'm not afraid of race-conditions in this case but this is for another discussion because sometimes I do afraid then I need some kind of lock mechanism when updating.


I well aware I can have other grains or any other app mechanism to keep track of which grain is alive i.e. by using timers as @ashkan-saeedi-mazdeh suggested in gitter. I can also keep in the storage a flag if the grain is active. But then I'll have to keep timers actually even reminders for every grain to make it robust enough.
This is very heavy stuff and cumbersome to write and maintain.

I know I can also check it via `ManagementGrain` but it's a singleton grain and it would be a bottleneck to use it in frequent cases.

Note about scenario 1 - I've also thought about using Streams (classic pub/sub solution) but I don't want to keep a stream per each Game and unfortunately in my experience streams are just not reliable enough (a matter for yet another discussion).
About scenario 2 - streams could have been a good fit. In addition in this rare case it could be ok to use the ManagementGrain.

---
So I wish the Orleans framework could expose a built-in mechanism for this purpose.
I'm not sure about the internals. But when you are using the `GrainFactory` to Get a grain it probably checks against the directory if it's active and if not then it should activate it.. ? so in this process can we expose just the first part? wether it's already active?

Many thanks if you read this far :)</Title_Description>
    <Label>enhancement</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5278</IssueLabelID>
    <Title>ArgumentNullException thrown when stopping the TestSilo</Title>
    <Description>This is similar to #4965 although that issue has been fixed with PR #5072 I am still getting this error on the latest release version (2.2.0) of `Microsoft.Orleans.TestingHost`.

I encountered this when running unit tests for Orleans Grains on Azure DevOps. My tests _intermittedly_ fail on _linux_ and it appears that this was the cause:


```
2018-12-26T00:50:30.8425892Z &#x1B;[40m&#x1B;[32minfo&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Threading.ThreadPoolThread[100328]
2018-12-26T00:50:30.8426773Z       Stopping Thread Runtime.Messaging.SiloMessageSender/PingSender0 on managed thread 19
2018-12-26T00:50:30.8427348Z &#x1B;[41m&#x1B;[30mfail&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.IncomingMessageAgent/Ping[100026]
2018-12-26T00:50:30.8427657Z       Asynch agent Runtime.Messaging.IncomingMessageAgent/Ping encountered unexpected exception The Stage will be restarted.
2018-12-26T00:50:30.8427926Z System.ArgumentNullException: Value cannot be null.
2018-12-26T00:50:30.8428135Z    at System.Threading.Monitor.Exit(Object obj)
2018-12-26T00:50:30.8428384Z    at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
2018-12-26T00:50:30.8428706Z    at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
2018-12-26T00:50:30.8429034Z    at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
2018-12-26T00:50:30.8429324Z    at System.Collections.Concurrent.BlockingCollection`1.Take(CancellationToken cancellationToken)
2018-12-26T00:50:30.8429740Z    at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type CancellationToken cancellationToken)
2018-12-26T00:50:30.8429938Z    at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
2018-12-26T00:50:30.8430969Z    at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
2018-12-26T00:50:30.8431638Z    at Orleans.Threading.FiltersApplicant`1.Apply(T action)
2018-12-26T00:50:30.8433164Z &#x1B;[40m&#x1B;[32minfo&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Threading.ThreadPoolThread[100328]
2018-12-26T00:50:30.8440723Z       Stopping Thread Runtime.Messaging.IncomingMessageAgent/Ping0 on managed thread 22 
```
(☝️  snippet of logs from my [Azure DevOps build](https://dev.azure.com/radiumz/Zezo/_build/results?buildId=50) I added retry logic for the Silo shutdown so the build did not fail but you can see the Orleans exception in the logs for the last `DotNetCoreCLI` task for job "linux". This exception seems like to be caused by a race condition as it was intermittent and goes away after retrying).

It was only encountered on Linux so far; &lt;del&gt;has not been reproduced on macOS and Windows so far.&lt;/del&gt; actually the exception is seen in macOS/Windows logs as well.

&gt; [Here](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs) is the code I used to [start](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs#L33-L46) and [stop](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs#L53-L60) the TestSilo.</Description>
    <Title_Description>ArgumentNullException thrown when stopping the TestSilo This is similar to #4965 although that issue has been fixed with PR #5072 I am still getting this error on the latest release version (2.2.0) of `Microsoft.Orleans.TestingHost`.

I encountered this when running unit tests for Orleans Grains on Azure DevOps. My tests _intermittedly_ fail on _linux_ and it appears that this was the cause:


```
2018-12-26T00:50:30.8425892Z &#x1B;[40m&#x1B;[32minfo&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Threading.ThreadPoolThread[100328]
2018-12-26T00:50:30.8426773Z       Stopping Thread Runtime.Messaging.SiloMessageSender/PingSender0 on managed thread 19
2018-12-26T00:50:30.8427348Z &#x1B;[41m&#x1B;[30mfail&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.IncomingMessageAgent/Ping[100026]
2018-12-26T00:50:30.8427657Z       Asynch agent Runtime.Messaging.IncomingMessageAgent/Ping encountered unexpected exception The Stage will be restarted.
2018-12-26T00:50:30.8427926Z System.ArgumentNullException: Value cannot be null.
2018-12-26T00:50:30.8428135Z    at System.Threading.Monitor.Exit(Object obj)
2018-12-26T00:50:30.8428384Z    at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
2018-12-26T00:50:30.8428706Z    at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
2018-12-26T00:50:30.8429034Z    at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
2018-12-26T00:50:30.8429324Z    at System.Collections.Concurrent.BlockingCollection`1.Take(CancellationToken cancellationToken)
2018-12-26T00:50:30.8429740Z    at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type CancellationToken cancellationToken)
2018-12-26T00:50:30.8429938Z    at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
2018-12-26T00:50:30.8430969Z    at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
2018-12-26T00:50:30.8431638Z    at Orleans.Threading.FiltersApplicant`1.Apply(T action)
2018-12-26T00:50:30.8433164Z &#x1B;[40m&#x1B;[32minfo&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Threading.ThreadPoolThread[100328]
2018-12-26T00:50:30.8440723Z       Stopping Thread Runtime.Messaging.IncomingMessageAgent/Ping0 on managed thread 22 
```
(☝️  snippet of logs from my [Azure DevOps build](https://dev.azure.com/radiumz/Zezo/_build/results?buildId=50) I added retry logic for the Silo shutdown so the build did not fail but you can see the Orleans exception in the logs for the last `DotNetCoreCLI` task for job "linux". This exception seems like to be caused by a race condition as it was intermittent and goes away after retrying).

It was only encountered on Linux so far; &lt;del&gt;has not been reproduced on macOS and Windows so far.&lt;/del&gt; actually the exception is seen in macOS/Windows logs as well.

&gt; [Here](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs) is the code I used to [start](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs#L33-L46) and [stop](https://github.com/ztl8702/CrowdSource/blob/c603fef5cf9966ff746a3aa4920f559ed89db6da/test/Zezo.Core.Grains.Tests/BaseGrainTest.cs#L53-L60) the TestSilo.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5277</IssueLabelID>
    <Title>Docs clarification: Reentrancy</Title>
    <Description>I have the following questions when looking at the 2.0 Docs on the topic of [Reentrancy](https://github.com/dotnet/orleans/blob/cfdd759d798f1f6b49d037cceda159beb4f37b10/src/Documentation/grains/reentrancy.md):

1. When an interface method is attributed `[AlwaysInterleave]` is it allowed to _be interleaved_ by other methods calls (meaning its execution is "interrupted" by execution of other methods) or can it _interleave into_ any other method calls (meaning that it will cause "interruption" in the execution of other methods). The example in the doc only contains examples of "`GoFast` only" and "`GoSlow` only" but not one with "`GoFast` and `GoSlow` mixed". For example in the following case:
   ```csharp
   await Task.WhenAll(slowpoke.GoSlow() slowpoke.GoFast());
   ```

   is `GoFast()`'s execution started before `GoSlow()` ends?

   what about:
   ```csharp
   await Task.WhenAll(slowpoke.GoFast() slowpoke.GoSlow());
   ```
   is `GoSlow()`'s execution started before `GoFast()` ends?

   (And also to clarify such interleaving behavior can only happen if there is asynchronous work in the currently-executing method basically when the Grain's code is awaiting something else right? I might be misusing the word "interrupt" as there is no pausing/resuming of currently executing code.)

2. When using [a predicate](https://github.com/dotnet/orleans/blob/cfdd759d798f1f6b49d037cceda159beb4f37b10/src/Documentation/grains/reentrancy.md/#reentrancy-using-a-predicate) to dynamically decide whether to allow interleaving of each request the predicate only received an `InvokeMethodRequest` argument which contains `InterfaceId` and `MethodId` as `int`s (I believe these are Orleans' internal data structures?). How do I determine which method on the Grain's interface is being invoked by this request? The example only demonstrates checking attributes on the request argument types. But if I cannot decide which interface method is being invoked what is the point of checking the arguments? And what about argumentless interface methods?

Those aren't very clear to me as I learn to use Orleans. So could anyone from the team please clarify these and possibly add to the docs? Thanks!</Description>
    <Title_Description>Docs clarification: Reentrancy I have the following questions when looking at the 2.0 Docs on the topic of [Reentrancy](https://github.com/dotnet/orleans/blob/cfdd759d798f1f6b49d037cceda159beb4f37b10/src/Documentation/grains/reentrancy.md):

1. When an interface method is attributed `[AlwaysInterleave]` is it allowed to _be interleaved_ by other methods calls (meaning its execution is "interrupted" by execution of other methods) or can it _interleave into_ any other method calls (meaning that it will cause "interruption" in the execution of other methods). The example in the doc only contains examples of "`GoFast` only" and "`GoSlow` only" but not one with "`GoFast` and `GoSlow` mixed". For example in the following case:
   ```csharp
   await Task.WhenAll(slowpoke.GoSlow() slowpoke.GoFast());
   ```

   is `GoFast()`'s execution started before `GoSlow()` ends?

   what about:
   ```csharp
   await Task.WhenAll(slowpoke.GoFast() slowpoke.GoSlow());
   ```
   is `GoSlow()`'s execution started before `GoFast()` ends?

   (And also to clarify such interleaving behavior can only happen if there is asynchronous work in the currently-executing method basically when the Grain's code is awaiting something else right? I might be misusing the word "interrupt" as there is no pausing/resuming of currently executing code.)

2. When using [a predicate](https://github.com/dotnet/orleans/blob/cfdd759d798f1f6b49d037cceda159beb4f37b10/src/Documentation/grains/reentrancy.md/#reentrancy-using-a-predicate) to dynamically decide whether to allow interleaving of each request the predicate only received an `InvokeMethodRequest` argument which contains `InterfaceId` and `MethodId` as `int`s (I believe these are Orleans' internal data structures?). How do I determine which method on the Grain's interface is being invoked by this request? The example only demonstrates checking attributes on the request argument types. But if I cannot decide which interface method is being invoked what is the point of checking the arguments? And what about argumentless interface methods?

Those aren't very clear to me as I learn to use Orleans. So could anyone from the team please clarify these and possibly add to the docs? Thanks!</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>25/12/2018 5:54:59 PM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 10:37:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5276</IssueLabelID>
    <Title>Sort out LocalGrainDirectory shutdown sequence</Title>
    <Description>- move LocalGrainDirectory stop to `silo.OnBecomeActiveStop` after `MembershipOracle.shutdown` instead being trigged by MembershipOracleShutdown -&gt; Sent notification to its SiloStatatusListeners about its shuttingdown -&gt; LocalGrainDirectory.Stop(). and not awaiting the call. 

- sort out its shutdown sequence to be : 

1. exclude itself from GrainDirectoryPartition calculation since it is shutting down and cannot serve as as GrainDirectoryPartition anymore
2. Stop Mantainers
3. GrainPartition handoff and we are awaiting this call 
4. Clear local activation cache
5. MarkStopPreparationCompleted

</Description>
    <Title_Description>Sort out LocalGrainDirectory shutdown sequence - move LocalGrainDirectory stop to `silo.OnBecomeActiveStop` after `MembershipOracle.shutdown` instead being trigged by MembershipOracleShutdown -&gt; Sent notification to its SiloStatatusListeners about its shuttingdown -&gt; LocalGrainDirectory.Stop(). and not awaiting the call. 

- sort out its shutdown sequence to be : 

1. exclude itself from GrainDirectoryPartition calculation since it is shutting down and cannot serve as as GrainDirectoryPartition anymore
2. Stop Mantainers
3. GrainPartition handoff and we are awaiting this call 
4. Clear local activation cache
5. MarkStopPreparationCompleted

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5275</IssueLabelID>
    <Title>Null reference in CallGrainActivate</Title>
    <Description>Hi! I have really strange error and behavior. 
I'v created GranService which use EventProcessorHost and register appropriate EventHubProcessor.
EventHubProcessor get reference to OtherGrain and call on it method Process with grainId extracted from message. OtherGrain has state. There is a lot a different graindIds (around 10k). After running Silo on server im getting following error:

```
Exc level 0: System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.GetCollection(String grainType)
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass16_0.&lt;&lt;ReadStateAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass20_0.&lt;&lt;DoAndLog&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.DoAndLog[T](String actionName Func`1 action)
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() ---&gt; System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.GetCollection(String grainType)
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass16_0.&lt;&lt;ReadStateAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass20_0.&lt;&lt;DoAndLog&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.DoAndLog[T](String actionName Func`1 action)
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()
   --- End of inner exception stack trace ---
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action)
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
   at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData)
```
- This error happen only on server i can't reproduce it on my dev machine and i see a correct documents in MongoDB
- This error happen also on AzureStorage provider:

```
Object reference not set to an instance of an object.
at Orleans.Storage.AzureBlobGrainStorage.ReadStateAsync(String grainType GrainReference grainId IGrainState grainState)
at Orleans.Core.StateStorageBridge1.ReadStateAsync() ---&gt; System.NullReferenceException: Object reference not set to an instance of an object. at Orleans.Storage.AzureBlobGrainStorage.ReadStateAsync(String grainType GrainReference grainId IGrainState grainState) at Orleans.Core.StateStorageBridge1.ReadStateAsync()
--- End of inner exception stack trace ---
at Orleans.Core.StateStorageBridge1.ReadStateAsync() at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func2 action)
at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
--- End of inner exception stack trace ---
at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData)
```</Description>
    <Title_Description>Null reference in CallGrainActivate Hi! I have really strange error and behavior. 
I'v created GranService which use EventProcessorHost and register appropriate EventHubProcessor.
EventHubProcessor get reference to OtherGrain and call on it method Process with grainId extracted from message. OtherGrain has state. There is a lot a different graindIds (around 10k). After running Silo on server im getting following error:

```
Exc level 0: System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.GetCollection(String grainType)
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass16_0.&lt;&lt;ReadStateAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass20_0.&lt;&lt;DoAndLog&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.DoAndLog[T](String actionName Func`1 action)
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() ---&gt; System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.GetCollection(String grainType)
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass16_0.&lt;&lt;ReadStateAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.&lt;&gt;c__DisplayClass20_0.&lt;&lt;DoAndLog&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Providers.MongoDB.StorageProviders.MongoGrainStorage.DoAndLog[T](String actionName Func`1 action)
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()
   --- End of inner exception stack trace ---
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action)
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
   --- End of inner exception stack trace ---
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
   at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData)
```
- This error happen only on server i can't reproduce it on my dev machine and i see a correct documents in MongoDB
- This error happen also on AzureStorage provider:

```
Object reference not set to an instance of an object.
at Orleans.Storage.AzureBlobGrainStorage.ReadStateAsync(String grainType GrainReference grainId IGrainState grainState)
at Orleans.Core.StateStorageBridge1.ReadStateAsync() ---&gt; System.NullReferenceException: Object reference not set to an instance of an object. at Orleans.Storage.AzureBlobGrainStorage.ReadStateAsync(String grainType GrainReference grainId IGrainState grainState) at Orleans.Core.StateStorageBridge1.ReadStateAsync()
--- End of inner exception stack trace ---
at Orleans.Core.StateStorageBridge1.ReadStateAsync() at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func2 action)
at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
--- End of inner exception stack trace ---
at Orleans.LifecycleSubject.OnStart(CancellationToken ct)
at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData)
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5271</IssueLabelID>
    <Title>Increase default build version to 2.3.0</Title>
    <Description>
    </Description>
    <Title_Description>Increase default build version to 2.3.0 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5265</IssueLabelID>
    <Title>Compilation error `error CS0579: Duplicate GeneratedCodeAttribute attribute` when used with webapi project</Title>
    <Description>I have a webapi project created using `dotnet new webapi` which calls Orleans client and silo. The Orleans client and silo projects were working fine initially as a console application. But after inclusion of webapi project I am getting a compilation error `error CS0579: Duplicate 'global::System.CodeDom.Compiler.GeneratedCodeAttribute' attribute`. The project and the associated bin-log can be found [here](https://drive.google.com/drive/folders/1k8pXqQ7l4VpaxWX7CW2_EtQC_YPtasSv?usp=sharing)</Description>
    <Title_Description>Compilation error `error CS0579: Duplicate GeneratedCodeAttribute attribute` when used with webapi project I have a webapi project created using `dotnet new webapi` which calls Orleans client and silo. The Orleans client and silo projects were working fine initially as a console application. But after inclusion of webapi project I am getting a compilation error `error CS0579: Duplicate 'global::System.CodeDom.Compiler.GeneratedCodeAttribute' attribute`. The project and the associated bin-log can be found [here](https://drive.google.com/drive/folders/1k8pXqQ7l4VpaxWX7CW2_EtQC_YPtasSv?usp=sharing)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5262</IssueLabelID>
    <Title>Question - Architecture - Processing a file</Title>
    <Description>I am working presently on parsing a zip file.  In that file has about 1000 +/- files that I need to seek 4 of them out and do some backend work to extract information about the contents of the file (and maybe need to extract a subsequent 4-5 files thereafter... undecided yet).

My current implementation is doing this via my web portal and although it works it does not seem ideal long-term.

What I think I want to do is to basically:
1. Create a worker node for this parsing
2. Teach the upload API to accept the file drop it to Azure storage then create an item in a queue and/or publish it via an Orleans stream
3. Have a subscriber on the Orleans stream and/or queue pick it up and do the work on the back-end reporting back to the user that uploaded the file what the status is.

Think of doing an operation within the Azure portal today.

Are there any best practices available from the team as to how to properly do this within Orleans and/or has anyone done anything like this within Orleans?  If so what were the gotchas etc????</Description>
    <Title_Description>Question - Architecture - Processing a file I am working presently on parsing a zip file.  In that file has about 1000 +/- files that I need to seek 4 of them out and do some backend work to extract information about the contents of the file (and maybe need to extract a subsequent 4-5 files thereafter... undecided yet).

My current implementation is doing this via my web portal and although it works it does not seem ideal long-term.

What I think I want to do is to basically:
1. Create a worker node for this parsing
2. Teach the upload API to accept the file drop it to Azure storage then create an item in a queue and/or publish it via an Orleans stream
3. Have a subscriber on the Orleans stream and/or queue pick it up and do the work on the back-end reporting back to the user that uploaded the file what the status is.

Think of doing an operation within the Azure portal today.

Are there any best practices available from the team as to how to properly do this within Orleans and/or has anyone done anything like this within Orleans?  If so what were the gotchas etc????</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5261</IssueLabelID>
    <Title>Microsoft.Extensions.Hosting support</Title>
    <Description>This PR adds [Microsoft.Extensions.Hosting](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1) support for Orleans (aka _Generic Host_).

This PR is being worked out aligned with @ReubenBond and the strategy described [here](https://github.com/dotnet/orleans/issues/4702#issuecomment-446684609).

Fixes #4702</Description>
    <Title_Description>Microsoft.Extensions.Hosting support This PR adds [Microsoft.Extensions.Hosting](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1) support for Orleans (aka _Generic Host_).

This PR is being worked out aligned with @ReubenBond and the strategy described [here](https://github.com/dotnet/orleans/issues/4702#issuecomment-446684609).

Fixes #4702</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5260</IssueLabelID>
    <Title>What interface does Orleans have to get all Grain?</Title>
    <Description>What interface does Orleans have to get all Grain? </Description>
    <Title_Description>What interface does Orleans have to get all Grain? What interface does Orleans have to get all Grain? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5259</IssueLabelID>
    <Title>P2P network?</Title>
    <Description>I noticed in the adventure example that the host was also the client. This has me wondering: what is stopping you from axing the middle man altogether and making the client the host too? I.e. a P2P network?</Description>
    <Title_Description>P2P network? I noticed in the adventure example that the host was also the client. This has me wondering: what is stopping you from axing the middle man altogether and making the client the host too? I.e. a P2P network?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>14/12/2018 3:36:34 AM +00:00</CreatedAt>
    <ClosedAt>4/01/2019 10:32:31 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5256</IssueLabelID>
    <Title>Is there any way to get the type of the grain reference which passed in the method parameters?</Title>
    <Description>Is there any way to get the type of the grain reference which passed in the method parameters?
Like below:

Caller interfaces:
```cs
    public interface IClients : IGrainWithStringKey { }

    public interface IGroup : IClients { }

    public interface IUser : IClients { }
```

Caller implemetation:
```cs
    public abstract class Clients : Grain IClients
    {
        // Here "this" is passed in the parameter.
        // This method can be called by dedrived grain classes
        // like UserGrain GroupGrain.
        protected Task AddAsync(string connectionId)
        {
            return GrainFactory.GetGrain&lt;IClient&gt;(connectionId).OnAddAsync(this);
        }
    }

    public class Group : Clients IGroup { }

    public class User : Clients IUser { }
```

Receiver:
```cs
    public interface IClient : IGrainWithStringKey
    {
        Task OnAddAsync(IClients clients);
    }

    public class Client : Grain IClient
    {
        public async Task OnAddAsync(IClients clients)
        {
            // // here it is how to get its grain interface type?
            switch (clients)
            {
                case IGroup group:
                    // Do sth
                    break;
                case IUser user:
                    // Do sth
                    break;
            }
            await Task.CompletedTask;
        }
    }
```</Description>
    <Title_Description>Is there any way to get the type of the grain reference, which passed in the method parameters? Is there any way to get the type of the grain reference which passed in the method parameters?
Like below:

Caller interfaces:
```cs
    public interface IClients : IGrainWithStringKey { }

    public interface IGroup : IClients { }

    public interface IUser : IClients { }
```

Caller implemetation:
```cs
    public abstract class Clients : Grain IClients
    {
        // Here "this" is passed in the parameter.
        // This method can be called by dedrived grain classes
        // like UserGrain GroupGrain.
        protected Task AddAsync(string connectionId)
        {
            return GrainFactory.GetGrain&lt;IClient&gt;(connectionId).OnAddAsync(this);
        }
    }

    public class Group : Clients IGroup { }

    public class User : Clients IUser { }
```

Receiver:
```cs
    public interface IClient : IGrainWithStringKey
    {
        Task OnAddAsync(IClients clients);
    }

    public class Client : Grain IClient
    {
        public async Task OnAddAsync(IClients clients)
        {
            // // here it is how to get its grain interface type?
            switch (clients)
            {
                case IGroup group:
                    // Do sth
                    break;
                case IUser user:
                    // Do sth
                    break;
            }
            await Task.CompletedTask;
        }
    }
```</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5255</IssueLabelID>
    <Title>Fix build warnings caused by new codegen in test tree </Title>
    <Description>The warning introduced in #5031 shows up in our build logs because some test state classes inherit from `Dictionary&lt;&gt;`</Description>
    <Title_Description>Fix build warnings caused by new codegen in test tree  The warning introduced in #5031 shows up in our build logs because some test state classes inherit from `Dictionary&lt;&gt;`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5254</IssueLabelID>
    <Title>Cherry-pick post 2.2.0-rc1 fixes for 2.2.0 final #3</Title>
    <Description>Add GSI cache maintenance and tests (#5184)
Revert: Fix call chain reentrancy (#5145 #5225) (#5249)</Description>
    <Title_Description>Cherry-pick post 2.2.0-rc1 fixes for 2.2.0 final #3 Add GSI cache maintenance and tests (#5184)
Revert: Fix call chain reentrancy (#5145 #5225) (#5249)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5252</IssueLabelID>
    <Title>Logger names in transactions</Title>
    <Description>Currently the logger name used throughout most of the transaction system is unique per resource. While this can be helpful when tracing transactions it also makes it more difficult for someone not very familiar with the internals to turn on debug logging for just transactions. In my case this was compounded by having logging settings that don't print the logger name.

Perhaps a compromise between what is there now and more standard logger names is to prefix the logger name with `Orleans.Transactions` to allow a simple source filter to work.</Description>
    <Title_Description>Logger names in transactions Currently the logger name used throughout most of the transaction system is unique per resource. While this can be helpful when tracing transactions it also makes it more difficult for someone not very familiar with the internals to turn on debug logging for just transactions. In my case this was compounded by having logging settings that don't print the logger name.

Perhaps a compromise between what is there now and more standard logger names is to prefix the logger name with `Orleans.Transactions` to allow a simple source filter to work.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5250</IssueLabelID>
    <Title>A transaction with only 1 write participant incorrectly assumes that the write participant is local</Title>
    <Description>Setup:
Orleans 2.2.0-rc1
Have a transaction with 2 or more participants where only 1 of them writes.
*It may or may not be necessary for the 1st participant to be read only.
Wait for `RemoteTransactionPingFrequency` (60) seconds.
Observe the transaction get reverted.

Cause:
https://github.com/dotnet/orleans/blob/fb7699a779883a1cec27775037575012b156269e/src/Orleans.Transactions/State/TransactionQueue.cs#L777
The local commit assumes that it doesn't need to notify other participants if there is only one write participant. This is definitely incorrect if the TM isn't the write participant and I believe also incorrect if it is (though arguably other code should handle that).

Possible Solution:
I'm thinking changing it to 
```c#
if (entry.WriteParticipants.Count &gt; 1 || (entry.WriteParticipants.Count &gt; 0 &amp;&amp; !entry.WriteParticipants[0].Equals(this.resource)))
```
would fix this particular problem but I have some doubts about how read only participants are handled in read + write transactions since at least on the surface it looks like they are still expecting to get the confirmations.

I'm pretty sure this is a regression from 2.1.</Description>
    <Title_Description>A transaction with only 1 write participant incorrectly assumes that the write participant is local Setup:
Orleans 2.2.0-rc1
Have a transaction with 2 or more participants where only 1 of them writes.
*It may or may not be necessary for the 1st participant to be read only.
Wait for `RemoteTransactionPingFrequency` (60) seconds.
Observe the transaction get reverted.

Cause:
https://github.com/dotnet/orleans/blob/fb7699a779883a1cec27775037575012b156269e/src/Orleans.Transactions/State/TransactionQueue.cs#L777
The local commit assumes that it doesn't need to notify other participants if there is only one write participant. This is definitely incorrect if the TM isn't the write participant and I believe also incorrect if it is (though arguably other code should handle that).

Possible Solution:
I'm thinking changing it to 
```c#
if (entry.WriteParticipants.Count &gt; 1 || (entry.WriteParticipants.Count &gt; 0 &amp;&amp; !entry.WriteParticipants[0].Equals(this.resource)))
```
would fix this particular problem but I have some doubts about how read only participants are handled in read + write transactions since at least on the surface it looks like they are still expecting to get the confirmations.

I'm pretty sure this is a regression from 2.1.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5248</IssueLabelID>
    <Title>Added 'first' and 'last' to grain lifecycle stages.</Title>
    <Description>Added first and last stages to grain lifecycle stages to align with service lifecycle stages</Description>
    <Title_Description>Added 'first' and 'last' to grain lifecycle stages. Added first and last stages to grain lifecycle stages to align with service lifecycle stages</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5247</IssueLabelID>
    <Title>RegexImplicitStreamSubscription not working</Title>
    <Description>Implicit stream subscription with RegexImplicitStreamSubscription attribute is not working:

&gt; System.Runtime.Serialization.SerializationException: 'Type 'System.Text.RegularExpressions.RegexReplacement' in Assembly 'System.Text.RegularExpressions Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.'


</Description>
    <Title_Description>RegexImplicitStreamSubscription not working Implicit stream subscription with RegexImplicitStreamSubscription attribute is not working:

&gt; System.Runtime.Serialization.SerializationException: 'Type 'System.Text.RegularExpressions.RegexReplacement' in Assembly 'System.Text.RegularExpressions Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' is not marked as serializable.'


</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5245</IssueLabelID>
    <Title>Microsoft.Orleans.OrleansCodeGenerator.Build dotnet core 2.2 support</Title>
    <Description>Hello

Today I've tried to update my Orleans project to dotnet core 2.2 and faced the following issue. Seems that Microsoft.Orleans.OrleansCodeGenerator.Build package (https://www.nuget.org/packages/Microsoft.Orleans.OrleansCodeGenerator.Build/2.2.0-rc1) supports dotnet core 2.1 https://github.com/dotnet/orleans/blob/master/src/Orleans.CodeGeneration.Build/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets and in latest RC-1 for orleans 2.2.0 there is no support for dotnet core 2.2 as well.

The error looks like this and it is expected due to the how *targets* file is implemented.
```
 Orleans-CodeGen - Generating file /home/rakkattakka/Development/reviewiteasy/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Common/obj/Debug/netcoreapp2.2/ReviewItEasy.Webhooks.Common.orleans.g.cs
  -- Code Generation FAILED -- 
  
  Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
  
     at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
     at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
     at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
     at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
     at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
     at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
     at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
     at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
     at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature)
     at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
     at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager)
     at Orleans.CodeGenerator.RoslynCodeGenerator..ctor(IApplicationPartManager partManager ILoggerFactory loggerFactory)
     at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
     at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
     at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
     at Orleans.CodeGeneration.Program.Main(String[] args)
/home/rakkattakka/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.1.2/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(825): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/home/rakkattakka/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.1.2/build/../tasks/netcoreapp2.0/Orleans.CodeGeneration.Build.dll" "@obj/Debug/netcoreapp2.2/codegen/ReviewItEasy.Webhooks.Common.orleans.g.args.txt"" exited with code 3. [/home/rakkattakka/Development/reviewiteasy/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Common/ReviewItEasy.Webhooks.Common.csproj]
```

I'm wondering whether there are plans to support netcore 2.2 with the release?

Thanks. </Description>
    <Title_Description>Microsoft.Orleans.OrleansCodeGenerator.Build dotnet core 2.2 support Hello

Today I've tried to update my Orleans project to dotnet core 2.2 and faced the following issue. Seems that Microsoft.Orleans.OrleansCodeGenerator.Build package (https://www.nuget.org/packages/Microsoft.Orleans.OrleansCodeGenerator.Build/2.2.0-rc1) supports dotnet core 2.1 https://github.com/dotnet/orleans/blob/master/src/Orleans.CodeGeneration.Build/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets and in latest RC-1 for orleans 2.2.0 there is no support for dotnet core 2.2 as well.

The error looks like this and it is expected due to the how *targets* file is implemented.
```
 Orleans-CodeGen - Generating file /home/rakkattakka/Development/reviewiteasy/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Common/obj/Debug/netcoreapp2.2/ReviewItEasy.Webhooks.Common.orleans.g.cs
  -- Code Generation FAILED -- 
  
  Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
  
     at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
     at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
     at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
     at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
     at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
     at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
     at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
     at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
     at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature)
     at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature)
     at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager)
     at Orleans.CodeGenerator.RoslynCodeGenerator..ctor(IApplicationPartManager partManager ILoggerFactory loggerFactory)
     at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
     at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
     at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
     at Orleans.CodeGeneration.Program.Main(String[] args)
/home/rakkattakka/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.1.2/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(825): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/home/rakkattakka/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.1.2/build/../tasks/netcoreapp2.0/Orleans.CodeGeneration.Build.dll" "@obj/Debug/netcoreapp2.2/codegen/ReviewItEasy.Webhooks.Common.orleans.g.args.txt"" exited with code 3. [/home/rakkattakka/Development/reviewiteasy/ReviewItEasy.Webhooks/src/ReviewItEasy.Webhooks.Common/ReviewItEasy.Webhooks.Common.csproj]
```

I'm wondering whether there are plans to support netcore 2.2 with the release?

Thanks. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5244</IssueLabelID>
    <Title>Missing global:: prefix in generated code</Title>
    <Description>I'm using `Microsoft.Orleans.CodeGenerator.MSBuild` and I got this compile error:

&gt; The type or namespace name 'Reflection' does not exist in the namespace 'MyNamespace.System' (are you missing an assembly reference?)

Looking at the generated code `MyProject.orleans.gs` I noticed the generator had created code like this:

```
global::System.Reflection.FieldInfo field0 = typeof(global::MyNamespace.MyClass).GetField("&lt;AnotherClass&gt;k__BackingField" (System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public));
```

My project has a `MyNamespace.System` namespace so `System.Reflection.BindingFlags` tries to resolve the namespace `MyNamespace.System.Reflection` namespace which of course doesn't exist.

The problem is that `System.Reflection.BindingFlags` in the generated code is missing the `global::` prefix.</Description>
    <Title_Description>Missing global:: prefix in generated code I'm using `Microsoft.Orleans.CodeGenerator.MSBuild` and I got this compile error:

&gt; The type or namespace name 'Reflection' does not exist in the namespace 'MyNamespace.System' (are you missing an assembly reference?)

Looking at the generated code `MyProject.orleans.gs` I noticed the generator had created code like this:

```
global::System.Reflection.FieldInfo field0 = typeof(global::MyNamespace.MyClass).GetField("&lt;AnotherClass&gt;k__BackingField" (System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public));
```

My project has a `MyNamespace.System` namespace so `System.Reflection.BindingFlags` tries to resolve the namespace `MyNamespace.System.Reflection` namespace which of course doesn't exist.

The problem is that `System.Reflection.BindingFlags` in the generated code is missing the `global::` prefix.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5243</IssueLabelID>
    <Title>MSBuild code generator cannot generate serializer for struct with array field</Title>
    <Description>I changed the code generator in my project to `Microsoft.Orleans.CodeGenerator.MSBuild` hoping to work around some code generation problems I had on my build server. Supposedly the new code generator is better anyway.

However it seems that it cannot generate a serializer for a value type containing an array of a "primitive" type. This is the gist of the exception that is thrown by the code generator:

&gt; System.NotSupportedException: Field MyStruct.myArray in type MyStruct is not an INamedTypeSymbol and therefore is not supported. Type is Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+SZArray

This would be my value type:

```
public readonly struct MyStruct
{
    private readonly byte[] myArray;
}
```

As far as I can tell the exception is thrown in [SerializerGenerator.IsValueTypeFieldsShallowCopyable](https://github.com/dotnet/orleans/blob/008605e3717ccd5f7396c388090e8c7a6ea1a46c/src/Orleans.CodeGenerator/Generators/SerializerGenerator.cs#L633).

The issue seems to be that the new code generator will only create a serializer if the field can be shallow copied. However an array of a type that can be shallow copied can also be shallow copied by copying the array. The old code generator didn't have this issue and I hope this can be fixed in the new code generator.</Description>
    <Title_Description>MSBuild code generator cannot generate serializer for struct with array field I changed the code generator in my project to `Microsoft.Orleans.CodeGenerator.MSBuild` hoping to work around some code generation problems I had on my build server. Supposedly the new code generator is better anyway.

However it seems that it cannot generate a serializer for a value type containing an array of a "primitive" type. This is the gist of the exception that is thrown by the code generator:

&gt; System.NotSupportedException: Field MyStruct.myArray in type MyStruct is not an INamedTypeSymbol and therefore is not supported. Type is Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+SZArray

This would be my value type:

```
public readonly struct MyStruct
{
    private readonly byte[] myArray;
}
```

As far as I can tell the exception is thrown in [SerializerGenerator.IsValueTypeFieldsShallowCopyable](https://github.com/dotnet/orleans/blob/008605e3717ccd5f7396c388090e8c7a6ea1a46c/src/Orleans.CodeGenerator/Generators/SerializerGenerator.cs#L633).

The issue seems to be that the new code generator will only create a serializer if the field can be shallow copied. However an array of a type that can be shallow copied can also be shallow copied by copying the array. The old code generator didn't have this issue and I hope this can be fixed in the new code generator.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5242</IssueLabelID>
    <Title>Cherry-pick post 2.2.0-rc1 fixes for 2.2.0 final #2</Title>
    <Description>Update ZooKeeperNetEx package to 3.4.12.1 (#5236)
Include exception in TryForwardRequest info log (#5238)
Improve logging of stream delivery errors. (#5230)
Support ProxyGatewayEndpoint from legacy configuration (#5214)</Description>
    <Title_Description>Cherry-pick post 2.2.0-rc1 fixes for 2.2.0 final #2 Update ZooKeeperNetEx package to 3.4.12.1 (#5236)
Include exception in TryForwardRequest info log (#5238)
Improve logging of stream delivery errors. (#5230)
Support ProxyGatewayEndpoint from legacy configuration (#5214)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5241</IssueLabelID>
    <Title>AzureStorageClustering does not work with Azurite</Title>
    <Description>I was trying out Azurite as the storage emulator as the version 5.8 of the official storage emulator has a huge bug (https://github.com/Azure/azure-storage-net/issues/801) where blobs cannot be written. Since I am relying on blob storage for non-orleans use I had to move away from using the emulator since I was unable to find an installer for the previous 5.7 version of the emulator (https://github.com/Azure/azure-storage-net/issues/810#issuecomment-446123225)

However my silo will not start using azurite. The OrleansSiloInstances table is created and populated with the SampleStore/VersionRow entry. The following is the output from the Azurite terminal:

![image](https://user-images.githubusercontent.com/2112306/49789609-b6ad5000-fd2c-11e8-9457-7fcd4e1811e8.png)

Storage emulator fiddler:
![image](https://user-images.githubusercontent.com/2112306/49792023-004c6980-fd32-11e8-99b8-36f9b33e9569.png)

Azurite fiddler:
![image](https://user-images.githubusercontent.com/2112306/49792051-135f3980-fd32-11e8-902a-d13031708323.png)



I know that this is not an Orleans bug but maybe we could help the Azurite guys to reproduce what is going on...?</Description>
    <Title_Description>AzureStorageClustering does not work with Azurite I was trying out Azurite as the storage emulator as the version 5.8 of the official storage emulator has a huge bug (https://github.com/Azure/azure-storage-net/issues/801) where blobs cannot be written. Since I am relying on blob storage for non-orleans use I had to move away from using the emulator since I was unable to find an installer for the previous 5.7 version of the emulator (https://github.com/Azure/azure-storage-net/issues/810#issuecomment-446123225)

However my silo will not start using azurite. The OrleansSiloInstances table is created and populated with the SampleStore/VersionRow entry. The following is the output from the Azurite terminal:

![image](https://user-images.githubusercontent.com/2112306/49789609-b6ad5000-fd2c-11e8-9457-7fcd4e1811e8.png)

Storage emulator fiddler:
![image](https://user-images.githubusercontent.com/2112306/49792023-004c6980-fd32-11e8-99b8-36f9b33e9569.png)

Azurite fiddler:
![image](https://user-images.githubusercontent.com/2112306/49792051-135f3980-fd32-11e8-902a-d13031708323.png)



I know that this is not an Orleans bug but maybe we could help the Azurite guys to reproduce what is going on...?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5240</IssueLabelID>
    <Title>2.2.0 1</Title>
    <Description>Resubmitting this PR to be merged without squashing.</Description>
    <Title_Description>2.2.0 1 Resubmitting this PR to be merged without squashing.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5239</IssueLabelID>
    <Title>Mark key legacy types/methods as [Obsolete]</Title>
    <Description>Fixes #5221

I disabled legacy type warnings for the `test` subtree maybe that's questionable. The alternative is to either:

1. Port all tests away from `[Obsolete]` types
2. Individually mark every file with the right `#pragma` incantation
3. Individually surround every usage with the right `#pragma`

I figured:

* 1 is too much work for now (especially between rc and final)
* 2 offers little benefit over the chosen approach with more cost
* 3 would make code ugly since it requires many changes which will eventually need to be undone before (presumably) 3.0.</Description>
    <Title_Description>Mark key legacy types/methods as [Obsolete] Fixes #5221

I disabled legacy type warnings for the `test` subtree maybe that's questionable. The alternative is to either:

1. Port all tests away from `[Obsolete]` types
2. Individually mark every file with the right `#pragma` incantation
3. Individually surround every usage with the right `#pragma`

I figured:

* 1 is too much work for now (especially between rc and final)
* 2 offers little benefit over the chosen approach with more cost
* 3 would make code ugly since it requires many changes which will eventually need to be undone before (presumably) 3.0.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5237</IssueLabelID>
    <Title>silo dead</Title>
    <Description>`I have been told I am dead so this silo will stop! I should he Dead accor ding to membership table (in TrylpdateMystatusGlohalOnce): myEntry=SiloAddress92.168.2.139:11112:282118722 Si loName-silotatus =Dead`
I see a lot of the same problems and I configure it very simply

&gt;  var builder = new SiloHostBuilder()
                //.UseDashboard(options =&gt;
                //{
                //    options.Username = "ABC";
                //    options.Password = "123";
                //    options.Host = "*";
                //    options.Port = 11110;
                //    options.HostSelf = true;
                //    options.CounterUpdateIntervalMs = 1000;
                //})
                .Configure&lt;SerializationProviderOptions&gt;(d =&gt; { d.SerializationProviders.Add(typeof(ProtobufSerializer).GetTypeInfo()); })
               .UseAdoNetClustering(options =&gt;
               {
                   options.Invariant = invariant;
                   options.ConnectionString = connectionString;
               })
                .UseAdoNetReminderService(options =&gt;
                {
                    options.Invariant = invariant;
                    options.ConnectionString = connectionString;
                })
                .AddAdoNetGrainStorage("ProductServerWeb" options =&gt;
                {
                    options.Invariant = invariant;
                    options.ConnectionString = connectionString;
                }).AddAdoNetGrainStorageAsDefault(opations =&gt; {
                     opations.ConnectionString = connectionString;
                 }) .ConfigureEndpoints(siloPort gatewayPort)
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "dev";
                        options.ServiceId = "AuthorizationServer";
                    })
                    .AddStartupTask((IServiceProvider services CancellationToken cancellation) =&gt;
                      {
                          var grainFactory = services.GetRequiredService&lt;IGrainFactory&gt;();
                          return Task.CompletedTask;
                      })
                     .ConfigureLogging(logging =&gt; logging.AddConsole());
            var host = builder.Build();
            await host.StartAsync();
            return host;

I started it and then I went to PLAY and after a while about 20 minutes it had a problem. I repeated the result several times during which only this warehouse was running and no calls were made

Why does it kill itself and notify it and then it dies?</Description>
    <Title_Description>silo dead `I have been told I am dead so this silo will stop! I should he Dead accor ding to membership table (in TrylpdateMystatusGlohalOnce): myEntry=SiloAddress92.168.2.139:11112:282118722 Si loName-silotatus =Dead`
I see a lot of the same problems and I configure it very simply

&gt;  var builder = new SiloHostBuilder()
                //.UseDashboard(options =&gt;
                //{
                //    options.Username = "ABC";
                //    options.Password = "123";
                //    options.Host = "*";
                //    options.Port = 11110;
                //    options.HostSelf = true;
                //    options.CounterUpdateIntervalMs = 1000;
                //})
                .Configure&lt;SerializationProviderOptions&gt;(d =&gt; { d.SerializationProviders.Add(typeof(ProtobufSerializer).GetTypeInfo()); })
               .UseAdoNetClustering(options =&gt;
               {
                   options.Invariant = invariant;
                   options.ConnectionString = connectionString;
               })
                .UseAdoNetReminderService(options =&gt;
                {
                    options.Invariant = invariant;
                    options.ConnectionString = connectionString;
                })
                .AddAdoNetGrainStorage("ProductServerWeb" options =&gt;
                {
                    options.Invariant = invariant;
                    options.ConnectionString = connectionString;
                }).AddAdoNetGrainStorageAsDefault(opations =&gt; {
                     opations.ConnectionString = connectionString;
                 }) .ConfigureEndpoints(siloPort gatewayPort)
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "dev";
                        options.ServiceId = "AuthorizationServer";
                    })
                    .AddStartupTask((IServiceProvider services CancellationToken cancellation) =&gt;
                      {
                          var grainFactory = services.GetRequiredService&lt;IGrainFactory&gt;();
                          return Task.CompletedTask;
                      })
                     .ConfigureLogging(logging =&gt; logging.AddConsole());
            var host = builder.Build();
            await host.StartAsync();
            return host;

I started it and then I went to PLAY and after a while about 20 minutes it had a problem. I repeated the result several times during which only this warehouse was running and no calls were made

Why does it kill itself and notify it and then it dies?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5234</IssueLabelID>
    <Title>Ensure OrleansProviders is added as an ApplicationPart in streams providers</Title>
    <Description>Fixes #5172 for all streams providers

Thanks for being patient @galvesribeiro :)</Description>
    <Title_Description>Ensure OrleansProviders is added as an ApplicationPart in streams providers Fixes #5172 for all streams providers

Thanks for being patient @galvesribeiro :)</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5231</IssueLabelID>
    <Title>Stream Provider Configurator work</Title>
    <Description>In 2.0 we introduced StreamConfigurator the concept the abstracions and minimum implementations. The goal is to move stream configuration from an inheritance based approach to a dependency injection based approach. That work has been started a minimum implementation is put in. but It is still far from finishing. </Description>
    <Title_Description>Stream Provider Configurator work In 2.0 we introduced StreamConfigurator the concept the abstracions and minimum implementations. The goal is to move stream configuration from an inheritance based approach to a dependency injection based approach. That work has been started a minimum implementation is put in. but It is still far from finishing. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5230</IssueLabelID>
    <Title>Improve logging of stream delivery errors.</Title>
    <Description>Attempt to address #5205</Description>
    <Title_Description>Improve logging of stream delivery errors. Attempt to address #5205</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5226</IssueLabelID>
    <Title>Receive timeout explanation / guarantees</Title>
    <Description>I understand the client and silo messaging timeouts can be configured. My questions is what kind of guarantees do I have when the timeouts occur?

I would like to cover the following scenarios:

1. When the timeout occurs I'd like the (grain) method to finish its work and not be interrupted
1. When an exception occurs I'd like it to be logged

As far as I've tested locally even when the timeout on the client occurs the method finishes correctly. I has a test case with an intentional `Task.Delay` to trigger the timeout and then submitting an item to the stream. The code was executed correctly the stream handler (using implicit subscription) handled the message. The log had a warning (I don't know how to decipher grain identities but I suspect this is from the grain code calling the stream's `OnNextAsync`:

```
warn: Orleans.Runtime.CallbackData[100157]
      Response did not arrive on time in 00:00:05 for message: NewPlacement Request S127.0.0.1:11111:281806867*grn/DCD8FF05/00000000@59d450b3-&gt;S127.0.0.1:11111:281806867*grn/CAE8EA10/00000000@3d0ee9b6 #31: . Target History is: &lt;S127.0.0.1:11111:281806867:*grn/CAE8EA10/00000000:@3d0ee9b6&gt;. About to break its promise.
```

Exception handling is trickier: when a client is connected the exceptions are sent to the client. When the timeout occurs the exceptions are swallowed. I then implemented an incoming grain call filter and that one catches the exceptions so they can be at least logged.

The questions are:

* does Orleans runtime guarantee that the grain method code will execute after the timeout?
* is implementing an incoming grain call filter the right approach for catching exceptions?

Thanks!</Description>
    <Title_Description>Receive timeout explanation / guarantees I understand the client and silo messaging timeouts can be configured. My questions is what kind of guarantees do I have when the timeouts occur?

I would like to cover the following scenarios:

1. When the timeout occurs I'd like the (grain) method to finish its work and not be interrupted
1. When an exception occurs I'd like it to be logged

As far as I've tested locally even when the timeout on the client occurs the method finishes correctly. I has a test case with an intentional `Task.Delay` to trigger the timeout and then submitting an item to the stream. The code was executed correctly the stream handler (using implicit subscription) handled the message. The log had a warning (I don't know how to decipher grain identities but I suspect this is from the grain code calling the stream's `OnNextAsync`:

```
warn: Orleans.Runtime.CallbackData[100157]
      Response did not arrive on time in 00:00:05 for message: NewPlacement Request S127.0.0.1:11111:281806867*grn/DCD8FF05/00000000@59d450b3-&gt;S127.0.0.1:11111:281806867*grn/CAE8EA10/00000000@3d0ee9b6 #31: . Target History is: &lt;S127.0.0.1:11111:281806867:*grn/CAE8EA10/00000000:@3d0ee9b6&gt;. About to break its promise.
```

Exception handling is trickier: when a client is connected the exceptions are sent to the client. When the timeout occurs the exceptions are swallowed. I then implemented an incoming grain call filter and that one catches the exceptions so they can be at least logged.

The questions are:

* does Orleans runtime guarantee that the grain method code will execute after the timeout?
* is implementing an incoming grain call filter the right approach for catching exceptions?

Thanks!</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5224</IssueLabelID>
    <Title>Timeout exception when using Simple Message Stream Provider / Implicit Subscription</Title>
    <Description>I activate 3122 grains via a [OneWay] grain (Grain A) method. This first grain (Grain A) saves state pushes an event (Event A) to stream and activates 2 more grains (Grain B and Grain C). Both Grain B and C save state and push an event to stream (Event B and Event C).

Event A and Event B are not picked up by any Grain (no subscribers). We do this to save the event that is event sourcing.

This is how we save state and push the event (Grain A B and C inherit from a base class).
```
protected async Task WriteStateAndPublishEventAsync(TEventBase @event)
        {
            IEventLogGrain eventLogGrain = null;
            bool isEventSaved = false;
            try
            {
                // 1. Save event.
                var eventGuid = Guid.NewGuid();
                eventLogGrain = base.GrainFactory.GetGrain&lt;IEventLogGrain&gt;(eventGuid);
                await eventLogGrain.SaveEventAsync(@event);
                isEventSaved = true;

                // 2. Write State.
                await base.WriteStateAsync();

                // 3. Send even on the stream.
                IAsyncStream&lt;TEventBase&gt; stream = this.StreamProvider.GetStream&lt;TEventBase&gt;(this.GetKey() @event.GetType().Name);
                IAsyncObserver&lt;TEventBase&gt; producer = stream;
                if (producer != null)
                {
                    await producer.OnNextAsync(@event);
                }
            }
            catch
            {
                // Roll-back event.
                if (eventLogGrain != null)
                {
                    if (isEventSaved)
                    {
                        await eventLogGrain.RollbackEventAsync(@event);
                    }
                }

                // Tell Orleans to deactivate grain after the current grian is completed.
                // In this way any state is removed from the memory.
                base.DeactivateOnIdle();

                throw;
            }
        }
```

Event C is picked up by 2 grains Grain D and Grain E. Grain D saves the state while Grain E makes an HTTP Call which POSTs some value. So with this logic all grains need to be activated 3122 times I should have 3122 saved states for Grain A B C and D 3122 HTTP calls from Grain E as well as 9366 entries in the event log (we save them all under one table).

This code shows how we subscribe to the stream:

```
protected override async Task BecomeConsumer()
        {
            IStreamProvider streamProvider = GetStreamProvider(StreamsConstants.AzureStreamProvider);
            IAsyncStream&lt;EventC&gt; stream = streamProvider.GetStream&lt;GrainCEvent&gt;(this.GetPrimaryKey() nameof(EventC));

            var promises = new List&lt;Task&gt;();
            promises.Add(stream.SubscribeAsync(EventCHandler));
            await Task.WhenAll(promises);
        }
```

The numbers add up except the HTTP calls. The number however is haphazard and not always the same. During this whole process I can see the following message for Grain C (the grain for which it has 2 grains subscribed to its event).

```
[17:33:52 WRN] Exception during Grain method call of message: NewPlacement OneWay S10.0.75.1:11111:281723462*cli/2fe333bd@c798b2b4-&gt;S10.0.75.1:11111:281723462*grn/2262AE79/e6f679bd@307e2ba8 #171:
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: NewPlacement Request S10.0.75.1:11111:281723462*grn/2262AE79/e6f679bd@307e2ba8-&gt;S10.0.75.1:11111:281723462*grn/2F2DBAA7/e6f679bd@582e2ab1 #16579: . Target History is: &lt;S10.0.75.1:11111:281723462:*grn/2F2DBAA7/e6f679bd:@582e2ab1&gt;.
```

I am seeing this message too:

```
[17:35:44 WRN] Response did not arrive on time in 00:00:30 for message: NewPlacement Request S10.0.75.1:11111:281723462*grn/2F2DBAA7/f586ea16@d23ea6b9-&gt;S10.0.75.1:11111:281723462*grn/CE1C7277/f586ea16@ab709c91 #61856: . Target History is: &lt;S10.0.75.1:11111:281723462:*grn/CE1C7277/f586ea16:@ab709c91&gt;. About to break its promise.
[17:35:44 INF] DeactivateActivationOnIdle: [Activation: S10.0.75.1:11111:281723462*grn/716E8E94/bf83f8d1+AzureStreamProvider_EventC@8384eab5 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[17:35:44 INF] DeactivateActivationOnIdle: [Activation: S10.0.75.1:11111:281723462*grn/2F2DBAA7/431e3197@fdd503a3 #GrainType=GrainC Placement=RandomPlacement State=Deactivating] later when become idle.
```

The rest of the message is just a stack trace from Grain C up to the invocation of the [OneWay] method of Grain A.

After this process some statistics show up in the console. Let me share some of them with you:
```
Grain.GrainA.Current=3122
Grain.GrainB.Current=3122
Grain.GrainC.Current=186
Grain.GrainD.Current=3122
Grain.GrainE.Current=2917
```

Grain C and Grain E do not make sense at all. Somehow the messages are not being picked up on time and lost completely. This behaviour only appears when we launch the application without debugging. When we debug the application everything works fine.
</Description>
    <Title_Description>Timeout exception when using Simple Message Stream Provider / Implicit Subscription I activate 3122 grains via a [OneWay] grain (Grain A) method. This first grain (Grain A) saves state pushes an event (Event A) to stream and activates 2 more grains (Grain B and Grain C). Both Grain B and C save state and push an event to stream (Event B and Event C).

Event A and Event B are not picked up by any Grain (no subscribers). We do this to save the event that is event sourcing.

This is how we save state and push the event (Grain A B and C inherit from a base class).
```
protected async Task WriteStateAndPublishEventAsync(TEventBase @event)
        {
            IEventLogGrain eventLogGrain = null;
            bool isEventSaved = false;
            try
            {
                // 1. Save event.
                var eventGuid = Guid.NewGuid();
                eventLogGrain = base.GrainFactory.GetGrain&lt;IEventLogGrain&gt;(eventGuid);
                await eventLogGrain.SaveEventAsync(@event);
                isEventSaved = true;

                // 2. Write State.
                await base.WriteStateAsync();

                // 3. Send even on the stream.
                IAsyncStream&lt;TEventBase&gt; stream = this.StreamProvider.GetStream&lt;TEventBase&gt;(this.GetKey() @event.GetType().Name);
                IAsyncObserver&lt;TEventBase&gt; producer = stream;
                if (producer != null)
                {
                    await producer.OnNextAsync(@event);
                }
            }
            catch
            {
                // Roll-back event.
                if (eventLogGrain != null)
                {
                    if (isEventSaved)
                    {
                        await eventLogGrain.RollbackEventAsync(@event);
                    }
                }

                // Tell Orleans to deactivate grain after the current grian is completed.
                // In this way any state is removed from the memory.
                base.DeactivateOnIdle();

                throw;
            }
        }
```

Event C is picked up by 2 grains Grain D and Grain E. Grain D saves the state while Grain E makes an HTTP Call which POSTs some value. So with this logic all grains need to be activated 3122 times I should have 3122 saved states for Grain A B C and D 3122 HTTP calls from Grain E as well as 9366 entries in the event log (we save them all under one table).

This code shows how we subscribe to the stream:

```
protected override async Task BecomeConsumer()
        {
            IStreamProvider streamProvider = GetStreamProvider(StreamsConstants.AzureStreamProvider);
            IAsyncStream&lt;EventC&gt; stream = streamProvider.GetStream&lt;GrainCEvent&gt;(this.GetPrimaryKey() nameof(EventC));

            var promises = new List&lt;Task&gt;();
            promises.Add(stream.SubscribeAsync(EventCHandler));
            await Task.WhenAll(promises);
        }
```

The numbers add up except the HTTP calls. The number however is haphazard and not always the same. During this whole process I can see the following message for Grain C (the grain for which it has 2 grains subscribed to its event).

```
[17:33:52 WRN] Exception during Grain method call of message: NewPlacement OneWay S10.0.75.1:11111:281723462*cli/2fe333bd@c798b2b4-&gt;S10.0.75.1:11111:281723462*grn/2262AE79/e6f679bd@307e2ba8 #171:
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: NewPlacement Request S10.0.75.1:11111:281723462*grn/2262AE79/e6f679bd@307e2ba8-&gt;S10.0.75.1:11111:281723462*grn/2F2DBAA7/e6f679bd@582e2ab1 #16579: . Target History is: &lt;S10.0.75.1:11111:281723462:*grn/2F2DBAA7/e6f679bd:@582e2ab1&gt;.
```

I am seeing this message too:

```
[17:35:44 WRN] Response did not arrive on time in 00:00:30 for message: NewPlacement Request S10.0.75.1:11111:281723462*grn/2F2DBAA7/f586ea16@d23ea6b9-&gt;S10.0.75.1:11111:281723462*grn/CE1C7277/f586ea16@ab709c91 #61856: . Target History is: &lt;S10.0.75.1:11111:281723462:*grn/CE1C7277/f586ea16:@ab709c91&gt;. About to break its promise.
[17:35:44 INF] DeactivateActivationOnIdle: [Activation: S10.0.75.1:11111:281723462*grn/716E8E94/bf83f8d1+AzureStreamProvider_EventC@8384eab5 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[17:35:44 INF] DeactivateActivationOnIdle: [Activation: S10.0.75.1:11111:281723462*grn/2F2DBAA7/431e3197@fdd503a3 #GrainType=GrainC Placement=RandomPlacement State=Deactivating] later when become idle.
```

The rest of the message is just a stack trace from Grain C up to the invocation of the [OneWay] method of Grain A.

After this process some statistics show up in the console. Let me share some of them with you:
```
Grain.GrainA.Current=3122
Grain.GrainB.Current=3122
Grain.GrainC.Current=186
Grain.GrainD.Current=3122
Grain.GrainE.Current=2917
```

Grain C and Grain E do not make sense at all. Somehow the messages are not being picked up on time and lost completely. This behaviour only appears when we launch the application without debugging. When we debug the application everything works fine.
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5223</IssueLabelID>
    <Title>Add warm up to transaction recovery tests and reduce grain logging</Title>
    <Description>TransactionWillRecoverAfterRandomSiloFailure test failed on the first assert where we send transaction request to grains for the first time before we shutdown or kill silo. Failure are prepareTimeout and break lock. So I suspect it is because grains are taking too long to activate or grains logging are too verbose. So in order to make TransactionWillRecoverAfterRandomSiloFailure passing more consistent  added a ping method to the grain interface and call Ping() to activate grains before transaction calls and reduce grain logging level.</Description>
    <Title_Description>Add warm up to transaction recovery tests and reduce grain logging TransactionWillRecoverAfterRandomSiloFailure test failed on the first assert where we send transaction request to grains for the first time before we shutdown or kill silo. Failure are prepareTimeout and break lock. So I suspect it is because grains are taking too long to activate or grains logging are too verbose. So in order to make TransactionWillRecoverAfterRandomSiloFailure passing more consistent  added a ping method to the grain interface and call Ping() to activate grains before transaction calls and reduce grain logging level.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5222</IssueLabelID>
    <Title>Changelog for 2.2.0-rc1</Title>
    <Description>
    </Description>
    <Title_Description>Changelog for 2.2.0-rc1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5221</IssueLabelID>
    <Title>Mark legacy types as [Obsolete]</Title>
    <Description>We do not plan to ship legacy packages and classes like `AzureSilo` and `AzureClient` as part of 3.0 because they will have outlived their utility by then. To communicate this intent we need to mark all types that will be going away as [Obsolete] now so that people have enough time to plan and adjust their code.</Description>
    <Title_Description>Mark legacy types as [Obsolete] We do not plan to ship legacy packages and classes like `AzureSilo` and `AzureClient` as part of 3.0 because they will have outlived their utility by then. To communicate this intent we need to mark all types that will be going away as [Obsolete] now so that people have enough time to plan and adjust their code.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5220</IssueLabelID>
    <Title>Nullref when calling injected IGrainServiceClient from a FooGrainService</Title>
    <Description>I'm getting a nullref when trying to invoke an injected IBarGrainServiceClient from a FooGrainService. GrainServiceClient.CallingGrainReference is throwing a nullref due to RuntimeContext.Current?.ActivationContext?.Activation being null.

```
public interface IAService: IGrainService
{
  Task Execute();
}
public interface IAServiceClient: IGrainServiceClient&lt;IAService&gt; IAService
{}
public interface IBService: IGrainService
{
  Task Execute();
}
public interface IBServiceClient: IGrainServiceClient&lt;IBService&gt; IBService
{}

public interface ICService :IGrainService{}

public class CService :GrainService ICService
{
        private readonly IAServiceClient _aService;
        private readonly IBServiceClient _bService;
        public CService(IAServiceClient aService IBServiceClient IGrainIdentity id Silo silo ILoggerFactory loggerFactory): base(id silo loggerFactory)
        {
            _aService = aService;
            _bService = bService;
        }
        public override async Task Start()
        {
            await base.Start();
            _timer = this.RegisterTimer(_ =&gt; Execute() null TimeSpan.Zero TimeSpan.FromSeconds(30));
        }

        public override async Task Stop()
        {
            _timer?.Dispose();
            await base.Stop();
        }
        private async Task Execute() //service execution must be sequential
        {
            await _aService.Execute(); //throws at GrainServiceClient.GrainService_get
            await _bService.Execute();
        }
}

```</Description>
    <Title_Description>Nullref when calling injected IGrainServiceClient from a FooGrainService I'm getting a nullref when trying to invoke an injected IBarGrainServiceClient from a FooGrainService. GrainServiceClient.CallingGrainReference is throwing a nullref due to RuntimeContext.Current?.ActivationContext?.Activation being null.

```
public interface IAService: IGrainService
{
  Task Execute();
}
public interface IAServiceClient: IGrainServiceClient&lt;IAService&gt; IAService
{}
public interface IBService: IGrainService
{
  Task Execute();
}
public interface IBServiceClient: IGrainServiceClient&lt;IBService&gt; IBService
{}

public interface ICService :IGrainService{}

public class CService :GrainService ICService
{
        private readonly IAServiceClient _aService;
        private readonly IBServiceClient _bService;
        public CService(IAServiceClient aService IBServiceClient IGrainIdentity id Silo silo ILoggerFactory loggerFactory): base(id silo loggerFactory)
        {
            _aService = aService;
            _bService = bService;
        }
        public override async Task Start()
        {
            await base.Start();
            _timer = this.RegisterTimer(_ =&gt; Execute() null TimeSpan.Zero TimeSpan.FromSeconds(30));
        }

        public override async Task Stop()
        {
            _timer?.Dispose();
            await base.Stop();
        }
        private async Task Execute() //service execution must be sequential
        {
            await _aService.Execute(); //throws at GrainServiceClient.GrainService_get
            await _bService.Execute();
        }
}

```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5219</IssueLabelID>
    <Title>Clearing state failed for grain which hasn't been yet saved to AzureTable storage</Title>
    <Description>Good day to all.

Calling ClearStateAsync failed with exception when grain instance doesn't have table record.

This is because of grainState.Etag is null during grain Activation if it doesn't have a table record.
Possible solutions:
- Skip deletion for null Etag
- Using '*' as Etag value for null Etag

Exception details:

Exc level 0: System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130
System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130

</Description>
    <Title_Description>Clearing state failed for grain which hasn't been yet saved to AzureTable storage Good day to all.

Calling ClearStateAsync failed with exception when grain instance doesn't have table record.

This is because of grainState.Etag is null during grain Activation if it doesn't have a table record.
Possible solutions:
- Skip deletion for null Etag
- Using '*' as Etag value for null Etag

Exception details:

Exc level 0: System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130
System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130

</Title_Description>
    <Label>help wanted</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5218</IssueLabelID>
    <Title>[Question] Google Cloud Platform PubSub</Title>
    <Description>Hello

In the Orleans.Stream.GCP.csproj there is the following:

` &lt;PropertyGroup&gt;
    &lt;!-- Cannot release a stable version of this package that depends on a prerelease version of Google.Cloud.PubSub.V1. --&gt;
    &lt;IsPackable&gt;false&lt;/IsPackable&gt;
&lt;/PropertyGroup&gt;`

Since Google.Cloud.PubSub has been release and is not in beta version can we consider Orleans Google's PubSub as a stable version?

https://www.nuget.org/packages/Google.Cloud.PubSub.V1

</Description>
    <Title_Description>[Question] Google Cloud Platform PubSub Hello

In the Orleans.Stream.GCP.csproj there is the following:

` &lt;PropertyGroup&gt;
    &lt;!-- Cannot release a stable version of this package that depends on a prerelease version of Google.Cloud.PubSub.V1. --&gt;
    &lt;IsPackable&gt;false&lt;/IsPackable&gt;
&lt;/PropertyGroup&gt;`

Since Google.Cloud.PubSub has been release and is not in beta version can we consider Orleans Google's PubSub as a stable version?

https://www.nuget.org/packages/Google.Cloud.PubSub.V1

</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5217</IssueLabelID>
    <Title>AdoNetGrainStorage : Newtonsoft.Json.JsonSerializationException: Self referencing loop detected</Title>
    <Description>We have json serialization error during WriteState for grain. We use the AdoNetGrainStorage .
Looks like the using of ReferenceLoopHandling json setting is missing.
```c#

Exc level 0: Newtonsoft.Json.JsonSerializationException: Self referencing loop detected with type 'Data.Item'. Path 'Items.$values[3].Orders.Item.$values'.
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.CheckForCircularReference(JsonWriter writer Object value JsonProperty property JsonContract contract JsonContainerContract containerContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer IEnumerable values JsonArrayContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer IEnumerable values JsonArrayContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.Serialize(JsonWriter jsonWriter Object value Type objectType)
   at Newtonsoft.Json.JsonSerializer.SerializeInternal(JsonWriter jsonWriter Object value Type objectType)
   at Newtonsoft.Json.JsonConvert.SerializeObjectInternal(Object value Type type JsonSerializer jsonSerializer)
   at Orleans.Storage.OrleansStorageDefaultJsonSerializer.Serialize(Object data)
   at Orleans.Storage.AdoNetGrainStorage.&lt;&gt;c__DisplayClass33_1.&lt;WriteStateAsync&gt;b__0(IDbCommand command)
   at Orleans.Persistence.AdoNet.Storage.RelationalStorage.&lt;ExecuteAsync&gt;d__15`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Persistence.AdoNet.Storage.RelationalStorage.&lt;ReadAsync&gt;d__10`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Storage.AdoNetGrainStorage.&lt;WriteStateAsync&gt;d__33.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Core.StateStorageBridge`1.&lt;WriteStateAsync&gt;d__12.MoveNext()

```</Description>
    <Title_Description>AdoNetGrainStorage : Newtonsoft.Json.JsonSerializationException: Self referencing loop detected We have json serialization error during WriteState for grain. We use the AdoNetGrainStorage .
Looks like the using of ReferenceLoopHandling json setting is missing.
```c#

Exc level 0: Newtonsoft.Json.JsonSerializationException: Self referencing loop detected with type 'Data.Item'. Path 'Items.$values[3].Orders.Item.$values'.
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.CheckForCircularReference(JsonWriter writer Object value JsonProperty property JsonContract contract JsonContainerContract containerContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer IEnumerable values JsonArrayContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer IEnumerable values JsonArrayContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer Object value JsonObjectContract contract JsonProperty member JsonContainerContract collectionContract JsonProperty containerProperty)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.Serialize(JsonWriter jsonWriter Object value Type objectType)
   at Newtonsoft.Json.JsonSerializer.SerializeInternal(JsonWriter jsonWriter Object value Type objectType)
   at Newtonsoft.Json.JsonConvert.SerializeObjectInternal(Object value Type type JsonSerializer jsonSerializer)
   at Orleans.Storage.OrleansStorageDefaultJsonSerializer.Serialize(Object data)
   at Orleans.Storage.AdoNetGrainStorage.&lt;&gt;c__DisplayClass33_1.&lt;WriteStateAsync&gt;b__0(IDbCommand command)
   at Orleans.Persistence.AdoNet.Storage.RelationalStorage.&lt;ExecuteAsync&gt;d__15`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Persistence.AdoNet.Storage.RelationalStorage.&lt;ReadAsync&gt;d__10`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Storage.AdoNetGrainStorage.&lt;WriteStateAsync&gt;d__33.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Core.StateStorageBridge`1.&lt;WriteStateAsync&gt;d__12.MoveNext()

```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5216</IssueLabelID>
    <Title>ConsistentRingProviderTests_Silo.Ring_1Fsec1J test failure</Title>
    <Description>Example: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2428/testReport/junit/UnitTests.General/ConsistentRingProviderTests_Silo/Ring_1Fsec1J/

`MESSAGE:
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 20000\r\n-------- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:29580:281582574*stg/0/00000000@S00000000-&gt;S127.0.0.1:29579:281582567*grn/FCB3F509/00003039@80c09988 #36174[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now.
+++++++++++++++++++
STACK TRACE:
at System.Threading.Tasks.Task.WaitAll(Task[] tasks Int32 millisecondsTimeout CancellationToken cancellationToken) at System.Threading.Tasks.Task.WaitAll(Task[] tasks Int32 millisecondsTimeout) at System.Threading.Tasks.Task.WaitAll(Task[] tasks TimeSpan timeout) at UnitTests.General.ConsistentRingProviderTests_Silo.&lt;Ring_1Fsec1J&gt;d__22.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\General\ConsistentRingProviderTests_Silo.cs:line 188 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) ----- Inner Stack Trace ----- at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 269 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.InProcessSiloHandle.&lt;CreateAsync&gt;d__7.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 37 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.TestCluster.&lt;StartSiloAsync&gt;d__61.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 543 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.TestCluster.&lt;StartAdditionalSilosAsync&gt;d__44.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 318 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at UnitTests.General.ConsistentRingProviderTests_Silo.&lt;&gt;c__DisplayClass22_0.&lt;Ring_1Fsec1J&gt;b__1(Task`1 t) in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\General\ConsistentRingProviderTests_Silo.cs:line 191 at System.Threading.Tasks.ContinuationResultTaskFromResultTask`2.InnerInvoke() at System.Threading.Tasks.Task.Execute() ----- Inner Stack Trace ----- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 218 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.ReminderService.LocalReminderService.&lt;Start&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 218 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;&lt;OnActiveStart&gt;g__StartReminderService|73_0&gt;d.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 540 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 390 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;d__73.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 543 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 82 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55`</Description>
    <Title_Description>ConsistentRingProviderTests_Silo.Ring_1Fsec1J test failure Example: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2428/testReport/junit/UnitTests.General/ConsistentRingProviderTests_Silo/Ring_1Fsec1J/

`MESSAGE:
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 20000\r\n-------- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:29580:281582574*stg/0/00000000@S00000000-&gt;S127.0.0.1:29579:281582567*grn/FCB3F509/00003039@80c09988 #36174[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now.
+++++++++++++++++++
STACK TRACE:
at System.Threading.Tasks.Task.WaitAll(Task[] tasks Int32 millisecondsTimeout CancellationToken cancellationToken) at System.Threading.Tasks.Task.WaitAll(Task[] tasks Int32 millisecondsTimeout) at System.Threading.Tasks.Task.WaitAll(Task[] tasks TimeSpan timeout) at UnitTests.General.ConsistentRingProviderTests_Silo.&lt;Ring_1Fsec1J&gt;d__22.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\General\ConsistentRingProviderTests_Silo.cs:line 188 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) ----- Inner Stack Trace ----- at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 269 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.InProcessSiloHandle.&lt;CreateAsync&gt;d__7.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 37 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.TestCluster.&lt;StartSiloAsync&gt;d__61.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 543 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.TestCluster.&lt;StartAdditionalSilosAsync&gt;d__44.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 318 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at UnitTests.General.ConsistentRingProviderTests_Silo.&lt;&gt;c__DisplayClass22_0.&lt;Ring_1Fsec1J&gt;b__1(Task`1 t) in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\General\ConsistentRingProviderTests_Silo.cs:line 191 at System.Threading.Tasks.ContinuationResultTaskFromResultTask`2.InnerInvoke() at System.Threading.Tasks.Task.Execute() ----- Inner Stack Trace ----- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 218 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.ReminderService.LocalReminderService.&lt;Start&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 57 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 218 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;&lt;OnActiveStart&gt;g__StartReminderService|73_0&gt;d.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 540 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 390 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;d__73.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 543 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 82 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55`</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/12/2018 2:02:14 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5214</IssueLabelID>
    <Title>Support ProxyGatewayEndpoint from legacy configuration</Title>
    <Description>Propagates the `ProxyGatewayEndpoint` setting from legacy `NodeConfiguration` to `EndpointOptions`. The silo-to-silo endpoint options are being propagated correctly and don't need to change.

~~`GatewayPort` is redundant and should not be used if `GatewayEndpoint` is set but it shouldn't hurt to explicitly set it anyway.~~ EDIT: setting gateway port here `GatewayPort` wasn't redundant: it was being used to determine whether or not to start a gateway etc. I added changes to fix that.</Description>
    <Title_Description>Support ProxyGatewayEndpoint from legacy configuration Propagates the `ProxyGatewayEndpoint` setting from legacy `NodeConfiguration` to `EndpointOptions`. The silo-to-silo endpoint options are being propagated correctly and don't need to change.

~~`GatewayPort` is redundant and should not be used if `GatewayEndpoint` is set but it shouldn't hurt to explicitly set it anyway.~~ EDIT: setting gateway port here `GatewayPort` wasn't redundant: it was being used to determine whether or not to start a gateway etc. I added changes to fix that.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5213</IssueLabelID>
    <Title>Fix AzureSilo startup</Title>
    <Description>We saw an issue with `AzureSilo` which amounts to discrepancies between the membership table entry published manually by `AzureSilo` during startup and the entry published by the `IMembershipTable` implementation.

Two main changes: 

* Do not manually publish an entry into the table
* Do not manually configure a silo generation (which will be overwritten later anyway).

We can include this post 2.2.0-rc1</Description>
    <Title_Description>Fix AzureSilo startup We saw an issue with `AzureSilo` which amounts to discrepancies between the membership table entry published manually by `AzureSilo` during startup and the entry published by the `IMembershipTable` implementation.

Two main changes: 

* Do not manually publish an entry into the table
* Do not manually configure a silo generation (which will be overwritten later anyway).

We can include this post 2.2.0-rc1</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5212</IssueLabelID>
    <Title>Turn off nuget release for transaction testkit projects</Title>
    <Description>
    </Description>
    <Title_Description>Turn off nuget release for transaction testkit projects </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5210</IssueLabelID>
    <Title>Optimize memory allocation with custom EqualityComparer</Title>
    <Description>The `BinaryTokenStreamWriter` uses dictionaries with `RuntimeTypeHandle` keys to lookup appropriate `SerializationTokenType` and serialization action for every field in an object graph. 
Since `RuntimeTypeHandle` does not implement IEquatable interface (even though it has `Equals(RuntimeTypeHandle)` method) dictionaries are using `ObjectEqualityComparer` which in turn uses `Equals(object)` and that causes a boxing allocation to occur at every lookup of a dictionary.
In this PR I'm proposing a usage of a custom `RuntimeTypeHandlerEqualityComparer` to eliminate allocation.</Description>
    <Title_Description>Optimize memory allocation with custom EqualityComparer The `BinaryTokenStreamWriter` uses dictionaries with `RuntimeTypeHandle` keys to lookup appropriate `SerializationTokenType` and serialization action for every field in an object graph. 
Since `RuntimeTypeHandle` does not implement IEquatable interface (even though it has `Equals(RuntimeTypeHandle)` method) dictionaries are using `ObjectEqualityComparer` which in turn uses `Equals(object)` and that causes a boxing allocation to occur at every lookup of a dictionary.
In this PR I'm proposing a usage of a custom `RuntimeTypeHandlerEqualityComparer` to eliminate allocation.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5206</IssueLabelID>
    <Title>How do I deploy Silo on Azure as a app service?</Title>
    <Description>I am trying to deploy to my first Orleans project on Azure as a service but was not able to find any solution.
Right now I am using a local cluster and it is working fine.</Description>
    <Title_Description>How do I deploy Silo on Azure as a app service? I am trying to deploy to my first Orleans project on Azure as a service but was not able to find any solution.
Right now I am using a local cluster and it is working fine.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5205</IssueLabelID>
    <Title>Exceptions on stream consumers are not logged</Title>
    <Description>Hey folks!

I don't know if it the desired behaviour but I noticed that when a grain receives a message and it throw an exception it doesn't even write a a Warning log. It just swallow the exception:

![image](https://user-images.githubusercontent.com/4714040/49260064-059ce080-f423-11e8-916d-8db9ec5da8f0.png)

If I set `FireAndForgetDelivery = false` then the caller get the exception:

![image](https://user-images.githubusercontent.com/4714040/49260117-4268d780-f423-11e8-9b1a-47fed2539d81.png)

This is my repro code:

```
[ImplicitStreamSubscription("MyStream")]
    public class ConsumerGrain : Grain IConsumerGrain
    {
        private readonly ILogger _logger;

        public ConsumerGrain(ILoggerFactory loggerFactory)
        {
            this._logger = loggerFactory.CreateLogger&lt;ConsumerGrain&gt;();
        }

        public override async Task OnActivateAsync()
        {
            var provider = this.GetStreamProvider("MyProvider");
            var stream = provider.GetStream&lt;int&gt;(this.GetPrimaryKey() "MyStream");

            var handles = await stream.GetAllSubscriptionHandles();
            if (handles.Count &gt; 0)
            {
                var tasks = new List&lt;Task&gt;();
                foreach (var handle in handles)
                {
                    tasks.Add(handle.ResumeAsync(this.Consume));
                }
                await Task.WhenAll(tasks);
            }
            else
            {
                await stream.SubscribeAsync(this.Consume);
            }
        }
        public Task Consume(int number StreamSequenceToken token)
        {
            if (number % 2 == 0)
            {
                this._logger.LogInformation($"Stream received a message with an even number: {number}");

            }
            else
            {
                throw new InvalidOperationException($"Ops we got an odd number and that is not cool: {number}");
            }

            return Task.CompletedTask;
        }
    }
```
```
public class PublisherGrain : Grain IPublisherGrain
    {
        private IAsyncStream&lt;int&gt; _stream;
        private readonly Random _rnd;
        private readonly ILogger _logger;

        public PublisherGrain(ILoggerFactory loggerFactory)
        {
            this._logger = loggerFactory.CreateLogger&lt;PublisherGrain&gt;();
            this._rnd = new Random();
        }

        public override Task OnActivateAsync()
        {
            var provider = this.GetStreamProvider("MyProvider");
            this._stream = provider.GetStream&lt;int&gt;(this.GetPrimaryKey() "MyStream");

            this.RegisterTimer(_ =&gt;
            {
                return _stream.OnNextAsync(this._rnd.Next());
            } null TimeSpan.FromSeconds(2) TimeSpan.FromSeconds(2));

            return Task.CompletedTask;
        }
        public Task Publish()
        {
            this._logger.LogInformation("Running tests!");
            return Task.CompletedTask;
        }
    }
```

So `FireAndForgetDelivery` makes sense to _ignore_ exceptions on the caller. However other providers doesn't have that option (nor make sense to). 

Shouldn't the stream runtime notify as a Warning that it tried to delivery a message but an exception happened? I know it does that if the consumer grain fail to get activated (i.e. fail on `OnActivateAsync()`) but not on the processing method...

Any thoughts?</Description>
    <Title_Description>Exceptions on stream consumers are not logged Hey folks!

I don't know if it the desired behaviour but I noticed that when a grain receives a message and it throw an exception it doesn't even write a a Warning log. It just swallow the exception:

![image](https://user-images.githubusercontent.com/4714040/49260064-059ce080-f423-11e8-916d-8db9ec5da8f0.png)

If I set `FireAndForgetDelivery = false` then the caller get the exception:

![image](https://user-images.githubusercontent.com/4714040/49260117-4268d780-f423-11e8-9b1a-47fed2539d81.png)

This is my repro code:

```
[ImplicitStreamSubscription("MyStream")]
    public class ConsumerGrain : Grain IConsumerGrain
    {
        private readonly ILogger _logger;

        public ConsumerGrain(ILoggerFactory loggerFactory)
        {
            this._logger = loggerFactory.CreateLogger&lt;ConsumerGrain&gt;();
        }

        public override async Task OnActivateAsync()
        {
            var provider = this.GetStreamProvider("MyProvider");
            var stream = provider.GetStream&lt;int&gt;(this.GetPrimaryKey() "MyStream");

            var handles = await stream.GetAllSubscriptionHandles();
            if (handles.Count &gt; 0)
            {
                var tasks = new List&lt;Task&gt;();
                foreach (var handle in handles)
                {
                    tasks.Add(handle.ResumeAsync(this.Consume));
                }
                await Task.WhenAll(tasks);
            }
            else
            {
                await stream.SubscribeAsync(this.Consume);
            }
        }
        public Task Consume(int number StreamSequenceToken token)
        {
            if (number % 2 == 0)
            {
                this._logger.LogInformation($"Stream received a message with an even number: {number}");

            }
            else
            {
                throw new InvalidOperationException($"Ops we got an odd number and that is not cool: {number}");
            }

            return Task.CompletedTask;
        }
    }
```
```
public class PublisherGrain : Grain IPublisherGrain
    {
        private IAsyncStream&lt;int&gt; _stream;
        private readonly Random _rnd;
        private readonly ILogger _logger;

        public PublisherGrain(ILoggerFactory loggerFactory)
        {
            this._logger = loggerFactory.CreateLogger&lt;PublisherGrain&gt;();
            this._rnd = new Random();
        }

        public override Task OnActivateAsync()
        {
            var provider = this.GetStreamProvider("MyProvider");
            this._stream = provider.GetStream&lt;int&gt;(this.GetPrimaryKey() "MyStream");

            this.RegisterTimer(_ =&gt;
            {
                return _stream.OnNextAsync(this._rnd.Next());
            } null TimeSpan.FromSeconds(2) TimeSpan.FromSeconds(2));

            return Task.CompletedTask;
        }
        public Task Publish()
        {
            this._logger.LogInformation("Running tests!");
            return Task.CompletedTask;
        }
    }
```

So `FireAndForgetDelivery` makes sense to _ignore_ exceptions on the caller. However other providers doesn't have that option (nor make sense to). 

Shouldn't the stream runtime notify as a Warning that it tried to delivery a message but an exception happened? I know it does that if the consumer grain fail to get activated (i.e. fail on `OnActivateAsync()`) but not on the processing method...

Any thoughts?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5203</IssueLabelID>
    <Title>Handling canary deployments</Title>
    <Description>This is a new incarnation of an old subject we wrap our head against since starting to use Orleans some years ago :-) 
It's all about deployment strategies. 

A quick description of the problem - we build microservices that use Orleans as their infrastructure. Each microservice is a separate Orleans cluster (with several silos on several machines).
To reduce deployment risks we would like to use canary deployments. Meaning deploy a new version of the service switch a portion of the traffic to it (1% 5%) monitor for differences in behavior if all is well switch to the new version. 

This is a deployment strategy that works well with stateless services. But when using Orleans there are multiple obstacles - 

- You cannot randomly switch traffic. Since you have stateful grains you need to be able to switch a portion of the traffic according to a specific identifier that can signify the grains that are used (so all requests for certain grains ends up in the same cluster - prod or canary). Otherwise you have multiple activation and stale states.

- What do you do if there is no consistent identifier that you can route on for all the methods the service exposes? What if you identify the "id" only in the middle of handling the request in the service?

- What if you need to switch off the canary? Some grains were already instantiated in the canary cluster but they might be also active in the prod cluster. Now traffic will go again to prod possibly to the old grains and again you have stale state.

I don't think that the grain versioning feature answers this problem fully. I'm wondering if anyone else tried to handle this or what are the deployment strategies that are actually used in production for high scale systems that are running on Orleans. 
</Description>
    <Title_Description>Handling canary deployments This is a new incarnation of an old subject we wrap our head against since starting to use Orleans some years ago :-) 
It's all about deployment strategies. 

A quick description of the problem - we build microservices that use Orleans as their infrastructure. Each microservice is a separate Orleans cluster (with several silos on several machines).
To reduce deployment risks we would like to use canary deployments. Meaning deploy a new version of the service switch a portion of the traffic to it (1% 5%) monitor for differences in behavior if all is well switch to the new version. 

This is a deployment strategy that works well with stateless services. But when using Orleans there are multiple obstacles - 

- You cannot randomly switch traffic. Since you have stateful grains you need to be able to switch a portion of the traffic according to a specific identifier that can signify the grains that are used (so all requests for certain grains ends up in the same cluster - prod or canary). Otherwise you have multiple activation and stale states.

- What do you do if there is no consistent identifier that you can route on for all the methods the service exposes? What if you identify the "id" only in the middle of handling the request in the service?

- What if you need to switch off the canary? Some grains were already instantiated in the canary cluster but they might be also active in the prod cluster. Now traffic will go again to prod possibly to the old grains and again you have stale state.

I don't think that the grain versioning feature answers this problem fully. I'm wondering if anyone else tried to handle this or what are the deployment strategies that are actually used in production for high scale systems that are running on Orleans. 
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5202</IssueLabelID>
    <Title>Requests to old silo incarnation</Title>
    <Description>Hi

I just had the following scenario:

A silo was restarted (IP 10.0.0.46) and it was correctly updated in the membership table (MongoDB):

![membership table](https://user-images.githubusercontent.com/1236435/49216292-03a73300-f3cb-11e8-9833-b7c865dc1446.PNG)

The orleans dashboard only shows the new incarnation of this silo:

![dashboard](https://user-images.githubusercontent.com/1236435/49216319-128de580-f3cb-11e8-8205-f52865bb62dd.PNG)

Then I see a lot of exceptions like

`The target silo is no longer active: target was S10.0.0.46:11111:280671239 but this silo is S10.0.0.46:11111:281180672`

or 

`Response did not arrive on time in 00:00:30 for message: Request S10.0.1.38:11111:280671207*cli/da7976b3@755c9398-&gt;S10.0.0.46:11111:280671239*grn/23E3C64D/e1aa2aaa@654c47ab #10491769[ForwardCount=1]: . Target History is: &lt;S10.0.0.46:11111:280671239:*grn/23E3C64D/e1aa2aaa:@654c47ab&gt;    &lt;S10.0.1.38:11111:280671207:*grn/23E3C64D/e1aa2aaa:@a63ff19e&gt;.`

or

`
No target activation S10.0.1.38:11111:280671207*cli/da7976b3@755c9398 for response message: Transient Rejection (info: Silo S10.0.1.37:11111:280671208 is rejecting message: Request S10.0.1.38:11111:280671207*cli/da7976b3@755c9398-&gt;S10.0.0.46:11111:280671239*grn/16D28AEC/73a42f8e@704b21ad #10487332[ForwardCount=1]: . Reason = Target S10.0.0.46:11111:280671239 silo is known to be dead) Response S10.0.0.46:11111:280671239*grn/16D28AEC/73a42f8e@704b21ad-&gt;S10.0.1.38:11111:280671207*cli/da7976b3@755c9398 #10487332: 
`

It stopped after I terminated this node. The new node got a new IP and everything was fine.

It could be a bug in the MongoDB Membership Table but I am confused why everything else looks good.

</Description>
    <Title_Description>Requests to old silo incarnation Hi

I just had the following scenario:

A silo was restarted (IP 10.0.0.46) and it was correctly updated in the membership table (MongoDB):

![membership table](https://user-images.githubusercontent.com/1236435/49216292-03a73300-f3cb-11e8-9833-b7c865dc1446.PNG)

The orleans dashboard only shows the new incarnation of this silo:

![dashboard](https://user-images.githubusercontent.com/1236435/49216319-128de580-f3cb-11e8-8205-f52865bb62dd.PNG)

Then I see a lot of exceptions like

`The target silo is no longer active: target was S10.0.0.46:11111:280671239 but this silo is S10.0.0.46:11111:281180672`

or 

`Response did not arrive on time in 00:00:30 for message: Request S10.0.1.38:11111:280671207*cli/da7976b3@755c9398-&gt;S10.0.0.46:11111:280671239*grn/23E3C64D/e1aa2aaa@654c47ab #10491769[ForwardCount=1]: . Target History is: &lt;S10.0.0.46:11111:280671239:*grn/23E3C64D/e1aa2aaa:@654c47ab&gt;    &lt;S10.0.1.38:11111:280671207:*grn/23E3C64D/e1aa2aaa:@a63ff19e&gt;.`

or

`
No target activation S10.0.1.38:11111:280671207*cli/da7976b3@755c9398 for response message: Transient Rejection (info: Silo S10.0.1.37:11111:280671208 is rejecting message: Request S10.0.1.38:11111:280671207*cli/da7976b3@755c9398-&gt;S10.0.0.46:11111:280671239*grn/16D28AEC/73a42f8e@704b21ad #10487332[ForwardCount=1]: . Reason = Target S10.0.0.46:11111:280671239 silo is known to be dead) Response S10.0.0.46:11111:280671239*grn/16D28AEC/73a42f8e@704b21ad-&gt;S10.0.1.38:11111:280671207*cli/da7976b3@755c9398 #10487332: 
`

It stopped after I terminated this node. The new node got a new IP and everything was fine.

It could be a bug in the MongoDB Membership Table but I am confused why everything else looks good.

</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5200</IssueLabelID>
    <Title>SiloHostBuilder not validating GrainCollectionOptions during build</Title>
    <Description>**Repro code:**

```
var siloHostBuilder = new SiloHostBuilder()                    
                    .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
                    {
                        options.CollectionAge = TimeSpan.FromSeconds(30);
                    });

siloHostBuilder.Build();
```

**Expected behavior**
The call to siloHostBuilder.Build() should throw an exception because the specified TimeSpan for options.Collection age is less than 1 minute.

**Actual behavior**
The call to siloHostBuilder.Build() succeeds however activations will fail because the TimeSpan is less than 1 minutes.  Moreover when the runtime throws the exception on the silo when the activation fails the exception never reaches the client which made the initial request to the cluster and the client experiences a timeout.</Description>
    <Title_Description>SiloHostBuilder not validating GrainCollectionOptions during build **Repro code:**

```
var siloHostBuilder = new SiloHostBuilder()                    
                    .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
                    {
                        options.CollectionAge = TimeSpan.FromSeconds(30);
                    });

siloHostBuilder.Build();
```

**Expected behavior**
The call to siloHostBuilder.Build() should throw an exception because the specified TimeSpan for options.Collection age is less than 1 minute.

**Actual behavior**
The call to siloHostBuilder.Build() succeeds however activations will fail because the TimeSpan is less than 1 minutes.  Moreover when the runtime throws the exception on the silo when the activation fails the exception never reaches the client which made the initial request to the cluster and the client experiences a timeout.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5197</IssueLabelID>
    <Title> transactional multiple read/write tests</Title>
    <Description>Added golden path tests for multiple transactional reads and writes within a single transaction</Description>
    <Title_Description> transactional multiple read/write tests Added golden path tests for multiple transactional reads and writes within a single transaction</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5196</IssueLabelID>
    <Title>Ignored RegisterAsStreamProducer error on EventHub streams</Title>
    <Description>Hi. Im testing EventHub stream providers on high throughputs with a lot streams. (32k).
I observed when launching my orleans on existing eventhub with populated data (32 partitions 1000 partionsKeys per partition) that orleans spams my pubsub storage on blob azure and get a lot errors. Orleans works further and im ending up with a lot of streams not being processed due to this errors because they are never retried.
I changed this to MemoryStorage and that part pass with success but then errors occur on loading grain states (initial check as i doesn't have any grain saved yet). 
My questions are:
1. If Orleans has some retry mechanism for getting pubsub storage and grain state storage?
2. Why Orleans spam pubsub storage when using Implicit subscription? What is purpose for that? </Description>
    <Title_Description>Ignored RegisterAsStreamProducer error on EventHub streams Hi. Im testing EventHub stream providers on high throughputs with a lot streams. (32k).
I observed when launching my orleans on existing eventhub with populated data (32 partitions 1000 partionsKeys per partition) that orleans spams my pubsub storage on blob azure and get a lot errors. Orleans works further and im ending up with a lot of streams not being processed due to this errors because they are never retried.
I changed this to MemoryStorage and that part pass with success but then errors occur on loading grain states (initial check as i doesn't have any grain saved yet). 
My questions are:
1. If Orleans has some retry mechanism for getting pubsub storage and grain state storage?
2. Why Orleans spam pubsub storage when using Implicit subscription? What is purpose for that? </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5195</IssueLabelID>
    <Title>dotnet build fails with error MSB4062 on sdk 2.1.500</Title>
    <Description>Hey guys

I've created a Silo on .NET SDK 2.1.500 and I'm encountering a build error when using the `dotnet build` command line. 

```
C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask
```

I managed to reproduce the issue on the 2.1 Stocks sample solution.

```
PS C:\Temp\2.1\Stocks\src\SiloHost&gt; dotnet build
Microsoft (R) Build Engine version 15.9.20+g88f5fadfbe for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for C:\Temp\2.1\Stocks\src\SiloHost\SiloHost.csproj...
  Restoring packages for C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj...
  Restoring packages for C:\Temp\2.1\Stocks\src\Stocks.Grains\Stocks.Grains.csproj...
  Generating MSBuild file C:\Temp\2.1\Stocks\src\Stocks.Interfaces\obj\Stocks.Interfaces.csproj.nuget.g.props.
  Restore completed in 147 sec for C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj.
  Generating MSBuild file C:\Temp\2.1\Stocks\src\Stocks.Grains\obj\Stocks.Grains.csproj.nuget.g.props.
  Restore completed in 15 sec for C:\Temp\2.1\Stocks\src\Stocks.Grains\Stocks.Grains.csproj.
  Installing Microsoft.Extensions.Logging.Console 2.0.0.
  Generating MSBuild file C:\Temp\2.1\Stocks\src\SiloHost\obj\SiloHost.csproj.nuget.g.props.
  Restore completed in 271 sec for C:\Temp\2.1\Stocks\src\SiloHost\SiloHost.csproj.
C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask. [C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj]

Build FAILED.

C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask. [C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj]
    0 Warning(s)
    1 Error(s)

Time Elapsed 00:00:03.61
```
dotnet --info

```
.NET Core SDK (reflecting any global.json):
 Version:   2.1.500
 Commit:    b68b931422

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.500\

Host (useful for support):
  Version: 2.1.6
  Commit:  3f4f8eebd8

.NET Core SDKs installed:
  1.1.10 [C:\Program Files\dotnet\sdk]
  1.1.11 [C:\Program Files\dotnet\sdk]
  2.1.202 [C:\Program Files\dotnet\sdk]
  2.1.402 [C:\Program Files\dotnet\sdk]
  2.1.403 [C:\Program Files\dotnet\sdk]
  2.1.500 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

Additional info:
- The solution does compile successfully from Visual Studio but I'm unable to build it using `dotnet build` or `dotnet publish` from the command line.
- I've tried changing all referenced `netstandard2.0` apps to `netcoreapp2.1` without success.
- I've also swapped the package reference from `Microsoft.Orleans.OrleansCodeGenerator.Build` to `Microsoft.Orleans.CodeGenerator.MSBuild` without success.

Am I doing something wrong or is there a known workaround? 

Any help appreciated!
</Description>
    <Title_Description>dotnet build fails with error MSB4062 on sdk 2.1.500 Hey guys

I've created a Silo on .NET SDK 2.1.500 and I'm encountering a build error when using the `dotnet build` command line. 

```
C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask
```

I managed to reproduce the issue on the 2.1 Stocks sample solution.

```
PS C:\Temp\2.1\Stocks\src\SiloHost&gt; dotnet build
Microsoft (R) Build Engine version 15.9.20+g88f5fadfbe for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for C:\Temp\2.1\Stocks\src\SiloHost\SiloHost.csproj...
  Restoring packages for C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj...
  Restoring packages for C:\Temp\2.1\Stocks\src\Stocks.Grains\Stocks.Grains.csproj...
  Generating MSBuild file C:\Temp\2.1\Stocks\src\Stocks.Interfaces\obj\Stocks.Interfaces.csproj.nuget.g.props.
  Restore completed in 147 sec for C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj.
  Generating MSBuild file C:\Temp\2.1\Stocks\src\Stocks.Grains\obj\Stocks.Grains.csproj.nuget.g.props.
  Restore completed in 15 sec for C:\Temp\2.1\Stocks\src\Stocks.Grains\Stocks.Grains.csproj.
  Installing Microsoft.Extensions.Logging.Console 2.0.0.
  Generating MSBuild file C:\Temp\2.1\Stocks\src\SiloHost\obj\SiloHost.csproj.nuget.g.props.
  Restore completed in 271 sec for C:\Temp\2.1\Stocks\src\SiloHost\SiloHost.csproj.
C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask. [C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj]

Build FAILED.

C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.CSharp.Core.targets(525): error MSB4062: The "Microsoft.CodeAnalysis.BuildTasks.Csc" task could not be loaded from the assembly C:\Program Files\dotnet\sdk\2.1.500\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask. [C:\Temp\2.1\Stocks\src\Stocks.Interfaces\Stocks.Interfaces.csproj]
    0 Warning(s)
    1 Error(s)

Time Elapsed 00:00:03.61
```
dotnet --info

```
.NET Core SDK (reflecting any global.json):
 Version:   2.1.500
 Commit:    b68b931422

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.500\

Host (useful for support):
  Version: 2.1.6
  Commit:  3f4f8eebd8

.NET Core SDKs installed:
  1.1.10 [C:\Program Files\dotnet\sdk]
  1.1.11 [C:\Program Files\dotnet\sdk]
  2.1.202 [C:\Program Files\dotnet\sdk]
  2.1.402 [C:\Program Files\dotnet\sdk]
  2.1.403 [C:\Program Files\dotnet\sdk]
  2.1.500 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.10 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

Additional info:
- The solution does compile successfully from Visual Studio but I'm unable to build it using `dotnet build` or `dotnet publish` from the command line.
- I've tried changing all referenced `netstandard2.0` apps to `netcoreapp2.1` without success.
- I've also swapped the package reference from `Microsoft.Orleans.OrleansCodeGenerator.Build` to `Microsoft.Orleans.CodeGenerator.MSBuild` without success.

Am I doing something wrong or is there a known workaround? 

Any help appreciated!
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5189</IssueLabelID>
    <Title>Question: Can an IGrainService or IGrainServiceClient be called from an Orleans Client?</Title>
    <Description>Can an IGrainService or IGrainServiceClient be called from an Orleans Client or is it only accessible within a silo?

Can I get a handle to an IGrainService via clusterClient.GetGrain&lt;T&gt;?

</Description>
    <Title_Description>Question: Can an IGrainService or IGrainServiceClient be called from an Orleans Client? Can an IGrainService or IGrainServiceClient be called from an Orleans Client or is it only accessible within a silo?

Can I get a handle to an IGrainService via clusterClient.GetGrain&lt;T&gt;?

</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5188</IssueLabelID>
    <Title>Cleanup Transaction Agent</Title>
    <Description>- Reduced linq usages and allocations.</Description>
    <Title_Description>Cleanup Transaction Agent - Reduced linq usages and allocations.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5187</IssueLabelID>
    <Title>EventHubStreamProvider run out for memory</Title>
    <Description>Hi. I did adaptation of EventHubStreamProvider to read from EventHubs external messages.
It works and im getting messages.
Then i run load test running silo on VM machine with 16 GB rams. 
I populated EventHub with huge amount of small messages and then run Orleans - with grain attached to the Stream. Grain is StatelessWorker. Grain just receive messages and return Task.CompletedTask. 
I get something around 45-50k reuqests/s on that grain and that was great. But i noticed that the memory on VM machine quickly grow to 14-15 GB and then my VM starts to be unresponsive orleans dashboard hangs and orleans console start signaling that requests cannot be completed. I wait a long time but situation never changed - memory was still overload and not cleaned. 

My grain:
```
[StatelessWorker]
    [ImplicitStreamSubscription("messages")]
    public class ReadFromEventHubGrain : Grain IReadFromEventHubGrain
    {
        public override async Task OnActivateAsync()
        {
            var streamProvider = GetStreamProvider("eventhub");
            var stream = streamProvider.GetStream&lt;EventHubMessage&gt;(this.GetPrimaryKey() "messages");

            IList&lt;StreamSubscriptionHandle&lt;EventHubMessage&gt;&gt; allMyHandles = await stream.GetAllSubscriptionHandles();

            foreach (var subscriptionHandle in allMyHandles)
            {
                await subscriptionHandle.ResumeAsync((data token) =&gt; HandleSubscription(data token));
            }

            await base.OnActivateAsync();
        }


        private Task HandleSubscription(EventHubMessage data StreamSequenceToken token)
        {
            return Task.CompletedTask;
        }
    }
```
Any thoughts about this? 
 </Description>
    <Title_Description>EventHubStreamProvider run out for memory Hi. I did adaptation of EventHubStreamProvider to read from EventHubs external messages.
It works and im getting messages.
Then i run load test running silo on VM machine with 16 GB rams. 
I populated EventHub with huge amount of small messages and then run Orleans - with grain attached to the Stream. Grain is StatelessWorker. Grain just receive messages and return Task.CompletedTask. 
I get something around 45-50k reuqests/s on that grain and that was great. But i noticed that the memory on VM machine quickly grow to 14-15 GB and then my VM starts to be unresponsive orleans dashboard hangs and orleans console start signaling that requests cannot be completed. I wait a long time but situation never changed - memory was still overload and not cleaned. 

My grain:
```
[StatelessWorker]
    [ImplicitStreamSubscription("messages")]
    public class ReadFromEventHubGrain : Grain IReadFromEventHubGrain
    {
        public override async Task OnActivateAsync()
        {
            var streamProvider = GetStreamProvider("eventhub");
            var stream = streamProvider.GetStream&lt;EventHubMessage&gt;(this.GetPrimaryKey() "messages");

            IList&lt;StreamSubscriptionHandle&lt;EventHubMessage&gt;&gt; allMyHandles = await stream.GetAllSubscriptionHandles();

            foreach (var subscriptionHandle in allMyHandles)
            {
                await subscriptionHandle.ResumeAsync((data token) =&gt; HandleSubscription(data token));
            }

            await base.OnActivateAsync();
        }


        private Task HandleSubscription(EventHubMessage data StreamSequenceToken token)
        {
            return Task.CompletedTask;
        }
    }
```
Any thoughts about this? 
 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5185</IssueLabelID>
    <Title>Invoke silo.StopAsync() to an infinite loop</Title>
    <Description>Invoke silo.StopAsync() to an infinite loop

![image](https://user-images.githubusercontent.com/28291464/48750862-53e01000-ecbc-11e8-8b16-26e0c9faab60.png)
</Description>
    <Title_Description>Invoke silo.StopAsync() to an infinite loop Invoke silo.StopAsync() to an infinite loop

![image](https://user-images.githubusercontent.com/28291464/48750862-53e01000-ecbc-11e8-8b16-26e0c9faab60.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5183</IssueLabelID>
    <Title>More graceful graceful shutdowns</Title>
    <Description>Orleans version: **2.1.2**

I've been experimenting with rolling upgrades (primarily in Kubernetes) and have noticed some inconsistent behaviour when shutting silos down gracefully (calling ISiloHost.StopAsync()). It is not specific to running in containers though the same behaviour can be observed in console applications.

Note: Generally Orleans does what is advertised on the box but I do feel that graceful shutdowns could be more consistent and ... well more graceful. Even if that means that graceful shutdown would be slower/consist of more phases.

It would be great if errors can be avoided completely when all shutdowns are graceful as is the case with rolling upgrades. This is particularly important when end users interact with grains - long pauses affecting some users during rolling upgrades are not ideal.

To help visualise these I've attached a simple solution consisting of two console apps:
* GracefulShutdownReproSiloHost is the host which should be run a few times to start up a couple of silos.
* GracefulShutdownReproUI requests state and displays placement for 100 grains once per second.

With a few silos running and while watching the UI gracefully shut down a silo by pressing Ctrl+C in its console window.

Some non-ideal behaviours I've observed:
* Spamming the logs with warnings related to shutting down (would it not be better to either avoid these or suppress these as they seem to be just noise?):
`warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message Request S...:14377:280331499*cli/62b67d9a@35412dbd-&gt;S...:14377:280331499*grn/9FBF3810/00000044@d2463480 #2595[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
warn: Runtime.Messaging.GatewaySender/GatewaySiloSender_0[0]
      Invalid usage attempt of Runtime.Messaging.GatewaySender/GatewaySiloSender_0 agent in Stopped state`
* A few errors in the log (would it not be better to either avoid these or suppress these as they seem to be just noise?):
`fail: Runtime.Messaging.IncomingMessageAgent/Application[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection``1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection``1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection``1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\InboundMessageQueue.cs:line 96
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\MessageCenter.cs:line 244
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\IncomingMessageAgent.cs:line 50
   at Orleans.Threading.FiltersApplicant``1.Apply(T action) in D:\build\agent\_work\24\s\src\Orleans.Core\Threading\ActionFilter.cs:line 86`
* In various silos some warnings about non-existent and duplicate activations when another silo is gracefully shut down (these could persist for up to 30 seconds):
`warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message Request S...:14377:280331499*cli/62b67d9a@35412dbd-&gt;S...:16512:280331498*grn/9FBF3810/0000001c@fe65279b #2656[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message NewPlacement Request S...:41545:280331496*cli/62b67d9a@35412dbd-&gt;S...:16512:280331498*grn/9FBF3810/0000004b@d3fea594 #2804[ForwardCount=2]:  for 2 times after Duplicate activation to invalid activation. Rejecting now.`
* Sometimes a shutdown will result in very quick movement of all grains to different silos bar one or two. The calls to the grains that did not move quickly will not time out but could take 5-10 seconds before they return successfully.
* Sometimes requests to a fair number of grains (those where the silo that was gracefully shut down was the grain directory master) will take about 10 seconds to return with or without warnings logged in the client app and/or by other silos. These are often easier to demonstrate with 2 silos via shutting down one of them as more grains are affected but the behaviour is similar with higher numbers of silos.

PS. When the UI console app runs out of colours just restart it.

[GracefulShutdownRepro.zip](https://github.com/dotnet/orleans/files/2595625/GracefulShutdownRepro.zip)</Description>
    <Title_Description>More graceful graceful shutdowns Orleans version: **2.1.2**

I've been experimenting with rolling upgrades (primarily in Kubernetes) and have noticed some inconsistent behaviour when shutting silos down gracefully (calling ISiloHost.StopAsync()). It is not specific to running in containers though the same behaviour can be observed in console applications.

Note: Generally Orleans does what is advertised on the box but I do feel that graceful shutdowns could be more consistent and ... well more graceful. Even if that means that graceful shutdown would be slower/consist of more phases.

It would be great if errors can be avoided completely when all shutdowns are graceful as is the case with rolling upgrades. This is particularly important when end users interact with grains - long pauses affecting some users during rolling upgrades are not ideal.

To help visualise these I've attached a simple solution consisting of two console apps:
* GracefulShutdownReproSiloHost is the host which should be run a few times to start up a couple of silos.
* GracefulShutdownReproUI requests state and displays placement for 100 grains once per second.

With a few silos running and while watching the UI gracefully shut down a silo by pressing Ctrl+C in its console window.

Some non-ideal behaviours I've observed:
* Spamming the logs with warnings related to shutting down (would it not be better to either avoid these or suppress these as they seem to be just noise?):
`warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message Request S...:14377:280331499*cli/62b67d9a@35412dbd-&gt;S...:14377:280331499*grn/9FBF3810/00000044@d2463480 #2595[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
warn: Runtime.Messaging.GatewaySender/GatewaySiloSender_0[0]
      Invalid usage attempt of Runtime.Messaging.GatewaySender/GatewaySiloSender_0 agent in Stopped state`
* A few errors in the log (would it not be better to either avoid these or suppress these as they seem to be just noise?):
`fail: Runtime.Messaging.IncomingMessageAgent/Application[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection``1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection``1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection``1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\InboundMessageQueue.cs:line 96
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct) in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\MessageCenter.cs:line 244
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Messaging\IncomingMessageAgent.cs:line 50
   at Orleans.Threading.FiltersApplicant``1.Apply(T action) in D:\build\agent\_work\24\s\src\Orleans.Core\Threading\ActionFilter.cs:line 86`
* In various silos some warnings about non-existent and duplicate activations when another silo is gracefully shut down (these could persist for up to 30 seconds):
`warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message Request S...:14377:280331499*cli/62b67d9a@35412dbd-&gt;S...:16512:280331498*grn/9FBF3810/0000001c@fe65279b #2656[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
warn: Orleans.Runtime.Dispatcher[101032]
      Forwarding failed: tried to forward message NewPlacement Request S...:41545:280331496*cli/62b67d9a@35412dbd-&gt;S...:16512:280331498*grn/9FBF3810/0000004b@d3fea594 #2804[ForwardCount=2]:  for 2 times after Duplicate activation to invalid activation. Rejecting now.`
* Sometimes a shutdown will result in very quick movement of all grains to different silos bar one or two. The calls to the grains that did not move quickly will not time out but could take 5-10 seconds before they return successfully.
* Sometimes requests to a fair number of grains (those where the silo that was gracefully shut down was the grain directory master) will take about 10 seconds to return with or without warnings logged in the client app and/or by other silos. These are often easier to demonstrate with 2 silos via shutting down one of them as more grains are affected but the behaviour is similar with higher numbers of silos.

PS. When the UI console app runs out of colours just restart it.

[GracefulShutdownRepro.zip](https://github.com/dotnet/orleans/files/2595625/GracefulShutdownRepro.zip)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5182</IssueLabelID>
    <Title>Message broadcasting</Title>
    <Description>Normally when a message is published into a stream is received by one grain that as subscribed that stream.
There is any stream provider that does broadcasting to all grain that has subscribed that channel ?</Description>
    <Title_Description>Message broadcasting Normally when a message is published into a stream is received by one grain that as subscribed that stream.
There is any stream provider that does broadcasting to all grain that has subscribed that channel ?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5181</IssueLabelID>
    <Title>How to Serialize/Deserilize DataTable?</Title>
    <Description>I wrote an interface like this:
``` C#
    public interface  IUserService:IGrainWithIntegerKey
    {
        ...       
        Task&lt;DataTable&gt; GetData();
        ...
    }
```
and I wrote a grain then.
When I call this method in a garin client the exception occured:
&gt;System.InvalidCastException: Unable to cast object of type 'Orleans.Serialization.SerializationContext' to type 'System.IConvertible'.

Now I have to convert the DataTable to  a IEnumerable&lt;IDictionary&lt;stringobject&gt;&gt; to make it work.
I wonder if there's a graceful way to handle it.</Description>
    <Title_Description>How to Serialize/Deserilize DataTable? I wrote an interface like this:
``` C#
    public interface  IUserService:IGrainWithIntegerKey
    {
        ...       
        Task&lt;DataTable&gt; GetData();
        ...
    }
```
and I wrote a grain then.
When I call this method in a garin client the exception occured:
&gt;System.InvalidCastException: Unable to cast object of type 'Orleans.Serialization.SerializationContext' to type 'System.IConvertible'.

Now I have to convert the DataTable to  a IEnumerable&lt;IDictionary&lt;stringobject&gt;&gt; to make it work.
I wonder if there's a graceful way to handle it.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5180</IssueLabelID>
    <Title>Missing Grain Activations</Title>
    <Description>I'm experiencing an issue where a grain is sometimes not activating frustratingly consistently always skipping the activation that is critical to the application. I've had this issue in both 2.0.4 and 2.1.2. Clients and silos are both in the same process and yes this is occurring when there's only one process running in the environment (which is a Windows Service on Windows Server 2012 R2 .NET Framework 4.6.1 with .NET Core 2.1.302 and SQL Server storage).

I'm getting and calling the method on the grain on what is basically an inherited event handler from a base class. While debugging with breakpoints I can see the particular event come in to the handler and go over the lines to get and call the grain. The actual type of `baseEvent` is some subtype deriving from `BaseEventType`.

``` csharp
protected override void ProcessEvent(BaseEventType baseEvent)
{
  // need to check if OrleansClient is initialized as this method can be hit before the client is ready
  if (OrleansClient?.IsInitialized == true)
  {
    var grain = OrleansClient.GetGrain&lt;IBaseEventProcessor&gt;(baseEvent.ID); // ID is a GUID string
    grain.ProcessBaseEvent(baseEvent);
  }
}
```

The ProcessEvent in the grain is an implementation of the command pattern with deduplication of the event's ID.

``` csharp
public interface IBaseEventProcessor : IGrainWithStringKey
{
  Task ProcessBaseEvent(BaseEventType baseEvent);
}

public class BaseEventProcessorGrain : Grain IBaseEventProcessor
{
  private readonly IMemoryCache _memoryCache;
  private readonly IEnumerable&lt;IBaseEventHandler&gt; _eventHandlers;
  private readonly ILogger&lt;BaseEventProcessorGrain&gt; _logger;

  public BaseEventProcessorGrain(IEnumerable&lt;IBaseEventHandler&gt; eventHandlers IMemoryCache memoryCache ILogger&lt;BaseEventProcessorGrain&gt; logger)
  {
    _eventHandlers = eventHandlers ?? throw new ArgumentNullException(nameof(eventHandlers));
    _memoryCache = memoryCache ?? throw new ArgumentNullException(nameof(memoryCache));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
  }

  public async Task ProcessBaseEvent(BaseEventType baseEvent)
  {
    if (_memoryCache.TryGetValue(baseEvent.ID out object _))
    {
      _logger.LogDebug("Event {ID} has already been processed." baseEvent.ID);
      return;
    }
    using (var cacheEntry = _memoryCache.CreateEntry(baseEvent.ID))
    {
      cacheEntry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
    }

    foreach (var handler in _eventHandlers.Where(h =&gt; h.CanProcess(baseEvent)))
    {
      try
      {
        await handler.HandleEvent(baseEvent);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex "Processing {HandlerName} failed." handler.GetType().Name);
      }
    }
  }
}
```

I've tried marking the class as reentrant the interface method for interleaving. I've overridden `OnActivateAsync()` in the grain to see if there was some error occurring during activation but I'm consistently getting nothing in a particular situation. There will be 6 events (always the same 6 in the same order) raised via the overridden `ProcessEvent()` but only the last 3 actually end up as grain activations.

To add to the intrigue/frustration those events are all actually internally grouped into a parent container event type...

``` csharp
public class EventContainer
{
  public BaseEventType[] BaseEvents { get; set; }
  public DateTime Timestamp { get; set; }
  // other irrelevant properties
}
```
In the situation that's giving me issues the first 3 events (including the one that is critical to the application) are in the same `EventContainer` and the last 3 in their own (so 4 `EventContainer`s total). I tried extending my grain and interface to have a method that takes the `EventContainer` and passes off inside that method to the method that takes each `BaseEventType` but of course I end up with no activated grain for that first `EventContainer`. There are other situations where I easily get more than 6 unique activations at once.

I've checked logs (I have both Microsoft.Extensions.Logging.Debug and Microsoft.Extensions.Logging.EventLog ILogger implementations added) and I'm not seeing any errors.
[orleans_log.txt](https://github.com/dotnet/orleans/files/2594380/orleans_log.txt)</Description>
    <Title_Description>Missing Grain Activations I'm experiencing an issue where a grain is sometimes not activating frustratingly consistently always skipping the activation that is critical to the application. I've had this issue in both 2.0.4 and 2.1.2. Clients and silos are both in the same process and yes this is occurring when there's only one process running in the environment (which is a Windows Service on Windows Server 2012 R2 .NET Framework 4.6.1 with .NET Core 2.1.302 and SQL Server storage).

I'm getting and calling the method on the grain on what is basically an inherited event handler from a base class. While debugging with breakpoints I can see the particular event come in to the handler and go over the lines to get and call the grain. The actual type of `baseEvent` is some subtype deriving from `BaseEventType`.

``` csharp
protected override void ProcessEvent(BaseEventType baseEvent)
{
  // need to check if OrleansClient is initialized as this method can be hit before the client is ready
  if (OrleansClient?.IsInitialized == true)
  {
    var grain = OrleansClient.GetGrain&lt;IBaseEventProcessor&gt;(baseEvent.ID); // ID is a GUID string
    grain.ProcessBaseEvent(baseEvent);
  }
}
```

The ProcessEvent in the grain is an implementation of the command pattern with deduplication of the event's ID.

``` csharp
public interface IBaseEventProcessor : IGrainWithStringKey
{
  Task ProcessBaseEvent(BaseEventType baseEvent);
}

public class BaseEventProcessorGrain : Grain IBaseEventProcessor
{
  private readonly IMemoryCache _memoryCache;
  private readonly IEnumerable&lt;IBaseEventHandler&gt; _eventHandlers;
  private readonly ILogger&lt;BaseEventProcessorGrain&gt; _logger;

  public BaseEventProcessorGrain(IEnumerable&lt;IBaseEventHandler&gt; eventHandlers IMemoryCache memoryCache ILogger&lt;BaseEventProcessorGrain&gt; logger)
  {
    _eventHandlers = eventHandlers ?? throw new ArgumentNullException(nameof(eventHandlers));
    _memoryCache = memoryCache ?? throw new ArgumentNullException(nameof(memoryCache));
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
  }

  public async Task ProcessBaseEvent(BaseEventType baseEvent)
  {
    if (_memoryCache.TryGetValue(baseEvent.ID out object _))
    {
      _logger.LogDebug("Event {ID} has already been processed." baseEvent.ID);
      return;
    }
    using (var cacheEntry = _memoryCache.CreateEntry(baseEvent.ID))
    {
      cacheEntry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);
    }

    foreach (var handler in _eventHandlers.Where(h =&gt; h.CanProcess(baseEvent)))
    {
      try
      {
        await handler.HandleEvent(baseEvent);
      }
      catch (Exception ex)
      {
        _logger.LogError(ex "Processing {HandlerName} failed." handler.GetType().Name);
      }
    }
  }
}
```

I've tried marking the class as reentrant the interface method for interleaving. I've overridden `OnActivateAsync()` in the grain to see if there was some error occurring during activation but I'm consistently getting nothing in a particular situation. There will be 6 events (always the same 6 in the same order) raised via the overridden `ProcessEvent()` but only the last 3 actually end up as grain activations.

To add to the intrigue/frustration those events are all actually internally grouped into a parent container event type...

``` csharp
public class EventContainer
{
  public BaseEventType[] BaseEvents { get; set; }
  public DateTime Timestamp { get; set; }
  // other irrelevant properties
}
```
In the situation that's giving me issues the first 3 events (including the one that is critical to the application) are in the same `EventContainer` and the last 3 in their own (so 4 `EventContainer`s total). I tried extending my grain and interface to have a method that takes the `EventContainer` and passes off inside that method to the method that takes each `BaseEventType` but of course I end up with no activated grain for that first `EventContainer`. There are other situations where I easily get more than 6 unique activations at once.

I've checked logs (I have both Microsoft.Extensions.Logging.Debug and Microsoft.Extensions.Logging.EventLog ILogger implementations added) and I'm not seeing any errors.
[orleans_log.txt](https://github.com/dotnet/orleans/files/2594380/orleans_log.txt)</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5179</IssueLabelID>
    <Title>How to deal with the relationship between the gateway and transmission entity？</Title>
    <Description>Main Silo (gateway) seems to be quoted all transport entities or the gateway will throw an exception.
`Fail: Orleans.Runtine.Messaging. IncomingMessageAcceptor[101027]ProcessReceivedBuffer exception with RemoteEndPoint 10.10.10.140:1886: System.TypeAccessException: Named type "Entity.GoodsEntity" is invalid: Type str ing "Entity.GoodsEntity" t be resolued.`
If so in the development each time a colleague modify transport entities to restart gateway?

</Description>
    <Title_Description>How to deal with the relationship between the gateway and transmission entity？ Main Silo (gateway) seems to be quoted all transport entities or the gateway will throw an exception.
`Fail: Orleans.Runtine.Messaging. IncomingMessageAcceptor[101027]ProcessReceivedBuffer exception with RemoteEndPoint 10.10.10.140:1886: System.TypeAccessException: Named type "Entity.GoodsEntity" is invalid: Type str ing "Entity.GoodsEntity" t be resolued.`
If so in the development each time a colleague modify transport entities to restart gateway?

</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5178</IssueLabelID>
    <Title>Expedite type map refresh after cluster membership change</Title>
    <Description>When a silo joins a cluster the cluster type map on other silos is not refreshed immediately.

This means that there is a delay between a new silo joining and the time that other silos begin placing grains on that new silo.

Emile van Reenen inquired about this on Gitter: https://gitter.im/dotnet/orleans?at=5bed7ef392b7d11721924cd5
</Description>
    <Title_Description>Expedite type map refresh after cluster membership change When a silo joins a cluster the cluster type map on other silos is not refreshed immediately.

This means that there is a delay between a new silo joining and the time that other silos begin placing grains on that new silo.

Emile van Reenen inquired about this on Gitter: https://gitter.im/dotnet/orleans?at=5bed7ef392b7d11721924cd5
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5177</IssueLabelID>
    <Title>Expected request rate to OrleansSilos table</Title>
    <Description>What rate/volume of requests can be expected to the OrleansSilos table?

Context:
We have a dev environment setup using DynamoDB for primary storage and for clustering. We are using default grain membership configuration. To save costs we have the provisioning limit set very low. We observed that with only a few users hitting the system we were hitting throttling on read requests to the OrleansSilos table.
One thing that might be impacting our workload is using `IManagementGrain` on a regular basis.

We can certainly increase the provisioning but are a bit concerned about how those accesses might scale.</Description>
    <Title_Description>Expected request rate to OrleansSilos table What rate/volume of requests can be expected to the OrleansSilos table?

Context:
We have a dev environment setup using DynamoDB for primary storage and for clustering. We are using default grain membership configuration. To save costs we have the provisioning limit set very low. We observed that with only a few users hitting the system we were hitting throttling on read requests to the OrleansSilos table.
One thing that might be impacting our workload is using `IManagementGrain` on a regular basis.

We can certainly increase the provisioning but are a bit concerned about how those accesses might scale.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5176</IssueLabelID>
    <Title>Update compatible_grains.md</Title>
    <Description>
    </Description>
    <Title_Description>Update compatible_grains.md </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5175</IssueLabelID>
    <Title>Lock worker error handling improvements</Title>
    <Description>
    </Description>
    <Title_Description>Lock worker error handling improvements </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5173</IssueLabelID>
    <Title>SMS stream resending last message to new subscribers</Title>
    <Description>A feature that I would really like to see implemented in SMS streams is the configurable option to have the stream resend the "most-recently-sent" message to any NEW subscriber.

In other words the stream would keep a copy of the last message sent on that stream and immediately send it when a NEW subscription is made just to that new subscription.

In this way messages can be sent periodically (or rarely) on an SMS stream and new subscribers can be brought immediately up to date with the last-sent-message when they subscribe without any extra plumbing code.

For my use case the "last-sent-message" would not need to be persisted. It could be just kept in memory but I see the advantage and disadvantages of storing it as well. If the SMS stream is having messages sent rapidly it would "slow down" the stream by writing every message to storage before sending it so if storage is to be used there may have to be some configuration regarding the "max write rate" to keep the stream running optimally at high messaging rates.

Can we add this feature to SMS streams? </Description>
    <Title_Description>SMS stream resending last message to new subscribers A feature that I would really like to see implemented in SMS streams is the configurable option to have the stream resend the "most-recently-sent" message to any NEW subscriber.

In other words the stream would keep a copy of the last message sent on that stream and immediately send it when a NEW subscription is made just to that new subscription.

In this way messages can be sent periodically (or rarely) on an SMS stream and new subscribers can be brought immediately up to date with the last-sent-message when they subscribe without any extra plumbing code.

For my use case the "last-sent-message" would not need to be persisted. It could be just kept in memory but I see the advantage and disadvantages of storing it as well. If the SMS stream is having messages sent rapidly it would "slow down" the stream by writing every message to storage before sending it so if storage is to be used there may have to be some configuration regarding the "max write rate" to keep the stream running optimally at high messaging rates.

Can we add this feature to SMS streams? </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5172</IssueLabelID>
    <Title>Failure to use stream providers with EventSequenceTokenV2</Title>
    <Description>Hey folks!

After migrate some codebase that worked properly using SMS _streams_ to AWS SQS provider I got this exception when trying to send/receive messages (both on client and silo):

```
[2018-11-08 19:22:54.095 UTC] hostid=XXXXXXXX env=dev shard=devtest proc=frontend level=WARN log=Orleans.InvokableObjectManager Exception during message body deserialization in LocalObjectMessagePumpAsync for message: Request S10.123.7.112:11111:279400800*stg/9856493027359806105/bae55299@Sbae55299-&gt;*cli/d9df2186@fab7c2bf77357389-7236-401d-b6a2-869be26fb1cf #1371:  Exception: System.Runtime.Serialization.SerializationException: Unsupported type 'Orleans.Providers.Streams.Common.EventSequenceTokenV2' encountered. Perhaps you need to mark it [Serializable] or define a custom serializer for it?
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at SQSBatchContainerDeserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeImmutable[T](Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeInvokeMethodRequest(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.InvokableObjectManager.&lt;LocalObjectMessagePumpAsync&gt;d__11.MoveNext()
```

The workaround as discussed with @sergeybykov was to add that type's assembly to the app parts list like this (both client and silo):

```
builder.AddApplicationPart(typeof(EventSequenceTokenV2 ).Assembly);
```

That unblocked us but it would be nice to get it fixed as it is an internal type from the runtime. I wonder if the codegen isn't generating code for it or if it does the assembly isn't being loaded by it.

For reference we are on Orleans 2.1.2 using the new source-to-source build time codegen.

Thanks!

</Description>
    <Title_Description>Failure to use stream providers with EventSequenceTokenV2 Hey folks!

After migrate some codebase that worked properly using SMS _streams_ to AWS SQS provider I got this exception when trying to send/receive messages (both on client and silo):

```
[2018-11-08 19:22:54.095 UTC] hostid=XXXXXXXX env=dev shard=devtest proc=frontend level=WARN log=Orleans.InvokableObjectManager Exception during message body deserialization in LocalObjectMessagePumpAsync for message: Request S10.123.7.112:11111:279400800*stg/9856493027359806105/bae55299@Sbae55299-&gt;*cli/d9df2186@fab7c2bf77357389-7236-401d-b6a2-869be26fb1cf #1371:  Exception: System.Runtime.Serialization.SerializationException: Unsupported type 'Orleans.Providers.Streams.Common.EventSequenceTokenV2' encountered. Perhaps you need to mark it [Serializable] or define a custom serializer for it?
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at SQSBatchContainerDeserializer(Type  IDeserializationContext )
   at Orleans.Serialization.ILBasedSerializer.Deserialize(Type expectedType IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeImmutable[T](Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeInvokeMethodRequest(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.InvokableObjectManager.&lt;LocalObjectMessagePumpAsync&gt;d__11.MoveNext()
```

The workaround as discussed with @sergeybykov was to add that type's assembly to the app parts list like this (both client and silo):

```
builder.AddApplicationPart(typeof(EventSequenceTokenV2 ).Assembly);
```

That unblocked us but it would be nice to get it fixed as it is an internal type from the runtime. I wonder if the codegen isn't generating code for it or if it does the assembly isn't being loaded by it.

For reference we are on Orleans 2.1.2 using the new source-to-source build time codegen.

Thanks!

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5171</IssueLabelID>
    <Title>Is't possible to access TransactionalState in non-transactional method?</Title>
    <Description>I asked at [gitter](https://gitter.im/dotnet/orleans)
```
Hello I'm planning to use TransactionalState and found out
every request that access to TransactionalState should be part of a Transaction.
Is there any ways to read-only access TransactionalState in non-transaction request?
```

@sergeybykov answered
```
In order to provide isolation reads must be transactional
 Otherwise the grain might return a state that is not yet committed or would never be committed.
I guess you can always have a separate non-transactional copy for non-transactional methods
that can do dirty reads.
```</Description>
    <Title_Description>Is't possible to access TransactionalState in non-transactional method? I asked at [gitter](https://gitter.im/dotnet/orleans)
```
Hello I'm planning to use TransactionalState and found out
every request that access to TransactionalState should be part of a Transaction.
Is there any ways to read-only access TransactionalState in non-transaction request?
```

@sergeybykov answered
```
In order to provide isolation reads must be transactional
 Otherwise the grain might return a state that is not yet committed or would never be committed.
I guess you can always have a separate non-transactional copy for non-transactional methods
that can do dirty reads.
```</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5170</IssueLabelID>
    <Title>Add SubscriptionObserverWithImplicitSubscribingGrainTests</Title>
    <Description>add tests cover ISubscriptionObserver used with ImplicitSubsribe</Description>
    <Title_Description>Add SubscriptionObserverWithImplicitSubscribingGrainTests add tests cover ISubscriptionObserver used with ImplicitSubsribe</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5169</IssueLabelID>
    <Title>[Question] Writing to storage performance</Title>
    <Description>Hi everyone! I have following scenario: ClusterClient read events from EventHub and then send them to the Orleans. One grain takes those batches groups them by the key and then send to the second grain which writes to Blob Storage (append blob - one blob for one key). 

I have implementation of this (stateless workers) and everything works fine when key granularity is low. (we make less connection to blobs writing grouped batches). 

But when granularity of key grow (for example in worst scenario we can have one event - one key) bad things start happen and everything chocks up. I understand that this is due to almost one event - one write to blob but i wonder what optimizations can be done here to improve this. 

I tried raising DefaultConnectionLimit play with number of activation of statlessworkers but i can't go beyond of 250 messages per second on single machine (Azure Standard F8s_v2 (8 vcpus 16 GB memory)). This is with default settings. 

To contrast that when i choose one single key to write everything to the same blob in batches (exact same batch which was received in EventHubProccesorHost) i can achieve 25k messages per second on the same machine and have almost half cpu % reserve. Of course the number of writes to the blob storage is far less than 25k messages as single write has up to 1024 messages).
Quotas on blob storage says that it can achieve 20k requests per second. 
Do you have idea how to improve this? How many concurrent connection to the blob one single machine can achieve?

big picture:

![orleanstopology](https://user-images.githubusercontent.com/4254758/48219499-f5966180-e38c-11e8-9cb0-ccfee0b4cd7c.png)

Few notes: 
- Everything is async/await</Description>
    <Title_Description>[Question] Writing to storage performance Hi everyone! I have following scenario: ClusterClient read events from EventHub and then send them to the Orleans. One grain takes those batches groups them by the key and then send to the second grain which writes to Blob Storage (append blob - one blob for one key). 

I have implementation of this (stateless workers) and everything works fine when key granularity is low. (we make less connection to blobs writing grouped batches). 

But when granularity of key grow (for example in worst scenario we can have one event - one key) bad things start happen and everything chocks up. I understand that this is due to almost one event - one write to blob but i wonder what optimizations can be done here to improve this. 

I tried raising DefaultConnectionLimit play with number of activation of statlessworkers but i can't go beyond of 250 messages per second on single machine (Azure Standard F8s_v2 (8 vcpus 16 GB memory)). This is with default settings. 

To contrast that when i choose one single key to write everything to the same blob in batches (exact same batch which was received in EventHubProccesorHost) i can achieve 25k messages per second on the same machine and have almost half cpu % reserve. Of course the number of writes to the blob storage is far less than 25k messages as single write has up to 1024 messages).
Quotas on blob storage says that it can achieve 20k requests per second. 
Do you have idea how to improve this? How many concurrent connection to the blob one single machine can achieve?

big picture:

![orleanstopology](https://user-images.githubusercontent.com/4254758/48219499-f5966180-e38c-11e8-9cb0-ccfee0b4cd7c.png)

Few notes: 
- Everything is async/await</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5167</IssueLabelID>
    <Title>Fix test cluster deploy deadlock</Title>
    <Description>Fixes https://github.com/dotnet/orleans/issues/5166  but has some breacking changes public test APIs</Description>
    <Title_Description>Fix test cluster deploy deadlock Fixes https://github.com/dotnet/orleans/issues/5166  but has some breacking changes public test APIs</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5166</IssueLabelID>
    <Title>Orleans TestCluster Deploy causes deadlock with xUnit</Title>
    <Description>In case of trying run TestCluster Deploy parallel with xUnit deadlock occured.

Steps to reproduce:
1) Create as many simple classes as you have logical processors or more (i.e i have 8 logical processors i need to create 8 or more same classes)
```   
 public class Class1
    {
        [Fact TestCategory("Functional")]
        public async Task Test()
        {
            var builder = new TestClusterBuilder(2);
            builder.Options.ServiceId = Guid.NewGuid().ToString();
            builder.ConfigureHostConfiguration(TestDefaultConfiguration.ConfigureHostConfiguration);
            var testCluster = builder.Build();

            await testCluster.DeployAsync();
        }
    }
```
2) Run all tests from created classes with xUnit

Result: deadlock at https://github.com/dotnet/orleans/blob/master/src/Orleans.TestingHost/InProcessSiloHandle.cs#L34

I think xUnit custom SyncronizationContext not allows such way of executing async metod result. I have solution with full async flow but it can break public testing API.</Description>
    <Title_Description>Orleans TestCluster Deploy causes deadlock with xUnit In case of trying run TestCluster Deploy parallel with xUnit deadlock occured.

Steps to reproduce:
1) Create as many simple classes as you have logical processors or more (i.e i have 8 logical processors i need to create 8 or more same classes)
```   
 public class Class1
    {
        [Fact TestCategory("Functional")]
        public async Task Test()
        {
            var builder = new TestClusterBuilder(2);
            builder.Options.ServiceId = Guid.NewGuid().ToString();
            builder.ConfigureHostConfiguration(TestDefaultConfiguration.ConfigureHostConfiguration);
            var testCluster = builder.Build();

            await testCluster.DeployAsync();
        }
    }
```
2) Run all tests from created classes with xUnit

Result: deadlock at https://github.com/dotnet/orleans/blob/master/src/Orleans.TestingHost/InProcessSiloHandle.cs#L34

I think xUnit custom SyncronizationContext not allows such way of executing async metod result. I have solution with full async flow but it can break public testing API.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5165</IssueLabelID>
    <Title>[Question] EventStore Read-only stream adapter</Title>
    <Description>Hi. Im trying use Orleans for CQRS - EventSource pattern. I want grains to persist their state in EventStore.
That part is pretty obvious - we can use OnActivate and load all neccesery events and build Grain State.
But when Grain publish new Event to the EventStore we want to subscribe to this events in other Grains and it seems that great option is use Orleans Streams with own custom adapter which is read-only and read via subscriptions new events from EventStore streams and pushes them to the subscribed grains.
I want to try write this stream adapter. 
My first concern is - a queueID and it's concept and how this should map to the EventStore inftrastrucute. 
EventStore only contains streams - we can subscribe to them. How to achieve this with QueueID concept in Orleans? It should be one queue for each stream? What piece of code decide how many queues will be created? Can anyone guide me here? 
</Description>
    <Title_Description>[Question] EventStore Read-only stream adapter Hi. Im trying use Orleans for CQRS - EventSource pattern. I want grains to persist their state in EventStore.
That part is pretty obvious - we can use OnActivate and load all neccesery events and build Grain State.
But when Grain publish new Event to the EventStore we want to subscribe to this events in other Grains and it seems that great option is use Orleans Streams with own custom adapter which is read-only and read via subscriptions new events from EventStore streams and pushes them to the subscribed grains.
I want to try write this stream adapter. 
My first concern is - a queueID and it's concept and how this should map to the EventStore inftrastrucute. 
EventStore only contains streams - we can subscribe to them. How to achieve this with QueueID concept in Orleans? It should be one queue for each stream? What piece of code decide how many queues will be created? Can anyone guide me here? 
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5164</IssueLabelID>
    <Title>[Question] The case for Orleans streams</Title>
    <Description>Hello colleagues

I'm evaluating the usage of `orleans` at the project and would like to clarify a couple of things about `orleans` streams design. I'm familiar with actor model in general (some BEAM VM background with Erlang/Elixir) but still completely new with `orleans` as only went through the doc. Sadly there is no graphical schemas in the docs that could make them more clear.

## Intro 
What I'm trying to do it to understand `orleans` streams based on the practical task. We have a bunch of microservices in the system that will be responsible for producing events of different types. Number of event types are limited (~ 20). The goal is to build a notification system (webhooks) where clients could subscribe to certain types of events.

## Parties

Producers - generate events of certain types the number is limited is will be &lt; 20;
Events - limited number of event types (~20);
Grains - represents subscriptions (consumers) where each subscription could listen to one or more event types and all of them are of the same grain type; the number of subscriptions is much bigger (hundreds and thousands);

## Schemas

### Case 1 Topology

![event_stream_1](https://user-images.githubusercontent.com/5213282/48087607-d7a3f200-e210-11e8-8036-594bded9e978.png)

All grains are of the same type and stateful. In this case each grain (1 2 ... n) will subscribe to certain event types. As far as I understand from the documentation the subscription handles that are used for resuming subscriptions are defined on the stream level. As a result in order to continue the processing correctly as part of the activation the grain should save subscription handles somewhere in its state and use them instead of calling `GetAllSubscriptionHandles`.

**Question**: Is this a correct understanding or subscription handles depend on the grain instance as well - somehow capture the grain instance identity (1 2 .. n) implicitly and `GetAllSubscriptionHandles` will return handles for this particular stream + grain instance?

Besides I have an impression that such approach where we have a lot of consumers and limited number of streams does not play well with the design of `orleans` streams. As a result I've come to the case 2.

### Case 2 Topology

![event_stream_2](https://user-images.githubusercontent.com/5213282/48088436-0cb14400-e213-11e8-866a-7f5797adfa04.png)

There are two types of grains:
+ yellow - subscription processing grains that are responsible for event processing; each such grain has a particular stream that contain events of different types in which this grain is interested in;
+ grey - distributors - they gather events of a particular type and distribute them across yellow grain streams;

With such approach we have a limited number of grey distributor grains that push events to a large number of streams for processing. This seems to be the case for `orleans` streams. There will be no issue with `GetAllSubscriptionHandles` as each stream will be unique for a subscription processing grain instance (1 2 ... n). 

What bothers me here:
+ each grey grain will have to keep a mapping between event type and yellow grain stream identity and this could become potentially a big thing; as far as I understand this could be distributed more with some sort of sharding;
+ events will have more hops as it will first trap into a distributor and next from distributor to the subscription processing stream;

**Question**: Is my understand correct and `orleans` is primarily designed to have a lot of relatively small streams and in cases where we have a small number of event types and large number of consumers we need to distribute such work by creating a lot of streams?

Thanks. </Description>
    <Title_Description>[Question] The case for Orleans streams Hello colleagues

I'm evaluating the usage of `orleans` at the project and would like to clarify a couple of things about `orleans` streams design. I'm familiar with actor model in general (some BEAM VM background with Erlang/Elixir) but still completely new with `orleans` as only went through the doc. Sadly there is no graphical schemas in the docs that could make them more clear.

## Intro 
What I'm trying to do it to understand `orleans` streams based on the practical task. We have a bunch of microservices in the system that will be responsible for producing events of different types. Number of event types are limited (~ 20). The goal is to build a notification system (webhooks) where clients could subscribe to certain types of events.

## Parties

Producers - generate events of certain types the number is limited is will be &lt; 20;
Events - limited number of event types (~20);
Grains - represents subscriptions (consumers) where each subscription could listen to one or more event types and all of them are of the same grain type; the number of subscriptions is much bigger (hundreds and thousands);

## Schemas

### Case 1 Topology

![event_stream_1](https://user-images.githubusercontent.com/5213282/48087607-d7a3f200-e210-11e8-8036-594bded9e978.png)

All grains are of the same type and stateful. In this case each grain (1 2 ... n) will subscribe to certain event types. As far as I understand from the documentation the subscription handles that are used for resuming subscriptions are defined on the stream level. As a result in order to continue the processing correctly as part of the activation the grain should save subscription handles somewhere in its state and use them instead of calling `GetAllSubscriptionHandles`.

**Question**: Is this a correct understanding or subscription handles depend on the grain instance as well - somehow capture the grain instance identity (1 2 .. n) implicitly and `GetAllSubscriptionHandles` will return handles for this particular stream + grain instance?

Besides I have an impression that such approach where we have a lot of consumers and limited number of streams does not play well with the design of `orleans` streams. As a result I've come to the case 2.

### Case 2 Topology

![event_stream_2](https://user-images.githubusercontent.com/5213282/48088436-0cb14400-e213-11e8-866a-7f5797adfa04.png)

There are two types of grains:
+ yellow - subscription processing grains that are responsible for event processing; each such grain has a particular stream that contain events of different types in which this grain is interested in;
+ grey - distributors - they gather events of a particular type and distribute them across yellow grain streams;

With such approach we have a limited number of grey distributor grains that push events to a large number of streams for processing. This seems to be the case for `orleans` streams. There will be no issue with `GetAllSubscriptionHandles` as each stream will be unique for a subscription processing grain instance (1 2 ... n). 

What bothers me here:
+ each grey grain will have to keep a mapping between event type and yellow grain stream identity and this could become potentially a big thing; as far as I understand this could be distributed more with some sort of sharding;
+ events will have more hops as it will first trap into a distributor and next from distributor to the subscription processing stream;

**Question**: Is my understand correct and `orleans` is primarily designed to have a lot of relatively small streams and in cases where we have a small number of event types and large number of consumers we need to distribute such work by creating a lot of streams?

Thanks. </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5163</IssueLabelID>
    <Title>OrleansMessageRejectionException Forwarding failure</Title>
    <Description>Orleans 1.5.0

```
Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S10.240.2.203:11112:278616633ProviderManagerSystemTarget@S00000013-&gt;S10.240.2.203:11112:278616633*grn/67B8C418/00000000@6e4b5ba9 #1387[ForwardCount=2]: global::ServiceClient.Context.ISegmentRepository:GetSegments() for 2 times after Non-existent activation to invalid activation. Rejecting now. 
```

Occurs periodically on both single and multi silo environments.

Exception occurs from a `Grain` to a `StatelessWorker(1)` call.</Description>
    <Title_Description>OrleansMessageRejectionException Forwarding failure Orleans 1.5.0

```
Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S10.240.2.203:11112:278616633ProviderManagerSystemTarget@S00000013-&gt;S10.240.2.203:11112:278616633*grn/67B8C418/00000000@6e4b5ba9 #1387[ForwardCount=2]: global::ServiceClient.Context.ISegmentRepository:GetSegments() for 2 times after Non-existent activation to invalid activation. Rejecting now. 
```

Occurs periodically on both single and multi silo environments.

Exception occurs from a `Grain` to a `StatelessWorker(1)` call.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5162</IssueLabelID>
    <Title>cannot call from inside of grain</Title>
    <Description>It could look like dumb but I could not solve the problem and found nowhere but here to ask.

I'm planning to use the Orleans and testing some simple codes.
The Grain implementation is something similar to the codes to this.
```
public class TestGrain : Orleans.Grain ITestGrain
{
    private readonly ILogger logger;

    public TestGrain(ILogger&lt;TestGrain&gt; logger)
    {
        this.logger = logger;
    }

    Task&lt;bool&gt; FirstCall(int secondGrainId)
    {
        var secondGrain = GrainFactory.GetGrain&lt;ITestGrain&gt;(secondGrainId);
        var response = secondGrain.SecondCall();
        this.logger.LogInformation("Responded");
        return response;
    }

    Task&lt;bool&gt; SecondCall()
    {
        this.logger.LogInformation("SecondCall called");
        return Task.FromResult(true);
    }
}
```

I could see "SecondCall called". but couldn't see "Responded".
I tried to get some informations from debug log but there was nothing (at least on my thought).
Could you help me out?</Description>
    <Title_Description>cannot call from inside of grain It could look like dumb but I could not solve the problem and found nowhere but here to ask.

I'm planning to use the Orleans and testing some simple codes.
The Grain implementation is something similar to the codes to this.
```
public class TestGrain : Orleans.Grain ITestGrain
{
    private readonly ILogger logger;

    public TestGrain(ILogger&lt;TestGrain&gt; logger)
    {
        this.logger = logger;
    }

    Task&lt;bool&gt; FirstCall(int secondGrainId)
    {
        var secondGrain = GrainFactory.GetGrain&lt;ITestGrain&gt;(secondGrainId);
        var response = secondGrain.SecondCall();
        this.logger.LogInformation("Responded");
        return response;
    }

    Task&lt;bool&gt; SecondCall()
    {
        this.logger.LogInformation("SecondCall called");
        return Task.FromResult(true);
    }
}
```

I could see "SecondCall called". but couldn't see "Responded".
I tried to get some informations from debug log but there was nothing (at least on my thought).
Could you help me out?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5161</IssueLabelID>
    <Title>The orleans client connection to the silo often occurs timeout</Title>
    <Description>I have developed a product using the Orleans .net core version which uses .net core
 webapi is connected to Silo(server side) as a client. Unfortunately some problems occurred after the product went online that is the orleans client connect to the silo often (about every half a day) occurs timeout.The following error messages appear in the log:

`Orleans.Runtime.CallbackData Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S10.123.6.17:11111:278069385*grn/F8588497/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@38484092-&gt;S10.123.6.17:11111:278069385*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@757ca091 #1966753: . Target History is: &lt;S10.123.6.17:11111:278069385:*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4:@757ca091&gt;. About to break its promise.`

After the above situation the entire product becomes unavailable.I initially thought from the above log that the webapi client could not connect to the silo server but I don't know what caused the problem.I searched a lot of relevant information but still can't solve the problem.Currently I have to make the product available by restarting Silo.

The following is the starting Silo code in the Silo server side of the product:

```csharp
private static async Task&lt;ISiloHost&gt; StartConsulSilo()
        {
            var orleansCluster = GetOrleansClusterOptions();
            var siloServerOptions = GetSiloServerOptions();

            var builder = new SiloHostBuilder()
                .Configure&lt;EndpointOptions&gt;(ConfigureSiloOptions)
                .Configure&lt;ClusterOptions&gt;(options =&gt; { options.ClusterId = orleansCluster.ClusterId; options.ServiceId = siloServerOptions.ServiceId; })
                .UseConsulClustering(options =&gt; { options.Address = new Uri(orleansCluster.ConsulAddress); })
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(CacheGrain&lt;&gt;).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(UserGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AuditGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(TaskGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ProductGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ParameterGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(FtpGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(BaseFileGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(TaskFileGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(RoleGrain).Assembly).WithReferences())
                .ConfigureLogging(logging =&gt; logging.AddNLog())
                .ConfigureServices(services =&gt;
                {
                    services.UseNLog("nlog.config");
                    services.AddTransient&lt;IDbContext DefaultDbContext&gt;();
                    services.AddSingleton&lt;IAppFolders&gt;(SetAppFolders());
                })
                .AddMongoDBGrainStorageAsDefault(options =&gt;
                {
                    var mongoOptions = new MongoOptions();
                    hostConfiguration.GetSection("MongoDB").Bind(mongoOptions);
                    options.Configure(config =&gt;
                    {
                        config.ConnectionString = mongoOptions.ConnectionString;
                        config.DatabaseName = mongoOptions.DatabaseName;
                        config.CollectionPrefix = "State_";
                    });
                });

            var host = builder.Build();
            await host.StartAsync();
            return host;
        }
```

The following is the connecting Silo code in the webapi client of the product:

```csharp
private static async Task&lt;IClusterClient&gt; StartClientWithRetries(ILogger&lt;Startup&gt; logger int initAttemptBeforeFailing = 5)
        {
            int attempt = 0;
            IClusterClient client;
            var orleansCluster = GetOrleansClusterOptions();

            while (true)
            {
                try
                {
                    client = new ClientBuilder()
                        .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = orleansCluster.ClusterId)
                        .UseConsulClustering(gatewayOptions =&gt; { gatewayOptions.Address = new Uri(orleansCluster.ConsulAddress); })
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICacheGrain&lt;&gt;).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IUserGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IAuditGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITaskGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IProductGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IParameterGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IModuleGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IDfsGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IBaseFileGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITaskFileGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IRoleGrain).Assembly).WithReferences())
                        .ConfigureLogging(logging =&gt;
                        {
                            logging.ClearProviders();
                            logging.AddNLog();
                        })
                        .Build();

                    await client.Connect();

                    logger.Info("The client successfully connected to the silo");
                    break;
                }
                catch (SiloUnavailableException ex)
                {
                    attempt++;
                    logger.LogError(ex $"Trying to initialize the Orleans client fails {attempt}/{initAttemptBeforeFailing}");

                    if (attempt &gt; initAttemptBeforeFailing)
                    {
                        throw ex;
                    }

                    await Task.Delay(TimeSpan.FromSeconds(3));
                }
            }

            return client;
  }
```

Have you encountered this situation? Is the way I use the client and server as it is correct? 
I am looking forward to your help so that I can solve this problem as soon as possible.Thank you.</Description>
    <Title_Description>The orleans client connection to the silo often occurs timeout I have developed a product using the Orleans .net core version which uses .net core
 webapi is connected to Silo(server side) as a client. Unfortunately some problems occurred after the product went online that is the orleans client connect to the silo often (about every half a day) occurs timeout.The following error messages appear in the log:

`Orleans.Runtime.CallbackData Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S10.123.6.17:11111:278069385*grn/F8588497/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@38484092-&gt;S10.123.6.17:11111:278069385*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@757ca091 #1966753: . Target History is: &lt;S10.123.6.17:11111:278069385:*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4:@757ca091&gt;. About to break its promise.`

After the above situation the entire product becomes unavailable.I initially thought from the above log that the webapi client could not connect to the silo server but I don't know what caused the problem.I searched a lot of relevant information but still can't solve the problem.Currently I have to make the product available by restarting Silo.

The following is the starting Silo code in the Silo server side of the product:

```csharp
private static async Task&lt;ISiloHost&gt; StartConsulSilo()
        {
            var orleansCluster = GetOrleansClusterOptions();
            var siloServerOptions = GetSiloServerOptions();

            var builder = new SiloHostBuilder()
                .Configure&lt;EndpointOptions&gt;(ConfigureSiloOptions)
                .Configure&lt;ClusterOptions&gt;(options =&gt; { options.ClusterId = orleansCluster.ClusterId; options.ServiceId = siloServerOptions.ServiceId; })
                .UseConsulClustering(options =&gt; { options.Address = new Uri(orleansCluster.ConsulAddress); })
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(CacheGrain&lt;&gt;).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(UserGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AuditGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(TaskGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ProductGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ParameterGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(FtpGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(BaseFileGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(TaskFileGrain).Assembly).WithReferences())
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(RoleGrain).Assembly).WithReferences())
                .ConfigureLogging(logging =&gt; logging.AddNLog())
                .ConfigureServices(services =&gt;
                {
                    services.UseNLog("nlog.config");
                    services.AddTransient&lt;IDbContext DefaultDbContext&gt;();
                    services.AddSingleton&lt;IAppFolders&gt;(SetAppFolders());
                })
                .AddMongoDBGrainStorageAsDefault(options =&gt;
                {
                    var mongoOptions = new MongoOptions();
                    hostConfiguration.GetSection("MongoDB").Bind(mongoOptions);
                    options.Configure(config =&gt;
                    {
                        config.ConnectionString = mongoOptions.ConnectionString;
                        config.DatabaseName = mongoOptions.DatabaseName;
                        config.CollectionPrefix = "State_";
                    });
                });

            var host = builder.Build();
            await host.StartAsync();
            return host;
        }
```

The following is the connecting Silo code in the webapi client of the product:

```csharp
private static async Task&lt;IClusterClient&gt; StartClientWithRetries(ILogger&lt;Startup&gt; logger int initAttemptBeforeFailing = 5)
        {
            int attempt = 0;
            IClusterClient client;
            var orleansCluster = GetOrleansClusterOptions();

            while (true)
            {
                try
                {
                    client = new ClientBuilder()
                        .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = orleansCluster.ClusterId)
                        .UseConsulClustering(gatewayOptions =&gt; { gatewayOptions.Address = new Uri(orleansCluster.ConsulAddress); })
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICacheGrain&lt;&gt;).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IUserGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IAuditGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITaskGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IProductGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IParameterGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IModuleGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IDfsGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IBaseFileGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITaskFileGrain).Assembly).WithReferences())
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IRoleGrain).Assembly).WithReferences())
                        .ConfigureLogging(logging =&gt;
                        {
                            logging.ClearProviders();
                            logging.AddNLog();
                        })
                        .Build();

                    await client.Connect();

                    logger.Info("The client successfully connected to the silo");
                    break;
                }
                catch (SiloUnavailableException ex)
                {
                    attempt++;
                    logger.LogError(ex $"Trying to initialize the Orleans client fails {attempt}/{initAttemptBeforeFailing}");

                    if (attempt &gt; initAttemptBeforeFailing)
                    {
                        throw ex;
                    }

                    await Task.Delay(TimeSpan.FromSeconds(3));
                }
            }

            return client;
  }
```

Have you encountered this situation? Is the way I use the client and server as it is correct? 
I am looking forward to your help so that I can solve this problem as soon as possible.Thank you.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5160</IssueLabelID>
    <Title>The SocketAsyncEventArgs.Buffer is not cleared when it's returned to the pool.</Title>
    <Description>The Buffer of the SocketAsyncEventArgs is not cleared when it's returned to the pool. When this args is used for the next time the old buffer which may contains the legacy data will still be passed to IncomingMessageBuffer.UpdateReceivedData. Then if the IncomingMessageBuffer wanted to read "e.BytesTransferred" bytes from the Buffer it might get the old message.

This code should be added to the method below.
`
Array.Clear(args.Buffer 0 args.Buffer.Length);

args.SetBuffer(0 args.Buffer.Length);
`

https://github.com/dotnet/orleans/blob/6b802f6365e78d691430360a4101b1993eb7afee/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L441

==

Update: There could be another bug in .net core runtime on linux. After I called SetBuffer and when it triggered the OnCompleted event the BytesTransferred is not zero but the args.Offset is zero.

Maybe it could be solved if we don't use a pool</Description>
    <Title_Description>The SocketAsyncEventArgs.Buffer is not cleared when it's returned to the pool. The Buffer of the SocketAsyncEventArgs is not cleared when it's returned to the pool. When this args is used for the next time the old buffer which may contains the legacy data will still be passed to IncomingMessageBuffer.UpdateReceivedData. Then if the IncomingMessageBuffer wanted to read "e.BytesTransferred" bytes from the Buffer it might get the old message.

This code should be added to the method below.
`
Array.Clear(args.Buffer 0 args.Buffer.Length);

args.SetBuffer(0 args.Buffer.Length);
`

https://github.com/dotnet/orleans/blob/6b802f6365e78d691430360a4101b1993eb7afee/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L441

==

Update: There could be another bug in .net core runtime on linux. After I called SetBuffer and when it triggered the OnCompleted event the BytesTransferred is not zero but the args.Offset is zero.

Maybe it could be solved if we don't use a pool</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5158</IssueLabelID>
    <Title>Client connection using AdoNetClustering  fails on Docker container</Title>
    <Description>- Used Orleans 2.1.0. 
- Run on .NET Core 2.1 Docker linux container.

[orleans.log](https://github.com/dotnet/orleans/files/2542565/orleans.log)
(frontend is Orleans Client app. backend is silo. Db is Postgresql)

Using StaticClustering configuration runs perfectly.

I saw an issue similar with this at https://github.com/Azure/service-fabric-issues/issues/1182</Description>
    <Title_Description>Client connection using AdoNetClustering  fails on Docker container - Used Orleans 2.1.0. 
- Run on .NET Core 2.1 Docker linux container.

[orleans.log](https://github.com/dotnet/orleans/files/2542565/orleans.log)
(frontend is Orleans Client app. backend is silo. Db is Postgresql)

Using StaticClustering configuration runs perfectly.

I saw an issue similar with this at https://github.com/Azure/service-fabric-issues/issues/1182</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5157</IssueLabelID>
    <Title>Is it possible to cross the LAN</Title>
    <Description>I wonder if the two lans can communicate with him
I've tried non-reliable deployments and the problem is that my primary repository can only use UseLocalhostClustering() which is 127.0.0.1 and seems inaccessible to outsiders</Description>
    <Title_Description>Is it possible to cross the LAN I wonder if the two lans can communicate with him
I've tried non-reliable deployments and the problem is that my primary repository can only use UseLocalhostClustering() which is 127.0.0.1 and seems inaccessible to outsiders</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5156</IssueLabelID>
    <Title>System.NotSupportedException: Call cannot be made outside of a transaction.  </Title>
    <Description>i use interceptor and transactionsit runs wrong. how do i solve thank you</Description>
    <Title_Description>System.NotSupportedException: Call cannot be made outside of a transaction.   i use interceptor and transactionsit runs wrong. how do i solve thank you</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5155</IssueLabelID>
    <Title>add tests to the transactional state storage test kit</Title>
    <Description>Adds a bunch of tests. This is not necessarily a complete suite yet but it covers much of the (prepare/confirm/cancel) logic including some batching.</Description>
    <Title_Description>add tests to the transactional state storage test kit Adds a bunch of tests. This is not necessarily a complete suite yet but it covers much of the (prepare/confirm/cancel) logic including some batching.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5149</IssueLabelID>
    <Title>Internal transactional states are now immutable</Title>
    <Description>Internal transactional states are now immutable outside transactional operations.</Description>
    <Title_Description>Internal transactional states are now immutable Internal transactional states are now immutable outside transactional operations.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5147</IssueLabelID>
    <Title>Unexpected token 'Error' introducing type specifier when calling grain method. </Title>
    <Description>Hi! Im getting
"Unexpected token 'Error' introducing type specifier " every time when i call method Recieve on my grain  which have following signature:

```
Task Recieve(IEnumerable&lt;GrainsInterfaces.EventData&gt; messages)

public class EventData
    {
        public ArraySegment&lt;byte&gt; Body { get; set; }

        public IDictionary&lt;string object&gt; Properties { get; set; }

        public SystemPropertiesCollection SystemProperties { get; set; }

        public sealed class SystemPropertiesCollection : Dictionary&lt;string object&gt;
        {
            public long SequenceNumber { get; set; }

            public DateTime EnqueuedTimeUtc { get; set; }

            public string Offset { get; set; }

            public string PartitionKey { get; set; }
        }
    }
```

Grain has  [StatelessWorker] and [Reentrant] attributes.

Other method which has simplier signature:

 Task&lt;string&gt; SayHello(string greetings) works ok.

Do you know what can cause this? Is there any limitation if comes to data contract? </Description>
    <Title_Description>Unexpected token 'Error' introducing type specifier when calling grain method.  Hi! Im getting
"Unexpected token 'Error' introducing type specifier " every time when i call method Recieve on my grain  which have following signature:

```
Task Recieve(IEnumerable&lt;GrainsInterfaces.EventData&gt; messages)

public class EventData
    {
        public ArraySegment&lt;byte&gt; Body { get; set; }

        public IDictionary&lt;string object&gt; Properties { get; set; }

        public SystemPropertiesCollection SystemProperties { get; set; }

        public sealed class SystemPropertiesCollection : Dictionary&lt;string object&gt;
        {
            public long SequenceNumber { get; set; }

            public DateTime EnqueuedTimeUtc { get; set; }

            public string Offset { get; set; }

            public string PartitionKey { get; set; }
        }
    }
```

Grain has  [StatelessWorker] and [Reentrant] attributes.

Other method which has simplier signature:

 Task&lt;string&gt; SayHello(string greetings) works ok.

Do you know what can cause this? Is there any limitation if comes to data contract? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5146</IssueLabelID>
    <Title>Make the logs to print more clear Grain/Interface identity.</Title>
    <Description>I'm trying to diagnose several performance issues like _from nothing_ the silo starts to eat 100% CPU and profiling on async code is a nightmare...

Thousands of those messages are printed when the scenario happens:

`[2018-10-24 12:59:34.308 UTC] hostid=XXXXXXXXX env=dev shard=devsvc proc=silo level=WARN log=Orleans.Runtime.CallbackData Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S10.123.6.17:11111:278069385*grn/F8588497/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@38484092-&gt;S10.123.6.17:11111:278069385*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@757ca091 #1966753: . Target History is: &lt;S10.123.6.17:11111:278069385:*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4:@757ca091&gt;. About to break its promise.`


Among others where the TypeCode (i.e. `*grn/F8588497/`) is printed on it but we don't have it referenced anywhere in code being generated because codegen stores the interfaceId IIRC...

So what we are trying to do is to have a way to map those IDs to our grains so at our log server we can make it replace the IDs at the logs on-the-fly so it can help us detect issues.
</Description>
    <Title_Description>Make the logs to print more clear Grain/Interface identity. I'm trying to diagnose several performance issues like _from nothing_ the silo starts to eat 100% CPU and profiling on async code is a nightmare...

Thousands of those messages are printed when the scenario happens:

`[2018-10-24 12:59:34.308 UTC] hostid=XXXXXXXXX env=dev shard=devsvc proc=silo level=WARN log=Orleans.Runtime.CallbackData Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S10.123.6.17:11111:278069385*grn/F8588497/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@38484092-&gt;S10.123.6.17:11111:278069385*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4@757ca091 #1966753: . Target History is: &lt;S10.123.6.17:11111:278069385:*grn/9C2A0175/00000000+cf03f099-e162-41e3-9d12-abc02245aea4:@757ca091&gt;. About to break its promise.`


Among others where the TypeCode (i.e. `*grn/F8588497/`) is printed on it but we don't have it referenced anywhere in code being generated because codegen stores the interfaceId IIRC...

So what we are trying to do is to have a way to map those IDs to our grains so at our log server we can make it replace the IDs at the logs on-the-fly so it can help us detect issues.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5145</IssueLabelID>
    <Title>Fix call chain reentrancy</Title>
    <Description>Current behavior is to only allow call chain re-entrancy on A-&gt;B-&gt;A or A-&gt;A. This adds a new option for allowing A-&gt;B-&gt;C-&gt;A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the application layer.

* Refactor re-entrancy tests to use common code
* Change bool to enum in config and introduce new option CallChainReentrancyStrategy.EntireChain

Passes call chain tests. Sending an early version for feedback on the approach.

Remaining questions:
* Do we want to reconcile the code for Single Call and full call chain?
* Do we want to eliminate the option for single call (probably needs perf testing to determine impact)
* Still need to figure out logging in tests</Description>
    <Title_Description>Fix call chain reentrancy Current behavior is to only allow call chain re-entrancy on A-&gt;B-&gt;A or A-&gt;A. This adds a new option for allowing A-&gt;B-&gt;C-&gt;A. Also flow the reentrancy context via RequestContext so that it can be viewed and serialized by the application layer.

* Refactor re-entrancy tests to use common code
* Change bool to enum in config and introduce new option CallChainReentrancyStrategy.EntireChain

Passes call chain tests. Sending an early version for feedback on the approach.

Remaining questions:
* Do we want to reconcile the code for Single Call and full call chain?
* Do we want to eliminate the option for single call (probably needs perf testing to determine impact)
* Still need to figure out logging in tests</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5144</IssueLabelID>
    <Title>Document hosted client</Title>
    <Description>Need to add a documentation page for #3362.</Description>
    <Title_Description>Document hosted client Need to add a documentation page for #3362.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5142</IssueLabelID>
    <Title>Error: Extension not installed on grain attempting to invoke type OrleansCodeGenCancellationSourcesExtensionMethodInvoker</Title>
    <Description>During calling to GrainCancellationTokenSource.Cancel I have following error.
I use GrainCancellationToken for aborting long running operation. 
What is missing? Thanks

```C#

Orleans.Runtime.GrainExtensionNotInstalledException
  HResult=0x80131500
  Message=Extension not installed on grain Server.Grains.ProgressWatcherGrain attempting to invoke type Orleans.Runtime.OrleansCodeGenCancellationSourcesExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData
  Source=Orleans.Runtime
  StackTrace:
   at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__62.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AsyncExecutorWithRetries.&lt;&gt;c__DisplayClass1_0.&lt;&lt;ExecuteWithRetries&gt;b__0&gt;d.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AsyncExecutorWithRetries.&lt;ExecuteWithRetriesHelper&gt;d__4`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at Orleans.AsyncExecutorWithRetries.&lt;ExecuteWithRetriesHelper&gt;d__4`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Server.Grains.ProjectGrain.&lt;AbortProject&gt;d__20.MoveNext()


```</Description>
    <Title_Description>Error: Extension not installed on grain attempting to invoke type OrleansCodeGenCancellationSourcesExtensionMethodInvoker During calling to GrainCancellationTokenSource.Cancel I have following error.
I use GrainCancellationToken for aborting long running operation. 
What is missing? Thanks

```C#

Orleans.Runtime.GrainExtensionNotInstalledException
  HResult=0x80131500
  Message=Extension not installed on grain Server.Grains.ProgressWatcherGrain attempting to invoke type Orleans.Runtime.OrleansCodeGenCancellationSourcesExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData
  Source=Orleans.Runtime
  StackTrace:
   at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__62.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AsyncExecutorWithRetries.&lt;&gt;c__DisplayClass1_0.&lt;&lt;ExecuteWithRetries&gt;b__0&gt;d.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AsyncExecutorWithRetries.&lt;ExecuteWithRetriesHelper&gt;d__4`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at Orleans.AsyncExecutorWithRetries.&lt;ExecuteWithRetriesHelper&gt;d__4`1.MoveNext()
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Server.Grains.ProjectGrain.&lt;AbortProject&gt;d__20.MoveNext()


```</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5141</IssueLabelID>
    <Title>multi silos，how can i configure my client</Title>
    <Description>silo1=&gt;port : 11111 gatewayport: 30000
silo2=&gt;port : 11112 gatewayport: 30001( can i use the same gateway port?)
my silos/clients running on the same host.

_Originally posted by @leoterry-ulrica in https://github.com/dotnet/orleans/issues/4384#issuecomment-433624135_</Description>
    <Title_Description>multi silos，how can i configure my client silo1=&gt;port : 11111 gatewayport: 30000
silo2=&gt;port : 11112 gatewayport: 30001( can i use the same gateway port?)
my silos/clients running on the same host.

_Originally posted by @leoterry-ulrica in https://github.com/dotnet/orleans/issues/4384#issuecomment-433624135_</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5140</IssueLabelID>
    <Title>GrainReference throwing `System.InvalidOperationException: Should be overridden by subclass` in GrainStorage.ReadStateAsync</Title>
    <Description>```
Exc level 0: System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68 ---&gt; System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68
   --- End of inner exception stack trace ---
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 80
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1170
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.InitActivation(ActivationData activation String grainType String genericArguments Dictionary`2 requestContextData) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 556
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Sims.Gates.Modules.Players.PlayerService.Login(Session context Login msg) in C:\Users\supei\xd\sims\OrleansLobby\Sims\Gates\Modules\Players\PlayerService.cs:line 79
   at Sims.Gates.Session.recvLoop() in C:\Users\supei\xd\sims\OrleansLobby\Sims\Gates\Session.cs:line 91
System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68
```</Description>
    <Title_Description>GrainReference throwing `System.InvalidOperationException: Should be overridden by subclass` in GrainStorage.ReadStateAsync ```
Exc level 0: System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68 ---&gt; System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68
   --- End of inner exception stack trace ---
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 80
   at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115
   at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55
   at Orleans.Runtime.Catalog.CallGrainActivate(ActivationData activation Dictionary`2 requestContextData) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1170
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.InitActivation(ActivationData activation String grainType String genericArguments Dictionary`2 requestContextData) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 556
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync|4_0[T](Task`1 asyncTask) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at Sims.Gates.Modules.Players.PlayerService.Login(Session context Login msg) in C:\Users\supei\xd\sims\OrleansLobby\Sims\Gates\Modules\Players\PlayerService.cs:line 79
   at Sims.Gates.Session.recvLoop() in C:\Users\supei\xd\sims\OrleansLobby\Sims\Gates\Session.cs:line 91
System.InvalidOperationException: Should be overridden by subclass
   at Orleans.Runtime.GrainReference.get_InterfaceName() in C:\Users\a\source\repos\orleans\src\Orleans.Core.Abstractions\Runtime\GrainReference.cs:line 305
   at Orleans.Persistence.RedisGrainStorage.GetKey(GrainReference grainReference) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 213
   at Orleans.Persistence.RedisGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Users\supei\xd\sims\OrleansLobby\Orleans.Persistence.Redis\RedisGrainStorage.cs:line 128
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 68
```</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5138</IssueLabelID>
    <Title>Does Orleans fit my case?</Title>
    <Description>Hello friends

sorry for posting a question here. I'd like to ask for some suggestions for my scenario and check if Orleans is a good fit for it. 
I have a bunch (about 30000-70000) of processing to perform and would like to split this among 5 high spec computers we have (16 processors 32GB RAM and SSD each).  The processing consists of creating a small input text file and send it to a 3rd party app that process it and return a string as result. This 3rd party app can eat some CPU sometimes it can take 1-3 seconds to process the input.
So the idea would be to create a Job list dispatch this and get the result as its happens. 

Do you thing Orleans is a good pick for this or would you recommend something else?

Thank you </Description>
    <Title_Description>Does Orleans fit my case? Hello friends

sorry for posting a question here. I'd like to ask for some suggestions for my scenario and check if Orleans is a good fit for it. 
I have a bunch (about 30000-70000) of processing to perform and would like to split this among 5 high spec computers we have (16 processors 32GB RAM and SSD each).  The processing consists of creating a small input text file and send it to a 3rd party app that process it and return a string as result. This 3rd party app can eat some CPU sometimes it can take 1-3 seconds to process the input.
So the idea would be to create a Job list dispatch this and get the result as its happens. 

Do you thing Orleans is a good pick for this or would you recommend something else?

Thank you </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5137</IssueLabelID>
    <Title>Exception of type 'zookeeper.KeeperException+NoNodeException' was thrown in Orleans client</Title>
    <Description>We use Orleans 2.0 to build orleans cluster by docker deployment: the docker containers contains: 3 silos containers 1 client container 3 zookeeper containers (used as membership table). There are 3 VMs to host containers. We ensure 3 silos are in separate vms(123) 3 zookeepers are in separate vms(123) 1 client is in vm1. 
Most time this cluster works well but sometimes (about one per week) client throws exception as follows:

&gt; org.apache.zookeeper.KeeperException+NoNodeException: Exception of type 'org.apache.zookeeper.KeeperException+NoNodeException' was thrown. at org.apache.zookeeper.ZooKeeper.getDataAsync(String path Watcher watcher) at Orleans.Runtime.Membership.ZooKeeperBasedMembershipTable.GetRow(ZooKeeper zk SiloAddress siloAddress) at Orleans.Runtime.Membership.ZooKeeperBasedMembershipTable.&lt;&gt;c.&lt;&lt;ReadAll&gt;b__11_0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at org.apache.zookeeper.ZooKeeper.TryOperation[T](ZooKeeper zk Func`2 zkMethod) at org.apache.zookeeper.ZooKeeper.&lt;&gt;c__DisplayClass62_0`1.&lt;&lt;Using&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at org.apache.zookeeper.ZooKeeper.Using[T](ZooKeeper zk Func`2 zkMethod) at Orleans.Runtime.Membership.ZooKeeperClusteringClientOptions.GetGateways() at Orleans.Messaging.GatewayManager.RefreshSnapshotLiveGateways_TimerCallback(Object context)

We doubt if there is any dirty data in zookeeper node so that exception thrown when trying to retrieve active gateway list from zk but membership table are fully maintained by Orleans runtime (package 'Microsoft.Orleans.OrleansZooKeeperUtils' used is version 2.0.0). Could you please give some information what happened? Thanks!</Description>
    <Title_Description>Exception of type 'zookeeper.KeeperException+NoNodeException' was thrown in Orleans client We use Orleans 2.0 to build orleans cluster by docker deployment: the docker containers contains: 3 silos containers 1 client container 3 zookeeper containers (used as membership table). There are 3 VMs to host containers. We ensure 3 silos are in separate vms(123) 3 zookeepers are in separate vms(123) 1 client is in vm1. 
Most time this cluster works well but sometimes (about one per week) client throws exception as follows:

&gt; org.apache.zookeeper.KeeperException+NoNodeException: Exception of type 'org.apache.zookeeper.KeeperException+NoNodeException' was thrown. at org.apache.zookeeper.ZooKeeper.getDataAsync(String path Watcher watcher) at Orleans.Runtime.Membership.ZooKeeperBasedMembershipTable.GetRow(ZooKeeper zk SiloAddress siloAddress) at Orleans.Runtime.Membership.ZooKeeperBasedMembershipTable.&lt;&gt;c.&lt;&lt;ReadAll&gt;b__11_0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at org.apache.zookeeper.ZooKeeper.TryOperation[T](ZooKeeper zk Func`2 zkMethod) at org.apache.zookeeper.ZooKeeper.&lt;&gt;c__DisplayClass62_0`1.&lt;&lt;Using&gt;b__0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown --- at org.apache.zookeeper.ZooKeeper.Using[T](ZooKeeper zk Func`2 zkMethod) at Orleans.Runtime.Membership.ZooKeeperClusteringClientOptions.GetGateways() at Orleans.Messaging.GatewayManager.RefreshSnapshotLiveGateways_TimerCallback(Object context)

We doubt if there is any dirty data in zookeeper node so that exception thrown when trying to retrieve active gateway list from zk but membership table are fully maintained by Orleans runtime (package 'Microsoft.Orleans.OrleansZooKeeperUtils' used is version 2.0.0). Could you please give some information what happened? Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5136</IssueLabelID>
    <Title>Using Microsoft.Orleans.ProtobufNet</Title>
    <Description>I have a question about the ProtobufNet serializer in orleans. I have tried to implement it but I could not find allot of documentation around using this within Orleans. I just want to make sure that what I have done is what is required to use this serializer. 

I am currently using Orleans 2.1 and from [this issue](https://github.com/dotnet/orleans/issues/4305) it looks like it is as simple as the steps below. 

1. I have installed **Microsoft.Orleans.ProtobufNet** package into both my Silo and client projects.
2. Added the following to the Silo and Client configuration
```
builder.Configure&lt;SerializationProviderOptions&gt;(opt =&gt;
{
    opt.SerializationProviders.Add(typeof(ProtobufNetSerializer).GetTypeInfo());
});
```
3. Added the following attributes to my response object from grain
```
[ProtoContract]
public class Person
{
     [ProtoMember(1)]
     public string Name { get; set; }

     [ProtoMember(2)]
     public string Surname { get; set; }
}
```

Is this all that is needed to use the ProtobufNet serializer ? Or Am I missing something.



</Description>
    <Title_Description>Using Microsoft.Orleans.ProtobufNet I have a question about the ProtobufNet serializer in orleans. I have tried to implement it but I could not find allot of documentation around using this within Orleans. I just want to make sure that what I have done is what is required to use this serializer. 

I am currently using Orleans 2.1 and from [this issue](https://github.com/dotnet/orleans/issues/4305) it looks like it is as simple as the steps below. 

1. I have installed **Microsoft.Orleans.ProtobufNet** package into both my Silo and client projects.
2. Added the following to the Silo and Client configuration
```
builder.Configure&lt;SerializationProviderOptions&gt;(opt =&gt;
{
    opt.SerializationProviders.Add(typeof(ProtobufNetSerializer).GetTypeInfo());
});
```
3. Added the following attributes to my response object from grain
```
[ProtoContract]
public class Person
{
     [ProtoMember(1)]
     public string Name { get; set; }

     [ProtoMember(2)]
     public string Surname { get; set; }
}
```

Is this all that is needed to use the ProtobufNet serializer ? Or Am I missing something.



</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5133</IssueLabelID>
    <Title>Add event on gateway count changed</Title>
    <Description>Based on gitter discussion with @ReubenBond 

Adds an event that the user can listen for changes in the gateway counts. Contains the current count of gateways as well as the previous count (to differentiate between gainin and losing gateways).

It's hard to test the reconnect situation. The only way I found so far to make a test that passes is included but it's not clean. I also had to implement a Reconnect functionality in the ClientMessageCenter for the test but it seems to not actually connect to any silos. The gateways reconnect and send the proper events but any grain requests after Reconnect time out. This makes me wonder if this is only a test cluster scenario (possibly due to faulty Reconnect implementation) or can it also happen in a regular cluster (which would make the entire event useless) 

TODO:
- [ ] Proper tests (need to figure out how to either fix the Reconnect in ClientMessageCenter or some other way of properly testing the reconnect situation)

- [x]  Whitespace cleanup </Description>
    <Title_Description>Add event on gateway count changed Based on gitter discussion with @ReubenBond 

Adds an event that the user can listen for changes in the gateway counts. Contains the current count of gateways as well as the previous count (to differentiate between gainin and losing gateways).

It's hard to test the reconnect situation. The only way I found so far to make a test that passes is included but it's not clean. I also had to implement a Reconnect functionality in the ClientMessageCenter for the test but it seems to not actually connect to any silos. The gateways reconnect and send the proper events but any grain requests after Reconnect time out. This makes me wonder if this is only a test cluster scenario (possibly due to faulty Reconnect implementation) or can it also happen in a regular cluster (which would make the entire event useless) 

TODO:
- [ ] Proper tests (need to figure out how to either fix the Reconnect in ClientMessageCenter or some other way of properly testing the reconnect situation)

- [x]  Whitespace cleanup </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5132</IssueLabelID>
    <Title>Documentation: Connect/clarify client Observer documentation to Streaming</Title>
    <Description>I think next tuning of documentation would be helpful to many newcomers to Orleans

Now `Events/callbacks` are under [Grains-&gt; Observers](https://dotnet.github.io/orleans/Documentation/grains/observers.html)

Now `Events/callbacks` are under[`Streaming -&gt; Streams Programming APIs -&gt;Grains and Orleans Clients](https://dotnet.github.io/orleans/Documentation/streaming/streams_programming_APIs.html#grains-and-orleans-clientsa-namegrains-and-orleans-clients)
with 
&gt;  This greatly simplifies the application logic making special client-side APIs such as Grain Observers redundant.

I think tt would be helpful that documentation about similar things connected via links. Specifically `Grains-&gt; Observers` which is read first should link to `Streaming` as alternative. Especially because of `Grain Observers redundant`.


</Description>
    <Title_Description>Documentation: Connect/clarify client Observer documentation to Streaming I think next tuning of documentation would be helpful to many newcomers to Orleans

Now `Events/callbacks` are under [Grains-&gt; Observers](https://dotnet.github.io/orleans/Documentation/grains/observers.html)

Now `Events/callbacks` are under[`Streaming -&gt; Streams Programming APIs -&gt;Grains and Orleans Clients](https://dotnet.github.io/orleans/Documentation/streaming/streams_programming_APIs.html#grains-and-orleans-clientsa-namegrains-and-orleans-clients)
with 
&gt;  This greatly simplifies the application logic making special client-side APIs such as Grain Observers redundant.

I think tt would be helpful that documentation about similar things connected via links. Specifically `Grains-&gt; Observers` which is read first should link to `Streaming` as alternative. Especially because of `Grain Observers redundant`.


</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5131</IssueLabelID>
    <Title>local cluster shutdown stuck 30 second</Title>
    <Description>setup:

1. memory storage + local cluster
2. API gate + direct client + silo host in one process
3. orleans version: b0fa540

```
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 20000 which took 3 Milliseconds.
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 20000 took 6.2884 Milliseconds
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.Silo|Silo starting to Shutdown()
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.MembershipService.MembershipOracleData|-ShutDown
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|DeactivateAllActivations.
2018-10-25 14:47:37.5063|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0 on managed thread 53
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|DeactivateActivations: total 5 to shutdown out of them 5 promptly 0 later when become idle and 0 are already being destroyed or invalid.
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|Starting DestroyActivations #0 of 5 activations
2018-10-25 14:47:37.5277|INFO|Default|Room 132080 stopping reason stop by room agent
2018-10-25 14:47:37.5277|INFO|Default|Cleanup Room 132080
2018-10-25 14:47:37.5377|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-25 14:47:37.5604|INFO|Orleans.Runtime.Catalog|Done FinishDestroyActivations #0 - Destroyed 1 Activations.
2018-10-25 14:47:43.1263|ERROR|Orleans.Runtime.ClientObserverRegistrar|Directory.RegisterAsync S127.0.0.1:11111:278146050*cli/069a77af@d38dd7f2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 578
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 138
2018-10-25 14:47:43.1325|ERROR|Orleans.Runtime.ClientObserverRegistrar|OnClientRefreshTimer has thrown an exceptions. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 578
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.Runtime.ClientObserverRegistrar.OnClientRefreshTimer(Object data) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\ClientObserverRegistrar.cs:line 136
2018-10-25 14:48:07.8081|WARN|Orleans.Runtime.CallbackData|Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: . Target History is: &lt;S127.0.0.1:11111:278146050:*grn/716E8E94/00000001+ClientMessageService_ClientMessageService:@12fdf888&gt;. About to break its promise.
2018-10-25 14:48:07.8081|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: . Target History is: &lt;S127.0.0.1:11111:278146050:*grn/716E8E94/00000001+ClientMessageService_ClientMessageService:@12fdf888&gt;.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-25 14:48:07.8081|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 4 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Dispatcher|Forwarding 1 requests destined for address S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 to address  after Finished Destroy Activation.
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Catalog|Done FinishDestroyActivations #0 - Destroyed 4 Activations.
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Dispatcher|Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: .
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.GatewayAcceptor0 on managed thread 55
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 19999 which took 30324 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 19999 took 30324.2329 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore stopped in stage 10000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 10000 took 0.1231 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 8000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 8000 took 0.0793 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 4000 which took 1 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 4000 took 1.8309 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.InsideRuntimeClient stopped in stage 2000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.Silo|Silo is Stopped()
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.MembershipService.MembershipOracleData|-KillMyself
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/System0 on managed thread 50
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/Application0 on managed thread 51
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/Ping0 on managed thread 49
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Watchdog0 on managed thread 54
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.ActivationDirectory|ActivationDirectory.PrintActivationDirectory(): Size = 2 Directory:
[++   [Activation: S127.0.0.1:11111:278146050*grn/30D642F0/000000000000000000000000000000010300000030d642f0-0x53883087@43f10f9d #GrainType=Orleans.Storage.MemoryStorageGrain Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:32.6087081 CollectionAgeLimit=02:00:00]
++   [Activation: S127.0.0.1:11111:278146050*grn/30D642F0/000000000000000000000000000000080300000030d642f0-0x3C74C8EA@5e82ecad #GrainType=Orleans.Storage.MemoryStorageGrain Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:30.3045059 CollectionAgeLimit=02:00:00]]
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAcceptor0 on managed thread 46
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.SiloMessageSender/PingSender0 on managed thread 47
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.SiloMessageSender/SystemSender0 on managed thread 48
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.CounterStatistic|Stopping  Windows perf counter stats collection
2018-10-25 14:48:07.8432|INFO|Orleans.RuntimeSiloLogStatistics|Statistics: ^^^
App.Requests.Latency.Average.Millis=734.000
App.Requests.LatencyHistogram.Millis=[0.0128:0.0255]=2 [0.0256:0.0511]=3 [0.0512:0.1023]=3 [0.1024:0.2047]=2 [0.2048:0.4095]=2 [0.4096:0.8191]=2 [0.8192:1.6383]=8 [1.6384:3.2767]=6 [3.2768:6.5535]=2 [6.5536:13.1071]=4 [13.1072:26.2143]=2 [52.4288:104.8575]=2 [104.8576:209.7151]=1 [209.7152:419.4303]=3 [26843.5456:53687.0911]=1
App.Requests.TimedOut.Current=1
```</Description>
    <Title_Description>local cluster shutdown stuck 30 second setup:

1. memory storage + local cluster
2. API gate + direct client + silo host in one process
3. orleans version: b0fa540

```
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 20000 which took 3 Milliseconds.
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 20000 took 6.2884 Milliseconds
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.Silo|Silo starting to Shutdown()
2018-10-25 14:47:37.4937|INFO|Orleans.Runtime.MembershipService.MembershipOracleData|-ShutDown
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|DeactivateAllActivations.
2018-10-25 14:47:37.5063|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0 on managed thread 53
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|DeactivateActivations: total 5 to shutdown out of them 5 promptly 0 later when become idle and 0 are already being destroyed or invalid.
2018-10-25 14:47:37.5063|INFO|Orleans.Runtime.Catalog|Starting DestroyActivations #0 of 5 activations
2018-10-25 14:47:37.5277|INFO|Default|Room 132080 stopping reason stop by room agent
2018-10-25 14:47:37.5277|INFO|Default|Cleanup Room 132080
2018-10-25 14:47:37.5377|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-25 14:47:37.5604|INFO|Orleans.Runtime.Catalog|Done FinishDestroyActivations #0 - Destroyed 1 Activations.
2018-10-25 14:47:43.1263|ERROR|Orleans.Runtime.ClientObserverRegistrar|Directory.RegisterAsync S127.0.0.1:11111:278146050*cli/069a77af@d38dd7f2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 578
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 138
2018-10-25 14:47:43.1325|ERROR|Orleans.Runtime.ClientObserverRegistrar|OnClientRefreshTimer has thrown an exceptions. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.RegisterAsync(ActivationAddress address Boolean singleActivation Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 578
   at Orleans.OrleansTaskExtentions.LogException(Task task ILogger logger ErrorCode errorCode String message) in C:\Users\a\source\repos\orleans\src\Orleans.Core\Async\TaskExtensions.cs:line 138
   at Orleans.Runtime.ClientObserverRegistrar.OnClientRefreshTimer(Object data) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\ClientObserverRegistrar.cs:line 136
2018-10-25 14:48:07.8081|WARN|Orleans.Runtime.CallbackData|Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: . Target History is: &lt;S127.0.0.1:11111:278146050:*grn/716E8E94/00000001+ClientMessageService_ClientMessageService:@12fdf888&gt;. About to break its promise.
2018-10-25 14:48:07.8081|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: . Target History is: &lt;S127.0.0.1:11111:278146050:*grn/716E8E94/00000001+ClientMessageService_ClientMessageService:@12fdf888&gt;.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-25 14:48:07.8081|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 4 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Dispatcher|Forwarding 1 requests destined for address S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 to address  after Finished Destroy Activation.
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Catalog|Done FinishDestroyActivations #0 - Destroyed 4 Activations.
2018-10-25 14:48:07.8081|INFO|Orleans.Runtime.Dispatcher|Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S127.0.0.1:11111:278146050*grn/736BA21C/00000001@b56bd5bc-&gt;S127.0.0.1:11111:278146050*grn/716E8E94/00000001+ClientMessageService_ClientMessageService@12fdf888 #45: .
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.GatewayAcceptor0 on managed thread 55
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 19999 which took 30324 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 19999 took 30324.2329 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore stopped in stage 10000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 10000 took 0.1231 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 8000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 8000 took 0.0793 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.Silo stopped in stage 4000 which took 1 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Stopping lifecycle stage 4000 took 1.8309 Milliseconds
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.SiloLifecycleSubject|Lifecycle observer Orleans.Runtime.InsideRuntimeClient stopped in stage 2000 which took 0 Milliseconds.
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.Silo|Silo is Stopped()
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.MembershipService.MembershipOracleData|-KillMyself
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/System0 on managed thread 50
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/Application0 on managed thread 51
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAgent/Ping0 on managed thread 49
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Watchdog0 on managed thread 54
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.ActivationDirectory|ActivationDirectory.PrintActivationDirectory(): Size = 2 Directory:
[++   [Activation: S127.0.0.1:11111:278146050*grn/30D642F0/000000000000000000000000000000010300000030d642f0-0x53883087@43f10f9d #GrainType=Orleans.Storage.MemoryStorageGrain Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:32.6087081 CollectionAgeLimit=02:00:00]
++   [Activation: S127.0.0.1:11111:278146050*grn/30D642F0/000000000000000000000000000000080300000030d642f0-0x3C74C8EA@5e82ecad #GrainType=Orleans.Storage.MemoryStorageGrain Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:00:30.3045059 CollectionAgeLimit=02:00:00]]
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.IncomingMessageAcceptor0 on managed thread 46
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.SiloMessageSender/PingSender0 on managed thread 47
2018-10-25 14:48:07.8188|INFO|Orleans.Threading.ThreadPoolThread|Stopping Thread Runtime.Messaging.SiloMessageSender/SystemSender0 on managed thread 48
2018-10-25 14:48:07.8188|INFO|Orleans.Runtime.CounterStatistic|Stopping  Windows perf counter stats collection
2018-10-25 14:48:07.8432|INFO|Orleans.RuntimeSiloLogStatistics|Statistics: ^^^
App.Requests.Latency.Average.Millis=734.000
App.Requests.LatencyHistogram.Millis=[0.0128:0.0255]=2 [0.0256:0.0511]=3 [0.0512:0.1023]=3 [0.1024:0.2047]=2 [0.2048:0.4095]=2 [0.4096:0.8191]=2 [0.8192:1.6383]=8 [1.6384:3.2767]=6 [3.2768:6.5535]=2 [6.5536:13.1071]=4 [13.1072:26.2143]=2 [52.4288:104.8575]=2 [104.8576:209.7151]=1 [209.7152:419.4303]=3 [26843.5456:53687.0911]=1
App.Requests.TimedOut.Current=1
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5130</IssueLabelID>
    <Title>Can i integrate with the NLog log component</Title>
    <Description>I want to use the NLog component as my log provider.How can I achieve it? @ReubenBond  Thx</Description>
    <Title_Description>Can i integrate with the NLog log component I want to use the NLog component as my log provider.How can I achieve it? @ReubenBond  Thx</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5127</IssueLabelID>
    <Title>Update https://dotnet.github.io/orleans/Documentation/grains/index.html</Title>
    <Description>1. Update `Asynchronous Programming with Async and Await` link from https://msdn.microsoft.com/en-us/library/hh191443.aspx into up to date https://docs.microsoft.com/en-us/dotnet/csharp/async

2. Document possibility to use ValueTask #4562.

3. Document possibility of grain to have 2 interfaces and one implementation ( I tested in single Silo and seems #1511 kind of works)

```
namespace UserNotification.Host
{
    public class MatchMakingGrain : Grain
    IGameGrain IPlayerDisconnect
    { 
        // ...
    }

var grainClassNamePrefix= "UserNotification.Host.MatchMakingGrain";
var sameActivationDifferentFace1 = this.GrainFactory.GetGrain&lt;IGameGrain&gt;("13" grainClassNamePrefix);
var sameActivationDifferentFace1  = this.GrainFactory.GetGrain&lt;IPlayerDisconnect&gt;("13" grainClassNamePrefix);

```


</Description>
    <Title_Description>Update https://dotnet.github.io/orleans/Documentation/grains/index.html 1. Update `Asynchronous Programming with Async and Await` link from https://msdn.microsoft.com/en-us/library/hh191443.aspx into up to date https://docs.microsoft.com/en-us/dotnet/csharp/async

2. Document possibility to use ValueTask #4562.

3. Document possibility of grain to have 2 interfaces and one implementation ( I tested in single Silo and seems #1511 kind of works)

```
namespace UserNotification.Host
{
    public class MatchMakingGrain : Grain
    IGameGrain IPlayerDisconnect
    { 
        // ...
    }

var grainClassNamePrefix= "UserNotification.Host.MatchMakingGrain";
var sameActivationDifferentFace1 = this.GrainFactory.GetGrain&lt;IGameGrain&gt;("13" grainClassNamePrefix);
var sameActivationDifferentFace1  = this.GrainFactory.GetGrain&lt;IPlayerDisconnect&gt;("13" grainClassNamePrefix);

```


</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>24/10/2018 1:22:06 PM +00:00</CreatedAt>
    <ClosedAt>25/02/2019 10:40:16 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5126</IssueLabelID>
    <Title> `Improve this Doc` link does not work on https://dotnet.github.io/orleans/Documentation</Title>
    <Description>
1. https://dotnet.github.io/orleans/Documentation/grains/index.html
2. Press  `Improve this Doc`
3. https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/grains/index.md/#L1

Actual: Get 404
Expected: Editor</Description>
    <Title_Description> `Improve this Doc` link does not work on https://dotnet.github.io/orleans/Documentation 
1. https://dotnet.github.io/orleans/Documentation/grains/index.html
2. Press  `Improve this Doc`
3. https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/grains/index.md/#L1

Actual: Get 404
Expected: Editor</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5125</IssueLabelID>
    <Title>System.InvalidOperationException : No default ITransactionalStateStorageFactory nor IGrainStorage was found while attempting to create transactional state storage.</Title>
    <Description>var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "fiiipay";
                })
                .UseLocalhostClustering()
                .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
                .ConfigureApplicationParts(parts =&gt;
                {
                    parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences();
                })
                .AddAdoNetGrainStorage("store0"configureOptions =&gt;
                {
                    configureOptions.ConnectionString =
                        "Data Source=.;Database=FiiiPay.Account;Integrated Security=True;Pooling=False;Max Pool Size=200;";
                    configureOptions.Invariant = "System.Data.SqlClient";
                })
                .AddAdoNetGrainStorage("store1"configureOptions =&gt;
                {
                    configureOptions.ConnectionString =
                        "Data Source=.;Database=Test;Integrated Security=True;Pooling=False;Max Pool Size=200;";
                    configureOptions.Invariant = "System.Data.SqlClient";
                })
                .UseTransactions(); 
this is my host code</Description>
    <Title_Description>System.InvalidOperationException : No default ITransactionalStateStorageFactory nor IGrainStorage was found while attempting to create transactional state storage. var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "fiiipay";
                })
                .UseLocalhostClustering()
                .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
                .ConfigureApplicationParts(parts =&gt;
                {
                    parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences();
                })
                .AddAdoNetGrainStorage("store0"configureOptions =&gt;
                {
                    configureOptions.ConnectionString =
                        "Data Source=.;Database=FiiiPay.Account;Integrated Security=True;Pooling=False;Max Pool Size=200;";
                    configureOptions.Invariant = "System.Data.SqlClient";
                })
                .AddAdoNetGrainStorage("store1"configureOptions =&gt;
                {
                    configureOptions.ConnectionString =
                        "Data Source=.;Database=Test;Integrated Security=True;Pooling=False;Max Pool Size=200;";
                    configureOptions.Invariant = "System.Data.SqlClient";
                })
                .UseTransactions(); 
this is my host code</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5124</IssueLabelID>
    <Title>microsoft.orleans.codegenerator.msbuild build fail</Title>
    <Description>严重性	代码	说明	项目	文件	行	禁止显示状态
错误	MSB3073	命令“"dotnet" "C:\Users\thinkpad\.nuget\packages\microsoft.orleans.codegenerator.msbuild\2.1.2\build\..\tasks\netcoreapp2.0\Orleans.CodeGenerator.MSBuild.dll" SourceToSource "D:\aws-gitlab\dme\SH2018CP030\src\Dist.Product.Dme\Dist.Dme.Orleans.Interfaces\obj\x86\Debug\netcoreapp2.1\Dist.Dme.Orleans.Interfaces.orleans.g.args.txt"”已退出，代码为 3。	Dist.Dme.Orleans.Interfaces	C:\Users\thinkpad\.nuget\packages\microsoft.orleans.codegenerator.msbuild\2.1.2\build\Microsoft.Orleans.CodeGenerator.MSBuild.targets	122	

why? thx</Description>
    <Title_Description>microsoft.orleans.codegenerator.msbuild build fail 严重性	代码	说明	项目	文件	行	禁止显示状态
错误	MSB3073	命令“"dotnet" "C:\Users\thinkpad\.nuget\packages\microsoft.orleans.codegenerator.msbuild\2.1.2\build\..\tasks\netcoreapp2.0\Orleans.CodeGenerator.MSBuild.dll" SourceToSource "D:\aws-gitlab\dme\SH2018CP030\src\Dist.Product.Dme\Dist.Dme.Orleans.Interfaces\obj\x86\Debug\netcoreapp2.1\Dist.Dme.Orleans.Interfaces.orleans.g.args.txt"”已退出，代码为 3。	Dist.Dme.Orleans.Interfaces	C:\Users\thinkpad\.nuget\packages\microsoft.orleans.codegenerator.msbuild\2.1.2\build\Microsoft.Orleans.CodeGenerator.MSBuild.targets	122	

why? thx</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5123</IssueLabelID>
    <Title>Cleaned up ping benchmark</Title>
    <Description>
    </Description>
    <Title_Description>Cleaned up ping benchmark </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5120</IssueLabelID>
    <Title>Consume EventHub - the best way to do that</Title>
    <Description>Hi. Im looking on Orleans and have scenario where i have to read external data from EventHub (EventHub is not populated with data from Orleans applications/clients) and eventually pass them further to other grains - model flows and etc. I wonder - is this is somehow achievable inside orleans middle-tier (to leverage scaling and distributed nature of the system) or i have to externally (as OrleanClient) read the events from EventHub and then eventually pass them to needed grains? 
For example let's assume scenario where i want to read data from EventHub partition them and catch by arbitrary property (UserId) and then write grouped as single transaction (for reach key) to DataLake. The trigger to write should be size of cached data (around 4 MB) or time (if we not make it to gather 4 MB before time elapsed). From theory i would use some Orleans Service or Stream to read data extract key and then pass each message to grain with key as ID - then grain batch this events and have Orleans Timer or size Trigger to flush data do DataLake - but if this has any chance of success? Is 4 MB size grains are suitable for Orleans? And still i have no idea how to read those events from EventHub. 
Is something like this achievable in Olreans? 
@jason-bragg - could you help here? :)</Description>
    <Title_Description>Consume EventHub - the best way to do that Hi. Im looking on Orleans and have scenario where i have to read external data from EventHub (EventHub is not populated with data from Orleans applications/clients) and eventually pass them further to other grains - model flows and etc. I wonder - is this is somehow achievable inside orleans middle-tier (to leverage scaling and distributed nature of the system) or i have to externally (as OrleanClient) read the events from EventHub and then eventually pass them to needed grains? 
For example let's assume scenario where i want to read data from EventHub partition them and catch by arbitrary property (UserId) and then write grouped as single transaction (for reach key) to DataLake. The trigger to write should be size of cached data (around 4 MB) or time (if we not make it to gather 4 MB before time elapsed). From theory i would use some Orleans Service or Stream to read data extract key and then pass each message to grain with key as ID - then grain batch this events and have Orleans Timer or size Trigger to flush data do DataLake - but if this has any chance of success? Is 4 MB size grains are suitable for Orleans? And still i have no idea how to read those events from EventHub. 
Is something like this achievable in Olreans? 
@jason-bragg - could you help here? :)</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5119</IssueLabelID>
    <Title>Orleans method call slower than Orleans streams</Title>
    <Description>We have implemented a workflow execution system using Orleans 2.0.0. The workflow contains 4 operators  connected one after the other. Each operator (implemented as its own grain class) after it processes a tuple passes it to the next operator. This 'passing' is implemented in two ways - 1) method calls to the downstream operator 2) Streams between each consecutive operators and the downstream operators subscribe to the stream of their previous operator. We use SMSProvider for our streams.

In both implementations the results from the last operator reach the Client using a stream (SMSProvider).

We ran tests using two input sizes - 1) 100000 tuples and 2) 1 million tuples. Following are the time taken for the two implementations (averaged over multiple iterations):

```
                             Method Calls                               Orleans Streams
100000 tuples                 20 s                                              6 s
1 million tuples          didn't finish after 15 min                        1 min 8 s
```

In the 1 million tuple method calls case we saw that that we were getting a warning 

&gt; Orleans.Runtime.CallbackData[100157]
&gt;       Response did not arrive on time in 00:00:30 for message: Request *cli/65424186@696554ac-&gt;S127.0.0.1:30000:0*grn/B3410F44/0000000b#82: . Target History is: &lt;S127.0.0.1:30000:0:*grn/B3410F44/0000000b:&gt;. About to break its promise. 


In the Orleans dashboard we see that the grains of operators after the first operator aren't even getting activated. However we don't know how accurate the data shown by Orleans Dashboard is. We had a print statement to be shown when the second operator finished its processing. The print statement was never shown for 1 million `Method Call` case.

For all other cases everything goes on fine. But we do see the slower performance of Method Calls as compared to streams.

The two implementations are in my Github repository under the branches [workflow_RPCs_with_ordering_v2](https://github.com/avinash0161/TexeraPrototypes/tree/workflow_RPCs_with_ordering_v2) and [workflow_streams_with_ordering](https://github.com/avinash0161/TexeraPrototypes/tree/workflow_streams_with_ordering).</Description>
    <Title_Description>Orleans method call slower than Orleans streams We have implemented a workflow execution system using Orleans 2.0.0. The workflow contains 4 operators  connected one after the other. Each operator (implemented as its own grain class) after it processes a tuple passes it to the next operator. This 'passing' is implemented in two ways - 1) method calls to the downstream operator 2) Streams between each consecutive operators and the downstream operators subscribe to the stream of their previous operator. We use SMSProvider for our streams.

In both implementations the results from the last operator reach the Client using a stream (SMSProvider).

We ran tests using two input sizes - 1) 100000 tuples and 2) 1 million tuples. Following are the time taken for the two implementations (averaged over multiple iterations):

```
                             Method Calls                               Orleans Streams
100000 tuples                 20 s                                              6 s
1 million tuples          didn't finish after 15 min                        1 min 8 s
```

In the 1 million tuple method calls case we saw that that we were getting a warning 

&gt; Orleans.Runtime.CallbackData[100157]
&gt;       Response did not arrive on time in 00:00:30 for message: Request *cli/65424186@696554ac-&gt;S127.0.0.1:30000:0*grn/B3410F44/0000000b#82: . Target History is: &lt;S127.0.0.1:30000:0:*grn/B3410F44/0000000b:&gt;. About to break its promise. 


In the Orleans dashboard we see that the grains of operators after the first operator aren't even getting activated. However we don't know how accurate the data shown by Orleans Dashboard is. We had a print statement to be shown when the second operator finished its processing. The print statement was never shown for 1 million `Method Call` case.

For all other cases everything goes on fine. But we do see the slower performance of Method Calls as compared to streams.

The two implementations are in my Github repository under the branches [workflow_RPCs_with_ordering_v2](https://github.com/avinash0161/TexeraPrototypes/tree/workflow_RPCs_with_ordering_v2) and [workflow_streams_with_ordering](https://github.com/avinash0161/TexeraPrototypes/tree/workflow_streams_with_ordering).</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5118</IssueLabelID>
    <Title>gossip channels across Azure availability zones?</Title>
    <Description>What are the requirements for the gossip channel(s) to work correctly?

With Azure now having 3+ "Availability Zones" per region is multi-cluster support needed for silos to span zones or would these inter-zone hops be low enough latency to form a single cluster across zones within a single region?

Any thoughts on hierarchical partitioning/silo-affinity ("within zone across zones across regions" for example)? Is it done anywhere or considered for Orleans? Or does existing multi-cluster support in Orleans already cover every conceivable scenario?</Description>
    <Title_Description>gossip channels across Azure availability zones? What are the requirements for the gossip channel(s) to work correctly?

With Azure now having 3+ "Availability Zones" per region is multi-cluster support needed for silos to span zones or would these inter-zone hops be low enough latency to form a single cluster across zones within a single region?

Any thoughts on hierarchical partitioning/silo-affinity ("within zone across zones across regions" for example)? Is it done anywhere or considered for Orleans? Or does existing multi-cluster support in Orleans already cover every conceivable scenario?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5117</IssueLabelID>
    <Title>Add changelog for 2.2.0-beta1</Title>
    <Description>
    </Description>
    <Title_Description>Add changelog for 2.2.0-beta1 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5115</IssueLabelID>
    <Title>HelloWorld Tutorial/sample needs a correction</Title>
    <Description>Hello

The documentation of HelloWorld sample available at http://dotnet.github.io/orleans/Documentation/tutorials_and_samples/Hello-World.html needs a correction. The **Improve this Doc** link on the page is broken too

`.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
 .ConfigureLogging(logging =&gt; logging.AddConsole());`
needs to be corrected to 
`.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)`
**_.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences())_**
  `.ConfigureLogging(logging =&gt; logging.AddConsole());`

With the missing statement related to adding the assembly that holds definition of the _Grains_ the documentation misses the point on how the _SiloHost_ picks the _grains_ to host</Description>
    <Title_Description>HelloWorld Tutorial/sample needs a correction Hello

The documentation of HelloWorld sample available at http://dotnet.github.io/orleans/Documentation/tutorials_and_samples/Hello-World.html needs a correction. The **Improve this Doc** link on the page is broken too

`.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
 .ConfigureLogging(logging =&gt; logging.AddConsole());`
needs to be corrected to 
`.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)`
**_.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences())_**
  `.ConfigureLogging(logging =&gt; logging.AddConsole());`

With the missing statement related to adding the assembly that holds definition of the _Grains_ the documentation misses the point on how the _SiloHost_ picks the _grains_ to host</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5114</IssueLabelID>
    <Title>How do you get all the grain collections?</Title>
    <Description>For example there are many users grain one of them needs to change the name and the name cannot be the same as other users what should be done at this time ~
What I can think of at the moment is to use a grain like user management to manage all users grain but it doesn't feel reasonable because that grain will become very big can anyone tell me what to do</Description>
    <Title_Description>How do you get all the grain collections? For example there are many users grain one of them needs to change the name and the name cannot be the same as other users what should be done at this time ~
What I can think of at the moment is to use a grain like user management to manage all users grain but it doesn't feel reasonable because that grain will become very big can anyone tell me what to do</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>21/10/2018 3:45:19 PM +00:00</CreatedAt>
    <ClosedAt>1/11/2018 2:05:37 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5113</IssueLabelID>
    <Title>Update AccountTransfer sample </Title>
    <Description>* Update sample to the newer version of the transaction interface.
* Add ReadKey in sample client after an exception is thrown to keep the window open long enough to read the exception
* Fix an exception to remove reference to deprecated functionality.</Description>
    <Title_Description>Update AccountTransfer sample  * Update sample to the newer version of the transaction interface.
* Add ReadKey in sample client after an exception is thrown to keep the window open long enough to read the exception
* Fix an exception to remove reference to deprecated functionality.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5110</IssueLabelID>
    <Title>Possible reasons and correct handling of TableStorageUpdateConditionNotSatisfiedException</Title>
    <Description>Hi All

I noticed we're getting `TableStorageUpdateConditionNotSatisfiedException`  and I'm wondering whether we're doing anything wrong or there's an issue in Orleans.

It seems that the exception can be thrown in any grain that calls `WriteStateAsync`.

Exceptions are as follows:
```
Error from storage provider AzureTableGrainStorage.MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain during WriteState for grain Type=MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain Pk=*grn/A67DBB61/0000000000000000000000000000000006ffffffa67dbb61+226399::1-0x14215DB0 Id=GrainReference:*grn/A67DBB61/00000000+226399::1 Error=UpdateConditionNotSatisfied
 
Exc level 0: Orleans.Storage.TableStorageUpdateConditionNotSatisfiedException: Table storage condition not Satisfied.  GrainType: MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain GrainId: GrainReference:*grn/A67DBB61/00000000+226399::1 TableName: OrleansGrainState StoredETag: Unknown CurrentETag: W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'"
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
   at Orleans.Storage.AzureTableGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState)
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync()
Exc level 1: Microsoft.WindowsAzure.Storage.StorageException: Message = Precondition Failed HttpStatusCode = 412 HttpStatusMessage = Precondition Failed ExtendedErrorInformation.ErrorCode = UpdateConditionNotSatisfied ExtendedErrorInformation.ErrorMessage = The update condition specified in the request was not satisfied.
RequestId:a048cff3-6002-0039-2503-67bdc9000000
Time:2018-10-18T16:57:55.8897711Z.
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.UpdateTableEntryAsync(T data String dataEtag)
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Write(GrainStateRecord record)
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
InconsistentStateException: Table storage condition not Satisfied.  GrainType: MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain GrainId: GrainReference:*grn/A67DBB61/00000000+226399::1 TableName: OrleansGrainState StoredETag: Unknown CurrentETag: W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'" Expected Etag=Unknown Received Etag=W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'" Microsoft.WindowsAzure.Storage.StorageException: Precondition Failed
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.UpdateTableEntryAsync(T data String dataEtag)
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Write(GrainStateRecord record)
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
Request Information
RequestID:a048cff3-6002-0039-2503-67bdc9000000
RequestDate:Thu 18 Oct 2018 16:57:55 GMT
StatusMessage:Precondition Failed
ErrorCode:UpdateConditionNotSatisfied
ErrorMessage:The update condition specified in the request was not satisfied.
RequestId:a048cff3-6002-0039-2503-67bdc9000000
Time:2018-10-18T16:57:55.8897711Z
```

The only difference from the standard that we have is that all grains inherit the same base grain class:
```
    public class GrainWithMetrics&lt;T&gt;: Grain&lt;T&gt; where T : new()
    {
        private readonly string _typeName; 
        
        public GrainWithMetrics()
        {
            _typeName = GetType().Name;
        }
        
        protected override Task ReadStateAsync()
        {
            return base.ReadStateAsync()
                .WithStopwatchAsync($"{_typeName}::ReadState" Metrics.StopwatchObserver);
        }

        protected override Task WriteStateAsync()
        {
            return base.WriteStateAsync()
                .WithStopwatchAsync($"{_typeName}::WriteState" Metrics.StopwatchObserver);
        }
    }
```

Where `WithStopwatchAsync` does just something like this:
```
        public static async Task&lt;T&gt; WithStopwatchAsync&lt;T&gt;(
            this Task&lt;T&gt; task
            [NotNull] Action&lt;TimeSpan&gt; onTaskFinished)
        {
            if (task == null) return default(T);
            if (onTaskFinished == null) throw new ArgumentNullException(nameof(onTaskFinished));

            var sw = new Stopwatch();
            sw.Start();

            try { return await task; }
            finally
            {
                sw.Stop();

                try { onTaskFinished(sw.Elapsed); }
                catch (Exception e)
                {
                    Trace.TraceError(
                        $"Errror calling {nameof(onTaskFinished)} in {nameof(StopwatchExtensions)}.{nameof(WithStopwatchAsync)}:\n{e}");
                }
            }
        }
```

We're running Orleans 2.0.5.

Any help would be hugely appreciated thanks in advance.</Description>
    <Title_Description>Possible reasons and correct handling of TableStorageUpdateConditionNotSatisfiedException Hi All

I noticed we're getting `TableStorageUpdateConditionNotSatisfiedException`  and I'm wondering whether we're doing anything wrong or there's an issue in Orleans.

It seems that the exception can be thrown in any grain that calls `WriteStateAsync`.

Exceptions are as follows:
```
Error from storage provider AzureTableGrainStorage.MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain during WriteState for grain Type=MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain Pk=*grn/A67DBB61/0000000000000000000000000000000006ffffffa67dbb61+226399::1-0x14215DB0 Id=GrainReference:*grn/A67DBB61/00000000+226399::1 Error=UpdateConditionNotSatisfied
 
Exc level 0: Orleans.Storage.TableStorageUpdateConditionNotSatisfiedException: Table storage condition not Satisfied.  GrainType: MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain GrainId: GrainReference:*grn/A67DBB61/00000000+226399::1 TableName: OrleansGrainState StoredETag: Unknown CurrentETag: W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'"
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
   at Orleans.Storage.AzureTableGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState)
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync()
Exc level 1: Microsoft.WindowsAzure.Storage.StorageException: Message = Precondition Failed HttpStatusCode = 412 HttpStatusMessage = Precondition Failed ExtendedErrorInformation.ErrorCode = UpdateConditionNotSatisfied ExtendedErrorInformation.ErrorMessage = The update condition specified in the request was not satisfied.
RequestId:a048cff3-6002-0039-2503-67bdc9000000
Time:2018-10-18T16:57:55.8897711Z.
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.UpdateTableEntryAsync(T data String dataEtag)
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Write(GrainStateRecord record)
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
InconsistentStateException: Table storage condition not Satisfied.  GrainType: MyNamespace.OrleansSilo.GrainsCollection.PlateRecognizer.PlateDeduplicationGrain GrainId: GrainReference:*grn/A67DBB61/00000000+226399::1 TableName: OrleansGrainState StoredETag: Unknown CurrentETag: W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'" Expected Etag=Unknown Received Etag=W/"datetime'2018-10-18T16%3A45%3A04.1338014Z'" Microsoft.WindowsAzure.Storage.StorageException: Precondition Failed
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.UpdateTableEntryAsync(T data String dataEtag)
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Write(GrainStateRecord record)
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation String grainType GrainReference grainReference String tableName String currentETag)
Request Information
RequestID:a048cff3-6002-0039-2503-67bdc9000000
RequestDate:Thu 18 Oct 2018 16:57:55 GMT
StatusMessage:Precondition Failed
ErrorCode:UpdateConditionNotSatisfied
ErrorMessage:The update condition specified in the request was not satisfied.
RequestId:a048cff3-6002-0039-2503-67bdc9000000
Time:2018-10-18T16:57:55.8897711Z
```

The only difference from the standard that we have is that all grains inherit the same base grain class:
```
    public class GrainWithMetrics&lt;T&gt;: Grain&lt;T&gt; where T : new()
    {
        private readonly string _typeName; 
        
        public GrainWithMetrics()
        {
            _typeName = GetType().Name;
        }
        
        protected override Task ReadStateAsync()
        {
            return base.ReadStateAsync()
                .WithStopwatchAsync($"{_typeName}::ReadState" Metrics.StopwatchObserver);
        }

        protected override Task WriteStateAsync()
        {
            return base.WriteStateAsync()
                .WithStopwatchAsync($"{_typeName}::WriteState" Metrics.StopwatchObserver);
        }
    }
```

Where `WithStopwatchAsync` does just something like this:
```
        public static async Task&lt;T&gt; WithStopwatchAsync&lt;T&gt;(
            this Task&lt;T&gt; task
            [NotNull] Action&lt;TimeSpan&gt; onTaskFinished)
        {
            if (task == null) return default(T);
            if (onTaskFinished == null) throw new ArgumentNullException(nameof(onTaskFinished));

            var sw = new Stopwatch();
            sw.Start();

            try { return await task; }
            finally
            {
                sw.Stop();

                try { onTaskFinished(sw.Elapsed); }
                catch (Exception e)
                {
                    Trace.TraceError(
                        $"Errror calling {nameof(onTaskFinished)} in {nameof(StopwatchExtensions)}.{nameof(WithStopwatchAsync)}:\n{e}");
                }
            }
        }
```

We're running Orleans 2.0.5.

Any help would be hugely appreciated thanks in advance.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5107</IssueLabelID>
    <Title>CustomStorage.LogViewAdaptor could potentially cause an endless loop</Title>
    <Description>When there is an exception during `ReadStateFromStorage` in` LogViewAdaptor.ReadAsync` which is unrecoverable
the `JournalledGrain` ends up trying to load in an endless loop.

https://github.com/dotnet/orleans/blob/36faf869b555407e42b6f4db9e34db3848eab7d0/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs#L119-L169


We would like to deactivate the grain (same behavior as InconsistentState exception).

I've tried deactivating the grain inside the `ICustomStorageInterface&lt;T object&gt;.ReadStateFromStorage()` but that method is not run inside a grain context but from a BatchWorker.





</Description>
    <Title_Description>CustomStorage.LogViewAdaptor could potentially cause an endless loop When there is an exception during `ReadStateFromStorage` in` LogViewAdaptor.ReadAsync` which is unrecoverable
the `JournalledGrain` ends up trying to load in an endless loop.

https://github.com/dotnet/orleans/blob/36faf869b555407e42b6f4db9e34db3848eab7d0/src/Orleans.EventSourcing/CustomStorage/LogViewAdaptor.cs#L119-L169


We would like to deactivate the grain (same behavior as InconsistentState exception).

I've tried deactivating the grain inside the `ICustomStorageInterface&lt;T object&gt;.ReadStateFromStorage()` but that method is not run inside a grain context but from a BatchWorker.





</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5106</IssueLabelID>
    <Title>`Orleans.Runtime.Silo.StartAsync` stuck occasionally</Title>
    <Description>setup:
* memory storage + local cluster
* co-host  1)API gate  2) cluster client 3) silo host in one process
* orleans version:  b0fa5401891a2490bf99b95dca5d11c80df593d2

clrstack:
```
OS Thread Id: 0x853c (56)
        Child SP               IP Call Site
000000d82e37d3b0 00007fff625baa44 [GCFrame: 000000d82e37d3b0] 
000000d82e37d4f8 00007fff625baa44 [HelperMethodFrame_1OBJ: 000000d82e37d4f8] System.Threading.Monitor.ObjWait(Boolean Int32 System.Object)
000000d82e37d620 00007ffeee162d90 System.Threading.ManualResetEventSlim.Wait(Int32 System.Threading.CancellationToken)
000000d82e37d6c0 00007ffeee1304b7 System.Threading.Tasks.Task.SpinThenBlockingWait(Int32 System.Threading.CancellationToken)
000000d82e37d730 00007ffeee130355 System.Threading.Tasks.Task.InternalWaitCore(Int32 System.Threading.CancellationToken)
000000d82e37d7b0 00007ffeee1300cf System.Threading.Tasks.Task.Wait(Int32 System.Threading.CancellationToken)
000000d82e37d7f0 00007ffeee12fff2 System.Threading.Tasks.Task.Wait()
000000d82e37d820 00007ffead277cbd Sims.Program.startSilo() [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 259]
000000d82e37dc20 00007ffead275774 Sims.Program.startServices() [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 106]
000000d82e37dc50 00007ffeacf93239 Sims.Program.Main(System.String[]) [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 58]
000000d82e37df10 00007fff0ca63ba3 [GCFrame: 000000d82e37df10] 
000000d82e37e458 00007fff0ca63ba3 [GCFrame: 000000d82e37e458] 
```

`C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 259` is `siloHost.StartAsync().Wait()`</Description>
    <Title_Description>`Orleans.Runtime.Silo.StartAsync` stuck occasionally setup:
* memory storage + local cluster
* co-host  1)API gate  2) cluster client 3) silo host in one process
* orleans version:  b0fa5401891a2490bf99b95dca5d11c80df593d2

clrstack:
```
OS Thread Id: 0x853c (56)
        Child SP               IP Call Site
000000d82e37d3b0 00007fff625baa44 [GCFrame: 000000d82e37d3b0] 
000000d82e37d4f8 00007fff625baa44 [HelperMethodFrame_1OBJ: 000000d82e37d4f8] System.Threading.Monitor.ObjWait(Boolean Int32 System.Object)
000000d82e37d620 00007ffeee162d90 System.Threading.ManualResetEventSlim.Wait(Int32 System.Threading.CancellationToken)
000000d82e37d6c0 00007ffeee1304b7 System.Threading.Tasks.Task.SpinThenBlockingWait(Int32 System.Threading.CancellationToken)
000000d82e37d730 00007ffeee130355 System.Threading.Tasks.Task.InternalWaitCore(Int32 System.Threading.CancellationToken)
000000d82e37d7b0 00007ffeee1300cf System.Threading.Tasks.Task.Wait(Int32 System.Threading.CancellationToken)
000000d82e37d7f0 00007ffeee12fff2 System.Threading.Tasks.Task.Wait()
000000d82e37d820 00007ffead277cbd Sims.Program.startSilo() [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 259]
000000d82e37dc20 00007ffead275774 Sims.Program.startServices() [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 106]
000000d82e37dc50 00007ffeacf93239 Sims.Program.Main(System.String[]) [C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 58]
000000d82e37df10 00007fff0ca63ba3 [GCFrame: 000000d82e37df10] 
000000d82e37e458 00007fff0ca63ba3 [GCFrame: 000000d82e37e458] 
```

`C:\Users\a\source\repos\OrleansLobby\Sims\Program.cs @ 259` is `siloHost.StartAsync().Wait()`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5104</IssueLabelID>
    <Title>#2359 Migrated HelloWorld to dotnet core 2.1</Title>
    <Description>Migrated HelloWorld to dotnet core 2.1 #2359 </Description>
    <Title_Description>#2359 Migrated HelloWorld to dotnet core 2.1 Migrated HelloWorld to dotnet core 2.1 #2359 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5102</IssueLabelID>
    <Title>Tutorial 1 for Orleans 2.0</Title>
    <Description>This tutorial ties in with the Hello World sample. </Description>
    <Title_Description>Tutorial 1 for Orleans 2.0 This tutorial ties in with the Hello World sample. </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5101</IssueLabelID>
    <Title>Reenabled transaction recovery tests</Title>
    <Description>
    </Description>
    <Title_Description>Reenabled transaction recovery tests </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5100</IssueLabelID>
    <Title>Fix Consul rootKvFolder option is not backward compatible</Title>
    <Description>Fix rootKvFolder is not backward compatible</Description>
    <Title_Description>Fix Consul rootKvFolder option is not backward compatible Fix rootKvFolder is not backward compatible</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5099</IssueLabelID>
    <Title>Java service as producer of Orleans stream events</Title>
    <Description>I have question regarding producing stream events. We have java service the will store event to azure queue. Is it possible to integrate this events with Orleans streams?</Description>
    <Title_Description>Java service as producer of Orleans stream events I have question regarding producing stream events. We have java service the will store event to azure queue. Is it possible to integrate this events with Orleans streams?</Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5098</IssueLabelID>
    <Title>Fixed bug in transaction confirmation logic</Title>
    <Description>- Refactored confirmation management.
- Confirmation task only resoved after write to storage.</Description>
    <Title_Description>Fixed bug in transaction confirmation logic - Refactored confirmation management.
- Confirmation task only resoved after write to storage.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5097</IssueLabelID>
    <Title>Small issues running Orleans2.1 ClusterClient on Mono/Unity/Android</Title>
    <Description>Hello I am running Orleans 2.1 ClusterClient on Mono/Unity/Android. The common features work fine but following small problems:

1. 
https://github.com/dotnet/orleans/blob/b0fa5401891a2490bf99b95dca5d11c80df593d2/src/Orleans.Core/Runtime/RuntimeVersion.cs#L18

This line will throw an exception from GetVersionInfo because "thisProg.Location" param is empty under Android. 
The purpose of this line is only to print log but it prevents the ClusterClient from launching under Android.
Hope that a checking of whether the file exists here can be added before calling GetVersionInfo like:
`if (!File.Exists(thisProg.Location)) { return ApiVersion/"or some string else"; }`


2. 
https://github.com/dotnet/orleans/blob/b0fa5401891a2490bf99b95dca5d11c80df593d2/src/Orleans.Core/Configuration/ConfigUtilities.cs#L439

In this line "netInterface.OperationalStatus" is always OperationalStatus.Unknow under Android/iOS which will cause continuous continue and finnally to the bottom OrleansException throw.
I am currently changing this line to: 
`... != OperationalStatus.Up &amp;&amp; netInterface.OperationalStatus != OperationalStatus.Unknown`
This change may not be universal so I thought adding a property in ClientMessagingOptions would good like:
`Func&lt;NetworkInterface bool&gt; NetworkInterfaceFilter { get; set; }`
which can be configured during ClusterClient building and invoked in this line.

A question in addtion how will the address returned by this method GetLocalIPAddress be used by ClusterClient?

Thanks!</Description>
    <Title_Description>Small issues running Orleans2.1 ClusterClient on Mono/Unity/Android Hello I am running Orleans 2.1 ClusterClient on Mono/Unity/Android. The common features work fine but following small problems:

1. 
https://github.com/dotnet/orleans/blob/b0fa5401891a2490bf99b95dca5d11c80df593d2/src/Orleans.Core/Runtime/RuntimeVersion.cs#L18

This line will throw an exception from GetVersionInfo because "thisProg.Location" param is empty under Android. 
The purpose of this line is only to print log but it prevents the ClusterClient from launching under Android.
Hope that a checking of whether the file exists here can be added before calling GetVersionInfo like:
`if (!File.Exists(thisProg.Location)) { return ApiVersion/"or some string else"; }`


2. 
https://github.com/dotnet/orleans/blob/b0fa5401891a2490bf99b95dca5d11c80df593d2/src/Orleans.Core/Configuration/ConfigUtilities.cs#L439

In this line "netInterface.OperationalStatus" is always OperationalStatus.Unknow under Android/iOS which will cause continuous continue and finnally to the bottom OrleansException throw.
I am currently changing this line to: 
`... != OperationalStatus.Up &amp;&amp; netInterface.OperationalStatus != OperationalStatus.Unknown`
This change may not be universal so I thought adding a property in ClientMessagingOptions would good like:
`Func&lt;NetworkInterface bool&gt; NetworkInterfaceFilter { get; set; }`
which can be configured during ClusterClient building and invoked in this line.

A question in addtion how will the address returned by this method GetLocalIPAddress be used by ClusterClient?

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5095</IssueLabelID>
    <Title>Rewrite BufferPool with ArrayPool&lt;byte&gt;.Shared</Title>
    <Description>Let BufferPool wrap `ArrayPool&lt;byte&gt;.Shared` instead manage byte arrays directly similar to what MemoryPool does.

Since [`ArrayPool&lt;byte&gt;.Shared` doesn't accept arrays which not from pool](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs#L181) the workaround for this brokes the optimization in long bytes writing(like bytes from serializer).


</Description>
    <Title_Description>Rewrite BufferPool with ArrayPool&lt;byte&gt;.Shared Let BufferPool wrap `ArrayPool&lt;byte&gt;.Shared` instead manage byte arrays directly similar to what MemoryPool does.

Since [`ArrayPool&lt;byte&gt;.Shared` doesn't accept arrays which not from pool](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Buffers/TlsOverPerCoreLockedStacksArrayPool.cs#L181) the workaround for this brokes the optimization in long bytes writing(like bytes from serializer).


</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5093</IssueLabelID>
    <Title>Testing OneWay grain messages is hard</Title>
    <Description>Writing tests involving grain calls with [OneWay]s generally means getting to rig up a lock to wait until something else happens to make sure the OneWay actually fired. It's not awful but it does involve lots of boilerplate code.

Has there been any or is there any room for discussing testing these types of grain calls? I can think of a couple of options:
- Horrible static OneWayAttribute test-hook that causes one-way messages to be called normally
- Orleans configuration that causes all one-way attributes to be called normally
- A means of calling a grain method that forces a normal calling (this might exist?)
- The ability to extend OneWayAttribute (it's sealed right now) so as to extend or not from OneWayAttribute based on a configuration flag

Or perhaps there's a more obvious means of doing this in which case that's even better. :)</Description>
    <Title_Description>Testing OneWay grain messages is hard Writing tests involving grain calls with [OneWay]s generally means getting to rig up a lock to wait until something else happens to make sure the OneWay actually fired. It's not awful but it does involve lots of boilerplate code.

Has there been any or is there any room for discussing testing these types of grain calls? I can think of a couple of options:
- Horrible static OneWayAttribute test-hook that causes one-way messages to be called normally
- Orleans configuration that causes all one-way attributes to be called normally
- A means of calling a grain method that forces a normal calling (this might exist?)
- The ability to extend OneWayAttribute (it's sealed right now) so as to extend or not from OneWayAttribute based on a configuration flag

Or perhaps there's a more obvious means of doing this in which case that's even better. :)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5092</IssueLabelID>
    <Title>Receiving notifications about transaction lifecycle</Title>
    <Description>Hi

I'm looking for a way to send information about changes to grain state to an external service but only after the transaction in which those changes were made is committed.  To do this I'd like to be able to receive a notification (in each silo where the information was reported) after a transaction is confirmed or aborted.

It looks like there is some work around separating transaction management and participation specifically in #4810 #4820 and #4860.  From what I can understand the idea is to add an `ITransactionalResource` or `ITransactionalResourceExtension` as a participant in transactions I'm interested in but it's not clear what the "right" way to do this is.

I've run into a few issues going down this route - in particular when a reference to `ITransactionalResourceExtension` is a transaction participant it is sometimes assumed to also be an `ITransactionManagerExtension` (for example when it is the first participant added to the transaction).

Is separation of transaction management and participation intended to support this kind of use case?  If so is that support ready in version `2.1.0` and could you point me to some resources as to how to use it?

 </Description>
    <Title_Description>Receiving notifications about transaction lifecycle Hi

I'm looking for a way to send information about changes to grain state to an external service but only after the transaction in which those changes were made is committed.  To do this I'd like to be able to receive a notification (in each silo where the information was reported) after a transaction is confirmed or aborted.

It looks like there is some work around separating transaction management and participation specifically in #4810 #4820 and #4860.  From what I can understand the idea is to add an `ITransactionalResource` or `ITransactionalResourceExtension` as a participant in transactions I'm interested in but it's not clear what the "right" way to do this is.

I've run into a few issues going down this route - in particular when a reference to `ITransactionalResourceExtension` is a transaction participant it is sometimes assumed to also be an `ITransactionManagerExtension` (for example when it is the first participant added to the transaction).

Is separation of transaction management and participation intended to support this kind of use case?  If so is that support ready in version `2.1.0` and could you point me to some resources as to how to use it?

 </Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5091</IssueLabelID>
    <Title>Will you join sagas in the later plan?</Title>
    <Description>actor+sagas is very good.
ex:  https://github.com/apache/incubator-servicecomb-saga
https://github.com/OpenSagas-csharp/servicecomb-saga-csharp</Description>
    <Title_Description>Will you join sagas in the later plan? actor+sagas is very good.
ex:  https://github.com/apache/incubator-servicecomb-saga
https://github.com/OpenSagas-csharp/servicecomb-saga-csharp</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5089</IssueLabelID>
    <Title>Backport: Revert some revert change to fix backward compatibility (#5088)</Title>
    <Description>
    </Description>
    <Title_Description>Backport: Revert some revert change to fix backward compatibility (#5088) </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5087</IssueLabelID>
    <Title>Backport #5086 for 2.1.2</Title>
    <Description>
    </Description>
    <Title_Description>Backport #5086 for 2.1.2 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5086</IssueLabelID>
    <Title>Revert "Don't enforce reentrancy for one way requests" #4382</Title>
    <Description>It seems that #4382 introduced some regressions (see #5080 #5059 maybe other weird behavior).

I propose we revert it to be able to quickly publish a new 2.1 version. We can then work to bring it back in 2.2.0 once the issue is fixed.</Description>
    <Title_Description>Revert "Don't enforce reentrancy for one way requests" #4382 It seems that #4382 introduced some regressions (see #5080 #5059 maybe other weird behavior).

I propose we revert it to be able to quickly publish a new 2.1 version. We can then work to bring it back in 2.2.0 once the issue is fixed.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5085</IssueLabelID>
    <Title>TimeoutExceptions on deployments</Title>
    <Description>We're seeing a load of errors when we deploy new Silos around timeouts. We see messages like: ```Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message NewPlacement Request S10.244.3.112:11111:276798707*cli/0baec4b3@b8382fb9-&gt;S10.244.3.112:11111:276798707*grn/649A94A0/00000000@90dc1d82 #13[ForwardCount=2]:  for 2 times after ReceiveRequest to invalid activation. Rejecting now.``` and
```System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.244.3.112:11111:276798707*cli/0baec4b3@b8382fb9-&gt;S10.244.3.112:11111:276798707*grn/649A94A0/00000000@fd6354b5 #11016: . Target History is: &lt;S10.244.3.112:11111:276798707:*grn/649A94A0/00000000:@fd6354b5&gt;.```

We have a background service that lives in the same process as our Silos that pulls messages from a queue and calls a method on a grain to deliver the data. It's these calls that are failing. We're using ILifecycleParticipant&lt;ISiloLifecycle&gt; to start &amp; stop this background service.

The silos updated via rolling deployments in Kubernetes. Once everything settles these error messages go away.

Is there some way we can fix these errors?</Description>
    <Title_Description>TimeoutExceptions on deployments We're seeing a load of errors when we deploy new Silos around timeouts. We see messages like: ```Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message NewPlacement Request S10.244.3.112:11111:276798707*cli/0baec4b3@b8382fb9-&gt;S10.244.3.112:11111:276798707*grn/649A94A0/00000000@90dc1d82 #13[ForwardCount=2]:  for 2 times after ReceiveRequest to invalid activation. Rejecting now.``` and
```System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.244.3.112:11111:276798707*cli/0baec4b3@b8382fb9-&gt;S10.244.3.112:11111:276798707*grn/649A94A0/00000000@fd6354b5 #11016: . Target History is: &lt;S10.244.3.112:11111:276798707:*grn/649A94A0/00000000:@fd6354b5&gt;.```

We have a background service that lives in the same process as our Silos that pulls messages from a queue and calls a method on a grain to deliver the data. It's these calls that are failing. We're using ILifecycleParticipant&lt;ISiloLifecycle&gt; to start &amp; stop this background service.

The silos updated via rolling deployments in Kubernetes. Once everything settles these error messages go away.

Is there some way we can fix these errors?</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5084</IssueLabelID>
    <Title>Added testing reference from 1.5 for 2.0.</Title>
    <Description>Also added reference around dependency injection after a conversation
with @ReubonBond.

Fixes #5083.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Description>
    <Title_Description>Added testing reference from 1.5 for 2.0. Also added reference around dependency injection after a conversation
with @ReubonBond.

Fixes #5083.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>9/10/2018 6:23:18 AM +00:00</CreatedAt>
    <ClosedAt>10/10/2018 7:34:11 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5083</IssueLabelID>
    <Title>1.5 -&gt; 2.0 testing documentation</Title>
    <Description>Looking at the [1.5 testing docs](https://dotnet.github.io/orleans/1.5/Tutorials/Unit-Testing-Grains.html) there is guidance on how to mock the cluster and grains but that documentation isn't carried forward into 2.0. There is also a constructor signature change as well:

```c#
// old
TestCluster();

// new
TestCluster(TestClusterOptions options IReadOnlyList&lt;IConfigurationSource&gt; configurationSources)
```

The docs don't explain what the change is nor does the code give too many hints on proper usage.</Description>
    <Title_Description>1.5 -&gt; 2.0 testing documentation Looking at the [1.5 testing docs](https://dotnet.github.io/orleans/1.5/Tutorials/Unit-Testing-Grains.html) there is guidance on how to mock the cluster and grains but that documentation isn't carried forward into 2.0. There is also a constructor signature change as well:

```c#
// old
TestCluster();

// new
TestCluster(TestClusterOptions options IReadOnlyList&lt;IConfigurationSource&gt; configurationSources)
```

The docs don't explain what the change is nor does the code give too many hints on proper usage.</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5082</IssueLabelID>
    <Title>Allow placement strategies to specify deterministic activation ids</Title>
    <Description>When grains are placed using the (upcoming) Service Fabric Stateful Service strategy there is no grain directory involvement and hence we need a mechanism to determine which activation id to use when routing messages.

This PR enables that functionality but keeps it *`internal`* so that it will only be exposed to the SF library for now. The reasoning here is that it's unlikely anyone else will need it and if someone stumbles upon this they may opt-in to it for their placement strategy without understanding the consequences.

If `PlacementStrategy.IsDeterministicActivationId` is `true` then all activations for a particular grain will have an `ActivationId` whose `Key` is equal to the grain's `GrainId.Key`. If `false` then no behavior changes and `ActivationId` is randomly generated.

Without this PR initial calls to already-activated grains placed using `StatefulServicePlacement` will round-trip to the target silo using the incorrect generated `ActivationId` and the silo will need to forward those calls to the correct activation. The response message will invalidate the caller's routing cache but will not specify the activation's new address so the caller will continue to call using incorrect `ActivationId`s. This is *benign* but unpleasant and inefficient. Users would almost certainly complain about warnings and other garbage in their logs. It is also slower. This PR enables the first and subsequent call to succeed without any round-trips for routing info.

See #5073 under part 4:
&gt; Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e 1:1 relationship). It's possible that this will be contentious since previously an `ActivationId` was ephemeral. This change is important though because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy` which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)</Description>
    <Title_Description>Allow placement strategies to specify deterministic activation ids When grains are placed using the (upcoming) Service Fabric Stateful Service strategy there is no grain directory involvement and hence we need a mechanism to determine which activation id to use when routing messages.

This PR enables that functionality but keeps it *`internal`* so that it will only be exposed to the SF library for now. The reasoning here is that it's unlikely anyone else will need it and if someone stumbles upon this they may opt-in to it for their placement strategy without understanding the consequences.

If `PlacementStrategy.IsDeterministicActivationId` is `true` then all activations for a particular grain will have an `ActivationId` whose `Key` is equal to the grain's `GrainId.Key`. If `false` then no behavior changes and `ActivationId` is randomly generated.

Without this PR initial calls to already-activated grains placed using `StatefulServicePlacement` will round-trip to the target silo using the incorrect generated `ActivationId` and the silo will need to forward those calls to the correct activation. The response message will invalidate the caller's routing cache but will not specify the activation's new address so the caller will continue to call using incorrect `ActivationId`s. This is *benign* but unpleasant and inefficient. Users would almost certainly complain about warnings and other garbage in their logs. It is also slower. This PR enables the first and subsequent call to succeed without any round-trips for routing info.

See #5073 under part 4:
&gt; Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e 1:1 relationship). It's possible that this will be contentious since previously an `ActivationId` was ephemeral. This change is important though because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy` which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5081</IssueLabelID>
    <Title>Update "What is a Grain Client?" doc page to 2.0 configuration API</Title>
    <Description>http://dotnet.github.io/orleans/Documentation/clusters_and_clients/index.html#initialization-of-grain-client is still referring to the legacy configuration API. We need to make it consistent with http://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/client_configuration.html. Otherwise the page content is confusing.</Description>
    <Title_Description>Update "What is a Grain Client?" doc page to 2.0 configuration API http://dotnet.github.io/orleans/Documentation/clusters_and_clients/index.html#initialization-of-grain-client is still referring to the legacy configuration API. We need to make it consistent with http://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/client_configuration.html. Otherwise the page content is confusing.</Title_Description>
    <Label>P1</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5080</IssueLabelID>
    <Title>Orleans.Storage.InconsistentStateException after migrating to Orleans 2.1 (repro sample included)</Title>
    <Description>I have an issue after updating to Orleans 2.1. I am using `MemoryGrainStorage` for my integrational tests and tests started failing after update (maybe problem not in memory storage but in new scheduler). I have created small project to reproduce this issue. I think this is trivial flow for grains and shouldn't throw any exceptions.
[Grains.zip](https://github.com/dotnet/orleans/files/2457102/Grains.zip)

</Description>
    <Title_Description>Orleans.Storage.InconsistentStateException after migrating to Orleans 2.1 (repro sample included) I have an issue after updating to Orleans 2.1. I am using `MemoryGrainStorage` for my integrational tests and tests started failing after update (maybe problem not in memory storage but in new scheduler). I have created small project to reproduce this issue. I think this is trivial flow for grains and shouldn't throw any exceptions.
[Grains.zip](https://github.com/dotnet/orleans/files/2457102/Grains.zip)

</Title_Description>
    <Label>P1</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5079</IssueLabelID>
    <Title>is it possible to prevent timers from starting?</Title>
    <Description>We have a case where we shut all silos down at once and start them again.
this is mainly when we need to rollback to a previous version or perform an upgrade that is not possible as a rolling upgrade (like upgrading to orleans 2.0).

what we see is we have a lot of reminders ticking just as soon as some silos become available and therefore have a lot of stuff happening before we are ready for it.
this also causes most of the activations to go on the first silo that was ready then we have to restart that one to rebalance the activations.

what do you suggest doing?</Description>
    <Title_Description>is it possible to prevent timers from starting? We have a case where we shut all silos down at once and start them again.
this is mainly when we need to rollback to a previous version or perform an upgrade that is not possible as a rolling upgrade (like upgrading to orleans 2.0).

what we see is we have a lot of reminders ticking just as soon as some silos become available and therefore have a lot of stuff happening before we are ready for it.
this also causes most of the activations to go on the first silo that was ready then we have to restart that one to rebalance the activations.

what do you suggest doing?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5076</IssueLabelID>
    <Title>proposal: add issue template</Title>
    <Description>e.g. 
1. https://github.com/golang/go/issues/new
2. https://github.com/golang/go/blob/master/.github/ISSUE_TEMPLATE</Description>
    <Title_Description>proposal: add issue template e.g. 
1. https://github.com/golang/go/issues/new
2. https://github.com/golang/go/blob/master/.github/ISSUE_TEMPLATE</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5075</IssueLabelID>
    <Title>Getting `System.InvalidOperationException: Grain directory is stopping` when shutting down </Title>
    <Description>setup:
* memory storage + local cluster
* co-host  1)API gate  2) cluster client 3) silo host in one process
* orleans version:  （almost) bb360159f695b008be701d7bafd581e410781001 
 ( https://github.com/sillyousu/orleans/tree/fix-4965)

When I shutdown the process I got following warning:
```
2018-10-05 16:28:18.2058|INFO|Sims.Program|Recevie signal shutting down
~\source\repos\OrleansLobby\Sims [master ≡ +0 ~9 -0 !]&gt; 2018-10-05 16:28:18.3516|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002767@9c66859e-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #121[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4219|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002767@9c66859e-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #121[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.4708|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002767@3e27ffa6-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #123[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.4941|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002767@3e27ffa6-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #123[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.4941|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.5562|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6057|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6397|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6874|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002766@234b9789-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #122[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.7024|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002766@234b9789-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #122[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.7024|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.7887|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002766@a66f81a1-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #120[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.8041|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002766@a66f81a1-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #120[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.8041|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.8379|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
```</Description>
    <Title_Description>Getting `System.InvalidOperationException: Grain directory is stopping` when shutting down  setup:
* memory storage + local cluster
* co-host  1)API gate  2) cluster client 3) silo host in one process
* orleans version:  （almost) bb360159f695b008be701d7bafd581e410781001 
 ( https://github.com/sillyousu/orleans/tree/fix-4965)

When I shutdown the process I got following warning:
```
2018-10-05 16:28:18.2058|INFO|Sims.Program|Recevie signal shutting down
~\source\repos\OrleansLobby\Sims [master ≡ +0 ~9 -0 !]&gt; 2018-10-05 16:28:18.3516|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002767@9c66859e-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #121[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.4061|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.4219|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002767@9c66859e-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #121[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.4708|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002767@3e27ffa6-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #123[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.4941|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002767@3e27ffa6-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002767+ClientMessageService_ClientMessageService@466cef8e #123[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.4941|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.5562|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6057|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6397|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.6874|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002766@234b9789-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #122[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.7024|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/442EA8BA/00002766@234b9789-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #122[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.7024|WARN|Orleans.Runtime.Dispatcher|Failed to un-register NonExistentActivation S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterAsync(ActivationAddress address UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 675
   at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass18_1.&lt;&lt;ReceiveMessage&gt;b__0&gt;d.MoveNext() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Core\Dispatcher.cs:line 166
2018-10-05 16:28:18.7887|WARN|Orleans.Runtime.Dispatcher|Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002766@a66f81a1-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #120[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
2018-10-05 16:28:18.8041|WARN|Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1[[LobbyGrains.Core.Messages.ClientMessage LobbyGrains Version=1.0.0.0 Culture=neutral PublicKeyToken=null]]|Ignoring unhandled exception during PubSub.UnregisterProducer Orleans.Runtime.OrleansMessageRejectionException: Forwarding failed: tried to forward message Request S127.0.0.1:11111:276424065*grn/736BA21C/00002766@a66f81a1-&gt;S127.0.0.1:11111:276424065*grn/716E8E94/00002766+ClientMessageService_ClientMessageService@28e00185 #120[ForwardCount=2]:  for 2 times after Non-existent activation to invalid activation. Rejecting now.
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.Cleanup() in C:\Users\a\source\repos\orleans\src\Orleans.Core\Streams\SimpleMessageStream\SimpleMessageStreamProducer.cs:line 157
2018-10-05 16:28:18.8041|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 2 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
2018-10-05 16:28:18.8379|WARN|Orleans.Runtime.Catalog|UnregisterManyAsync 1 failed. System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 560
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 721
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterManyAsync(List`1 addresses UnregistrationCause cause Int32 hopCount) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs:line 768
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.Execute() in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63
   at Orleans.Runtime.Catalog.FinishDestroyActivations(List`1 list Int32 number MultiTaskCompletionSource tcs) in C:\Users\a\source\repos\orleans\src\Orleans.Runtime\Catalog\Catalog.cs:line 1013
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5072</IssueLabelID>
    <Title>IMessageCenter.WaitMessage support cancellation</Title>
    <Description>In the shutdown procedure the message center thread is blocked for waiting for
new inbound messages. Meanwhile the shutdown procedure also dispose 
the in-used objects (BlockingCollection) which cause unexpected throw
(ArgumentNullException) in message center thread.

The original decision that avoiding passing cancellation to
`BlockingCollection.Take` was in consideration of performance.
But I can't see any regression in my benchmark program.

see also:
https://github.com/dotnet/corefx/issues/14320#issuecomment-266128170

fix #4965</Description>
    <Title_Description>IMessageCenter.WaitMessage support cancellation In the shutdown procedure the message center thread is blocked for waiting for
new inbound messages. Meanwhile the shutdown procedure also dispose 
the in-used objects (BlockingCollection) which cause unexpected throw
(ArgumentNullException) in message center thread.

The original decision that avoiding passing cancellation to
`BlockingCollection.Take` was in consideration of performance.
But I can't see any regression in my benchmark program.

see also:
https://github.com/dotnet/corefx/issues/14320#issuecomment-266128170

fix #4965</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5070</IssueLabelID>
    <Title>Partial fix for transaction recovery tests</Title>
    <Description>- May still be an issues need to run test 19289 more times in a row to find it :/
- Still looking</Description>
    <Title_Description>Partial fix for transaction recovery tests - May still be an issues need to run test 19289 more times in a row to find it :/
- Still looking</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5069</IssueLabelID>
    <Title>Service Fabric Mesh support</Title>
    <Description>I started thinking about adding support for [Service Fabric Mesh](https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-overview).

So far the docker-aspnet-core example works like a charm example [here](https://github.com/mholo65/mesh-orleans-sample/tree/414d0d73c3a1e977de1667a977fc2e153645b992). But I want to take this further and use Service Fabric Mesh for clustering and (when Service Fabric 6.4 lands) use Standalone Reliable Collections for persisting grain state.

For clustering I started looking at current the current implementation in `Microsoft.Orleans.Clustering.ServiceFabric` and _"I think"_ that a similar approach would be doable but instead of taking dependency on `System.Fabric.FabricClient` one should try using the [Service Fabric Client REST Api](https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-index#applicationresource-apissfclient-index-applicationresourcemd) instead.

Now to the questions:
- Is adding support for Service Fabric Mesh on your roadmap? AFAIK Mesh will not bring the Actor programming model currently available in Service Fabric Native. People (including me) are looking for alternatives if moving to Service Fabric Mesh. I would love to help adding Mesh support for Orleans.
- As I'm new to Orleans (and specifically extending Orleans) I might need some help on getting started. To add support for new clustering providers am I right in saying that I need to implement the following services?:
  - `IMembershipOracle` or `IMembershipTable`
  - `IGatewayListProvider`.</Description>
    <Title_Description>Service Fabric Mesh support I started thinking about adding support for [Service Fabric Mesh](https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-overview).

So far the docker-aspnet-core example works like a charm example [here](https://github.com/mholo65/mesh-orleans-sample/tree/414d0d73c3a1e977de1667a977fc2e153645b992). But I want to take this further and use Service Fabric Mesh for clustering and (when Service Fabric 6.4 lands) use Standalone Reliable Collections for persisting grain state.

For clustering I started looking at current the current implementation in `Microsoft.Orleans.Clustering.ServiceFabric` and _"I think"_ that a similar approach would be doable but instead of taking dependency on `System.Fabric.FabricClient` one should try using the [Service Fabric Client REST Api](https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-index#applicationresource-apissfclient-index-applicationresourcemd) instead.

Now to the questions:
- Is adding support for Service Fabric Mesh on your roadmap? AFAIK Mesh will not bring the Actor programming model currently available in Service Fabric Native. People (including me) are looking for alternatives if moving to Service Fabric Mesh. I would love to help adding Mesh support for Orleans.
- As I'm new to Orleans (and specifically extending Orleans) I might need some help on getting started. To add support for new clustering providers am I right in saying that I need to implement the following services?:
  - `IMembershipOracle` or `IMembershipTable`
  - `IGatewayListProvider`.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5067</IssueLabelID>
    <Title>"System" namespace conflicts with generated code</Title>
    <Description>A namespace of of *.System breaks with the generated code because the binding flags don't use the global alias.

`System.Reflection.BindingFlags.NonPublic` vs `global::System.Reflection.BindingFlags.NonPublic`

PR to follow.</Description>
    <Title_Description>"System" namespace conflicts with generated code A namespace of of *.System breaks with the generated code because the binding flags don't use the global alias.

`System.Reflection.BindingFlags.NonPublic` vs `global::System.Reflection.BindingFlags.NonPublic`

PR to follow.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5066</IssueLabelID>
    <Title>Disable fault injection tx test</Title>
    <Description>Disable fault injection tx test will turn it on after investigation on its failures </Description>
    <Title_Description>Disable fault injection tx test Disable fault injection tx test will turn it on after investigation on its failures </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5064</IssueLabelID>
    <Title>Dissabling transaction recovery tests while investigating</Title>
    <Description>
    </Description>
    <Title_Description>Dissabling transaction recovery tests while investigating </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5063</IssueLabelID>
    <Title>Backport fixes to ZooKeeper and Consul providers to 2.1.1</Title>
    <Description>
    </Description>
    <Title_Description>Backport fixes to ZooKeeper and Consul providers to 2.1.1 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5062</IssueLabelID>
    <Title>Increase package versions to 2.2.0</Title>
    <Description>Increase package versions to 2.2.0 so that we don't need to update it for every patch release.
Also add a missing nuget packaging condition for Service Fabric meta-package.</Description>
    <Title_Description>Increase package versions to 2.2.0 Increase package versions to 2.2.0 so that we don't need to update it for every patch release.
Also add a missing nuget packaging condition for Service Fabric meta-package.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5061</IssueLabelID>
    <Title>Start using Span and new language features for increasing Orleans perfomance</Title>
    <Description>Initial PR to inject Span and C# 7.3 optimizations in Orleans project with simple example of using it where we avoid unnecessary GC array allocations.</Description>
    <Title_Description>Start using Span and new language features for increasing Orleans perfomance Initial PR to inject Span and C# 7.3 optimizations in Orleans project with simple example of using it where we avoid unnecessary GC array allocations.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5059</IssueLabelID>
    <Title>Inconsistent State Exception on PubSub grain</Title>
    <Description>Hello folks

When we are starting a silo it get several messages about duplicated activations of a grain the PubSub grain which is weird because they happen on a single silo as well. After that those grains are being deactivated and then I see `InconsistentStateException` from the PubSub grain state storage.  After it appear over and over looks like the silo give up trying to activate them and then we start to the see messages of `.NET Runtime Platform stalled for XXXX - possibly GC?...` and the mem count is growing until eat the whole machine memory (last time we tried it was 22Gb when I stopped the process + we had 8gb of logs!). 

Here is a piece of the logs when initializing the silo. It is important to notice that we are using AWS providers but it happens even with in-memory grain storage.

```
[2018-10-02 19:11:11.369] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue5] [INFO] [Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider.InventoryClientStreamProvider] - Initialized SimpleMessageStreamProvider with name InventoryClientStreamProvider and with property FireAndForgetDelivery: True OptimizeForImmutableData: True and PubSubType: ExplicitGrainBasedAndImplicit
[2018-10-02 19:11:11.514] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.517] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.520] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.689] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.719] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.740] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:11.747] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.750] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.765] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=5261 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] took elapsed time 0:00:00.2416379 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:11.779] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.791] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.795] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.801] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.805] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.821] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.843] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.845] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.849] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.854] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.879] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #0 of 1 activations
[2018-10-02 19:11:12.015] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 4 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 to address  after Finished Destroy Activation.
[2018-10-02 19:11:12.017] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200@be7db6a5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #791: .
[2018-10-02 19:11:12.018] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #0 - Destroyed 1 Activations.
[2018-10-02 19:11:12.019] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #881: .
[2018-10-02 19:11:12.021] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #990: .
[2018-10-02 19:11:12.053] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #1165: .
[2018-10-02 19:11:12.057] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4b53de7f534a8c5a81d406d0dc4fe4ab0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.058] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4d0a14e4c0c856e7ffafb6e394a65c960000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.062] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.069] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.070] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab #990[ForwardCount=1]: .
[2018-10-02 19:11:12.071] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4b49cc711d3404dd7ebe73525239098f0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.072] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 #1165[ForwardCount=1]: .
[2018-10-02 19:11:12.078] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.081] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f #881[ForwardCount=1]: .
[2018-10-02 19:11:12.180] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.191] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.215] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.231] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.233] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:12.239] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.240] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.271] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.293] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.298] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.303] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.307] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.310] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.337] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.355] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.357] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.364] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.367] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.371] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #1 of 1 activations
[2018-10-02 19:11:12.374] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 2 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 to address  after Finished Destroy Activation.
[2018-10-02 19:11:12.378] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #1 - Destroyed 1 Activations.
[2018-10-02 19:11:12.381] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #1872: .
[2018-10-02 19:11:12.386] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #2056: .
[2018-10-02 19:11:12.392] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @489bf915a3e24b23108b25baee120aaa0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.401] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4add9305d5ad03170740839e8ff39b810000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.401] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 after Duplicate activation.
[2018-10-02 19:11:12.406] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 after Duplicate activation.
[2018-10-02 19:11:12.406] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa #2056[ForwardCount=1]: .
[2018-10-02 19:11:12.409] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 0. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 #2208: .
[2018-10-02 19:11:12.502] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.529] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.549] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.551] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:12.557] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.559] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.562] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #2 of 1 activations
[2018-10-02 19:11:12.566] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #2 - Destroyed 1 Activations.
[2018-10-02 19:11:13.813] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.0240075 - possibly GC? We are now using total of 82MB memory. gc=2 2 2
[2018-10-02 19:11:15.992] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1767644 - possibly GC? We are now using total of 108MB memory. gc=2 2 2
[2018-10-02 19:11:17.126] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003a6153-0d0a-0d02-0016-0075002e8c25"
[2018-10-02 19:11:17.561] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=117350 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/87C3DBC4/00000000+Default@2ac2a3af #GrainType=QCMachinePoolGrainLibrary.MachinePoolGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2842059 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:19.556] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1789757 - possibly GC? We are now using total of 155MB memory. gc=2 2 2
[2018-10-02 19:11:25.525] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1901570 - possibly GC? We are now using total of 134MB memory. gc=4 3 3
[2018-10-02 19:11:55.947] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Before collection#2: memory=605MB #activations=28 collector=&lt;#Activations=26 #Buckets=2 buckets=[0h:10m:4s.75ms-&gt;1 items 2h:0m:4s.75ms-&gt;25 items]&gt;.
[2018-10-02 19:12:05.717] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.TypeManager] - OnRefreshClusterMapTimer: refresh start
[2018-10-02 19:11:39.104] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003a1edd-220a-0b02-0017-03bb57e80469"
[2018-10-02 19:12:08.210] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=693978 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5 #GrainType=QCServicesGrainLibrary.AccountDataClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2901696 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:58.971] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=623289 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003a1edd-220a-0b02-0017-03bb57e80469@c08349a8 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Activating] took elapsed time 0:01:19.8673859 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:53.092] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003b863e-320a-0b02-0018-01f05c68aa3d"
[2018-10-02 19:12:58.980] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - After collection#2: memory=479MB #activations=28 collected 0 activations collector=&lt;#Activations=26 #Buckets=3 buckets=[0h:9m:1s.20ms-&gt;1 items 1h:59m:1s.20ms-&gt;16 items 2h:0m:1s.20ms-&gt;9 items]&gt; collection time=00:01:03.0548348.
[2018-10-02 19:12:58.981] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=977052 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003b863e-320a-0b02-0018-01f05c68aa3d@c8468eb2 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Activating] took elapsed time 0:01:05.8894345 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.203] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=686414 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981 #GrainType=QCServicesGrainLibrary.QuestClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2851082 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.211] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue5] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=719966 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd #GrainType=QCServicesGrainLibrary.InventoryClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2942272 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:58.988] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [WARN] [Orleans.Runtime.Scheduler *stg/14/0000000e.WorkItemGroup] - Task [Id=1049335 Status=RanToCompletion] in WorkGroup [SystemTarget: S10.1.8.29:11111:276203453*stg/14/0000000e@S0000000e] took elapsed time 0:01:03.0628451 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.204] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue6] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=1186230 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/F8588497/00000000+003ae096-090a-0d02-0018-0218071ef200@7ba03585 #GrainType=QCGameLobbyGrainLibrary.GameLobbyClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2833186 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.203] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue7] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=742265 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200@be7db6a5 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2831067 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:59.004] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [WARN] [Orleans.Runtime.GrainTimer] - -GrainTimer.Membership.ProbeTimer. TimerCallbackHandler:Orleans.Runtime.GrainTimer+&lt;&gt;c__DisplayClass16_0-&gt;System.Threading.Tasks.Task &lt;FromTimerCallback&gt;b__0(System.Object) did not fire on time. Last fired at 2018-10-02 19:12:03.846 GMT 00:00:55.1516845 since previous fire should have fired after 00:00:10.
[2018-10-02 19:12:59.055] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [WARN] [Orleans.Runtime.Scheduler *stg/17/00000011.WorkItemGroup] - Task [Id=1292243 Status=RanToCompletion] in WorkGroup [SystemTarget: S10.1.8.29:11111:276203453*stg/17/00000011@S00000011] took elapsed time 0:00:53.337184 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
```
</Description>
    <Title_Description>Inconsistent State Exception on PubSub grain Hello folks

When we are starting a silo it get several messages about duplicated activations of a grain the PubSub grain which is weird because they happen on a single silo as well. After that those grains are being deactivated and then I see `InconsistentStateException` from the PubSub grain state storage.  After it appear over and over looks like the silo give up trying to activate them and then we start to the see messages of `.NET Runtime Platform stalled for XXXX - possibly GC?...` and the mem count is growing until eat the whole machine memory (last time we tried it was 22Gb when I stopped the process + we had 8gb of logs!). 

Here is a piece of the logs when initializing the silo. It is important to notice that we are using AWS providers but it happens even with in-memory grain storage.

```
[2018-10-02 19:11:11.369] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue5] [INFO] [Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProvider.InventoryClientStreamProvider] - Initialized SimpleMessageStreamProvider with name InventoryClientStreamProvider and with property FireAndForgetDelivery: True OptimizeForImmutableData: True and PubSubType: ExplicitGrainBasedAndImplicit
[2018-10-02 19:11:11.514] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.517] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.520] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:11.689] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.719] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.740] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:11.747] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.750] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.765] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=5261 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] took elapsed time 0:00:00.2416379 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:11.779] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.791] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.795] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.801] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.805] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.821] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:11.843] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:11.845] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.849] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:11.854] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:11.879] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue0] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #0 of 1 activations
[2018-10-02 19:11:12.015] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 4 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 to address  after Finished Destroy Activation.
[2018-10-02 19:11:12.017] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200@be7db6a5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #791: .
[2018-10-02 19:11:12.018] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #0 - Destroyed 1 Activations.
[2018-10-02 19:11:12.019] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #881: .
[2018-10-02 19:11:12.021] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #990: .
[2018-10-02 19:11:12.053] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b729e883 #1165: .
[2018-10-02 19:11:12.057] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4b53de7f534a8c5a81d406d0dc4fe4ab0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.058] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4d0a14e4c0c856e7ffafb6e394a65c960000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.062] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.069] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.070] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@dc4fe4ab #990[ForwardCount=1]: .
[2018-10-02 19:11:12.071] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4b49cc711d3404dd7ebe73525239098f0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.072] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@94a65c96 #1165[ForwardCount=1]: .
[2018-10-02 19:11:12.078] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 after Duplicate activation.
[2018-10-02 19:11:12.081] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@5239098f #881[ForwardCount=1]: .
[2018-10-02 19:11:12.180] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.191] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.215] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.231] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.233] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:12.239] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.240] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.271] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.293] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.298] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.303] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.307] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.310] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.337] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.355] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.357] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.364] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.367] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.371] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #1 of 1 activations
[2018-10-02 19:11:12.374] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 2 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 to address  after Finished Destroy Activation.
[2018-10-02 19:11:12.378] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #1 - Destroyed 1 Activations.
[2018-10-02 19:11:12.381] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #1872: .
[2018-10-02 19:11:12.386] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Finished Destroy Activation ForwardCount = 0. Message Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@f26d2584 #2056: .
[2018-10-02 19:11:12.392] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @489bf915a3e24b23108b25baee120aaa0000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.401] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Tried to create a duplicate activation S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 but we'll use S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 instead. GrainInstanceType is Orleans.Streams.PubSubRendezvousGrain. Primary Directory partition for this grain is S10.1.8.29:11111:276203453. Full activation address is [ActivationAddress: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 Full GrainId: [GrainId: *grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 IdCategory: KeyExtGrain BaseTypeCode: 1903070868 (x716E8E94) PrimaryKey: 144627d0-3bb3-5d6a-8e9d-3389d225348e (x{0x144627d00x3bb30x5d6a{0x8e0x9d0x330x890xd20x250x340x8e}}) UniformHashCode: 4270266246 (0xFE871786) KeyExtension: ClientStreamProvider_OnDisconnected] Full ActivationId: @4add9305d5ad03170740839e8ff39b810000000000000000]. We have 1 messages to forward.
[2018-10-02 19:11:12.401] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 after Duplicate activation.
[2018-10-02 19:11:12.406] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Dispatcher] - Forwarding 1 requests destined for address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 to address S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 after Duplicate activation.
[2018-10-02 19:11:12.406] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 1. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@ee120aaa #2056[ForwardCount=1]: .
[2018-10-02 19:11:12.409] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.Dispatcher] - Trying to forward after Duplicate activation ForwardCount = 0. Message NewPlacement Request S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5-&gt;S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@8ff39b81 #2208: .
[2018-10-02 19:11:12.502] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Persistence.DynamoDB.DynamoDBStorage] - Intermediate error upserting to the table localGutemberg_GrainState
[2018-10-02 19:11:12.529] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Storage.DynamoDBGrainStorage] - Error from storage provider DynamoDBGrainStorage.Orleans.Streams.PubSubRendezvousGrain during WriteState for grain Type=Orleans.Streams.PubSubRendezvousGrain Pk=*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786 Id=GrainReference:*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected Error=

Exc level 0: Orleans.Storage.InconsistentStateException: Invalid grain state
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 171
   at Orleans.Core.StateStorageBridge`1.WriteStateAsync() in D:\build\agent\_work\17\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 100
Exc level 1: Amazon.DynamoDBv2.Model.ConditionalCheckFailedException: The conditional request failed
   at Amazon.Runtime.Internal.HttpErrorResponseExceptionHandler.HandleException(IExecutionContext executionContext HttpErrorResponseException exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\HttpErrorResponseExceptionHandler.cs:line 60
   at Amazon.Runtime.Internal.ErrorHandler.ProcessException(IExecutionContext executionContext Exception exception) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 212
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\ErrorHandler\ErrorHandler.cs:line 104
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CredentialsRetriever.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\Handlers\CredentialsRetriever.cs:line 98
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.RetryHandler.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\RetryHandler\RetryHandler.cs:line 137
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.CallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorCallbackHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.MetricsHandler.InvokeAsync[T](IExecutionContext executionContext)
   at Orleans.Persistence.DynamoDB.DynamoDBStorage.UpsertEntryAsync(String tableName Dictionary`2 keys Dictionary`2 fields String conditionExpression Dictionary`2 conditionValues String extraExpression Dictionary`2 extraExpressionValues) in D:\build\agent\_work\17\s\src\AWS\Shared\Storage\DynamoDBStorage.cs:line 287
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateInternal(IGrainState grainState GrainStateRecord record Boolean clear) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 234
   at Orleans.Storage.DynamoDBGrainStorage.WriteStateAsync(String grainType GrainReference grainReference IGrainState grainState) in D:\build\agent\_work\17\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs:line 167
Exc level 2: Amazon.Runtime.Internal.HttpErrorResponseException: Exception of type 'Amazon.Runtime.Internal.HttpErrorResponseException' was thrown.
   at Amazon.Runtime.HttpWebRequestMessage.GetResponseAsync(CancellationToken cancellationToken) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\_mobile\HttpRequestMessageFactory.cs:line 443
   at Amazon.Runtime.Internal.HttpHandler`1.InvokeAsync[T](IExecutionContext executionContext) in E:\JenkinsWorkspaces\v3-trebuchet-release\AWSDotNetPublic\sdk\src\Core\Amazon.Runtime\Pipeline\HttpHandler\HttpHandler.cs:line 175
   at Amazon.Runtime.Internal.Unmarshaller.InvokeAsync[T](IExecutionContext executionContext)
   at Amazon.Runtime.Internal.ErrorHandler.InvokeAsync[T](IExecutionContext executionContext)
[2018-10-02 19:11:12.549] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [ERROR] [Orleans.Streams.PubSubRendezvousGrain.S10.1.8.29:11111:276203453.*grn/716E8E94/5d6a3bb3144627d08e3425d289339d8e06000000716e8e94+ClientStreamProvider_OnDisconnected-0xFE871786] - Failed to register a stream producer.  Stream: OnDisconnected-144627d0-3bb3-5d6a-8e9d-3389d225348e-ClientStreamProvider Producer: GrainReference:*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200
[2018-10-02 19:11:12.551] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.
[2018-10-02 19:11:12.557] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Grain.InvokeException] - Deactivating [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] due to inconsistent state.
[2018-10-02 19:11:12.559] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - DeactivateActivationOnIdle: [Activation: S10.1.8.29:11111:276203453*grn/716E8E94/89339d8e+ClientStreamProvider_OnDisconnected@b45467a3 #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] already being destroyed or invalid.
[2018-10-02 19:11:12.562] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - Starting DestroyActivations #2 of 1 activations
[2018-10-02 19:11:12.566] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [INFO] [Orleans.Runtime.Catalog] - Done FinishDestroyActivations #2 - Destroyed 1 Activations.
[2018-10-02 19:11:13.813] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.0240075 - possibly GC? We are now using total of 82MB memory. gc=2 2 2
[2018-10-02 19:11:15.992] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1767644 - possibly GC? We are now using total of 108MB memory. gc=2 2 2
[2018-10-02 19:11:17.126] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003a6153-0d0a-0d02-0016-0075002e8c25"
[2018-10-02 19:11:17.561] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=117350 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/87C3DBC4/00000000+Default@2ac2a3af #GrainType=QCMachinePoolGrainLibrary.MachinePoolGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2842059 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:19.556] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1789757 - possibly GC? We are now using total of 155MB memory. gc=2 2 2
[2018-10-02 19:11:25.525] [Runtime.Watchdog0] [WARN] [Orleans.Runtime.Watchdog] - .NET Runtime Platform stalled for 00:00:02.1901570 - possibly GC? We are now using total of 134MB memory. gc=4 3 3
[2018-10-02 19:11:55.947] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - Before collection#2: memory=605MB #activations=28 collector=&lt;#Activations=26 #Buckets=2 buckets=[0h:10m:4s.75ms-&gt;1 items 2h:0m:4s.75ms-&gt;25 items]&gt;.
[2018-10-02 19:12:05.717] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [INFO] [Orleans.Runtime.TypeManager] - OnRefreshClusterMapTimer: refresh start
[2018-10-02 19:11:39.104] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003a1edd-220a-0b02-0017-03bb57e80469"
[2018-10-02 19:12:08.210] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue2] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=693978 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/8E291998/00000000+003ae096-090a-0d02-0018-0218071ef200@01c7bab5 #GrainType=QCServicesGrainLibrary.AccountDataClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2901696 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:58.971] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue1] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=623289 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003a1edd-220a-0b02-0017-03bb57e80469@c08349a8 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Activating] took elapsed time 0:01:19.8673859 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:11:53.092] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [INFO] [QCServicesGrainLibrary.GameServerClientGrain] - Activating. Id="003b863e-320a-0b02-0018-01f05c68aa3d"
[2018-10-02 19:12:58.980] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [INFO] [Orleans.Runtime.Catalog] - After collection#2: memory=479MB #activations=28 collected 0 activations collector=&lt;#Activations=26 #Buckets=3 buckets=[0h:9m:1s.20ms-&gt;1 items 1h:59m:1s.20ms-&gt;16 items 2h:0m:1s.20ms-&gt;9 items]&gt; collection time=00:01:03.0548348.
[2018-10-02 19:12:58.981] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue3] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=977052 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003b863e-320a-0b02-0018-01f05c68aa3d@c8468eb2 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Activating] took elapsed time 0:01:05.8894345 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.203] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue4] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=686414 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/9C2A0175/00000000+003ae096-090a-0d02-0018-0218071ef200@7d817981 #GrainType=QCServicesGrainLibrary.QuestClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2851082 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.211] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue5] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=719966 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/38B8C332/00000000+003ae096-090a-0d02-0018-0218071ef200@10e43fbd #GrainType=QCServicesGrainLibrary.InventoryClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2942272 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:58.988] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [WARN] [Orleans.Runtime.Scheduler *stg/14/0000000e.WorkItemGroup] - Task [Id=1049335 Status=RanToCompletion] in WorkGroup [SystemTarget: S10.1.8.29:11111:276203453*stg/14/0000000e@S0000000e] took elapsed time 0:01:03.0628451 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.204] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue6] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=1186230 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/F8588497/00000000+003ae096-090a-0d02-0018-0218071ef200@7ba03585 #GrainType=QCGameLobbyGrainLibrary.GameLobbyClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2833186 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:08.203] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.MainQueue7] [WARN] [Orleans.Runtime.Scheduler.WorkItemGroup] - Task [Id=742265 Status=RanToCompletion] in WorkGroup [Activation: S10.1.8.29:11111:276203453*grn/D1BCF3B4/00000000+003ae096-090a-0d02-0018-0218071ef200@be7db6a5 #GrainType=QCServicesGrainLibrary.GameServerClientGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2831067 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
[2018-10-02 19:12:59.004] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue0] [WARN] [Orleans.Runtime.GrainTimer] - -GrainTimer.Membership.ProbeTimer. TimerCallbackHandler:Orleans.Runtime.GrainTimer+&lt;&gt;c__DisplayClass16_0-&gt;System.Threading.Tasks.Task &lt;FromTimerCallback&gt;b__0(System.Object) did not fire on time. Last fired at 2018-10-02 19:12:03.846 GMT 00:00:55.1516845 since previous fire should have fired after 00:00:10.
[2018-10-02 19:12:59.055] [Runtime.Scheduler.OrleansSchedulerAsynchAgent/Scheduler.LevelOne.SystemQueue1] [WARN] [Orleans.Runtime.Scheduler *stg/17/00000011.WorkItemGroup] - Task [Id=1292243 Status=RanToCompletion] in WorkGroup [SystemTarget: S10.1.8.29:11111:276203453*stg/17/00000011@S00000011] took elapsed time 0:00:53.337184 for execution which is longer than 00:00:00.2000000. Running on thread System.Threading.Thread
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5058</IssueLabelID>
    <Title>Log compact/aggregation not working after 2.x migration</Title>
    <Description>Hello folks!

According to the [docs](http://dotnet.github.io/orleans/Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html): 

&gt; If multiple logs of the same log code occur within a designated time interval (the default is &gt;5 within 1 minute) then additional log messages with that log code are suppressed and output as a "bulk" entry with log code equal to the original log code + 500000. So for example multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute.


After migrating to 2.x and using the new logging infrastructure based on MEL the logs aren't being aggregated anymore.

Can someone take a look why?
</Description>
    <Title_Description>Log compact/aggregation not working after 2.x migration Hello folks!

According to the [docs](http://dotnet.github.io/orleans/Documentation/clusters_and_clients/monitoring/silo_error_code_monitoring.html): 

&gt; If multiple logs of the same log code occur within a designated time interval (the default is &gt;5 within 1 minute) then additional log messages with that log code are suppressed and output as a "bulk" entry with log code equal to the original log code + 500000. So for example multiple 100157 entries will show in the logs as 5 x 100157 + 1 x 600157 log entry per minute.


After migrating to 2.x and using the new logging infrastructure based on MEL the logs aren't being aggregated anymore.

Can someone take a look why?
</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5056</IssueLabelID>
    <Title>ServiceBus.Tests build error in vs 2017</Title>
    <Description>```
Severity	Code	Description	Project	File	Line	Suppression State
Error	NETSDK1005	Assets file 'C:\Users\a\source\repos\orleans\test\Extensions\ServiceBus.Tests\obj\project.assets.json' doesn't have a target for '.NETFrameworkVersion=v2.0'. Ensure that restore has run and that you have included 'net20' in the TargetFrameworks for your project.	ServiceBus.Tests	C:\Program Files\dotnet\sdk\2.1.402\Sdks\Microsoft.NET.Sdk\targets\Microsoft.PackageDependencyResolution.targets	198	
```

Anybody know what's wrong? </Description>
    <Title_Description>ServiceBus.Tests build error in vs 2017 ```
Severity	Code	Description	Project	File	Line	Suppression State
Error	NETSDK1005	Assets file 'C:\Users\a\source\repos\orleans\test\Extensions\ServiceBus.Tests\obj\project.assets.json' doesn't have a target for '.NETFrameworkVersion=v2.0'. Ensure that restore has run and that you have included 'net20' in the TargetFrameworks for your project.	ServiceBus.Tests	C:\Program Files\dotnet\sdk\2.1.402\Sdks\Microsoft.NET.Sdk\targets\Microsoft.PackageDependencyResolution.targets	198	
```

Anybody know what's wrong? </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5052</IssueLabelID>
    <Title>Grain reminders documentation</Title>
    <Description>The answers to these questions could be included in the grain reminders documentation:

- What is the maximum allowed value for the `dueTime` and `period` of a reminder?
- If we want a reminder to fire once only and never again what value should be used for the `period` parameter? 
- What is the effect of using `TimeSpan.Zero` or a negative `TimeSpan` value for the `period` parameter?</Description>
    <Title_Description>Grain reminders documentation The answers to these questions could be included in the grain reminders documentation:

- What is the maximum allowed value for the `dueTime` and `period` of a reminder?
- If we want a reminder to fire once only and never again what value should be used for the `period` parameter? 
- What is the effect of using `TimeSpan.Zero` or a negative `TimeSpan` value for the `period` parameter?</Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5051</IssueLabelID>
    <Title>Typo and spelling check XML doc and strings. A to E. #Hacktoberfest</Title>
    <Description>:dog2: *Much error.* :dog2: 
:dog: *Very typo.* :dog: 
:heavy_check_mark: *Many spell check.* :heavy_check_mark: 

I had to break this up into multiple PRs. This PR only contains **A to E** corrections. Mostly focused on XML doc comments. I tried to ignore `//` source comments. Also corrected some hard-coded strings in `Exception` messages that had spelling errors.

Let me know if you'd like me to continue checking.

Also happy #Hacktoberfest ! :smiley_cat: :fearful: :skull_and_crossbones: :moon: :bat: 

Thanks
Brian

:crystal_ball: :dolls: ***["Magic and technology. Voodoo dolls and chants. Electricity. Were makin weird science..."](https://www.youtube.com/watch?v=Jm-upHSP9KU)***
</Description>
    <Title_Description>Typo and spelling check XML doc and strings. A to E. #Hacktoberfest :dog2: *Much error.* :dog2: 
:dog: *Very typo.* :dog: 
:heavy_check_mark: *Many spell check.* :heavy_check_mark: 

I had to break this up into multiple PRs. This PR only contains **A to E** corrections. Mostly focused on XML doc comments. I tried to ignore `//` source comments. Also corrected some hard-coded strings in `Exception` messages that had spelling errors.

Let me know if you'd like me to continue checking.

Also happy #Hacktoberfest ! :smiley_cat: :fearful: :skull_and_crossbones: :moon: :bat: 

Thanks
Brian

:crystal_ball: :dolls: ***["Magic and technology. Voodoo dolls and chants. Electricity. Were makin weird science..."](https://www.youtube.com/watch?v=Jm-upHSP9KU)***
</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>philrowan-mtb</Assignee>
    <CreatedAt>1/10/2018 11:15:33 PM +00:00</CreatedAt>
    <ClosedAt>2/10/2018 2:10:29 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5048</IssueLabelID>
    <Title>Slow access to Azure Table "OrleansReminders" for "ReadTableEntriesAndEtags" which took 00:00:03.0158598</Title>
    <Description>Where is a problem in case of these warnings:
`
Slow access to Azure Table "OrleansReminders" for "ReadTableEntriesAndEtags" which took 00:00:03.0158598.
`

`
Slow access to Azure queue "xxx-app-appeventsstreamprovider-6" for "GetQueueMessages" which took 00:00:04.1207254. 
`
</Description>
    <Title_Description>Slow access to Azure Table "OrleansReminders" for "ReadTableEntriesAndEtags", which took 00:00:03.0158598 Where is a problem in case of these warnings:
`
Slow access to Azure Table "OrleansReminders" for "ReadTableEntriesAndEtags" which took 00:00:03.0158598.
`

`
Slow access to Azure queue "xxx-app-appeventsstreamprovider-6" for "GetQueueMessages" which took 00:00:04.1207254. 
`
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5047</IssueLabelID>
    <Title>Change TelemetryConsumers.NewRelic to target .NET Standard #5044</Title>
    <Description>Change Target Framework of Orleans.TelemetryConsumers.NewRelic to .NET Standard
Fixes #5044
</Description>
    <Title_Description>Change TelemetryConsumers.NewRelic to target .NET Standard #5044 Change Target Framework of Orleans.TelemetryConsumers.NewRelic to .NET Standard
Fixes #5044
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5045</IssueLabelID>
    <Title>Cleaned up StreamId code</Title>
    <Description>The ValueTuple type allowed a lovely cleanup of the StreamId class. 
When the Record types becomes a c# feature another cleanup can be made.</Description>
    <Title_Description>Cleaned up StreamId code The ValueTuple type allowed a lovely cleanup of the StreamId class. 
When the Record types becomes a c# feature another cleanup can be made.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5044</IssueLabelID>
    <Title>Change Target Framework of Orleans.TelemetryConsumers.NewRelic to .NET Standard</Title>
    <Description>Orleans.TelemetryConsumers.NewRelic currently targets .NET Framework 4.6.1

Can we please change that project to target .NET Standard ?

Cheers</Description>
    <Title_Description>Change Target Framework of Orleans.TelemetryConsumers.NewRelic to .NET Standard Orleans.TelemetryConsumers.NewRelic currently targets .NET Framework 4.6.1

Can we please change that project to target .NET Standard ?

Cheers</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5043</IssueLabelID>
    <Title>Using MySQL as a Membership Provider with Microsoft.Orleans.Clustering.AdoNet 2.1.0 too many Connection error occurred</Title>
    <Description>When i using MySQL as a Membership Provider with Microsoft.Orleans.Clustering.AdoNet 2.1.0 too many Connection error occurred.
In previous versions a silo had only 2-5 connections. But now one silo have more than 30 connections.
Too surprised me there is such a problem.

My .net version is: .net framework 4.6.1
Orleans version is: 2.1.0
</Description>
    <Title_Description>Using MySQL as a Membership Provider with Microsoft.Orleans.Clustering.AdoNet 2.1.0 too many Connection error occurred When i using MySQL as a Membership Provider with Microsoft.Orleans.Clustering.AdoNet 2.1.0 too many Connection error occurred.
In previous versions a silo had only 2-5 connections. But now one silo have more than 30 connections.
Too surprised me there is such a problem.

My .net version is: .net framework 4.6.1
Orleans version is: 2.1.0
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5042</IssueLabelID>
    <Title>Lifetime of services injected into grains</Title>
    <Description>It's not clear what is lifetime of a service that registered as services.AddScoped in silo and injected into grain? In case of silo and grains what is different between AddScoped and AddTransient?
For example I have a grain that can be activated by client stream or reminder. This grain can activate hundred another grains . By default lifetime of each grain is 2 hour. In this case what is request scope?
I have not found any documentation about DI on Olreans. </Description>
    <Title_Description>Lifetime of services injected into grains It's not clear what is lifetime of a service that registered as services.AddScoped in silo and injected into grain? In case of silo and grains what is different between AddScoped and AddTransient?
For example I have a grain that can be activated by client stream or reminder. This grain can activate hundred another grains . By default lifetime of each grain is 2 hour. In this case what is request scope?
I have not found any documentation about DI on Olreans. </Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5041</IssueLabelID>
    <Title>When I Use Orleans Microsoft.Orleans.CodeGenerator.MSBuild 2.1.0 Build the Interface  failed.</Title>
    <Description>` public void Populate(global::Orleans.Serialization.SerializerFeature feature)
        {
            feature.AddSerializerType(typeof(global::Services.ES.DTO.Tool.Bulk.Respond.RespondBeginBulkDTO) typeof(Services.ES.DTO.Tool.Bulk.Respond.OrleansCodeGenMJSaas_Services_ES_DTO_Tool_Bulk_Respond_RespondBeginBulkDTOSerializer) false);
            feature.AddKnownType("System.Threading.Tasks.Task`1" "Task'1");
}`

Error Message: CS1501 “AddSerializerType” method not have 3 parameters override.</Description>
    <Title_Description>When I Use Orleans Microsoft.Orleans.CodeGenerator.MSBuild 2.1.0 Build the Interface  failed. ` public void Populate(global::Orleans.Serialization.SerializerFeature feature)
        {
            feature.AddSerializerType(typeof(global::Services.ES.DTO.Tool.Bulk.Respond.RespondBeginBulkDTO) typeof(Services.ES.DTO.Tool.Bulk.Respond.OrleansCodeGenMJSaas_Services_ES_DTO_Tool_Bulk_Respond_RespondBeginBulkDTOSerializer) false);
            feature.AddKnownType("System.Threading.Tasks.Task`1" "Task'1");
}`

Error Message: CS1501 “AddSerializerType” method not have 3 parameters override.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5040</IssueLabelID>
    <Title>About when the silo stops</Title>
    <Description>I started silo s1 and s2
client c1 and c2 connect silo s1 and subscribe.
Then turn off silo s1
c1 and c2 subscribed grains to s2
c1 and c2 need to re-subscribe to the previous grain
but c1 and c2 don't know. 
How should this be solved?!
I'm sorry about the English ~</Description>
    <Title_Description>About when the silo stops I started silo s1 and s2
client c1 and c2 connect silo s1 and subscribe.
Then turn off silo s1
c1 and c2 subscribed grains to s2
c1 and c2 need to re-subscribe to the previous grain
but c1 and c2 don't know. 
How should this be solved?!
I'm sorry about the English ~</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5037</IssueLabelID>
    <Title>Port of #5033 to 1.5.x: Make MaxSockets in SocketManager configurable</Title>
    <Description>
    </Description>
    <Title_Description>Port of #5033 to 1.5.x: Make MaxSockets in SocketManager configurable </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5034</IssueLabelID>
    <Title>Implicit stream subscriptions seem to stop being called after some time</Title>
    <Description>We're seeing a grain implicitly subscribed to multiple streams suddenly stop having it's `OnNextAsync()` method called. Other explicitly subscribed grains to one of the streams continue to work as expected. Other implicitly subscribed grains continue to work as expected.

Orleans Version:
```
Microsoft Orleans Client =&gt; 2.0.3
Microsoft Orleans Core =&gt; 2.0.3
Microsoft Orleans Core_Legacy =&gt; 2.0.3
Microsoft Orleans Core_Abstractions =&gt; 2.0.0
Microsoft Orleans OrleansCodeGenerator_Build =&gt; 2.0.3
Microsoft Orleans OrleansProviders =&gt; 2.0.4
Microsoft Orleans Runtime =&gt; 2.0.4
Microsoft Orleans Server =&gt; 2.0.4
Microsoft Orleans Runtime_Legacy =&gt; 2.0.4
Microsoft Orleans TestingHost =&gt; 2.0.4
```

I have a grain class defined similar to:
```c#
[StorageProvider(ProviderName = DocumentPersistence.ServiceLifetimeRedisStorage)]
[ImplicitStreamSubscription(DocumentStreams.DocumentA)]
[ImplicitStreamSubscription(DocumentStreams.DocumentB)]
public class MyGrain : Grain&lt;MyGrainState&gt;
    IMyGrain
    IAsyncObserver&lt;IEnumerable&lt;DocumentA&gt;&gt;
    IAsyncObserver&lt;IEnumerable&lt;DocumentB&gt;&gt;
{
    public override async Task OnActivateAsync()
    {
        var id = this.GetPrimaryKey();

        var provider = GetStreamProvider(DocumentStreams.StreamProvider);

        var documentAStream = provider.GetDocumentStream&lt;DocumentA&gt;(id);
        await documentAStream.SubscribeAsync(this);

        var documentBStream = provider.GetDocumentStream&lt;DocumentB&gt;(id);
        await documentBStream.SubscribeAsync(this);
    }

    public async Task HandleDocument(DocumentA change)
    {
        // ...
    }

    public async Task HandleDocument(DocumentB change)
    {
        // ...
    }

    public async Task OnNextAsync(IEnumerable&lt;DocumentA&gt; items StreamSequenceToken token = null)
    {
        var tasks = new List&lt;Task&gt;();
        foreach (var document in items)
        {
            tasks.Add(HandleDocument(document));
        }

        await Task.WhenAll(tasks);
    }

    public async Task OnNextAsync(IEnumerable&lt;DocumentB&gt; items StreamSequenceToken token = null)
    {
        var tasks = new List&lt;Task&gt;();
        foreach (var document in items)
        {
            tasks.Add(HandleDocument(document));
        }

        await Task.WhenAll(tasks);
    }

    public Task OnCompletedAsync() =&gt; Task.CompletedTask;

    public Task OnErrorAsync(Exception ex)
    {
        GetSerilog().Error(ex "An exception occurred while receiving stream data");
        return Task.CompletedTask;
    }
}
```

_Most_ of the time all is well and `OnActivatedAsync()` followed by `OnNextAsync()` calls fire as one would expect. However left running over night we no longer receive `OnNextAsync()` calls when expected - none to be exact. Other grains that are subsequently explicitly subscribed to the streams continue to work.

I should point out that we are using a [redis stream and storage provider](https://github.com/berdon/Orleans.Providers.Redis); however all other stream subscriptions (both explicit and implicit) are working fine. It's seemingly only this grain with _two_ implicit subscriptions that is no longer receiving stream messages.

Some things I've tried to suss out what is actually going on:
- Tested other stream flows
- `GrainCollectionOptions.CollectionAge = TimeSpan.FromMinutes(1)` to force grain collection. I was able to repro the issue but only after still letting it run over night. Once in this state waiting a number of minutes I was never able to get `OnActivatedAsync()` to fire in the grain. This seems to imply the grain was either inaccessible due to some deadlock or busy waiting or that the grain itself was never activated and sent the message. Given that the grain is _relatively_ simple and devoid of any locks I am suspicious that it's the latter.</Description>
    <Title_Description>Implicit stream subscriptions seem to stop being called after some time We're seeing a grain implicitly subscribed to multiple streams suddenly stop having it's `OnNextAsync()` method called. Other explicitly subscribed grains to one of the streams continue to work as expected. Other implicitly subscribed grains continue to work as expected.

Orleans Version:
```
Microsoft Orleans Client =&gt; 2.0.3
Microsoft Orleans Core =&gt; 2.0.3
Microsoft Orleans Core_Legacy =&gt; 2.0.3
Microsoft Orleans Core_Abstractions =&gt; 2.0.0
Microsoft Orleans OrleansCodeGenerator_Build =&gt; 2.0.3
Microsoft Orleans OrleansProviders =&gt; 2.0.4
Microsoft Orleans Runtime =&gt; 2.0.4
Microsoft Orleans Server =&gt; 2.0.4
Microsoft Orleans Runtime_Legacy =&gt; 2.0.4
Microsoft Orleans TestingHost =&gt; 2.0.4
```

I have a grain class defined similar to:
```c#
[StorageProvider(ProviderName = DocumentPersistence.ServiceLifetimeRedisStorage)]
[ImplicitStreamSubscription(DocumentStreams.DocumentA)]
[ImplicitStreamSubscription(DocumentStreams.DocumentB)]
public class MyGrain : Grain&lt;MyGrainState&gt;
    IMyGrain
    IAsyncObserver&lt;IEnumerable&lt;DocumentA&gt;&gt;
    IAsyncObserver&lt;IEnumerable&lt;DocumentB&gt;&gt;
{
    public override async Task OnActivateAsync()
    {
        var id = this.GetPrimaryKey();

        var provider = GetStreamProvider(DocumentStreams.StreamProvider);

        var documentAStream = provider.GetDocumentStream&lt;DocumentA&gt;(id);
        await documentAStream.SubscribeAsync(this);

        var documentBStream = provider.GetDocumentStream&lt;DocumentB&gt;(id);
        await documentBStream.SubscribeAsync(this);
    }

    public async Task HandleDocument(DocumentA change)
    {
        // ...
    }

    public async Task HandleDocument(DocumentB change)
    {
        // ...
    }

    public async Task OnNextAsync(IEnumerable&lt;DocumentA&gt; items StreamSequenceToken token = null)
    {
        var tasks = new List&lt;Task&gt;();
        foreach (var document in items)
        {
            tasks.Add(HandleDocument(document));
        }

        await Task.WhenAll(tasks);
    }

    public async Task OnNextAsync(IEnumerable&lt;DocumentB&gt; items StreamSequenceToken token = null)
    {
        var tasks = new List&lt;Task&gt;();
        foreach (var document in items)
        {
            tasks.Add(HandleDocument(document));
        }

        await Task.WhenAll(tasks);
    }

    public Task OnCompletedAsync() =&gt; Task.CompletedTask;

    public Task OnErrorAsync(Exception ex)
    {
        GetSerilog().Error(ex "An exception occurred while receiving stream data");
        return Task.CompletedTask;
    }
}
```

_Most_ of the time all is well and `OnActivatedAsync()` followed by `OnNextAsync()` calls fire as one would expect. However left running over night we no longer receive `OnNextAsync()` calls when expected - none to be exact. Other grains that are subsequently explicitly subscribed to the streams continue to work.

I should point out that we are using a [redis stream and storage provider](https://github.com/berdon/Orleans.Providers.Redis); however all other stream subscriptions (both explicit and implicit) are working fine. It's seemingly only this grain with _two_ implicit subscriptions that is no longer receiving stream messages.

Some things I've tried to suss out what is actually going on:
- Tested other stream flows
- `GrainCollectionOptions.CollectionAge = TimeSpan.FromMinutes(1)` to force grain collection. I was able to repro the issue but only after still letting it run over night. Once in this state waiting a number of minutes I was never able to get `OnActivatedAsync()` to fire in the grain. This seems to imply the grain was either inaccessible due to some deadlock or busy waiting or that the grain itself was never activated and sent the message. Given that the grain is _relatively_ simple and devoid of any locks I am suspicious that it's the latter.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5033</IssueLabelID>
    <Title>Make MaxSockets in SocketManager configurable</Title>
    <Description>Make MaxSockets in SocketManager configurable.
Raise the default from 200 to 500.

With clusters larger than 200 silos the hardcoded limit on the number of sockets causes massive churn of sockets that get constantly closed and reopened.</Description>
    <Title_Description>Make MaxSockets in SocketManager configurable Make MaxSockets in SocketManager configurable.
Raise the default from 200 to 500.

With clusters larger than 200 silos the hardcoded limit on the number of sockets causes massive churn of sockets that get constantly closed and reopened.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5030</IssueLabelID>
    <Title>Cleanup types in transaction state storage interface</Title>
    <Description>Participated of transaction manager and metadata are now passed to storage by structure not string values.</Description>
    <Title_Description>Cleanup types in transaction state storage interface Participated of transaction manager and metadata are now passed to storage by structure not string values.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5029</IssueLabelID>
    <Title>Serialization bug in new codegenerator for types deriving from Dictionary&lt;TKey TValue&gt;</Title>
    <Description>If a grain interface method takes as parameter a custom dictionary which inherits from `Dictionary&lt;TKey TValue&gt;` then the dictionary is not populated on the receiving side. The error only exist when the new code generator is used it works correctly with the old one.

There is a reproducing project here: https://github.com/rmja/OrleansIssueDictionary
The project currently references the new generator. Changing back to the old one makes the test pass.</Description>
    <Title_Description>Serialization bug in new codegenerator for types deriving from Dictionary&lt;TKey, TValue&gt; If a grain interface method takes as parameter a custom dictionary which inherits from `Dictionary&lt;TKey TValue&gt;` then the dictionary is not populated on the receiving side. The error only exist when the new code generator is used it works correctly with the old one.

There is a reproducing project here: https://github.com/rmja/OrleansIssueDictionary
The project currently references the new generator. Changing back to the old one makes the test pass.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5027</IssueLabelID>
    <Title>What would be the recommended approach to persist grain state in relational database in order to query across multiple actors?</Title>
    <Description>I had been following the indexing of actor state and read the paper published on it but there doesn't seem to be much movement on it.

**What would be the recommended approach to persist grain state in relational database in order to query across multiple actors?**

_For the moment I have implemented it as such:_
- _all the grains which I need to query from emit a stream event after writing their state in grain storage_
- _an implicit stream reads all events and persist them in relation DB_
 </Description>
    <Title_Description>What would be the recommended approach to persist grain state in relational database in order to query across multiple actors? I had been following the indexing of actor state and read the paper published on it but there doesn't seem to be much movement on it.

**What would be the recommended approach to persist grain state in relational database in order to query across multiple actors?**

_For the moment I have implemented it as such:_
- _all the grains which I need to query from emit a stream event after writing their state in grain storage_
- _an implicit stream reads all events and persist them in relation DB_
 </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>26/09/2018 7:25:43 AM +00:00</CreatedAt>
    <ClosedAt>5/10/2018 8:02:11 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5025</IssueLabelID>
    <Title>Getting a SiloUnavailableException</Title>
    <Description>Getting a  `SiloUnavailableException` after launching an orleans app which consist of both silo client and silo host. 

I had read [troubleshooting doc](https://dotnet.github.io/orleans/Documentation/deployment/troubleshooting_deployments.html#getting-a-silounavailableexception
) and I think my bootstrap process is good (or correct me if I'm wrong)

My program bootstrap like this :

```csharp
static void Main() {
    startSiloHost();
    startSiloClient();
    startGate();  
}

startSiloHost() {
    ISiloHostBuilder builder = new SiloHostBuilder(); 
    // a lot config stuff.
   var host = builder.Build()
   host.StartAsync().Wait();
}

startSiloClient() {
    ISiloHostBuilder builder = new SiloClientBuilder(); 
    // a lot config stuff.
   var client = builder.Build()
   client.StartAsync().Wait();
}

startGate() {
    // listen and serve real clients
}
```


```
2018-09-25 15:03:04.8621|INFO|Sims.Program|server start! "unknow"
2018-09-25 15:03:05.5019|WARN|Orleans.Runtime.Silo|Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-09-25 15:03:05.5019|WARN|Orleans.Runtime.Silo|Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-09-25 15:03:05.5608|WARN|Orleans.Runtime.NoOpHostEnvironmentStatistics|No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-09-25 15:03:12.3743|INFO|Sims.Program|server start done!
2018-09-25 15:03:49.9147|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #0 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #34: .
2018-09-25 15:03:59.9196|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #1 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #35: .
2018-09-25 15:04:09.9346|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #2 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #36: .
2018-09-25 15:04:09.9863|WARN|Orleans.Runtime.CallbackData|The target silo became unavailable for message: Request S127.0.0.1:30000:275554985*stg/22/00000016@S00000016-&gt;S127.0.0.1:11111:275554985*stg/22/00000016@S00000016 #32: . Target History is: &lt;S127.0.0.1:11111:275554985:*stg/22/00000016:@S00000016&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
2018-09-25 15:04:10.0175|WARN|Orleans.Runtime.DeploymentLoadPublisher|An exception was thrown by PublishStatistics.UpdateRuntimeStatistics(). Ignoring. Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request S127.0.0.1:30000:275554985*stg/22/00000016@S00000016-&gt;S127.0.0.1:11111:275554985*stg/22/00000016@S00000016 #32: . Target History is: &lt;S127.0.0.1:11111:275554985:*stg/22/00000016:@S00000016&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.Runtime.DeploymentLoadPublisher.PublishStatistics(Object _) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Placement\DeploymentLoadPublisher.cs:line 116
2018-09-25 15:04:12.2202|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:04:12.3790|WARN|Orleans.OutsideRuntimeClient|Refresh the GrainTypeResolver failed. WIll be retried after Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress() in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 436
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 318
   at Orleans.OutsideRuntimeClient.RefreshGrainTypeResolver(Object _) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 293
2018-09-25 15:04:12.3790|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:05:12.2345|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:05:12.3886|WARN|Orleans.OutsideRuntimeClient|Refresh the GrainTypeResolver failed. WIll be retried after Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress() in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 436
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 318
   at Orleans.OutsideRuntimeClient.RefreshGrainTypeResolver(Object _) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 293
2018-09-25 15:05:12.3886|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
```</Description>
    <Title_Description>Getting a SiloUnavailableException Getting a  `SiloUnavailableException` after launching an orleans app which consist of both silo client and silo host. 

I had read [troubleshooting doc](https://dotnet.github.io/orleans/Documentation/deployment/troubleshooting_deployments.html#getting-a-silounavailableexception
) and I think my bootstrap process is good (or correct me if I'm wrong)

My program bootstrap like this :

```csharp
static void Main() {
    startSiloHost();
    startSiloClient();
    startGate();  
}

startSiloHost() {
    ISiloHostBuilder builder = new SiloHostBuilder(); 
    // a lot config stuff.
   var host = builder.Build()
   host.StartAsync().Wait();
}

startSiloClient() {
    ISiloHostBuilder builder = new SiloClientBuilder(); 
    // a lot config stuff.
   var client = builder.Build()
   client.StartAsync().Wait();
}

startGate() {
    // listen and serve real clients
}
```


```
2018-09-25 15:03:04.8621|INFO|Sims.Program|server start! "unknow"
2018-09-25 15:03:05.5019|WARN|Orleans.Runtime.Silo|Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-09-25 15:03:05.5019|WARN|Orleans.Runtime.Silo|Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-09-25 15:03:05.5608|WARN|Orleans.Runtime.NoOpHostEnvironmentStatistics|No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-09-25 15:03:12.3743|INFO|Sims.Program|server start done!
2018-09-25 15:03:49.9147|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #0 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #34: .
2018-09-25 15:03:59.9196|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #1 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #35: .
2018-09-25 15:04:09.9346|WARN|Orleans.Runtime.MembershipService.MembershipOracleData|-Did not get ping response for ping #2 from S127.0.0.1:11111:275554985. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:The target silo is no longer active: target was S127.0.0.1:11111:275554985 but this silo is S127.0.0.1:30000:275554985. The rejected ping message is Request S127.0.0.1:30000:275554985*stg/15/0000000f@S0000000f-&gt;S127.0.0.1:11111:275554985*stg/15/0000000f@S0000000f #36: .
2018-09-25 15:04:09.9863|WARN|Orleans.Runtime.CallbackData|The target silo became unavailable for message: Request S127.0.0.1:30000:275554985*stg/22/00000016@S00000016-&gt;S127.0.0.1:11111:275554985*stg/22/00000016@S00000016 #32: . Target History is: &lt;S127.0.0.1:11111:275554985:*stg/22/00000016:@S00000016&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
2018-09-25 15:04:10.0175|WARN|Orleans.Runtime.DeploymentLoadPublisher|An exception was thrown by PublishStatistics.UpdateRuntimeStatistics(). Ignoring. Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request S127.0.0.1:30000:275554985*stg/22/00000016@S00000016-&gt;S127.0.0.1:11111:275554985*stg/22/00000016@S00000016 #32: . Target History is: &lt;S127.0.0.1:11111:275554985:*stg/22/00000016:@S00000016&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.Runtime.DeploymentLoadPublisher.PublishStatistics(Object _) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Placement\DeploymentLoadPublisher.cs:line 116
2018-09-25 15:04:12.2202|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:04:12.3790|WARN|Orleans.OutsideRuntimeClient|Refresh the GrainTypeResolver failed. WIll be retried after Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress() in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 436
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 318
   at Orleans.OutsideRuntimeClient.RefreshGrainTypeResolver(Object _) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 293
2018-09-25 15:04:12.3790|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:05:12.2345|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
2018-09-25 15:05:12.3886|WARN|Orleans.OutsideRuntimeClient|Refresh the GrainTypeResolver failed. WIll be retried after Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress() in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 436
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs:line 318
   at Orleans.OutsideRuntimeClient.RefreshGrainTypeResolver(Object _) in D:\build\agent\_work\23\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs:line 293
2018-09-25 15:05:12.3886|WARN|Orleans.Messaging.GatewayManager|All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5023</IssueLabelID>
    <Title>Ensure AsyncAgent restarts on fault</Title>
    <Description>AsyncAgents were not restarting on fault when configured to do so.
- Added test to repro
- Fixed in AsyncAgent
</Description>
    <Title_Description>Ensure AsyncAgent restarts on fault AsyncAgents were not restarting on fault when configured to do so.
- Added test to repro
- Fixed in AsyncAgent
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5022</IssueLabelID>
    <Title>Add LargeMessageWarningThreshold back to Silo(Client)MessagingOptions</Title>
    <Description>Add LargeMessageWarningThreshold back to Silo(Client)MessagingOptions and also legacy configuration objects</Description>
    <Title_Description>Add LargeMessageWarningThreshold back to Silo(Client)MessagingOptions Add LargeMessageWarningThreshold back to Silo(Client)MessagingOptions and also legacy configuration objects</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5021</IssueLabelID>
    <Title>The new code generator adds everything to feature.AddKnownType</Title>
    <Description>This was a problem with the old code generator already as documented in #4437 but with the new code generator it's a lot worse.

For example I have a functional tests project that has a single grain interface with a few simple calls it references various other projects. Both code generators write about 200 lines of code for the grain method invoker but then they generate endless `feature.AddKnownType` lines - the old one about 700 lines the new one about **26000** lines! The generated assembly grows from 300KB to 6MB and is really slow to start up.

What's the purpose of `feature.AddKnownType`? It looks like it adds every type that is visible to Roslyn during codegen or something similar. And the added information doesn't look useful at all - it's just a list of type names.</Description>
    <Title_Description>The new code generator adds everything to feature.AddKnownType This was a problem with the old code generator already as documented in #4437 but with the new code generator it's a lot worse.

For example I have a functional tests project that has a single grain interface with a few simple calls it references various other projects. Both code generators write about 200 lines of code for the grain method invoker but then they generate endless `feature.AddKnownType` lines - the old one about 700 lines the new one about **26000** lines! The generated assembly grows from 300KB to 6MB and is really slow to start up.

What's the purpose of `feature.AddKnownType`? It looks like it adds every type that is visible to Roslyn during codegen or something similar. And the added information doesn't look useful at all - it's just a list of type names.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5020</IssueLabelID>
    <Title>Added Validations for Blob Names and refactored the ContianerName &amp; TableName validations</Title>
    <Description>PR for: Azure Blob storage provider does not sanitize blob names (https://github.com/dotnet/orleans/issues/1496) </Description>
    <Title_Description>Added Validations for Blob Names and refactored the ContianerName &amp; TableName validations PR for: Azure Blob storage provider does not sanitize blob names (https://github.com/dotnet/orleans/issues/1496) </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5018</IssueLabelID>
    <Title>Exception serialization with .NET Core 2.0?</Title>
    <Description>Hi

I use Orleans since one of one of the earliest alphas for 2.0 with .NET Core and I think that I never had a problem with exceptions although I am not sure.

Recently we discovered a bug where validation details where not displayed correctly in the UI. It does not happen very often because there is also a lot of client side validation. Validation errors are transported with a custom validation exception something like:

```
[Serializable]
class ValidationException : Exception
{
   LIst&lt;ValidationError&gt; Details;
}
```

Details was always Empty and the reason was that our serialization logic was not correct. So we fixed it: https://github.com/Squidex/squidex/blob/master/src/Squidex.Infrastructure/ValidationException.cs#L53

The docu says:

&gt; Fallback Serialization:  .NET Core uses the ILBasedSerializer by default whereas .NET 4.6 uses BinaryFormatterSerializer by default.

But obviously it cannot be correct for exceptions and I am not sure if this behavior has been changed recently.

Futhermore the documentation says nothing about exceptions and serialization.

Some clarification would be great.</Description>
    <Title_Description>Exception serialization with .NET Core 2.0? Hi

I use Orleans since one of one of the earliest alphas for 2.0 with .NET Core and I think that I never had a problem with exceptions although I am not sure.

Recently we discovered a bug where validation details where not displayed correctly in the UI. It does not happen very often because there is also a lot of client side validation. Validation errors are transported with a custom validation exception something like:

```
[Serializable]
class ValidationException : Exception
{
   LIst&lt;ValidationError&gt; Details;
}
```

Details was always Empty and the reason was that our serialization logic was not correct. So we fixed it: https://github.com/Squidex/squidex/blob/master/src/Squidex.Infrastructure/ValidationException.cs#L53

The docu says:

&gt; Fallback Serialization:  .NET Core uses the ILBasedSerializer by default whereas .NET 4.6 uses BinaryFormatterSerializer by default.

But obviously it cannot be correct for exceptions and I am not sure if this behavior has been changed recently.

Futhermore the documentation says nothing about exceptions and serialization.

Some clarification would be great.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5017</IssueLabelID>
    <Title>New code generator fails (2.1-RC2)</Title>
    <Description>Using the new generator one of my project fails with the following error:

&gt;  Using "Exec" task from assembly "Microsoft.Build.Tasks.Core Version=15.1.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a".
&gt;        Task "Exec"
&gt;          "/usr/share/dotnet/dotnet" "/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/../tasks/netcoreapp2.0/Orleans.CodeGenerator.MSBuild.dll" SourceToSource "/home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt"
&gt;          Orleans.CodeGenerator - command-line = SourceToSource /home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt
&gt;          -- Code Generation FAILED -- 
&gt;          
&gt;          Exc level 0: System.InvalidOperationException: Unable to find type with metadata name "System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute".
&gt;             at Orleans.CodeGenerator.WellKnownTypes.&lt;FromCompilation&gt;g__Type|0_0(String type &lt;&gt;c__DisplayClass0_0&amp; )
&gt;             at Orleans.CodeGenerator.WellKnownTypes.FromCompilation(Compilation compilation)
&gt;             at Orleans.CodeGenerator.CodeGenerator..ctor(Compilation compilation ILogger log)
&gt;             at Orleans.CodeGenerator.MSBuild.CodeGeneratorCommand.&lt;Execute&gt;d__39.MoveNext()
&gt;          --- End of stack trace from previous location where exception was thrown ---
&gt;             at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;             at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;             at Microsoft.Orleans.CodeGenerator.MSBuild.Program.SourceToSource(String[] args)
&gt;             at Microsoft.Orleans.CodeGenerator.MSBuild.Program.Main(String[] args)
&gt;    1:7&gt;/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/Microsoft.Orleans.CodeGenerator.MSBuild.targets(1225): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/../tasks/netcoreapp2.0/Orleans.CodeGenerator.MSBuild.dll" SourceToSource "/home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt"" exited with code 3. [/home/sro/projects/xxx/src/Core.Grains/Core.Grains.csproj]
&gt;        Done executing task "Exec" -- FAILED.

In total I have 4 projects using the generator and only 1 fails.
I use dotnet 2.1.402

I don't know how to provide you more information about the problem.</Description>
    <Title_Description>New code generator fails (2.1-RC2) Using the new generator one of my project fails with the following error:

&gt;  Using "Exec" task from assembly "Microsoft.Build.Tasks.Core Version=15.1.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a".
&gt;        Task "Exec"
&gt;          "/usr/share/dotnet/dotnet" "/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/../tasks/netcoreapp2.0/Orleans.CodeGenerator.MSBuild.dll" SourceToSource "/home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt"
&gt;          Orleans.CodeGenerator - command-line = SourceToSource /home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt
&gt;          -- Code Generation FAILED -- 
&gt;          
&gt;          Exc level 0: System.InvalidOperationException: Unable to find type with metadata name "System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute".
&gt;             at Orleans.CodeGenerator.WellKnownTypes.&lt;FromCompilation&gt;g__Type|0_0(String type &lt;&gt;c__DisplayClass0_0&amp; )
&gt;             at Orleans.CodeGenerator.WellKnownTypes.FromCompilation(Compilation compilation)
&gt;             at Orleans.CodeGenerator.CodeGenerator..ctor(Compilation compilation ILogger log)
&gt;             at Orleans.CodeGenerator.MSBuild.CodeGeneratorCommand.&lt;Execute&gt;d__39.MoveNext()
&gt;          --- End of stack trace from previous location where exception was thrown ---
&gt;             at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;             at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;             at Microsoft.Orleans.CodeGenerator.MSBuild.Program.SourceToSource(String[] args)
&gt;             at Microsoft.Orleans.CodeGenerator.MSBuild.Program.Main(String[] args)
&gt;    1:7&gt;/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/Microsoft.Orleans.CodeGenerator.MSBuild.targets(1225): error MSB3073: The command ""/usr/share/dotnet/dotnet" "/home/sro/.nuget/packages/microsoft.orleans.codegenerator.msbuild/2.1.0-rc2/build/../tasks/netcoreapp2.0/Orleans.CodeGenerator.MSBuild.dll" SourceToSource "/home/sro/projects/xxx/src/Core.Grains/obj/Debug/netstandard2.0/Core.Grains.orleans.g.args.txt"" exited with code 3. [/home/sro/projects/xxx/src/Core.Grains/Core.Grains.csproj]
&gt;        Done executing task "Exec" -- FAILED.

In total I have 4 projects using the generator and only 1 fails.
I use dotnet 2.1.402

I don't know how to provide you more information about the problem.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5016</IssueLabelID>
    <Title>Update changelog for 2.1.0-rc2</Title>
    <Description>
    </Description>
    <Title_Description>Update changelog for 2.1.0-rc2 </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5015</IssueLabelID>
    <Title>Prevent packaging of Orleans.CodeGenerator.MSBuild.Tasks.csproj</Title>
    <Description>This project generates an unneeded NuGet package that we don't need to and cannot publish to nuget.org.</Description>
    <Title_Description>Prevent packaging of Orleans.CodeGenerator.MSBuild.Tasks.csproj This project generates an unneeded NuGet package that we don't need to and cannot publish to nuget.org.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5014</IssueLabelID>
    <Title>Need to update whats_new_in_orleans.md with releases since 2.0.0</Title>
    <Description>Need to append information about releases since 2.0.0.</Description>
    <Title_Description>Need to update whats_new_in_orleans.md with releases since 2.0.0 Need to append information about releases since 2.0.0.</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5013</IssueLabelID>
    <Title>How to write a client in .NET Standard 2.0 that can connect to old v1.5 server?</Title>
    <Description>I have an old Orleans v1.5 cluster which cannot be updated to v2 ATM.

I'm writing an Azure Function v2 which is a .NET Standard 2.0 application.

This applications needs an Orleans Client to connect to the old cluster. Unfortunately the latest available client library (NuGet: Microsoft.Orleans.Client 1.5.5) does not work with .NET Standard 2.0 (there is an issue with dependency injection described in #3325).

I tried using the latest v2 client (NuGet: Microsoft.Orleans.Client 2.0.3) but it is obviously not compatible with old cluster since it fails with an exception during connection:

``
NotImplementedException
Orleans: interfaceId=-1666714017methodId=1041119701.
``

Is there some workaround (legacy mode?) to make new client work with old server? There was a fix that would make the old client work with .NET Standard 2.0 (issue #3356) but it was never implemented into 1.5 branch.
</Description>
    <Title_Description>How to write a client in .NET Standard 2.0 that can connect to old v1.5 server? I have an old Orleans v1.5 cluster which cannot be updated to v2 ATM.

I'm writing an Azure Function v2 which is a .NET Standard 2.0 application.

This applications needs an Orleans Client to connect to the old cluster. Unfortunately the latest available client library (NuGet: Microsoft.Orleans.Client 1.5.5) does not work with .NET Standard 2.0 (there is an issue with dependency injection described in #3325).

I tried using the latest v2 client (NuGet: Microsoft.Orleans.Client 2.0.3) but it is obviously not compatible with old cluster since it fails with an exception during connection:

``
NotImplementedException
Orleans: interfaceId=-1666714017methodId=1041119701.
``

Is there some workaround (legacy mode?) to make new client work with old server? There was a fix that would make the old client work with .NET Standard 2.0 (issue #3356) but it was never implemented into 1.5 branch.
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5009</IssueLabelID>
    <Title>Can a Grain subscribe to multiple streams at the same time?</Title>
    <Description>Hi I've been trying to use Explicit Streams and have 2 separate clients calling the grain's method to subscribe to different streams. However when the 2nd client is trying to have the grain subscribe to a second stream (after it subscribed to a different stream) nothing happens. No errors no exceptions or anything. Can grains subscribe to multiple different streams at the same time (assuming all the OnNextAsync() are stubbed out)?.</Description>
    <Title_Description>Can a Grain subscribe to multiple streams at the same time? Hi I've been trying to use Explicit Streams and have 2 separate clients calling the grain's method to subscribe to different streams. However when the 2nd client is trying to have the grain subscribe to a second stream (after it subscribed to a different stream) nothing happens. No errors no exceptions or anything. Can grains subscribe to multiple different streams at the same time (assuming all the OnNextAsync() are stubbed out)?.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5007</IssueLabelID>
    <Title>New CodeGenerator fails with packages such as Orleans.Dashboard which are built with old code generator</Title>
    <Description>I tested 2.1.0-ci.20180919.3 from myget.

The build works but when I run the application I get the following exception:

`Method not found: 'Void Orleans.Serialization.SerializerFeature.AddSerializerType(System.Type System.Type)`

The stacktrace is from Orleans Dashboard which was build with the old code generator.

But because you added  a  new parameter it fails: https://github.com/dotnet/orleans/blob/ffabe550a7891e7378f9f076e88a8e3c184d967f/src/Orleans.Core.Abstractions/Serialization/SerializerFeature.cs#L36

A good old method overload should fix the problem.</Description>
    <Title_Description>New CodeGenerator fails with packages such as Orleans.Dashboard which are built with old code generator I tested 2.1.0-ci.20180919.3 from myget.

The build works but when I run the application I get the following exception:

`Method not found: 'Void Orleans.Serialization.SerializerFeature.AddSerializerType(System.Type System.Type)`

The stacktrace is from Orleans Dashboard which was build with the old code generator.

But because you added  a  new parameter it fails: https://github.com/dotnet/orleans/blob/ffabe550a7891e7378f9f076e88a8e3c184d967f/src/Orleans.Core.Abstractions/Serialization/SerializerFeature.cs#L36

A good old method overload should fix the problem.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5003</IssueLabelID>
    <Title>CloudTable reference in Azure Table Storage is a singleton but it is not threadsafe</Title>
    <Description>The `AzureTableDataManager` used by `AzureTableGrainStorage` which is registered as a singleton has a single instance of `CloudTable` but this type [is not thread safe](https://stackoverflow.com/questions/13246720/is-azure-cloudtable-thread-safe). This results in exceptions thrown by the AzureStorage under load from `AzureTableDataManager.ReadSingleTableEntryAsync`:

```
Microsoft.WindowsAzure.Storage.StorageException: An item with the same key has already been added. Key: timeout ---&gt; System.ArgumentException: An item with the same key has already been added. Key: timeout
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key TValue value InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key TValue value)
   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpRequestMessageFactory.CreateRequestMessage(HttpMethod method Uri uri Nullable`1 timeout UriQueryBuilder builder HttpContent content OperationContext operationContext ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpRequestMessageFactory.BuildRequestCore(Uri uri UriQueryBuilder builder HttpMethod method Nullable`1 timeout HttpContent content OperationContext ctx ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpRequestMessageFactory.BuildRequestForTableQuery(Uri uri UriQueryBuilder builder Nullable`1 timeout HttpContent content OperationContext ctx TablePayloadFormat payloadFormat ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.TableQuery`1.&lt;&gt;c__DisplayClass24_0`2.&lt;QueryImpl&gt;b__0(RESTCommand`1 cmd Uri uri UriQueryBuilder queryBuilder HttpContent cnt Nullable`1 serverTimeout OperationContext ctx)
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   --- End of inner exception stack trace ---
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Microsoft.WindowsAzure.Storage.Table.TableQuery`1.&lt;&gt;c__DisplayClass20_0.&lt;&lt;ExecuteQuerySegmentedAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.ReadSingleTableEntryAsync(String partitionKey String rowKey)
   at SampleStore.Silo.CustomAzureTableGrainStorage.GrainStateTableDataManager.Read(String partitionKey String rowKey) in C:\Source\Utiliread\src\SampleStore.Silo\CustomAzureTableGrainStorage.cs:line 408
   at SampleStore.Silo.CustomAzureTableGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Source\Utiliread\src\SampleStore.Silo\CustomAzureTableGrainStorage.cs:line 74
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()

```

The `Table` property on `AzureTableDataManager` is unfortunately public so I don't see an easy fix (that I can do). If it was private to the manager one could simply have a `ConcurrentBag&lt;CloudTable&gt;` where one can borrow initialized clients from.</Description>
    <Title_Description>CloudTable reference in Azure Table Storage is a singleton but it is not threadsafe The `AzureTableDataManager` used by `AzureTableGrainStorage` which is registered as a singleton has a single instance of `CloudTable` but this type [is not thread safe](https://stackoverflow.com/questions/13246720/is-azure-cloudtable-thread-safe). This results in exceptions thrown by the AzureStorage under load from `AzureTableDataManager.ReadSingleTableEntryAsync`:

```
Microsoft.WindowsAzure.Storage.StorageException: An item with the same key has already been added. Key: timeout ---&gt; System.ArgumentException: An item with the same key has already been added. Key: timeout
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key TValue value InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key TValue value)
   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpRequestMessageFactory.CreateRequestMessage(HttpMethod method Uri uri Nullable`1 timeout UriQueryBuilder builder HttpContent content OperationContext operationContext ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpRequestMessageFactory.BuildRequestCore(Uri uri UriQueryBuilder builder HttpMethod method Nullable`1 timeout HttpContent content OperationContext ctx ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.Protocol.TableOperationHttpRequestMessageFactory.BuildRequestForTableQuery(Uri uri UriQueryBuilder builder Nullable`1 timeout HttpContent content OperationContext ctx TablePayloadFormat payloadFormat ICanonicalizer canonicalizer StorageCredentials credentials)
   at Microsoft.WindowsAzure.Storage.Table.TableQuery`1.&lt;&gt;c__DisplayClass24_0`2.&lt;QueryImpl&gt;b__0(RESTCommand`1 cmd Uri uri UriQueryBuilder queryBuilder HttpContent cnt Nullable`1 serverTimeout OperationContext ctx)
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   --- End of inner exception stack trace ---
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.ExecuteAsyncInternal[T](RESTCommand`1 cmd IRetryPolicy policy OperationContext operationContext CancellationToken token)
   at Microsoft.WindowsAzure.Storage.Table.TableQuery`1.&lt;&gt;c__DisplayClass20_0.&lt;&lt;ExecuteQuerySegmentedAsync&gt;b__0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.ReadSingleTableEntryAsync(String partitionKey String rowKey)
   at SampleStore.Silo.CustomAzureTableGrainStorage.GrainStateTableDataManager.Read(String partitionKey String rowKey) in C:\Source\Utiliread\src\SampleStore.Silo\CustomAzureTableGrainStorage.cs:line 408
   at SampleStore.Silo.CustomAzureTableGrainStorage.ReadStateAsync(String grainType GrainReference grainReference IGrainState grainState) in C:\Source\Utiliread\src\SampleStore.Silo\CustomAzureTableGrainStorage.cs:line 74
   at Orleans.Core.StateStorageBridge`1.ReadStateAsync()

```

The `Table` property on `AzureTableDataManager` is unfortunately public so I don't see an easy fix (that I can do). If it was private to the manager one could simply have a `ConcurrentBag&lt;CloudTable&gt;` where one can borrow initialized clients from.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5002</IssueLabelID>
    <Title>Orleans CodeGenerator not found</Title>
    <Description>When we build our project in Visual Studio 2017 we get following error:
src\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.1.5.3\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(465): error :  could not be found!

This results in Orleans code files not being generated.
Has anyone faced this issue?
Installing latest updates to Visual Studio did not help.</Description>
    <Title_Description>Orleans CodeGenerator not found When we build our project in Visual Studio 2017 we get following error:
src\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.1.5.3\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(465): error :  could not be found!

This results in Orleans code files not being generated.
Has anyone faced this issue?
Installing latest updates to Visual Studio did not help.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5001</IssueLabelID>
    <Title>Add option to Orleans generated code  will be hidden from the debugging process</Title>
    <Description>This is quite helpful when you don’t  want to go to stepping inside of a generated method while debugging.</Description>
    <Title_Description>Add option to Orleans generated code  will be hidden from the debugging process This is quite helpful when you don’t  want to go to stepping inside of a generated method while debugging.</Title_Description>
    <Label>codegen</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>5000</IssueLabelID>
    <Title>[Question] Any plans for migration to netstandard2.1?</Title>
    <Description>And start using improved .net core runtime and new built-in features like `Span&lt;T&gt;` and others?</Description>
    <Title_Description>[Question] Any plans for migration to netstandard2.1? And start using improved .net core runtime and new built-in features like `Span&lt;T&gt;` and others?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4999</IssueLabelID>
    <Title>When ClientBuilder.Build() throw  System.ExecutionEngineException</Title>
    <Description>`private static void ValidateSystemConfiguration(IServiceProvider serviceProvider)
        {
            var validators = serviceProvider.GetServices&lt;IConfigurationValidator&gt;();
            foreach (var validator in validators)
            {
                validator.ValidateConfiguration();
            }
        }`
when exec at the function ValidateSystemConfigurationthrow System.ExecutionEngineException;</Description>
    <Title_Description>When ClientBuilder.Build() throw  System.ExecutionEngineException `private static void ValidateSystemConfiguration(IServiceProvider serviceProvider)
        {
            var validators = serviceProvider.GetServices&lt;IConfigurationValidator&gt;();
            foreach (var validator in validators)
            {
                validator.ValidateConfiguration();
            }
        }`
when exec at the function ValidateSystemConfigurationthrow System.ExecutionEngineException;</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4998</IssueLabelID>
    <Title>How to debug the source code using Visual Studio 2017?</Title>
    <Description>Is it possible to debug the Orleans source code in my projects?</Description>
    <Title_Description>How to debug the source code using Visual Studio 2017? Is it possible to debug the Orleans source code in my projects?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4997</IssueLabelID>
    <Title>ServiceId_SiloRestart test fails intermittently</Title>
    <Description>UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.ServiceId_SiloRestart fails intermittently


MESSAGE:
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 19999\r\n---- System.TimeoutException : MembershipOracle activating failed due to timeout 00:05:00
+++++++++++++++++++
STACK TRACE:
at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__65.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 274 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 36 at Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 521 at Orleans.TestingHost.TestCluster.RestartSilo(SiloHandle instance) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 419 at UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.&lt;ServiceId_SiloRestart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\StreamProvidersTests.cs:line 92 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) ----- Inner Stack Trace ----- at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 0 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;&lt;OnBecomeActiveStart&gt;g__BecomeActive|73_1&gt;d.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 527 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__70.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 395 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;OnBecomeActiveStart&gt;d__73.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 529 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 82 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55</Description>
    <Title_Description>ServiceId_SiloRestart test fails intermittently UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.ServiceId_SiloRestart fails intermittently


MESSAGE:
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 19999\r\n---- System.TimeoutException : MembershipOracle activating failed due to timeout 00:05:00
+++++++++++++++++++
STACK TRACE:
at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs:line 63 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__65.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 274 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\InProcessSiloHandle.cs:line 36 at Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 521 at Orleans.TestingHost.TestCluster.RestartSilo(SiloHandle instance) in D:\j\workspace\functional_pr---83d31c72\src\Orleans.TestingHost\TestCluster.cs:line 419 at UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.&lt;ServiceId_SiloRestart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\TesterInternal\StreamProvidersTests.cs:line 92 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) ----- Inner Stack Trace ----- at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Async\TaskExtensions.cs:line 0 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;&lt;OnBecomeActiveStart&gt;g__BecomeActive|73_1&gt;d.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 527 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__70.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 395 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.Silo.&lt;OnBecomeActiveStart&gt;d__73.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Silo\Silo.cs:line 529 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 82 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 115 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext() in D:\j\workspace\functional_pr---83d31c72\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 55</Title_Description>
    <Label>test-issue</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4996</IssueLabelID>
    <Title>Resolve transaction on abort.</Title>
    <Description>Abort and Cancel calls are no longer one way.  When transactions return abort exceptions they can usually be retried immediately.  In some rare cases this will cause a single cascade abort.


Correctness testing and fault testing now enabled.
</Description>
    <Title_Description>Resolve transaction on abort. Abort and Cancel calls are no longer one way.  When transactions return abort exceptions they can usually be retried immediately.  In some rare cases this will cause a single cascade abort.


Correctness testing and fault testing now enabled.
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4995</IssueLabelID>
    <Title>Revert Microsoft.ServiceFabric.Services version</Title>
    <Description>Upgrading even the patch version of the `Microsoft.ServiceFabric.Services` is a breaking change and requires the user to upgrade their SF cluster. Please consider to revert this back to 3.0.456.</Description>
    <Title_Description>Revert Microsoft.ServiceFabric.Services version Upgrading even the patch version of the `Microsoft.ServiceFabric.Services` is a breaking change and requires the user to upgrade their SF cluster. Please consider to revert this back to 3.0.456.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4994</IssueLabelID>
    <Title>Use grain state type when deserializing json state in azure table sto…</Title>
    <Description>…rage. Fixes #4993</Description>
    <Title_Description>Use grain state type when deserializing json state in azure table sto… …rage. Fixes #4993</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4993</IssueLabelID>
    <Title>InvalidCastException when deserializing json state when custom JsonProperty is used with TypeNameHandling.None</Title>
    <Description>`InvalidCastException` is thrown when deserializing json state using the Azure Table Storage provider if the state was serialized with properties having the `JsonProperty` attribute with a redefining property name. The exception is thrown if the state is stored with `TypeNameHandling.None`.

A PR is coming...
</Description>
    <Title_Description>InvalidCastException when deserializing json state when custom JsonProperty is used with TypeNameHandling.None `InvalidCastException` is thrown when deserializing json state using the Azure Table Storage provider if the state was serialized with properties having the `JsonProperty` attribute with a redefining property name. The exception is thrown if the state is stored with `TypeNameHandling.None`.

A PR is coming...
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4992</IssueLabelID>
    <Title>Distributed tracing and Orleans</Title>
    <Description># Goal
Distributed tracing that works out-of-the-box with other Microsoft libraries like System.Net (HttpClient) EntityFramework Event Hubs SDK and Service Bus SDK.

# Value
I want to instrument my Orleans application in a way I can correlate events so I can trace the effect of any one request across an entire system across service boundaries. As an example by adding a trace identifier to a HTTP request I want to see that it reaches my gateway (in ASP.NET Core) each grain it hits (in Orleans) the messages it creates (on an Event Hub) and the database transaction it executes (via Entity Framework). 

# Background
I understand Orleans provides an [ActivityId](https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs#L37) however it doesn't cover distributed tracing out-of-the-box (i.e. flowing that ActivityId to other systems).

I looked at how other Microsoft libraries did this (e.g. [System.Net](https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs) [Event Hubs SDK](https://github.com/Azure/azure-event-hubs-dotnet/blob/1a890942ce86339ef4ed97f9246acf36823cb4f7/src/Microsoft.Azure.EventHubs/EventHubsDiagnosticSource.cs)) and they seem to be converging on [System.Diagnostics.Activity](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Activity.cs) which is available as an AsyncLocal container (Activity.Current) for carrying diagnostic context. (More information about Activity is in [the user guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md).)
Unfortunately it's not something that is used with Microsoft.Extension.Logging but rather introduces a (yet another) new diagnostic API: [System.Diagnostics.DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/DiagnosticSource.cs). DiagnosticSource is distinct from other logging systems in that it's to be consumed in-process and sources normally provide rich payloads.
(More information about DiagnosticSource is in [the user guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).)

Libraries using Activity which make or receive external calls often implement some variation of [this correlation protocol](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md). This means that the Activity is emitted on outbound requests and resumed on inbound requests.
It [looks](https://github.com/aspnet/Hosting/issues/1457) [like](https://github.com/dotnet/corefx/issues/30332) there is work underway to standardize (the header names) based on the [W3C spec for distributed tracing](https://w3c.github.io/distributed-tracing/report-trace-context.html). However Orleans should be able to be instrumented now without being affected by these changes. (Client-to-Orleans calls are via an Orleans-provided library so I don't think a change in header names would be a breaking change.)
~~(There (hopefully?) won't be any change to Activity itself [depending on this discussion](https://github.com/dotnet/corefx/issues/30331).)~~
Edit: See @lmolkova's comment for details on the impact of W3C distributed tracing.

# Implementation
There is official guidance for [Activity](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md) and [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) but newer documentation is work-in-progress and [available here](https://github.com/Microsoft/ApplicationInsights-dotnet-server/pull/917).

Based on [the experience of people who have consumed DiagnosticSources before](https://github.com/MiniProfiler/dotnet/issues/322#issuecomment-421198415) it looks like a implementation similar to Entity Framework [where the events are typed](https://github.com/aspnet/EntityFrameworkCore/pull/8351) would be preferable.

My insight only goes as deep as poking around over the last week. I've come across people who seem very involved in the .NET and distributed tracing space who might be able to chime in and enlighten us about the right way of approaching this such as @SergeyKanzhelev @lmolkova and @cwe1ss.

## Minimal
A minimal implementation would allow the Activity to flow across service boundaries with a DiagnosticSource for grain requests. Log providers (ILoggerProvider) could optionally listen to this DiagnosticSource (or all DiagnosticSources) and enrich the logs with the Activity context.

* Add an interceptor to start an Activity and add it to the [RequestContext](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs).
   @rikbosch has a gist with an implementation of [this part here](https://github.com/dotnet/orleans/issues/3093#issuecomment-308039802).
* Add a client-side interceptor (if that's a thing) which starts an Activity and adds it to the RequestContext.
* Add documentation for log providers wanting to enrich logs with the Activity context and/or document which providers work like this out of the box.
   @SergeyKanzhelev does App Insight's (ASP.NET Core?) ILoggerProvider implementation already make use of the Activity.Current for correlation? I saw [this](https://docs.microsoft.com/en-us/azure/application-insights/application-insights-correlation) but does that mean it'll work for any DiagnosticSource?
   &gt;Application Insights SDK starting version 2.4.0-beta1 uses DiagnosticSource and Activity to collect telemetry and associate it with the current activity.

## Extended
An extended implementation might go so far as to replace ILogger use in Orleans with DiagnosticSources and provide adapters back to ILogger (and to ITelemetryProvider for performance counters). I think the value of going this far would be to offer richer diagnostics to people who want it (e.g. someone who wants to build a profiler) and a single diagnostics API for Orleans. (The minimal implementation would mean Orleans would offer both ILogger and DiagnosticSource which is ugh.)
</Description>
    <Title_Description>Distributed tracing and Orleans # Goal
Distributed tracing that works out-of-the-box with other Microsoft libraries like System.Net (HttpClient) EntityFramework Event Hubs SDK and Service Bus SDK.

# Value
I want to instrument my Orleans application in a way I can correlate events so I can trace the effect of any one request across an entire system across service boundaries. As an example by adding a trace identifier to a HTTP request I want to see that it reaches my gateway (in ASP.NET Core) each grain it hits (in Orleans) the messages it creates (on an Event Hub) and the database transaction it executes (via Entity Framework). 

# Background
I understand Orleans provides an [ActivityId](https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs#L37) however it doesn't cover distributed tracing out-of-the-box (i.e. flowing that ActivityId to other systems).

I looked at how other Microsoft libraries did this (e.g. [System.Net](https://github.com/dotnet/corefx/blob/master/src/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs) [Event Hubs SDK](https://github.com/Azure/azure-event-hubs-dotnet/blob/1a890942ce86339ef4ed97f9246acf36823cb4f7/src/Microsoft.Azure.EventHubs/EventHubsDiagnosticSource.cs)) and they seem to be converging on [System.Diagnostics.Activity](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Activity.cs) which is available as an AsyncLocal container (Activity.Current) for carrying diagnostic context. (More information about Activity is in [the user guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md).)
Unfortunately it's not something that is used with Microsoft.Extension.Logging but rather introduces a (yet another) new diagnostic API: [System.Diagnostics.DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/DiagnosticSource.cs). DiagnosticSource is distinct from other logging systems in that it's to be consumed in-process and sources normally provide rich payloads.
(More information about DiagnosticSource is in [the user guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).)

Libraries using Activity which make or receive external calls often implement some variation of [this correlation protocol](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/HttpCorrelationProtocol.md). This means that the Activity is emitted on outbound requests and resumed on inbound requests.
It [looks](https://github.com/aspnet/Hosting/issues/1457) [like](https://github.com/dotnet/corefx/issues/30332) there is work underway to standardize (the header names) based on the [W3C spec for distributed tracing](https://w3c.github.io/distributed-tracing/report-trace-context.html). However Orleans should be able to be instrumented now without being affected by these changes. (Client-to-Orleans calls are via an Orleans-provided library so I don't think a change in header names would be a breaking change.)
~~(There (hopefully?) won't be any change to Activity itself [depending on this discussion](https://github.com/dotnet/corefx/issues/30331).)~~
Edit: See @lmolkova's comment for details on the impact of W3C distributed tracing.

# Implementation
There is official guidance for [Activity](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md) and [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) but newer documentation is work-in-progress and [available here](https://github.com/Microsoft/ApplicationInsights-dotnet-server/pull/917).

Based on [the experience of people who have consumed DiagnosticSources before](https://github.com/MiniProfiler/dotnet/issues/322#issuecomment-421198415) it looks like a implementation similar to Entity Framework [where the events are typed](https://github.com/aspnet/EntityFrameworkCore/pull/8351) would be preferable.

My insight only goes as deep as poking around over the last week. I've come across people who seem very involved in the .NET and distributed tracing space who might be able to chime in and enlighten us about the right way of approaching this such as @SergeyKanzhelev @lmolkova and @cwe1ss.

## Minimal
A minimal implementation would allow the Activity to flow across service boundaries with a DiagnosticSource for grain requests. Log providers (ILoggerProvider) could optionally listen to this DiagnosticSource (or all DiagnosticSources) and enrich the logs with the Activity context.

* Add an interceptor to start an Activity and add it to the [RequestContext](https://github.com/dotnet/orleans/blob/master/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs).
   @rikbosch has a gist with an implementation of [this part here](https://github.com/dotnet/orleans/issues/3093#issuecomment-308039802).
* Add a client-side interceptor (if that's a thing) which starts an Activity and adds it to the RequestContext.
* Add documentation for log providers wanting to enrich logs with the Activity context and/or document which providers work like this out of the box.
   @SergeyKanzhelev does App Insight's (ASP.NET Core?) ILoggerProvider implementation already make use of the Activity.Current for correlation? I saw [this](https://docs.microsoft.com/en-us/azure/application-insights/application-insights-correlation) but does that mean it'll work for any DiagnosticSource?
   &gt;Application Insights SDK starting version 2.4.0-beta1 uses DiagnosticSource and Activity to collect telemetry and associate it with the current activity.

## Extended
An extended implementation might go so far as to replace ILogger use in Orleans with DiagnosticSources and provide adapters back to ILogger (and to ITelemetryProvider for performance counters). I think the value of going this far would be to offer richer diagnostics to people who want it (e.g. someone who wants to build a profiler) and a single diagnostics API for Orleans. (The minimal implementation would mean Orleans would offer both ILogger and DiagnosticSource which is ugh.)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4990</IssueLabelID>
    <Title>Start silo fails with System.IndexOutOfRangeException on 2.1.0</Title>
    <Description>#### Environments:
* Windows 10 1803
* Visual Studio 2017 15.9.0 Preview 2.0
* .NET Core SDK 2.1.402
* Orleans 2.1.0-rc1

#### Issue:
Silo failed to start with error:

&gt; info: Orleans.Runtime.Silo[100452]
      Start Incoming message agents took 33 Milliseconds to finish
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.Messaging.IncomingMessageAgent/Application0 on managed thread 22
info: Orleans.Runtime.GrainDirectory.LocalGrainDirectory[0]
      Start
info: Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1[0]
      Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 5
info: Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer[0]
      Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 5
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`10 on managed thread 23
info: Orleans.Runtime.Silo[100452]
      Start local grain directory took 13 Milliseconds to finish
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0 on managed thread 24
info: Orleans.Runtime.Silo[100452]
      Init implicit stream subscribe table took 11 Milliseconds to finish
info: Orleans.Runtime.Silo[100452]
      Create system targets and inject dependencies took 27 Milliseconds to finish
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 118 Milliseconds.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Starting lifecycle stage 4000 took 118.1442 Milliseconds
info: Orleans.Runtime.Catalog[100507]
      Before collection#1: memory=6MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
info: Orleans.Runtime.Catalog[100508]
      After collection#1: memory=6MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0137324.
info: Orleans.Runtime.Silo[100452]
      Init grain services took 1 Milliseconds to finish
info: Orleans.Runtime.MembershipService.MembershipOracleData[100603]
      MembershipOracle starting on host = szf-sl address = S127.0.0.1:11111:274874211 at 2018-09-17 09:56:51.881 GMT backOffMax = 00:00:02
info: Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable[100635]
      Creating in-memory membership table
info: Orleans.Runtime.MembershipService.MembershipTableSystemTarget[100637]
      GrainBasedMembershipTable Activated.
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101017]
      Exception trying to process 198 bytes from endpoint 127.0.0.1:63001
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Orleans.Runtime.MessagingStatisticsGroup.OnMessageReceive(Message msg Int32 headerBytes Int32 bodyBytes) in D:\build\agent\_work\23\s\src\Orleans.Core\Statistics\MessagingStatisticsGroup.cs:line 192
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 197
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 659
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101027]
      ProcessReceivedBuffer exception with RemoteEndPoint 127.0.0.1:63001:
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Orleans.Runtime.MessagingStatisticsGroup.OnMessageReceive(Message msg Int32 headerBytes Int32 bodyBytes) in D:\build\agent\_work\23\s\src\Orleans.Core\Statistics\MessagingStatisticsGroup.cs:line 192
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 197
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 659
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ProcessReceive(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 489

It happens on all 2.1.0 versions(Including beta1rc1 and ci builds). **And there's no such error if I directly reference the `Orleans.Server` source project instead of the package `Microsoft.Orleans.Server` .**

</Description>
    <Title_Description>Start silo fails with System.IndexOutOfRangeException on 2.1.0 #### Environments:
* Windows 10 1803
* Visual Studio 2017 15.9.0 Preview 2.0
* .NET Core SDK 2.1.402
* Orleans 2.1.0-rc1

#### Issue:
Silo failed to start with error:

&gt; info: Orleans.Runtime.Silo[100452]
      Start Incoming message agents took 33 Milliseconds to finish
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.Messaging.IncomingMessageAgent/Application0 on managed thread 22
info: Orleans.Runtime.GrainDirectory.LocalGrainDirectory[0]
      Start
info: Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1[0]
      Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 5
info: Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer[0]
      Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 5
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`10 on managed thread 23
info: Orleans.Runtime.Silo[100452]
      Start local grain directory took 13 Milliseconds to finish
info: Orleans.Threading.ThreadPoolThread[0]
      Starting thread Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer0 on managed thread 24
info: Orleans.Runtime.Silo[100452]
      Init implicit stream subscribe table took 11 Milliseconds to finish
info: Orleans.Runtime.Silo[100452]
      Create system targets and inject dependencies took 27 Milliseconds to finish
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 118 Milliseconds.
info: Orleans.Runtime.SiloLifecycleSubject[100452]
      Starting lifecycle stage 4000 took 118.1442 Milliseconds
info: Orleans.Runtime.Catalog[100507]
      Before collection#1: memory=6MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
info: Orleans.Runtime.Catalog[100508]
      After collection#1: memory=6MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0137324.
info: Orleans.Runtime.Silo[100452]
      Init grain services took 1 Milliseconds to finish
info: Orleans.Runtime.MembershipService.MembershipOracleData[100603]
      MembershipOracle starting on host = szf-sl address = S127.0.0.1:11111:274874211 at 2018-09-17 09:56:51.881 GMT backOffMax = 00:00:02
info: Orleans.Runtime.MembershipService.SystemTargetBasedMembershipTable[100635]
      Creating in-memory membership table
info: Orleans.Runtime.MembershipService.MembershipTableSystemTarget[100637]
      GrainBasedMembershipTable Activated.
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101017]
      Exception trying to process 198 bytes from endpoint 127.0.0.1:63001
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Orleans.Runtime.MessagingStatisticsGroup.OnMessageReceive(Message msg Int32 headerBytes Int32 bodyBytes) in D:\build\agent\_work\23\s\src\Orleans.Core\Statistics\MessagingStatisticsGroup.cs:line 192
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 197
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 659
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101027]
      ProcessReceivedBuffer exception with RemoteEndPoint 127.0.0.1:63001:
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at Orleans.Runtime.MessagingStatisticsGroup.OnMessageReceive(Message msg Int32 headerBytes Int32 bodyBytes) in D:\build\agent\_work\23\s\src\Orleans.Core\Statistics\MessagingStatisticsGroup.cs:line 192
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\build\agent\_work\23\s\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 197
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 659
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ProcessReceive(SocketAsyncEventArgs e) in D:\build\agent\_work\23\s\src\Orleans.Runtime\Messaging\IncomingMessageAcceptor.cs:line 489

It happens on all 2.1.0 versions(Including beta1rc1 and ci builds). **And there's no such error if I directly reference the `Orleans.Server` source project instead of the package `Microsoft.Orleans.Server` .**

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4989</IssueLabelID>
    <Title>Reminders documentation improvement idea</Title>
    <Description>This knowledge should be added to the Orleans reminders documentation: 

![image](https://user-images.githubusercontent.com/1445862/43936561-5d9737c4-9c9c-11e8-80df-43f80fb6d241.png)
</Description>
    <Title_Description>Reminders documentation improvement idea This knowledge should be added to the Orleans reminders documentation: 

![image](https://user-images.githubusercontent.com/1445862/43936561-5d9737c4-9c9c-11e8-80df-43f80fb6d241.png)
</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4988</IssueLabelID>
    <Title>Move implementation details pages to the respective section</Title>
    <Description>
    </Description>
    <Title_Description>Move implementation details pages to the respective section </Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4987</IssueLabelID>
    <Title>Add changelog for 2.1.0-rc1</Title>
    <Description>
    </Description>
    <Title_Description>Add changelog for 2.1.0-rc1 </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4986</IssueLabelID>
    <Title>ToTypedTask&lt;T&gt; fails with NullReferenceException on ASP.NET Core 2.1</Title>
    <Description>I'm working on developing an ASP.NET Core Web API to front-end an Orleans cluster for image management. I'm leveraging ASP.NET Core 2.1 because of the new `ActionResult&lt;T&gt;` feature - this feature allows a Controller to return either an `ActionResult` which wraps the return type or the raw return type. I have tested this issue with both Windows and Ubuntu 16.04 (WSL) versions of .NET Core and the results are the same. I have no build time errors or dependency warnings. I'm not sure how much information is enough information so I've pasted the relevant code from the ASP.NET Controller the ASP.NET configuration the Grain class and the Silo configuration in case any of those configs are relevant.

I can share more code/configs upon request. :)

The workflow:
1. Image gets uploaded to ASP.NET Controller.
1. Image is converted to `Orleans.Concurrency.Immutable&lt;byte[]&gt;`.
1. Image is sent to silo through grain client.
1. Grain client throws `NullReferenceException`.

With this REST controller:

```c#
[HttpPost]
[ProducesResponseType(201)]
[ProducesResponseType(400)]
[ProducesResponseType(401)]
public async Task&lt;ActionResult&lt;Image&gt;&gt; PostImage([Required] string owner [Required] IFormFile imagePayload) {
    if (imagePayload == null || imagePayload.Length == 0) {
        return new BadRequestObjectResult(new Image());
    }
    Image localImageRef = new Image();
    ...    
    var grain = _orleansClient.GetGrain&lt;IImage&gt;(localImageRef.Id);

    // make a quick buffer to read the image and then send it as a raw payload. since it's an image file no
    // data should change hence Immutable&lt;T&gt; is used.
    MemoryStream ms = new MemoryStream();
    await imagePayload.CopyToAsync(ms);
    Immutable&lt;byte[]&gt; imageByteArray = new Immutable&lt;byte[]&gt;(ms.ToArray());

    return await grain.CreateImage(localImageRef imageByteArray);
}
```

Running in a Kestrel server with this configuration

```c#
public void ConfigureServices(IServiceCollection services) {
            services.AddSingleton&lt;IClusterClient&gt;(CreateOrleansClient());
            ...
        }
        public void Configure(IApplicationBuilder app IHostingEnvironment env) {
            if (env.IsDevelopment()) {
                app.UseDeveloperExceptionPage();
            }
            ...
            app.UseMvc();
        }
        private IClusterClient CreateOrleansClient() {
            IClientBuilder clientBuilder = new ClientBuilder()
                .UseLocalhostClustering()
                .Configure&lt;ClusterOptions&gt;(opts =&gt; {
                    opts.ClusterId = "dev";
                    opts.ServiceId = "ImageStorageTest";
                })
                .ConfigureLogging(logging =&gt; logging.AddConsole());
            IClusterClient clusterClient = clientBuilder.Build();
            clusterClient.Connect(async ex =&gt; {
                Console.WriteLine("Retrying...");
                await Task.Delay(3000);
                return true;
            }).Wait();
            return clusterClient;
        }
```

Calling into this grain:

```c#
public class ImageGrain : Grain&lt;ImageState&gt; IImage {
        private readonly MinioClient _minio;
        public ImageGrain(IServiceProvider serviceProvider) {
            _minio = serviceProvider.GetService&lt;MinioClient&gt;();
        }

        public async Task&lt;Image&gt; CreateImage(Image localImageRef Immutable&lt;byte[]&gt; imagePayload) {
            localImageRef.LastUpdated = DateTime.UtcNow;
            await _minio.PutObjectAsync(...);
            localImageRef.Location = await _minio.PresignedGetObjectAsync(...);
            ...
            await WriteStateAsync();
            return localImageRef;
        }
        ...
```

Which runs with this silo configuration:

```c#
private static async Task&lt;ISiloHost&gt; StartSilo() {
            ISiloHostBuilder siloBuilder = new SiloHostBuilder()
                .AddMemoryGrainStorage("ImageStorage" options =&gt; options.NumStorageGrains = 10)
                .UseLocalhostClustering()
                .UseDashboard(opts =&gt; { })
                .Configure&lt;ClusterOptions&gt;(opts =&gt; {
                    opts.ClusterId = "dev";
                    opts.ServiceId = "ImageStorageTest";
                })
                .Configure&lt;EndpointOptions&gt;(opts =&gt; { opts.AdvertisedIPAddress = IPAddress.Loopback; })
                .ConfigureServices(services =&gt; {
                    services.AddSingleton&lt;IMinioClient&gt;(provider =&gt;
                        new MinioStorageClient(...));
                })
                .ConfigureApplicationParts(parts =&gt; {
                    parts.AddApplicationPart(typeof(ImageGrain).Assembly).WithReferences();
                })
                .ConfigureLogging(logging =&gt; {
                    logging.AddConsole();
                });
            ISiloHost host = siloBuilder.Build();
            await host.StartAsync();
            return host;
        }
```

When I try to upload an image file from my local machine to the localhost ASP.NET Core server like this:

```bash
curl -X POST "http://localhost:5000/api/images?owner=mxplusb" -H  "accept: application/json" -H  "Content-Type: multipart/form-data" -F "imagePayload=@IMG_1460.jpg;type=image/jpeg"
```

I get this exception:

```c#
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[101018]
      Preparing to send large message Size=1500814 HeaderLength=130 BodyLength=1500676 #ArraySegments=5. Msg=Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]
      An unhandled exception has occurred while executing the request.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync4_0[T](Task`1 asyncTask) in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at WarframeAPI.Controllers.ImageController.PostImage(String owner IFormFile imagePayload) in P:\csharp\warframe\Backend\Controllers\ImageController.cs:line 80
   at lambda_method(Closure  Object )
   at Microsoft.Extensions.Internal.ObjectMethodExecutorAwaitable.Awaiter.GetResult()
   at Microsoft.AspNetCore.Mvc.Internal.ActionMethodExecutor.AwaitableObjectResultExecutor.Execute(IActionResultTypeMapper mapper ObjectMethodExecutor executor Object controller Object[] arguments)
   at System.Threading.Tasks.ValueTask`1.get_Result()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeActionMethodAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeNextActionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Rethrow(ActionExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeInnerFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextResourceFilter()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ResourceExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeFilterPipelineAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeAsync()
   at Microsoft.AspNetCore.Builder.RouterMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.StaticFiles.StaticFileMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIIndexMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
```

Windows .NET Core SDK info:

```powershell
&gt; dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.401
 Commit:    91b1c13032

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.401\

Host (useful for support):
  Version: 2.1.3-servicing-26724-03
  Commit:  124038c13e

.NET Core SDKs installed:
  2.1.2 [C:\Program Files\dotnet\sdk]
  2.1.202 [C:\Program Files\dotnet\sdk]
  2.1.302 [C:\Program Files\dotnet\sdk]
  2.1.401 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.3-servicing-26724-03 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
```

Ubuntu 16.04 (WSL) .NET SDK info:

```bash
% dotnet --info
.NET Command Line Tools (2.1.105)

Product Information:
 Version:            2.1.105
 Commit SHA-1 hash:  141cc8d976

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.1.105/

Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0

.NET Core SDKs installed:
  2.1.105 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.NETCore.App 2.0.7 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
```

Project configuration:

```xml
&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Folder Include="wwwroot\" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.All" Version="2.1.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Client" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansCodeGenerator.Build" Version="2.0.5" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore" Version="3.0.0" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;DotNetCliToolReference Include="Microsoft.VisualStudio.Web.CodeGeneration.Tools" Version="2.0.3" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\GrainInterfaces\WarframeGrainInterfaces.csproj" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
```

Edit: added package config.</Description>
    <Title_Description>ToTypedTask&lt;T&gt; fails with NullReferenceException on ASP.NET Core 2.1 I'm working on developing an ASP.NET Core Web API to front-end an Orleans cluster for image management. I'm leveraging ASP.NET Core 2.1 because of the new `ActionResult&lt;T&gt;` feature - this feature allows a Controller to return either an `ActionResult` which wraps the return type or the raw return type. I have tested this issue with both Windows and Ubuntu 16.04 (WSL) versions of .NET Core and the results are the same. I have no build time errors or dependency warnings. I'm not sure how much information is enough information so I've pasted the relevant code from the ASP.NET Controller the ASP.NET configuration the Grain class and the Silo configuration in case any of those configs are relevant.

I can share more code/configs upon request. :)

The workflow:
1. Image gets uploaded to ASP.NET Controller.
1. Image is converted to `Orleans.Concurrency.Immutable&lt;byte[]&gt;`.
1. Image is sent to silo through grain client.
1. Grain client throws `NullReferenceException`.

With this REST controller:

```c#
[HttpPost]
[ProducesResponseType(201)]
[ProducesResponseType(400)]
[ProducesResponseType(401)]
public async Task&lt;ActionResult&lt;Image&gt;&gt; PostImage([Required] string owner [Required] IFormFile imagePayload) {
    if (imagePayload == null || imagePayload.Length == 0) {
        return new BadRequestObjectResult(new Image());
    }
    Image localImageRef = new Image();
    ...    
    var grain = _orleansClient.GetGrain&lt;IImage&gt;(localImageRef.Id);

    // make a quick buffer to read the image and then send it as a raw payload. since it's an image file no
    // data should change hence Immutable&lt;T&gt; is used.
    MemoryStream ms = new MemoryStream();
    await imagePayload.CopyToAsync(ms);
    Immutable&lt;byte[]&gt; imageByteArray = new Immutable&lt;byte[]&gt;(ms.ToArray());

    return await grain.CreateImage(localImageRef imageByteArray);
}
```

Running in a Kestrel server with this configuration

```c#
public void ConfigureServices(IServiceCollection services) {
            services.AddSingleton&lt;IClusterClient&gt;(CreateOrleansClient());
            ...
        }
        public void Configure(IApplicationBuilder app IHostingEnvironment env) {
            if (env.IsDevelopment()) {
                app.UseDeveloperExceptionPage();
            }
            ...
            app.UseMvc();
        }
        private IClusterClient CreateOrleansClient() {
            IClientBuilder clientBuilder = new ClientBuilder()
                .UseLocalhostClustering()
                .Configure&lt;ClusterOptions&gt;(opts =&gt; {
                    opts.ClusterId = "dev";
                    opts.ServiceId = "ImageStorageTest";
                })
                .ConfigureLogging(logging =&gt; logging.AddConsole());
            IClusterClient clusterClient = clientBuilder.Build();
            clusterClient.Connect(async ex =&gt; {
                Console.WriteLine("Retrying...");
                await Task.Delay(3000);
                return true;
            }).Wait();
            return clusterClient;
        }
```

Calling into this grain:

```c#
public class ImageGrain : Grain&lt;ImageState&gt; IImage {
        private readonly MinioClient _minio;
        public ImageGrain(IServiceProvider serviceProvider) {
            _minio = serviceProvider.GetService&lt;MinioClient&gt;();
        }

        public async Task&lt;Image&gt; CreateImage(Image localImageRef Immutable&lt;byte[]&gt; imagePayload) {
            localImageRef.LastUpdated = DateTime.UtcNow;
            await _minio.PutObjectAsync(...);
            localImageRef.Location = await _minio.PresignedGetObjectAsync(...);
            ...
            await WriteStateAsync();
            return localImageRef;
        }
        ...
```

Which runs with this silo configuration:

```c#
private static async Task&lt;ISiloHost&gt; StartSilo() {
            ISiloHostBuilder siloBuilder = new SiloHostBuilder()
                .AddMemoryGrainStorage("ImageStorage" options =&gt; options.NumStorageGrains = 10)
                .UseLocalhostClustering()
                .UseDashboard(opts =&gt; { })
                .Configure&lt;ClusterOptions&gt;(opts =&gt; {
                    opts.ClusterId = "dev";
                    opts.ServiceId = "ImageStorageTest";
                })
                .Configure&lt;EndpointOptions&gt;(opts =&gt; { opts.AdvertisedIPAddress = IPAddress.Loopback; })
                .ConfigureServices(services =&gt; {
                    services.AddSingleton&lt;IMinioClient&gt;(provider =&gt;
                        new MinioStorageClient(...));
                })
                .ConfigureApplicationParts(parts =&gt; {
                    parts.AddApplicationPart(typeof(ImageGrain).Assembly).WithReferences();
                })
                .ConfigureLogging(logging =&gt; {
                    logging.AddConsole();
                });
            ISiloHost host = siloBuilder.Build();
            await host.StartAsync();
            return host;
        }
```

When I try to upload an image file from my local machine to the localhost ASP.NET Core server like this:

```bash
curl -X POST "http://localhost:5000/api/images?owner=mxplusb" -H  "accept: application/json" -H  "Content-Type: multipart/form-data" -F "imagePayload=@IMG_1460.jpg;type=image/jpeg"
```

I get this exception:

```c#
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[101018]
      Preparing to send large message Size=1500814 HeaderLength=130 BodyLength=1500676 #ArraySegments=5. Msg=Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]
      An unhandled exception has occurred while executing the request.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.OrleansTaskExtentions.&lt;ToTypedTask&gt;g__ConvertAsync4_0[T](Task`1 asyncTask) in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
   at WarframeAPI.Controllers.ImageController.PostImage(String owner IFormFile imagePayload) in P:\csharp\warframe\Backend\Controllers\ImageController.cs:line 80
   at lambda_method(Closure  Object )
   at Microsoft.Extensions.Internal.ObjectMethodExecutorAwaitable.Awaiter.GetResult()
   at Microsoft.AspNetCore.Mvc.Internal.ActionMethodExecutor.AwaitableObjectResultExecutor.Execute(IActionResultTypeMapper mapper ObjectMethodExecutor executor Object controller Object[] arguments)
   at System.Threading.Tasks.ValueTask`1.get_Result()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeActionMethodAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeNextActionFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Rethrow(ActionExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker.InvokeInnerFilterAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeNextResourceFilter()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Rethrow(ResourceExecutedContext context)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.Next(State&amp; next Scope&amp; scope Object&amp; state Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeFilterPipelineAsync()
   at Microsoft.AspNetCore.Mvc.Internal.ResourceInvoker.InvokeAsync()
   at Microsoft.AspNetCore.Builder.RouterMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.StaticFiles.StaticFileMiddleware.Invoke(HttpContext context)
   at Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIIndexMiddleware.Invoke(HttpContext httpContext)
   at Swashbuckle.AspNetCore.Swagger.SwaggerMiddleware.Invoke(HttpContext httpContext)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
```

Windows .NET Core SDK info:

```powershell
&gt; dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.401
 Commit:    91b1c13032

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.401\

Host (useful for support):
  Version: 2.1.3-servicing-26724-03
  Commit:  124038c13e

.NET Core SDKs installed:
  2.1.2 [C:\Program Files\dotnet\sdk]
  2.1.202 [C:\Program Files\dotnet\sdk]
  2.1.302 [C:\Program Files\dotnet\sdk]
  2.1.401 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.0.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.3-servicing-26724-03 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
```

Ubuntu 16.04 (WSL) .NET SDK info:

```bash
% dotnet --info
.NET Command Line Tools (2.1.105)

Product Information:
 Version:            2.1.105
 Commit SHA-1 hash:  141cc8d976

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  16.04
 OS Platform: Linux
 RID:         ubuntu.16.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.1.105/

Host (useful for support):
  Version: 2.1.2
  Commit:  811c3ce6c0

.NET Core SDKs installed:
  2.1.105 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.NETCore.App 2.0.7 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
```

Project configuration:

```xml
&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Folder Include="wwwroot\" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.All" Version="2.1.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Client" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansCodeGenerator.Build" Version="2.0.5" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore" Version="3.0.0" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;DotNetCliToolReference Include="Microsoft.VisualStudio.Web.CodeGeneration.Tools" Version="2.0.3" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\GrainInterfaces\WarframeGrainInterfaces.csproj" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
```

Edit: added package config.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4985</IssueLabelID>
    <Title>Durability Guarantees</Title>
    <Description>When I save the actor state what are the durability guarantees?  How long before that data is actually persisted?</Description>
    <Title_Description>Durability Guarantees When I save the actor state what are the durability guarantees?  How long before that data is actually persisted?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>14/09/2018 4:57:53 AM +00:00</CreatedAt>
    <ClosedAt>4/10/2018 6:17:14 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4984</IssueLabelID>
    <Title>Revist Transaction serialization</Title>
    <Description>* Consider passing object directly to transaction storage APIs (rather than serialized)
* Ensure that grain references can be serialized by user code

Backwards compatibility is required by the time transactions are stabilized.

cc @jason-bragg 
</Description>
    <Title_Description>Revist Transaction serialization * Consider passing object directly to transaction storage APIs (rather than serialized)
* Ensure that grain references can be serialized by user code

Backwards compatibility is required by the time transactions are stabilized.

cc @jason-bragg 
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4981</IssueLabelID>
    <Title>Move advanced topis and implementation details to separate sections</Title>
    <Description>This is to unclutter the core documentation about grains.</Description>
    <Title_Description>Move advanced topis and implementation details to separate sections This is to unclutter the core documentation about grains.</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4978</IssueLabelID>
    <Title>Add TableName to Azure Storage clustering and reminders config</Title>
    <Description>This resolves: https://github.com/dotnet/orleans/issues/4971
As it is implemented here it solves our needs.

As far as I could see there are no validators for these options but I can whip some up in a separate PR.

One open question: Should this also be made configurable for AzureSilo and the tests?</Description>
    <Title_Description>Add TableName to Azure Storage clustering and reminders config This resolves: https://github.com/dotnet/orleans/issues/4971
As it is implemented here it solves our needs.

As far as I could see there are no validators for these options but I can whip some up in a separate PR.

One open question: Should this also be made configurable for AzureSilo and the tests?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4977</IssueLabelID>
    <Title>Fix logo on README.md</Title>
    <Description>Seems that a recent change in the gh-pages branch broke the logo at the top of our README
Previously the logo was here: https://github.com/dotnet/orleans/blob/gh-pages/assets/logo_full.png</Description>
    <Title_Description>Fix logo on README.md Seems that a recent change in the gh-pages branch broke the logo at the top of our README
Previously the logo was here: https://github.com/dotnet/orleans/blob/gh-pages/assets/logo_full.png</Title_Description>
    <Label>
    </Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4975</IssueLabelID>
    <Title>Using streams with RabbitMQ</Title>
    <Description>Hi I'm learning about Streams and am interested in using it together with a message queuing system like RabbitMQ. My use case can have potentially a large number of requests and I want to be able to implement throttling (such as limiting the number of Grains that are doing work at a time) and work priority. My use case is similar to a cloud base Borg Hivemind trying to conquer the universe.

I was thinking to have a master queue like RabbitMQ hold all the tasks that a Borg unit would do and a large number of BorgUnitGrain would subscribe to and perform tasks listed in the RabbitMQ master queue as they receive them. 

I want to be able to control concurrency and throttling on a per planet basis for assimilation so multiple planets could be marked but I only want a set number of BorgUnitGrains to be working on a planet at a time. I was thinking that I can control concurrency by having an orchestrator control what tasks get pushed onto RabbitMQ to be divided up by the BorgUnitGrains. Do you guys have any recommendations for what I'm trying to do?</Description>
    <Title_Description>Using streams with RabbitMQ Hi I'm learning about Streams and am interested in using it together with a message queuing system like RabbitMQ. My use case can have potentially a large number of requests and I want to be able to implement throttling (such as limiting the number of Grains that are doing work at a time) and work priority. My use case is similar to a cloud base Borg Hivemind trying to conquer the universe.

I was thinking to have a master queue like RabbitMQ hold all the tasks that a Borg unit would do and a large number of BorgUnitGrain would subscribe to and perform tasks listed in the RabbitMQ master queue as they receive them. 

I want to be able to control concurrency and throttling on a per planet basis for assimilation so multiple planets could be marked but I only want a set number of BorgUnitGrains to be working on a planet at a time. I was thinking that I can control concurrency by having an orchestrator control what tasks get pushed onto RabbitMQ to be divided up by the BorgUnitGrains. Do you guys have any recommendations for what I'm trying to do?</Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4973</IssueLabelID>
    <Title>No storage provider named "PubSubStore" found loading grain type Orleans.Streams.PubSubRendezvousGrain.</Title>
    <Description>When I used IAsyncstream to notify the client I was prompted that a storage provider named “PubSubStore” was not found but I did configure the storage provider only the configuration name was not “PubSubStore” and if I had storage provider's name configured as “PubSubStore” there would be no problem. In the end I found the class PubSubRendezvousGrain in the source code with the attribute[Storageprovider (ProviderName =  "Pubsubstore")] so I wonder if  this attribute is the reason I have to configure a stroage provider named PubSubStore?</Description>
    <Title_Description>No storage provider named "PubSubStore" found loading grain type Orleans.Streams.PubSubRendezvousGrain. When I used IAsyncstream to notify the client I was prompted that a storage provider named “PubSubStore” was not found but I did configure the storage provider only the configuration name was not “PubSubStore” and if I had storage provider's name configured as “PubSubStore” there would be no problem. In the end I found the class PubSubRendezvousGrain in the source code with the attribute[Storageprovider (ProviderName =  "Pubsubstore")] so I wonder if  this attribute is the reason I have to configure a stroage provider named PubSubStore?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4971</IssueLabelID>
    <Title>Make Azure Storage table name (OrleansSiloInstances OrleansReminders) configurable</Title>
    <Description>We're looking into deploying concurrent and disposable instances of our application.
To reduce the amount of orchestration we intend to re-use a single Azure Storage Accounts for multiple deployments of our application concurrently.

State storage can already sufficiently configure to not collide using `AzureBlobStorageOptions.ContainerName`.
However the 'OrleansSiloInstances' and 'OrleansReminders' table is not configurable.

Could `AzureStorageClusteringOptions` and `AzureTableReminderStorageOptions` be extended to take a table name?

This would allow us to clean up after we pull down an instance of the application by just deleting the named tables and container.

Meanwhile as a workaround would using a different ClusterId allow multiple independent Orleans clusters to run side by side on the same tables?</Description>
    <Title_Description>Make Azure Storage table name (OrleansSiloInstances, OrleansReminders) configurable We're looking into deploying concurrent and disposable instances of our application.
To reduce the amount of orchestration we intend to re-use a single Azure Storage Accounts for multiple deployments of our application concurrently.

State storage can already sufficiently configure to not collide using `AzureBlobStorageOptions.ContainerName`.
However the 'OrleansSiloInstances' and 'OrleansReminders' table is not configurable.

Could `AzureStorageClusteringOptions` and `AzureTableReminderStorageOptions` be extended to take a table name?

This would allow us to clean up after we pull down an instance of the application by just deleting the named tables and container.

Meanwhile as a workaround would using a different ClusterId allow multiple independent Orleans clusters to run side by side on the same tables?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4969</IssueLabelID>
    <Title>Strange timers behaviour in Orleans 1.5.4</Title>
    <Description>We just spotted some strange timers behaviour in our system. 
We have a healthGrain which performs some basic operations in cluster.
Invocation of that grain is in our `/api/health` endpoint and we are using it to do some regular "checking" of the entire system. It's nowhere near a comprehensive health check in a cluster but it allows us to ensure that the following is true:
1. API client can address and reach grain in silo
2. That grain can invoke other grain
3. Message to stream is passable + 
4. Timer in arbitrary grain is up and running - I would assume all other timers are working too.
5. Internally that grain being invoked on reminder every 1-5 minutes - thus I would assume all other reminders are working.

Not a rocket science and the entire implementation looks like this:
```
public class HealthCheckGrain : BaseProxyGrain IHealthCheckGrain IRemindable
	{
		private string _context = nameof(HealthCheckGrain);
		
		private readonly IGrainLogger _logger;
		private readonly IGrainFactory _grainFactory;
		private readonly IReminderRegistry _reminders;
		private readonly ITimerRegistry _timers;
		private readonly IStreamProviderManager _streamProvManager;

		private IDisposable _maintenanceJobTimer;

		public HealthCheckGrain(IGrainLogger logger IGrainFactory grainFactory IReminderRegistry reminders ITimerRegistry timers IStreamProviderManager streamProvManager)
		{
			// DI is working in proxy grains
			_logger = logger;
			_grainFactory = grainFactory;
			_reminders = reminders;
			_timers = timers;
			_streamProvManager = streamProvManager;
		}


		public override async Task OnActivateAsync()
		{
			// New way to register timers with DI
			_maintenanceJobTimer = _timers.RegisterTimer(this timerCallback null TimeSpan.FromMinutes(1) TimeSpan.FromMinutes(3));
			// New way to register Reminders with DI
			var grainReminder = await _reminders.RegisterOrUpdateReminder(_context TimeSpan.FromMinutes(1) TimeSpan.FromMinutes(5));

			await base.OnActivateAsync();
		}

		public override Task OnDeactivateAsync()
		{
			return base.OnDeactivateAsync();
		}

		/// &lt;summary&gt; Returns health response &lt;/summary&gt;
		/// &lt;returns&gt; &lt;/returns&gt;
		public async Task&lt;string&gt; CheckHealth()
		{
			
			var hello = _grainFactory.GetGrain&lt;IHello&gt;(0);
			var helloResult = await hello.SayHello($"HealthCheck @ {DateTimeOffset.UtcNow:O}");
			
			var prov = _streamProvManager.GetStreamProvider(StreamNames.StronglyTypedCoreEvents_Provider);
			await prov.GetStream&lt;CoreEvent&gt;(Guid.NewGuid() nameof(HealthCheckStreamEvt)).OnNextAsync(new HealthCheckStreamEvt {Msg = "Hey hey stream is reachable WITH Injection"});
			
			await raise(new HealthCheckStreamEvt {Msg = "Hey hey stream is reachable"});

			return $"Hi I'm a healthy grain! Stream is reachable. Response from Stateful grain: {helloResult}";
		}


		private async Task timerCallback(object grainState)
		{
			_logger.LogInfo("Working timer in 1.5.4" _context);

			await Task.CompletedTask;
		}

		public async Task ReceiveReminder(string reminderName TickStatus status)
		{
			_logger.LogInfo($"Working reminder {reminderName} in 1.5.4" _context);
			await Task.CompletedTask;
		}
	}
```
Results of timer and reminder callbacks look like this in our SEQ logs.
Reminder (which is valid ticks every 5 mins as per registration above) : 
![image](https://user-images.githubusercontent.com/720822/45402627-ec915880-b699-11e8-96cc-ddc474c1bff2.png)

And timer ( should tick once every 3 minutes):
![image](https://user-images.githubusercontent.com/720822/45402680-26faf580-b69a-11e8-90e4-bdae87619ff7.png)

And the question is - what happens with timer ? It has some crazy random invocation pattern.
Grain is not marked as `[StatelessWorker]` so I would assume there is only 1 grain activation in the cluster. Previously we had bug when api endpoint was calling grain with random Guid and that registered plenty of reminders. We fixed it now it uses Guid.Empty as grain id and cleaned up reminders from system table. But timers are stateless and looks like there is something wrong either in Timers or in our code. And I can't understand what's and where.</Description>
    <Title_Description>Strange timers behaviour in Orleans 1.5.4 We just spotted some strange timers behaviour in our system. 
We have a healthGrain which performs some basic operations in cluster.
Invocation of that grain is in our `/api/health` endpoint and we are using it to do some regular "checking" of the entire system. It's nowhere near a comprehensive health check in a cluster but it allows us to ensure that the following is true:
1. API client can address and reach grain in silo
2. That grain can invoke other grain
3. Message to stream is passable + 
4. Timer in arbitrary grain is up and running - I would assume all other timers are working too.
5. Internally that grain being invoked on reminder every 1-5 minutes - thus I would assume all other reminders are working.

Not a rocket science and the entire implementation looks like this:
```
public class HealthCheckGrain : BaseProxyGrain IHealthCheckGrain IRemindable
	{
		private string _context = nameof(HealthCheckGrain);
		
		private readonly IGrainLogger _logger;
		private readonly IGrainFactory _grainFactory;
		private readonly IReminderRegistry _reminders;
		private readonly ITimerRegistry _timers;
		private readonly IStreamProviderManager _streamProvManager;

		private IDisposable _maintenanceJobTimer;

		public HealthCheckGrain(IGrainLogger logger IGrainFactory grainFactory IReminderRegistry reminders ITimerRegistry timers IStreamProviderManager streamProvManager)
		{
			// DI is working in proxy grains
			_logger = logger;
			_grainFactory = grainFactory;
			_reminders = reminders;
			_timers = timers;
			_streamProvManager = streamProvManager;
		}


		public override async Task OnActivateAsync()
		{
			// New way to register timers with DI
			_maintenanceJobTimer = _timers.RegisterTimer(this timerCallback null TimeSpan.FromMinutes(1) TimeSpan.FromMinutes(3));
			// New way to register Reminders with DI
			var grainReminder = await _reminders.RegisterOrUpdateReminder(_context TimeSpan.FromMinutes(1) TimeSpan.FromMinutes(5));

			await base.OnActivateAsync();
		}

		public override Task OnDeactivateAsync()
		{
			return base.OnDeactivateAsync();
		}

		/// &lt;summary&gt; Returns health response &lt;/summary&gt;
		/// &lt;returns&gt; &lt;/returns&gt;
		public async Task&lt;string&gt; CheckHealth()
		{
			
			var hello = _grainFactory.GetGrain&lt;IHello&gt;(0);
			var helloResult = await hello.SayHello($"HealthCheck @ {DateTimeOffset.UtcNow:O}");
			
			var prov = _streamProvManager.GetStreamProvider(StreamNames.StronglyTypedCoreEvents_Provider);
			await prov.GetStream&lt;CoreEvent&gt;(Guid.NewGuid() nameof(HealthCheckStreamEvt)).OnNextAsync(new HealthCheckStreamEvt {Msg = "Hey hey stream is reachable WITH Injection"});
			
			await raise(new HealthCheckStreamEvt {Msg = "Hey hey stream is reachable"});

			return $"Hi I'm a healthy grain! Stream is reachable. Response from Stateful grain: {helloResult}";
		}


		private async Task timerCallback(object grainState)
		{
			_logger.LogInfo("Working timer in 1.5.4" _context);

			await Task.CompletedTask;
		}

		public async Task ReceiveReminder(string reminderName TickStatus status)
		{
			_logger.LogInfo($"Working reminder {reminderName} in 1.5.4" _context);
			await Task.CompletedTask;
		}
	}
```
Results of timer and reminder callbacks look like this in our SEQ logs.
Reminder (which is valid ticks every 5 mins as per registration above) : 
![image](https://user-images.githubusercontent.com/720822/45402627-ec915880-b699-11e8-96cc-ddc474c1bff2.png)

And timer ( should tick once every 3 minutes):
![image](https://user-images.githubusercontent.com/720822/45402680-26faf580-b69a-11e8-90e4-bdae87619ff7.png)

And the question is - what happens with timer ? It has some crazy random invocation pattern.
Grain is not marked as `[StatelessWorker]` so I would assume there is only 1 grain activation in the cluster. Previously we had bug when api endpoint was calling grain with random Guid and that registered plenty of reminders. We fixed it now it uses Guid.Empty as grain id and cleaned up reminders from system table. But timers are stateless and looks like there is something wrong either in Timers or in our code. And I can't understand what's and where.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4968</IssueLabelID>
    <Title>More fixed to TOC</Title>
    <Description>Added commit operation to pre store actions.
This still doesn't work correctly with batching in all cases but does not violate non-toc transaction semantics.  TOC is still not production ready.</Description>
    <Title_Description>More fixed to TOC Added commit operation to pre store actions.
This still doesn't work correctly with batching in all cases but does not violate non-toc transaction semantics.  TOC is still not production ready.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4966</IssueLabelID>
    <Title>Argument Null Exception on 1.5 Cluster Startup</Title>
    <Description>I've been testing our stuff on a localhost primary silo setup for a while now and finally moved to getting onto a cluster setup. But I can't get even one silo started. I keep getting this error on startup:

![image](https://user-images.githubusercontent.com/4165786/45377348-504b5100-b5c8-11e8-9c62-812c4292548c.png)

I figure I must be missing something in the config but I can figure out what. 

Here's my startup code:

```
var dataConnString = Config.ConnectionString("Orleans");
var config = new ClusterConfiguration();			

//	Globals
config.Globals.DataConnectionString = dataConnString;
config.Globals.RegisterStorageProvider&lt;Orleans.StorageProviders.SimpleSQLServerStorage.SimpleSQLServerStorage&gt;("sqlKeyValueStorage"
	new Dictionary&lt;string string&gt;
	{
			{ "DataConnectionString" dataConnString }
			{ "ProviderName" "System.Data.SqlClient" }
			{ "UseJsonFormat" "both" }
	});

config.Globals.RegisterStorageProvider&lt;Orleans.StorageProviders.SimpleSQLServerStorage.SimpleSQLServerStorage&gt;("PubSubStore"
	new Dictionary&lt;string string&gt;
	{
			{ "DataConnectionString" dataConnString }
			{ "ProviderName" "System.Data.SqlClient" }
			{ "UseJsonFormat" "both" }
	});

config.Globals.RegisterStreamProvider&lt;SimpleMessageStreamProvider&gt;("SmsProvider"
	new Dictionary&lt;string string&gt;
	{
		{ "DataConnectionString" dataConnString }
		{ "ProviderName" "System.Data.SqlClient" }
		{ "FireAndForgetDelivery" "True" }
	});

config.Globals.ClusterId = Config.AppSetting("ClusterId");
config.Globals.ServiceId = Guid.Parse(Config.AppSetting("ServiceId"));
config.Globals.LivenessEnabled = true;
config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.SqlServer;
config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.SqlServer;
//config.Globals.type
config.Globals.AdoInvariant = "System.Data.SqlClient";
config.Globals.DeploymentId = "LocalHost";

//	Scheduler
config.Defaults.TurnWarningLengthThreshold = TimeSpan.FromSeconds(1);

//	Networking
config.Defaults.HostNameOrIPAddress = "127.0.0.1";
config.Defaults.Port = int.Parse(Config.AppSetting("SiloPort"));
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Loopback int.Parse(Config.AppSetting("GatewayPort")));

//	Tracing
config.Defaults.DefaultTraceLevel = Severity.Warning;
config.Defaults.TraceToConsole = true;
config.Defaults.BulkMessageLimit = 1000;
config.Defaults.TraceLevelOverrides.Add(Tuple.Create("Grain" Severity.Info));
config.Defaults.TraceLevelOverrides.Add(Tuple.Create("Runtime" Severity.Warning));

config.Globals.UseGlobalSingleInstanceByDefault = true;

var siloHost = new SiloHost(Dns.GetHostName() config);

siloHost.SetSiloType(Silo.SiloType.None);

siloHost.InitializeOrleansSilo();

var started = siloHost.StartOrleansSilo();

if (!started)
	throw new SystemException(String.Format("Failed to start Orleans silo '{0}' as a {1} node" siloHost.Name siloHost.Type));

Console.WriteLine("Orleans Silo is running.\nPress Enter to terminate...");
Console.ReadLine();


siloHost.ShutdownOrleansSilo();
siloHost.Dispose();
GC.SuppressFinalize(siloHost);
Console.WriteLine($"Orleans silo '{siloHost.Name}' shutdown.");
siloHost = null;
```</Description>
    <Title_Description>Argument Null Exception on 1.5 Cluster Startup I've been testing our stuff on a localhost primary silo setup for a while now and finally moved to getting onto a cluster setup. But I can't get even one silo started. I keep getting this error on startup:

![image](https://user-images.githubusercontent.com/4165786/45377348-504b5100-b5c8-11e8-9c62-812c4292548c.png)

I figure I must be missing something in the config but I can figure out what. 

Here's my startup code:

```
var dataConnString = Config.ConnectionString("Orleans");
var config = new ClusterConfiguration();			

//	Globals
config.Globals.DataConnectionString = dataConnString;
config.Globals.RegisterStorageProvider&lt;Orleans.StorageProviders.SimpleSQLServerStorage.SimpleSQLServerStorage&gt;("sqlKeyValueStorage"
	new Dictionary&lt;string string&gt;
	{
			{ "DataConnectionString" dataConnString }
			{ "ProviderName" "System.Data.SqlClient" }
			{ "UseJsonFormat" "both" }
	});

config.Globals.RegisterStorageProvider&lt;Orleans.StorageProviders.SimpleSQLServerStorage.SimpleSQLServerStorage&gt;("PubSubStore"
	new Dictionary&lt;string string&gt;
	{
			{ "DataConnectionString" dataConnString }
			{ "ProviderName" "System.Data.SqlClient" }
			{ "UseJsonFormat" "both" }
	});

config.Globals.RegisterStreamProvider&lt;SimpleMessageStreamProvider&gt;("SmsProvider"
	new Dictionary&lt;string string&gt;
	{
		{ "DataConnectionString" dataConnString }
		{ "ProviderName" "System.Data.SqlClient" }
		{ "FireAndForgetDelivery" "True" }
	});

config.Globals.ClusterId = Config.AppSetting("ClusterId");
config.Globals.ServiceId = Guid.Parse(Config.AppSetting("ServiceId"));
config.Globals.LivenessEnabled = true;
config.Globals.LivenessType = GlobalConfiguration.LivenessProviderType.SqlServer;
config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.SqlServer;
//config.Globals.type
config.Globals.AdoInvariant = "System.Data.SqlClient";
config.Globals.DeploymentId = "LocalHost";

//	Scheduler
config.Defaults.TurnWarningLengthThreshold = TimeSpan.FromSeconds(1);

//	Networking
config.Defaults.HostNameOrIPAddress = "127.0.0.1";
config.Defaults.Port = int.Parse(Config.AppSetting("SiloPort"));
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Loopback int.Parse(Config.AppSetting("GatewayPort")));

//	Tracing
config.Defaults.DefaultTraceLevel = Severity.Warning;
config.Defaults.TraceToConsole = true;
config.Defaults.BulkMessageLimit = 1000;
config.Defaults.TraceLevelOverrides.Add(Tuple.Create("Grain" Severity.Info));
config.Defaults.TraceLevelOverrides.Add(Tuple.Create("Runtime" Severity.Warning));

config.Globals.UseGlobalSingleInstanceByDefault = true;

var siloHost = new SiloHost(Dns.GetHostName() config);

siloHost.SetSiloType(Silo.SiloType.None);

siloHost.InitializeOrleansSilo();

var started = siloHost.StartOrleansSilo();

if (!started)
	throw new SystemException(String.Format("Failed to start Orleans silo '{0}' as a {1} node" siloHost.Name siloHost.Type));

Console.WriteLine("Orleans Silo is running.\nPress Enter to terminate...");
Console.ReadLine();


siloHost.ShutdownOrleansSilo();
siloHost.Dispose();
GC.SuppressFinalize(siloHost);
Console.WriteLine($"Orleans silo '{siloHost.Name}' shutdown.");
siloHost = null;
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4965</IssueLabelID>
    <Title>ArgumentNullException thrown when stopping the silo</Title>
    <Description>When the silo is starting to shut down gracefully at some point strange exceptions has been thrown.
The most important ones:
```
Runtime.Messaging.IncomingMessageAgent/Ping[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Ping encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```
and
```
Runtime.Messaging.IncomingMessageAgent/Application[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```
and
```
Runtime.Messaging.IncomingMessageAgent/System[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/System encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```

Less important
```
Orleans.Runtime.Silo[100325]
      Ignoring System.ObjectDisposedException exception thrown from an action called by Silo.Stop.
System.ObjectDisposedException: Cannot access a disposed object.
Object name: 'IServiceProvider'.
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ThrowHelper.ThrowObjectDisposedException()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance[T](IServiceProvider provider Object[] parameters)
   at Orleans.Runtime.AsynchAgent.EnsureExecutorInitialized()
   at Orleans.Runtime.AsynchAgent.Start()
   at Orleans.Runtime.Messaging.OutboundMessageQueue.&lt;&gt;c__DisplayClass9_1.&lt;.ctor&gt;b__0()
   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)
   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication Boolean useDefaultConstructor)
   at System.Lazy`1.CreateValue()
   at Orleans.Runtime.Messaging.OutboundMessageQueue.Dispose()
   at Orleans.Runtime.Messaging.MessageCenter.Dispose()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.Dispose()
   at Orleans.Runtime.Utils.SafeExecute(Action action ILogger logger Func`1 callerGetter)
```
the silo is deployed to the Kubernetus v1.10.6-gke.2 with 3 replicas as a StatefulSet using AdoNet clustering provider
Orleans v2.1.0-beta1
dotnet sdk v2.1.401
dotnet runtime v2.1.3

Looks like there is something bad happened in the corefx blocking collection.
Regarding ObjectDisposedException it really minor but a bit annoying because why the silo is trying to dispose the service provider again?
Does anyone know anything about this?
</Description>
    <Title_Description>ArgumentNullException thrown when stopping the silo When the silo is starting to shut down gracefully at some point strange exceptions has been thrown.
The most important ones:
```
Runtime.Messaging.IncomingMessageAgent/Ping[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Ping encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```
and
```
Runtime.Messaging.IncomingMessageAgent/Application[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```
and
```
Runtime.Messaging.IncomingMessageAgent/System[100026]
      Asynch agent Runtime.Messaging.IncomingMessageAgent/System encountered unexpected exception The Stage will be restarted.
System.ArgumentNullException: Value cannot be null.
   at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)
```

Less important
```
Orleans.Runtime.Silo[100325]
      Ignoring System.ObjectDisposedException exception thrown from an action called by Silo.Stop.
System.ObjectDisposedException: Cannot access a disposed object.
Object name: 'IServiceProvider'.
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ThrowHelper.ThrowObjectDisposedException()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance[T](IServiceProvider provider Object[] parameters)
   at Orleans.Runtime.AsynchAgent.EnsureExecutorInitialized()
   at Orleans.Runtime.AsynchAgent.Start()
   at Orleans.Runtime.Messaging.OutboundMessageQueue.&lt;&gt;c__DisplayClass9_1.&lt;.ctor&gt;b__0()
   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)
   at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication Boolean useDefaultConstructor)
   at System.Lazy`1.CreateValue()
   at Orleans.Runtime.Messaging.OutboundMessageQueue.Dispose()
   at Orleans.Runtime.Messaging.MessageCenter.Dispose()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.Dispose()
   at Orleans.Runtime.Utils.SafeExecute(Action action ILogger logger Func`1 callerGetter)
```
the silo is deployed to the Kubernetus v1.10.6-gke.2 with 3 replicas as a StatefulSet using AdoNet clustering provider
Orleans v2.1.0-beta1
dotnet sdk v2.1.401
dotnet runtime v2.1.3

Looks like there is something bad happened in the corefx blocking collection.
Regarding ObjectDisposedException it really minor but a bit annoying because why the silo is trying to dispose the service provider again?
Does anyone know anything about this?
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4964</IssueLabelID>
    <Title>Troubleshooting help not available</Title>
    <Description>In orleans/src/Orleans.Core/Runtime/Constants.cs the link
https://aka.ms/orleans-troubleshooting
is referenced which shows up for an error in our deployed version. It doesn't lead to any page though. Please correct the link.

Thanks!</Description>
    <Title_Description>Troubleshooting help not available In orleans/src/Orleans.Core/Runtime/Constants.cs the link
https://aka.ms/orleans-troubleshooting
is referenced which shows up for an error in our deployed version. It doesn't lead to any page though. Please correct the link.

Thanks!</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4963</IssueLabelID>
    <Title>Code generation fails when running dotnet build without --no-restore flag</Title>
    <Description>Possibly the same problem as #4877 (so the --no-restore flag might be a possible workaround there)
Using version 2.1.0-beta1 on Windows. 
Building the project from Visual Studio also works fine.
Let me know if you need more information to reproduce

The error I get is : 
`root\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.1.0-beta1\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(625): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly root\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.1.0-beta1\build\..\tasks\netcoreapp2.1\Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask`</Description>
    <Title_Description>Code generation fails when running dotnet build without --no-restore flag Possibly the same problem as #4877 (so the --no-restore flag might be a possible workaround there)
Using version 2.1.0-beta1 on Windows. 
Building the project from Visual Studio also works fine.
Let me know if you need more information to reproduce

The error I get is : 
`root\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.1.0-beta1\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(625): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly root\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.1.0-beta1\build\..\tasks\netcoreapp2.1\Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4962</IssueLabelID>
    <Title>SQL Schema files should be mentioned in the documentation</Title>
    <Description>The files are available in the [repo](https://github.com/dotnet/orleans/tree/master/src/AdoNet/Orleans.Clustering.AdoNet) but are not referenced in the 2.0 documentation. They are referenced in the [1.5 documentation](https://dotnet.github.io/orleans/1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html). 

Perhaps these pages are a good candidate to mention how to setup cluster membership table:
* https://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/server_configuration.html
* https://dotnet.github.io/orleans/Documentation/deployment/cluster_management.html

Other persistence specifics (i.e. how to setup Azure Table Storage Consul etc.) should be documented as well.</Description>
    <Title_Description>SQL Schema files should be mentioned in the documentation The files are available in the [repo](https://github.com/dotnet/orleans/tree/master/src/AdoNet/Orleans.Clustering.AdoNet) but are not referenced in the 2.0 documentation. They are referenced in the [1.5 documentation](https://dotnet.github.io/orleans/1.5/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-SQL-Tables.html). 

Perhaps these pages are a good candidate to mention how to setup cluster membership table:
* https://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/server_configuration.html
* https://dotnet.github.io/orleans/Documentation/deployment/cluster_management.html

Other persistence specifics (i.e. how to setup Azure Table Storage Consul etc.) should be documented as well.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>11/09/2018 6:42:11 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4961</IssueLabelID>
    <Title>Fix azure streaming tests</Title>
    <Description>some azure streaming tests failed due to diff introduced to WaitUntilAsync in pr #4923 . It is not necessarily the changes in WaitUtilAcync is wrong is how those tests uses it is slightly wrong IMO. For a quick fix let's revert WaitUtilAsync's behavior to its original when `delayOnFail` is not set. @jason-bragg let me know if this affects the tx recovery fix you put in #4923 . 


The azure steaming tests failed due to that timing become hasher after WaitUtilAsync change. Before the pr WaitUtilAsync would be waiting 1 sec regardless but after the pr it won't if predicate succeed. For tests such as `StreamingTests_Consumer_Producer_UnSubscribe` the test use WaitUtilAsync to ensure producer produced. After the pr producer would produce far less leaving little time for consumer to react before being checked. The time of a message sent from producer to consumer is short but apparently not that short ;) </Description>
    <Title_Description>Fix azure streaming tests some azure streaming tests failed due to diff introduced to WaitUntilAsync in pr #4923 . It is not necessarily the changes in WaitUtilAcync is wrong is how those tests uses it is slightly wrong IMO. For a quick fix let's revert WaitUtilAsync's behavior to its original when `delayOnFail` is not set. @jason-bragg let me know if this affects the tx recovery fix you put in #4923 . 


The azure steaming tests failed due to that timing become hasher after WaitUtilAsync change. Before the pr WaitUtilAsync would be waiting 1 sec regardless but after the pr it won't if predicate succeed. For tests such as `StreamingTests_Consumer_Producer_UnSubscribe` the test use WaitUtilAsync to ensure producer produced. After the pr producer would produce far less leaving little time for consumer to react before being checked. The time of a message sent from producer to consumer is short but apparently not that short ;) </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4960</IssueLabelID>
    <Title>Question about 2.0 ChatRoom example</Title>
    <Description>How can the Channel grain detect when a user disconnects/closes the Client app in order to remove them from the onlineMembers list?

I know the client can leave the channel but I wanted to know of a more reliable way to detect this since if a client just closes the app without leaving the channel the user remains in the onlineMembers list indefinitely.</Description>
    <Title_Description>Question about 2.0 ChatRoom example How can the Channel grain detect when a user disconnects/closes the Client app in order to remove them from the onlineMembers list?

I know the client can leave the channel but I wanted to know of a more reliable way to detect this since if a client just closes the app without leaving the channel the user remains in the onlineMembers list indefinitely.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4958</IssueLabelID>
    <Title>Multiclustering using Oracle</Title>
    <Description>Just wanted to know whether the oracle implementation for gossip channel is complete and ready to use?

I was referring to the class MultiClusterOracle.cs</Description>
    <Title_Description>Multiclustering using Oracle Just wanted to know whether the oracle implementation for gossip channel is complete and ready to use?

I was referring to the class MultiClusterOracle.cs</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4957</IssueLabelID>
    <Title>Standardize naming create content for resources/index.md and make m…</Title>
    <Description>…inor grammatical changes.

</Description>
    <Title_Description>Standardize naming, create content for resources/index.md, and make m… …inor grammatical changes.

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>10/09/2018 2:08:00 PM +00:00</CreatedAt>
    <ClosedAt>21/09/2018 4:09:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4956</IssueLabelID>
    <Title>Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0</Title>
    <Description>Orleans version: 2.1.0-beta1

SDK: .NET Core 2.1.401

Tragetframework: netstandard2.0

Detail:  Works findif I switch targetframework to netcoreapp2.1.

ErrorMessage:
 Orleans-CodeGen - Generating file C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core Version=1.1.5.0 Culture=neutral PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core Version=1.1.5.0 Culture=neutral PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  Orleans-CodeGen - Generated file written C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs</Description>
    <Title_Description>Could not load file or assembly 'System.Threading.Tasks.Extensions, Version=4.2.0.0 Orleans version: 2.1.0-beta1

SDK: .NET Core 2.1.401

Tragetframework: netstandard2.0

Detail:  Works findif I switch targetframework to netcoreapp2.1.

ErrorMessage:
 Orleans-CodeGen - Generating file C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core Version=1.1.5.0 Culture=neutral PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
        Exception loading types from assembly 'Ray.Core Version=1.1.5.0 Culture=neutral PublicKeyToken=null':
        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。
        Exc level 1: System.IO.FileNotFoundException: Could not load file or assembly 'System.Threading.Tasks.Extensions Version=4.2.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. 系统找不到指定的文件。.
  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\25\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
  Orleans-CodeGen - Generated file written C:\Users\Jz.Fan\Source\Repos\Ray\Ray.Core\obj\Debug\netstandard2.0\Ray.Core.orleans.g.cs</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4955</IssueLabelID>
    <Title>Documentation on handling failures</Title>
    <Description>A question came up on Gitter that highlights many of the topics on the following page are only discussed in the 1.5 Tutorials section:

http://dotnet.github.io/orleans/1.5/Tutorials/Failure-Handling.html

Finding this information in the 1.5 Tutorials section may not be intuitive to new users and I think it would be great to see this migrated to the new Documentation navigation tree.</Description>
    <Title_Description>Documentation on handling failures A question came up on Gitter that highlights many of the topics on the following page are only discussed in the 1.5 Tutorials section:

http://dotnet.github.io/orleans/1.5/Tutorials/Failure-Handling.html

Finding this information in the 1.5 Tutorials section may not be intuitive to new users and I think it would be great to see this migrated to the new Documentation navigation tree.</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4954</IssueLabelID>
    <Title>Add Microsoft.Orleans.Streaming.AzureStorage as a dependency to AzureUtils</Title>
    <Description>Fixes #4800.

Add `Microsoft.Orleans.Streaming.AzureStorage` as a dependency to `Microsoft.Orleans.OrleansAzureUtils`.</Description>
    <Title_Description>Add Microsoft.Orleans.Streaming.AzureStorage as a dependency to AzureUtils Fixes #4800.

Add `Microsoft.Orleans.Streaming.AzureStorage` as a dependency to `Microsoft.Orleans.OrleansAzureUtils`.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4953</IssueLabelID>
    <Title>Minor revisions to transaction tracing</Title>
    <Description>This is a minor refactoring to give us better information when reading traces of failed tests.</Description>
    <Title_Description>Minor revisions to transaction tracing This is a minor refactoring to give us better information when reading traces of failed tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4951</IssueLabelID>
    <Title>Clear transaction context on error</Title>
    <Description>
    </Description>
    <Title_Description>Clear transaction context on error </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4950</IssueLabelID>
    <Title>Fixed TransactionFaultInjectionTests</Title>
    <Description>- Addressed transaction recovery issues.
- Fixed minor test issues.
- Still not added to functional because they take too long to run.  Need to fix the abort issue then we can remove delays and to functional</Description>
    <Title_Description>Fixed TransactionFaultInjectionTests - Addressed transaction recovery issues.
- Fixed minor test issues.
- Still not added to functional because they take too long to run.  Need to fix the abort issue then we can remove delays and to functional</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4949</IssueLabelID>
    <Title>TOC aborts under service failure</Title>
    <Description>Fixed TOC aborts under service failure
Added minimal failure testing for TOC.</Description>
    <Title_Description>TOC aborts under service failure Fixed TOC aborts under service failure
Added minimal failure testing for TOC.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4947</IssueLabelID>
    <Title>Transaction Scope in Grains</Title>
    <Description>Is there a sample implementation or example for transaction scope across multiple grains? The main objective is too commit and rollback database transactions.</Description>
    <Title_Description>Transaction Scope in Grains Is there a sample implementation or example for transaction scope across multiple grains? The main objective is too commit and rollback database transactions.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4945</IssueLabelID>
    <Title>IsOrleansShallowCopyable fixes</Title>
    <Description>- `Guid` is shallow copyable and primitive.
- `Nullable&lt;T&gt;` is shallow copyable if the wrapped type is shallow copyable.
- `Tuple&lt;T...&gt;` is shallow copyable if all the element types are shallow copyable.
- Value types are shallow copyable if all public and private instance fields are shallow copyable.
Previously private fields were ignored and public static fields were checked instead and generic types were not allowed.
- Changed the static constructor to a field initializer for better performance (static constructors enforce precise initialization timing which can be expensive).</Description>
    <Title_Description>IsOrleansShallowCopyable fixes - `Guid` is shallow copyable and primitive.
- `Nullable&lt;T&gt;` is shallow copyable if the wrapped type is shallow copyable.
- `Tuple&lt;T...&gt;` is shallow copyable if all the element types are shallow copyable.
- Value types are shallow copyable if all public and private instance fields are shallow copyable.
Previously private fields were ignored and public static fields were checked instead and generic types were not allowed.
- Changed the static constructor to a field initializer for better performance (static constructors enforce precise initialization timing which can be expensive).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4943</IssueLabelID>
    <Title>Port of #3843 and #3851</Title>
    <Description>Port of #3843 and #3851 PRs from master to 1.5.5.</Description>
    <Title_Description>Port of #3843 and #3851 Port of #3843 and #3851 PRs from master to 1.5.5.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4942</IssueLabelID>
    <Title>Consul clustering enhancements</Title>
    <Description>Following changes have been included in this PR.

1. Consul ACL integration.
2. Creating the cluster folder under a specific folder at the root of KV store.

Consul ACL integration
************************
The current orleans clustering consul package is not having an import feature i.e ACL integration which is a security features of Consul that restricts unauthorized access on the cluster KV folder. 


Sample code


 var client = new ClientBuilder().Configure&lt;ClusterOptions&gt;(options =&gt;
            {
                options.ClusterId = ConfigurationManager.AppSettings["ClusterId"];
                options.ServiceId = ConfigurationManager.AppSettings["ServiceId"];
            })
                .UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    gatewayOptions.AclClientToken = ConfigurationManager.AppSettings["ServiceDiscoveryToken"];
                    gatewayOptions.KvRootFolder = ConfigurationManager.AppSettings["KvFolderName"];

                })
                .ConfigureApplicationParts(parts =&gt;
                    parts.AddApplicationPart(typeof(ICustomerRule).Assembly).WithReferences())
                .Build();


            await client.Connect();
            return client;

Creating the cluster folder under a specific folder at the root of KV store.
****************************************************************************

When we have multiple projects using the orleans framework then all the cluster folder gets created at the root level of the KV store to organize it in a better way I've added an ability to configure the folder name where the cluster folder should be created.

.UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    gatewayOptions.AclClientToken = ConfigurationManager.AppSettings["ServiceDiscoveryToken"];
                    gatewayOptions.KvRootFolder = ConfigurationManager.AppSettings["KvFolderName"];

                })

 </Description>
    <Title_Description>Consul clustering enhancements Following changes have been included in this PR.

1. Consul ACL integration.
2. Creating the cluster folder under a specific folder at the root of KV store.

Consul ACL integration
************************
The current orleans clustering consul package is not having an import feature i.e ACL integration which is a security features of Consul that restricts unauthorized access on the cluster KV folder. 


Sample code


 var client = new ClientBuilder().Configure&lt;ClusterOptions&gt;(options =&gt;
            {
                options.ClusterId = ConfigurationManager.AppSettings["ClusterId"];
                options.ServiceId = ConfigurationManager.AppSettings["ServiceId"];
            })
                .UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    gatewayOptions.AclClientToken = ConfigurationManager.AppSettings["ServiceDiscoveryToken"];
                    gatewayOptions.KvRootFolder = ConfigurationManager.AppSettings["KvFolderName"];

                })
                .ConfigureApplicationParts(parts =&gt;
                    parts.AddApplicationPart(typeof(ICustomerRule).Assembly).WithReferences())
                .Build();


            await client.Connect();
            return client;

Creating the cluster folder under a specific folder at the root of KV store.
****************************************************************************

When we have multiple projects using the orleans framework then all the cluster folder gets created at the root level of the KV store to organize it in a better way I've added an ability to configure the folder name where the cluster folder should be created.

.UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    gatewayOptions.AclClientToken = ConfigurationManager.AppSettings["ServiceDiscoveryToken"];
                    gatewayOptions.KvRootFolder = ConfigurationManager.AppSettings["KvFolderName"];

                })

 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4939</IssueLabelID>
    <Title>Orleans silos crashing 'Process is terminating due to StackOverflowException.'</Title>
    <Description>We have recently put an orleans service into production to manage the login session lifecycle of our application. This is running Orleans 2.0.4 and .net core 2.0 hosted in Kubernetes using Linux docker containers built using the microsoft/aspnetcore:2.0 image.

We are using Azure Storage for clustering and state based persistence..

Occasionally at first and with increased frequency we are seeing the silo host containers crash out due to a Stack Over Flow.

We believe this is somehow related to the use of 'reminders' because with a clean state for around the first 40 minutes there are no crashes but gradually over a number of days crashes and restarts happen more and more frequently until it is impossible to keep the cluster up and running in a health state.

While we are not ruling out our specific application code as the cause (accept this is the most likely) we can find no instances of recursive function calls have experimented with removal and refactoring of several areas of the code and have so far been unsuccessful in resolving this.

This doesn't happen on our internal development and testing clusters but that isn't under load in the same way.

Are there any known issues / potential configurations with Orleans 2.x that are known to cause this? What information do I need to collect / how can i go about diagnosing this?</Description>
    <Title_Description>Orleans silos crashing 'Process is terminating due to StackOverflowException.' We have recently put an orleans service into production to manage the login session lifecycle of our application. This is running Orleans 2.0.4 and .net core 2.0 hosted in Kubernetes using Linux docker containers built using the microsoft/aspnetcore:2.0 image.

We are using Azure Storage for clustering and state based persistence..

Occasionally at first and with increased frequency we are seeing the silo host containers crash out due to a Stack Over Flow.

We believe this is somehow related to the use of 'reminders' because with a clean state for around the first 40 minutes there are no crashes but gradually over a number of days crashes and restarts happen more and more frequently until it is impossible to keep the cluster up and running in a health state.

While we are not ruling out our specific application code as the cause (accept this is the most likely) we can find no instances of recursive function calls have experimented with removal and refactoring of several areas of the code and have so far been unsuccessful in resolving this.

This doesn't happen on our internal development and testing clusters but that isn't under load in the same way.

Are there any known issues / potential configurations with Orleans 2.x that are known to cause this? What information do I need to collect / how can i go about diagnosing this?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4938</IssueLabelID>
    <Title>Orleans.Transactions.ITransactionManagerGrain. Make sure the grain assembly was correctly deployed and loaded in the silo</Title>
    <Description>i use orleans.transactions v2.04 nuget when i silobulider add UseInClusterTransactionManager() it run errorif i delete it it will run ok.
![image](https://user-images.githubusercontent.com/26404526/45068227-06122d80-b0f9-11e8-94f7-c52fe1c02d70.png)
</Description>
    <Title_Description>Orleans.Transactions.ITransactionManagerGrain. Make sure the grain assembly was correctly deployed and loaded in the silo i use orleans.transactions v2.04 nuget when i silobulider add UseInClusterTransactionManager() it run errorif i delete it it will run ok.
![image](https://user-images.githubusercontent.com/26404526/45068227-06122d80-b0f9-11e8-94f7-c52fe1c02d70.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4936</IssueLabelID>
    <Title>#4935 Fixing race condition with simple queue cache</Title>
    <Description>Related to #4935 
- Cursor was allowed to be in a state dependent on a token
  while allowing the containing bucket to be purged</Description>
    <Title_Description>#4935 Fixing race condition with simple queue cache Related to #4935 
- Cursor was allowed to be in a state dependent on a token
  while allowing the containing bucket to be purged</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4935</IssueLabelID>
    <Title>Race condition with SimpleQueueCache allows for broken cursor</Title>
    <Description>See https://gitter.im/dotnet/orleans?at=5b8ed56958a3797aa301e47e:

Essentially a cursor being spun up with an empty sequence token was set to the first available token but not tracked. This allows for periodic purging to purge the item with the token causing the cursor to report a cache miss forever.

The fix is pretty simple and supplied by @jason-bragg. I'll throw a PR up shortly.</Description>
    <Title_Description>Race condition with SimpleQueueCache allows for broken cursor See https://gitter.im/dotnet/orleans?at=5b8ed56958a3797aa301e47e:

Essentially a cursor being spun up with an empty sequence token was set to the first available token but not tracked. This allows for periodic purging to purge the item with the token causing the cursor to report a cache miss forever.

The fix is pretty simple and supplied by @jason-bragg. I'll throw a PR up shortly.</Title_Description>
    <Label>bug</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4933</IssueLabelID>
    <Title>Remove 'Types of Grains.md" placeholder page insert content from...</Title>
    <Description>…"Actor Identity.md" and replace "actor" with "grain" throughout document.
Also reformat  to Documentation Guidelines and make grammatical changes.

</Description>
    <Title_Description>Remove 'Types of Grains.md" placeholder page, insert content from... …"Actor Identity.md" and replace "actor" with "grain" throughout document.
Also reformat  to Documentation Guidelines and make grammatical changes.

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/09/2018 6:49:32 PM +00:00</CreatedAt>
    <ClosedAt>7/09/2018 10:49:55 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4932</IssueLabelID>
    <Title>Remove 'Who's using Orleans" file from table of contents.</Title>
    <Description>File is not needed.</Description>
    <Title_Description>Remove 'Who's using Orleans" file from table of contents. File is not needed.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/09/2018 6:35:24 PM +00:00</CreatedAt>
    <ClosedAt>6/09/2018 1:58:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4931</IssueLabelID>
    <Title>Rename file from 'Benefits.md' to 'benefits.md' change 'actor' to ...</Title>
    <Description>…'grain' where needed and change grammar and wording.

This combines and replaces two other PRs that had problems.</Description>
    <Title_Description>Rename file from 'Benefits.md' to 'benefits.md', change 'actor' to ... …'grain' where needed and change grammar and wording.

This combines and replaces two other PRs that had problems.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/09/2018 6:29:42 PM +00:00</CreatedAt>
    <ClosedAt>6/09/2018 2:11:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4930</IssueLabelID>
    <Title>Change 'gateways' to 'gatewayPort: 30000'.</Title>
    <Description>
    </Description>
    <Title_Description>Change 'gateways' to 'gatewayPort: 30000'. </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/09/2018 5:57:50 PM +00:00</CreatedAt>
    <ClosedAt>13/09/2018 7:08:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4927</IssueLabelID>
    <Title>Enable fault injection tests</Title>
    <Description>Didn't know confirm would be retried on failure so I didn't reset fault injection control after confirmed once which cause some of the tests failing.


This pr fixes it. </Description>
    <Title_Description>Enable fault injection tests Didn't know confirm would be retried on failure so I didn't reset fault injection control after confirmed once which cause some of the tests failing.


This pr fixes it. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4926</IssueLabelID>
    <Title>Fix fault injection tests and enable them </Title>
    <Description>I didn't know confirm would be retried on storage error so I didn't reset fault injection control after confirmed once which cause some of the tests failing. </Description>
    <Title_Description>Fix fault injection tests and enable them  I didn't know confirm would be retried on storage error so I didn't reset fault injection control after confirmed once which cause some of the tests failing. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4925</IssueLabelID>
    <Title>Rebalance grains to new server on request</Title>
    <Description>Hi

Is there any option to migrate grain with its state to a new silohost?

For now we created our own solution.

1. Monitor number of silohost
2. Monitor number of grains on each silo host
3. When new siloHost join cluster - Call DeactivateOnIdle on grains that are on the busiest server 

Maybe to have an easy implementation for archiving the same solution?

1. Fetch statistics - number of siloHosts number of grain (one type) per siloHost
2. Rebalance grains (Need to be atomic)
    a) Take the state of grain
    b) Deactivate grain on SiloHost 1
    b) Activate grain on SiloHost 2 (do not call onActivate event!)
    c) Load grain state on SiloHost 2

Best

Dean
  </Description>
    <Title_Description>Rebalance grains to new server on request Hi

Is there any option to migrate grain with its state to a new silohost?

For now we created our own solution.

1. Monitor number of silohost
2. Monitor number of grains on each silo host
3. When new siloHost join cluster - Call DeactivateOnIdle on grains that are on the busiest server 

Maybe to have an easy implementation for archiving the same solution?

1. Fetch statistics - number of siloHosts number of grain (one type) per siloHost
2. Rebalance grains (Need to be atomic)
    a) Take the state of grain
    b) Deactivate grain on SiloHost 1
    b) Activate grain on SiloHost 2 (do not call onActivate event!)
    c) Load grain state on SiloHost 2

Best

Dean
  </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4913</IssueLabelID>
    <Title>Add back .editorconfig</Title>
    <Description>This adds back the .editorconfig file from #3872 that was removed by #3963.
I fixed some bugs in the file (removed severity from formatting rules that don't support it) and changed all warnings to suggestions or even to "none" for some rules.
Changed some of the rules to better match the existing codebase but it's not always consistent so suggestions for style changes are welcome.</Description>
    <Title_Description>Add back .editorconfig This adds back the .editorconfig file from #3872 that was removed by #3963.
I fixed some bugs in the file (removed severity from formatting rules that don't support it) and changed all warnings to suggestions or even to "none" for some rules.
Changed some of the rules to better match the existing codebase but it's not always consistent so suggestions for style changes are welcome.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4911</IssueLabelID>
    <Title>Do not try to register GrainVersionStore if an implementation of IVersionStore is already registered</Title>
    <Description>Fix for #4855 </Description>
    <Title_Description>Do not try to register GrainVersionStore if an implementation of IVersionStore is already registered Fix for #4855 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4910</IssueLabelID>
    <Title>Access to declared state type in IGrainStorage</Title>
    <Description>The declared type of the grain state is not accessible via IGrainState.  The runtime type is however you can't determine the actual declared type. This causes problems when the state is of a derived type of the declared type.
e.g. in the IGrainStorage interface the only params you get about the state is IGrainState and if you need the declared type you're out of luck.

There's a hack available though. The implementation type of IGrainState is the internal ```GrainState&lt;&gt;```. so it is possible to extract the state type but it's not pretty.
something like this:
```
Type declaredStateType = grainState.GetType().GenericTypeArguments[0]
```
and hope the grainState runtime type doesn't change.

I can suggest two options:
1 - Add **DeclaredStateType** parameter to IGrainStorage methods.
2 - Add DeclaredStateType to IGrainState. This does make the grain state object bigger and I don't know other places using IGrainState. So if there's no benefit other than this I would stay with the hack or give it a second thought.

</Description>
    <Title_Description>Access to declared state type in IGrainStorage The declared type of the grain state is not accessible via IGrainState.  The runtime type is however you can't determine the actual declared type. This causes problems when the state is of a derived type of the declared type.
e.g. in the IGrainStorage interface the only params you get about the state is IGrainState and if you need the declared type you're out of luck.

There's a hack available though. The implementation type of IGrainState is the internal ```GrainState&lt;&gt;```. so it is possible to extract the state type but it's not pretty.
something like this:
```
Type declaredStateType = grainState.GetType().GenericTypeArguments[0]
```
and hope the grainState runtime type doesn't change.

I can suggest two options:
1 - Add **DeclaredStateType** parameter to IGrainStorage methods.
2 - Add DeclaredStateType to IGrainState. This does make the grain state object bigger and I don't know other places using IGrainState. So if there's no benefit other than this I would stay with the hack or give it a second thought.

</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4908</IssueLabelID>
    <Title>ManagementGrain.ForceActivationCollection with zero ageLimit causes undesired effects</Title>
    <Description>Calling ManagementGrain.ForceActivationCollection(TimeSpan.Zero) collects every grain including system grains and the ManagementGrain itself. Which effectively almost restarts the silo and causes the said grain call to timeout.

Shouldn't this exclude some grains (management grain pubsub etc.)? or at least make the TimeSpan.Zero value an invalid one? 

I can't think of a scenario where current behavior would be useful.
</Description>
    <Title_Description>ManagementGrain.ForceActivationCollection with zero ageLimit causes undesired effects Calling ManagementGrain.ForceActivationCollection(TimeSpan.Zero) collects every grain including system grains and the ManagementGrain itself. Which effectively almost restarts the silo and causes the said grain call to timeout.

Shouldn't this exclude some grains (management grain pubsub etc.)? or at least make the TimeSpan.Zero value an invalid one? 

I can't think of a scenario where current behavior would be useful.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4907</IssueLabelID>
    <Title>Propagate message serialization exceptions to callers</Title>
    <Description>Fixes #4793 

There are 6 scenarios being tested which can be summed up as `{Serialization Deserialization} exception sending to a {client grain} from a {client grain}` except I didn't add tests for the client-to-client cases (they go via silo anyway).

In the end there's similar logic for handling these exceptions in:
* `GatewayConnection.OnMessageSerializationFailure` - client to gateway (request)
* `InvokableObjectManager.LocalObjectMessagePumpAsync` - client to gateway (response)
* `Gateway.GatewaySender.OnMessageSerializationFailure` - gateway to client
* `SiloMessageSender.OnMessageSerializationFailure` - silo to silo

The client-to-gateway response scenarios are a little contrived since client objects are not supposed to be able to return `Task` or `Task&lt;T&gt;` only `void`. The code generator blocks `Task`/`Task&lt;T&gt;` for external users. Nevertheless it's worth adding tests for the scenario just in case and it helped to uncover some issues and places we could improve logging.</Description>
    <Title_Description>Propagate message serialization exceptions to callers Fixes #4793 

There are 6 scenarios being tested which can be summed up as `{Serialization Deserialization} exception sending to a {client grain} from a {client grain}` except I didn't add tests for the client-to-client cases (they go via silo anyway).

In the end there's similar logic for handling these exceptions in:
* `GatewayConnection.OnMessageSerializationFailure` - client to gateway (request)
* `InvokableObjectManager.LocalObjectMessagePumpAsync` - client to gateway (response)
* `Gateway.GatewaySender.OnMessageSerializationFailure` - gateway to client
* `SiloMessageSender.OnMessageSerializationFailure` - silo to silo

The client-to-gateway response scenarios are a little contrived since client objects are not supposed to be able to return `Task` or `Task&lt;T&gt;` only `void`. The code generator blocks `Task`/`Task&lt;T&gt;` for external users. Nevertheless it's worth adding tests for the scenario just in case and it helped to uncover some issues and places we could improve logging.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4906</IssueLabelID>
    <Title>Migrate DynamoDB transaction state provider to new interface</Title>
    <Description>DynamoDB was originally submitted and merge with #4056. It implemented the `ITransactionLogStorage` interface which no longer exists.

The provider project was deleted from the sources when transitioning to the distributed transaction manager (TM) which removed the ITransactionLogStorage.  The project can be reintroduced for a DynamoDB implementation of `ITransactionalStateStorage`.</Description>
    <Title_Description>Migrate DynamoDB transaction state provider to new interface DynamoDB was originally submitted and merge with #4056. It implemented the `ITransactionLogStorage` interface which no longer exists.

The provider project was deleted from the sources when transitioning to the distributed transaction manager (TM) which removed the ITransactionLogStorage.  The project can be reintroduced for a DynamoDB implementation of `ITransactionalStateStorage`.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/08/2018 11:33:27 PM +00:00</CreatedAt>
    <ClosedAt>29/11/2018 10:39:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4905</IssueLabelID>
    <Title>Add 2.1.0-beta1 to changelog</Title>
    <Description>
    </Description>
    <Title_Description>Add 2.1.0-beta1 to changelog </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4904</IssueLabelID>
    <Title>Remove ITransactionFaultInjector from src</Title>
    <Description>- Remove ITransactionFaultInjector from src. Fault are now injected into storage layer through FaultInjectedTransactionStateStorage implementations in test proj. 
- Remove MemoryConsistencyTests since we don't have a fault injection memory state storage for it to use yet. Can be added later. </Description>
    <Title_Description>Remove ITransactionFaultInjector from src - Remove ITransactionFaultInjector from src. Fault are now injected into storage layer through FaultInjectedTransactionStateStorage implementations in test proj. 
- Remove MemoryConsistencyTests since we don't have a fault injection memory state storage for it to use yet. Can be added later. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4901</IssueLabelID>
    <Title>Move actor identity content from 1.5 tutorials to grains section</Title>
    <Description>The content of the 1.5 tutorial "Actor Identity" contains information about grain IDs and no steps to accomplish a task. It should be put with other similar pages.

</Description>
    <Title_Description>Move actor identity content from 1.5 tutorials to grains section The content of the 1.5 tutorial "Actor Identity" contains information about grain IDs and no steps to accomplish a task. It should be put with other similar pages.

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4900</IssueLabelID>
    <Title>API to access the default DeepCopier</Title>
    <Description>There should be a way to access the default copier from an `IExternalSerializer` implementation. That would be useful when only trying to override the serialization/deserialization behavior of a type.
And it should be possible to access the default serialization code when only overriding deep-copying is needed.</Description>
    <Title_Description>API to access the default DeepCopier There should be a way to access the default copier from an `IExternalSerializer` implementation. That would be useful when only trying to override the serialization/deserialization behavior of a type.
And it should be possible to access the default serialization code when only overriding deep-copying is needed.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4896</IssueLabelID>
    <Title>Activation address cache is not invalidated when only [OneWay] calls are used</Title>
    <Description>Scenario:

* Call `[OneWay]` methods on a grain from silo A
  * Activation is hosted on silo B
  * Activation is registered in directory partition on silo C 
* Deactivate that grain (eg by killing silo C) 
* Silo A will never learn that the grain has been destroyed and will keep messaging a non-existent activation (unsuccessfully unbeknownst to caller or calling silo)

</Description>
    <Title_Description>Activation address cache is not invalidated when only [OneWay] calls are used Scenario:

* Call `[OneWay]` methods on a grain from silo A
  * Activation is hosted on silo B
  * Activation is registered in directory partition on silo C 
* Deactivate that grain (eg by killing silo C) 
* Silo A will never learn that the grain has been destroyed and will keep messaging a non-existent activation (unsuccessfully unbeknownst to caller or calling silo)

</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4895</IssueLabelID>
    <Title>Use netcoreapp2.0 for msbuild target dll if using dotnet core msbuild but targeting full .net</Title>
    <Description>(Cherry-pick of #4689)

#4673 introduced a regression: when using the command `dotnet build` to build project that target the full .NET framework the variable for `CoreAssembly` is not set and the variable `TaskAssembly` depends on it.

The easiest workaround here is to always fallback to 2.0 dll

Maybe we could instead removing this task dependency and rely on the fact that we should find the `dotnet` command in the path @ReubenBond ?</Description>
    <Title_Description>Use netcoreapp2.0 for msbuild target dll if using dotnet core msbuild but targeting full .net (Cherry-pick of #4689)

#4673 introduced a regression: when using the command `dotnet build` to build project that target the full .NET framework the variable for `CoreAssembly` is not set and the variable `TaskAssembly` depends on it.

The easiest workaround here is to always fallback to 2.0 dll

Maybe we could instead removing this task dependency and rely on the fact that we should find the `dotnet` command in the path @ReubenBond ?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4894</IssueLabelID>
    <Title>Fixed build breaks from bad merge:</Title>
    <Description> - Constructor mismatches
 - Adde CurrentTransactionId to transaction context</Description>
    <Title_Description>Fixed build breaks from bad merge:  - Constructor mismatches
 - Adde CurrentTransactionId to transaction context</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4893</IssueLabelID>
    <Title>Build time codegen in 2.0.4 not working when using dotnet cli while targeting full .net framework</Title>
    <Description>We need to backport #4689 to fix this issue</Description>
    <Title_Description>Build time codegen in 2.0.4 not working when using dotnet cli while targeting full .net framework We need to backport #4689 to fix this issue</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4892</IssueLabelID>
    <Title>fixes 'placeholder page' issue for Grains section</Title>
    <Description>
    </Description>
    <Title_Description>fixes 'placeholder page' issue for Grains section </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/08/2018 3:12:44 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 11:29:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4891</IssueLabelID>
    <Title>Move actor identity content from 1.5 tutorials to grains section</Title>
    <Description>The 1.5 Tutorial page "Actor Identity" is informational not procedural - it should be included among other informational pages.</Description>
    <Title_Description>Move actor identity content from 1.5 tutorials to grains section The 1.5 Tutorial page "Actor Identity" is informational not procedural - it should be included among other informational pages.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4890</IssueLabelID>
    <Title>Feature per grain collection attribute</Title>
    <Description>
    </Description>
    <Title_Description>Feature per grain collection attribute </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4888</IssueLabelID>
    <Title>Fixes 'clusters and clients' similar to 'grains'</Title>
    <Description>
    </Description>
    <Title_Description>Fixes 'clusters and clients' similar to 'grains' </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4886</IssueLabelID>
    <Title>Moved the "This documentation is for the 2.0 release" section... </Title>
    <Description>… from Orleans Overview to main landing page (to keep content about documentation itself together)
- made some grammar and sentence structure edits
- verified links
</Description>
    <Title_Description>Moved the "This documentation is for the 2.0 release" section...  … from Orleans Overview to main landing page (to keep content about documentation itself together)
- made some grammar and sentence structure edits
- verified links
</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>24/08/2018 5:23:31 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 7:43:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4885</IssueLabelID>
    <Title>What kind of scenario will the SiloName of the two nodes be the same?</Title>
    <Description>When I read the code I saw the following code from `Orleans.Runtime.MembershipService.MembershipOracle`.
```csharp
private async Task DetectNodeMigration(string myHostname)
{
    MembershipTableData table = await membershipTableProvider.ReadAll();

    string mySiloName = SiloName;
    MembershipEntry mostRecentPreviousEntry = null;
    foreach (MembershipEntry entry in table.Members.Select(tuple =&gt; tuple.Item1).Where(data =&gt; mySiloName.Equals(data.SiloName)))
    {
        bool iAmLater = MyAddress.Generation.CompareTo(entry.SiloAddress.Generation) &gt; 0;
        // more recent
        if (iAmLater &amp;&amp; (mostRecentPreviousEntry == null || entry.SiloAddress.Generation.CompareTo(mostRecentPreviousEntry.SiloAddress.Generation) &gt; 0))
            mostRecentPreviousEntry = entry;
    }

    if (mostRecentPreviousEntry != null)
    {
        bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !MyAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);
        if (physicalHostChanged)
        {
            string error = String.Format("Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}."
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.HostName mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeMigrated error);
        }
        else
        {
            string error = String.Format("Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}"
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeRestarted error);
        }
    }
}
```

This code first reads all the columns of the member table then select the entry with the same silo name as the current node.
But according to the code SiloName is generated by GUID.
So how can there be the same SiloName? Or what is the `DetectNodeMigration` method used to handle?</Description>
    <Title_Description>What kind of scenario will the SiloName of the two nodes be the same? When I read the code I saw the following code from `Orleans.Runtime.MembershipService.MembershipOracle`.
```csharp
private async Task DetectNodeMigration(string myHostname)
{
    MembershipTableData table = await membershipTableProvider.ReadAll();

    string mySiloName = SiloName;
    MembershipEntry mostRecentPreviousEntry = null;
    foreach (MembershipEntry entry in table.Members.Select(tuple =&gt; tuple.Item1).Where(data =&gt; mySiloName.Equals(data.SiloName)))
    {
        bool iAmLater = MyAddress.Generation.CompareTo(entry.SiloAddress.Generation) &gt; 0;
        // more recent
        if (iAmLater &amp;&amp; (mostRecentPreviousEntry == null || entry.SiloAddress.Generation.CompareTo(mostRecentPreviousEntry.SiloAddress.Generation) &gt; 0))
            mostRecentPreviousEntry = entry;
    }

    if (mostRecentPreviousEntry != null)
    {
        bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !MyAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);
        if (physicalHostChanged)
        {
            string error = String.Format("Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}."
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.HostName mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeMigrated error);
        }
        else
        {
            string error = String.Format("Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}"
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeRestarted error);
        }
    }
}
```

This code first reads all the columns of the member table then select the entry with the same silo name as the current node.
But according to the code SiloName is generated by GUID.
So how can there be the same SiloName? Or what is the `DetectNodeMigration` method used to handle?</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4884</IssueLabelID>
    <Title>Event Hub checkpoint on shutdown</Title>
    <Description>Checkpoints don't seem to occur on silo shutdown. This results in re-processing events when a silo comes back up.

Maybe `EventHubQueueCache.Dispose() `should call `EventHubQueueCache.UpdateCheckpoint()`?
</Description>
    <Title_Description>Event Hub checkpoint on shutdown Checkpoints don't seem to occur on silo shutdown. This results in re-processing events when a silo comes back up.

Maybe `EventHubQueueCache.Dispose() `should call `EventHubQueueCache.UpdateCheckpoint()`?
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4877</IssueLabelID>
    <Title>Build-time code generation version 2.0.4 breaks docker builds</Title>
    <Description>When upgrading the `Microsoft.Orleans.OrleansCodeGenerator.Build` package to version 2.0.4 docker builds with the `microsoft/dotnet:2.1.401-sdk` base image start to fail with the error message below. Building on the host machine with the exact same commands as in the Dockerfile does not produce the error nor does running the project in an IDE. 

Downgrading to 2.0.3 fixes the issue. I tried to setup a simple project to reproduce but could not reproduce the exact issue so the problem may only appear in a complex solution with 10+ projects in it.

`/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(605): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly /root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/../tasks/netcoreapp2.1/Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask.`</Description>
    <Title_Description>Build-time code generation version 2.0.4 breaks docker builds When upgrading the `Microsoft.Orleans.OrleansCodeGenerator.Build` package to version 2.0.4 docker builds with the `microsoft/dotnet:2.1.401-sdk` base image start to fail with the error message below. Building on the host machine with the exact same commands as in the Dockerfile does not produce the error nor does running the project in an IDE. 

Downgrading to 2.0.3 fixes the issue. I tried to setup a simple project to reproduce but could not reproduce the exact issue so the problem may only appear in a complex solution with 10+ projects in it.

`/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(605): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly /root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/../tasks/netcoreapp2.1/Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask.`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4876</IssueLabelID>
    <Title>Fix DI cycle involving OrleansJsonSerializer</Title>
    <Description>Fixes #4873</Description>
    <Title_Description>Fix DI cycle involving OrleansJsonSerializer Fixes #4873</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4875</IssueLabelID>
    <Title>Revisit silo stop/shutdown timeout</Title>
    <Description>
    </Description>
    <Title_Description>Revisit silo stop/shutdown timeout </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4874</IssueLabelID>
    <Title>Add storage exception injection logic into fault injection test runner</Title>
    <Description>Adding fault injection test case
- inject storage exception before store during Prepare
- inject storage exception after store during Prepare 
- inject storage exception before store during Confirm
- inject storage exception after store during Confirm
- inject storage exception before store during PrepareAndCommit
- inject storage exception after store during PrepareAndCommit

injecting exception before store simulates situation that state update failed to persist
injecting exception after store simulates situation that state update succeed to persist but runtime think it failed

currently all tests failed... I don't think I have a test logic issue. But please give me a second eye. </Description>
    <Title_Description>Add storage exception injection logic into fault injection test runner Adding fault injection test case
- inject storage exception before store during Prepare
- inject storage exception after store during Prepare 
- inject storage exception before store during Confirm
- inject storage exception after store during Confirm
- inject storage exception before store during PrepareAndCommit
- inject storage exception after store during PrepareAndCommit

injecting exception before store simulates situation that state update failed to persist
injecting exception after store simulates situation that state update succeed to persist but runtime think it failed

currently all tests failed... I don't think I have a test logic issue. But please give me a second eye. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4873</IssueLabelID>
    <Title>StackOverflowException when adding OrleansJsonSerializer as a SerializationProvider</Title>
    <Description>Workaround: use this gist instead https://gist.github.com/ReubenBond/45ef767aff071302ee62731b5c706dd7

Repro:
```C#
var client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
var s = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();

var silo = new SiloHostBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
s = silo.Services.GetRequiredService&lt;SerializationManager&gt;();
```

Only the silo fails the client doesn't have a dependency cycle.</Description>
    <Title_Description>StackOverflowException when adding OrleansJsonSerializer as a SerializationProvider Workaround: use this gist instead https://gist.github.com/ReubenBond/45ef767aff071302ee62731b5c706dd7

Repro:
```C#
var client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
var s = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();

var silo = new SiloHostBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
s = silo.Services.GetRequiredService&lt;SerializationManager&gt;();
```

Only the silo fails the client doesn't have a dependency cycle.</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4872</IssueLabelID>
    <Title>No menu topic for Streaming after restructuring of docs</Title>
    <Description>
    </Description>
    <Title_Description>No menu topic for Streaming after restructuring of docs </Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4871</IssueLabelID>
    <Title>Rename UseDistributedTM to UseTransactions</Title>
    <Description>fix issue #4688 </Description>
    <Title_Description>Rename UseDistributedTM to UseTransactions fix issue #4688 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4870</IssueLabelID>
    <Title>Remove documentation sources</Title>
    <Description>I moved documentation sources to the docs branch so that we completely separate them from the generated html output. The goal is to move them to a separate repo altogether.

This is to delete doc sources from the gh-pages branch to prevent duplication and potential confusion.</Description>
    <Title_Description>Remove documentation sources I moved documentation sources to the docs branch so that we completely separate them from the generated html output. The goal is to move them to a separate repo altogether.

This is to delete doc sources from the gh-pages branch to prevent duplication and potential confusion.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4868</IssueLabelID>
    <Title>Should not need `.AsReference&lt;&gt;` when returning a grain</Title>
    <Description>I have a bit of code in the Registry pattern:

```
        public async Task&lt;IRegistryGrain&lt;TGrain&gt;&gt; RegisterGrain(TGrain grain)
        {
            if (State == null)
            {
                State = new HashSet&lt;TGrain&gt;();
            }

            State.Add(grain);
            await WriteStateAsync();

            return this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();
        }
```

If I just `return this;` instead of `this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();` I get an exception saying serialization failed.

Is this an edge case that got missed for grain checking?</Description>
    <Title_Description>Should not need `.AsReference&lt;&gt;` when returning a grain I have a bit of code in the Registry pattern:

```
        public async Task&lt;IRegistryGrain&lt;TGrain&gt;&gt; RegisterGrain(TGrain grain)
        {
            if (State == null)
            {
                State = new HashSet&lt;TGrain&gt;();
            }

            State.Add(grain);
            await WriteStateAsync();

            return this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();
        }
```

If I just `return this;` instead of `this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();` I get an exception saying serialization failed.

Is this an edge case that got missed for grain checking?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4867</IssueLabelID>
    <Title>Avoiding the OrleansAdoNetContent folder</Title>
    <Description>The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans but not for an established project. In my case the files are possibly harmful as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Description>
    <Title_Description>Avoiding the OrleansAdoNetContent folder The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans but not for an established project. In my case the files are possibly harmful as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4866</IssueLabelID>
    <Title>Minio grain storage provider</Title>
    <Description>I made a grain storage provider implementation with [Minio](https://www.minio.io/) which is a free  open source distributed object storage.

The implementation currently resides as code on [my repository](https://github.com/Kimserey/orleans-minio) under [/OrleansMinio](https://github.com/Kimserey/orleans-minio/tree/master/OrleansMinio) which I would like to PR into Orleans. I just don't know how to proceed. 

https://github.com/Kimserey/orleans-minio

If someone could guide me by answering the following questions:

1. Is it something you see worth PR'ing? If it isn't we can close this question.
_Minio is useful for me as I wish to not be tied to cloud providers services and prefer rely on free open source solutions._
2. How should I proceed? Are there any guidelines as I see other grain storages are within folder that are _linked files_ to _/shared_.

Thanks!</Description>
    <Title_Description>Minio grain storage provider I made a grain storage provider implementation with [Minio](https://www.minio.io/) which is a free  open source distributed object storage.

The implementation currently resides as code on [my repository](https://github.com/Kimserey/orleans-minio) under [/OrleansMinio](https://github.com/Kimserey/orleans-minio/tree/master/OrleansMinio) which I would like to PR into Orleans. I just don't know how to proceed. 

https://github.com/Kimserey/orleans-minio

If someone could guide me by answering the following questions:

1. Is it something you see worth PR'ing? If it isn't we can close this question.
_Minio is useful for me as I wish to not be tied to cloud providers services and prefer rely on free open source solutions._
2. How should I proceed? Are there any guidelines as I see other grain storages are within folder that are _linked files_ to _/shared_.

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>22/08/2018 12:02:12 PM +00:00</CreatedAt>
    <ClosedAt>5/09/2018 7:24:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4865</IssueLabelID>
    <Title>Await tasks in DedicatedAsynchAgent.Run()</Title>
    <Description>Source description in gitter:
&gt; I'm discovering the internal of orleans' runtime and I found that `DedicatedAsynchAgent.Run()`'s return type is void so its implements all can not be awaited. So is it safe to make DedicatedAsynchAgent.Run() awaitable(return a Task)? I want to try System.IO.Pipelines and System.Threading.Channels in Orleans which are designed to reactivate by async/wait pattern

There are some ambiguities in my description so I'll try to explain it more clearly

### Intention
I'm learning about orleans' internal and wanna try out some new .NET Core features like `System.IO.Pipelines` and `System.Threading.Channels`  in orleans.
Pipelines for sockets communication and Channels for internal message queue.
(There are already some great work by @JanEggers in https://github.com/dotnet/orleans/issues/3617#issuecomment-352587339)

### What's The Problem
The readers/writers in Pipelines/Channels are reactivate which means when pipes/channels are empty they will suspend readers and awaken them after data arrived in without blocking the current thread. This is implemented by Tasks and async/await.
I want to achieve these "awaitable" behavior in `IncomingMessageAgent.Run()`(For polling/posting message from/to channels) but couldn't because `DedicatedAsynchAgent.Run()` returns void.

At first I simply change `DedicatedAsynchAgent.Run()` to return a task and enqueue async delegate to thread executor instead:
``` csharp
internal abstract class DedicatedAsynchAgent : AsynchAgent
{
    public override void OnStart()
    {
        executor.QueueWorkItem(async _ =&gt; await Run());
    }
    protected abstract Task Run();
}
```
Or start a new task like [what `IncomingMessageAcceptor.ProcessAccept` does](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L353):
``` csharp
Task.Factory.StartNew(async () =&gt;
{
    await DoWork();
});
```
**BUT**: 
a) What `DedicatedAsynchAgent.Run()`s do is to enqueue a delegate to a specific Thread so it seems there's no meaning for "un-blocking" this thread.
b) await in async delegate will lead to the remaining code to enter a .Net thread pool thread.

### What I Want To Know
* Why `DedicatedAsynchAgent` uses the custom `ThreadPoolExecutor` rather than just start a job/task in the .NET thread pool.
* If it is safe to execute DedicatedAsynchAgent logic out of its ThreadPoolExecutor's thread.


PS.
*There may be some misunderstanding about ThreadPoolExecutor/AsynchAgent/Async-Await ... I'm glad to be corrected.*
*It's so much fun to read Orleans' source code what you people did is fantastic*</Description>
    <Title_Description>Await tasks in DedicatedAsynchAgent.Run() Source description in gitter:
&gt; I'm discovering the internal of orleans' runtime and I found that `DedicatedAsynchAgent.Run()`'s return type is void so its implements all can not be awaited. So is it safe to make DedicatedAsynchAgent.Run() awaitable(return a Task)? I want to try System.IO.Pipelines and System.Threading.Channels in Orleans which are designed to reactivate by async/wait pattern

There are some ambiguities in my description so I'll try to explain it more clearly

### Intention
I'm learning about orleans' internal and wanna try out some new .NET Core features like `System.IO.Pipelines` and `System.Threading.Channels`  in orleans.
Pipelines for sockets communication and Channels for internal message queue.
(There are already some great work by @JanEggers in https://github.com/dotnet/orleans/issues/3617#issuecomment-352587339)

### What's The Problem
The readers/writers in Pipelines/Channels are reactivate which means when pipes/channels are empty they will suspend readers and awaken them after data arrived in without blocking the current thread. This is implemented by Tasks and async/await.
I want to achieve these "awaitable" behavior in `IncomingMessageAgent.Run()`(For polling/posting message from/to channels) but couldn't because `DedicatedAsynchAgent.Run()` returns void.

At first I simply change `DedicatedAsynchAgent.Run()` to return a task and enqueue async delegate to thread executor instead:
``` csharp
internal abstract class DedicatedAsynchAgent : AsynchAgent
{
    public override void OnStart()
    {
        executor.QueueWorkItem(async _ =&gt; await Run());
    }
    protected abstract Task Run();
}
```
Or start a new task like [what `IncomingMessageAcceptor.ProcessAccept` does](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L353):
``` csharp
Task.Factory.StartNew(async () =&gt;
{
    await DoWork();
});
```
**BUT**: 
a) What `DedicatedAsynchAgent.Run()`s do is to enqueue a delegate to a specific Thread so it seems there's no meaning for "un-blocking" this thread.
b) await in async delegate will lead to the remaining code to enter a .Net thread pool thread.

### What I Want To Know
* Why `DedicatedAsynchAgent` uses the custom `ThreadPoolExecutor` rather than just start a job/task in the .NET thread pool.
* If it is safe to execute DedicatedAsynchAgent logic out of its ThreadPoolExecutor's thread.


PS.
*There may be some misunderstanding about ThreadPoolExecutor/AsynchAgent/Async-Await ... I'm glad to be corrected.*
*It's so much fun to read Orleans' source code what you people did is fantastic*</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4862</IssueLabelID>
    <Title>[Question] Orleans Event Sourcing snapshots of event log</Title>
    <Description>I have a JournaledGrain which I am persisting events through the attribute [LogConsistencyProvider(ProviderName = "LogStorage")]. Since this grain will handle heavy load hydrating the grain every time with all the events can result in a performance bottleneck. As a result snapshot are one alternative to this problem by hydrating events since the latest snapshot only. Is there is a way to handle snapshots in Orleans Event Sourcing?

I am using MongoDB to persist the data.</Description>
    <Title_Description>[Question] Orleans Event Sourcing snapshots of event log I have a JournaledGrain which I am persisting events through the attribute [LogConsistencyProvider(ProviderName = "LogStorage")]. Since this grain will handle heavy load hydrating the grain every time with all the events can result in a performance bottleneck. As a result snapshot are one alternative to this problem by hydrating events since the latest snapshot only. Is there is a way to handle snapshots in Orleans Event Sourcing?

I am using MongoDB to persist the data.</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4861</IssueLabelID>
    <Title>No default grains storage added to container if one is not configured.</Title>
    <Description>Addresses - IGrainStorage null implementation registerd in DI container #4710</Description>
    <Title_Description>No default grains storage added to container if one is not configured. Addresses - IGrainStorage null implementation registerd in DI container #4710</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4860</IssueLabelID>
    <Title>Minimal TOC</Title>
    <Description>Minimal transfer of coordintation support for transactions.
- TransactionCommitter facet
- Changed to commit logic to commit only upon successfull remot service call.
- Minima golden path tests</Description>
    <Title_Description>Minimal TOC Minimal transfer of coordintation support for transactions.
- TransactionCommitter facet
- Changed to commit logic to commit only upon successfull remot service call.
- Minima golden path tests</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4859</IssueLabelID>
    <Title>Silo with EFCore Lazy Loading failed to catch System.ExecutionEngineException and crash silently</Title>
    <Description>* Orleans.Server: 2.0.4
* EntityFrameworkCore: 2.1.1

I'm using EF Core and enable Lazy Loading for grain to store data.
When I use the EF entity proxy object as a return value for grain method it will throw a `System.ExecutionEngineException`in `unknown module` and silo fails to catch it and crash without any error message until you debug it.
It looks like crash in `ILBasedSerializer` while deep copying the return object.

The best practice is map the entity to a dto and return but it shouldn't causing exception if you return the proxy object directly in ASP.NET Core when you return a EF Core proxy entity to the browser(Or serialize to json) it will works(just get an extra json key `LazyLoader: {}`).</Description>
    <Title_Description>Silo with EFCore Lazy Loading failed to catch System.ExecutionEngineException and crash silently * Orleans.Server: 2.0.4
* EntityFrameworkCore: 2.1.1

I'm using EF Core and enable Lazy Loading for grain to store data.
When I use the EF entity proxy object as a return value for grain method it will throw a `System.ExecutionEngineException`in `unknown module` and silo fails to catch it and crash without any error message until you debug it.
It looks like crash in `ILBasedSerializer` while deep copying the return object.

The best practice is map the entity to a dto and return but it shouldn't causing exception if you return the proxy object directly in ASP.NET Core when you return a EF Core proxy entity to the browser(Or serialize to json) it will works(just get an extra json key `LazyLoader: {}`).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4858</IssueLabelID>
    <Title>Orleans.Transactions.TransactionInfo not in Core</Title>
    <Description>When a transaction aborts for whatever reason the exception that is serialized contains the Orleans.Transactions.TransactionInfo type.  That type is in Orleans.Transactions not in Orleans.Core so if the client doesn't reference the transactions package it fails to deserialize the exception (which unfortunately causes a grain timeout exception instead of a failed to deserialize exception to be delivered to the caller).</Description>
    <Title_Description>Orleans.Transactions.TransactionInfo not in Core When a transaction aborts for whatever reason the exception that is serialized contains the Orleans.Transactions.TransactionInfo type.  That type is in Orleans.Transactions not in Orleans.Core so if the client doesn't reference the transactions package it fails to deserialize the exception (which unfortunately causes a grain timeout exception instead of a failed to deserialize exception to be delivered to the caller).</Title_Description>
    <Label>P1</Label>
    <Assignee>xiazen</Assignee>
    <CreatedAt>17/08/2018 11:32:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4855</IssueLabelID>
    <Title>[Question] about GrainStorage and the internal VersionStoreGrain</Title>
    <Description>I'm writing a storage provider using efcore. 
The provider works against a configured dbcontext which means any type being used as storage should have a corresponding DbSet&lt;&gt; on the context. So arbitrary types are not welcomed here as the backing storage is not happy with them (SQL Server for example).

Now the problem raises If the provider is used as the default grain storage. This causes the internal ```VersionStoreGrain``` to malfunction because of the not configured ```VersionStoreGrainState```. 
Since the ```IVersionStoreGrain``` is an internal interface I can't add another implementation for it (Haven't really thought about if it's a good idea or not).

So to summarize my options:
- Provide another implementation for IVersionStoreGrain (which is not doable cause everything in there is internal)
- Handle ```VersionStoreGrainState``` differently. This probably suggest an internal dbcontext to handle Orleans related stuff. Which also causes the provider to break if I'm missing another internal type.
- Handle arbitrary types using a fallback provider or a key-value table.
- Don't allow the provider to be used as the default storage.

I know using entity framework inherently suggest that arbitrary types can't be used but for this to work it should be able to be used as the only grain storage provider in the silo.

I'll probably go with option 3 with my current knowledge of Orleans. Any advice is very appreciated. I'm gonna open source this as soon as I finish this and write more tests.</Description>
    <Title_Description>[Question] about GrainStorage and the internal VersionStoreGrain I'm writing a storage provider using efcore. 
The provider works against a configured dbcontext which means any type being used as storage should have a corresponding DbSet&lt;&gt; on the context. So arbitrary types are not welcomed here as the backing storage is not happy with them (SQL Server for example).

Now the problem raises If the provider is used as the default grain storage. This causes the internal ```VersionStoreGrain``` to malfunction because of the not configured ```VersionStoreGrainState```. 
Since the ```IVersionStoreGrain``` is an internal interface I can't add another implementation for it (Haven't really thought about if it's a good idea or not).

So to summarize my options:
- Provide another implementation for IVersionStoreGrain (which is not doable cause everything in there is internal)
- Handle ```VersionStoreGrainState``` differently. This probably suggest an internal dbcontext to handle Orleans related stuff. Which also causes the provider to break if I'm missing another internal type.
- Handle arbitrary types using a fallback provider or a key-value table.
- Don't allow the provider to be used as the default storage.

I know using entity framework inherently suggest that arbitrary types can't be used but for this to work it should be able to be used as the only grain storage provider in the silo.

I'll probably go with option 3 with my current knowledge of Orleans. Any advice is very appreciated. I'm gonna open source this as soon as I finish this and write more tests.</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4853</IssueLabelID>
    <Title>Do not place stateless worker locally if the silo is stopping</Title>
    <Description>Fix for #4852 and #4757 </Description>
    <Title_Description>Do not place stateless worker locally if the silo is stopping Fix for #4852 and #4757 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4852</IssueLabelID>
    <Title>Revisit handling of StatelessWorker grains during shutdown</Title>
    <Description>Base on the feedback in #4757 we need to reconsider how StatelessWorker grains are handled during silo shutdown.</Description>
    <Title_Description>Revisit handling of StatelessWorker grains during shutdown Base on the feedback in #4757 we need to reconsider how StatelessWorker grains are handled during silo shutdown.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4851</IssueLabelID>
    <Title>transaction consistency tests and error injection</Title>
    <Description>the consistency tests I have been using for testing the transaction implementation.

- includes a test runner that runs randomized transaction tests using various scale and randomization settings.  Running all of those takes a long time (because of the large number of tests and the volume of the tests) but this is sort of intentional for this type of test (random testing is quite good at discovering subtle race conditions if run with enough volume).

- each consistency test records a lot of data while executing the random transactions (state version numbers read &amp; written by each transaction for each grain)  that is checked for serializability in the end. Also I check if any exceptions encountered are expected for the type of test being run. For example there should not be any transient exceptions under low congestion and when avoiding deadlocks and there should not be any unknown exceptions when storage injection is off.

- These tests can run with or without fault injection. 

- The fault injector randomly injects three kinds of exceptions:
    - an uninterpreted exception before or after writing to storage
    - an InconsistentStateException before writing to storage</Description>
    <Title_Description>transaction consistency tests and error injection the consistency tests I have been using for testing the transaction implementation.

- includes a test runner that runs randomized transaction tests using various scale and randomization settings.  Running all of those takes a long time (because of the large number of tests and the volume of the tests) but this is sort of intentional for this type of test (random testing is quite good at discovering subtle race conditions if run with enough volume).

- each consistency test records a lot of data while executing the random transactions (state version numbers read &amp; written by each transaction for each grain)  that is checked for serializability in the end. Also I check if any exceptions encountered are expected for the type of test being run. For example there should not be any transient exceptions under low congestion and when avoiding deadlocks and there should not be any unknown exceptions when storage injection is off.

- These tests can run with or without fault injection. 

- The fault injector randomly injects three kinds of exceptions:
    - an uninterpreted exception before or after writing to storage
    - an InconsistentStateException before writing to storage</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4850</IssueLabelID>
    <Title>Fix NullReferenceException in ExecutingWorkItemsTracker</Title>
    <Description>I hit a `NullReferenceException` here while debugging #4617.

The root cause was the order of initialization of `log` and `executingWorkTracker` in the `ThreadPoolExecutor` constructor.

This PR fixes that adds some defensiveness and cleans up the code a little.</Description>
    <Title_Description>Fix NullReferenceException in ExecutingWorkItemsTracker I hit a `NullReferenceException` here while debugging #4617.

The root cause was the order of initialization of `log` and `executingWorkTracker` in the `ThreadPoolExecutor` constructor.

This PR fixes that adds some defensiveness and cleans up the code a little.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4847</IssueLabelID>
    <Title>Why is it that only the last Silo suspected of P can declare its death?</Title>
    <Description>If the successor node ABC of P starts at intervals then it is possible that A suspects P writes; B suspects P writes; C suspects P writes and in such a dead cycle can not really declare P's death.</Description>
    <Title_Description>Why is it that only the last Silo suspected of P can declare its death? If the successor node ABC of P starts at intervals then it is possible that A suspects P writes; B suspects P writes; C suspects P writes and in such a dead cycle can not really declare P's death.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4846</IssueLabelID>
    <Title>Repair typesetting error</Title>
    <Description>Repair typesetting error.</Description>
    <Title_Description>Repair typesetting error Repair typesetting error.</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4844</IssueLabelID>
    <Title>Fix partial build</Title>
    <Description>Tentative to bring #4740 to the master branch</Description>
    <Title_Description>Fix partial build Tentative to bring #4740 to the master branch</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4843</IssueLabelID>
    <Title>Orleans Health Check</Title>
    <Description>We are running Orleans on a Kubernetes cluster.

What is the recommended way to set up readiness/liveliness (health) checks on silos?
</Description>
    <Title_Description>Orleans Health Check We are running Orleans on a Kubernetes cluster.

What is the recommended way to set up readiness/liveliness (health) checks on silos?
</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4842</IssueLabelID>
    <Title>Orleans.Runtime.OrleansException: Not connected to a gateway when reconnecting to a local silo</Title>
    <Description>I'm just playing with Orleans and one of the basics and I tried the 2.0 sample app.

I started the client before the silo (intentionally) just to see if the retry policy outlined there would work. The client connected but then immediately failed with the error I'm pasting below.

Steps to reproduce:

1. Use the [Hello world sample](https://github.com/dotnet/orleans/tree/master/Samples/2.0/HelloWorld)
1. Start the client
1. Start the silo (after the client has been started)
1. Observe the log output to see the exception

Expected behaviour:
I would expect the client to successfully reconnect and perform operations normally. Is this something that is supposed to work or am I expecting too much? Let me know if you need more details on the setup.

Log output:

&lt;details&gt;
  &lt;summary&gt;Expand log content&lt;/summary&gt;

```
$ dotnet run --project src/OrleansClient/OrleansClient.csproj
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on Petarda.local at 172.16.1.50 Client Id = *cli/c3e0439a ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.3. Commit Hash: c5432c1809a37f12142fb1c489fb0a4f77ed3bda (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=OrleansClient&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/c3e0439a@28c5cba1 #2:
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Retrying ...
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
Cluster client failed to connect to cluster with unexpected error.  Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at OrleansClient.Program.StartClientWithRetries() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 59
   at OrleansClient.Program.RunMainAsync() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 29
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:40
```
&lt;/details&gt;</Description>
    <Title_Description>Orleans.Runtime.OrleansException: Not connected to a gateway when reconnecting to a local silo I'm just playing with Orleans and one of the basics and I tried the 2.0 sample app.

I started the client before the silo (intentionally) just to see if the retry policy outlined there would work. The client connected but then immediately failed with the error I'm pasting below.

Steps to reproduce:

1. Use the [Hello world sample](https://github.com/dotnet/orleans/tree/master/Samples/2.0/HelloWorld)
1. Start the client
1. Start the silo (after the client has been started)
1. Observe the log output to see the exception

Expected behaviour:
I would expect the client to successfully reconnect and perform operations normally. Is this something that is supposed to work or am I expecting too much? Let me know if you need more details on the setup.

Log output:

&lt;details&gt;
  &lt;summary&gt;Expand log content&lt;/summary&gt;

```
$ dotnet run --project src/OrleansClient/OrleansClient.csproj
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on Petarda.local at 172.16.1.50 Client Id = *cli/c3e0439a ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.3. Commit Hash: c5432c1809a37f12142fb1c489fb0a4f77ed3bda (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=OrleansClient&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/c3e0439a@28c5cba1 #2:
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Retrying ...
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
Cluster client failed to connect to cluster with unexpected error.  Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at OrleansClient.Program.StartClientWithRetries() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 59
   at OrleansClient.Program.RunMainAsync() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 29
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:40
```
&lt;/details&gt;</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4841</IssueLabelID>
    <Title>Ignore ambiguous transactions in correctness testing.</Title>
    <Description>Updated transaction correctness/recoverability tests to not check results against client expectations if transaction success was ambiguous.</Description>
    <Title_Description>Ignore ambiguous transactions in correctness testing. Updated transaction correctness/recoverability tests to not check results against client expectations if transaction success was ambiguous.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4839</IssueLabelID>
    <Title>Namespace property removed from ImplicitStreamSubscriptionAttribute in 1.5</Title>
    <Description>From [gitter chat here](https://gitter.im/dotnet/orleans?at=5b6bf2c9e9b96f2c98e36bec)

We started to migrate 1.4 -&gt; 1.5 (2.0 deemed too big rework and too many breaking changes)
and discovered that we need to make some changes in our code base. They are more or less reasonable like DI for constructors and some removed defaults. There is one change in 1.5 that looks strange and unreasonable and I'd like to understand what was the reasoning behind it:

Previously (in 1.4) `ImplicitStreamSubscriptionAttribute` has a public `Namespace` property on it and it was quite nice way to use subscription attribute itself to subscribe instance of the class to streams:
we are using reflection to create shared code in `BaseStreamListener` class which simply reflected over attributes and produced the list of "namespaces" to subscribe - thus we have centralized way to subscribe to the stream in base class - reusable piece of logic.
in 1.5. `Namespace` property was replaced by `Predicate` and  for simple scenario like ours - all what we need is to pass namespace string in ctor which then will be converted to `ExactMatchStreamNamespacePredicate` (which design is also leaves question as it's internal and doesn't expose any helpful information to subscribe to streams in the stream listening classes).

From my understanding - we still need to subscribe instance to the stream in runtime and call something like this:
```
foreach(var streamNamespace in allNamespaces)
  var inputStream = StreamFactory.GetStream&lt;TMessageType&gt;(primaryKey streamProvider streamNamespace);
   var handle = await inputStream.SubscribeAsync(ReceiveCommand OnCommandError OnCommandCompleted);
  _streams.Add(inputStream);
  _handles.Add(handle);
}
``` 
At least this is how we are working with streams in 1.4.

In _raw_ Orleans 1.5 we need to add `ImplicitStreamSubscription("fooNamespace")` attribute to the class but ALSO to keep a separate collection of namespaces to subscribe in runtime like in above example. It feels that this is not a well-thought decision and some practical functionality was removed without adding any obvious way to achieve the same results.

In 1.4. we don't need to maintain any separate collection - it was beautifully simple to scrap all string values from attributes on the class:
```
    protected virtual IEnumerable&lt;string&gt; getNamespacesFromAttributes()
    {
            var allNamespaces = this.GetType()
                .GetCustomAttributes(typeof(ImplicitStreamSubscriptionAttribute) false)
                .Select(attrib =&gt; ((ImplicitStreamSubscriptionAttribute) attrib).Namespace)
                .ToList();

            return allNamespaces;
    }
```
and the attributes on top of the class were a single source of truth for namespaces this stream is subscribed to.

We can simply add back this functionality by creating
```
/// &lt;summary&gt;
	/// The reason why this class exists is that between 1.4 and 1.5 ImplicitStreamSubscriptionAttribute lost it's property "Namespace" that we were using in getNamespacesFromAttributes method of BaseListenerGrain.
	/// This class simply returns it back.
	/// &lt;/summary&gt;
	[AttributeUsage(AttributeTargets.Class AllowMultiple = true)]
	public class DrawboardImplicitStreamSubscriptionAttribute : ImplicitStreamSubscriptionAttribute
	{
		/// &lt;summary&gt;
		/// Legacy compartible property Namespace to make subscription easier
		/// &lt;/summary&gt;
		public string  Namespace { get; }

		/// &lt;summary&gt;Used to subscribe to all stream namespaces.&lt;/summary&gt;
		public DrawboardImplicitStreamSubscriptionAttribute() : base()
		{
			this.Namespace = string.Empty;
		}

		/// &lt;summary&gt;Used to subscribe to the specified stream namespace.&lt;/summary&gt;
		/// &lt;param name="streamNamespace"&gt;The stream namespace to subscribe.&lt;/param&gt;
		public DrawboardImplicitStreamSubscriptionAttribute(string streamNamespace) : base(streamNamespace)
		{
			this.Namespace = streamNamespace;
		}

	}
```
And ditch all `ImplicitStreamSubscriptionAttribute` in favour of our own one and this is what we are doing now. For me it's a code smell to introduce your own attributes to solve the problem that was perfectly solved in older versions of framework.

But the question is - what was the reason behind this breaking change ? It feels that it doesn't affect anything but was simply to break public contract that was in use (across multiple 1.x version) without any obvious alternative or any afterthoughts of how this is going to affect existing deployments.

Also If there is a better way to implement this in non 2.0 world - keen to hear in comments.</Description>
    <Title_Description>Namespace property removed from ImplicitStreamSubscriptionAttribute in 1.5 From [gitter chat here](https://gitter.im/dotnet/orleans?at=5b6bf2c9e9b96f2c98e36bec)

We started to migrate 1.4 -&gt; 1.5 (2.0 deemed too big rework and too many breaking changes)
and discovered that we need to make some changes in our code base. They are more or less reasonable like DI for constructors and some removed defaults. There is one change in 1.5 that looks strange and unreasonable and I'd like to understand what was the reasoning behind it:

Previously (in 1.4) `ImplicitStreamSubscriptionAttribute` has a public `Namespace` property on it and it was quite nice way to use subscription attribute itself to subscribe instance of the class to streams:
we are using reflection to create shared code in `BaseStreamListener` class which simply reflected over attributes and produced the list of "namespaces" to subscribe - thus we have centralized way to subscribe to the stream in base class - reusable piece of logic.
in 1.5. `Namespace` property was replaced by `Predicate` and  for simple scenario like ours - all what we need is to pass namespace string in ctor which then will be converted to `ExactMatchStreamNamespacePredicate` (which design is also leaves question as it's internal and doesn't expose any helpful information to subscribe to streams in the stream listening classes).

From my understanding - we still need to subscribe instance to the stream in runtime and call something like this:
```
foreach(var streamNamespace in allNamespaces)
  var inputStream = StreamFactory.GetStream&lt;TMessageType&gt;(primaryKey streamProvider streamNamespace);
   var handle = await inputStream.SubscribeAsync(ReceiveCommand OnCommandError OnCommandCompleted);
  _streams.Add(inputStream);
  _handles.Add(handle);
}
``` 
At least this is how we are working with streams in 1.4.

In _raw_ Orleans 1.5 we need to add `ImplicitStreamSubscription("fooNamespace")` attribute to the class but ALSO to keep a separate collection of namespaces to subscribe in runtime like in above example. It feels that this is not a well-thought decision and some practical functionality was removed without adding any obvious way to achieve the same results.

In 1.4. we don't need to maintain any separate collection - it was beautifully simple to scrap all string values from attributes on the class:
```
    protected virtual IEnumerable&lt;string&gt; getNamespacesFromAttributes()
    {
            var allNamespaces = this.GetType()
                .GetCustomAttributes(typeof(ImplicitStreamSubscriptionAttribute) false)
                .Select(attrib =&gt; ((ImplicitStreamSubscriptionAttribute) attrib).Namespace)
                .ToList();

            return allNamespaces;
    }
```
and the attributes on top of the class were a single source of truth for namespaces this stream is subscribed to.

We can simply add back this functionality by creating
```
/// &lt;summary&gt;
	/// The reason why this class exists is that between 1.4 and 1.5 ImplicitStreamSubscriptionAttribute lost it's property "Namespace" that we were using in getNamespacesFromAttributes method of BaseListenerGrain.
	/// This class simply returns it back.
	/// &lt;/summary&gt;
	[AttributeUsage(AttributeTargets.Class AllowMultiple = true)]
	public class DrawboardImplicitStreamSubscriptionAttribute : ImplicitStreamSubscriptionAttribute
	{
		/// &lt;summary&gt;
		/// Legacy compartible property Namespace to make subscription easier
		/// &lt;/summary&gt;
		public string  Namespace { get; }

		/// &lt;summary&gt;Used to subscribe to all stream namespaces.&lt;/summary&gt;
		public DrawboardImplicitStreamSubscriptionAttribute() : base()
		{
			this.Namespace = string.Empty;
		}

		/// &lt;summary&gt;Used to subscribe to the specified stream namespace.&lt;/summary&gt;
		/// &lt;param name="streamNamespace"&gt;The stream namespace to subscribe.&lt;/param&gt;
		public DrawboardImplicitStreamSubscriptionAttribute(string streamNamespace) : base(streamNamespace)
		{
			this.Namespace = streamNamespace;
		}

	}
```
And ditch all `ImplicitStreamSubscriptionAttribute` in favour of our own one and this is what we are doing now. For me it's a code smell to introduce your own attributes to solve the problem that was perfectly solved in older versions of framework.

But the question is - what was the reason behind this breaking change ? It feels that it doesn't affect anything but was simply to break public contract that was in use (across multiple 1.x version) without any obvious alternative or any afterthoughts of how this is going to affect existing deployments.

Also If there is a better way to implement this in non 2.0 world - keen to hear in comments.</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>9/08/2018 10:44:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4837</IssueLabelID>
    <Title>Client shutdown problem</Title>
    <Description>Hi

We noticed that if we kill the client without calling method .Close next time when we tried to establish a connection with silo host client connection hangs with the state "Starting".

From console log we can see all active gateways TCP connection is alive but code simply hangs on 
![image](https://user-images.githubusercontent.com/1646051/43911787-9f151528-9c00-11e8-9390-e6dbec010879.png)

Has anyone else noticed the same issue before?

Best

Dean</Description>
    <Title_Description>Client shutdown problem Hi

We noticed that if we kill the client without calling method .Close next time when we tried to establish a connection with silo host client connection hangs with the state "Starting".

From console log we can see all active gateways TCP connection is alive but code simply hangs on 
![image](https://user-images.githubusercontent.com/1646051/43911787-9f151528-9c00-11e8-9390-e6dbec010879.png)

Has anyone else noticed the same issue before?

Best

Dean</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4835</IssueLabelID>
    <Title>Change Orleans.TelemetryConsumers.Counters project target platform to netstandard or netcoreapp</Title>
    <Description>Currently `Orleans.TelemetryConsumers.Counters` targets `net461` framework. I am unable to use it with .net core app. I have an exception building `SiloHost` with `AddPerfCountersTelemetryConsumer` extension method
`System.IO.FileNotFoundException: 'Could not load file or assembly 'System.Diagnostics.PerformanceCounter Version=0.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.' `

Looks like it uses full framework version of `System.Diagnostics.PerformanceCounter`. I think we can use netstandart version of `System.Diagnostics.PerformanceCounter` since  it is already available for netstandart https://www.nuget.org/packages/System.Diagnostics.PerformanceCounter/</Description>
    <Title_Description>Change Orleans.TelemetryConsumers.Counters project target platform to netstandard or netcoreapp Currently `Orleans.TelemetryConsumers.Counters` targets `net461` framework. I am unable to use it with .net core app. I have an exception building `SiloHost` with `AddPerfCountersTelemetryConsumer` extension method
`System.IO.FileNotFoundException: 'Could not load file or assembly 'System.Diagnostics.PerformanceCounter Version=0.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.' `

Looks like it uses full framework version of `System.Diagnostics.PerformanceCounter`. I think we can use netstandart version of `System.Diagnostics.PerformanceCounter` since  it is already available for netstandart https://www.nuget.org/packages/System.Diagnostics.PerformanceCounter/</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4834</IssueLabelID>
    <Title>Questions about Reminders timing</Title>
    <Description>Hey there
In our team we are using Orleans Reminders to perform an action that should run exactly every 1 hour.
Reminders are registered with the following function: `RegisterOrUpdateReminder(string reminderName TimeSpan dueTime TimeSpan period);
`
As we noticed recently a reminder that was registered with dueTime=0 period=1 hour will not tick every one hour exactly.
It will simply wait 1 hour _after the last reminder ended_ and then send the next reminder tick.
That is a problem to us since the reminder invokes a function that can take few seconds to end. In that case we will have an **accumulative delay** on reminder ticks that will be received every 1 hour **+ epsilon**.

From [Orleans Documentation](https://dotnet.github.io/orleans/1.5/Documentation/Core-Features/Timers-and-Reminders.html) it is said to be the case for Orleans Timers and for Reminders it said that "Reminders are similar to timers [...]".

My question is **whether there is an option to configure reminder timing** to be exactly as we registered (first tick after dueTime time and then a tick every period) without being affected by the duration of the function the reminder invokes.
If there isn't other solutions would be (A) making the reminder to invoke a async Task without awaiting for it (B) making the reminder to start a timer to do the actual work or (C) keeping track on the delay from the expected time and once it got too big update and re-schedule the reminder.

We'll be glad to hear if you know a way to handle it or simply what would you do in such cases :)
</Description>
    <Title_Description>Questions about Reminders timing Hey there
In our team we are using Orleans Reminders to perform an action that should run exactly every 1 hour.
Reminders are registered with the following function: `RegisterOrUpdateReminder(string reminderName TimeSpan dueTime TimeSpan period);
`
As we noticed recently a reminder that was registered with dueTime=0 period=1 hour will not tick every one hour exactly.
It will simply wait 1 hour _after the last reminder ended_ and then send the next reminder tick.
That is a problem to us since the reminder invokes a function that can take few seconds to end. In that case we will have an **accumulative delay** on reminder ticks that will be received every 1 hour **+ epsilon**.

From [Orleans Documentation](https://dotnet.github.io/orleans/1.5/Documentation/Core-Features/Timers-and-Reminders.html) it is said to be the case for Orleans Timers and for Reminders it said that "Reminders are similar to timers [...]".

My question is **whether there is an option to configure reminder timing** to be exactly as we registered (first tick after dueTime time and then a tick every period) without being affected by the duration of the function the reminder invokes.
If there isn't other solutions would be (A) making the reminder to invoke a async Task without awaiting for it (B) making the reminder to start a timer to do the actual work or (C) keeping track on the delay from the expected time and once it got too big update and re-schedule the reminder.

We'll be glad to hear if you know a way to handle it or simply what would you do in such cases :)
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4833</IssueLabelID>
    <Title>Accepting into an existing Socket is not supported on this platform.</Title>
    <Description>Hi There 

I am deploying Orleans within docker on linux for the first time and have found an exception in my log that so far does not seem to be causing any issues. I though it worth reporting nonetheless.

My base image for docker deployment is microsoft/dotnet:2.1-runtime 

The log I have is as follows:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-1-240 silo address S10.0.1.240:11111:271491670 to host ip-10-0-0-38 silo address S10.0.0.38:11111:271491664.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]`</Description>
    <Title_Description>Accepting into an existing Socket is not supported on this platform. Hi There 

I am deploying Orleans within docker on linux for the first time and have found an exception in my log that so far does not seem to be causing any issues. I though it worth reporting nonetheless.

My base image for docker deployment is microsoft/dotnet:2.1-runtime 

The log I have is as follows:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-1-240 silo address S10.0.1.240:11111:271491670 to host ip-10-0-0-38 silo address S10.0.0.38:11111:271491664.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4832</IssueLabelID>
    <Title>Serializing Delegates not supported on this platform</Title>
    <Description>Hi There

I am running the latest version of Orleans on a docker container based upon microsoft/dotnet:2.1-runtime on linux.

It's running at AWS in the ECS environment.

The problem seems to be related to Fallback serialization of exceptions. I make a call to an external library AmazonLambdaClient which is throwing a permissions exception. The permissions exception is a custom exception type and it seems that there is something wrong with serialization of this custom exception within docker on linux. 

For now my workaround is to catch the exception and convert it to a regular System.Exception but I'm guessing this problem will rear it's head somewhere else.

The exception log is below:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-0-38 silo address S10.0.0.38:11111:271490656 to host ip-10-0-1-240 silo address S10.0.1.240:11111:271489317.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
Task [Id=1 Status=RanToCompletion] in WorkGroup [Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.4759661 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=13 Executing Task Id=1 Status=RanToCompletion for 00:00:00.4787084 on WorkItem=WorkItemGroup:Name=[Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.4792611. .&gt;
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]
Unexpected error sending message Response S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af-&gt;S10.0.1.240:11111:271490656*grn/37AC7DD4/99220d9c@36823a84 #180:
System.Runtime.Serialization.SerializationException: Serializing delegates is not supported on this platform.
at System.MulticastDelegate.GetObjectData(SerializationInfo info StreamingContext context)
at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph BinaryFormatterWriter serWriter Boolean fCheck)
at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Boolean check)
at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AcceptOperationSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeDictionary[KV](Object original ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncEngineSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SafeCloseSocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at CachedConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeList[T](Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeArray(Array array ISerializationContext context Type expected Type et)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TablesSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at RedirectHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketsHttpHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at DiagnosticsHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpResponseMessageBodySerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AmazonLambdaExceptionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.Serialize(Object raw IBinaryTokenStreamWriter stream)
at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]`</Description>
    <Title_Description>Serializing Delegates not supported on this platform Hi There

I am running the latest version of Orleans on a docker container based upon microsoft/dotnet:2.1-runtime on linux.

It's running at AWS in the ECS environment.

The problem seems to be related to Fallback serialization of exceptions. I make a call to an external library AmazonLambdaClient which is throwing a permissions exception. The permissions exception is a custom exception type and it seems that there is something wrong with serialization of this custom exception within docker on linux. 

For now my workaround is to catch the exception and convert it to a regular System.Exception but I'm guessing this problem will rear it's head somewhere else.

The exception log is below:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-0-38 silo address S10.0.0.38:11111:271490656 to host ip-10-0-1-240 silo address S10.0.1.240:11111:271489317.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
Task [Id=1 Status=RanToCompletion] in WorkGroup [Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.4759661 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=13 Executing Task Id=1 Status=RanToCompletion for 00:00:00.4787084 on WorkItem=WorkItemGroup:Name=[Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.4792611. .&gt;
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]
Unexpected error sending message Response S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af-&gt;S10.0.1.240:11111:271490656*grn/37AC7DD4/99220d9c@36823a84 #180:
System.Runtime.Serialization.SerializationException: Serializing delegates is not supported on this platform.
at System.MulticastDelegate.GetObjectData(SerializationInfo info StreamingContext context)
at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph BinaryFormatterWriter serWriter Boolean fCheck)
at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Boolean check)
at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AcceptOperationSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeDictionary[KV](Object original ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncEngineSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SafeCloseSocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at CachedConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeList[T](Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeArray(Array array ISerializationContext context Type expected Type et)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TablesSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at RedirectHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketsHttpHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at DiagnosticsHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpResponseMessageBodySerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AmazonLambdaExceptionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.Serialize(Object raw IBinaryTokenStreamWriter stream)
at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4831</IssueLabelID>
    <Title>Added support for priority transaction manager. </Title>
    <Description>Only one priority transaction manager is allowed per transaction.  Priority TM be used to detect TOC in future changes.

Also moved ReadonlyCommit to resource interface from tm interface.  Call was placed in wrong interface when split.</Description>
    <Title_Description>Added support for priority transaction manager.  Only one priority transaction manager is allowed per transaction.  Priority TM be used to detect TOC in future changes.

Also moved ReadonlyCommit to resource interface from tm interface.  Call was placed in wrong interface when split.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4830</IssueLabelID>
    <Title>When deactivating a grain do not stop timers if there are running requests </Title>
    <Description>Fix for #4774 

Thanks @yevhen  I was able to repro this issue 100% with this test. Like said in the issue this will fix only part of the issue.</Description>
    <Title_Description>When deactivating a grain, do not stop timers if there are running requests  Fix for #4774 

Thanks @yevhen  I was able to repro this issue 100% with this test. Like said in the issue this will fix only part of the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4828</IssueLabelID>
    <Title>Questions about the order of method calls </Title>
    <Description>Hi 

I am working on a stream processing system which might be sensitive to the orders of the method calls between grains. If I call an async method which sends messages from A to B multiple times will the messages are processed in order? 

Thanks!

 </Description>
    <Title_Description>Questions about the order of method calls  Hi 

I am working on a stream processing system which might be sensitive to the orders of the method calls between grains. If I call an async method which sends messages from A to B multiple times will the messages are processed in order? 

Thanks!

 </Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4826</IssueLabelID>
    <Title>Question/Sample Request: Long running function execution via Orleans</Title>
    <Description>I've seen in the documentation about how "Orleans is not suited for long running work*" (*Generally) - I may be paraphrasing. There are a few issues regarding that same topic #4531 #4370 #3071 and several others that I'm having trouble finding ATM.

The tldr of what I'm hoping to accomplish with Orleans is to take lots of calls from my app and dispatch them across a cluster of Orleans silos.  Many of these calls that occur are completed in a few milliseconds but many take several minutes to complete when running in our non-Orleans implementation.  

I understand there is a default timeout of 30 seconds for the client to receive a response from the grain and I would feel weird about increasing that to accommodate our "longest running logic"  I feel like there has to be a better way of doing it that just increasing the timeout.

Currently my calls (either fast or slow) look similar to this and note this is all CPU bound work:

Client.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    var grain = _clusterClient.GetGrain&lt;IMyGrain&gt;(Guid.NewGuid());
    return await grain.DoWork(param);
}
```

Grain.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    return await Task.Run(() =&gt;
    {
         // CPU bound sync code
    });
}
```

The above seems to work out great when `DoWork` is fast running at least at small scale. Prior to using Orleans I was using a `LimitedConcurrencyTaskScheduler` in order to keep memory usage down; it seemed like I was getting into some situations where I'd have so many scheduled tasks that all memory would be utilized and nothing would complete.  

The above code does not work without setting the timeout to at least as high as our "longest running operation".  It seems that a lot of suggestions on getting around this are to "return immediately that the task has been started then get the result when it's finished" but I'm not finding any samples on how to accomplish this at least from both a client and grain perspective.

Could some samples be provided on how to accomplish what I'm going after?  It seems that some sort of check that an invocation is complete would be needed but I'm not sure how to go about that.  Would this require my grains to become stateful rather than stateless? #4370 seems like it ***may*** be of use but I'm only seeing from the grain perspective not what it looks like from the client.  Ideally my fast and long running client/grains with have similar looking implementations but if I have to break out into separate methods for accommodating that's fine as well.

Hopefully this all makes sense!</Description>
    <Title_Description>Question/Sample Request: Long running function execution via Orleans I've seen in the documentation about how "Orleans is not suited for long running work*" (*Generally) - I may be paraphrasing. There are a few issues regarding that same topic #4531 #4370 #3071 and several others that I'm having trouble finding ATM.

The tldr of what I'm hoping to accomplish with Orleans is to take lots of calls from my app and dispatch them across a cluster of Orleans silos.  Many of these calls that occur are completed in a few milliseconds but many take several minutes to complete when running in our non-Orleans implementation.  

I understand there is a default timeout of 30 seconds for the client to receive a response from the grain and I would feel weird about increasing that to accommodate our "longest running logic"  I feel like there has to be a better way of doing it that just increasing the timeout.

Currently my calls (either fast or slow) look similar to this and note this is all CPU bound work:

Client.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    var grain = _clusterClient.GetGrain&lt;IMyGrain&gt;(Guid.NewGuid());
    return await grain.DoWork(param);
}
```

Grain.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    return await Task.Run(() =&gt;
    {
         // CPU bound sync code
    });
}
```

The above seems to work out great when `DoWork` is fast running at least at small scale. Prior to using Orleans I was using a `LimitedConcurrencyTaskScheduler` in order to keep memory usage down; it seemed like I was getting into some situations where I'd have so many scheduled tasks that all memory would be utilized and nothing would complete.  

The above code does not work without setting the timeout to at least as high as our "longest running operation".  It seems that a lot of suggestions on getting around this are to "return immediately that the task has been started then get the result when it's finished" but I'm not finding any samples on how to accomplish this at least from both a client and grain perspective.

Could some samples be provided on how to accomplish what I'm going after?  It seems that some sort of check that an invocation is complete would be needed but I'm not sure how to go about that.  Would this require my grains to become stateful rather than stateless? #4370 seems like it ***may*** be of use but I'm only seeing from the grain perspective not what it looks like from the client.  Ideally my fast and long running client/grains with have similar looking implementations but if I have to break out into separate methods for accommodating that's fine as well.

Hopefully this all makes sense!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4823</IssueLabelID>
    <Title>Error occurs in clusterbuilder.build  when  iis website restart</Title>
    <Description>Hi
  I have a websit using Orleans Client connect to the server.

  I have a static ClusterClient
    and when the website start the ClientBuilder.Build() is invoked and connect to the server.
    and when  the website shut down IClusterClient.Close() and Dispose() is invoked .

  it runs good but when the website restart it become unstable   and then if continue access the 
  website it will become ok because the IClusterClient is still null and  ClientBuilder.Build() is also 
   invoked for init. and then it will OK all the time.

  the env is:   windows 10  IIS 10  donet framework 4.7.2  asp.net mvc 5.2.4.0.

the debugger show that:
FatalExecutionEngineError  error address is 0x0df3063f，at thread 0xbf8 。error code is 0xc0000005。maybe it is a CLR  bug，or unsafe code bug。maybe with COM-interop or PInvoke .

please help.

![error](https://user-images.githubusercontent.com/17829409/43782305-a40558ce-9a91-11e8-9c2b-73e460f6af09.PNG)

![error2](https://user-images.githubusercontent.com/17829409/43782812-bf60bb58-9a92-11e8-8751-99d24f0fe083.PNG)
</Description>
    <Title_Description>Error occurs in clusterbuilder.build  when  iis website restart Hi
  I have a websit using Orleans Client connect to the server.

  I have a static ClusterClient
    and when the website start the ClientBuilder.Build() is invoked and connect to the server.
    and when  the website shut down IClusterClient.Close() and Dispose() is invoked .

  it runs good but when the website restart it become unstable   and then if continue access the 
  website it will become ok because the IClusterClient is still null and  ClientBuilder.Build() is also 
   invoked for init. and then it will OK all the time.

  the env is:   windows 10  IIS 10  donet framework 4.7.2  asp.net mvc 5.2.4.0.

the debugger show that:
FatalExecutionEngineError  error address is 0x0df3063f，at thread 0xbf8 。error code is 0xc0000005。maybe it is a CLR  bug，or unsafe code bug。maybe with COM-interop or PInvoke .

please help.

![error](https://user-images.githubusercontent.com/17829409/43782305-a40558ce-9a91-11e8-9c2b-73e460f6af09.PNG)

![error2](https://user-images.githubusercontent.com/17829409/43782812-bf60bb58-9a92-11e8-8751-99d24f0fe083.PNG)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4822</IssueLabelID>
    <Title>Which code files are maintained for memberships tables and grain directory tables?</Title>
    <Description>  I'm studying the implementation of Orleans but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members normal exit and abnormal exit Grain activation and deactivation and node failure when the table recovery operations.

  Could you tell me which files are the specific implementation codes of these operations?</Description>
    <Title_Description>Which code files are maintained for memberships tables and grain directory tables?   I'm studying the implementation of Orleans but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members normal exit and abnormal exit Grain activation and deactivation and node failure when the table recovery operations.

  Could you tell me which files are the specific implementation codes of these operations?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4821</IssueLabelID>
    <Title>GatewayClientReceiver.FillBuffer() being slow and looks like executing in critical section</Title>
    <Description>Hi Team

While troubleshooting slowness with our cloud service we noticed from the memory dump logs that the GatewayClientReceiver.FillBuffer() is taking time and might be executing in critical section which might also be blocking other threads. However when I look at the code it looks like only initialization logic for senders/receivers is getting executed in critical section. 
some of the stack trace from memory dump where we see that the thread have been stuck for a while:
```
0d clr!ObjectNative::WaitTimeout
0e mscorlib!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(Int32 UInt32 System.Threading.CancellationToken)
0f mscorlib!System.Threading.SemaphoreSlim.Wait(Int32 System.Threading.CancellationToken)
10 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTakeWithNoTimeValidation(System.__Canon ByRef Int32 System.Threading.CancellationToken System.Threading.CancellationTokenSource)
11 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTake(System.__Canon ByRef Int32 System.Threading.CancellationToken)
12 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].Take()
13 Orleans_Core!Orleans.Runtime.AsynchQueueAgent`1[[System.__Canon mscorlib]].RunNonBatching()
14 Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
```

```
06 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError ByRef)
07 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags)
08 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.FillBuffer(System.Collections.Generic.List`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt;)
09 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.Run()
0a Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
0b mscorlib!System.Threading.Tasks.Task.Execute()
0c mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0d mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0e mscorlib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
0f mscorlib!System.Threading.Tasks.Task.ExecuteEntry(Boolean)
10 mscorlib!System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
11 mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
12 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
13 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)
14 mscorlib!System.Threading.ThreadHelper.ThreadStart()
```
As it is difficult to find the real cause here we need a confirmation from you that the processing of messages (queuing and fillbuffer) should be executing well within the expected time.
Also should we reduce or increase the sizes of send/receive buffers to fine tune the performance considering that our application works in high load and sends/receives a lot of messages within Orleans cluster.
We are using Orleans 2.0.0 on Azure Cloud Service.</Description>
    <Title_Description>GatewayClientReceiver.FillBuffer() being slow and looks like executing in critical section Hi Team

While troubleshooting slowness with our cloud service we noticed from the memory dump logs that the GatewayClientReceiver.FillBuffer() is taking time and might be executing in critical section which might also be blocking other threads. However when I look at the code it looks like only initialization logic for senders/receivers is getting executed in critical section. 
some of the stack trace from memory dump where we see that the thread have been stuck for a while:
```
0d clr!ObjectNative::WaitTimeout
0e mscorlib!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(Int32 UInt32 System.Threading.CancellationToken)
0f mscorlib!System.Threading.SemaphoreSlim.Wait(Int32 System.Threading.CancellationToken)
10 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTakeWithNoTimeValidation(System.__Canon ByRef Int32 System.Threading.CancellationToken System.Threading.CancellationTokenSource)
11 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTake(System.__Canon ByRef Int32 System.Threading.CancellationToken)
12 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].Take()
13 Orleans_Core!Orleans.Runtime.AsynchQueueAgent`1[[System.__Canon mscorlib]].RunNonBatching()
14 Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
```

```
06 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError ByRef)
07 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags)
08 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.FillBuffer(System.Collections.Generic.List`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt;)
09 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.Run()
0a Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
0b mscorlib!System.Threading.Tasks.Task.Execute()
0c mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0d mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0e mscorlib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
0f mscorlib!System.Threading.Tasks.Task.ExecuteEntry(Boolean)
10 mscorlib!System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
11 mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
12 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
13 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)
14 mscorlib!System.Threading.ThreadHelper.ThreadStart()
```
As it is difficult to find the real cause here we need a confirmation from you that the processing of messages (queuing and fillbuffer) should be executing well within the expected time.
Also should we reduce or increase the sizes of send/receive buffers to fine tune the performance considering that our application works in high load and sends/receives a lot of messages within Orleans cluster.
We are using Orleans 2.0.0 on Azure Cloud Service.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4820</IssueLabelID>
    <Title>Separation of Transaction Manager and Transactional Resource</Title>
    <Description>Separation of Transaction Manager and Transactional Resource
- Remove transaction participant
- Full separation of tm and resource grain extensions.
- Grain references are used everwhere and cast to extensions where needed.

Next step: Add TOC support
</Description>
    <Title_Description>Separation of Transaction Manager and Transactional Resource Separation of Transaction Manager and Transactional Resource
- Remove transaction participant
- Full separation of tm and resource grain extensions.
- Grain references are used everwhere and cast to extensions where needed.

Next step: Add TOC support
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4819</IssueLabelID>
    <Title>Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.</Title>
    <Description>When I do the following setting Client will throw an exception..
```
.Configure&lt;SchedulingOptions&gt;(c =&gt;
{
    c.PerformDeadlockDetection = true;
})

at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
         at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
         at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
         at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
         at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
         at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43. Restarting gateway receiver for gwy.tcp://127.0.0.1:30000/0.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
fail: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[100026]
      Asynch agent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 encountered unexpected exception The Stage will be restarted.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
   at Orleans.Threading.FiltersApplicant`1.Apply(T action) in D:\Git\orleans\src\Orleans.Core\Threading\ActionFilter.cs:line 86</Description>
    <Title_Description>Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved. When I do the following setting Client will throw an exception..
```
.Configure&lt;SchedulingOptions&gt;(c =&gt;
{
    c.PerformDeadlockDetection = true;
})

at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
         at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
         at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
         at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
         at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
         at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43. Restarting gateway receiver for gwy.tcp://127.0.0.1:30000/0.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
fail: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[100026]
      Asynch agent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 encountered unexpected exception The Stage will be restarted.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
   at Orleans.Threading.FiltersApplicant`1.Apply(T action) in D:\Git\orleans\src\Orleans.Core\Threading\ActionFilter.cs:line 86</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4818</IssueLabelID>
    <Title>Grain can't be collection normally</Title>
    <Description>I set up the following：
```
...
.Configure&lt;GrainCollectionOptions&gt;(options =&gt;
{
    options.CollectionAge = TimeSpan.FromMinutes(1);

})
.UseDashboard(options =&gt; { options.Port = 9090; })
```
After the Grain is collection it can be seen through the Dashboardand has not been collection successfully.
I will not be able to activate these Grain again.
But if update SqlEventStorage.cs line 136 use Task.Run will not the problem.
This problem is very easy to happen if you introduce a third party library.

Example:
Startup need the postgresql and rabbitmq.
[Ray.git.zip](https://github.com/dotnet/orleans/files/2260031/Ray.git.zip)
</Description>
    <Title_Description>Grain can't be collection normally I set up the following：
```
...
.Configure&lt;GrainCollectionOptions&gt;(options =&gt;
{
    options.CollectionAge = TimeSpan.FromMinutes(1);

})
.UseDashboard(options =&gt; { options.Port = 9090; })
```
After the Grain is collection it can be seen through the Dashboardand has not been collection successfully.
I will not be able to activate these Grain again.
But if update SqlEventStorage.cs line 136 use Task.Run will not the problem.
This problem is very easy to happen if you introduce a third party library.

Example:
Startup need the postgresql and rabbitmq.
[Ray.git.zip](https://github.com/dotnet/orleans/files/2260031/Ray.git.zip)
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4816</IssueLabelID>
    <Title>[WIP] Add memory threshold</Title>
    <Description>A naive implementation that allows for configurable suppression of grain collection based on memory pressure.</Description>
    <Title_Description>[WIP] Add memory threshold A naive implementation that allows for configurable suppression of grain collection based on memory pressure.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4813</IssueLabelID>
    <Title>Bump code generation version to 2.0.4</Title>
    <Description>
    </Description>
    <Title_Description>Bump code generation version to 2.0.4 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4812</IssueLabelID>
    <Title>Build time codegen quite unstable on Orleans 2.x</Title>
    <Description>Hello folks 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact I've suffering since 2.0 release with multiple different issues with it. Some PR were made attempting to fix but which just failed.

I'm opening this issue in an attempt to bring team's attention to this matter as it is turning build time codegen practically unusable the way it is now.

As discussed with @ReubenBond it looks like the new codegen he is working is going to fix if not all the majority of those current issues but the work is on hold due to other team's priorities. 

It is a major block on multiple projects I'm working with so I would appreciate if Reuben have a bit more of time to dedicate to it. 

Thank you all!</Description>
    <Title_Description>Build time codegen quite unstable on Orleans 2.x Hello folks 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact I've suffering since 2.0 release with multiple different issues with it. Some PR were made attempting to fix but which just failed.

I'm opening this issue in an attempt to bring team's attention to this matter as it is turning build time codegen practically unusable the way it is now.

As discussed with @ReubenBond it looks like the new codegen he is working is going to fix if not all the majority of those current issues but the work is on hold due to other team's priorities. 

It is a major block on multiple projects I'm working with so I would appreciate if Reuben have a bit more of time to dedicate to it. 

Thank you all!</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4811</IssueLabelID>
    <Title>Errors from SiloHost</Title>
    <Description>Hello

I have a Silohost &amp; client running on local machine and connects through consul membership. Everything works fine but I was able to find below exceptions. What are these excepions? Do I need to fix something before these code move to higher environments?

{"Timestamp":"2018-08-01T17:00:58.0013497-05:00""Level":"Error""MessageTemplate":"Worker pool thread Runtime.Scheduler.WorkerPoolThread/3 (ManagedThreadId=40) has been busy for long time:
 Executing Task Id=97879 Status=Running for 00:00:59.7464953 on WorkItem=WorkItemGroup:Name=[Activation: S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+XXXXZ505@01be8caf
 #GrainType=XXXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]WorkGroupStatus=Running Executing for 00:00:59.7555196. WorkItemGroup Details: 
 WorkItemGroup:Name=[Activation: S10.XX.XX.XX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]
 WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed 
 SchedulingContext=&lt;[Activation: S10.XXX.XX.XXX:XXX:270856538*grn/9B57CB77/0000000000000000000000000000000006ffffff9b57cb77+17543CZ505-0x1E0EA515@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus 
 Placement=ActivationCountBasedPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=1 NumRunning=1 IdlenessTimeSpan=736906.22:00:58.0003454 
 CollectionAgeLimit=02:00:00 CurrentlyExecuting=NewPlacement Request XXX.XXX.XX.XX:XXX:270856538*cli/a64bf6b3@bf402085-&gt;S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf 
 #5: ]&gt;.""Properties":{"EventId":{"Id":101212}"SourceContext":"Runtime.Scheduler.WorkerPoolThread/3""Orleans":"XXXXXX""EnvironmentUserName":"XXXXX\\XXXXXX""MachineName":"XXXXXXX"
 "ProcessId":15836"ProcessName":"XXXX.XXXXX.Host""ThreadId":40}}
 
{"Timestamp":"2018-08-01T17:00:59.7092269-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. 
Last fired at 2018-08-01 22:00:42.396 GMT 00:00:17.3124134 since previous fire should have fired after 00:00:10.""Properties":{"EventId":{"Id":101412}"SourceContext":
"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"ProcessName":"XXXXX.XXXX.Host""ThreadId":40}}


{"Timestamp":"2018-08-01T17:01:03.2601117-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. 
Last fired at 2018-08-01 21:55:44.998 GMT 00:05:18.2619388 since previous fire should have fired after 00:05:00.""Properties":{"EventId":{"Id":101412}
"SourceContext":"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"
ProcessName":"XXXXX.XXXXX.Host""ThreadId":40}}
</Description>
    <Title_Description>Errors from SiloHost Hello

I have a Silohost &amp; client running on local machine and connects through consul membership. Everything works fine but I was able to find below exceptions. What are these excepions? Do I need to fix something before these code move to higher environments?

{"Timestamp":"2018-08-01T17:00:58.0013497-05:00""Level":"Error""MessageTemplate":"Worker pool thread Runtime.Scheduler.WorkerPoolThread/3 (ManagedThreadId=40) has been busy for long time:
 Executing Task Id=97879 Status=Running for 00:00:59.7464953 on WorkItem=WorkItemGroup:Name=[Activation: S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+XXXXZ505@01be8caf
 #GrainType=XXXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]WorkGroupStatus=Running Executing for 00:00:59.7555196. WorkItemGroup Details: 
 WorkItemGroup:Name=[Activation: S10.XX.XX.XX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]
 WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed 
 SchedulingContext=&lt;[Activation: S10.XXX.XX.XXX:XXX:270856538*grn/9B57CB77/0000000000000000000000000000000006ffffff9b57cb77+17543CZ505-0x1E0EA515@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus 
 Placement=ActivationCountBasedPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=1 NumRunning=1 IdlenessTimeSpan=736906.22:00:58.0003454 
 CollectionAgeLimit=02:00:00 CurrentlyExecuting=NewPlacement Request XXX.XXX.XX.XX:XXX:270856538*cli/a64bf6b3@bf402085-&gt;S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf 
 #5: ]&gt;.""Properties":{"EventId":{"Id":101212}"SourceContext":"Runtime.Scheduler.WorkerPoolThread/3""Orleans":"XXXXXX""EnvironmentUserName":"XXXXX\\XXXXXX""MachineName":"XXXXXXX"
 "ProcessId":15836"ProcessName":"XXXX.XXXXX.Host""ThreadId":40}}
 
{"Timestamp":"2018-08-01T17:00:59.7092269-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. 
Last fired at 2018-08-01 22:00:42.396 GMT 00:00:17.3124134 since previous fire should have fired after 00:00:10.""Properties":{"EventId":{"Id":101412}"SourceContext":
"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"ProcessName":"XXXXX.XXXX.Host""ThreadId":40}}


{"Timestamp":"2018-08-01T17:01:03.2601117-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. 
Last fired at 2018-08-01 21:55:44.998 GMT 00:05:18.2619388 since previous fire should have fired after 00:05:00.""Properties":{"EventId":{"Id":101412}
"SourceContext":"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"
ProcessName":"XXXXX.XXXXX.Host""ThreadId":40}}
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4810</IssueLabelID>
    <Title>Limited separation of transaction orchestration and participation.</Title>
    <Description>First pass at separating transaction orchestration (transaction manager) from participation (transactional resource).

Goal is to eventually be able to support a variety of transactional resources (state queues event sourcing ...) as well as advanced transactional patterns like Transfer of Commit (TOC).

This PR should have no behavioral changes only code reorganization.
- Added transaction manager and transactional resource interfaces
- Removed partial classes separating logic into a read/write lock and transaction queue transaction manager and transactional resource.

More work needs be done this is just a first pass.</Description>
    <Title_Description>Limited separation of transaction orchestration and participation. First pass at separating transaction orchestration (transaction manager) from participation (transactional resource).

Goal is to eventually be able to support a variety of transactional resources (state queues event sourcing ...) as well as advanced transactional patterns like Transfer of Commit (TOC).

This PR should have no behavioral changes only code reorganization.
- Added transaction manager and transactional resource interfaces
- Removed partial classes separating logic into a read/write lock and transaction queue transaction manager and transactional resource.

More work needs be done this is just a first pass.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4809</IssueLabelID>
    <Title>LightInject integration issue</Title>
    <Description>I am trying to use [LightInject ](https://github.com/seesharper/LightInject) as IoC container in Orleans Silo and on startup it throws an error `Common Language Runtime detected an invalid program`.

This looks like some issues with assembly loading and the root cause of it is that LightInject can't resolve `IOptionsFormatter&lt;&gt;` (which may be separate issue).

Tested with::
* Microsoft.Orleans.Server 2.0.3
* LightInject 5.1.5
* LightInject.Microsoft.DependencyInjection 2.0.7

Integration code looks like this:
```csharp
var container = new LightInject.ServiceContainer(opts);
var siloBuilder = new SiloHostBuilder()
    .UseServiceProviderFactory(services =&gt;
    {
        return container.CreateServiceProvider(services);
    })
```

Full stack:
```
at DynamicMethod(Object[] )
at LightInject.Microsoft.DependencyInjection.PerRootScopeLifetime.CreateScopedInstance(Func`1 createInstance)
at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
at DynamicMethod(Object[] )
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Runtime.SiloOptionsLogger.OnStart(CancellationToken token) in D:\build\agent\_work\18\s\src\Orleans.Runtime\OptionsLogger\OptionsLogger.cs:line 22
at Orleans.LifecycleExtensions.Observer.OnStart(CancellationToken ct)
at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 70
at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 103
at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 49
```
Dotnet info:
```
&gt; dotnet --info                                     
.NET Core SDK (reflecting any global.json):         
 Version:   2.1.300                                 
 Commit:    adab45bf0c                              
                                                    
Runtime Environment:                                
 OS Name:     Windows                               
 OS Version:  10.0.15063                            
 OS Platform: Windows                               
 RID:         win10-x64                             
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300\  
                                                    
Host (useful for support):                          
  Version: 2.1.0                                    
  Commit:  caa7b7e2ba                               
```
Full solution that can reproduce the issue can be found here:
https://github.com/n-sidorov/OreansLightInjectIssueRepro</Description>
    <Title_Description>LightInject integration issue I am trying to use [LightInject ](https://github.com/seesharper/LightInject) as IoC container in Orleans Silo and on startup it throws an error `Common Language Runtime detected an invalid program`.

This looks like some issues with assembly loading and the root cause of it is that LightInject can't resolve `IOptionsFormatter&lt;&gt;` (which may be separate issue).

Tested with::
* Microsoft.Orleans.Server 2.0.3
* LightInject 5.1.5
* LightInject.Microsoft.DependencyInjection 2.0.7

Integration code looks like this:
```csharp
var container = new LightInject.ServiceContainer(opts);
var siloBuilder = new SiloHostBuilder()
    .UseServiceProviderFactory(services =&gt;
    {
        return container.CreateServiceProvider(services);
    })
```

Full stack:
```
at DynamicMethod(Object[] )
at LightInject.Microsoft.DependencyInjection.PerRootScopeLifetime.CreateScopedInstance(Func`1 createInstance)
at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
at DynamicMethod(Object[] )
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Runtime.SiloOptionsLogger.OnStart(CancellationToken token) in D:\build\agent\_work\18\s\src\Orleans.Runtime\OptionsLogger\OptionsLogger.cs:line 22
at Orleans.LifecycleExtensions.Observer.OnStart(CancellationToken ct)
at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 70
at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 103
at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 49
```
Dotnet info:
```
&gt; dotnet --info                                     
.NET Core SDK (reflecting any global.json):         
 Version:   2.1.300                                 
 Commit:    adab45bf0c                              
                                                    
Runtime Environment:                                
 OS Name:     Windows                               
 OS Version:  10.0.15063                            
 OS Platform: Windows                               
 RID:         win10-x64                             
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300\  
                                                    
Host (useful for support):                          
  Version: 2.1.0                                    
  Commit:  caa7b7e2ba                               
```
Full solution that can reproduce the issue can be found here:
https://github.com/n-sidorov/OreansLightInjectIssueRepro</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4808</IssueLabelID>
    <Title>Remove the callchain information for the OneWay message</Title>
    <Description>Recently I've met a deadlock exception caused by a OneWay message. As far as I know the sender of the one-way message will not wailt for the response of the message. This means that even if the callee calls the function on the same grain the message will be added to the next position of messaging queue and will not cause a deadlock. So we should add a check on the line below if it is a OneWay message the call chain information should not be passed to next calls. 

https://github.com/dotnet/orleans/blob/e2b25a695767ae5746ffe47218c1331427997894/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L292

I don't know if I'm correct. If the thought is correct I will make a pull-request to fix it.</Description>
    <Title_Description>Remove the callchain information for the OneWay message Recently I've met a deadlock exception caused by a OneWay message. As far as I know the sender of the one-way message will not wailt for the response of the message. This means that even if the callee calls the function on the same grain the message will be added to the next position of messaging queue and will not cause a deadlock. So we should add a check on the line below if it is a OneWay message the call chain information should not be passed to next calls. 

https://github.com/dotnet/orleans/blob/e2b25a695767ae5746ffe47218c1331427997894/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L292

I don't know if I'm correct. If the thought is correct I will make a pull-request to fix it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4913</IssueLabelID>
    <Title>Add back .editorconfig</Title>
    <Description>This adds back the .editorconfig file from #3872 that was removed by #3963.
I fixed some bugs in the file (removed severity from formatting rules that don't support it) and changed all warnings to suggestions or even to "none" for some rules.
Changed some of the rules to better match the existing codebase but it's not always consistent so suggestions for style changes are welcome.</Description>
    <Title_Description>Add back .editorconfig This adds back the .editorconfig file from #3872 that was removed by #3963.
I fixed some bugs in the file (removed severity from formatting rules that don't support it) and changed all warnings to suggestions or even to "none" for some rules.
Changed some of the rules to better match the existing codebase but it's not always consistent so suggestions for style changes are welcome.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4911</IssueLabelID>
    <Title>Do not try to register GrainVersionStore if an implementation of IVersionStore is already registered</Title>
    <Description>Fix for #4855 </Description>
    <Title_Description>Do not try to register GrainVersionStore if an implementation of IVersionStore is already registered Fix for #4855 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4910</IssueLabelID>
    <Title>Access to declared state type in IGrainStorage</Title>
    <Description>The declared type of the grain state is not accessible via IGrainState.  The runtime type is however you can't determine the actual declared type. This causes problems when the state is of a derived type of the declared type.
e.g. in the IGrainStorage interface the only params you get about the state is IGrainState and if you need the declared type you're out of luck.

There's a hack available though. The implementation type of IGrainState is the internal ```GrainState&lt;&gt;```. so it is possible to extract the state type but it's not pretty.
something like this:
```
Type declaredStateType = grainState.GetType().GenericTypeArguments[0]
```
and hope the grainState runtime type doesn't change.

I can suggest two options:
1 - Add **DeclaredStateType** parameter to IGrainStorage methods.
2 - Add DeclaredStateType to IGrainState. This does make the grain state object bigger and I don't know other places using IGrainState. So if there's no benefit other than this I would stay with the hack or give it a second thought.

</Description>
    <Title_Description>Access to declared state type in IGrainStorage The declared type of the grain state is not accessible via IGrainState.  The runtime type is however you can't determine the actual declared type. This causes problems when the state is of a derived type of the declared type.
e.g. in the IGrainStorage interface the only params you get about the state is IGrainState and if you need the declared type you're out of luck.

There's a hack available though. The implementation type of IGrainState is the internal ```GrainState&lt;&gt;```. so it is possible to extract the state type but it's not pretty.
something like this:
```
Type declaredStateType = grainState.GetType().GenericTypeArguments[0]
```
and hope the grainState runtime type doesn't change.

I can suggest two options:
1 - Add **DeclaredStateType** parameter to IGrainStorage methods.
2 - Add DeclaredStateType to IGrainState. This does make the grain state object bigger and I don't know other places using IGrainState. So if there's no benefit other than this I would stay with the hack or give it a second thought.

</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4908</IssueLabelID>
    <Title>ManagementGrain.ForceActivationCollection with zero ageLimit causes undesired effects</Title>
    <Description>Calling ManagementGrain.ForceActivationCollection(TimeSpan.Zero) collects every grain including system grains and the ManagementGrain itself. Which effectively almost restarts the silo and causes the said grain call to timeout.

Shouldn't this exclude some grains (management grain pubsub etc.)? or at least make the TimeSpan.Zero value an invalid one? 

I can't think of a scenario where current behavior would be useful.
</Description>
    <Title_Description>ManagementGrain.ForceActivationCollection with zero ageLimit causes undesired effects Calling ManagementGrain.ForceActivationCollection(TimeSpan.Zero) collects every grain including system grains and the ManagementGrain itself. Which effectively almost restarts the silo and causes the said grain call to timeout.

Shouldn't this exclude some grains (management grain pubsub etc.)? or at least make the TimeSpan.Zero value an invalid one? 

I can't think of a scenario where current behavior would be useful.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4907</IssueLabelID>
    <Title>Propagate message serialization exceptions to callers</Title>
    <Description>Fixes #4793 

There are 6 scenarios being tested which can be summed up as `{Serialization Deserialization} exception sending to a {client grain} from a {client grain}` except I didn't add tests for the client-to-client cases (they go via silo anyway).

In the end there's similar logic for handling these exceptions in:
* `GatewayConnection.OnMessageSerializationFailure` - client to gateway (request)
* `InvokableObjectManager.LocalObjectMessagePumpAsync` - client to gateway (response)
* `Gateway.GatewaySender.OnMessageSerializationFailure` - gateway to client
* `SiloMessageSender.OnMessageSerializationFailure` - silo to silo

The client-to-gateway response scenarios are a little contrived since client objects are not supposed to be able to return `Task` or `Task&lt;T&gt;` only `void`. The code generator blocks `Task`/`Task&lt;T&gt;` for external users. Nevertheless it's worth adding tests for the scenario just in case and it helped to uncover some issues and places we could improve logging.</Description>
    <Title_Description>Propagate message serialization exceptions to callers Fixes #4793 

There are 6 scenarios being tested which can be summed up as `{Serialization Deserialization} exception sending to a {client grain} from a {client grain}` except I didn't add tests for the client-to-client cases (they go via silo anyway).

In the end there's similar logic for handling these exceptions in:
* `GatewayConnection.OnMessageSerializationFailure` - client to gateway (request)
* `InvokableObjectManager.LocalObjectMessagePumpAsync` - client to gateway (response)
* `Gateway.GatewaySender.OnMessageSerializationFailure` - gateway to client
* `SiloMessageSender.OnMessageSerializationFailure` - silo to silo

The client-to-gateway response scenarios are a little contrived since client objects are not supposed to be able to return `Task` or `Task&lt;T&gt;` only `void`. The code generator blocks `Task`/`Task&lt;T&gt;` for external users. Nevertheless it's worth adding tests for the scenario just in case and it helped to uncover some issues and places we could improve logging.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4906</IssueLabelID>
    <Title>Migrate DynamoDB transaction state provider to new interface</Title>
    <Description>DynamoDB was originally submitted and merge with #4056. It implemented the `ITransactionLogStorage` interface which no longer exists.

The provider project was deleted from the sources when transitioning to the distributed transaction manager (TM) which removed the ITransactionLogStorage.  The project can be reintroduced for a DynamoDB implementation of `ITransactionalStateStorage`.</Description>
    <Title_Description>Migrate DynamoDB transaction state provider to new interface DynamoDB was originally submitted and merge with #4056. It implemented the `ITransactionLogStorage` interface which no longer exists.

The provider project was deleted from the sources when transitioning to the distributed transaction manager (TM) which removed the ITransactionLogStorage.  The project can be reintroduced for a DynamoDB implementation of `ITransactionalStateStorage`.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/08/2018 11:33:27 PM +00:00</CreatedAt>
    <ClosedAt>29/11/2018 10:39:30 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4905</IssueLabelID>
    <Title>Add 2.1.0-beta1 to changelog</Title>
    <Description>
    </Description>
    <Title_Description>Add 2.1.0-beta1 to changelog </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4904</IssueLabelID>
    <Title>Remove ITransactionFaultInjector from src</Title>
    <Description>- Remove ITransactionFaultInjector from src. Fault are now injected into storage layer through FaultInjectedTransactionStateStorage implementations in test proj. 
- Remove MemoryConsistencyTests since we don't have a fault injection memory state storage for it to use yet. Can be added later. </Description>
    <Title_Description>Remove ITransactionFaultInjector from src - Remove ITransactionFaultInjector from src. Fault are now injected into storage layer through FaultInjectedTransactionStateStorage implementations in test proj. 
- Remove MemoryConsistencyTests since we don't have a fault injection memory state storage for it to use yet. Can be added later. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4901</IssueLabelID>
    <Title>Move actor identity content from 1.5 tutorials to grains section</Title>
    <Description>The content of the 1.5 tutorial "Actor Identity" contains information about grain IDs and no steps to accomplish a task. It should be put with other similar pages.

</Description>
    <Title_Description>Move actor identity content from 1.5 tutorials to grains section The content of the 1.5 tutorial "Actor Identity" contains information about grain IDs and no steps to accomplish a task. It should be put with other similar pages.

</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4900</IssueLabelID>
    <Title>API to access the default DeepCopier</Title>
    <Description>There should be a way to access the default copier from an `IExternalSerializer` implementation. That would be useful when only trying to override the serialization/deserialization behavior of a type.
And it should be possible to access the default serialization code when only overriding deep-copying is needed.</Description>
    <Title_Description>API to access the default DeepCopier There should be a way to access the default copier from an `IExternalSerializer` implementation. That would be useful when only trying to override the serialization/deserialization behavior of a type.
And it should be possible to access the default serialization code when only overriding deep-copying is needed.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4896</IssueLabelID>
    <Title>Activation address cache is not invalidated when only [OneWay] calls are used</Title>
    <Description>Scenario:

* Call `[OneWay]` methods on a grain from silo A
  * Activation is hosted on silo B
  * Activation is registered in directory partition on silo C 
* Deactivate that grain (eg by killing silo C) 
* Silo A will never learn that the grain has been destroyed and will keep messaging a non-existent activation (unsuccessfully unbeknownst to caller or calling silo)

</Description>
    <Title_Description>Activation address cache is not invalidated when only [OneWay] calls are used Scenario:

* Call `[OneWay]` methods on a grain from silo A
  * Activation is hosted on silo B
  * Activation is registered in directory partition on silo C 
* Deactivate that grain (eg by killing silo C) 
* Silo A will never learn that the grain has been destroyed and will keep messaging a non-existent activation (unsuccessfully unbeknownst to caller or calling silo)

</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4895</IssueLabelID>
    <Title>Use netcoreapp2.0 for msbuild target dll if using dotnet core msbuild but targeting full .net</Title>
    <Description>(Cherry-pick of #4689)

#4673 introduced a regression: when using the command `dotnet build` to build project that target the full .NET framework the variable for `CoreAssembly` is not set and the variable `TaskAssembly` depends on it.

The easiest workaround here is to always fallback to 2.0 dll

Maybe we could instead removing this task dependency and rely on the fact that we should find the `dotnet` command in the path @ReubenBond ?</Description>
    <Title_Description>Use netcoreapp2.0 for msbuild target dll if using dotnet core msbuild but targeting full .net (Cherry-pick of #4689)

#4673 introduced a regression: when using the command `dotnet build` to build project that target the full .NET framework the variable for `CoreAssembly` is not set and the variable `TaskAssembly` depends on it.

The easiest workaround here is to always fallback to 2.0 dll

Maybe we could instead removing this task dependency and rely on the fact that we should find the `dotnet` command in the path @ReubenBond ?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4894</IssueLabelID>
    <Title>Fixed build breaks from bad merge:</Title>
    <Description> - Constructor mismatches
 - Adde CurrentTransactionId to transaction context</Description>
    <Title_Description>Fixed build breaks from bad merge:  - Constructor mismatches
 - Adde CurrentTransactionId to transaction context</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4893</IssueLabelID>
    <Title>Build time codegen in 2.0.4 not working when using dotnet cli while targeting full .net framework</Title>
    <Description>We need to backport #4689 to fix this issue</Description>
    <Title_Description>Build time codegen in 2.0.4 not working when using dotnet cli while targeting full .net framework We need to backport #4689 to fix this issue</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4892</IssueLabelID>
    <Title>fixes 'placeholder page' issue for Grains section</Title>
    <Description>
    </Description>
    <Title_Description>fixes 'placeholder page' issue for Grains section </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/08/2018 3:12:44 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 11:29:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4891</IssueLabelID>
    <Title>Move actor identity content from 1.5 tutorials to grains section</Title>
    <Description>The 1.5 Tutorial page "Actor Identity" is informational not procedural - it should be included among other informational pages.</Description>
    <Title_Description>Move actor identity content from 1.5 tutorials to grains section The 1.5 Tutorial page "Actor Identity" is informational not procedural - it should be included among other informational pages.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4890</IssueLabelID>
    <Title>Feature per grain collection attribute</Title>
    <Description>
    </Description>
    <Title_Description>Feature per grain collection attribute </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4888</IssueLabelID>
    <Title>Fixes 'clusters and clients' similar to 'grains'</Title>
    <Description>
    </Description>
    <Title_Description>Fixes 'clusters and clients' similar to 'grains' </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4886</IssueLabelID>
    <Title>Moved the "This documentation is for the 2.0 release" section... </Title>
    <Description>… from Orleans Overview to main landing page (to keep content about documentation itself together)
- made some grammar and sentence structure edits
- verified links
</Description>
    <Title_Description>Moved the "This documentation is for the 2.0 release" section...  … from Orleans Overview to main landing page (to keep content about documentation itself together)
- made some grammar and sentence structure edits
- verified links
</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>24/08/2018 5:23:31 PM +00:00</CreatedAt>
    <ClosedAt>27/08/2018 7:43:01 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4885</IssueLabelID>
    <Title>What kind of scenario will the SiloName of the two nodes be the same?</Title>
    <Description>When I read the code I saw the following code from `Orleans.Runtime.MembershipService.MembershipOracle`.
```csharp
private async Task DetectNodeMigration(string myHostname)
{
    MembershipTableData table = await membershipTableProvider.ReadAll();

    string mySiloName = SiloName;
    MembershipEntry mostRecentPreviousEntry = null;
    foreach (MembershipEntry entry in table.Members.Select(tuple =&gt; tuple.Item1).Where(data =&gt; mySiloName.Equals(data.SiloName)))
    {
        bool iAmLater = MyAddress.Generation.CompareTo(entry.SiloAddress.Generation) &gt; 0;
        // more recent
        if (iAmLater &amp;&amp; (mostRecentPreviousEntry == null || entry.SiloAddress.Generation.CompareTo(mostRecentPreviousEntry.SiloAddress.Generation) &gt; 0))
            mostRecentPreviousEntry = entry;
    }

    if (mostRecentPreviousEntry != null)
    {
        bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !MyAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);
        if (physicalHostChanged)
        {
            string error = String.Format("Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}."
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.HostName mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeMigrated error);
        }
        else
        {
            string error = String.Format("Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}"
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeRestarted error);
        }
    }
}
```

This code first reads all the columns of the member table then select the entry with the same silo name as the current node.
But according to the code SiloName is generated by GUID.
So how can there be the same SiloName? Or what is the `DetectNodeMigration` method used to handle?</Description>
    <Title_Description>What kind of scenario will the SiloName of the two nodes be the same? When I read the code I saw the following code from `Orleans.Runtime.MembershipService.MembershipOracle`.
```csharp
private async Task DetectNodeMigration(string myHostname)
{
    MembershipTableData table = await membershipTableProvider.ReadAll();

    string mySiloName = SiloName;
    MembershipEntry mostRecentPreviousEntry = null;
    foreach (MembershipEntry entry in table.Members.Select(tuple =&gt; tuple.Item1).Where(data =&gt; mySiloName.Equals(data.SiloName)))
    {
        bool iAmLater = MyAddress.Generation.CompareTo(entry.SiloAddress.Generation) &gt; 0;
        // more recent
        if (iAmLater &amp;&amp; (mostRecentPreviousEntry == null || entry.SiloAddress.Generation.CompareTo(mostRecentPreviousEntry.SiloAddress.Generation) &gt; 0))
            mostRecentPreviousEntry = entry;
    }

    if (mostRecentPreviousEntry != null)
    {
        bool physicalHostChanged = !myHostname.Equals(mostRecentPreviousEntry.HostName) || !MyAddress.Endpoint.Equals(mostRecentPreviousEntry.SiloAddress.Endpoint);
        if (physicalHostChanged)
        {
            string error = String.Format("Silo {0} migrated from host {1} silo address {2} to host {3} silo address {4}."
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.HostName mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeMigrated error);
        }
        else
        {
            string error = String.Format("Silo {0} restarted on same host {1} New silo address = {2} Previous silo address = {3}"
                mySiloName myHostname MyAddress.ToLongString() mostRecentPreviousEntry.SiloAddress.ToLongString());
            logger.Warn(ErrorCode.MembershipNodeRestarted error);
        }
    }
}
```

This code first reads all the columns of the member table then select the entry with the same silo name as the current node.
But according to the code SiloName is generated by GUID.
So how can there be the same SiloName? Or what is the `DetectNodeMigration` method used to handle?</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4884</IssueLabelID>
    <Title>Event Hub checkpoint on shutdown</Title>
    <Description>Checkpoints don't seem to occur on silo shutdown. This results in re-processing events when a silo comes back up.

Maybe `EventHubQueueCache.Dispose() `should call `EventHubQueueCache.UpdateCheckpoint()`?
</Description>
    <Title_Description>Event Hub checkpoint on shutdown Checkpoints don't seem to occur on silo shutdown. This results in re-processing events when a silo comes back up.

Maybe `EventHubQueueCache.Dispose() `should call `EventHubQueueCache.UpdateCheckpoint()`?
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4877</IssueLabelID>
    <Title>Build-time code generation version 2.0.4 breaks docker builds</Title>
    <Description>When upgrading the `Microsoft.Orleans.OrleansCodeGenerator.Build` package to version 2.0.4 docker builds with the `microsoft/dotnet:2.1.401-sdk` base image start to fail with the error message below. Building on the host machine with the exact same commands as in the Dockerfile does not produce the error nor does running the project in an IDE. 

Downgrading to 2.0.3 fixes the issue. I tried to setup a simple project to reproduce but could not reproduce the exact issue so the problem may only appear in a complex solution with 10+ projects in it.

`/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(605): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly /root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/../tasks/netcoreapp2.1/Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask.`</Description>
    <Title_Description>Build-time code generation version 2.0.4 breaks docker builds When upgrading the `Microsoft.Orleans.OrleansCodeGenerator.Build` package to version 2.0.4 docker builds with the `microsoft/dotnet:2.1.401-sdk` base image start to fail with the error message below. Building on the host machine with the exact same commands as in the Dockerfile does not produce the error nor does running the project in an IDE. 

Downgrading to 2.0.3 fixes the issue. I tried to setup a simple project to reproduce but could not reproduce the exact issue so the problem may only appear in a complex solution with 10+ projects in it.

`/root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/Microsoft.Orleans.OrleansCodeGenerator.Build.targets(605): error MSB4062: The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded from the assembly /root/.nuget/packages/microsoft.orleans.orleanscodegenerator.build/2.0.4/build/../tasks/netcoreapp2.1/Orleans.CodeGeneration.Build.dll. Assembly with same name is already loaded Confirm that the &lt;UsingTask&gt; declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements Microsoft.Build.Framework.ITask.`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4876</IssueLabelID>
    <Title>Fix DI cycle involving OrleansJsonSerializer</Title>
    <Description>Fixes #4873</Description>
    <Title_Description>Fix DI cycle involving OrleansJsonSerializer Fixes #4873</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4875</IssueLabelID>
    <Title>Revisit silo stop/shutdown timeout</Title>
    <Description>
    </Description>
    <Title_Description>Revisit silo stop/shutdown timeout </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4874</IssueLabelID>
    <Title>Add storage exception injection logic into fault injection test runner</Title>
    <Description>Adding fault injection test case
- inject storage exception before store during Prepare
- inject storage exception after store during Prepare 
- inject storage exception before store during Confirm
- inject storage exception after store during Confirm
- inject storage exception before store during PrepareAndCommit
- inject storage exception after store during PrepareAndCommit

injecting exception before store simulates situation that state update failed to persist
injecting exception after store simulates situation that state update succeed to persist but runtime think it failed

currently all tests failed... I don't think I have a test logic issue. But please give me a second eye. </Description>
    <Title_Description>Add storage exception injection logic into fault injection test runner Adding fault injection test case
- inject storage exception before store during Prepare
- inject storage exception after store during Prepare 
- inject storage exception before store during Confirm
- inject storage exception after store during Confirm
- inject storage exception before store during PrepareAndCommit
- inject storage exception after store during PrepareAndCommit

injecting exception before store simulates situation that state update failed to persist
injecting exception after store simulates situation that state update succeed to persist but runtime think it failed

currently all tests failed... I don't think I have a test logic issue. But please give me a second eye. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4873</IssueLabelID>
    <Title>StackOverflowException when adding OrleansJsonSerializer as a SerializationProvider</Title>
    <Description>Workaround: use this gist instead https://gist.github.com/ReubenBond/45ef767aff071302ee62731b5c706dd7

Repro:
```C#
var client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
var s = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();

var silo = new SiloHostBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
s = silo.Services.GetRequiredService&lt;SerializationManager&gt;();
```

Only the silo fails the client doesn't have a dependency cycle.</Description>
    <Title_Description>StackOverflowException when adding OrleansJsonSerializer as a SerializationProvider Workaround: use this gist instead https://gist.github.com/ReubenBond/45ef767aff071302ee62731b5c706dd7

Repro:
```C#
var client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
var s = client.ServiceProvider.GetRequiredService&lt;SerializationManager&gt;();

var silo = new SiloHostBuilder()
    .Configure&lt;ClusterOptions&gt;(o =&gt; o.ClusterId = o.ServiceId = "s")
    .UseLocalhostClustering()
    .Configure&lt;SerializationProviderOptions&gt;(o =&gt;
        o.SerializationProviders.Add(typeof(OrleansJsonSerializer).GetTypeInfo()))
    .Build();
s = silo.Services.GetRequiredService&lt;SerializationManager&gt;();
```

Only the silo fails the client doesn't have a dependency cycle.</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4872</IssueLabelID>
    <Title>No menu topic for Streaming after restructuring of docs</Title>
    <Description>
    </Description>
    <Title_Description>No menu topic for Streaming after restructuring of docs </Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4871</IssueLabelID>
    <Title>Rename UseDistributedTM to UseTransactions</Title>
    <Description>fix issue #4688 </Description>
    <Title_Description>Rename UseDistributedTM to UseTransactions fix issue #4688 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4870</IssueLabelID>
    <Title>Remove documentation sources</Title>
    <Description>I moved documentation sources to the docs branch so that we completely separate them from the generated html output. The goal is to move them to a separate repo altogether.

This is to delete doc sources from the gh-pages branch to prevent duplication and potential confusion.</Description>
    <Title_Description>Remove documentation sources I moved documentation sources to the docs branch so that we completely separate them from the generated html output. The goal is to move them to a separate repo altogether.

This is to delete doc sources from the gh-pages branch to prevent duplication and potential confusion.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4868</IssueLabelID>
    <Title>Should not need `.AsReference&lt;&gt;` when returning a grain</Title>
    <Description>I have a bit of code in the Registry pattern:

```
        public async Task&lt;IRegistryGrain&lt;TGrain&gt;&gt; RegisterGrain(TGrain grain)
        {
            if (State == null)
            {
                State = new HashSet&lt;TGrain&gt;();
            }

            State.Add(grain);
            await WriteStateAsync();

            return this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();
        }
```

If I just `return this;` instead of `this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();` I get an exception saying serialization failed.

Is this an edge case that got missed for grain checking?</Description>
    <Title_Description>Should not need `.AsReference&lt;&gt;` when returning a grain I have a bit of code in the Registry pattern:

```
        public async Task&lt;IRegistryGrain&lt;TGrain&gt;&gt; RegisterGrain(TGrain grain)
        {
            if (State == null)
            {
                State = new HashSet&lt;TGrain&gt;();
            }

            State.Add(grain);
            await WriteStateAsync();

            return this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();
        }
```

If I just `return this;` instead of `this.AsReference&lt;IRegistryGrain&lt;TGrain&gt;&gt;();` I get an exception saying serialization failed.

Is this an edge case that got missed for grain checking?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4867</IssueLabelID>
    <Title>Avoiding the OrleansAdoNetContent folder</Title>
    <Description>The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans but not for an established project. In my case the files are possibly harmful as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Description>
    <Title_Description>Avoiding the OrleansAdoNetContent folder The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans but not for an established project. In my case the files are possibly harmful as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4866</IssueLabelID>
    <Title>Minio grain storage provider</Title>
    <Description>I made a grain storage provider implementation with [Minio](https://www.minio.io/) which is a free  open source distributed object storage.

The implementation currently resides as code on [my repository](https://github.com/Kimserey/orleans-minio) under [/OrleansMinio](https://github.com/Kimserey/orleans-minio/tree/master/OrleansMinio) which I would like to PR into Orleans. I just don't know how to proceed. 

https://github.com/Kimserey/orleans-minio

If someone could guide me by answering the following questions:

1. Is it something you see worth PR'ing? If it isn't we can close this question.
_Minio is useful for me as I wish to not be tied to cloud providers services and prefer rely on free open source solutions._
2. How should I proceed? Are there any guidelines as I see other grain storages are within folder that are _linked files_ to _/shared_.

Thanks!</Description>
    <Title_Description>Minio grain storage provider I made a grain storage provider implementation with [Minio](https://www.minio.io/) which is a free  open source distributed object storage.

The implementation currently resides as code on [my repository](https://github.com/Kimserey/orleans-minio) under [/OrleansMinio](https://github.com/Kimserey/orleans-minio/tree/master/OrleansMinio) which I would like to PR into Orleans. I just don't know how to proceed. 

https://github.com/Kimserey/orleans-minio

If someone could guide me by answering the following questions:

1. Is it something you see worth PR'ing? If it isn't we can close this question.
_Minio is useful for me as I wish to not be tied to cloud providers services and prefer rely on free open source solutions._
2. How should I proceed? Are there any guidelines as I see other grain storages are within folder that are _linked files_ to _/shared_.

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>22/08/2018 12:02:12 PM +00:00</CreatedAt>
    <ClosedAt>5/09/2018 7:24:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4865</IssueLabelID>
    <Title>Await tasks in DedicatedAsynchAgent.Run()</Title>
    <Description>Source description in gitter:
&gt; I'm discovering the internal of orleans' runtime and I found that `DedicatedAsynchAgent.Run()`'s return type is void so its implements all can not be awaited. So is it safe to make DedicatedAsynchAgent.Run() awaitable(return a Task)? I want to try System.IO.Pipelines and System.Threading.Channels in Orleans which are designed to reactivate by async/wait pattern

There are some ambiguities in my description so I'll try to explain it more clearly

### Intention
I'm learning about orleans' internal and wanna try out some new .NET Core features like `System.IO.Pipelines` and `System.Threading.Channels`  in orleans.
Pipelines for sockets communication and Channels for internal message queue.
(There are already some great work by @JanEggers in https://github.com/dotnet/orleans/issues/3617#issuecomment-352587339)

### What's The Problem
The readers/writers in Pipelines/Channels are reactivate which means when pipes/channels are empty they will suspend readers and awaken them after data arrived in without blocking the current thread. This is implemented by Tasks and async/await.
I want to achieve these "awaitable" behavior in `IncomingMessageAgent.Run()`(For polling/posting message from/to channels) but couldn't because `DedicatedAsynchAgent.Run()` returns void.

At first I simply change `DedicatedAsynchAgent.Run()` to return a task and enqueue async delegate to thread executor instead:
``` csharp
internal abstract class DedicatedAsynchAgent : AsynchAgent
{
    public override void OnStart()
    {
        executor.QueueWorkItem(async _ =&gt; await Run());
    }
    protected abstract Task Run();
}
```
Or start a new task like [what `IncomingMessageAcceptor.ProcessAccept` does](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L353):
``` csharp
Task.Factory.StartNew(async () =&gt;
{
    await DoWork();
});
```
**BUT**: 
a) What `DedicatedAsynchAgent.Run()`s do is to enqueue a delegate to a specific Thread so it seems there's no meaning for "un-blocking" this thread.
b) await in async delegate will lead to the remaining code to enter a .Net thread pool thread.

### What I Want To Know
* Why `DedicatedAsynchAgent` uses the custom `ThreadPoolExecutor` rather than just start a job/task in the .NET thread pool.
* If it is safe to execute DedicatedAsynchAgent logic out of its ThreadPoolExecutor's thread.


PS.
*There may be some misunderstanding about ThreadPoolExecutor/AsynchAgent/Async-Await ... I'm glad to be corrected.*
*It's so much fun to read Orleans' source code what you people did is fantastic*</Description>
    <Title_Description>Await tasks in DedicatedAsynchAgent.Run() Source description in gitter:
&gt; I'm discovering the internal of orleans' runtime and I found that `DedicatedAsynchAgent.Run()`'s return type is void so its implements all can not be awaited. So is it safe to make DedicatedAsynchAgent.Run() awaitable(return a Task)? I want to try System.IO.Pipelines and System.Threading.Channels in Orleans which are designed to reactivate by async/wait pattern

There are some ambiguities in my description so I'll try to explain it more clearly

### Intention
I'm learning about orleans' internal and wanna try out some new .NET Core features like `System.IO.Pipelines` and `System.Threading.Channels`  in orleans.
Pipelines for sockets communication and Channels for internal message queue.
(There are already some great work by @JanEggers in https://github.com/dotnet/orleans/issues/3617#issuecomment-352587339)

### What's The Problem
The readers/writers in Pipelines/Channels are reactivate which means when pipes/channels are empty they will suspend readers and awaken them after data arrived in without blocking the current thread. This is implemented by Tasks and async/await.
I want to achieve these "awaitable" behavior in `IncomingMessageAgent.Run()`(For polling/posting message from/to channels) but couldn't because `DedicatedAsynchAgent.Run()` returns void.

At first I simply change `DedicatedAsynchAgent.Run()` to return a task and enqueue async delegate to thread executor instead:
``` csharp
internal abstract class DedicatedAsynchAgent : AsynchAgent
{
    public override void OnStart()
    {
        executor.QueueWorkItem(async _ =&gt; await Run());
    }
    protected abstract Task Run();
}
```
Or start a new task like [what `IncomingMessageAcceptor.ProcessAccept` does](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L353):
``` csharp
Task.Factory.StartNew(async () =&gt;
{
    await DoWork();
});
```
**BUT**: 
a) What `DedicatedAsynchAgent.Run()`s do is to enqueue a delegate to a specific Thread so it seems there's no meaning for "un-blocking" this thread.
b) await in async delegate will lead to the remaining code to enter a .Net thread pool thread.

### What I Want To Know
* Why `DedicatedAsynchAgent` uses the custom `ThreadPoolExecutor` rather than just start a job/task in the .NET thread pool.
* If it is safe to execute DedicatedAsynchAgent logic out of its ThreadPoolExecutor's thread.


PS.
*There may be some misunderstanding about ThreadPoolExecutor/AsynchAgent/Async-Await ... I'm glad to be corrected.*
*It's so much fun to read Orleans' source code what you people did is fantastic*</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4862</IssueLabelID>
    <Title>[Question] Orleans Event Sourcing snapshots of event log</Title>
    <Description>I have a JournaledGrain which I am persisting events through the attribute [LogConsistencyProvider(ProviderName = "LogStorage")]. Since this grain will handle heavy load hydrating the grain every time with all the events can result in a performance bottleneck. As a result snapshot are one alternative to this problem by hydrating events since the latest snapshot only. Is there is a way to handle snapshots in Orleans Event Sourcing?

I am using MongoDB to persist the data.</Description>
    <Title_Description>[Question] Orleans Event Sourcing snapshots of event log I have a JournaledGrain which I am persisting events through the attribute [LogConsistencyProvider(ProviderName = "LogStorage")]. Since this grain will handle heavy load hydrating the grain every time with all the events can result in a performance bottleneck. As a result snapshot are one alternative to this problem by hydrating events since the latest snapshot only. Is there is a way to handle snapshots in Orleans Event Sourcing?

I am using MongoDB to persist the data.</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4861</IssueLabelID>
    <Title>No default grains storage added to container if one is not configured.</Title>
    <Description>Addresses - IGrainStorage null implementation registerd in DI container #4710</Description>
    <Title_Description>No default grains storage added to container if one is not configured. Addresses - IGrainStorage null implementation registerd in DI container #4710</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4860</IssueLabelID>
    <Title>Minimal TOC</Title>
    <Description>Minimal transfer of coordintation support for transactions.
- TransactionCommitter facet
- Changed to commit logic to commit only upon successfull remot service call.
- Minima golden path tests</Description>
    <Title_Description>Minimal TOC Minimal transfer of coordintation support for transactions.
- TransactionCommitter facet
- Changed to commit logic to commit only upon successfull remot service call.
- Minima golden path tests</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4859</IssueLabelID>
    <Title>Silo with EFCore Lazy Loading failed to catch System.ExecutionEngineException and crash silently</Title>
    <Description>* Orleans.Server: 2.0.4
* EntityFrameworkCore: 2.1.1

I'm using EF Core and enable Lazy Loading for grain to store data.
When I use the EF entity proxy object as a return value for grain method it will throw a `System.ExecutionEngineException`in `unknown module` and silo fails to catch it and crash without any error message until you debug it.
It looks like crash in `ILBasedSerializer` while deep copying the return object.

The best practice is map the entity to a dto and return but it shouldn't causing exception if you return the proxy object directly in ASP.NET Core when you return a EF Core proxy entity to the browser(Or serialize to json) it will works(just get an extra json key `LazyLoader: {}`).</Description>
    <Title_Description>Silo with EFCore Lazy Loading failed to catch System.ExecutionEngineException and crash silently * Orleans.Server: 2.0.4
* EntityFrameworkCore: 2.1.1

I'm using EF Core and enable Lazy Loading for grain to store data.
When I use the EF entity proxy object as a return value for grain method it will throw a `System.ExecutionEngineException`in `unknown module` and silo fails to catch it and crash without any error message until you debug it.
It looks like crash in `ILBasedSerializer` while deep copying the return object.

The best practice is map the entity to a dto and return but it shouldn't causing exception if you return the proxy object directly in ASP.NET Core when you return a EF Core proxy entity to the browser(Or serialize to json) it will works(just get an extra json key `LazyLoader: {}`).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4858</IssueLabelID>
    <Title>Orleans.Transactions.TransactionInfo not in Core</Title>
    <Description>When a transaction aborts for whatever reason the exception that is serialized contains the Orleans.Transactions.TransactionInfo type.  That type is in Orleans.Transactions not in Orleans.Core so if the client doesn't reference the transactions package it fails to deserialize the exception (which unfortunately causes a grain timeout exception instead of a failed to deserialize exception to be delivered to the caller).</Description>
    <Title_Description>Orleans.Transactions.TransactionInfo not in Core When a transaction aborts for whatever reason the exception that is serialized contains the Orleans.Transactions.TransactionInfo type.  That type is in Orleans.Transactions not in Orleans.Core so if the client doesn't reference the transactions package it fails to deserialize the exception (which unfortunately causes a grain timeout exception instead of a failed to deserialize exception to be delivered to the caller).</Title_Description>
    <Label>P1</Label>
    <Assignee>xiazen</Assignee>
    <CreatedAt>17/08/2018 11:32:25 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4855</IssueLabelID>
    <Title>[Question] about GrainStorage and the internal VersionStoreGrain</Title>
    <Description>I'm writing a storage provider using efcore. 
The provider works against a configured dbcontext which means any type being used as storage should have a corresponding DbSet&lt;&gt; on the context. So arbitrary types are not welcomed here as the backing storage is not happy with them (SQL Server for example).

Now the problem raises If the provider is used as the default grain storage. This causes the internal ```VersionStoreGrain``` to malfunction because of the not configured ```VersionStoreGrainState```. 
Since the ```IVersionStoreGrain``` is an internal interface I can't add another implementation for it (Haven't really thought about if it's a good idea or not).

So to summarize my options:
- Provide another implementation for IVersionStoreGrain (which is not doable cause everything in there is internal)
- Handle ```VersionStoreGrainState``` differently. This probably suggest an internal dbcontext to handle Orleans related stuff. Which also causes the provider to break if I'm missing another internal type.
- Handle arbitrary types using a fallback provider or a key-value table.
- Don't allow the provider to be used as the default storage.

I know using entity framework inherently suggest that arbitrary types can't be used but for this to work it should be able to be used as the only grain storage provider in the silo.

I'll probably go with option 3 with my current knowledge of Orleans. Any advice is very appreciated. I'm gonna open source this as soon as I finish this and write more tests.</Description>
    <Title_Description>[Question] about GrainStorage and the internal VersionStoreGrain I'm writing a storage provider using efcore. 
The provider works against a configured dbcontext which means any type being used as storage should have a corresponding DbSet&lt;&gt; on the context. So arbitrary types are not welcomed here as the backing storage is not happy with them (SQL Server for example).

Now the problem raises If the provider is used as the default grain storage. This causes the internal ```VersionStoreGrain``` to malfunction because of the not configured ```VersionStoreGrainState```. 
Since the ```IVersionStoreGrain``` is an internal interface I can't add another implementation for it (Haven't really thought about if it's a good idea or not).

So to summarize my options:
- Provide another implementation for IVersionStoreGrain (which is not doable cause everything in there is internal)
- Handle ```VersionStoreGrainState``` differently. This probably suggest an internal dbcontext to handle Orleans related stuff. Which also causes the provider to break if I'm missing another internal type.
- Handle arbitrary types using a fallback provider or a key-value table.
- Don't allow the provider to be used as the default storage.

I know using entity framework inherently suggest that arbitrary types can't be used but for this to work it should be able to be used as the only grain storage provider in the silo.

I'll probably go with option 3 with my current knowledge of Orleans. Any advice is very appreciated. I'm gonna open source this as soon as I finish this and write more tests.</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4853</IssueLabelID>
    <Title>Do not place stateless worker locally if the silo is stopping</Title>
    <Description>Fix for #4852 and #4757 </Description>
    <Title_Description>Do not place stateless worker locally if the silo is stopping Fix for #4852 and #4757 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4852</IssueLabelID>
    <Title>Revisit handling of StatelessWorker grains during shutdown</Title>
    <Description>Base on the feedback in #4757 we need to reconsider how StatelessWorker grains are handled during silo shutdown.</Description>
    <Title_Description>Revisit handling of StatelessWorker grains during shutdown Base on the feedback in #4757 we need to reconsider how StatelessWorker grains are handled during silo shutdown.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4851</IssueLabelID>
    <Title>transaction consistency tests and error injection</Title>
    <Description>the consistency tests I have been using for testing the transaction implementation.

- includes a test runner that runs randomized transaction tests using various scale and randomization settings.  Running all of those takes a long time (because of the large number of tests and the volume of the tests) but this is sort of intentional for this type of test (random testing is quite good at discovering subtle race conditions if run with enough volume).

- each consistency test records a lot of data while executing the random transactions (state version numbers read &amp; written by each transaction for each grain)  that is checked for serializability in the end. Also I check if any exceptions encountered are expected for the type of test being run. For example there should not be any transient exceptions under low congestion and when avoiding deadlocks and there should not be any unknown exceptions when storage injection is off.

- These tests can run with or without fault injection. 

- The fault injector randomly injects three kinds of exceptions:
    - an uninterpreted exception before or after writing to storage
    - an InconsistentStateException before writing to storage</Description>
    <Title_Description>transaction consistency tests and error injection the consistency tests I have been using for testing the transaction implementation.

- includes a test runner that runs randomized transaction tests using various scale and randomization settings.  Running all of those takes a long time (because of the large number of tests and the volume of the tests) but this is sort of intentional for this type of test (random testing is quite good at discovering subtle race conditions if run with enough volume).

- each consistency test records a lot of data while executing the random transactions (state version numbers read &amp; written by each transaction for each grain)  that is checked for serializability in the end. Also I check if any exceptions encountered are expected for the type of test being run. For example there should not be any transient exceptions under low congestion and when avoiding deadlocks and there should not be any unknown exceptions when storage injection is off.

- These tests can run with or without fault injection. 

- The fault injector randomly injects three kinds of exceptions:
    - an uninterpreted exception before or after writing to storage
    - an InconsistentStateException before writing to storage</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4850</IssueLabelID>
    <Title>Fix NullReferenceException in ExecutingWorkItemsTracker</Title>
    <Description>I hit a `NullReferenceException` here while debugging #4617.

The root cause was the order of initialization of `log` and `executingWorkTracker` in the `ThreadPoolExecutor` constructor.

This PR fixes that adds some defensiveness and cleans up the code a little.</Description>
    <Title_Description>Fix NullReferenceException in ExecutingWorkItemsTracker I hit a `NullReferenceException` here while debugging #4617.

The root cause was the order of initialization of `log` and `executingWorkTracker` in the `ThreadPoolExecutor` constructor.

This PR fixes that adds some defensiveness and cleans up the code a little.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4847</IssueLabelID>
    <Title>Why is it that only the last Silo suspected of P can declare its death?</Title>
    <Description>If the successor node ABC of P starts at intervals then it is possible that A suspects P writes; B suspects P writes; C suspects P writes and in such a dead cycle can not really declare P's death.</Description>
    <Title_Description>Why is it that only the last Silo suspected of P can declare its death? If the successor node ABC of P starts at intervals then it is possible that A suspects P writes; B suspects P writes; C suspects P writes and in such a dead cycle can not really declare P's death.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4846</IssueLabelID>
    <Title>Repair typesetting error</Title>
    <Description>Repair typesetting error.</Description>
    <Title_Description>Repair typesetting error Repair typesetting error.</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4844</IssueLabelID>
    <Title>Fix partial build</Title>
    <Description>Tentative to bring #4740 to the master branch</Description>
    <Title_Description>Fix partial build Tentative to bring #4740 to the master branch</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4843</IssueLabelID>
    <Title>Orleans Health Check</Title>
    <Description>We are running Orleans on a Kubernetes cluster.

What is the recommended way to set up readiness/liveliness (health) checks on silos?
</Description>
    <Title_Description>Orleans Health Check We are running Orleans on a Kubernetes cluster.

What is the recommended way to set up readiness/liveliness (health) checks on silos?
</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4842</IssueLabelID>
    <Title>Orleans.Runtime.OrleansException: Not connected to a gateway when reconnecting to a local silo</Title>
    <Description>I'm just playing with Orleans and one of the basics and I tried the 2.0 sample app.

I started the client before the silo (intentionally) just to see if the retry policy outlined there would work. The client connected but then immediately failed with the error I'm pasting below.

Steps to reproduce:

1. Use the [Hello world sample](https://github.com/dotnet/orleans/tree/master/Samples/2.0/HelloWorld)
1. Start the client
1. Start the silo (after the client has been started)
1. Observe the log output to see the exception

Expected behaviour:
I would expect the client to successfully reconnect and perform operations normally. Is this something that is supposed to work or am I expecting too much? Let me know if you need more details on the setup.

Log output:

&lt;details&gt;
  &lt;summary&gt;Expand log content&lt;/summary&gt;

```
$ dotnet run --project src/OrleansClient/OrleansClient.csproj
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on Petarda.local at 172.16.1.50 Client Id = *cli/c3e0439a ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.3. Commit Hash: c5432c1809a37f12142fb1c489fb0a4f77ed3bda (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=OrleansClient&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/c3e0439a@28c5cba1 #2:
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Retrying ...
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
Cluster client failed to connect to cluster with unexpected error.  Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at OrleansClient.Program.StartClientWithRetries() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 59
   at OrleansClient.Program.RunMainAsync() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 29
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:40
```
&lt;/details&gt;</Description>
    <Title_Description>Orleans.Runtime.OrleansException: Not connected to a gateway when reconnecting to a local silo I'm just playing with Orleans and one of the basics and I tried the 2.0 sample app.

I started the client before the silo (intentionally) just to see if the retry policy outlined there would work. The client connected but then immediately failed with the error I'm pasting below.

Steps to reproduce:

1. Use the [Hello world sample](https://github.com/dotnet/orleans/tree/master/Samples/2.0/HelloWorld)
1. Start the client
1. Start the silo (after the client has been started)
1. Observe the log output to see the exception

Expected behaviour:
I would expect the client to successfully reconnect and perform operations normally. Is this something that is supposed to work or am I expecting too much? Let me know if you need more details on the setup.

Log output:

&lt;details&gt;
  &lt;summary&gt;Expand log content&lt;/summary&gt;

```
$ dotnet run --project src/OrleansClient/OrleansClient.csproj
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on Petarda.local at 172.16.1.50 Client Id = *cli/c3e0439a ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.3. Commit Hash: c5432c1809a37f12142fb1c489fb0a4f77ed3bda (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=OrleansClient&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/c3e0439a@28c5cba1 #2:
Cluster client attempt 1 of 5 failed to connect to cluster.  Exception: Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/c3e0439a@28c5cba1-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Retrying ...
warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:30
Cluster client failed to connect to cluster with unexpected error.  Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
Exception: Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetGrainTypeResolver(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;b__58_2()
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;g__ExecuteWithRetries58_3(Func`1 task Func`2 shouldRetry)
   at Orleans.OutsideRuntimeClient.StartInternal(Func`2 retryFilter)
   at Orleans.OutsideRuntimeClient.Start(Func`2 retryFilter)
   at Orleans.ClusterClient.Connect(Func`2 retryFilter)
   at OrleansClient.Program.StartClientWithRetries() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 59
   at OrleansClient.Program.RunMainAsync() in /Users/miha/work/dev/Orleans-Docker/src/OrleansClient/Program.cs:line 29
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 08/10/2018 22:41:40
```
&lt;/details&gt;</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4841</IssueLabelID>
    <Title>Ignore ambiguous transactions in correctness testing.</Title>
    <Description>Updated transaction correctness/recoverability tests to not check results against client expectations if transaction success was ambiguous.</Description>
    <Title_Description>Ignore ambiguous transactions in correctness testing. Updated transaction correctness/recoverability tests to not check results against client expectations if transaction success was ambiguous.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4839</IssueLabelID>
    <Title>Namespace property removed from ImplicitStreamSubscriptionAttribute in 1.5</Title>
    <Description>From [gitter chat here](https://gitter.im/dotnet/orleans?at=5b6bf2c9e9b96f2c98e36bec)

We started to migrate 1.4 -&gt; 1.5 (2.0 deemed too big rework and too many breaking changes)
and discovered that we need to make some changes in our code base. They are more or less reasonable like DI for constructors and some removed defaults. There is one change in 1.5 that looks strange and unreasonable and I'd like to understand what was the reasoning behind it:

Previously (in 1.4) `ImplicitStreamSubscriptionAttribute` has a public `Namespace` property on it and it was quite nice way to use subscription attribute itself to subscribe instance of the class to streams:
we are using reflection to create shared code in `BaseStreamListener` class which simply reflected over attributes and produced the list of "namespaces" to subscribe - thus we have centralized way to subscribe to the stream in base class - reusable piece of logic.
in 1.5. `Namespace` property was replaced by `Predicate` and  for simple scenario like ours - all what we need is to pass namespace string in ctor which then will be converted to `ExactMatchStreamNamespacePredicate` (which design is also leaves question as it's internal and doesn't expose any helpful information to subscribe to streams in the stream listening classes).

From my understanding - we still need to subscribe instance to the stream in runtime and call something like this:
```
foreach(var streamNamespace in allNamespaces)
  var inputStream = StreamFactory.GetStream&lt;TMessageType&gt;(primaryKey streamProvider streamNamespace);
   var handle = await inputStream.SubscribeAsync(ReceiveCommand OnCommandError OnCommandCompleted);
  _streams.Add(inputStream);
  _handles.Add(handle);
}
``` 
At least this is how we are working with streams in 1.4.

In _raw_ Orleans 1.5 we need to add `ImplicitStreamSubscription("fooNamespace")` attribute to the class but ALSO to keep a separate collection of namespaces to subscribe in runtime like in above example. It feels that this is not a well-thought decision and some practical functionality was removed without adding any obvious way to achieve the same results.

In 1.4. we don't need to maintain any separate collection - it was beautifully simple to scrap all string values from attributes on the class:
```
    protected virtual IEnumerable&lt;string&gt; getNamespacesFromAttributes()
    {
            var allNamespaces = this.GetType()
                .GetCustomAttributes(typeof(ImplicitStreamSubscriptionAttribute) false)
                .Select(attrib =&gt; ((ImplicitStreamSubscriptionAttribute) attrib).Namespace)
                .ToList();

            return allNamespaces;
    }
```
and the attributes on top of the class were a single source of truth for namespaces this stream is subscribed to.

We can simply add back this functionality by creating
```
/// &lt;summary&gt;
	/// The reason why this class exists is that between 1.4 and 1.5 ImplicitStreamSubscriptionAttribute lost it's property "Namespace" that we were using in getNamespacesFromAttributes method of BaseListenerGrain.
	/// This class simply returns it back.
	/// &lt;/summary&gt;
	[AttributeUsage(AttributeTargets.Class AllowMultiple = true)]
	public class DrawboardImplicitStreamSubscriptionAttribute : ImplicitStreamSubscriptionAttribute
	{
		/// &lt;summary&gt;
		/// Legacy compartible property Namespace to make subscription easier
		/// &lt;/summary&gt;
		public string  Namespace { get; }

		/// &lt;summary&gt;Used to subscribe to all stream namespaces.&lt;/summary&gt;
		public DrawboardImplicitStreamSubscriptionAttribute() : base()
		{
			this.Namespace = string.Empty;
		}

		/// &lt;summary&gt;Used to subscribe to the specified stream namespace.&lt;/summary&gt;
		/// &lt;param name="streamNamespace"&gt;The stream namespace to subscribe.&lt;/param&gt;
		public DrawboardImplicitStreamSubscriptionAttribute(string streamNamespace) : base(streamNamespace)
		{
			this.Namespace = streamNamespace;
		}

	}
```
And ditch all `ImplicitStreamSubscriptionAttribute` in favour of our own one and this is what we are doing now. For me it's a code smell to introduce your own attributes to solve the problem that was perfectly solved in older versions of framework.

But the question is - what was the reason behind this breaking change ? It feels that it doesn't affect anything but was simply to break public contract that was in use (across multiple 1.x version) without any obvious alternative or any afterthoughts of how this is going to affect existing deployments.

Also If there is a better way to implement this in non 2.0 world - keen to hear in comments.</Description>
    <Title_Description>Namespace property removed from ImplicitStreamSubscriptionAttribute in 1.5 From [gitter chat here](https://gitter.im/dotnet/orleans?at=5b6bf2c9e9b96f2c98e36bec)

We started to migrate 1.4 -&gt; 1.5 (2.0 deemed too big rework and too many breaking changes)
and discovered that we need to make some changes in our code base. They are more or less reasonable like DI for constructors and some removed defaults. There is one change in 1.5 that looks strange and unreasonable and I'd like to understand what was the reasoning behind it:

Previously (in 1.4) `ImplicitStreamSubscriptionAttribute` has a public `Namespace` property on it and it was quite nice way to use subscription attribute itself to subscribe instance of the class to streams:
we are using reflection to create shared code in `BaseStreamListener` class which simply reflected over attributes and produced the list of "namespaces" to subscribe - thus we have centralized way to subscribe to the stream in base class - reusable piece of logic.
in 1.5. `Namespace` property was replaced by `Predicate` and  for simple scenario like ours - all what we need is to pass namespace string in ctor which then will be converted to `ExactMatchStreamNamespacePredicate` (which design is also leaves question as it's internal and doesn't expose any helpful information to subscribe to streams in the stream listening classes).

From my understanding - we still need to subscribe instance to the stream in runtime and call something like this:
```
foreach(var streamNamespace in allNamespaces)
  var inputStream = StreamFactory.GetStream&lt;TMessageType&gt;(primaryKey streamProvider streamNamespace);
   var handle = await inputStream.SubscribeAsync(ReceiveCommand OnCommandError OnCommandCompleted);
  _streams.Add(inputStream);
  _handles.Add(handle);
}
``` 
At least this is how we are working with streams in 1.4.

In _raw_ Orleans 1.5 we need to add `ImplicitStreamSubscription("fooNamespace")` attribute to the class but ALSO to keep a separate collection of namespaces to subscribe in runtime like in above example. It feels that this is not a well-thought decision and some practical functionality was removed without adding any obvious way to achieve the same results.

In 1.4. we don't need to maintain any separate collection - it was beautifully simple to scrap all string values from attributes on the class:
```
    protected virtual IEnumerable&lt;string&gt; getNamespacesFromAttributes()
    {
            var allNamespaces = this.GetType()
                .GetCustomAttributes(typeof(ImplicitStreamSubscriptionAttribute) false)
                .Select(attrib =&gt; ((ImplicitStreamSubscriptionAttribute) attrib).Namespace)
                .ToList();

            return allNamespaces;
    }
```
and the attributes on top of the class were a single source of truth for namespaces this stream is subscribed to.

We can simply add back this functionality by creating
```
/// &lt;summary&gt;
	/// The reason why this class exists is that between 1.4 and 1.5 ImplicitStreamSubscriptionAttribute lost it's property "Namespace" that we were using in getNamespacesFromAttributes method of BaseListenerGrain.
	/// This class simply returns it back.
	/// &lt;/summary&gt;
	[AttributeUsage(AttributeTargets.Class AllowMultiple = true)]
	public class DrawboardImplicitStreamSubscriptionAttribute : ImplicitStreamSubscriptionAttribute
	{
		/// &lt;summary&gt;
		/// Legacy compartible property Namespace to make subscription easier
		/// &lt;/summary&gt;
		public string  Namespace { get; }

		/// &lt;summary&gt;Used to subscribe to all stream namespaces.&lt;/summary&gt;
		public DrawboardImplicitStreamSubscriptionAttribute() : base()
		{
			this.Namespace = string.Empty;
		}

		/// &lt;summary&gt;Used to subscribe to the specified stream namespace.&lt;/summary&gt;
		/// &lt;param name="streamNamespace"&gt;The stream namespace to subscribe.&lt;/param&gt;
		public DrawboardImplicitStreamSubscriptionAttribute(string streamNamespace) : base(streamNamespace)
		{
			this.Namespace = streamNamespace;
		}

	}
```
And ditch all `ImplicitStreamSubscriptionAttribute` in favour of our own one and this is what we are doing now. For me it's a code smell to introduce your own attributes to solve the problem that was perfectly solved in older versions of framework.

But the question is - what was the reason behind this breaking change ? It feels that it doesn't affect anything but was simply to break public contract that was in use (across multiple 1.x version) without any obvious alternative or any afterthoughts of how this is going to affect existing deployments.

Also If there is a better way to implement this in non 2.0 world - keen to hear in comments.</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>9/08/2018 10:44:09 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4837</IssueLabelID>
    <Title>Client shutdown problem</Title>
    <Description>Hi

We noticed that if we kill the client without calling method .Close next time when we tried to establish a connection with silo host client connection hangs with the state "Starting".

From console log we can see all active gateways TCP connection is alive but code simply hangs on 
![image](https://user-images.githubusercontent.com/1646051/43911787-9f151528-9c00-11e8-9390-e6dbec010879.png)

Has anyone else noticed the same issue before?

Best

Dean</Description>
    <Title_Description>Client shutdown problem Hi

We noticed that if we kill the client without calling method .Close next time when we tried to establish a connection with silo host client connection hangs with the state "Starting".

From console log we can see all active gateways TCP connection is alive but code simply hangs on 
![image](https://user-images.githubusercontent.com/1646051/43911787-9f151528-9c00-11e8-9390-e6dbec010879.png)

Has anyone else noticed the same issue before?

Best

Dean</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4835</IssueLabelID>
    <Title>Change Orleans.TelemetryConsumers.Counters project target platform to netstandard or netcoreapp</Title>
    <Description>Currently `Orleans.TelemetryConsumers.Counters` targets `net461` framework. I am unable to use it with .net core app. I have an exception building `SiloHost` with `AddPerfCountersTelemetryConsumer` extension method
`System.IO.FileNotFoundException: 'Could not load file or assembly 'System.Diagnostics.PerformanceCounter Version=0.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.' `

Looks like it uses full framework version of `System.Diagnostics.PerformanceCounter`. I think we can use netstandart version of `System.Diagnostics.PerformanceCounter` since  it is already available for netstandart https://www.nuget.org/packages/System.Diagnostics.PerformanceCounter/</Description>
    <Title_Description>Change Orleans.TelemetryConsumers.Counters project target platform to netstandard or netcoreapp Currently `Orleans.TelemetryConsumers.Counters` targets `net461` framework. I am unable to use it with .net core app. I have an exception building `SiloHost` with `AddPerfCountersTelemetryConsumer` extension method
`System.IO.FileNotFoundException: 'Could not load file or assembly 'System.Diagnostics.PerformanceCounter Version=0.0.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. The system cannot find the file specified.' `

Looks like it uses full framework version of `System.Diagnostics.PerformanceCounter`. I think we can use netstandart version of `System.Diagnostics.PerformanceCounter` since  it is already available for netstandart https://www.nuget.org/packages/System.Diagnostics.PerformanceCounter/</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4834</IssueLabelID>
    <Title>Questions about Reminders timing</Title>
    <Description>Hey there
In our team we are using Orleans Reminders to perform an action that should run exactly every 1 hour.
Reminders are registered with the following function: `RegisterOrUpdateReminder(string reminderName TimeSpan dueTime TimeSpan period);
`
As we noticed recently a reminder that was registered with dueTime=0 period=1 hour will not tick every one hour exactly.
It will simply wait 1 hour _after the last reminder ended_ and then send the next reminder tick.
That is a problem to us since the reminder invokes a function that can take few seconds to end. In that case we will have an **accumulative delay** on reminder ticks that will be received every 1 hour **+ epsilon**.

From [Orleans Documentation](https://dotnet.github.io/orleans/1.5/Documentation/Core-Features/Timers-and-Reminders.html) it is said to be the case for Orleans Timers and for Reminders it said that "Reminders are similar to timers [...]".

My question is **whether there is an option to configure reminder timing** to be exactly as we registered (first tick after dueTime time and then a tick every period) without being affected by the duration of the function the reminder invokes.
If there isn't other solutions would be (A) making the reminder to invoke a async Task without awaiting for it (B) making the reminder to start a timer to do the actual work or (C) keeping track on the delay from the expected time and once it got too big update and re-schedule the reminder.

We'll be glad to hear if you know a way to handle it or simply what would you do in such cases :)
</Description>
    <Title_Description>Questions about Reminders timing Hey there
In our team we are using Orleans Reminders to perform an action that should run exactly every 1 hour.
Reminders are registered with the following function: `RegisterOrUpdateReminder(string reminderName TimeSpan dueTime TimeSpan period);
`
As we noticed recently a reminder that was registered with dueTime=0 period=1 hour will not tick every one hour exactly.
It will simply wait 1 hour _after the last reminder ended_ and then send the next reminder tick.
That is a problem to us since the reminder invokes a function that can take few seconds to end. In that case we will have an **accumulative delay** on reminder ticks that will be received every 1 hour **+ epsilon**.

From [Orleans Documentation](https://dotnet.github.io/orleans/1.5/Documentation/Core-Features/Timers-and-Reminders.html) it is said to be the case for Orleans Timers and for Reminders it said that "Reminders are similar to timers [...]".

My question is **whether there is an option to configure reminder timing** to be exactly as we registered (first tick after dueTime time and then a tick every period) without being affected by the duration of the function the reminder invokes.
If there isn't other solutions would be (A) making the reminder to invoke a async Task without awaiting for it (B) making the reminder to start a timer to do the actual work or (C) keeping track on the delay from the expected time and once it got too big update and re-schedule the reminder.

We'll be glad to hear if you know a way to handle it or simply what would you do in such cases :)
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4833</IssueLabelID>
    <Title>Accepting into an existing Socket is not supported on this platform.</Title>
    <Description>Hi There 

I am deploying Orleans within docker on linux for the first time and have found an exception in my log that so far does not seem to be causing any issues. I though it worth reporting nonetheless.

My base image for docker deployment is microsoft/dotnet:2.1-runtime 

The log I have is as follows:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-1-240 silo address S10.0.1.240:11111:271491670 to host ip-10-0-0-38 silo address S10.0.0.38:11111:271491664.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]`</Description>
    <Title_Description>Accepting into an existing Socket is not supported on this platform. Hi There 

I am deploying Orleans within docker on linux for the first time and have found an exception in my log that so far does not seem to be causing any issues. I though it worth reporting nonetheless.

My base image for docker deployment is microsoft/dotnet:2.1-runtime 

The log I have is as follows:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-1-240 silo address S10.0.1.240:11111:271491670 to host ip-10-0-0-38 silo address S10.0.0.38:11111:271491664.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4832</IssueLabelID>
    <Title>Serializing Delegates not supported on this platform</Title>
    <Description>Hi There

I am running the latest version of Orleans on a docker container based upon microsoft/dotnet:2.1-runtime on linux.

It's running at AWS in the ECS environment.

The problem seems to be related to Fallback serialization of exceptions. I make a call to an external library AmazonLambdaClient which is throwing a permissions exception. The permissions exception is a custom exception type and it seems that there is something wrong with serialization of this custom exception within docker on linux. 

For now my workaround is to catch the exception and convert it to a regular System.Exception but I'm guessing this problem will rear it's head somewhere else.

The exception log is below:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-0-38 silo address S10.0.0.38:11111:271490656 to host ip-10-0-1-240 silo address S10.0.1.240:11111:271489317.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
Task [Id=1 Status=RanToCompletion] in WorkGroup [Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.4759661 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=13 Executing Task Id=1 Status=RanToCompletion for 00:00:00.4787084 on WorkItem=WorkItemGroup:Name=[Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.4792611. .&gt;
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]
Unexpected error sending message Response S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af-&gt;S10.0.1.240:11111:271490656*grn/37AC7DD4/99220d9c@36823a84 #180:
System.Runtime.Serialization.SerializationException: Serializing delegates is not supported on this platform.
at System.MulticastDelegate.GetObjectData(SerializationInfo info StreamingContext context)
at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph BinaryFormatterWriter serWriter Boolean fCheck)
at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Boolean check)
at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AcceptOperationSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeDictionary[KV](Object original ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncEngineSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SafeCloseSocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at CachedConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeList[T](Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeArray(Array array ISerializationContext context Type expected Type et)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TablesSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at RedirectHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketsHttpHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at DiagnosticsHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpResponseMessageBodySerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AmazonLambdaExceptionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.Serialize(Object raw IBinaryTokenStreamWriter stream)
at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]`</Description>
    <Title_Description>Serializing Delegates not supported on this platform Hi There

I am running the latest version of Orleans on a docker container based upon microsoft/dotnet:2.1-runtime on linux.

It's running at AWS in the ECS environment.

The problem seems to be related to Fallback serialization of exceptions. I make a call to an external library AmazonLambdaClient which is throwing a permissions exception. The permissions exception is a custom exception type and it seems that there is something wrong with serialization of this custom exception within docker on linux. 

For now my workaround is to catch the exception and convert it to a regular System.Exception but I'm guessing this problem will rear it's head somewhere else.

The exception log is below:

`Hosting Environment is dockerprod
Using DynamoDB Clustering
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.NoOpHostEnvironmentStatistics[100708]
No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.MembershipService.MembershipOracleData[100601]
Silo silo1 migrated from host ip-10-0-0-38 silo address S10.0.0.38:11111:271490656 to host ip-10-0-1-240 silo address S10.0.1.240:11111:271489317.
Orleans Silo Running
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101036]
Exception on accepting socket during AcceptAsync
System.PlatformNotSupportedException: Accepting into an existing Socket is not supported on this platform.
at System.Net.Sockets.Socket.GetOrCreateAcceptSocket(Socket acceptSocket Boolean unused String propertyName SafeCloseSocket&amp; handle)
at System.Net.Sockets.Socket.AcceptAsync(SocketAsyncEventArgs e)
at Orleans.Runtime.Messaging.IncomingMessageAcceptor.StartAccept(SocketAsyncEventArgs acceptEventArg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Orleans.Runtime.Scheduler.WorkItemGroup[101215]
Task [Id=1 Status=RanToCompletion] in WorkGroup [Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.4759661 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=13 Executing Task Id=1 Status=RanToCompletion for 00:00:00.4787084 on WorkItem=WorkItemGroup:Name=[Activation: S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af #GrainType=PVL.Orl.Grains.SunSolveSystemJob Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.4792611. .&gt;
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]
Unexpected error sending message Response S10.0.0.38:11111:271490656*grn/F4D3640/46e1f291@744c36af-&gt;S10.0.1.240:11111:271490656*grn/37AC7DD4/99220d9c@36823a84 #180:
System.Runtime.Serialization.SerializationException: Serializing delegates is not supported on this platform.
at System.MulticastDelegate.GetObjectData(SerializationInfo info StreamingContext context)
at System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo.InitSerialize(Object obj ISurrogateSelector surrogateSelector StreamingContext context SerObjectInfoInit serObjectInfoInit IFormatterConverter converter ObjectWriter objectWriter SerializationBinder binder)
at System.Runtime.Serialization.Formatters.Binary.ObjectWriter.Serialize(Object graph BinaryFormatterWriter serWriter Boolean fCheck)
at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Serialize(Stream serializationStream Object graph Boolean check)
at Orleans.Serialization.BinaryFormatterSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.FallbackSerializer(Object raw ISerializationContext context Type t)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AcceptOperationSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeDictionary[KV](Object original ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncEngineSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketAsyncContextSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SafeCloseSocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at CachedConnectionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.BuiltInTypes.SerializeList[T](Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeArray(Array array ISerializationContext context Type expected Type et)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TablesSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at TimerQueueTimerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpConnectionPoolManagerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at RedirectHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at SocketsHttpHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at DiagnosticsHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientHandlerSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpClientSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at HttpResponseMessageBodySerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at AmazonLambdaExceptionSerializer(Object  ISerializationContext  Type )
at Orleans.Serialization.ILBasedExceptionSerializer.Serialize(Object item ISerializationContext outerContext Type expectedType)
at Orleans.Serialization.ILBasedSerializer.Serialize(Object item ISerializationContext context Type expectedType)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.SerializeInner(Object obj ISerializationContext context Type expected)
at Orleans.Serialization.SerializationManager.Serialize(Object raw IBinaryTokenStreamWriter stream)
at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)
&#x1B;[40m&#x1B;[1m&#x1B;[33mwarn&#x1B;[39m&#x1B;[22m&#x1B;[49m: Runtime.Messaging.SiloMessageSender/AppMsgsSender_0[101007]`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4831</IssueLabelID>
    <Title>Added support for priority transaction manager. </Title>
    <Description>Only one priority transaction manager is allowed per transaction.  Priority TM be used to detect TOC in future changes.

Also moved ReadonlyCommit to resource interface from tm interface.  Call was placed in wrong interface when split.</Description>
    <Title_Description>Added support for priority transaction manager.  Only one priority transaction manager is allowed per transaction.  Priority TM be used to detect TOC in future changes.

Also moved ReadonlyCommit to resource interface from tm interface.  Call was placed in wrong interface when split.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4830</IssueLabelID>
    <Title>When deactivating a grain do not stop timers if there are running requests </Title>
    <Description>Fix for #4774 

Thanks @yevhen  I was able to repro this issue 100% with this test. Like said in the issue this will fix only part of the issue.</Description>
    <Title_Description>When deactivating a grain, do not stop timers if there are running requests  Fix for #4774 

Thanks @yevhen  I was able to repro this issue 100% with this test. Like said in the issue this will fix only part of the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4828</IssueLabelID>
    <Title>Questions about the order of method calls </Title>
    <Description>Hi 

I am working on a stream processing system which might be sensitive to the orders of the method calls between grains. If I call an async method which sends messages from A to B multiple times will the messages are processed in order? 

Thanks!

 </Description>
    <Title_Description>Questions about the order of method calls  Hi 

I am working on a stream processing system which might be sensitive to the orders of the method calls between grains. If I call an async method which sends messages from A to B multiple times will the messages are processed in order? 

Thanks!

 </Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4826</IssueLabelID>
    <Title>Question/Sample Request: Long running function execution via Orleans</Title>
    <Description>I've seen in the documentation about how "Orleans is not suited for long running work*" (*Generally) - I may be paraphrasing. There are a few issues regarding that same topic #4531 #4370 #3071 and several others that I'm having trouble finding ATM.

The tldr of what I'm hoping to accomplish with Orleans is to take lots of calls from my app and dispatch them across a cluster of Orleans silos.  Many of these calls that occur are completed in a few milliseconds but many take several minutes to complete when running in our non-Orleans implementation.  

I understand there is a default timeout of 30 seconds for the client to receive a response from the grain and I would feel weird about increasing that to accommodate our "longest running logic"  I feel like there has to be a better way of doing it that just increasing the timeout.

Currently my calls (either fast or slow) look similar to this and note this is all CPU bound work:

Client.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    var grain = _clusterClient.GetGrain&lt;IMyGrain&gt;(Guid.NewGuid());
    return await grain.DoWork(param);
}
```

Grain.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    return await Task.Run(() =&gt;
    {
         // CPU bound sync code
    });
}
```

The above seems to work out great when `DoWork` is fast running at least at small scale. Prior to using Orleans I was using a `LimitedConcurrencyTaskScheduler` in order to keep memory usage down; it seemed like I was getting into some situations where I'd have so many scheduled tasks that all memory would be utilized and nothing would complete.  

The above code does not work without setting the timeout to at least as high as our "longest running operation".  It seems that a lot of suggestions on getting around this are to "return immediately that the task has been started then get the result when it's finished" but I'm not finding any samples on how to accomplish this at least from both a client and grain perspective.

Could some samples be provided on how to accomplish what I'm going after?  It seems that some sort of check that an invocation is complete would be needed but I'm not sure how to go about that.  Would this require my grains to become stateful rather than stateless? #4370 seems like it ***may*** be of use but I'm only seeing from the grain perspective not what it looks like from the client.  Ideally my fast and long running client/grains with have similar looking implementations but if I have to break out into separate methods for accommodating that's fine as well.

Hopefully this all makes sense!</Description>
    <Title_Description>Question/Sample Request: Long running function execution via Orleans I've seen in the documentation about how "Orleans is not suited for long running work*" (*Generally) - I may be paraphrasing. There are a few issues regarding that same topic #4531 #4370 #3071 and several others that I'm having trouble finding ATM.

The tldr of what I'm hoping to accomplish with Orleans is to take lots of calls from my app and dispatch them across a cluster of Orleans silos.  Many of these calls that occur are completed in a few milliseconds but many take several minutes to complete when running in our non-Orleans implementation.  

I understand there is a default timeout of 30 seconds for the client to receive a response from the grain and I would feel weird about increasing that to accommodate our "longest running logic"  I feel like there has to be a better way of doing it that just increasing the timeout.

Currently my calls (either fast or slow) look similar to this and note this is all CPU bound work:

Client.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    var grain = _clusterClient.GetGrain&lt;IMyGrain&gt;(Guid.NewGuid());
    return await grain.DoWork(param);
}
```

Grain.cs
```
public async Task&lt;MyType&gt; DoWork(Parameter param)
{
    return await Task.Run(() =&gt;
    {
         // CPU bound sync code
    });
}
```

The above seems to work out great when `DoWork` is fast running at least at small scale. Prior to using Orleans I was using a `LimitedConcurrencyTaskScheduler` in order to keep memory usage down; it seemed like I was getting into some situations where I'd have so many scheduled tasks that all memory would be utilized and nothing would complete.  

The above code does not work without setting the timeout to at least as high as our "longest running operation".  It seems that a lot of suggestions on getting around this are to "return immediately that the task has been started then get the result when it's finished" but I'm not finding any samples on how to accomplish this at least from both a client and grain perspective.

Could some samples be provided on how to accomplish what I'm going after?  It seems that some sort of check that an invocation is complete would be needed but I'm not sure how to go about that.  Would this require my grains to become stateful rather than stateless? #4370 seems like it ***may*** be of use but I'm only seeing from the grain perspective not what it looks like from the client.  Ideally my fast and long running client/grains with have similar looking implementations but if I have to break out into separate methods for accommodating that's fine as well.

Hopefully this all makes sense!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4823</IssueLabelID>
    <Title>Error occurs in clusterbuilder.build  when  iis website restart</Title>
    <Description>Hi
  I have a websit using Orleans Client connect to the server.

  I have a static ClusterClient
    and when the website start the ClientBuilder.Build() is invoked and connect to the server.
    and when  the website shut down IClusterClient.Close() and Dispose() is invoked .

  it runs good but when the website restart it become unstable   and then if continue access the 
  website it will become ok because the IClusterClient is still null and  ClientBuilder.Build() is also 
   invoked for init. and then it will OK all the time.

  the env is:   windows 10  IIS 10  donet framework 4.7.2  asp.net mvc 5.2.4.0.

the debugger show that:
FatalExecutionEngineError  error address is 0x0df3063f，at thread 0xbf8 。error code is 0xc0000005。maybe it is a CLR  bug，or unsafe code bug。maybe with COM-interop or PInvoke .

please help.

![error](https://user-images.githubusercontent.com/17829409/43782305-a40558ce-9a91-11e8-9c2b-73e460f6af09.PNG)

![error2](https://user-images.githubusercontent.com/17829409/43782812-bf60bb58-9a92-11e8-8751-99d24f0fe083.PNG)
</Description>
    <Title_Description>Error occurs in clusterbuilder.build  when  iis website restart Hi
  I have a websit using Orleans Client connect to the server.

  I have a static ClusterClient
    and when the website start the ClientBuilder.Build() is invoked and connect to the server.
    and when  the website shut down IClusterClient.Close() and Dispose() is invoked .

  it runs good but when the website restart it become unstable   and then if continue access the 
  website it will become ok because the IClusterClient is still null and  ClientBuilder.Build() is also 
   invoked for init. and then it will OK all the time.

  the env is:   windows 10  IIS 10  donet framework 4.7.2  asp.net mvc 5.2.4.0.

the debugger show that:
FatalExecutionEngineError  error address is 0x0df3063f，at thread 0xbf8 。error code is 0xc0000005。maybe it is a CLR  bug，or unsafe code bug。maybe with COM-interop or PInvoke .

please help.

![error](https://user-images.githubusercontent.com/17829409/43782305-a40558ce-9a91-11e8-9c2b-73e460f6af09.PNG)

![error2](https://user-images.githubusercontent.com/17829409/43782812-bf60bb58-9a92-11e8-8751-99d24f0fe083.PNG)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4822</IssueLabelID>
    <Title>Which code files are maintained for memberships tables and grain directory tables?</Title>
    <Description>  I'm studying the implementation of Orleans but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members normal exit and abnormal exit Grain activation and deactivation and node failure when the table recovery operations.

  Could you tell me which files are the specific implementation codes of these operations?</Description>
    <Title_Description>Which code files are maintained for memberships tables and grain directory tables?   I'm studying the implementation of Orleans but I've found that I can't find the specific maintenance code for the memberships table and the grain directory table. Including the entry of members normal exit and abnormal exit Grain activation and deactivation and node failure when the table recovery operations.

  Could you tell me which files are the specific implementation codes of these operations?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4821</IssueLabelID>
    <Title>GatewayClientReceiver.FillBuffer() being slow and looks like executing in critical section</Title>
    <Description>Hi Team

While troubleshooting slowness with our cloud service we noticed from the memory dump logs that the GatewayClientReceiver.FillBuffer() is taking time and might be executing in critical section which might also be blocking other threads. However when I look at the code it looks like only initialization logic for senders/receivers is getting executed in critical section. 
some of the stack trace from memory dump where we see that the thread have been stuck for a while:
```
0d clr!ObjectNative::WaitTimeout
0e mscorlib!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(Int32 UInt32 System.Threading.CancellationToken)
0f mscorlib!System.Threading.SemaphoreSlim.Wait(Int32 System.Threading.CancellationToken)
10 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTakeWithNoTimeValidation(System.__Canon ByRef Int32 System.Threading.CancellationToken System.Threading.CancellationTokenSource)
11 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTake(System.__Canon ByRef Int32 System.Threading.CancellationToken)
12 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].Take()
13 Orleans_Core!Orleans.Runtime.AsynchQueueAgent`1[[System.__Canon mscorlib]].RunNonBatching()
14 Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
```

```
06 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError ByRef)
07 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags)
08 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.FillBuffer(System.Collections.Generic.List`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt;)
09 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.Run()
0a Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
0b mscorlib!System.Threading.Tasks.Task.Execute()
0c mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0d mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0e mscorlib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
0f mscorlib!System.Threading.Tasks.Task.ExecuteEntry(Boolean)
10 mscorlib!System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
11 mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
12 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
13 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)
14 mscorlib!System.Threading.ThreadHelper.ThreadStart()
```
As it is difficult to find the real cause here we need a confirmation from you that the processing of messages (queuing and fillbuffer) should be executing well within the expected time.
Also should we reduce or increase the sizes of send/receive buffers to fine tune the performance considering that our application works in high load and sends/receives a lot of messages within Orleans cluster.
We are using Orleans 2.0.0 on Azure Cloud Service.</Description>
    <Title_Description>GatewayClientReceiver.FillBuffer() being slow and looks like executing in critical section Hi Team

While troubleshooting slowness with our cloud service we noticed from the memory dump logs that the GatewayClientReceiver.FillBuffer() is taking time and might be executing in critical section which might also be blocking other threads. However when I look at the code it looks like only initialization logic for senders/receivers is getting executed in critical section. 
some of the stack trace from memory dump where we see that the thread have been stuck for a while:
```
0d clr!ObjectNative::WaitTimeout
0e mscorlib!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(Int32 UInt32 System.Threading.CancellationToken)
0f mscorlib!System.Threading.SemaphoreSlim.Wait(Int32 System.Threading.CancellationToken)
10 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTakeWithNoTimeValidation(System.__Canon ByRef Int32 System.Threading.CancellationToken System.Threading.CancellationTokenSource)
11 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].TryTake(System.__Canon ByRef Int32 System.Threading.CancellationToken)
12 System!System.Collections.Concurrent.BlockingCollection`1[[System.__Canon mscorlib]].Take()
13 Orleans_Core!Orleans.Runtime.AsynchQueueAgent`1[[System.__Canon mscorlib]].RunNonBatching()
14 Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
```

```
06 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags System.Net.Sockets.SocketError ByRef)
07 System!System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt; System.Net.Sockets.SocketFlags)
08 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.FillBuffer(System.Collections.Generic.List`1&lt;System.ArraySegment`1&lt;Byte&gt;&gt;)
09 Orleans_Core!Orleans.Messaging.GatewayClientReceiver.Run()
0a Orleans_Core!Orleans.Runtime.AsynchAgent.AgentThreadProc(System.Object)
0b mscorlib!System.Threading.Tasks.Task.Execute()
0c mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0d mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
0e mscorlib!System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef)
0f mscorlib!System.Threading.Tasks.Task.ExecuteEntry(Boolean)
10 mscorlib!System.Threading.ThreadHelper.ThreadStart_Context(System.Object)
11 mscorlib!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
12 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object Boolean)
13 mscorlib!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext System.Threading.ContextCallback System.Object)
14 mscorlib!System.Threading.ThreadHelper.ThreadStart()
```
As it is difficult to find the real cause here we need a confirmation from you that the processing of messages (queuing and fillbuffer) should be executing well within the expected time.
Also should we reduce or increase the sizes of send/receive buffers to fine tune the performance considering that our application works in high load and sends/receives a lot of messages within Orleans cluster.
We are using Orleans 2.0.0 on Azure Cloud Service.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4820</IssueLabelID>
    <Title>Separation of Transaction Manager and Transactional Resource</Title>
    <Description>Separation of Transaction Manager and Transactional Resource
- Remove transaction participant
- Full separation of tm and resource grain extensions.
- Grain references are used everwhere and cast to extensions where needed.

Next step: Add TOC support
</Description>
    <Title_Description>Separation of Transaction Manager and Transactional Resource Separation of Transaction Manager and Transactional Resource
- Remove transaction participant
- Full separation of tm and resource grain extensions.
- Grain references are used everwhere and cast to extensions where needed.

Next step: Add TOC support
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4819</IssueLabelID>
    <Title>Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.</Title>
    <Description>When I do the following setting Client will throw an exception..
```
.Configure&lt;SchedulingOptions&gt;(c =&gt;
{
    c.PerformDeadlockDetection = true;
})

at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
         at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
         at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
         at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
         at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
         at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43. Restarting gateway receiver for gwy.tcp://127.0.0.1:30000/0.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
fail: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[100026]
      Asynch agent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 encountered unexpected exception The Stage will be restarted.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
   at Orleans.Threading.FiltersApplicant`1.Apply(T action) in D:\Git\orleans\src\Orleans.Core\Threading\ActionFilter.cs:line 86</Description>
    <Title_Description>Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved. When I do the following setting Client will throw an exception..
```
.Configure&lt;SchedulingOptions&gt;(c =&gt;
{
    c.PerformDeadlockDetection = true;
})

at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
         at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
         at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
         at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
         at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
         at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
         at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43. Restarting gateway receiver for gwy.tcp://127.0.0.1:30000/0.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
fail: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[100026]
      Asynch agent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 encountered unexpected exception The Stage will be restarted.
System.TypeAccessException: Named type "Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadFullTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager Type expected) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 464
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in D:\Git\orleans\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 374
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1288
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Messaging\Message.cs:line 1325
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context) in D:\Git\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:line 1563
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg) in D:\Git\orleans\src\Orleans.Core\Messaging\IncomingMessageBuffer.cs:line 175
   at Orleans.Messaging.GatewayClientReceiver.Run() in D:\Git\orleans\src\Orleans.Core\Messaging\GatewayClientReceiver.cs:line 43
   at Orleans.Threading.FiltersApplicant`1.Apply(T action) in D:\Git\orleans\src\Orleans.Core\Threading\ActionFilter.cs:line 86</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4818</IssueLabelID>
    <Title>Grain can't be collection normally</Title>
    <Description>I set up the following：
```
...
.Configure&lt;GrainCollectionOptions&gt;(options =&gt;
{
    options.CollectionAge = TimeSpan.FromMinutes(1);

})
.UseDashboard(options =&gt; { options.Port = 9090; })
```
After the Grain is collection it can be seen through the Dashboardand has not been collection successfully.
I will not be able to activate these Grain again.
But if update SqlEventStorage.cs line 136 use Task.Run will not the problem.
This problem is very easy to happen if you introduce a third party library.

Example:
Startup need the postgresql and rabbitmq.
[Ray.git.zip](https://github.com/dotnet/orleans/files/2260031/Ray.git.zip)
</Description>
    <Title_Description>Grain can't be collection normally I set up the following：
```
...
.Configure&lt;GrainCollectionOptions&gt;(options =&gt;
{
    options.CollectionAge = TimeSpan.FromMinutes(1);

})
.UseDashboard(options =&gt; { options.Port = 9090; })
```
After the Grain is collection it can be seen through the Dashboardand has not been collection successfully.
I will not be able to activate these Grain again.
But if update SqlEventStorage.cs line 136 use Task.Run will not the problem.
This problem is very easy to happen if you introduce a third party library.

Example:
Startup need the postgresql and rabbitmq.
[Ray.git.zip](https://github.com/dotnet/orleans/files/2260031/Ray.git.zip)
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4816</IssueLabelID>
    <Title>[WIP] Add memory threshold</Title>
    <Description>A naive implementation that allows for configurable suppression of grain collection based on memory pressure.</Description>
    <Title_Description>[WIP] Add memory threshold A naive implementation that allows for configurable suppression of grain collection based on memory pressure.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4813</IssueLabelID>
    <Title>Bump code generation version to 2.0.4</Title>
    <Description>
    </Description>
    <Title_Description>Bump code generation version to 2.0.4 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4812</IssueLabelID>
    <Title>Build time codegen quite unstable on Orleans 2.x</Title>
    <Description>Hello folks 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact I've suffering since 2.0 release with multiple different issues with it. Some PR were made attempting to fix but which just failed.

I'm opening this issue in an attempt to bring team's attention to this matter as it is turning build time codegen practically unusable the way it is now.

As discussed with @ReubenBond it looks like the new codegen he is working is going to fix if not all the majority of those current issues but the work is on hold due to other team's priorities. 

It is a major block on multiple projects I'm working with so I would appreciate if Reuben have a bit more of time to dedicate to it. 

Thank you all!</Description>
    <Title_Description>Build time codegen quite unstable on Orleans 2.x Hello folks 

I saw some issues pointing out multiple issues with build time codegen after Orleans 2.x was released.

In fact I've suffering since 2.0 release with multiple different issues with it. Some PR were made attempting to fix but which just failed.

I'm opening this issue in an attempt to bring team's attention to this matter as it is turning build time codegen practically unusable the way it is now.

As discussed with @ReubenBond it looks like the new codegen he is working is going to fix if not all the majority of those current issues but the work is on hold due to other team's priorities. 

It is a major block on multiple projects I'm working with so I would appreciate if Reuben have a bit more of time to dedicate to it. 

Thank you all!</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4811</IssueLabelID>
    <Title>Errors from SiloHost</Title>
    <Description>Hello

I have a Silohost &amp; client running on local machine and connects through consul membership. Everything works fine but I was able to find below exceptions. What are these excepions? Do I need to fix something before these code move to higher environments?

{"Timestamp":"2018-08-01T17:00:58.0013497-05:00""Level":"Error""MessageTemplate":"Worker pool thread Runtime.Scheduler.WorkerPoolThread/3 (ManagedThreadId=40) has been busy for long time:
 Executing Task Id=97879 Status=Running for 00:00:59.7464953 on WorkItem=WorkItemGroup:Name=[Activation: S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+XXXXZ505@01be8caf
 #GrainType=XXXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]WorkGroupStatus=Running Executing for 00:00:59.7555196. WorkItemGroup Details: 
 WorkItemGroup:Name=[Activation: S10.XX.XX.XX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]
 WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed 
 SchedulingContext=&lt;[Activation: S10.XXX.XX.XXX:XXX:270856538*grn/9B57CB77/0000000000000000000000000000000006ffffff9b57cb77+17543CZ505-0x1E0EA515@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus 
 Placement=ActivationCountBasedPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=1 NumRunning=1 IdlenessTimeSpan=736906.22:00:58.0003454 
 CollectionAgeLimit=02:00:00 CurrentlyExecuting=NewPlacement Request XXX.XXX.XX.XX:XXX:270856538*cli/a64bf6b3@bf402085-&gt;S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf 
 #5: ]&gt;.""Properties":{"EventId":{"Id":101212}"SourceContext":"Runtime.Scheduler.WorkerPoolThread/3""Orleans":"XXXXXX""EnvironmentUserName":"XXXXX\\XXXXXX""MachineName":"XXXXXXX"
 "ProcessId":15836"ProcessName":"XXXX.XXXXX.Host""ThreadId":40}}
 
{"Timestamp":"2018-08-01T17:00:59.7092269-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. 
Last fired at 2018-08-01 22:00:42.396 GMT 00:00:17.3124134 since previous fire should have fired after 00:00:10.""Properties":{"EventId":{"Id":101412}"SourceContext":
"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"ProcessName":"XXXXX.XXXX.Host""ThreadId":40}}


{"Timestamp":"2018-08-01T17:01:03.2601117-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. 
Last fired at 2018-08-01 21:55:44.998 GMT 00:05:18.2619388 since previous fire should have fired after 00:05:00.""Properties":{"EventId":{"Id":101412}
"SourceContext":"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"
ProcessName":"XXXXX.XXXXX.Host""ThreadId":40}}
</Description>
    <Title_Description>Errors from SiloHost Hello

I have a Silohost &amp; client running on local machine and connects through consul membership. Everything works fine but I was able to find below exceptions. What are these excepions? Do I need to fix something before these code move to higher environments?

{"Timestamp":"2018-08-01T17:00:58.0013497-05:00""Level":"Error""MessageTemplate":"Worker pool thread Runtime.Scheduler.WorkerPoolThread/3 (ManagedThreadId=40) has been busy for long time:
 Executing Task Id=97879 Status=Running for 00:00:59.7464953 on WorkItem=WorkItemGroup:Name=[Activation: S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+XXXXZ505@01be8caf
 #GrainType=XXXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]WorkGroupStatus=Running Executing for 00:00:59.7555196. WorkItemGroup Details: 
 WorkItemGroup:Name=[Activation: S10.XX.XX.XX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus Placement=ActivationCountBasedPlacement]
 WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed 
 SchedulingContext=&lt;[Activation: S10.XXX.XX.XXX:XXX:270856538*grn/9B57CB77/0000000000000000000000000000000006ffffff9b57cb77+17543CZ505-0x1E0EA515@01be8caf #GrainType=XXXX.XXXXX.Grains.CommandBus 
 Placement=ActivationCountBasedPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=0 InFlightCount=1 NumRunning=1 IdlenessTimeSpan=736906.22:00:58.0003454 
 CollectionAgeLimit=02:00:00 CurrentlyExecuting=NewPlacement Request XXX.XXX.XX.XX:XXX:270856538*cli/a64bf6b3@bf402085-&gt;S10.XXX.XX.XXX:XX:270856538*grn/9B57CB77/00000000+17543CZ505@01be8caf 
 #5: ]&gt;.""Properties":{"EventId":{"Id":101212}"SourceContext":"Runtime.Scheduler.WorkerPoolThread/3""Orleans":"XXXXXX""EnvironmentUserName":"XXXXX\\XXXXXX""MachineName":"XXXXXXX"
 "ProcessId":15836"ProcessName":"XXXX.XXXXX.Host""ThreadId":40}}
 
{"Timestamp":"2018-08-01T17:00:59.7092269-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.ProbeTimer did not fire on time. 
Last fired at 2018-08-01 22:00:42.396 GMT 00:00:17.3124134 since previous fire should have fired after 00:00:10.""Properties":{"EventId":{"Id":101412}"SourceContext":
"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"ProcessName":"XXXXX.XXXX.Host""ThreadId":40}}


{"Timestamp":"2018-08-01T17:01:03.2601117-05:00""Level":"Error""MessageTemplate":"Watchdog Freeze Alert: Orleans.Runtime.asynTask.SafeTimerBase.Membership.IAmAliveTimer did not fire on time. 
Last fired at 2018-08-01 21:55:44.998 GMT 00:05:18.2619388 since previous fire should have fired after 00:05:00.""Properties":{"EventId":{"Id":101412}
"SourceContext":"Orleans.Runtime.GrainTimer""Orleans":"SiloHostBuilder""EnvironmentUserName":"XXXX\\XXXXXX""MachineName":"XXXXXX-XXX""ProcessId":15836"
ProcessName":"XXXXX.XXXXX.Host""ThreadId":40}}
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4810</IssueLabelID>
    <Title>Limited separation of transaction orchestration and participation.</Title>
    <Description>First pass at separating transaction orchestration (transaction manager) from participation (transactional resource).

Goal is to eventually be able to support a variety of transactional resources (state queues event sourcing ...) as well as advanced transactional patterns like Transfer of Commit (TOC).

This PR should have no behavioral changes only code reorganization.
- Added transaction manager and transactional resource interfaces
- Removed partial classes separating logic into a read/write lock and transaction queue transaction manager and transactional resource.

More work needs be done this is just a first pass.</Description>
    <Title_Description>Limited separation of transaction orchestration and participation. First pass at separating transaction orchestration (transaction manager) from participation (transactional resource).

Goal is to eventually be able to support a variety of transactional resources (state queues event sourcing ...) as well as advanced transactional patterns like Transfer of Commit (TOC).

This PR should have no behavioral changes only code reorganization.
- Added transaction manager and transactional resource interfaces
- Removed partial classes separating logic into a read/write lock and transaction queue transaction manager and transactional resource.

More work needs be done this is just a first pass.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4809</IssueLabelID>
    <Title>LightInject integration issue</Title>
    <Description>I am trying to use [LightInject ](https://github.com/seesharper/LightInject) as IoC container in Orleans Silo and on startup it throws an error `Common Language Runtime detected an invalid program`.

This looks like some issues with assembly loading and the root cause of it is that LightInject can't resolve `IOptionsFormatter&lt;&gt;` (which may be separate issue).

Tested with::
* Microsoft.Orleans.Server 2.0.3
* LightInject 5.1.5
* LightInject.Microsoft.DependencyInjection 2.0.7

Integration code looks like this:
```csharp
var container = new LightInject.ServiceContainer(opts);
var siloBuilder = new SiloHostBuilder()
    .UseServiceProviderFactory(services =&gt;
    {
        return container.CreateServiceProvider(services);
    })
```

Full stack:
```
at DynamicMethod(Object[] )
at LightInject.Microsoft.DependencyInjection.PerRootScopeLifetime.CreateScopedInstance(Func`1 createInstance)
at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
at DynamicMethod(Object[] )
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Runtime.SiloOptionsLogger.OnStart(CancellationToken token) in D:\build\agent\_work\18\s\src\Orleans.Runtime\OptionsLogger\OptionsLogger.cs:line 22
at Orleans.LifecycleExtensions.Observer.OnStart(CancellationToken ct)
at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 70
at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 103
at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 49
```
Dotnet info:
```
&gt; dotnet --info                                     
.NET Core SDK (reflecting any global.json):         
 Version:   2.1.300                                 
 Commit:    adab45bf0c                              
                                                    
Runtime Environment:                                
 OS Name:     Windows                               
 OS Version:  10.0.15063                            
 OS Platform: Windows                               
 RID:         win10-x64                             
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300\  
                                                    
Host (useful for support):                          
  Version: 2.1.0                                    
  Commit:  caa7b7e2ba                               
```
Full solution that can reproduce the issue can be found here:
https://github.com/n-sidorov/OreansLightInjectIssueRepro</Description>
    <Title_Description>LightInject integration issue I am trying to use [LightInject ](https://github.com/seesharper/LightInject) as IoC container in Orleans Silo and on startup it throws an error `Common Language Runtime detected an invalid program`.

This looks like some issues with assembly loading and the root cause of it is that LightInject can't resolve `IOptionsFormatter&lt;&gt;` (which may be separate issue).

Tested with::
* Microsoft.Orleans.Server 2.0.3
* LightInject 5.1.5
* LightInject.Microsoft.DependencyInjection 2.0.7

Integration code looks like this:
```csharp
var container = new LightInject.ServiceContainer(opts);
var siloBuilder = new SiloHostBuilder()
    .UseServiceProviderFactory(services =&gt;
    {
        return container.CreateServiceProvider(services);
    })
```

Full stack:
```
at DynamicMethod(Object[] )
at LightInject.Microsoft.DependencyInjection.PerRootScopeLifetime.CreateScopedInstance(Func`1 createInstance)
at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key Func`2 valueFactory)
at DynamicMethod(Object[] )
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Runtime.SiloOptionsLogger.OnStart(CancellationToken token) in D:\build\agent\_work\18\s\src\Orleans.Runtime\OptionsLogger\OptionsLogger.cs:line 22
at Orleans.LifecycleExtensions.Observer.OnStart(CancellationToken ct)
at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs:line 70
at Orleans.LifecycleSubject.WrapExecution(CancellationToken ct Func`2 action) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 103
at Orleans.LifecycleSubject.OnStart(CancellationToken ct) in D:\build\agent\_work\18\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs:line 49
```
Dotnet info:
```
&gt; dotnet --info                                     
.NET Core SDK (reflecting any global.json):         
 Version:   2.1.300                                 
 Commit:    adab45bf0c                              
                                                    
Runtime Environment:                                
 OS Name:     Windows                               
 OS Version:  10.0.15063                            
 OS Platform: Windows                               
 RID:         win10-x64                             
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300\  
                                                    
Host (useful for support):                          
  Version: 2.1.0                                    
  Commit:  caa7b7e2ba                               
```
Full solution that can reproduce the issue can be found here:
https://github.com/n-sidorov/OreansLightInjectIssueRepro</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4808</IssueLabelID>
    <Title>Remove the callchain information for the OneWay message</Title>
    <Description>Recently I've met a deadlock exception caused by a OneWay message. As far as I know the sender of the one-way message will not wailt for the response of the message. This means that even if the callee calls the function on the same grain the message will be added to the next position of messaging queue and will not cause a deadlock. So we should add a check on the line below if it is a OneWay message the call chain information should not be passed to next calls. 

https://github.com/dotnet/orleans/blob/e2b25a695767ae5746ffe47218c1331427997894/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L292

I don't know if I'm correct. If the thought is correct I will make a pull-request to fix it.</Description>
    <Title_Description>Remove the callchain information for the OneWay message Recently I've met a deadlock exception caused by a OneWay message. As far as I know the sender of the one-way message will not wailt for the response of the message. This means that even if the callee calls the function on the same grain the message will be added to the next position of messaging queue and will not cause a deadlock. So we should add a check on the line below if it is a OneWay message the call chain information should not be passed to next calls. 

https://github.com/dotnet/orleans/blob/e2b25a695767ae5746ffe47218c1331427997894/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L292

I don't know if I'm correct. If the thought is correct I will make a pull-request to fix it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4802</IssueLabelID>
    <Title>The latest code is often compiled with exceptions</Title>
    <Description>Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.

Value cannot be null. 

 at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)</Description>
    <Title_Description>The latest code is often compiled with exceptions Asynch agent Runtime.Messaging.IncomingMessageAgent/Application encountered unexpected exception The Stage will be restarted.

Value cannot be null. 

 at System.Threading.Monitor.Exit(Object obj)
   at System.Threading.SemaphoreSlim.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken CancellationTokenSource combinedTokenSource)
   at System.Collections.Concurrent.BlockingCollection`1.TryTake(T&amp; item Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Collections.Concurrent.BlockingCollection`1.Take()
   at Orleans.Runtime.Messaging.InboundMessageQueue.WaitMessage(Categories type)
   at Orleans.Runtime.Messaging.MessageCenter.WaitMessage(Categories type CancellationToken ct)
   at Orleans.Runtime.Messaging.IncomingMessageAgent.Run()
   at Orleans.Threading.FiltersApplicant`1.Apply(T action)</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4801</IssueLabelID>
    <Title>Orleans StatelessWorker Grain throw System.TypeLoadException</Title>
    <Description>I create 3 projects:OLTest.ClientOLTest1.SiloOLTest2.Silo. I implemented a StatelessWorker Grain "Hello2Stateless" in OLTest2.Silo. Then run a LTest1.Silo instance and 2 OLTest2.Silo instances.Use OLTest.Client to call Hello2Stateless for testing (grainFactory.GetGrain&lt;IHello2Stateless&gt; (Guid.Empty).Say ())It runs well at this time.After that I close Hello2Stateless Grain to activate Silo (one of two instances of OLTest2.Silo) and then use OLTest.Client to call after cluster recovery.
Hello2Stateless will throw "System.TypeLoadException: Cannot find GrainTypeData for class OLTest2.Grains.Hello2Stateless in OLTest1.Silo instance.At Orleans.Runtime.GrainTypeManager.get_Item (String className) exception." (I use OrleansDashboard to see that OLTest.Client is connected to the LTest1.Silo instance if one of the instances in which OLTest.Client is connected to OLTest2.Silo does not appear the cluster is using the Sql Server mode).</Description>
    <Title_Description>Orleans StatelessWorker Grain throw System.TypeLoadException I create 3 projects:OLTest.ClientOLTest1.SiloOLTest2.Silo. I implemented a StatelessWorker Grain "Hello2Stateless" in OLTest2.Silo. Then run a LTest1.Silo instance and 2 OLTest2.Silo instances.Use OLTest.Client to call Hello2Stateless for testing (grainFactory.GetGrain&lt;IHello2Stateless&gt; (Guid.Empty).Say ())It runs well at this time.After that I close Hello2Stateless Grain to activate Silo (one of two instances of OLTest2.Silo) and then use OLTest.Client to call after cluster recovery.
Hello2Stateless will throw "System.TypeLoadException: Cannot find GrainTypeData for class OLTest2.Grains.Hello2Stateless in OLTest1.Silo instance.At Orleans.Runtime.GrainTypeManager.get_Item (String className) exception." (I use OrleansDashboard to see that OLTest.Client is connected to the LTest1.Silo instance if one of the instances in which OLTest.Client is connected to OLTest2.Silo does not appear the cluster is using the Sql Server mode).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4800</IssueLabelID>
    <Title>OrleansAzureUtils 2.0.4 no longer depends on Streaming.AzureStorage</Title>
    <Description>I updated our project's dependencies to the 2.0.4 bits on NuGet and encountered the following build error:

&gt; The type or namespace name 'AzureQueue' does not exist in the namespace 'Orleans.Providers.Streams' (are you missing an assembly reference?)

After some quick digging I found that the `Microsoft.Orleans.OrleansAzureUtils` package no longer depends on the `Microsoft.Orleans.Streaming.AzureStorage` package:

https://www.nuget.org/packages/Microsoft.Orleans.OrleansAzureUtils/2.0.0
https://www.nuget.org/packages/Microsoft.Orleans.OrleansAzureUtils/2.0.4

Is this expected and should it be documented in the release notes on GitHub?</Description>
    <Title_Description>OrleansAzureUtils 2.0.4 no longer depends on Streaming.AzureStorage I updated our project's dependencies to the 2.0.4 bits on NuGet and encountered the following build error:

&gt; The type or namespace name 'AzureQueue' does not exist in the namespace 'Orleans.Providers.Streams' (are you missing an assembly reference?)

After some quick digging I found that the `Microsoft.Orleans.OrleansAzureUtils` package no longer depends on the `Microsoft.Orleans.Streaming.AzureStorage` package:

https://www.nuget.org/packages/Microsoft.Orleans.OrleansAzureUtils/2.0.0
https://www.nuget.org/packages/Microsoft.Orleans.OrleansAzureUtils/2.0.4

Is this expected and should it be documented in the release notes on GitHub?</Title_Description>
    <Label>P3</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>26/07/2018 11:08:49 PM +00:00</CreatedAt>
    <ClosedAt>11/09/2018 8:48:05 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4798</IssueLabelID>
    <Title>Getting a lot of errors from azure queue stream provider</Title>
    <Description>We're trying to move from simple message stream to azure queue streams.
Getting a lot of these errors:
```
Error doing DeleteMessage for Azure storage queue felix-azurequeuestreamprovider-4 
Exception = Microsoft.WindowsAzure.Storage.StorageException: The remote server returned an error: (404) Not Found. ---&gt; System.Net.WebException: The remote server returned an error: (404) Not Found.
   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpResponseParsers.ProcessExpectedStatusCodeNoException[T](HttpStatusCode expectedStatusCode HttpStatusCode actualStatusCode T retVal StorageCommandBase`1 cmd Exception ex) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Shared\Protocol\HttpResponseParsers.Common.cs:line 50
   at Microsoft.WindowsAzure.Storage.Queue.CloudQueue.&lt;DeleteMessageImpl&gt;b__39(RESTCommand`1 cmd HttpWebResponse resp Exception ex OperationContext ctx) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Queue\CloudQueue.cs:line 2648
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Executor\Executor.cs:line 299
   --- End of inner exception stack trace ---
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Executor\Executor.cs:line 50
   at Microsoft.WindowsAzure.Storage.Core.Util.AsyncExtensions.&lt;&gt;c__DisplayClass4.&lt;CreateCallbackVoid&gt;b__3(IAsyncResult ar) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Util\AsyncExtensions.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AzureUtils.AzureQueueDataManager.&lt;DeleteQueueMessage&gt;d__21.MoveNext()
Request Information
RequestID:0b42e6b4-6003-0034-4232-24957a000000
RequestDate:Wed 25 Jul 2018 16:14:51 GMT
StatusMessage:The specified message does not exist.
ErrorCode:MessageNotFound
ErrorMessage:The specified message does not exist.
RequestId:0b42e6b4-6003-0034-4232-24957a000000
Time:2018-07-25T16:14:52.1243047Z
```

all of these are for the same queue: queue felix-azurequeuestreamprovider-4 
when looking at that queue in azure storage explorer that was the only one that was full.
I deleted that queue and i think that stopped it.

any ideas?</Description>
    <Title_Description>Getting a lot of errors from azure queue stream provider We're trying to move from simple message stream to azure queue streams.
Getting a lot of these errors:
```
Error doing DeleteMessage for Azure storage queue felix-azurequeuestreamprovider-4 
Exception = Microsoft.WindowsAzure.Storage.StorageException: The remote server returned an error: (404) Not Found. ---&gt; System.Net.WebException: The remote server returned an error: (404) Not Found.
   at Microsoft.WindowsAzure.Storage.Shared.Protocol.HttpResponseParsers.ProcessExpectedStatusCodeNoException[T](HttpStatusCode expectedStatusCode HttpStatusCode actualStatusCode T retVal StorageCommandBase`1 cmd Exception ex) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Shared\Protocol\HttpResponseParsers.Common.cs:line 50
   at Microsoft.WindowsAzure.Storage.Queue.CloudQueue.&lt;DeleteMessageImpl&gt;b__39(RESTCommand`1 cmd HttpWebResponse resp Exception ex OperationContext ctx) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Queue\CloudQueue.cs:line 2648
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndGetResponse[T](IAsyncResult getResponseResult) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Executor\Executor.cs:line 299
   --- End of inner exception stack trace ---
   at Microsoft.WindowsAzure.Storage.Core.Executor.Executor.EndExecuteAsync[T](IAsyncResult result) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Executor\Executor.cs:line 50
   at Microsoft.WindowsAzure.Storage.Core.Util.AsyncExtensions.&lt;&gt;c__DisplayClass4.&lt;CreateCallbackVoid&gt;b__3(IAsyncResult ar) in c:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\ClassLibraryCommon\Core\Util\AsyncExtensions.cs:line 115
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.AzureUtils.AzureQueueDataManager.&lt;DeleteQueueMessage&gt;d__21.MoveNext()
Request Information
RequestID:0b42e6b4-6003-0034-4232-24957a000000
RequestDate:Wed 25 Jul 2018 16:14:51 GMT
StatusMessage:The specified message does not exist.
ErrorCode:MessageNotFound
ErrorMessage:The specified message does not exist.
RequestId:0b42e6b4-6003-0034-4232-24957a000000
Time:2018-07-25T16:14:52.1243047Z
```

all of these are for the same queue: queue felix-azurequeuestreamprovider-4 
when looking at that queue in azure storage explorer that was the only one that was full.
I deleted that queue and i think that stopped it.

any ideas?</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4796</IssueLabelID>
    <Title>Verify exception handling logic when multiple particiant throw</Title>
    <Description>Verify exception handling logic when multiple particiant throw. The expected logic is only one exception is picked as the inner exception of OrleansTransactionAbortException</Description>
    <Title_Description>Verify exception handling logic when multiple particiant throw Verify exception handling logic when multiple particiant throw. The expected logic is only one exception is picked as the inner exception of OrleansTransactionAbortException</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4795</IssueLabelID>
    <Title>Named type "Domain.Model" is invalid: Type string "Domain.Model" cannot be resolved</Title>
    <Description>Hi

I have this strange exception happening. It happens randomly about 50% of the time kind of sending goes fine then sending again triggers exception and so on. I found similar [issues](https://github.com/dotnet/orleans/issues/1536) from 2016. Some of the issues in the context of generic types. However the type I'm using is a plain C# (POCO) type.

Here is my scenario.

I want to share some of my data types (models) between solutions so I create a NuGet package that I install wherever I need the model. I do the same with interfaces (e.g. different solutions implements client to the same grain in some silo).

I've read the documentation [Serialization and Writing Custom Serializers](http://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Serialization.html) about serialization but I can not see what I'm doing wrong. I do use "DataContract" attribute and also the "Serializable" attribute (as the document instruct me to use the "Serializable" attribute on types).

It is not clear from the documentation how I use other serializers (I see that it's possible to use other serializers instead of the one out-of-the-box - as long as all other parts of the environment uses the same serializer).

But now I've run out of ideas.

Here is the model that fails to be serialized (about 50% of the time):

```
    [Serializable]
    [DataContract]
    public class Model
    {
        [DataMember]
        public string Title { get; set; }

        [DataMember]
        public string Subtitle { get; set; }

        [DataMember(EmitDefaultValue = false)]
        public DateTime Created { get; set; }

        [DataMember(EmitDefaultValue = false)]
        public string Context { get; set; }
    }
```
And here is the code fragment using the model:

```
        _clusterClient
		.GetGrain&lt;IModelGrain&gt;(id)
		.Update(model);
```
The `_clusterClient` is a singleton object initialized once (connecting) and then used throughout. I do not restart my applications between failures. So the serialization seem to be failing somewhat randomly during runtime. I do however measure each time it fails (try-catch).

Since the `Microsoft.Orleans.OrleansCodeGenerator.Build` can't handle .NET Core version 2.1 (yet) all my solutions are locked to .NET Core version 2.0 (2.0.2). I'm using Orleans v2.0.3 and v2.0 throughout my (.NET Core) solutions.

I'd be happy to have some thoughts on why such a "simple" scenario fails. If it was consistent like failing all the time then I'd go with what the exception tells me that the type can not be resolved (not found) and work with it. But it is this scenario of the serializer failing on and off that I think is strange.

Thanks
Jan</Description>
    <Title_Description>Named type "Domain.Model" is invalid: Type string "Domain.Model" cannot be resolved Hi

I have this strange exception happening. It happens randomly about 50% of the time kind of sending goes fine then sending again triggers exception and so on. I found similar [issues](https://github.com/dotnet/orleans/issues/1536) from 2016. Some of the issues in the context of generic types. However the type I'm using is a plain C# (POCO) type.

Here is my scenario.

I want to share some of my data types (models) between solutions so I create a NuGet package that I install wherever I need the model. I do the same with interfaces (e.g. different solutions implements client to the same grain in some silo).

I've read the documentation [Serialization and Writing Custom Serializers](http://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Serialization.html) about serialization but I can not see what I'm doing wrong. I do use "DataContract" attribute and also the "Serializable" attribute (as the document instruct me to use the "Serializable" attribute on types).

It is not clear from the documentation how I use other serializers (I see that it's possible to use other serializers instead of the one out-of-the-box - as long as all other parts of the environment uses the same serializer).

But now I've run out of ideas.

Here is the model that fails to be serialized (about 50% of the time):

```
    [Serializable]
    [DataContract]
    public class Model
    {
        [DataMember]
        public string Title { get; set; }

        [DataMember]
        public string Subtitle { get; set; }

        [DataMember(EmitDefaultValue = false)]
        public DateTime Created { get; set; }

        [DataMember(EmitDefaultValue = false)]
        public string Context { get; set; }
    }
```
And here is the code fragment using the model:

```
        _clusterClient
		.GetGrain&lt;IModelGrain&gt;(id)
		.Update(model);
```
The `_clusterClient` is a singleton object initialized once (connecting) and then used throughout. I do not restart my applications between failures. So the serialization seem to be failing somewhat randomly during runtime. I do however measure each time it fails (try-catch).

Since the `Microsoft.Orleans.OrleansCodeGenerator.Build` can't handle .NET Core version 2.1 (yet) all my solutions are locked to .NET Core version 2.0 (2.0.2). I'm using Orleans v2.0.3 and v2.0 throughout my (.NET Core) solutions.

I'd be happy to have some thoughts on why such a "simple" scenario fails. If it was consistent like failing all the time then I'd go with what the exception tells me that the type can not be resolved (not found) and work with it. But it is this scenario of the serializer failing on and off that I think is strange.

Thanks
Jan</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4794</IssueLabelID>
    <Title>(v1.5.1) GC issue and the silo occurring Out Of Memory</Title>
    <Description>Affter occurring  following warnings for a few minutes， this silo occurring Out Of Memory issue and crash. 
The version of Orleans is 1.5.1. 

My GC configure is :
`&lt;gcServer enabled="true"/&gt;
&lt;gcConcurrent enabled="false"/&gt;`

`[2018-07-22 10:35:22.260 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.1563224 - possibly GC? We are now using total of 1752MB memory. gc=73796 59507 762	
[2018-07-22 10:35:40.089 GMT    19	WARNING	101215	Scheduler.WorkItemGroup	10.81.10.159:0]	Task [Id=1208361640 Status=RanToCompletion] in WorkGroup [Activation: S10.81.10.159:42005:268437616*grn/DB267BD1/c60d3004@3e4f8783 #GrainType=Services.ES.Implement.Report.Member.MemberReportServiceGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2171824 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/6 ManagedThreadId=19 Executing Task Id=1208361640 Status=RanToCompletion for 00:00:00.2187526 on WorkItem=WorkItemGroup:Name=[Activation: S10.81.10.159:42005:268437616*grn/DB267BD1/c60d3004@3e4f8783 #GrainType=Services.ES.Implement.Report.Member.MemberReportServiceGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.2187526. .&gt;	
[2018-07-22 10:35:46.651 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.0313614 - possibly GC? We are now using total of 1750MB memory. gc=73798 59509 763	
[2018-07-22 10:36:15.417 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.3594877 - possibly GC? We are now using total of 1752MB memory. gc=73800 59511 764`
</Description>
    <Title_Description>(v1.5.1) GC issue and the silo occurring Out Of Memory Affter occurring  following warnings for a few minutes， this silo occurring Out Of Memory issue and crash. 
The version of Orleans is 1.5.1. 

My GC configure is :
`&lt;gcServer enabled="true"/&gt;
&lt;gcConcurrent enabled="false"/&gt;`

`[2018-07-22 10:35:22.260 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.1563224 - possibly GC? We are now using total of 1752MB memory. gc=73796 59507 762	
[2018-07-22 10:35:40.089 GMT    19	WARNING	101215	Scheduler.WorkItemGroup	10.81.10.159:0]	Task [Id=1208361640 Status=RanToCompletion] in WorkGroup [Activation: S10.81.10.159:42005:268437616*grn/DB267BD1/c60d3004@3e4f8783 #GrainType=Services.ES.Implement.Report.Member.MemberReportServiceGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:00.2171824 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/6 ManagedThreadId=19 Executing Task Id=1208361640 Status=RanToCompletion for 00:00:00.2187526 on WorkItem=WorkItemGroup:Name=[Activation: S10.81.10.159:42005:268437616*grn/DB267BD1/c60d3004@3e4f8783 #GrainType=Services.ES.Implement.Report.Member.MemberReportServiceGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:00.2187526. .&gt;	
[2018-07-22 10:35:46.651 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.0313614 - possibly GC? We are now using total of 1750MB memory. gc=73798 59509 763	
[2018-07-22 10:36:15.417 GMT    39	WARNING	100150	Watchdog	10.81.10.159:0]	.NET Runtime Platform stalled for 00:00:02.3594877 - possibly GC? We are now using total of 1752MB memory. gc=73800 59511 764`
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4793</IssueLabelID>
    <Title>Serialization errors on exceptions thrown from grain methods cause client timeouts</Title>
    <Description>Take grain interface:

```
interface IFoo
{
    Task DoSomething();
}
```

If for whatever reason DoSomething() encounters an unhandled exception that reaches the runtime and the runtime cannot serialize it back to the client the runtime sends nothing back to the client causing an eventual client timeout.

The expected behavior is the client would receive some generic serialization failed exception.  Without this these types of issues are very difficult to debug.</Description>
    <Title_Description>Serialization errors on exceptions thrown from grain methods cause client timeouts Take grain interface:

```
interface IFoo
{
    Task DoSomething();
}
```

If for whatever reason DoSomething() encounters an unhandled exception that reaches the runtime and the runtime cannot serialize it back to the client the runtime sends nothing back to the client causing an eventual client timeout.

The expected behavior is the client would receive some generic serialization failed exception.  Without this these types of issues are very difficult to debug.</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4792</IssueLabelID>
    <Title>ISiloHost.Stopped not resolved when silo kill himself</Title>
    <Description>When a silo decide to kill himself because it sees its membership entry as "Dead" it will try to shutdown quickly by himelf. 

The issue is that the Task in `ISiloHost.Stopped` is not resolved so if the user relies on this task to quit the program the program will not quit even if the silo is not doing anything relevant anymore.
</Description>
    <Title_Description>ISiloHost.Stopped not resolved when silo kill himself When a silo decide to kill himself because it sees its membership entry as "Dead" it will try to shutdown quickly by himelf. 

The issue is that the Task in `ISiloHost.Stopped` is not resolved so if the user relies on this task to quit the program the program will not quit even if the silo is not doing anything relevant anymore.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4790</IssueLabelID>
    <Title>Request help No client request The  system auto Downtime</Title>
    <Description>No concurrency no call to Grain born unexplained problem.
After this error Client cannot connect to Orleans silo

Use .Net Core  V2.1.2
Use Orleans V2.0.4 


@ReubenBond Please help me see
This is all the logs that have an exception.
[Exception log.txt](https://github.com/dotnet/orleans/files/2238467/Exception.log.txt)
</Description>
    <Title_Description>Request help, No client request, The  system auto Downtime No concurrency no call to Grain born unexplained problem.
After this error Client cannot connect to Orleans silo

Use .Net Core  V2.1.2
Use Orleans V2.0.4 


@ReubenBond Please help me see
This is all the logs that have an exception.
[Exception log.txt](https://github.com/dotnet/orleans/files/2238467/Exception.log.txt)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4789</IssueLabelID>
    <Title>Gossip Channel Implementations</Title>
    <Description>
If we do not specify a Gossip channel then what would be the default gossip channel?</Description>
    <Title_Description>Gossip Channel Implementations 
If we do not specify a Gossip channel then what would be the default gossip channel?</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4785</IssueLabelID>
    <Title>"Developing a Grain" doc</Title>
    <Description>1. 2.0 (.Net Standard based right?) doc says to create a class project targeting .Net 4.6.1 - this is confusing
1. It says to install the nuget pkg `Microsoft.Orleans.OrleansCodeGenerator.Build` in to the class library but merely doing this does not resolve the sample code properly (ie: `IGrainWithGuidKey` `IGameGrain` etc)
~~~
PlayerGrain.cs(10371054): error CS0246: The type or namespace name 'IGrainWithGuidKey' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(18321837): error CS0246: The type or namespace name 'Grain' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(12141224): error CS0246: The type or namespace name 'IGameGrain' could not be found (are you missing a using directive or an assembly reference?)
~~~</Description>
    <Title_Description>"Developing a Grain" doc 1. 2.0 (.Net Standard based right?) doc says to create a class project targeting .Net 4.6.1 - this is confusing
1. It says to install the nuget pkg `Microsoft.Orleans.OrleansCodeGenerator.Build` in to the class library but merely doing this does not resolve the sample code properly (ie: `IGrainWithGuidKey` `IGameGrain` etc)
~~~
PlayerGrain.cs(10371054): error CS0246: The type or namespace name 'IGrainWithGuidKey' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(18321837): error CS0246: The type or namespace name 'Grain' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(12141224): error CS0246: The type or namespace name 'IGameGrain' could not be found (are you missing a using directive or an assembly reference?)
~~~</Title_Description>
    <Label>P1</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4781</IssueLabelID>
    <Title>More Transaction Metrics</Title>
    <Description>Added more transaction metrics and benchmark tests for transaction throttling.</Description>
    <Title_Description>More Transaction Metrics Added more transaction metrics and benchmark tests for transaction throttling.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4779</IssueLabelID>
    <Title>Allow the Grain state to define Partition key and Row key for Table Storage</Title>
    <Description>While enabling the state to persist in the storage we should have a mechanism to override the Partition Key /Row key so that data can be stored and retrieved effectively.
</Description>
    <Title_Description>Allow the Grain state to define Partition key and Row key for Table Storage While enabling the state to persist in the storage we should have a mechanism to override the Partition Key /Row key so that data can be stored and retrieved effectively.
</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>18/07/2018 12:04:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4778</IssueLabelID>
    <Title>Tuning Orleans table liveness for maximum availability</Title>
    <Description>Looking at this:
http://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Cluster-Management.html#configuration

It looks like the defaults for some liveness configurations are really high Like:
```
ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send "I am alive" heartbeat messages about itself. Default is 10 seconds.
```
We have a realtime system where 10 seconds of not knowing a silo is dead and getting errors is not something we can live with.

How would you recommend configuring liveness for MAXIMUM availability?
Would appreciate specific suggestions for values adding the keys here for convenience:

* ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send "I am alive" heartbeat messages about itself. Default is 10 seconds.

* TableRefreshTimeout - The number of seconds to fetch updates from the membership table. Default is 60 seconds.

* DeathVoteExpirationTimeout - Expiration time in seconds for death vote in the membership table. Default is 120 seconds

* NumMissedProbesLimit - The number of missed "I am alive" heartbeat messages from a silo or number of un-replied probes that lead to suspecting this silo as dead. Default is 3.

* NumProbedSilos - The number of silos each silo probes for liveness. Default is 3.

* NumVotesForDeathDeclaration - The number of non-expired votes that are needed to declare some silo as dead (should be at most NumMissedProbesLimit). Default is 2.

* UseLivenessGossip - Whether to use the gossip optimization to speed up spreading liveness information. Default is true.

* IAmAliveTablePublishTimeout - The number of seconds to periodically write in the membership table that this silo is alive. Used only for diagnostics. Default is 5 minutes.

* NumMissedTableIAmAliveLimit - The number of missed "I am alive" updates in the table from a silo that causes warning to be logged. Does not impact the liveness protocol. Default is 2.

* MaxJoinAttemptTime - The number of seconds to attempt to join a cluster of silos before giving up. Default is 5 minutes.

* ExpectedClusterSize - The expected size of a cluster. Need not be very accurate can be an overestimate. Used to tune the exponential backoff algorithm of retries to write to Azure table. Default is 20.</Description>
    <Title_Description>Tuning Orleans table liveness for maximum availability Looking at this:
http://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Cluster-Management.html#configuration

It looks like the defaults for some liveness configurations are really high Like:
```
ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send "I am alive" heartbeat messages about itself. Default is 10 seconds.
```
We have a realtime system where 10 seconds of not knowing a silo is dead and getting errors is not something we can live with.

How would you recommend configuring liveness for MAXIMUM availability?
Would appreciate specific suggestions for values adding the keys here for convenience:

* ProbeTimeout - The number of seconds to probe other silos for their liveness or for the silo to send "I am alive" heartbeat messages about itself. Default is 10 seconds.

* TableRefreshTimeout - The number of seconds to fetch updates from the membership table. Default is 60 seconds.

* DeathVoteExpirationTimeout - Expiration time in seconds for death vote in the membership table. Default is 120 seconds

* NumMissedProbesLimit - The number of missed "I am alive" heartbeat messages from a silo or number of un-replied probes that lead to suspecting this silo as dead. Default is 3.

* NumProbedSilos - The number of silos each silo probes for liveness. Default is 3.

* NumVotesForDeathDeclaration - The number of non-expired votes that are needed to declare some silo as dead (should be at most NumMissedProbesLimit). Default is 2.

* UseLivenessGossip - Whether to use the gossip optimization to speed up spreading liveness information. Default is true.

* IAmAliveTablePublishTimeout - The number of seconds to periodically write in the membership table that this silo is alive. Used only for diagnostics. Default is 5 minutes.

* NumMissedTableIAmAliveLimit - The number of missed "I am alive" updates in the table from a silo that causes warning to be logged. Does not impact the liveness protocol. Default is 2.

* MaxJoinAttemptTime - The number of seconds to attempt to join a cluster of silos before giving up. Default is 5 minutes.

* ExpectedClusterSize - The expected size of a cluster. Need not be very accurate can be an overestimate. Used to tune the exponential backoff algorithm of retries to write to Azure table. Default is 20.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4777</IssueLabelID>
    <Title>Service fabric clustering graceful shutdown</Title>
    <Description>Hey We are currently using service fabric clustering in orleans 1.5.3.
We're experiencing a lot of noise (errors slow execution) while doing a rolling upgrade. 
From what i've read here:
https://github.com/dotnet/orleans/blob/a2ad7e375af89f7920c3c6f272b972d5f3710774/src/OrleansServiceFabricUtils/OrleansCommunicationListener.cs#L120
it looks like this is an ungraceful shutdown which could cause this am i right?
I tried to change CloseAsync to do shutDownOrleansSilo instead of stop had no effect at all.

My assumption is that graceful shutdown does not work with service fabric clustering only with table membership clustering (the silo marks itself as shutting down finish requests and dont take any more work).
Is this  true?</Description>
    <Title_Description>Service fabric clustering graceful shutdown Hey We are currently using service fabric clustering in orleans 1.5.3.
We're experiencing a lot of noise (errors slow execution) while doing a rolling upgrade. 
From what i've read here:
https://github.com/dotnet/orleans/blob/a2ad7e375af89f7920c3c6f272b972d5f3710774/src/OrleansServiceFabricUtils/OrleansCommunicationListener.cs#L120
it looks like this is an ungraceful shutdown which could cause this am i right?
I tried to change CloseAsync to do shutDownOrleansSilo instead of stop had no effect at all.

My assumption is that graceful shutdown does not work with service fabric clustering only with table membership clustering (the silo marks itself as shutting down finish requests and dont take any more work).
Is this  true?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4774</IssueLabelID>
    <Title>Race condition with interleaved messages using TCS</Title>
    <Description>We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is crucial to performance boosts we got from batching in our system.

We figured out that problem we're experiencing with graceful shutdown described in #4757 is due to Orleans not being able to deactivate some of the grains. This only happens when TaskCompletionSource is used (along with the buffering and timer-based completion).

I have a failing test (#4773) for this scenario you can pull and check. On the surface it looks like after DeactivateOnIdle is called Orleans disposes the timer while there interleaved requests which leaves tasks in the uncompleted state thus preventing Orleans from deactivating the grain.

Please advice what can be done wrt to this issue.</Description>
    <Title_Description>Race condition with interleaved messages using TCS We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is crucial to performance boosts we got from batching in our system.

We figured out that problem we're experiencing with graceful shutdown described in #4757 is due to Orleans not being able to deactivate some of the grains. This only happens when TaskCompletionSource is used (along with the buffering and timer-based completion).

I have a failing test (#4773) for this scenario you can pull and check. On the surface it looks like after DeactivateOnIdle is called Orleans disposes the timer while there interleaved requests which leaves tasks in the uncompleted state thus preventing Orleans from deactivating the grain.

Please advice what can be done wrt to this issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4772</IssueLabelID>
    <Title>RollingUpdate fails on GetAllSubscriptions()</Title>
    <Description>Version:`Orleans 1.5.1`
StreamProvider: `SimpleStreamProvider`
Membership Table: `ServiceFabric Clustering `
While running a rolling update after a code change we get flooded with exceptions that are happening in the `OnActivateAsync()` of our grain specifically here:

```
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.0.0.11:20002:269521878*grn/A31B4281/f5ac76a1@88fe1ab0-&gt;S10.0.0.6:20002:269521702*grn/716E8E94/177ccc90+SimpleStreamProvider_SupportFeedItemEvents@6cdb1190 #4133: global::Orleans.Streams.IPubSubRendezvousGrain:GetAllSubscriptions(). Target History is: &lt;S10.0.0.6:20002:269521702:*grn/716E8E94/177ccc90+SimpleStreamProvider_SupportFeedItemEvents:@6cdb1190&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamPubSubImpl.&lt;GetAllSubscriptions&gt;d__9.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.&lt;GetAllSubscriptions&gt;d__17.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 ...
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;CallGrainActivate&gt;d__87.MoveNext()
```

Other errors have the same trace while the exception is:

```
Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request S10.0.0.11:20002:269521878*grn/A31B4281/968c808d@5de1b4ab-
```

Or

```
Orleans.Runtime.OrleansMessageRejectionException: Silo stopping
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamPubSubImpl.&lt;GetAllSubscriptions&gt;d__9.MoveNext()
```

But all errors are from the same `GetAllSubscriptions` method 

**Current workaround:**
Restart each node in our cluster and then errors dissapear</Description>
    <Title_Description>RollingUpdate fails on GetAllSubscriptions() Version:`Orleans 1.5.1`
StreamProvider: `SimpleStreamProvider`
Membership Table: `ServiceFabric Clustering `
While running a rolling update after a code change we get flooded with exceptions that are happening in the `OnActivateAsync()` of our grain specifically here:

```
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S10.0.0.11:20002:269521878*grn/A31B4281/f5ac76a1@88fe1ab0-&gt;S10.0.0.6:20002:269521702*grn/716E8E94/177ccc90+SimpleStreamProvider_SupportFeedItemEvents@6cdb1190 #4133: global::Orleans.Streams.IPubSubRendezvousGrain:GetAllSubscriptions(). Target History is: &lt;S10.0.0.6:20002:269521702:*grn/716E8E94/177ccc90+SimpleStreamProvider_SupportFeedItemEvents:@6cdb1190&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamPubSubImpl.&lt;GetAllSubscriptions&gt;d__9.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.&lt;GetAllSubscriptions&gt;d__17.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
 ...
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;CallGrainActivate&gt;d__87.MoveNext()
```

Other errors have the same trace while the exception is:

```
Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request S10.0.0.11:20002:269521878*grn/A31B4281/968c808d@5de1b4ab-
```

Or

```
Orleans.Runtime.OrleansMessageRejectionException: Silo stopping
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamPubSubImpl.&lt;GetAllSubscriptions&gt;d__9.MoveNext()
```

But all errors are from the same `GetAllSubscriptions` method 

**Current workaround:**
Restart each node in our cluster and then errors dissapear</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4771</IssueLabelID>
    <Title>Documentation issues ("ADO.NET Persistence Rationale")</Title>
    <Description>Please revise [this piece](https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Core-Features/Grain-Persistence.md/#adonet-persistence-rationale-) as it is full of typos and hard to understand. </Description>
    <Title_Description>Documentation issues ("ADO.NET Persistence Rationale") Please revise [this piece](https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Core-Features/Grain-Persistence.md/#adonet-persistence-rationale-) as it is full of typos and hard to understand. </Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4769</IssueLabelID>
    <Title>Azure App Service (Web App) cannot connect to Orleans Cloud Service silo</Title>
    <Description>Hello
I am sorry for bothering you with something that looks like an Azure VNET configuration issue but it seems you've done this a lot of times and you could point me to the right direction.  
I posted this originally on: https://stackoverflow.com/questions/51252380/azure-app-service-doesnt-see-worker-roles-in-vnet (and I set a bounty ;)). Copied here for ease of reading:  
I need to configure an Orleans cluster to connect to an Azure App Service. The issue is that networking is my weakest point ;).
I have configured an Orleans Silo using Azure Worker Role (4 instances) listening to the default ports: 

    .ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)

I've assigned the Worker Role to an Azure VNET (Classic) with these settings:  
Address Range 10.0.0.0/24  
Subnet-1 10.0.0.0/27 (the Worker Role is Assigned here as part of a network security group)  
Point to Site range 10.0.**1**.0/24  
GatewaySubnet 10.0.0.32/29 (added to the same network security group)

I see that the 4 deployed instances take proper IPs in the Subnet-1: 10.0.0.4 to 10.0.0.7.
The App Service is assigned to this VPN ("Certificates in sync") and reports:  
IP ADDRESSES ROUTED TO VNET   
10.0.0.0 - 10.255.255.255  
172.16.0.0 - 172.31.255.255  
192.168.0.0 - 192.168.255.255  

I see that the app service tries to connect to 10.0.0.7:30000
**I tested both by checking application logs when it starts up and tries to connect to the Orleans Silo and by using tcpping that 10.0.0.7:30000 is not accessible by the application.** (Unable to connect to gateway at address gwy.tcp://10.0.0.7:30000/268857231 […] AccessDenied)    
I am definitely missing something elementary here! 
</Description>
    <Title_Description>Azure App Service (Web App) cannot connect to Orleans Cloud Service silo Hello
I am sorry for bothering you with something that looks like an Azure VNET configuration issue but it seems you've done this a lot of times and you could point me to the right direction.  
I posted this originally on: https://stackoverflow.com/questions/51252380/azure-app-service-doesnt-see-worker-roles-in-vnet (and I set a bounty ;)). Copied here for ease of reading:  
I need to configure an Orleans cluster to connect to an Azure App Service. The issue is that networking is my weakest point ;).
I have configured an Orleans Silo using Azure Worker Role (4 instances) listening to the default ports: 

    .ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)

I've assigned the Worker Role to an Azure VNET (Classic) with these settings:  
Address Range 10.0.0.0/24  
Subnet-1 10.0.0.0/27 (the Worker Role is Assigned here as part of a network security group)  
Point to Site range 10.0.**1**.0/24  
GatewaySubnet 10.0.0.32/29 (added to the same network security group)

I see that the 4 deployed instances take proper IPs in the Subnet-1: 10.0.0.4 to 10.0.0.7.
The App Service is assigned to this VPN ("Certificates in sync") and reports:  
IP ADDRESSES ROUTED TO VNET   
10.0.0.0 - 10.255.255.255  
172.16.0.0 - 172.31.255.255  
192.168.0.0 - 192.168.255.255  

I see that the app service tries to connect to 10.0.0.7:30000
**I tested both by checking application logs when it starts up and tries to connect to the Orleans Silo and by using tcpping that 10.0.0.7:30000 is not accessible by the application.** (Unable to connect to gateway at address gwy.tcp://10.0.0.7:30000/268857231 […] AccessDenied)    
I am definitely missing something elementary here! 
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4768</IssueLabelID>
    <Title>Transaction participant wrapper json serialization fix</Title>
    <Description>Transaction wrapper was not serializing the participant when using json.</Description>
    <Title_Description>Transaction participant wrapper json serialization fix Transaction wrapper was not serializing the participant when using json.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4767</IssueLabelID>
    <Title>Cleanup connect retry loop in hello world sample</Title>
    <Description>
    </Description>
    <Title_Description>Cleanup connect retry loop in hello world sample </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4765</IssueLabelID>
    <Title>Clean up BatchWorker</Title>
    <Description>No functional change just a minor cleanup and minor reduction of API surface</Description>
    <Title_Description>Clean up BatchWorker No functional change just a minor cleanup and minor reduction of API surface</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4763</IssueLabelID>
    <Title>Added grain storage to benchmarks</Title>
    <Description>Added a grain storage benchmark to help track down #4612.

Unfortunately not able to repro the issue (yet).
</Description>
    <Title_Description>Added grain storage to benchmarks Added a grain storage benchmark to help track down #4612.

Unfortunately not able to repro the issue (yet).
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4762</IssueLabelID>
    <Title>Make azure queue name configurable</Title>
    <Description>-make azure queue name prefix configuration through `AzureQueueOptions`

-if not set then default to its original value  which is serviceId-providerName

For issue #4577 </Description>
    <Title_Description>Make azure queue name configurable -make azure queue name prefix configuration through `AzureQueueOptions`

-if not set then default to its original value  which is serviceId-providerName

For issue #4577 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4761</IssueLabelID>
    <Title>Moved request invocation history to core.</Title>
    <Description>Moved request invocation history to orleans core so it's available on the client.
Should address #4706</Description>
    <Title_Description>Moved request invocation history to core. Moved request invocation history to orleans core so it's available on the client.
Should address #4706</Title_Description>
    <Label>bug</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4760</IssueLabelID>
    <Title>Intermittent test failure ValidateGeneratedStreamsTest</Title>
    <Description>
UnitTests.StreamingTests.StreamGeneratorProviderTests.ValidateGeneratedStreamsTest

Assert.Equal() Failure\r\nExpected: 100\r\nActual: 101
+++++++++++++++++++
STACK TRACE:
at UnitTests.StreamingTests.StreamGeneratorProviderTests.&lt;CheckCounters&gt;d__6.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\test\Tester\StreamingTests\StreamGeneratorProviderTests.cs:line 77 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 93 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 106 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at UnitTests.StreamingTests.StreamGeneratorProviderTests.&lt;ValidateGeneratedStreamsTest&gt;d__5.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\test\Tester\StreamingTests\StreamGeneratorProviderTests.cs:line 65 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent test failure ValidateGeneratedStreamsTest 
UnitTests.StreamingTests.StreamGeneratorProviderTests.ValidateGeneratedStreamsTest

Assert.Equal() Failure\r\nExpected: 100\r\nActual: 101
+++++++++++++++++++
STACK TRACE:
at UnitTests.StreamingTests.StreamGeneratorProviderTests.&lt;CheckCounters&gt;d__6.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\test\Tester\StreamingTests\StreamGeneratorProviderTests.cs:line 77 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 93 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 106 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at UnitTests.StreamingTests.StreamGeneratorProviderTests.&lt;ValidateGeneratedStreamsTest&gt;d__5.MoveNext() in D:\j\workspace\bvt_prtest3cca9be5\test\Tester\StreamingTests\StreamGeneratorProviderTests.cs:line 65 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>11/07/2018 6:22:46 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4759</IssueLabelID>
    <Title>New Sample to go with new Tutorial</Title>
    <Description>@jason-bragg </Description>
    <Title_Description>New Sample to go with new Tutorial @jason-bragg </Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4758</IssueLabelID>
    <Title>Event hub stream provider questions</Title>
    <Description>Hi All

I have some questions regarding streaming in Orleans in general and specifically streaming using Event Hub Stream Provider.
I’ll briefly describe my scenario: I have a worker role (non-Orleans) that gets messages from an event hub. Each message belongs to some provider (there can be thousands of providers). The worker role then sends the message to a grain for this specific provider using streaming (there’s a separate stream for each provider grain). The processing of each message by the grain may take some time and that’s why I want to send the message over a persistent queue to decouple the sending from the handling of the message (unlike SMS provider). 
In addition there’s an accumulation of data in the grain itself and it in its turn sends the accumulated data to another service. That’s why I want the stream to be rewindable – if the silo crushed before the grain had sent the data batch I want to process the messages from the begging of the batch.
That’s why the event hub stream provider seems like the correct choice and that’s how I was thinking of using it:
When the first message of the batch arrives to the grain I will save its token in the (persisted) state of the grain. When the batch is sent I’ll update the token to the last message received and use a flag to indicate that I want to get messages with a newer token (the first message of the next batch). In this way if the silo crushes before I’ve sent the batch the grain will start processing messages from the last token saved.
1.	Can I consider event hub stream provider as ready for production systems? I don’t see any documentation for it but I see it’s been released long time ago and it’s been used by 343 industries.
2.	How many different streams does the event hub stream provider support? In the documentation states that “By default Orleans Streaming is targeted to support a large number of relatively small streams”. So it’s seems ok but I wanted to be sure.
3.	When I played with the event hub stream provider I tried to pass null to the StreamSequenceToken parameter on ResumeAsync expecting it to provider new events. But every time I started the Silo I got all the events that I previously sent. I have a workaround for this that I mentioned above but I’m wondering what the reason for this behavior is. 

Thanks!
Gal
</Description>
    <Title_Description>Event hub stream provider questions Hi All

I have some questions regarding streaming in Orleans in general and specifically streaming using Event Hub Stream Provider.
I’ll briefly describe my scenario: I have a worker role (non-Orleans) that gets messages from an event hub. Each message belongs to some provider (there can be thousands of providers). The worker role then sends the message to a grain for this specific provider using streaming (there’s a separate stream for each provider grain). The processing of each message by the grain may take some time and that’s why I want to send the message over a persistent queue to decouple the sending from the handling of the message (unlike SMS provider). 
In addition there’s an accumulation of data in the grain itself and it in its turn sends the accumulated data to another service. That’s why I want the stream to be rewindable – if the silo crushed before the grain had sent the data batch I want to process the messages from the begging of the batch.
That’s why the event hub stream provider seems like the correct choice and that’s how I was thinking of using it:
When the first message of the batch arrives to the grain I will save its token in the (persisted) state of the grain. When the batch is sent I’ll update the token to the last message received and use a flag to indicate that I want to get messages with a newer token (the first message of the next batch). In this way if the silo crushes before I’ve sent the batch the grain will start processing messages from the last token saved.
1.	Can I consider event hub stream provider as ready for production systems? I don’t see any documentation for it but I see it’s been released long time ago and it’s been used by 343 industries.
2.	How many different streams does the event hub stream provider support? In the documentation states that “By default Orleans Streaming is targeted to support a large number of relatively small streams”. So it’s seems ok but I wanted to be sure.
3.	When I played with the event hub stream provider I tried to pass null to the StreamSequenceToken parameter on ResumeAsync expecting it to provider new events. But every time I started the Silo I got all the events that I previously sent. I have a workaround for this that I mentioned above but I’m wondering what the reason for this behavior is. 

Thanks!
Gal
</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4757</IssueLabelID>
    <Title>Incorrect silo shutdown behavior</Title>
    <Description>We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo which is normal of course. Also there number of other actors that may exchange messages across silos also normal of course since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo neither from clients nor from other silos (basically close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down) and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

```
Trying to forward after Non-existent activation ForwardCount = 0. Message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+124531@dd334eba #17019
```

And

```
Forwarding failed: tried to forward message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+136155@897e8889 #17002[ForwardCount=1]:  for 1 times after Non-existent activation to invalid activation. Rejecting now.
```

And
 
```
Intermediate NonExistentActivation for message Request S10.31.5.14:100:268955504*cli/ee2e539e@6615b9ac-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba #46821:  with Exception Orleans.Runtime.Catalog+NonExistentActivationException: Non-existent activation: [ActivationAddress: S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba Full GrainId: [GrainId: *grn/2FB327A8/00000000000000000000000000000000060000002fb327a8+121772-0x577BB16A IdCategory: KeyExtGrain BaseTypeCode: 800270248 (x2FB327A8) PrimaryKey: 0 (x0) UniformHashCode: 1467724138 (0x577BB16A) KeyExtension: 121772] Full ActivationId: @42851f391a09207a71eff3b7882812ba0000000000000000] grain type: Fun.LegacyTheme.
   at Orleans.Runtime.Catalog.GetOrCreateActivation(ActivationAddress address Boolean newPlacement String grainType String genericArguments Dictionary`2 requestContextData Task&amp; activatedPromise)
   at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)
```

This is unacceptable behavior for us as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).</Description>
    <Title_Description>Incorrect silo shutdown behavior We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo which is normal of course. Also there number of other actors that may exchange messages across silos also normal of course since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo neither from clients nor from other silos (basically close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down) and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

```
Trying to forward after Non-existent activation ForwardCount = 0. Message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+124531@dd334eba #17019
```

And

```
Forwarding failed: tried to forward message Request S10.31.5.14:100:268955504*cli/586efeb6@0c49119e-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+136155@897e8889 #17002[ForwardCount=1]:  for 1 times after Non-existent activation to invalid activation. Rejecting now.
```

And
 
```
Intermediate NonExistentActivation for message Request S10.31.5.14:100:268955504*cli/ee2e539e@6615b9ac-&gt;S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba #46821:  with Exception Orleans.Runtime.Catalog+NonExistentActivationException: Non-existent activation: [ActivationAddress: S10.31.5.14:100:268955504*grn/2FB327A8/00000000+121772@882812ba Full GrainId: [GrainId: *grn/2FB327A8/00000000000000000000000000000000060000002fb327a8+121772-0x577BB16A IdCategory: KeyExtGrain BaseTypeCode: 800270248 (x2FB327A8) PrimaryKey: 0 (x0) UniformHashCode: 1467724138 (0x577BB16A) KeyExtension: 121772] Full ActivationId: @42851f391a09207a71eff3b7882812ba0000000000000000] grain type: Fun.LegacyTheme.
   at Orleans.Runtime.Catalog.GetOrCreateActivation(ActivationAddress address Boolean newPlacement String grainType String genericArguments Dictionary`2 requestContextData Task&amp; activatedPromise)
   at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)
```

This is unacceptable behavior for us as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4756</IssueLabelID>
    <Title>Upgrade to Microsoft.AzureEventHubs 2.x</Title>
    <Description>
    </Description>
    <Title_Description>Upgrade to Microsoft.AzureEventHubs 2.x </Title_Description>
    <Label>P2</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4755</IssueLabelID>
    <Title>DeadlockDetectionWithoutAllowCallChainReentrancyTests</Title>
    <Description>Added deadlock detection testing when allow call chain reenterancy is turned off.


Testing added to help track down PerformDeadlockDetection not working in 2.0 #4706 
</Description>
    <Title_Description>DeadlockDetectionWithoutAllowCallChainReentrancyTests Added deadlock detection testing when allow call chain reenterancy is turned off.


Testing added to help track down PerformDeadlockDetection not working in 2.0 #4706 
</Title_Description>
    <Label>testing</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4753</IssueLabelID>
    <Title>[WIP] Support configuration of messaging options via MessagingOptions</Title>
    <Description>Fixes #4751</Description>
    <Title_Description>[WIP] Support configuration of messaging options via MessagingOptions Fixes #4751</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4751</IssueLabelID>
    <Title>Response timeout is not respected</Title>
    <Description>We're using 2.0.3 and despite configured 10s timeout for both client (embedded in the same process) and silo we sometimes see 30 second TimeoutException in logs:

```
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request *cli/e89bccba@8e020588-&gt;S10.31.5.13:101:268855415*grn/6EF63849/00000000+133890 #289952: . Target History is: &lt;S10.31.5.13:101:268855415:*grn/6EF63849/00000000+133890:&gt;.
```

I don't understand how that could happen. We have that set in code:

```cs
client.Configure&lt;MessagingOptions&gt;(o =&gt; o.ResponseTimeout = TimeSpan.FromSeconds(10)); 
.....
cluster.Configure&lt;MessagingOptions&gt;(o =&gt; o.ResponseTimeout = TimeSpan.FromSeconds(10));
```

This usually happens after ungraceful shutdown of the silo ...</Description>
    <Title_Description>Response timeout is not respected We're using 2.0.3 and despite configured 10s timeout for both client (embedded in the same process) and silo we sometimes see 30 second TimeoutException in logs:

```
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request *cli/e89bccba@8e020588-&gt;S10.31.5.13:101:268855415*grn/6EF63849/00000000+133890 #289952: . Target History is: &lt;S10.31.5.13:101:268855415:*grn/6EF63849/00000000+133890:&gt;.
```

I don't understand how that could happen. We have that set in code:

```cs
client.Configure&lt;MessagingOptions&gt;(o =&gt; o.ResponseTimeout = TimeSpan.FromSeconds(10)); 
.....
cluster.Configure&lt;MessagingOptions&gt;(o =&gt; o.ResponseTimeout = TimeSpan.FromSeconds(10));
```

This usually happens after ungraceful shutdown of the silo ...</Title_Description>
    <Label>P3</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4750</IssueLabelID>
    <Title>Update Server-Configuration.md</Title>
    <Description>
    </Description>
    <Title_Description>Update Server-Configuration.md </Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4748</IssueLabelID>
    <Title>Exception thrown during OnActivateAsync not posted to client?</Title>
    <Description>I try this: a grain implemented Grain(T) while the entity T can not be found in storage during OnActivateAsync a EntityNotFoundException will be thrown. And the exception will not be posted to the client. How can I handle this error?</Description>
    <Title_Description>Exception thrown during OnActivateAsync not posted to client? I try this: a grain implemented Grain(T) while the entity T can not be found in storage during OnActivateAsync a EntityNotFoundException will be thrown. And the exception will not be posted to the client. How can I handle this error?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4747</IssueLabelID>
    <Title>Small spelling fix in Heterogeneous-Silos.md</Title>
    <Description>some very small spelling fixes</Description>
    <Title_Description>Small spelling fix in Heterogeneous-Silos.md some very small spelling fixes</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>6/07/2018 12:35:35 PM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 7:44:40 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4746</IssueLabelID>
    <Title>Update Configuring-AdoNet-Providers.md</Title>
    <Description>
    </Description>
    <Title_Description>Update Configuring-AdoNet-Providers.md </Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4744</IssueLabelID>
    <Title>Support adding cluster clients to an app's IServiceCollection</Title>
    <Description>Since most modern frontends user either ASP.NET (Mvc or WebApi) and with the new generic Host that was shipped in Microsoft.Extensions.Hosting 2.1 we can expect most Orleans clients will be using the `IServiceCollection` abstraction for building their frontend hosts.
It would be good to provide a simple way to configure an `IClusterClientFactory` that can build 1 or more cluster clients. This can benefit from passing the cross-cutting services configured in the app's container into each of the `IClusterClient`s that get built.
In particular for now pass in the logger factory and the host's configuration (whatever config providers that were configured using Microsoft.Extensions.Configuration) and potentially then use Polly for connection retries etc.

Note that I'm explicitly not suggesting we should share the app's container with the IClusterClient(s) but instead share it with the factory and keep the cluster client's container as an internal implementation that is isolated from the app's container or lifecycle.

We can use [HttpClientFactory as an inspiration](https://github.com/aspnet/HttpClientFactory/blob/master/samples/HttpClientFactorySample/Program.cs).

Then configuring an Orleans cluster client factory would be a matter of calling an extension method on an `IServiceCollection` and configuring the client (or named clients) normally except without explicitly configuring Logging or Configuration.

```
// ... configure MVC logging etc in a generic Host

services.AddClusterClient("some client identifier" c =&gt;
{
    c.UseAzureStorageClustering(...)
    c.Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = "dev";
        options.ServiceId = "HelloWorldApp";
    });
});
```
Of course we can also support a default (non-named) client.

Then you can just inject the `IClusterClientFactory` in your app code to get a hold of a particular client (or just inject the `IClusterClient` if it was registered as default.
The factory can also act as a hosted service (if using the generic Host) to gracefully shutdown all the clients when the host is shutting down.

For reasons why I don't advocate sharing the container 1 is obvious: it would make the assumption that a client library must be configured in the same way as the app host and it wouldn't even support multiple clients. For others there's [this longer chat thread](https://gitter.im/dotnet/orleans?at=5b3e746370efc60660b06f0f) with @galvesribeiro</Description>
    <Title_Description>Support adding cluster clients to an app's IServiceCollection Since most modern frontends user either ASP.NET (Mvc or WebApi) and with the new generic Host that was shipped in Microsoft.Extensions.Hosting 2.1 we can expect most Orleans clients will be using the `IServiceCollection` abstraction for building their frontend hosts.
It would be good to provide a simple way to configure an `IClusterClientFactory` that can build 1 or more cluster clients. This can benefit from passing the cross-cutting services configured in the app's container into each of the `IClusterClient`s that get built.
In particular for now pass in the logger factory and the host's configuration (whatever config providers that were configured using Microsoft.Extensions.Configuration) and potentially then use Polly for connection retries etc.

Note that I'm explicitly not suggesting we should share the app's container with the IClusterClient(s) but instead share it with the factory and keep the cluster client's container as an internal implementation that is isolated from the app's container or lifecycle.

We can use [HttpClientFactory as an inspiration](https://github.com/aspnet/HttpClientFactory/blob/master/samples/HttpClientFactorySample/Program.cs).

Then configuring an Orleans cluster client factory would be a matter of calling an extension method on an `IServiceCollection` and configuring the client (or named clients) normally except without explicitly configuring Logging or Configuration.

```
// ... configure MVC logging etc in a generic Host

services.AddClusterClient("some client identifier" c =&gt;
{
    c.UseAzureStorageClustering(...)
    c.Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = "dev";
        options.ServiceId = "HelloWorldApp";
    });
});
```
Of course we can also support a default (non-named) client.

Then you can just inject the `IClusterClientFactory` in your app code to get a hold of a particular client (or just inject the `IClusterClient` if it was registered as default.
The factory can also act as a hosted service (if using the generic Host) to gracefully shutdown all the clients when the host is shutting down.

For reasons why I don't advocate sharing the container 1 is obvious: it would make the assumption that a client library must be configured in the same way as the app host and it wouldn't even support multiple clients. For others there's [this longer chat thread](https://gitter.im/dotnet/orleans?at=5b3e746370efc60660b06f0f) with @galvesribeiro</Title_Description>
    <Label>P2</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4743</IssueLabelID>
    <Title>Update Grain-Persistence.md - fix typo</Title>
    <Description>Fix typo</Description>
    <Title_Description>Update Grain-Persistence.md - fix typo Fix typo</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4742</IssueLabelID>
    <Title>how to build microsoft orleans source code</Title>
    <Description>run Build.cmd then error msb3802 task failed because csc.dll not found.  i used vs2017 last version. </Description>
    <Title_Description>how to build microsoft orleans source code run Build.cmd then error msb3802 task failed because csc.dll not found.  i used vs2017 last version. </Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4739</IssueLabelID>
    <Title>Transaction attribution test</Title>
    <Description>Added test cases to ensure transaction attribute options (NotSupported Required RequiredNew) properly maintain transaction context.</Description>
    <Title_Description>Transaction attribution test Added test cases to ensure transaction attribute options (NotSupported Required RequiredNew) properly maintain transaction context.</Title_Description>
    <Label>bug</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4736</IssueLabelID>
    <Title>Workaround for CoreFx/#30781 (Fixes #4505)</Title>
    <Description>Fixes #4505 

This implements a workaround for some divergent behavior between .NET Core and .NET Framework tracked by https://github.com/dotnet/corefx/issues/30781

Note that this is intended for a 2.0.4 release.</Description>
    <Title_Description>Workaround for CoreFx/#30781 (Fixes #4505) Fixes #4505 

This implements a workaround for some divergent behavior between .NET Core and .NET Framework tracked by https://github.com/dotnet/corefx/issues/30781

Note that this is intended for a 2.0.4 release.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4735</IssueLabelID>
    <Title>Orleans unobserved exception</Title>
    <Description>With this code: 

```C#
TaskScheduler.UnobservedTaskException += (s e) =&gt; {
    log.LogError(e.Exception "Unobserved exception was thrown.");
    throw e.Exception; // Crashes the application - we wanna nail unobserved exceptions dead.
};
```

I managed to catch this unobserved exception: 

```
Response did not arrive on time in 00:30:00 for message: Request S172.20.0.6:11111:268279491*grn/A8DD5D4F/00000000+NadexConnection_e265e38b1bd24f378bffd67a0ac31ada@abbb4bbd-&gt;S172.20.0.6:11111:268279491*grn/6417C176/7ad6ff8b@7495f5bc 
#164[ForwardCount=2]: . Target History is: &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@7495f5bc&gt;    &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@4fe1c596&gt;    &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@f9f7438b&gt;.
```</Description>
    <Title_Description>Orleans unobserved exception With this code: 

```C#
TaskScheduler.UnobservedTaskException += (s e) =&gt; {
    log.LogError(e.Exception "Unobserved exception was thrown.");
    throw e.Exception; // Crashes the application - we wanna nail unobserved exceptions dead.
};
```

I managed to catch this unobserved exception: 

```
Response did not arrive on time in 00:30:00 for message: Request S172.20.0.6:11111:268279491*grn/A8DD5D4F/00000000+NadexConnection_e265e38b1bd24f378bffd67a0ac31ada@abbb4bbd-&gt;S172.20.0.6:11111:268279491*grn/6417C176/7ad6ff8b@7495f5bc 
#164[ForwardCount=2]: . Target History is: &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@7495f5bc&gt;    &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@4fe1c596&gt;    &lt;S172.20.0.6:11111:268279491:*grn/6417C176/7ad6ff8b:@f9f7438b&gt;.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4734</IssueLabelID>
    <Title>MembershipOracle activating failed</Title>
    <Description>While testing the ability to recover we manage to put the host into an unrecoverable state.

`Exception during Silo.Start
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 19999 ---&gt; System.TimeoutException: MembershipOracle activating failed due to timeout 00:05:00`

Please see attachment for repro:
[OrleansRepro.zip](https://github.com/dotnet/orleans/files/2156999/OrleansRepro.zip)


Note that SQL database is required in this sample as the ADO cluster provider is used.

Repro steps:

1. Start first host. Use silo port 11111 and gw port 30000 (or whatever preferred)
2. Start second host. Use silo port 11112 and gw port 30001 (or whatever preferred)
3. Wait till both instances run
4. Kill first host (ungraceful shutdown)
5. Kill second host (ungraceful shutdown)
6. Do step 1

The host is unable to recover and will eventually crash after a 5min timeout.

However doing a graceful shutdown won't put the host into an unrecoverable state.</Description>
    <Title_Description>MembershipOracle activating failed While testing the ability to recover we manage to put the host into an unrecoverable state.

`Exception during Silo.Start
Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 19999 ---&gt; System.TimeoutException: MembershipOracle activating failed due to timeout 00:05:00`

Please see attachment for repro:
[OrleansRepro.zip](https://github.com/dotnet/orleans/files/2156999/OrleansRepro.zip)


Note that SQL database is required in this sample as the ADO cluster provider is used.

Repro steps:

1. Start first host. Use silo port 11111 and gw port 30000 (or whatever preferred)
2. Start second host. Use silo port 11112 and gw port 30001 (or whatever preferred)
3. Wait till both instances run
4. Kill first host (ungraceful shutdown)
5. Kill second host (ungraceful shutdown)
6. Do step 1

The host is unable to recover and will eventually crash after a 5min timeout.

However doing a graceful shutdown won't put the host into an unrecoverable state.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4733</IssueLabelID>
    <Title>404 for Code Samples link on Orleans Streams page in the documentation</Title>
    <Description>The page at:
[http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html](http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html)

Contains a link to a sample at:
[https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs](https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs)

Which is a 404. I no longer find such a file in the repo.
</Description>
    <Title_Description>404 for Code Samples link on Orleans Streams page in the documentation The page at:
[http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html](http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html)

Contains a link to a sample at:
[https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs](https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs)

Which is a 404. I no longer find such a file in the repo.
</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4731</IssueLabelID>
    <Title>Testing the Ignore method - doesn't work if an exception is thrown synchronously.</Title>
    <Description>I found a situation where the Ignore() method fails to catch exceptions and demonstrated it with the code below.

Method `Works` is marked with the `async` keyword and the `Ignore` function is executed before its exception is thrown so this one has a succesfully-ignored exception.

Method `Explodes` does NOT have the `async` keyword and its exception is thrown before code execution has returned and run the `Ignore` function. So it blows up despite use of `Ignore`. 

In my opinion this is a major "Gotcha" that will catch developers by surprise. (It caught me) Thoughts? 

```C#
using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Threading;
using System.Threading.Tasks;

namespace ConsoleApp3 {
    class Program {

        static void Main(string[] args) {
            MainAsync(args).GetAwaiter().GetResult();
        }

        static Task MainAsync(string[] args) {
            Works().Ignore();
            Explodes().Ignore();
            Console.ReadLine();
            return Task.CompletedTask;
        }

        static async Task Works() {
            throw new Exception("BOOM!");
            await new WebClient().DownloadStringTaskAsync("https://google.com");
        }

        static Task Explodes() {
            throw new Exception("BOOM!");
            return new WebClient().DownloadStringTaskAsync("https://google.com");
        }
    }

    public static class PublicOrleansTaskExtensions {
        private static readonly Action&lt;Task&gt; IgnoreTaskContinuation = t =&gt; { _ = t.Exception; };
        [SuppressMessage("Microsoft.Performance" "CA1804:RemoveUnusedLocals" MessageId = "ignored")]
        public static void Ignore(this Task task) {
            if (task.IsCompleted) {
                _ = task.Exception;
            } else {
                task.ContinueWith(
                    IgnoreTaskContinuation
                    CancellationToken.None
                    TaskContinuationOptions.NotOnRanToCompletion | TaskContinuationOptions.ExecuteSynchronously
                    TaskScheduler.Default);
            }
        }
    }
}
```</Description>
    <Title_Description>Testing the Ignore method - doesn't work if an exception is thrown synchronously. I found a situation where the Ignore() method fails to catch exceptions and demonstrated it with the code below.

Method `Works` is marked with the `async` keyword and the `Ignore` function is executed before its exception is thrown so this one has a succesfully-ignored exception.

Method `Explodes` does NOT have the `async` keyword and its exception is thrown before code execution has returned and run the `Ignore` function. So it blows up despite use of `Ignore`. 

In my opinion this is a major "Gotcha" that will catch developers by surprise. (It caught me) Thoughts? 

```C#
using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Threading;
using System.Threading.Tasks;

namespace ConsoleApp3 {
    class Program {

        static void Main(string[] args) {
            MainAsync(args).GetAwaiter().GetResult();
        }

        static Task MainAsync(string[] args) {
            Works().Ignore();
            Explodes().Ignore();
            Console.ReadLine();
            return Task.CompletedTask;
        }

        static async Task Works() {
            throw new Exception("BOOM!");
            await new WebClient().DownloadStringTaskAsync("https://google.com");
        }

        static Task Explodes() {
            throw new Exception("BOOM!");
            return new WebClient().DownloadStringTaskAsync("https://google.com");
        }
    }

    public static class PublicOrleansTaskExtensions {
        private static readonly Action&lt;Task&gt; IgnoreTaskContinuation = t =&gt; { _ = t.Exception; };
        [SuppressMessage("Microsoft.Performance" "CA1804:RemoveUnusedLocals" MessageId = "ignored")]
        public static void Ignore(this Task task) {
            if (task.IsCompleted) {
                _ = task.Exception;
            } else {
                task.ContinueWith(
                    IgnoreTaskContinuation
                    CancellationToken.None
                    TaskContinuationOptions.NotOnRanToCompletion | TaskContinuationOptions.ExecuteSynchronously
                    TaskScheduler.Default);
            }
        }
    }
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4730</IssueLabelID>
    <Title>Orleans performance issue with GetGrain and saving to Event Store</Title>
    <Description>I'm using Orelans (2.0.3) with SQL database (2017). Database is on the same host where application is located. Currently I'm struggling with performance issue for:

```
var purchaseGrain = _grainFactory.GetGrain&lt;IPurchaseGrain&gt;(id);
await purchaseGrain.Create(id command);
```

**Create** method for test purposes do nothing and looks like:

```
public Task Create(Guid id CreatePurchaseCommand message)
        {
            var @event = new PurchaseCreatedEvent
            {
                Id = id
                Name = message.Name
                Type = message.Type
            };

            return Task.CompletedTask;
        }
```

Time execution of this part takes a long time:

```
var purchaseGrain = _grainFactory.GetGrain&lt;IPurchaseGrain&gt;(id);
await purchaseGrain.Create(id command);
```

Example time execution in miliseconds:
20-40ms

I have also problem with the following part:

```
protected async Task Publish(IEvent @event)
        {
            RaiseEvent(@event); //Rise event works very fast
            await ConfirmEvents(); // here is long time execution issue
        }
```

Example execution time in miliseconds for **ConfirmEvents**:
20-50ms

Those delays causes that I can't process more than 15-30 messages/s.

Everything is working on my local machine with CPU intel core i7 16 GB of RAM.
Please let me know which configruation should I provide to find the reason of this long time execution.
Thanks for any help !</Description>
    <Title_Description>Orleans performance issue with GetGrain and saving to Event Store I'm using Orelans (2.0.3) with SQL database (2017). Database is on the same host where application is located. Currently I'm struggling with performance issue for:

```
var purchaseGrain = _grainFactory.GetGrain&lt;IPurchaseGrain&gt;(id);
await purchaseGrain.Create(id command);
```

**Create** method for test purposes do nothing and looks like:

```
public Task Create(Guid id CreatePurchaseCommand message)
        {
            var @event = new PurchaseCreatedEvent
            {
                Id = id
                Name = message.Name
                Type = message.Type
            };

            return Task.CompletedTask;
        }
```

Time execution of this part takes a long time:

```
var purchaseGrain = _grainFactory.GetGrain&lt;IPurchaseGrain&gt;(id);
await purchaseGrain.Create(id command);
```

Example time execution in miliseconds:
20-40ms

I have also problem with the following part:

```
protected async Task Publish(IEvent @event)
        {
            RaiseEvent(@event); //Rise event works very fast
            await ConfirmEvents(); // here is long time execution issue
        }
```

Example execution time in miliseconds for **ConfirmEvents**:
20-50ms

Those delays causes that I can't process more than 15-30 messages/s.

Everything is working on my local machine with CPU intel core i7 16 GB of RAM.
Please let me know which configruation should I provide to find the reason of this long time execution.
Thanks for any help !</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4729</IssueLabelID>
    <Title>Updated Ignore(this Task) method</Title>
    <Description>https://github.com/dotnet/orleans/issues/4728</Description>
    <Title_Description>Updated Ignore(this Task) method https://github.com/dotnet/orleans/issues/4728</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4728</IssueLabelID>
    <Title>Improve the Ignore method</Title>
    <Description>The `Ignore` extension method implemented in Orleans copied below won't behave as expectedwhen the task is canceled because it uses the `TaskContinuationOptions.OnlyOnFaulted` option. Canceled tasks are not considered faulted and their exception won't be observed.

Therefore tasks that are ignored but get canceled and will still throw an unhandled `OperationCanceledException` or `TaskCanceledException`.

The fix is to either a) update the method summary noting the task will still throw task cancellation exceptions or b) use `TaskContinuationOptions.NotOnRanToCompletion` instead.

``` c#
 /// &lt;summary&gt;
    /// Utility functions for dealing with Tasks.
    /// &lt;/summary&gt;
    public static class PublicOrleansTaskExtensions
    {
        private static readonly Action&lt;Task&gt; IgnoreTaskContinuation = t =&gt; { var ignored = t.Exception; };

        /// &lt;summary&gt;
        /// Observes and ignores a potential exception on a given Task.
        /// If a Task fails and throws an exception which is never observed it will be caught by the .NET finalizer thread.
        /// This function awaits the given task and if the exception is thrown it observes this exception and simply ignores it.
        /// This will prevent the escalation of this exception to the .NET finalizer thread.
        /// &lt;/summary&gt;
        /// &lt;param name="task"&gt;The task to be ignored.&lt;/param&gt;
        [SuppressMessage("Microsoft.Performance" "CA1804:RemoveUnusedLocals" MessageId = "ignored")]
        public static void Ignore(this Task task)
        {
            if (task.IsCompleted)
            {
                var ignored = task.Exception;
            }
            else
            {
                task.ContinueWith(
                    IgnoreTaskContinuation
                    CancellationToken.None
                    TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously
                    TaskScheduler.Default);
            }
        }
    }
```</Description>
    <Title_Description>Improve the Ignore method The `Ignore` extension method implemented in Orleans copied below won't behave as expectedwhen the task is canceled because it uses the `TaskContinuationOptions.OnlyOnFaulted` option. Canceled tasks are not considered faulted and their exception won't be observed.

Therefore tasks that are ignored but get canceled and will still throw an unhandled `OperationCanceledException` or `TaskCanceledException`.

The fix is to either a) update the method summary noting the task will still throw task cancellation exceptions or b) use `TaskContinuationOptions.NotOnRanToCompletion` instead.

``` c#
 /// &lt;summary&gt;
    /// Utility functions for dealing with Tasks.
    /// &lt;/summary&gt;
    public static class PublicOrleansTaskExtensions
    {
        private static readonly Action&lt;Task&gt; IgnoreTaskContinuation = t =&gt; { var ignored = t.Exception; };

        /// &lt;summary&gt;
        /// Observes and ignores a potential exception on a given Task.
        /// If a Task fails and throws an exception which is never observed it will be caught by the .NET finalizer thread.
        /// This function awaits the given task and if the exception is thrown it observes this exception and simply ignores it.
        /// This will prevent the escalation of this exception to the .NET finalizer thread.
        /// &lt;/summary&gt;
        /// &lt;param name="task"&gt;The task to be ignored.&lt;/param&gt;
        [SuppressMessage("Microsoft.Performance" "CA1804:RemoveUnusedLocals" MessageId = "ignored")]
        public static void Ignore(this Task task)
        {
            if (task.IsCompleted)
            {
                var ignored = task.Exception;
            }
            else
            {
                task.ContinueWith(
                    IgnoreTaskContinuation
                    CancellationToken.None
                    TaskContinuationOptions.OnlyOnFaulted | TaskContinuationOptions.ExecuteSynchronously
                    TaskScheduler.Default);
            }
        }
    }
```</Title_Description>
    <Label>P3</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4725</IssueLabelID>
    <Title>Removed unnecessary parts configuration</Title>
    <Description>@jason-bragg </Description>
    <Title_Description>Removed unnecessary parts configuration @jason-bragg </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4722</IssueLabelID>
    <Title>Update Adventure.md</Title>
    <Description>Edited instructions with guidance from @richorama</Description>
    <Title_Description>Update Adventure.md Edited instructions with guidance from @richorama</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4721</IssueLabelID>
    <Title>ServiceId_SiloRestart fails intermittently</Title>
    <Description>
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 19999
2018-06-28T18:46:13.4380282Z       ---- System.TimeoutException : MembershipOracle activating failed due to timeout 00:05:00
2018-06-28T18:46:13.4390296Z       Stack Trace:
2018-06-28T18:46:13.4400270Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(630): at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()
2018-06-28T18:46:13.4410272Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4420308Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4430311Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4440267Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs(670): at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
2018-06-28T18:46:13.4450349Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4460312Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4470268Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4480310Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(2720): at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
2018-06-28T18:46:13.4490358Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4500269Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4520274Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4530310Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\InProcessSiloHandle.cs(360): at Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources)
2018-06-28T18:46:13.4540301Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\TestCluster.cs(5230): at Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort)
2018-06-28T18:46:13.4550314Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\TestCluster.cs(4190): at Orleans.TestingHost.TestCluster.RestartSilo(SiloHandle instance)
2018-06-28T18:46:13.4560208Z         D:\build\agent2\_work\13\s\test\TesterInternal\StreamProvidersTests.cs(900): at UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.&lt;ServiceId_SiloRestart&gt;d__9.MoveNext()
2018-06-28T18:46:13.4570308Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4580241Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4590278Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4600348Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4610265Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4630367Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4640374Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4650422Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4660310Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4670239Z         ----- Inner Stack Trace -----
2018-06-28T18:46:13.4680201Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Async\TaskExtensions.cs(2250): at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext()
2018-06-28T18:46:13.4690294Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4700308Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4710156Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4720307Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(5250): at Orleans.Runtime.Silo.&lt;&lt;OnBecomeActiveStart&gt;g__BecomeActive|72_1&gt;d.MoveNext()
2018-06-28T18:46:13.4730269Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4740231Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4761713Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4770267Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(3930): at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext()
2018-06-28T18:46:13.4780337Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4790334Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4800336Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4820323Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(5270): at Orleans.Runtime.Silo.&lt;OnBecomeActiveStart&gt;d__72.MoveNext()
2018-06-28T18:46:13.4830308Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4840265Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4850267Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4860281Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs(820): at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
2018-06-28T18:46:13.4870306Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4880348Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4890265Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4900353Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(1150): at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext()
2018-06-28T18:46:13.4910389Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4920300Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4930325Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4940265Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(550): at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()</Description>
    <Title_Description>ServiceId_SiloRestart fails intermittently 
Orleans.Runtime.OrleansLifecycleCanceledException : Lifecycle start canceled due to errors at stage 19999
2018-06-28T18:46:13.4380282Z       ---- System.TimeoutException : MembershipOracle activating failed due to timeout 00:05:00
2018-06-28T18:46:13.4390296Z       Stack Trace:
2018-06-28T18:46:13.4400270Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(630): at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()
2018-06-28T18:46:13.4410272Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4420308Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4430311Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4440267Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs(670): at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
2018-06-28T18:46:13.4450349Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4460312Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4470268Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4480310Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(2720): at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
2018-06-28T18:46:13.4490358Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4500269Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4520274Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4530310Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\InProcessSiloHandle.cs(360): at Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources)
2018-06-28T18:46:13.4540301Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\TestCluster.cs(5230): at Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort)
2018-06-28T18:46:13.4550314Z         D:\build\agent2\_work\13\s\src\Orleans.TestingHost\TestCluster.cs(4190): at Orleans.TestingHost.TestCluster.RestartSilo(SiloHandle instance)
2018-06-28T18:46:13.4560208Z         D:\build\agent2\_work\13\s\test\TesterInternal\StreamProvidersTests.cs(900): at UnitTests.Streaming.StreamProvidersTests_ProviderConfigNotLoaded.&lt;ServiceId_SiloRestart&gt;d__9.MoveNext()
2018-06-28T18:46:13.4570308Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4580241Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4590278Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4600348Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4610265Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4630367Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4640374Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4650422Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4660310Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4670239Z         ----- Inner Stack Trace -----
2018-06-28T18:46:13.4680201Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Async\TaskExtensions.cs(2250): at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext()
2018-06-28T18:46:13.4690294Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4700308Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4710156Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4720307Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(5250): at Orleans.Runtime.Silo.&lt;&lt;OnBecomeActiveStart&gt;g__BecomeActive|72_1&gt;d.MoveNext()
2018-06-28T18:46:13.4730269Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4740231Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4761713Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4770267Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(3930): at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext()
2018-06-28T18:46:13.4780337Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4790334Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4800336Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4820323Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Silo\Silo.cs(5270): at Orleans.Runtime.Silo.&lt;OnBecomeActiveStart&gt;d__72.MoveNext()
2018-06-28T18:46:13.4830308Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4840265Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4850267Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4860281Z         D:\build\agent2\_work\13\s\src\Orleans.Runtime\Lifecycle\SiloLifecycleSubject.cs(820): at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
2018-06-28T18:46:13.4870306Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4880348Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4890265Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4900353Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(1150): at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__10.MoveNext()
2018-06-28T18:46:13.4910389Z         --- End of stack trace from previous location where exception was thrown ---
2018-06-28T18:46:13.4920300Z            at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
2018-06-28T18:46:13.4930325Z            at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
2018-06-28T18:46:13.4940265Z         D:\build\agent2\_work\13\s\src\Orleans.Core\Lifecycle\LifecycleSubject.cs(550): at Orleans.LifecycleSubject.&lt;OnStart&gt;d__5.MoveNext()</Title_Description>
    <Label>P2</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4720</IssueLabelID>
    <Title>Several azure storage tests failing due silo lifecycle</Title>
    <Description>PersistenceProvider_Azure_ChangeReadFormat and 23 others are failing due to:

"System.InvalidOperationException : A suitable constructor for type 'Orleans.Runtime.SiloLifecycleSubject' could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor."</Description>
    <Title_Description>Several azure storage tests failing due silo lifecycle PersistenceProvider_Azure_ChangeReadFormat and 23 others are failing due to:

"System.InvalidOperationException : A suitable constructor for type 'Orleans.Runtime.SiloLifecycleSubject' could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor."</Title_Description>
    <Label>test-issue</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4719</IssueLabelID>
    <Title>AzureStorage Reminders does not replace invalide path chars in Row and Partition Keys</Title>
    <Description>Hello

We've experienced an issue recently when our Orleans Cluster has been migrated to Service Fabric.
We are using AzureStorage Table Service for clustering GrainState persistence and Reminders.

As the sample shows us we use the ServiceName of the fabric as the ServiceId of the cluster.
(https://github.com/dotnet/orleans/blob/master/Samples/2.0/ServiceFabric/Stateless/StatelessCalculatorService/StatelessCalculatorService.cs )
&gt; // The service id is unique for the entire service over its lifetime. This is used to identify persistent state
&gt; // such as reminders and grain state.
&gt; options.ServiceId = fabricServiceContext.ServiceName.ToString();

This works well for GrainState PartitionKey since invalid path chars like **/** or **\\** are replaced by underscores:
`fabric:_Silo.ServiceFabric_TheSilo_GrainReference=40080509dab600a3548839c6507585be030000003ab73acd`

But this seems to be not the case for GrainReminders. 
A lot of 400 bad request errors occured because of the PartitionKey name containing invalid path chars. 

&gt; The following characters are not allowed in values for the PartitionKey and RowKey properties:
&gt; 
&gt; The forward slash (/) character
&gt; The backslash (\\) character
&gt; The number sign (#) character
&gt; The question mark (?) character
&gt; Control characters from U+0000 to U+001F including:
&gt; The horizontal tab (\t) character
&gt; The linefeed (\n) character
&gt; The carriage return (\r) character
&gt; Control characters from U+007F to U+009F

The AzureTableReminderService should use the same sanitization mechanism for PartitionKeys and RowKeys of GrainReminders as GrainState. 

Thank you</Description>
    <Title_Description>AzureStorage Reminders does not replace invalide path chars in Row and Partition Keys Hello

We've experienced an issue recently when our Orleans Cluster has been migrated to Service Fabric.
We are using AzureStorage Table Service for clustering GrainState persistence and Reminders.

As the sample shows us we use the ServiceName of the fabric as the ServiceId of the cluster.
(https://github.com/dotnet/orleans/blob/master/Samples/2.0/ServiceFabric/Stateless/StatelessCalculatorService/StatelessCalculatorService.cs )
&gt; // The service id is unique for the entire service over its lifetime. This is used to identify persistent state
&gt; // such as reminders and grain state.
&gt; options.ServiceId = fabricServiceContext.ServiceName.ToString();

This works well for GrainState PartitionKey since invalid path chars like **/** or **\\** are replaced by underscores:
`fabric:_Silo.ServiceFabric_TheSilo_GrainReference=40080509dab600a3548839c6507585be030000003ab73acd`

But this seems to be not the case for GrainReminders. 
A lot of 400 bad request errors occured because of the PartitionKey name containing invalid path chars. 

&gt; The following characters are not allowed in values for the PartitionKey and RowKey properties:
&gt; 
&gt; The forward slash (/) character
&gt; The backslash (\\) character
&gt; The number sign (#) character
&gt; The question mark (?) character
&gt; Control characters from U+0000 to U+001F including:
&gt; The horizontal tab (\t) character
&gt; The linefeed (\n) character
&gt; The carriage return (\r) character
&gt; Control characters from U+007F to U+009F

The AzureTableReminderService should use the same sanitization mechanism for PartitionKeys and RowKeys of GrainReminders as GrainState. 

Thank you</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4717</IssueLabelID>
    <Title>Documentation URL structure makes no sense lacks default pages</Title>
    <Description>Let me walk through this to show what I mean.

I go to the 2.0 Documentation... URL is:
https://dotnet.github.io/orleans/Documentation/Introduction.html

![image](https://user-images.githubusercontent.com/13241564/41998681-36a3ce68-7a53-11e8-993c-d734e5b22231.png)

I remove Introduction.html from the URL. New URL is:
https://dotnet.github.io/orleans/Documentation/

![image](https://user-images.githubusercontent.com/13241564/41998728-5a413c5c-7a53-11e8-9e61-23180b4e993d.png)

Of course removing another level is okay because this is the real root of everything:
https://dotnet.github.io/orleans/

![image](https://user-images.githubusercontent.com/13241564/41998785-7aad3176-7a53-11e8-944b-273ad3d6db73.png)

Now let's go into 1.5 Documentation. URL is:
https://dotnet.github.io/orleans/1.5/Documentation/Introduction.html

Removing the filename and going up one or two levels as you can imagine results in a "this page does not exist".

![image](https://user-images.githubusercontent.com/13241564/41998933-e9559ca8-7a53-11e8-9d7c-23610ca3101b.png)

I think the least we can do here is toss in an index.html in a few places and use it to redirect to Introduction.html.

But if you think about it you have to do that under:

* /orleans/Documentation/ (points to /orleans/Documentation/Introduction.html)
* /orleans/1.5/Documentation/ (points to /orleans/1.5/Documentation/Introduction.html)
* /orleans/1.5/ (points to /orleans/1.5/Documentation/Introduction.html)

I think the above illustrates how the folder structure doesn't make that much sense. Probably that Documentation folder isn't even necessary.

This is obviously not going to change though for link preservation and SEO reasons.</Description>
    <Title_Description>Documentation URL structure makes no sense, lacks default pages Let me walk through this to show what I mean.

I go to the 2.0 Documentation... URL is:
https://dotnet.github.io/orleans/Documentation/Introduction.html

![image](https://user-images.githubusercontent.com/13241564/41998681-36a3ce68-7a53-11e8-993c-d734e5b22231.png)

I remove Introduction.html from the URL. New URL is:
https://dotnet.github.io/orleans/Documentation/

![image](https://user-images.githubusercontent.com/13241564/41998728-5a413c5c-7a53-11e8-9e61-23180b4e993d.png)

Of course removing another level is okay because this is the real root of everything:
https://dotnet.github.io/orleans/

![image](https://user-images.githubusercontent.com/13241564/41998785-7aad3176-7a53-11e8-944b-273ad3d6db73.png)

Now let's go into 1.5 Documentation. URL is:
https://dotnet.github.io/orleans/1.5/Documentation/Introduction.html

Removing the filename and going up one or two levels as you can imagine results in a "this page does not exist".

![image](https://user-images.githubusercontent.com/13241564/41998933-e9559ca8-7a53-11e8-9d7c-23610ca3101b.png)

I think the least we can do here is toss in an index.html in a few places and use it to redirect to Introduction.html.

But if you think about it you have to do that under:

* /orleans/Documentation/ (points to /orleans/Documentation/Introduction.html)
* /orleans/1.5/Documentation/ (points to /orleans/1.5/Documentation/Introduction.html)
* /orleans/1.5/ (points to /orleans/1.5/Documentation/Introduction.html)

I think the above illustrates how the folder structure doesn't make that much sense. Probably that Documentation folder isn't even necessary.

This is obviously not going to change though for link preservation and SEO reasons.</Title_Description>
    <Label>P1</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4716</IssueLabelID>
    <Title>Fixed intermittent Transaction test failures</Title>
    <Description>Tests where unnessessarily fanning out to 64 transactional states when only 8 where necessary for testing.  This led to intermittent failures due to timeouts.  They now only run against the targeted 8 transactional states.</Description>
    <Title_Description>Fixed intermittent Transaction test failures Tests where unnessessarily fanning out to 64 transactional states when only 8 where necessary for testing.  This led to intermittent failures due to timeouts.  They now only run against the targeted 8 transactional states.</Title_Description>
    <Label>test-issue</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4713</IssueLabelID>
    <Title>Do not use ip address from interface not operational</Title>
    <Description>Should fix #4524 </Description>
    <Title_Description>Do not use ip address from interface not operational Should fix #4524 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4712</IssueLabelID>
    <Title>Runtime motioning on 1.5.x</Title>
    <Description>https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html

there's only documentation on how to add Application insights and new relic for 2.0.
is this usable on 1.5.x? would be pretty helpful.</Description>
    <Title_Description>Runtime motioning on 1.5.x https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Monitoring/Runtime-Monitoring.html

there's only documentation on how to add Application insights and new relic for 2.0.
is this usable on 1.5.x? would be pretty helpful.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4710</IssueLabelID>
    <Title>IGrainStorage null implementation registerd in DI container</Title>
    <Description>We currently add the mapping:
services.TryAddSingleton&lt;IGrainStorage&gt;(sp =&gt; sp.GetServiceByName&lt;IGrainStorage&gt;(ProviderConstants.DEFAULT_STORAGE_PROVIDER_NAME));
any time we add a grain storage not just when the default is added. This is wasteful but also seems to break some containers as returning null for a registered service is considered invalid for some containers. I'm not sure what the 'conforming container' rules are around this but it's sloppy in any case.</Description>
    <Title_Description>IGrainStorage null implementation registerd in DI container We currently add the mapping:
services.TryAddSingleton&lt;IGrainStorage&gt;(sp =&gt; sp.GetServiceByName&lt;IGrainStorage&gt;(ProviderConstants.DEFAULT_STORAGE_PROVIDER_NAME));
any time we add a grain storage not just when the default is added. This is wasteful but also seems to break some containers as returning null for a registered service is considered invalid for some containers. I'm not sure what the 'conforming container' rules are around this but it's sloppy in any case.</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4709</IssueLabelID>
    <Title>Message response delay on serialization failures</Title>
    <Description>We observe a situation where Orleans don't return a response immediately on serialization failures but rather response is timing out. Is this by design? </Description>
    <Title_Description>Message response delay on serialization failures We observe a situation where Orleans don't return a response immediately on serialization failures but rather response is timing out. Is this by design? </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4708</IssueLabelID>
    <Title>What happens if I don't await an async operation</Title>
    <Description>We're using a timeout for slow storage request but since the built in blob storage provider doesn't expose any time out configuration we just stop waiting for the task to complete instead of canceling it (basically racing it with a timeout task we're using Polly's pessimistic timeout for this).

What effect does something like that have in Orleans?
</Description>
    <Title_Description>What happens if I don't await an async operation We're using a timeout for slow storage request but since the built in blob storage provider doesn't expose any time out configuration we just stop waiting for the task to complete instead of canceling it (basically racing it with a timeout task we're using Polly's pessimistic timeout for this).

What effect does something like that have in Orleans?
</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4706</IssueLabelID>
    <Title>PerformDeadlockDetection not working in 2.0</Title>
    <Description>Enabling PerformDeadlockDetection on Silo prevents Orleans Client from connecting with following TypeAccessException:

![image](https://user-images.githubusercontent.com/20849443/41804305-78c87750-76d7-11e8-8db0-67ce2cfcde6e.png)

![image](https://user-images.githubusercontent.com/20849443/41804275-e9835cea-76d6-11e8-96c2-4c27d2b5eaf6.png)

Not sure if I'm missing a certain package or if this is an Orleans bug.</Description>
    <Title_Description>PerformDeadlockDetection not working in 2.0 Enabling PerformDeadlockDetection on Silo prevents Orleans Client from connecting with following TypeAccessException:

![image](https://user-images.githubusercontent.com/20849443/41804305-78c87750-76d7-11e8-8db0-67ce2cfcde6e.png)

![image](https://user-images.githubusercontent.com/20849443/41804275-e9835cea-76d6-11e8-96c2-4c27d2b5eaf6.png)

Not sure if I'm missing a certain package or if this is an Orleans bug.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4705</IssueLabelID>
    <Title>Server Core OS support</Title>
    <Description>Hi

I can't find a list of supported operating systems in any documentation.  Is Orleans supported running on Server 2016 Core?  My assumption is it is but wanted confirmation.

Thanks.</Description>
    <Title_Description>Server Core OS support Hi

I can't find a list of supported operating systems in any documentation.  Is Orleans supported running on Server 2016 Core?  My assumption is it is but wanted confirmation.

Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>22/06/2018 11:21:18 AM +00:00</CreatedAt>
    <ClosedAt>22/06/2018 11:24:35 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4703</IssueLabelID>
    <Title>Update Microsoft.Extensions.Options to 2.1.1 and remove duplicate functionality</Title>
    <Description>Now that Options 2.1.x is released we can update to it and remove:

* `OptionBuilder&lt;T&gt;`
* `OptionsServiceCollectionExtensions`
* `OptionsBuilderConfigurationExtensions`
* `ConfigureNamedOptions&lt;TOptions TDep&gt;`
* `PostConfigureOptions&lt;TOptions TDep&gt;`

Note that this would be considered a breaking change since it removes those types (some of which are public) and modifies many configuration APIs to use the equivalent types in the options package (same type names different namespace &amp; assembly)

However if we don't do it then we may see some clashes for users who update that package on their own accord (eg since it's a dependency of ASP.NET bits).

Question is: are we ok with that minor breakage and what kind of version bump do we want to associate with it a minor (2.1.0) or a major (3.0.0)?

PoC branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:update-options</Description>
    <Title_Description>Update Microsoft.Extensions.Options to 2.1.1 and remove duplicate functionality Now that Options 2.1.x is released we can update to it and remove:

* `OptionBuilder&lt;T&gt;`
* `OptionsServiceCollectionExtensions`
* `OptionsBuilderConfigurationExtensions`
* `ConfigureNamedOptions&lt;TOptions TDep&gt;`
* `PostConfigureOptions&lt;TOptions TDep&gt;`

Note that this would be considered a breaking change since it removes those types (some of which are public) and modifies many configuration APIs to use the equivalent types in the options package (same type names different namespace &amp; assembly)

However if we don't do it then we may see some clashes for users who update that package on their own accord (eg since it's a dependency of ASP.NET bits).

Question is: are we ok with that minor breakage and what kind of version bump do we want to associate with it a minor (2.1.0) or a major (3.0.0)?

PoC branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:update-options</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4702</IssueLabelID>
    <Title>Support Microsoft.Extensions.Hosting.Abstractions</Title>
    <Description>In Orleans 2.0 we added `SiloHostBuilder` which was designed to align with `IHostBuilder` from the `Microsoft.Extensions.Hosting.Abstractions` package (which wasn't yet released).

The intention was that `SiloHostBuilder` would be temporary and we would add support for the [generic host](https://github.com/aspnet/Hosting/issues/1163) once it became available.

It's available now so we can consider adding support for it.

ASP.NET folks have a similar issue opened for `WebHostBuilder`: https://github.com/aspnet/Hosting/issues/1421. They've scheduled it for 3.0.0 so I imagine it will be a year or more before they move over.

I have a PoC for this on a branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:feature-generic-host

cc @galvesribeiro &amp; @attilah who asked for this today</Description>
    <Title_Description>Support Microsoft.Extensions.Hosting.Abstractions In Orleans 2.0 we added `SiloHostBuilder` which was designed to align with `IHostBuilder` from the `Microsoft.Extensions.Hosting.Abstractions` package (which wasn't yet released).

The intention was that `SiloHostBuilder` would be temporary and we would add support for the [generic host](https://github.com/aspnet/Hosting/issues/1163) once it became available.

It's available now so we can consider adding support for it.

ASP.NET folks have a similar issue opened for `WebHostBuilder`: https://github.com/aspnet/Hosting/issues/1421. They've scheduled it for 3.0.0 so I imagine it will be a year or more before they move over.

I have a PoC for this on a branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:feature-generic-host

cc @galvesribeiro &amp; @attilah who asked for this today</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4701</IssueLabelID>
    <Title>Clear the data generated by PubSubRendezvousGrain</Title>
    <Description>I use: 
`AddSimpleMessageStreamProvider`
`AddAdoNetGrainStorage`

1、When I generate Guid different PubSubRendezvousGrain generates a lot of data is there a function to clear them?
</Description>
    <Title_Description>Clear the data generated by PubSubRendezvousGrain I use: 
`AddSimpleMessageStreamProvider`
`AddAdoNetGrainStorage`

1、When I generate Guid different PubSubRendezvousGrain generates a lot of data is there a function to clear them?
</Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4700</IssueLabelID>
    <Title>Grain Disambiguation</Title>
    <Description>I am working on the project that some grain implementations inherit from an abstract grain implementation . 
Some just like this:
public abstract class A: Grain IGrainInterface
{
abstract method(); 
}

public class B: A
{
override method();
}

public class C: A
{
override method()
}

It seems I can use a grainClassNamePrefix to solve this problem but I haven't found any documents to describe how to use it. 

Thanks!</Description>
    <Title_Description>Grain Disambiguation I am working on the project that some grain implementations inherit from an abstract grain implementation . 
Some just like this:
public abstract class A: Grain IGrainInterface
{
abstract method(); 
}

public class B: A
{
override method();
}

public class C: A
{
override method()
}

It seems I can use a grainClassNamePrefix to solve this problem but I haven't found any documents to describe how to use it. 

Thanks!</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>19/06/2018 10:04:19 PM +00:00</CreatedAt>
    <ClosedAt>20/06/2018 7:07:27 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4697</IssueLabelID>
    <Title>InconsistentStateException with ADO.NET SQL Server grain storage</Title>
    <Description>We've been getting this exception for a while in various grains. Particularly one which is activated in a `StartupTask` that should never be deactivated. If I've understood correctly this can happen when there are duplicate activations of a grain (this happens perhaps during deployments) - so question is what do you do when that happens? Do you have to catch it and `DeactivateOnIdle`? Do you call `ReadStateAsync` and lose that data? We had a grain that during the lifetime of the activation never again could write to state so I'm wondering how you recover from it. I couldn't find info on this in docs maybe I missed it</Description>
    <Title_Description>InconsistentStateException with ADO.NET SQL Server grain storage We've been getting this exception for a while in various grains. Particularly one which is activated in a `StartupTask` that should never be deactivated. If I've understood correctly this can happen when there are duplicate activations of a grain (this happens perhaps during deployments) - so question is what do you do when that happens? Do you have to catch it and `DeactivateOnIdle`? Do you call `ReadStateAsync` and lose that data? We had a grain that during the lifetime of the activation never again could write to state so I'm wondering how you recover from it. I couldn't find info on this in docs maybe I missed it</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4696</IssueLabelID>
    <Title>Management Grain took to long</Title>
    <Description>i had this warning on a silo that was running using sql server liveness
WARNING	101215	Scheduler.WorkItemGroup	10.1.0.6:22222]	Task [Id=-1500906100 Status=RanToCompletion] in WorkGroup [Activation: S10.1.0.6:22222:265810487*grn/7483D9D2/00000000@b4f381b7 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:08.6929183 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=10 Executing Task Id=-1500906100 Status=RanToCompletion for 00:00:08.6914987 on WorkItem=WorkItemGroup:Name=[Activation: S10.1.0.6:22222:265810487*grn/7483D9D2/00000000@b4f381b7 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:08.6914987. .&gt;	

it is stating that the management grain took 8 seconds i am using orleans 1.4.2
after that i got a callbackdata took 30 seconds error.
what would cause such behaviour ?

</Description>
    <Title_Description>Management Grain took to long i had this warning on a silo that was running using sql server liveness
WARNING	101215	Scheduler.WorkItemGroup	10.1.0.6:22222]	Task [Id=-1500906100 Status=RanToCompletion] in WorkGroup [Activation: S10.1.0.6:22222:265810487*grn/7483D9D2/00000000@b4f381b7 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement State=Valid] took elapsed time 0:00:08.6929183 for execution which is longer than 00:00:00.2000000. Running on thread &lt;Runtime.Scheduler.WorkerPoolThread/3 ManagedThreadId=10 Executing Task Id=-1500906100 Status=RanToCompletion for 00:00:08.6914987 on WorkItem=WorkItemGroup:Name=[Activation: S10.1.0.6:22222:265810487*grn/7483D9D2/00000000@b4f381b7 #GrainType=Orleans.Runtime.Management.ManagementGrain Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:00:08.6914987. .&gt;	

it is stating that the management grain took 8 seconds i am using orleans 1.4.2
after that i got a callbackdata took 30 seconds error.
what would cause such behaviour ?

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4694</IssueLabelID>
    <Title>orleans rebalancing</Title>
    <Description>the load balancing and rebalancing grains into siloes is a very important topicplease provide us with an indepth look at it.
</Description>
    <Title_Description>orleans rebalancing the load balancing and rebalancing grains into siloes is a very important topicplease provide us with an indepth look at it.
</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4693</IssueLabelID>
    <Title>How to get Grain primary key from GrainReference string key</Title>
    <Description>Hey
we're using azure blob storage for grain state persistence.
all our grains are IGrainWithGuidKey.
We're investigating storage issues getting lots of 404 errors for blobs.
our problem is the primary key in the grainState table looks like this:
GrainReference=11e798b4058027ec3ea216eb790ad2bf03ffffff810989d7

how do we get the grain's primary key from this? i want to be able to troubleshoot this but this grainReference string means nothing to me.</Description>
    <Title_Description>How to get Grain primary key from GrainReference string key Hey
we're using azure blob storage for grain state persistence.
all our grains are IGrainWithGuidKey.
We're investigating storage issues getting lots of 404 errors for blobs.
our problem is the primary key in the grainState table looks like this:
GrainReference=11e798b4058027ec3ea216eb790ad2bf03ffffff810989d7

how do we get the grain's primary key from this? i want to be able to troubleshoot this but this grainReference string means nothing to me.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4692</IssueLabelID>
    <Title>Docs: Possible mistake in "Unreliable Deployment on a Cluster of Dedicated Servers"</Title>
    <Description>I tried to follow the guide for DevelopmentClustering
https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.md/#unreliable-deployment-on-a-cluster-of-dedicated-servers

When I ran the code the client couldn't connect so I tried changing the client port in the .UseStaticClustering()-call to the gateway port (30000). That seemed to do the trick.

I guess that it's a typo in the Docs but I'm extremely new to Orleans so I don't want to assume to much.

If it is a typo I can fix it and submit a PR

Also the ClusterId and and ServiceId mismatch between the silo and the client config but I caught that before I even tried to run the code.</Description>
    <Title_Description>Docs: Possible mistake in "Unreliable Deployment on a Cluster of Dedicated Servers" I tried to follow the guide for DevelopmentClustering
https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.md/#unreliable-deployment-on-a-cluster-of-dedicated-servers

When I ran the code the client couldn't connect so I tried changing the client port in the .UseStaticClustering()-call to the gateway port (30000). That seemed to do the trick.

I guess that it's a typo in the Docs but I'm extremely new to Orleans so I don't want to assume to much.

If it is a typo I can fix it and submit a PR

Also the ClusterId and and ServiceId mismatch between the silo and the client config but I caught that before I even tried to run the code.</Title_Description>
    <Label>P1</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4691</IssueLabelID>
    <Title>Enhance ADO.NET with ability to create user supplied tuning knobs</Title>
    <Description>This issue records some ideas from Gitter discussion with regards ADO.NET functionality. This started from an idea to make using "non-official" libraries easier such as https://mysql-net.github.io/MySqlConnector/ but it appears this library is drop-in compatible with the official one so for that case this refactoring isn't strictly needed. It may be there are others that are not.

Currently the ADO.NET provider does not surface the options to load the library to the public configuration surface but instead uses a user-supplied (well-known) ADO.NET invariant to load libraries. It happens at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/DbConnectionFactory.cs#L26 and the options being set are at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/DbConstantsStore.cs#L43 and used at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/RelationalStorage.cs#L274 for instance.

It could be beneficial to:
1. Consider that now that .NET Standard has again included `DbProviderFactory` if it could be used in the future (see at https://github.com/dotnet/corefx/issues/20903)
2. give the user an ability to change some of configuration values in `ConstantsStore` (such as if it's non-blocking or not)
3. give the user the option to supply the path to the connector dll to be loaded
4. and optionally create an utility function to extract the version of the library so it would become possible to just determine somewhat automatically if the library has certain properties such as truly non-blocking queries as-per some version.

It's notable these options are there to give some very fine-tuning knobs to certain situations but aren't strictly necessary.</Description>
    <Title_Description>Enhance ADO.NET with ability to create user supplied tuning knobs This issue records some ideas from Gitter discussion with regards ADO.NET functionality. This started from an idea to make using "non-official" libraries easier such as https://mysql-net.github.io/MySqlConnector/ but it appears this library is drop-in compatible with the official one so for that case this refactoring isn't strictly needed. It may be there are others that are not.

Currently the ADO.NET provider does not surface the options to load the library to the public configuration surface but instead uses a user-supplied (well-known) ADO.NET invariant to load libraries. It happens at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/DbConnectionFactory.cs#L26 and the options being set are at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/DbConstantsStore.cs#L43 and used at https://github.com/dotnet/orleans/blob/master/src/AdoNet/Shared/Storage/RelationalStorage.cs#L274 for instance.

It could be beneficial to:
1. Consider that now that .NET Standard has again included `DbProviderFactory` if it could be used in the future (see at https://github.com/dotnet/corefx/issues/20903)
2. give the user an ability to change some of configuration values in `ConstantsStore` (such as if it's non-blocking or not)
3. give the user the option to supply the path to the connector dll to be loaded
4. and optionally create an utility function to extract the version of the library so it would become possible to just determine somewhat automatically if the library has certain properties such as truly non-blocking queries as-per some version.

It's notable these options are there to give some very fine-tuning knobs to certain situations but aren't strictly necessary.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>veikkoeeva</Assignee>
    <CreatedAt>15/06/2018 5:55:30 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4688</IssueLabelID>
    <Title>Rename UseDistributedTM method</Title>
    <Description>The `UseDistributedTM()` method sits on `IServiceCollection` and `ISiloHostBuilder` but there's no way that we should have a method so ambiguously named.

Please rename to `UseDistributedTransactionManager` or something more obvious.</Description>
    <Title_Description>Rename UseDistributedTM method The `UseDistributedTM()` method sits on `IServiceCollection` and `ISiloHostBuilder` but there's no way that we should have a method so ambiguously named.

Please rename to `UseDistributedTransactionManager` or something more obvious.</Title_Description>
    <Label>P2</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4687</IssueLabelID>
    <Title>2.0.3 versions of TelemetryConsumers.AI and TelemetryConsumers.NewRelic haven't been released</Title>
    <Description>#4392 had fixes for these packages but we haven't released them.</Description>
    <Title_Description>2.0.3 versions of TelemetryConsumers.AI and TelemetryConsumers.NewRelic haven't been released #4392 had fixes for these packages but we haven't released them.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4686</IssueLabelID>
    <Title>EHStatistics_MonitorCalledAccordingly test fails intermittently</Title>
    <Description>ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.EHStatistics_MonitorCalledAccordingly

MESSAGE:
Assert.True() Failure\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.AssertCacheMonitorCallCounters(CacheMonitorCounters totalCacheMonitorCallCounters) in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 118 at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.&lt;EHStatistics_MonitorCalledAccordingly&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 103 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>EHStatistics_MonitorCalledAccordingly test fails intermittently ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.EHStatistics_MonitorCalledAccordingly

MESSAGE:
Assert.True() Failure\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.AssertCacheMonitorCallCounters(CacheMonitorCounters totalCacheMonitorCallCounters) in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 118 at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.&lt;EHStatistics_MonitorCalledAccordingly&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 103 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>testing</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4685</IssueLabelID>
    <Title>Fix more bugs in transactions code</Title>
    <Description>While developing the randomized consistency tests I found more bugs. These are the fixes.
</Description>
    <Title_Description>Fix more bugs in transactions code While developing the randomized consistency tests I found more bugs. These are the fixes.
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4683</IssueLabelID>
    <Title>Orleans.TelemetryConsumers.AI and Telemetry interfaces are not DI and usage friendly</Title>
    <Description>We are upgrading our Orleans solution from 1.5.x to 2.0 and we have to port the telemetry consumer code for the new version.
We are using the Application Insights telemetry consumer and the current implementation looks like this which is not to friendly to use it.

```
    public class SampleTelemetryGrain : Grain ISampleTelemetryGrain
    {
        public readonly ITraceTelemetryConsumer _traceTelemetry;
        public readonly IEventTelemetryConsumer _eventTelemetry;
        public readonly IExceptionTelemetryConsumer _exceptionTelemetry;

        public SampleTelemetryGrain(ITraceTelemetryConsumer traceTelemetry IEventTelemetryConsumer eventTelemetry IExceptionTelemetryConsumer exceptionTelemetry)
        {
            _traceTelemetry = traceTelemetry;
            _eventTelemetry = eventTelemetry;
            _exceptionTelemetry = exceptionTelemetry;
        }

        public Task DoSomthing()
        {
            try
            {
                _eventTelemetry.TrackEvent("Event");
                _traceTelemetry.TrackTrace("Event" Severity.Info);
                //Do somthing
            }
            catch (Exception ex)
            {
                _exceptionTelemetry.TrackException(ex);
                throw;
            }
            return Task.CompletedTask;
        }
    }

```
I also for this I have to register all these interfaces into the DI container separately

Would be great a Common Interface to register and use.

</Description>
    <Title_Description>Orleans.TelemetryConsumers.AI and Telemetry interfaces are not DI and usage friendly We are upgrading our Orleans solution from 1.5.x to 2.0 and we have to port the telemetry consumer code for the new version.
We are using the Application Insights telemetry consumer and the current implementation looks like this which is not to friendly to use it.

```
    public class SampleTelemetryGrain : Grain ISampleTelemetryGrain
    {
        public readonly ITraceTelemetryConsumer _traceTelemetry;
        public readonly IEventTelemetryConsumer _eventTelemetry;
        public readonly IExceptionTelemetryConsumer _exceptionTelemetry;

        public SampleTelemetryGrain(ITraceTelemetryConsumer traceTelemetry IEventTelemetryConsumer eventTelemetry IExceptionTelemetryConsumer exceptionTelemetry)
        {
            _traceTelemetry = traceTelemetry;
            _eventTelemetry = eventTelemetry;
            _exceptionTelemetry = exceptionTelemetry;
        }

        public Task DoSomthing()
        {
            try
            {
                _eventTelemetry.TrackEvent("Event");
                _traceTelemetry.TrackTrace("Event" Severity.Info);
                //Do somthing
            }
            catch (Exception ex)
            {
                _exceptionTelemetry.TrackException(ex);
                throw;
            }
            return Task.CompletedTask;
        }
    }

```
I also for this I have to register all these interfaces into the DI container separately

Would be great a Common Interface to register and use.

</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4681</IssueLabelID>
    <Title>Resubmitting #4667 for an unsquashed merge</Title>
    <Description>#4667 got squash-merged which is not good for tracking history. I reset the 1.5.4 branch so that these fixes can be re-merged without getting squashed.</Description>
    <Title_Description>Resubmitting #4667 for an unsquashed merge #4667 got squash-merged which is not good for tracking history. I reset the 1.5.4 branch so that these fixes can be re-merged without getting squashed.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4680</IssueLabelID>
    <Title>Silo can't start in docker</Title>
    <Description>I have strange error that can be reproduced in docker container only. When I run my application as regular application(not in the docker) all works as expected. 
What is interesting that the silo terminating in case when there is a startup task and orphan records in OrleansMembershipTable table I use ado.net membership.
If I remove orphan records from OrleansMembershipTable table or comment my startup task silo able to start and works.
Startup task activate a grain with reminder and timer for several background staff.

Below the full log of orleans from docker. 
I've skipped several sensitive info from the log
I use .NET 462 Orleans 2.0.3
&lt;details&gt;
&lt;summary&gt;Full Orleans Log&lt;/summary&gt;
&lt;pre&gt;
host.server_1   | [12:45:10 WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
host.server_1   | [12:45:10 INF] Starting OrleansTaskScheduler with 4 Max Active application Threads and 1 system thread.
host.server_1   | [12:45:10 INF] Silo starting with GC settings: ServerGC=True GCLatencyMode=Interactive
host.server_1   | [12:45:10 INF] -------------- Initializing silo on host 5a5cb449241b MachineName 5A5CB449241B at 172.26.83.96:11111 gen 266492710 --------------
host.server_1   | [12:45:10 INF] Starting silo Silo_d97f1
host.server_1   | [12:45:10 INF] Opened a listening socket at address 0.0.0.0:11111
host.server_1   | [12:45:10 INF] Opened a listening socket at address 0.0.0.0:30000
host.server_1   | [12:45:10 INF] Starting VirtualBucketsRingProvider on silo S172.26.83.96:11111:266492710/x28220225.
host.server_1   | [12:45:10 INF] Added Server S172.26.83.96:11111:266492710/x28220225. Current view: [S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]
host.server_1   | [12:45:10 INF] -NotifyLocalRangeSubscribers about old &lt;(0 0] Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True
host.server_1   | [12:45:11 INF] Skip multicluster oracle creation (no multicluster network configured)
host.server_1   | [12:45:11 INF] -------------- Started silo S172.26.83.96:11111:266492710 ConsistentHashCode 28220225 --------------
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.5 on managed thread 7
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 on managed thread 8
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 on managed thread 9
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 on managed thread 10
host.server_1   | [12:45:11 INF] Start Scheduler took 11 Milliseconds to finish
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 on managed thread 11
host.server_1   | [12:45:11 INF] Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 4000: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 8000: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 10000: Orleans.Runtime.Versions.GrainVersionStore Orleans.Storage.AdoNetGrainStorage-Default Orleans.Storage.AdoNetGrainStorage-OrleansStorage
host.server_1   | [12:45:11 INF] Stage 19999: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 20000: Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Start InsideRuntimeClient took 9 Milliseconds
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.InsideRuntimeClient started in stage 2000 which took 10 Milliseconds.
host.server_1   | [12:45:11 INF] Silo Start()
host.server_1   | [12:45:11 INF] Configured ThreadPool.SetMinThreads() to values: 200200. Previous values are: 22.
host.server_1   | [12:45:11 INF] Configured .NET ServicePointManager to Expect100Continue=False DefaultConnectionLimit=200 UseNagleAlgorithm=False to improve Azure storage performance.
host.server_1   | [12:45:11 INF] ConfigureThreadPoolAndServicePointSettings took 4 Milliseconds to finish
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 2000 which took 10 Milliseconds.
host.server_1   | [12:45:11 INF] Starting lifecycle stage 2000 took 24 Milliseconds
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAcceptor on managed thread 12
host.server_1   | [12:45:11 INF] Stopping AsyncAgent Runtime.Messaging.IncomingMessageAcceptor that runs on managed thread 12
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender on managed thread 13
host.server_1   | [12:45:11 INF] Start Message center took 3 Milliseconds to finish
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender on managed thread 15
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Ping on managed thread 16
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/System on managed thread 17
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Application on managed thread 18
host.server_1   | [12:45:11 INF] Start Incoming message agents took 2 Milliseconds to finish
host.server_1   | [12:45:11 INF] Start
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 19
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 20
host.server_1   | [12:45:11 INF] Stopping AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer that runs on managed thread 20
host.server_1   | [12:45:11 INF] Start local grain directory took 7 Milliseconds to finish
host.server_1   | [12:45:11 INF] Init implicit stream subscribe table took 5 Milliseconds to finish
host.server_1   | [12:45:11 INF] Creating reminder grain service for type=Orleans.Runtime.ReminderService.AdoNetReminderTable
host.server_1   | [12:45:11 INF] Create system targets and inject dependencies took 42 Milliseconds to finish
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 65 Milliseconds.
host.server_1   | [12:45:11 INF] Starting lifecycle stage 4000 took 65 Milliseconds
host.server_1   | [12:45:11 INF] Init transaction agent took 3 Milliseconds to finish
host.server_1   | [12:45:11 INF] Before collection#1: memory=14MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
host.server_1   | [12:45:11 INF] Init grain services took 2 Milliseconds to finish
host.server_1   | [12:45:11 INF] After collection#1: memory=14MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0070010.
host.server_1   | [12:45:11 INF] MembershipOracle starting on host = 5a5cb449241b address = S172.26.83.96:11111:266492710 at 2018-06-12 09:45:10.206 GMT backOffMax = 00:00:20
host.server_1   | [12:45:14 INF] -CleanupTable called on silo startup. Membership table 2 silos 1 are Active 1 are Dead Version=&lt;26 26&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:14 INF] Starting IAmAliveUpdateTimer.
host.server_1   | [12:45:14 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:14 AM no update for 03:02:26.0940000 which is more than 00:10:00.
host.server_1   | [12:45:14 INF] Starting local silo status oracle took 2980 Milliseconds to finish
host.server_1   | [12:45:14 INF] OnRefreshClusterMapTimer: refresh start
host.server_1   | [12:45:14 INF] Init type manager took 13 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting Windows perf counter stats collection with frequency=00:00:30
host.server_1   | [12:45:14 INF] Start silo statistics took 1 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting DeploymentLoadPublisher.
host.server_1   | [12:45:14 INF] Started DeploymentLoadPublisher.
host.server_1   | [12:45:14 INF] Start deployment load collector took 16 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting Silo Watchdog.
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 8000 which took 3026 Milliseconds.
host.server_1   | [12:45:14 INF] Starting lifecycle stage 8000 took 3026 Milliseconds
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Watchdog on managed thread 35
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore started in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:14 INF] Initialized storage provider: ServiceId=ServiceId-123 ProviderName=Default Invariant=System.Data.SqlClient ConnectionString=[skiped].
host.server_1   | [12:45:14 INF] Initialized storage provider: ServiceId=ServiceId-123 ProviderName=OrleansStorage Invariant=System.Data.SqlClient ConnectionString=[skiped].
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-Default started in stage 10000 which took 14 Milliseconds.
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-OrleansStorage started in stage 10000 which took 40 Milliseconds.
host.server_1   | [12:45:14 INF] Starting lifecycle stage 10000 took 40 Milliseconds
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Messaging.GatewayAcceptor on managed thread 38
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Messaging.GatewayClientCleanupAgent on managed thread 39
host.server_1   | [12:45:14 INF] Stopping AsyncAgent Runtime.Messaging.GatewayAcceptor that runs on managed thread 38
host.server_1   | [12:45:14 INF] Start gateway took 3 Milliseconds to finish
host.server_1   | [12:45:14 INF] -BecomeActive
host.server_1   | [12:45:16 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:16 AM no update for 03:02:28.1730000 which is more than 00:10:00.
host.server_1   | [12:45:16 INF] About to send pings to 0 nodes in order to validate communication in the Joining state. Pinged nodes = []
host.server_1   | [12:45:16 INF] -ReadAll (called from BecomeActive) Membership table 3 silos 2 are Active 1 are Dead Version=&lt;28 28&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.83.96:11111:266492710 SiloName=Silo_d97f1 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:16 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:16 AM no update for 03:02:28.2200000 which is more than 00:10:00.
host.server_1   | [12:45:16 INF] Added Server S172.26.95.237:11111:266481757/xA47E0772. Current view: [S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; S172.26.95.237:11111:266481757 -&gt; &lt;MultiRange: Size=x95B149A2 %Ring=58.474%&gt;]
host.server_1   | [12:45:16 INF] -NotifyLocalRangeSubscribers about old &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; increased? True
host.server_1   | [12:45:16 INF] Will watch (actively ping) 1 silos: [S172.26.95.237:11111:266481757]
host.server_1   | [12:45:16 INF] -ReadAll (called from BecomeActive after local view changed with removed duplicate deads) Membership table: 3 silos 2 are Active 1 are Dead Version=&lt;28 28&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.83.96:11111:266492710 SiloName=Silo_d97f1 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:16 INF] -Finished BecomeActive.
host.server_1   | [12:45:16 INF] Starting local silo status oracle took 2097 Milliseconds to finish
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 19999 which took 2102 Milliseconds.
host.server_1   | [12:45:16 INF] Starting lifecycle stage 19999 took 2102 Milliseconds
host.server_1   | [12:45:16 INF] Starting Orleans.Runtime.ReminderService.LocalReminderService grain service on: S172.26.83.96:11111:266492710 x28220225 with range &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt;
host.server_1   | [12:45:16 INF] Start reminder service took 93 Milliseconds to finish
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 20000 which took 102 Milliseconds.
host.server_1   | [12:45:16 INF] Reminder EVENT_LOG_REMOVE_HISTORY is disabled
host.server_1   | [12:45:16 INF] Starting lifecycle stage 2000 took 2 Milliseconds
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask started in stage 20000 which took 134 Milliseconds.
host.server_1   | [12:45:21 WRN] Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | System.TimeoutException: Connection to 172.26.95.237:11111 could not be established in 00:00:05
host.server_1   |    at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
host.server_1   |    at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)
host.server_1   |    at Orleans.Runtime.LRU`2.Get(TKey key)
host.server_1   |    at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #2: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #2: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757&lt;---
host.server_1   | [12:45:21 WRN] -Did not get ping response for ping #0 from S172.26.95.237:11111:266481757. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #10: . Reason = Recent (00:00:00.0155236 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 10 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | [12:45:21 WRN] Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | System.TimeoutException: Connection to 172.26.95.237:11111 could not be established in 00:00:05
host.server_1   |    at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
host.server_1   |    at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)
host.server_1   |    at Orleans.Runtime.LRU`2.Get(TKey key)
host.server_1   |    at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #5: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #5: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #7: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 7 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #7: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 7 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 WRN] An exception was thrown by PublishStatistics.UpdateRuntimeStatistics(). Ignoring.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/22/00000016@S00000016-&gt;S172.26.95.237:11111:266481757*stg/22/00000016@S00000016 #8: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 8 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.DeploymentLoadPublisher.&lt;PublishStatistics&gt;d__19.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #12: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 12 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #12: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 12 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #14: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 14 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #14: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 14 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #16: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 16 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #16: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 16 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #18: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 18 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #18: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 18 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #20: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 20 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #20: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 20 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #22: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 22 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #22: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 22 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #24: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 24 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #24: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 24 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #26: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 26 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #26: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 26 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #28: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 28 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #28: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 28 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #30: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 30 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #30: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 30 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #32: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 32 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #32: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 32 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #34: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 34 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #34: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 34 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #36: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 36 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #36: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 36 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #38: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 38 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #38: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 38 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #40: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 40 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #40: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 40 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #42: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 42 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #42: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 42 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask failed to start due to errors at stage 20000.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask failed to start due to errors at stage 20000.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle start canceled due to errors at stage 20000
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | [12:45:21 ERR] Exception during Silo.Start
host.server_1   | Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
host.server_1   | [12:45:21 ERR] One or more errors occurred.
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
host.server_1   |    at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
host.server_1   |    at System.Threading.Tasks.Task.Wait()
host.server_1   |    at host.Server.Host.Program.Main(String[] args)
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()&lt;---
host.server_1   | [12:45:21 INF] Silo Stopping...
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping Orleans.Runtime.ReminderService.LocalReminderService grain service
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 20000 which took 8 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 20000 took 10 Milliseconds
host.server_1   | [12:45:21 INF] Silo starting to Shutdown()
host.server_1   | [12:45:21 INF] -ShutDown
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #47: . Reason = Recent (00:00:00.1092715 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 47 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #47: . Reason = Recent (00:00:00.1092715 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 47 without sending. CONNECTION_RETRY_DELAY = 00:00:01.&lt;---
host.server_1   | [12:45:21 INF] DeactivateAllActivations.
host.server_1   | [12:45:21 INF] DeactivateActivations: total 1 to shutdown out of them 1 promptly 0 later when become idle and 0 are already being destroyed or invalid.
host.server_1   | [12:45:21 INF] Starting DestroyActivations #0 of 1 activations
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 2000 took 0 Milliseconds
host.server_1   | [12:45:21 WRN] UnregisterManyAsync 1 failed.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #49: . Reason = Recent (00:00:00.1249664 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 49 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Catalog.&lt;FinishDestroyActivations&gt;d__76.MoveNext()
host.server_1   | [12:45:21 INF] Done FinishDestroyActivations #0 - Destroyed 1 Activations.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 19999 which took 69 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 19999 took 69 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-OrleansStorage stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-Default stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 10000 took 0 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 8000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 8000 took 0 Milliseconds
host.server_1   | [12:45:21 WRN] Ignoring Orleans.Runtime.OrleansMessageRejectionException exception thrown from an action called by Silo.Stop.
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;HandoffMyPartitionUponStop&gt;d__11.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;ProcessSiloStoppingEvent_Impl&gt;d__14.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
host.server_1   |    at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
host.server_1   |    at System.Threading.Tasks.Task.Wait(TimeSpan timeout)
host.server_1   |    at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task TimeSpan timeout)
host.server_1   |    at Orleans.Runtime.Utils.SafeExecute(Action action ILogger logger Func`1 callerGetter)
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;HandoffMyPartitionUponStop&gt;d__11.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;ProcessSiloStoppingEvent_Impl&gt;d__14.MoveNext()&lt;---
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 4000 which took 4 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 4000 took 5 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.InsideRuntimeClient stopped in stage 2000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Silo is Stopped()
host.server_1   | [12:45:21 INF] -KillMyself
host.server_1   | [12:45:21 INF] ActivationDirectory.PrintActivationDirectory(): Size = 0 Directory:
host.server_1   | []
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.&lt;---
host.server_1   | [12:45:21 INF] Stop request processed
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender that runs on managed thread 15
host.server_1   | [12:45:21 INF] Stopping  Windows perf counter stats collection
host.server_1   | [12:45:21 INF] Stop request processed
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender that runs on managed thread 13
host.server_1   | [12:45:21 INF] Statistics: ^^^
host.server_1   | App.Requests.Latency.Average.Millis=677.000
host.server_1   | App.Requests.LatencyHistogram.Millis=[0.1024:0.2047]=3 [0.2048:0.4095]=4 [0.4096:0.8191]=7 [0.8192:1.6383]=5 [1.6384:3.2767]=14 [3.2768:6.5535]=7 [6.5536:13.1071]=1 [104.8576:209.7151]=1 [1677.7216:3355.4431]=1 [3355.4432:6710.8863]=6
host.server_1   | App.Requests.TimedOut.Current=0
host.server_1   | App.Requests.Total.Requests.Current=49
host.server_1   | Catalog.Activation.Collection.NumberOfCollections.Current=1
host.server_1   | Catalog.Activation.Created.Current=1
host.server_1   | Catalog.Activation.CurrentCount=0
host.server_1   | Catalog.Activation.Destroyed.Current=1
host.server_1   | Catalog.Activation.FailedToActivate.Current=0
host.server_1   | Catalog.Activation.Shutdown.ViaDirectShutdown.Current=1
host.server_1   | ConsistentRing.AverageRangePercentage=50.000
host.server_1   | ConsistentRing.MyRange.RingDistance=x6A4EB65E
host.server_1   | ConsistentRing.MyRange.RingPercentage=41.526
host.server_1   | ConsistentRing.Ring=[S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; S172.26.95.237:11111:266481757 -&gt; &lt;MultiRange: Size=x95B149A2 %Ring=58.474%&gt;]
host.server_1   | ConsistentRing.RingSize=2
host.server_1   | Directory.CacheSize=0
host.server_1   | Directory.Lookups.Cache.HitRatio=0 Delta=0
host.server_1   | Directory.Lookups.Cache.Issued.Current=20
host.server_1   | Directory.Lookups.Cache.Successes.Current=0
host.server_1   | Directory.Lookups.Full.Issued.Current=21
host.server_1   | Directory.Lookups.Local.Issued.Current=21
host.server_1   | Directory.Lookups.Local.Successes.Current=0
host.server_1   | Directory.Lookups.LocalDirectory.Issued.Current=2
host.server_1   | Directory.Lookups.LocalDirectory.Successes.Current=0
host.server_1   | Directory.Lookups.Remote.Received.Current=0
host.server_1   | Directory.Lookups.Remote.Sent.Current=20
host.server_1   | Directory.PartitionSize=1
host.server_1   | Directory.Registrations.Issued.Current=0
host.server_1   | Directory.Registrations.Local.Current=0
host.server_1   | Directory.Registrations.Remote.Received.Current=0
host.server_1   | Directory.Registrations.Remote.Sent.Current=0
host.server_1   | Directory.Registrations.SingleAct.Issued.Current=1
host.server_1   | Directory.Registrations.SingleAct.Local.Current=1
host.server_1   | Directory.Registrations.SingleAct.Remote.Received.Current=0
host.server_1   | Directory.Registrations.SingleAct.Remote.Sent.Current=0
host.server_1   | Directory.Ring=[S172.26.95.237:11111:266481757/A47E0772 S172.26.83.96:11111:266492710/28220225]
host.server_1   | Directory.Ring.MyPortion.AverageRingPercentage=50.000
host.server_1   | Directory.Ring.MyPortion.RingDistance=2086405451
host.server_1   | Directory.Ring.MyPortion.RingPercentage=48.578
host.server_1   | Directory.Ring.MyPredecessors=[S172.26.95.237:11111:266481757/A47E0772]
host.server_1   | Directory.Ring.MySuccessors=[S172.26.95.237:11111:266481757/A47E0772]
host.server_1   | Directory.Ring.RingSize=2
host.server_1   | Directory.UnRegistrations.Issued.Current=0
host.server_1   | Directory.UnRegistrations.Local.Current=0
host.server_1   | Directory.UnRegistrations.Remote.Received.Current=0
host.server_1   | Directory.UnRegistrations.Remote.Sent.Current=0
host.server_1   | Directory.UnRegistrationsMany.Issued.Current=1
host.server_1   | Directory.UnRegistrationsMany.Remote.Received.Current=0
host.server_1   | Directory.UnRegistrationsMany.Remote.Sent.Current=1
host.server_1   | Directory.Validations.Cache.Received.Current=0
host.server_1   | Directory.Validations.Cache.Sent.Current=0
host.server_1   | Dispatcher.NewPlacement.Current=1
host.server_1   | Gateway.ConnectedClients.Current=0
host.server_1   | Gateway.LoadShedding.Current=0
host.server_1   | Gateway.Received.Current=0
host.server_1   | Grain.host.Server.Grains.EventLogMaintenanceGrain.Current=0
host.server_1   | Membership.ActiveCluster=[S172.26.95.237:11111:266481757]
host.server_1   | Membership.ActiveClusterSize=1
host.server_1   | MessageCenter.ReceiveQueueLength=0
host.server_1   | MessageCenter.SendQueueLength=0
host.server_1   | Messaging.Acceptor.CheckedInSocketEventArgs.Current=0
host.server_1   | Messaging.Acceptor.CheckedOutSocketEventArgs.Current=0
host.server_1   | Messaging.Acceptor.InUseSocketEventArgs=0
host.server_1   | Messaging.Expired.AtDispatch.Current=0
host.server_1   | Messaging.Expired.AtInvoke.Current=0
host.server_1   | Messaging.Expired.AtReceive.Current=0
host.server_1   | Messaging.Expired.AtRespond.Current=0
host.server_1   | Messaging.Expired.AtSend.Current=0
host.server_1   | Messaging.Pings.ReplyMissed.S172.26.95.237:11111:266481757.Current=1
host.server_1   | Messaging.Pings.Sent.S172.26.95.237:11111:266481757.Current=1
host.server_1   | Messaging.Processing.ActivationData.All=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.Request.Current=20
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.Request.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.Request.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Total.Current=21
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.Request.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.OnActivationContext.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.OnNullContext.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Received.Total.Current=1
host.server_1   | Messaging.Processing.IGC.Forwarded.Current=0
host.server_1   | Messaging.Processing.IGC.ReRoute.Current=0
host.server_1   | Messaging.Processing.IGC.Resent.Current=0
host.server_1   | Messaging.Processing.IMA.Enqueued.ToActivationContex.Current=0
host.server_1   | Messaging.Processing.IMA.Enqueued.ToNullContex.Current=1
host.server_1   | Messaging.Processing.IMA.Enqueued.ToSystemTargetContex.Current=50
host.server_1   | Messaging.Processing.IMA.Received.Current=51
host.server_1   | Messaging.Received.BatchSize.PerSocketDirection.GatewayToClient=0.000
host.server_1   | Messaging.Received.BatchSize.PerSocketDirection.SiloToSilo=0.000
host.server_1   | Messaging.Received.BatchSizeBytesHistogram.Bytes.PerSocketDirection.GatewayToClient=
host.server_1   | Messaging.Received.BatchSizeBytesHistogram.Bytes.PerSocketDirection.SiloToSilo=
host.server_1   | Messaging.Received.Bytes.Header.Current=0
host.server_1   | Messaging.Received.Bytes.Total.Current=0
host.server_1   | Messaging.Received.Direction.OneWay.Current=0
host.server_1   | Messaging.Received.Direction.Request.Current=0
host.server_1   | Messaging.Received.Direction.Response.Current=0
host.server_1   | Messaging.Received.Messages.Total.Current=0
host.server_1   | Messaging.Received.MessageSizeHistogram.Bytes=
host.server_1   | Messaging.Rejected.Request.Current=47
host.server_1   | Messaging.Rerouted.OneWay.Current=0
host.server_1   | Messaging.Rerouted.Request.Current=0
host.server_1   | Messaging.Rerouted.Response.Current=0
host.server_1   | Messaging.Sent.BatchSize.PerSocketDirection.GatewayToClient=0.000
host.server_1   | Messaging.Sent.BatchSize.PerSocketDirection.SiloToSilo=0.000
host.server_1   | Messaging.Sent.BatchSizeBytesHistogram.Bytes.PerSocketDirection.GatewayToClient=
host.server_1   | Messaging.Sent.BatchSizeBytesHistogram.Bytes.PerSocketDirection.SiloToSilo=
host.server_1   | Messaging.Sent.Bytes.Header.Current=0
host.server_1   | Messaging.Sent.Bytes.Total.Current=0
host.server_1   | Messaging.Sent.Direction.OneWay.Current=0
host.server_1   | Messaging.Sent.Direction.Request.Current=0
host.server_1   | Messaging.Sent.Direction.Response.Current=0
host.server_1   | Messaging.Sent.Failed.Request.Current=27
host.server_1   | Messaging.Sent.LocalMessages.Current=24
host.server_1   | Messaging.Sent.Messages.Total.Current=0
host.server_1   | Messaging.Sent.MessageSizeHistogram.Bytes=
host.server_1   | Networking.Sockets.GatewayToClient.Duplex.Closed.Current=0
host.server_1   | Networking.Sockets.GatewayToClient.Duplex.Opened.Current=0
host.server_1   | Networking.Sockets.Silo.Receiving.Closed.Current=0
host.server_1   | Networking.Sockets.Silo.Receiving.Opened.Current=0
host.server_1   | Networking.Sockets.Silo.Sending.Closed.Current=0
host.server_1   | Networking.Sockets.Silo.Sending.Opened.Current=0
host.server_1   | Queues.QueueSize.Instantaneous.Scheduler.LevelOne=0
host.server_1   | Reminders.AverageTardiness.Seconds=0 Secs
host.server_1   | Reminders.NumberOfActiveReminders=1
host.server_1   | Reminders.TicksDelivered.Current=0
host.server_1   | Runtime.IsOverloaded=False
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.GatewayAcceptor.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.GatewayClientCleanupAgent.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.IncomingMessageAcceptor.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.IncomingMessageAgent.Current=3
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.SiloMessageSender.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Scheduler.WorkerPoolThread.Current=5
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Watchdog.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.TotalThreadsCreated.Current=16
host.server_1   | Scheduler.NumLongQueueWaitTimes.Current=0
host.server_1   | Scheduler.NumLongRunningTurns.Current=0
host.server_1   | Scheduler.WorkItemGroupCount=14
host.server_1   | Serialization.BufferPool.AllocatedBuffers.Current=250
host.server_1   | Serialization.BufferPool.BuffersInPool=250
host.server_1   | Serialization.BufferPool.CheckedInBuffers.Current=250
host.server_1   | Serialization.BufferPool.CheckedOutBuffers.Current=250
host.server_1   | Serialization.BufferPool.DroppedBuffers.Current=0
host.server_1   | Serialization.BufferPool.DroppedTooLargeBuffers.Current=0
host.server_1   | Serialization.BufferPool.InUse.AllocatedAndNotInPool_Buffers=0
host.server_1   | Serialization.BufferPool.InUse.CheckedOutAndNotCheckedIn_Buffers=0
host.server_1   | Silo.StartTime=2018-06-12 09:45:10.221 GMT
host.server_1   | Storage.Activate.Errors.Current=0
host.server_1   | Storage.Activate.Total.Current=0
host.server_1   | Storage.Clear.Errors.Current=0
host.server_1   | Storage.Clear.Latency=0 Secs
host.server_1   | Storage.Clear.Total.Current=0
host.server_1   | Storage.Read.Errors.Current=0
host.server_1   | Storage.Read.Latency=0 Secs
host.server_1   | Storage.Read.Total.Current=0
host.server_1   | Storage.Write.Errors.Current=0
host.server_1   | Storage.Write.Latency=0 Secs
host.server_1   | Storage.Write.Total.Current=0
host.server_1   | SystemTarget..Current=4
host.server_1   | Transactions.Abort.Total.Current=0
host.server_1   | Transactions.Commit.Completed.Current=0
host.server_1   | Transactions.Commit.InDoubt.Current=0
host.server_1   | Transactions.Commit.QueueLength.Current=0
host.server_1   | Transactions.Commit.Request.Current=0
host.server_1   | Transactions.Start.Completed.Current=0
host.server_1   | Transactions.Start.QueueLength.Current=0
host.server_1   | Transactions.Start.Request.Current=0
host.server_1   | Watchdog.NumHealthChecks.Current=0
host.server_1   |
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 2000 which took 44 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 2000 took 45 Milliseconds
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 that runs on managed thread 10
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 that runs on managed thread 9
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 that runs on managed thread 11
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.5 that runs on managed thread 7
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 that runs on managed thread 8
host.server_1   | [12:45:21 INF] OrleansTaskScheduler.PrintStatistics(): RunQueue=0 WorkItems=14 Directory:
host.server_1   | [--System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=33; Total processed=33; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-12:Queued=0; Detailed SchedulingContext=&lt;[LowPrioritySystemTarget: S172.26.83.96:11111:266492710*stg/0/00000000@S00000000] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/10/0000000aWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=3; Total processed=3; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-5:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a-&gt;S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a #48: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/11/0000000bWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=4; Total processed=4; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-6:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/11/0000000b@S0000000b] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/12/0000000cWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-2:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/12/0000000c@S0000000c] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/13/0000000dWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=2; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-8:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/13/0000000d@S0000000d] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/14/0000000eWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=67; Total processed=67; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-13:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #49: . Reason = Recent (00:00:00.1249664 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 49 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a-&gt;S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e #49: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/15/0000000fWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=34; Total processed=34; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-10:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f-&gt;S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f #50: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/17/00000011WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=1; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-9:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/17/00000011@S00000011] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/19/00000013WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/19/00000013@S00000013] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=76; Total processed=76; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-1:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/20/00000014@S00000014] CurrentlyExecuting=Unrecoverable Rejection (info:  Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()) Response S172.26.83.96:11111:266492710*grn/B3628901/00000000+Default-&gt;S172.26.83.96:11111:266492710*stg/20/00000014@S00000014 #44: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/22/00000016WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=14; Total processed=14; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-4:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/22/00000016@S00000016] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/22/00000016@S00000016-&gt;S172.26.95.237:11111:266481757*stg/22/00000016@S00000016 #8: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 8 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/22/00000016@S00000016-&gt;S172.26.83.96:11111:266492710*stg/22/00000016@S00000016 #8: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/24/00000018WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-7:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/24/00000018@S00000018] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/27/0000001bWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-3:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/27/0000001b@S0000001b] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/28/0000001cWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=656; Total processed=656; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-11:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/28/0000001c@S0000001c] CurrentlyExecuting=null&gt;]
host.server_1   | [12:45:21 INF] Silo Stopped
host.server_1   | [12:45:21 WRN] Process is exiting
host.server_1   | [12:45:21 INF] Silo termination is in progress - Will wait for it to finish
host.server_1 exited with code 1

&lt;/pre&gt;
&lt;/details&gt;</Description>
    <Title_Description>Silo can't start in docker I have strange error that can be reproduced in docker container only. When I run my application as regular application(not in the docker) all works as expected. 
What is interesting that the silo terminating in case when there is a startup task and orphan records in OrleansMembershipTable table I use ado.net membership.
If I remove orphan records from OrleansMembershipTable table or comment my startup task silo able to start and works.
Startup task activate a grain with reminder and timer for several background staff.

Below the full log of orleans from docker. 
I've skipped several sensitive info from the log
I use .NET 462 Orleans 2.0.3
&lt;details&gt;
&lt;summary&gt;Full Orleans Log&lt;/summary&gt;
&lt;pre&gt;
host.server_1   | [12:45:10 WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
host.server_1   | [12:45:10 INF] Starting OrleansTaskScheduler with 4 Max Active application Threads and 1 system thread.
host.server_1   | [12:45:10 INF] Silo starting with GC settings: ServerGC=True GCLatencyMode=Interactive
host.server_1   | [12:45:10 INF] -------------- Initializing silo on host 5a5cb449241b MachineName 5A5CB449241B at 172.26.83.96:11111 gen 266492710 --------------
host.server_1   | [12:45:10 INF] Starting silo Silo_d97f1
host.server_1   | [12:45:10 INF] Opened a listening socket at address 0.0.0.0:11111
host.server_1   | [12:45:10 INF] Opened a listening socket at address 0.0.0.0:30000
host.server_1   | [12:45:10 INF] Starting VirtualBucketsRingProvider on silo S172.26.83.96:11111:266492710/x28220225.
host.server_1   | [12:45:10 INF] Added Server S172.26.83.96:11111:266492710/x28220225. Current view: [S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]
host.server_1   | [12:45:10 INF] -NotifyLocalRangeSubscribers about old &lt;(0 0] Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True
host.server_1   | [12:45:11 INF] Skip multicluster oracle creation (no multicluster network configured)
host.server_1   | [12:45:11 INF] -------------- Started silo S172.26.83.96:11111:266492710 ConsistentHashCode 28220225 --------------
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.5 on managed thread 7
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 on managed thread 8
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 on managed thread 9
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 on managed thread 10
host.server_1   | [12:45:11 INF] Start Scheduler took 11 Milliseconds to finish
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 on managed thread 11
host.server_1   | [12:45:11 INF] Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 4000: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 8000: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 10000: Orleans.Runtime.Versions.GrainVersionStore Orleans.Storage.AdoNetGrainStorage-Default Orleans.Storage.AdoNetGrainStorage-OrleansStorage
host.server_1   | [12:45:11 INF] Stage 19999: Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Stage 20000: Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask Orleans.Runtime.Silo
host.server_1   | [12:45:11 INF] Start InsideRuntimeClient took 9 Milliseconds
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.InsideRuntimeClient started in stage 2000 which took 10 Milliseconds.
host.server_1   | [12:45:11 INF] Silo Start()
host.server_1   | [12:45:11 INF] Configured ThreadPool.SetMinThreads() to values: 200200. Previous values are: 22.
host.server_1   | [12:45:11 INF] Configured .NET ServicePointManager to Expect100Continue=False DefaultConnectionLimit=200 UseNagleAlgorithm=False to improve Azure storage performance.
host.server_1   | [12:45:11 INF] ConfigureThreadPoolAndServicePointSettings took 4 Milliseconds to finish
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 2000 which took 10 Milliseconds.
host.server_1   | [12:45:11 INF] Starting lifecycle stage 2000 took 24 Milliseconds
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAcceptor on managed thread 12
host.server_1   | [12:45:11 INF] Stopping AsyncAgent Runtime.Messaging.IncomingMessageAcceptor that runs on managed thread 12
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender on managed thread 13
host.server_1   | [12:45:11 INF] Start Message center took 3 Milliseconds to finish
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender on managed thread 15
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Ping on managed thread 16
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/System on managed thread 17
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Application on managed thread 18
host.server_1   | [12:45:11 INF] Start Incoming message agents took 2 Milliseconds to finish
host.server_1   | [12:45:11 INF] Start
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 19
host.server_1   | [12:45:11 INF] Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 20
host.server_1   | [12:45:11 INF] Stopping AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer that runs on managed thread 20
host.server_1   | [12:45:11 INF] Start local grain directory took 7 Milliseconds to finish
host.server_1   | [12:45:11 INF] Init implicit stream subscribe table took 5 Milliseconds to finish
host.server_1   | [12:45:11 INF] Creating reminder grain service for type=Orleans.Runtime.ReminderService.AdoNetReminderTable
host.server_1   | [12:45:11 INF] Create system targets and inject dependencies took 42 Milliseconds to finish
host.server_1   | [12:45:11 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 65 Milliseconds.
host.server_1   | [12:45:11 INF] Starting lifecycle stage 4000 took 65 Milliseconds
host.server_1   | [12:45:11 INF] Init transaction agent took 3 Milliseconds to finish
host.server_1   | [12:45:11 INF] Before collection#1: memory=14MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.
host.server_1   | [12:45:11 INF] Init grain services took 2 Milliseconds to finish
host.server_1   | [12:45:11 INF] After collection#1: memory=14MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0070010.
host.server_1   | [12:45:11 INF] MembershipOracle starting on host = 5a5cb449241b address = S172.26.83.96:11111:266492710 at 2018-06-12 09:45:10.206 GMT backOffMax = 00:00:20
host.server_1   | [12:45:14 INF] -CleanupTable called on silo startup. Membership table 2 silos 1 are Active 1 are Dead Version=&lt;26 26&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:14 INF] Starting IAmAliveUpdateTimer.
host.server_1   | [12:45:14 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:14 AM no update for 03:02:26.0940000 which is more than 00:10:00.
host.server_1   | [12:45:14 INF] Starting local silo status oracle took 2980 Milliseconds to finish
host.server_1   | [12:45:14 INF] OnRefreshClusterMapTimer: refresh start
host.server_1   | [12:45:14 INF] Init type manager took 13 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting Windows perf counter stats collection with frequency=00:00:30
host.server_1   | [12:45:14 INF] Start silo statistics took 1 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting DeploymentLoadPublisher.
host.server_1   | [12:45:14 INF] Started DeploymentLoadPublisher.
host.server_1   | [12:45:14 INF] Start deployment load collector took 16 Milliseconds to finish
host.server_1   | [12:45:14 INF] Starting Silo Watchdog.
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 8000 which took 3026 Milliseconds.
host.server_1   | [12:45:14 INF] Starting lifecycle stage 8000 took 3026 Milliseconds
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Watchdog on managed thread 35
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore started in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:14 INF] Initialized storage provider: ServiceId=ServiceId-123 ProviderName=Default Invariant=System.Data.SqlClient ConnectionString=[skiped].
host.server_1   | [12:45:14 INF] Initialized storage provider: ServiceId=ServiceId-123 ProviderName=OrleansStorage Invariant=System.Data.SqlClient ConnectionString=[skiped].
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-Default started in stage 10000 which took 14 Milliseconds.
host.server_1   | [12:45:14 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-OrleansStorage started in stage 10000 which took 40 Milliseconds.
host.server_1   | [12:45:14 INF] Starting lifecycle stage 10000 took 40 Milliseconds
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Messaging.GatewayAcceptor on managed thread 38
host.server_1   | [12:45:14 INF] Starting AsyncAgent Runtime.Messaging.GatewayClientCleanupAgent on managed thread 39
host.server_1   | [12:45:14 INF] Stopping AsyncAgent Runtime.Messaging.GatewayAcceptor that runs on managed thread 38
host.server_1   | [12:45:14 INF] Start gateway took 3 Milliseconds to finish
host.server_1   | [12:45:14 INF] -BecomeActive
host.server_1   | [12:45:16 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:16 AM no update for 03:02:28.1730000 which is more than 00:10:00.
host.server_1   | [12:45:16 INF] About to send pings to 0 nodes in order to validate communication in the Joining state. Pinged nodes = []
host.server_1   | [12:45:16 INF] -ReadAll (called from BecomeActive) Membership table 3 silos 2 are Active 1 are Dead Version=&lt;28 28&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.83.96:11111:266492710 SiloName=Silo_d97f1 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:16 WRN] Noticed that silo S172.26.95.237:11111:266481757 has not updated it's IAmAliveTime table column recently. Last update was at 6/12/2018 6:42:48 AM now is 6/12/2018 9:45:16 AM no update for 03:02:28.2200000 which is more than 00:10:00.
host.server_1   | [12:45:16 INF] Added Server S172.26.95.237:11111:266481757/xA47E0772. Current view: [S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; S172.26.95.237:11111:266481757 -&gt; &lt;MultiRange: Size=x95B149A2 %Ring=58.474%&gt;]
host.server_1   | [12:45:16 INF] -NotifyLocalRangeSubscribers about old &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; increased? True
host.server_1   | [12:45:16 INF] Will watch (actively ping) 1 silos: [S172.26.95.237:11111:266481757]
host.server_1   | [12:45:16 INF] -ReadAll (called from BecomeActive after local view changed with removed duplicate deads) Membership table: 3 silos 2 are Active 1 are Dead Version=&lt;28 28&gt;. All silos: [SiloAddress=S172.26.95.237:11111:266481757 SiloName=Silo_d57d4 Status=Active SiloAddress=S172.26.83.96:11111:266492710 SiloName=Silo_d97f1 Status=Active SiloAddress=S172.26.87.1:11111:266489784 SiloName=Silo_34c84 Status=Dead]
host.server_1   | [12:45:16 INF] -Finished BecomeActive.
host.server_1   | [12:45:16 INF] Starting local silo status oracle took 2097 Milliseconds to finish
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 19999 which took 2102 Milliseconds.
host.server_1   | [12:45:16 INF] Starting lifecycle stage 19999 took 2102 Milliseconds
host.server_1   | [12:45:16 INF] Starting Orleans.Runtime.ReminderService.LocalReminderService grain service on: S172.26.83.96:11111:266492710 x28220225 with range &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt;
host.server_1   | [12:45:16 INF] Start reminder service took 93 Milliseconds to finish
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Runtime.Silo started in stage 20000 which took 102 Milliseconds.
host.server_1   | [12:45:16 INF] Reminder EVENT_LOG_REMOVE_HISTORY is disabled
host.server_1   | [12:45:16 INF] Starting lifecycle stage 2000 took 2 Milliseconds
host.server_1   | [12:45:16 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask started in stage 20000 which took 134 Milliseconds.
host.server_1   | [12:45:21 WRN] Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | System.TimeoutException: Connection to 172.26.95.237:11111 could not be established in 00:00:05
host.server_1   |    at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
host.server_1   |    at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)
host.server_1   |    at Orleans.Runtime.LRU`2.Get(TKey key)
host.server_1   |    at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #2: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #2: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757&lt;---
host.server_1   | [12:45:21 WRN] -Did not get ping response for ping #0 from S172.26.95.237:11111:266481757. Reason = Original Exc Type: Orleans.Runtime.OrleansMessageRejectionException Message:Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #10: . Reason = Recent (00:00:00.0155236 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 10 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | [12:45:21 WRN] Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | System.TimeoutException: Connection to 172.26.95.237:11111 could not be established in 00:00:05
host.server_1   |    at Orleans.Runtime.SocketManager.Connect(Socket s IPEndPoint endPoint TimeSpan connectionTimeout)
host.server_1   |    at Orleans.Runtime.SocketManager.SendingSocketCreator(IPEndPoint target)
host.server_1   |    at Orleans.Runtime.LRU`2.Get(TKey key)
host.server_1   |    at Orleans.Runtime.Messaging.SiloMessageSender.GetSendingSocket(Message msg Socket&amp; socket SiloAddress&amp; targetSilo String&amp; error)
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #5: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #5: . Reason = Exception getting a sending socket to endpoint S172.26.95.237:11111:266481757
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #7: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 7 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #7: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 7 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 WRN] An exception was thrown by PublishStatistics.UpdateRuntimeStatistics(). Ignoring.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/22/00000016@S00000016-&gt;S172.26.95.237:11111:266481757*stg/22/00000016@S00000016 #8: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 8 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.DeploymentLoadPublisher.&lt;PublishStatistics&gt;d__19.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #12: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 12 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #12: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 12 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #14: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 14 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #14: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 14 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #16: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 16 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #16: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 16 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #18: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 18 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #18: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 18 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #20: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 20 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #20: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 20 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #22: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 22 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #22: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 22 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #24: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 24 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #24: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 24 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #26: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 26 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #26: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 26 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #28: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 28 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #28: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 28 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #30: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 30 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #30: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 30 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #32: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 32 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #32: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 32 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #34: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 34 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #34: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 34 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #36: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 36 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #36: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 36 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #38: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 38 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #38: . Reason = Recent (00:00:00.0155907 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 38 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #40: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 40 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #40: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 40 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #42: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 42 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #42: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 42 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] SelectTarget failed with Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask failed to start due to errors at stage 20000.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask failed to start due to errors at stage 20000.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | [12:45:21 ERR] Lifecycle start canceled due to errors at stage 20000
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | [12:45:21 ERR] Exception during Silo.Start
host.server_1   | Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
host.server_1   | [12:45:21 ERR] One or more errors occurred.
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
host.server_1   |    at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
host.server_1   |    at System.Threading.Tasks.Task.Wait()
host.server_1   |    at host.Server.Host.Program.Main(String[] args)
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 20000 ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #45: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 45 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
host.server_1   |    at host.Server.Common.Bootstrap`1.&lt;Execute&gt;d__3.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Silo.&lt;StartAsync&gt;d__64.MoveNext()&lt;---
host.server_1   | [12:45:21 INF] Silo Stopping...
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Hosting.SiloBuilderStartupExtensions+StartupTask stopped in stage 20000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping Orleans.Runtime.ReminderService.LocalReminderService grain service
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 20000 which took 8 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 20000 took 10 Milliseconds
host.server_1   | [12:45:21 INF] Silo starting to Shutdown()
host.server_1   | [12:45:21 INF] -ShutDown
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #47: . Reason = Recent (00:00:00.1092715 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 47 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #47: . Reason = Recent (00:00:00.1092715 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 47 without sending. CONNECTION_RETRY_DELAY = 00:00:01.&lt;---
host.server_1   | [12:45:21 INF] DeactivateAllActivations.
host.server_1   | [12:45:21 INF] DeactivateActivations: total 1 to shutdown out of them 1 promptly 0 later when become idle and 0 are already being destroyed or invalid.
host.server_1   | [12:45:21 INF] Starting DestroyActivations #0 of 1 activations
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 2000 took 0 Milliseconds
host.server_1   | [12:45:21 WRN] UnregisterManyAsync 1 failed.
host.server_1   | Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #49: . Reason = Recent (00:00:00.1249664 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 49 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Catalog.&lt;FinishDestroyActivations&gt;d__76.MoveNext()
host.server_1   | [12:45:21 INF] Done FinishDestroyActivations #0 - Destroyed 1 Activations.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 19999 which took 69 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 19999 took 69 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-OrleansStorage stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Storage.AdoNetGrainStorage-Default stopped in stage 10000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 10000 took 0 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 8000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 8000 took 0 Milliseconds
host.server_1   | [12:45:21 WRN] Ignoring Orleans.Runtime.OrleansMessageRejectionException exception thrown from an action called by Silo.Stop.
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;HandoffMyPartitionUponStop&gt;d__11.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;ProcessSiloStoppingEvent_Impl&gt;d__14.MoveNext()
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   |    at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
host.server_1   |    at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
host.server_1   |    at System.Threading.Tasks.Task.Wait(TimeSpan timeout)
host.server_1   |    at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task TimeSpan timeout)
host.server_1   |    at Orleans.Runtime.Utils.SafeExecute(Action action ILogger logger Func`1 callerGetter)
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;HandoffMyPartitionUponStop&gt;d__11.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.GrainDirectoryHandoffManager.&lt;ProcessSiloStoppingEvent_Impl&gt;d__14.MoveNext()&lt;---
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 4000 which took 4 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 4000 took 5 Milliseconds
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.InsideRuntimeClient stopped in stage 2000 which took 0 Milliseconds.
host.server_1   | [12:45:21 INF] Silo is Stopped()
host.server_1   | [12:45:21 INF] -KillMyself
host.server_1   | [12:45:21 INF] ActivationDirectory.PrintActivationDirectory(): Size = 0 Directory:
host.server_1   | []
host.server_1   | [12:45:21 ERR] SiloStatusChangeNotification failed
host.server_1   | System.AggregateException: One or more errors occurred. ---&gt; Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    --- End of inner exception stack trace ---
host.server_1   | ---&gt; (Inner Exception #0) Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.&lt;---
host.server_1   | [12:45:21 INF] Stop request processed
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender that runs on managed thread 15
host.server_1   | [12:45:21 INF] Stopping  Windows perf counter stats collection
host.server_1   | [12:45:21 INF] Stop request processed
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender that runs on managed thread 13
host.server_1   | [12:45:21 INF] Statistics: ^^^
host.server_1   | App.Requests.Latency.Average.Millis=677.000
host.server_1   | App.Requests.LatencyHistogram.Millis=[0.1024:0.2047]=3 [0.2048:0.4095]=4 [0.4096:0.8191]=7 [0.8192:1.6383]=5 [1.6384:3.2767]=14 [3.2768:6.5535]=7 [6.5536:13.1071]=1 [104.8576:209.7151]=1 [1677.7216:3355.4431]=1 [3355.4432:6710.8863]=6
host.server_1   | App.Requests.TimedOut.Current=0
host.server_1   | App.Requests.Total.Requests.Current=49
host.server_1   | Catalog.Activation.Collection.NumberOfCollections.Current=1
host.server_1   | Catalog.Activation.Created.Current=1
host.server_1   | Catalog.Activation.CurrentCount=0
host.server_1   | Catalog.Activation.Destroyed.Current=1
host.server_1   | Catalog.Activation.FailedToActivate.Current=0
host.server_1   | Catalog.Activation.Shutdown.ViaDirectShutdown.Current=1
host.server_1   | ConsistentRing.AverageRangePercentage=50.000
host.server_1   | ConsistentRing.MyRange.RingDistance=x6A4EB65E
host.server_1   | ConsistentRing.MyRange.RingPercentage=41.526
host.server_1   | ConsistentRing.Ring=[S172.26.83.96:11111:266492710 -&gt; &lt;MultiRange: Size=x6A4EB65E %Ring=41.526%&gt; S172.26.95.237:11111:266481757 -&gt; &lt;MultiRange: Size=x95B149A2 %Ring=58.474%&gt;]
host.server_1   | ConsistentRing.RingSize=2
host.server_1   | Directory.CacheSize=0
host.server_1   | Directory.Lookups.Cache.HitRatio=0 Delta=0
host.server_1   | Directory.Lookups.Cache.Issued.Current=20
host.server_1   | Directory.Lookups.Cache.Successes.Current=0
host.server_1   | Directory.Lookups.Full.Issued.Current=21
host.server_1   | Directory.Lookups.Local.Issued.Current=21
host.server_1   | Directory.Lookups.Local.Successes.Current=0
host.server_1   | Directory.Lookups.LocalDirectory.Issued.Current=2
host.server_1   | Directory.Lookups.LocalDirectory.Successes.Current=0
host.server_1   | Directory.Lookups.Remote.Received.Current=0
host.server_1   | Directory.Lookups.Remote.Sent.Current=20
host.server_1   | Directory.PartitionSize=1
host.server_1   | Directory.Registrations.Issued.Current=0
host.server_1   | Directory.Registrations.Local.Current=0
host.server_1   | Directory.Registrations.Remote.Received.Current=0
host.server_1   | Directory.Registrations.Remote.Sent.Current=0
host.server_1   | Directory.Registrations.SingleAct.Issued.Current=1
host.server_1   | Directory.Registrations.SingleAct.Local.Current=1
host.server_1   | Directory.Registrations.SingleAct.Remote.Received.Current=0
host.server_1   | Directory.Registrations.SingleAct.Remote.Sent.Current=0
host.server_1   | Directory.Ring=[S172.26.95.237:11111:266481757/A47E0772 S172.26.83.96:11111:266492710/28220225]
host.server_1   | Directory.Ring.MyPortion.AverageRingPercentage=50.000
host.server_1   | Directory.Ring.MyPortion.RingDistance=2086405451
host.server_1   | Directory.Ring.MyPortion.RingPercentage=48.578
host.server_1   | Directory.Ring.MyPredecessors=[S172.26.95.237:11111:266481757/A47E0772]
host.server_1   | Directory.Ring.MySuccessors=[S172.26.95.237:11111:266481757/A47E0772]
host.server_1   | Directory.Ring.RingSize=2
host.server_1   | Directory.UnRegistrations.Issued.Current=0
host.server_1   | Directory.UnRegistrations.Local.Current=0
host.server_1   | Directory.UnRegistrations.Remote.Received.Current=0
host.server_1   | Directory.UnRegistrations.Remote.Sent.Current=0
host.server_1   | Directory.UnRegistrationsMany.Issued.Current=1
host.server_1   | Directory.UnRegistrationsMany.Remote.Received.Current=0
host.server_1   | Directory.UnRegistrationsMany.Remote.Sent.Current=1
host.server_1   | Directory.Validations.Cache.Received.Current=0
host.server_1   | Directory.Validations.Cache.Sent.Current=0
host.server_1   | Dispatcher.NewPlacement.Current=1
host.server_1   | Gateway.ConnectedClients.Current=0
host.server_1   | Gateway.LoadShedding.Current=0
host.server_1   | Gateway.Received.Current=0
host.server_1   | Grain.host.Server.Grains.EventLogMaintenanceGrain.Current=0
host.server_1   | Membership.ActiveCluster=[S172.26.95.237:11111:266481757]
host.server_1   | Membership.ActiveClusterSize=1
host.server_1   | MessageCenter.ReceiveQueueLength=0
host.server_1   | MessageCenter.SendQueueLength=0
host.server_1   | Messaging.Acceptor.CheckedInSocketEventArgs.Current=0
host.server_1   | Messaging.Acceptor.CheckedOutSocketEventArgs.Current=0
host.server_1   | Messaging.Acceptor.InUseSocketEventArgs=0
host.server_1   | Messaging.Expired.AtDispatch.Current=0
host.server_1   | Messaging.Expired.AtInvoke.Current=0
host.server_1   | Messaging.Expired.AtReceive.Current=0
host.server_1   | Messaging.Expired.AtRespond.Current=0
host.server_1   | Messaging.Expired.AtSend.Current=0
host.server_1   | Messaging.Pings.ReplyMissed.S172.26.95.237:11111:266481757.Current=1
host.server_1   | Messaging.Pings.Sent.S172.26.95.237:11111:266481757.Current=1
host.server_1   | Messaging.Processing.ActivationData.All=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.Request.Current=20
host.server_1   | Messaging.Processing.Dispatcher.Processed.Errors.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.Request.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Processed.Ok.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.Request.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.ReRoute.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Processed.Total.Current=21
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.OneWay.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.Request.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Received.Direction.Response.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.OnActivationContext.Current=0
host.server_1   | Messaging.Processing.Dispatcher.Received.OnNullContext.Current=1
host.server_1   | Messaging.Processing.Dispatcher.Received.Total.Current=1
host.server_1   | Messaging.Processing.IGC.Forwarded.Current=0
host.server_1   | Messaging.Processing.IGC.ReRoute.Current=0
host.server_1   | Messaging.Processing.IGC.Resent.Current=0
host.server_1   | Messaging.Processing.IMA.Enqueued.ToActivationContex.Current=0
host.server_1   | Messaging.Processing.IMA.Enqueued.ToNullContex.Current=1
host.server_1   | Messaging.Processing.IMA.Enqueued.ToSystemTargetContex.Current=50
host.server_1   | Messaging.Processing.IMA.Received.Current=51
host.server_1   | Messaging.Received.BatchSize.PerSocketDirection.GatewayToClient=0.000
host.server_1   | Messaging.Received.BatchSize.PerSocketDirection.SiloToSilo=0.000
host.server_1   | Messaging.Received.BatchSizeBytesHistogram.Bytes.PerSocketDirection.GatewayToClient=
host.server_1   | Messaging.Received.BatchSizeBytesHistogram.Bytes.PerSocketDirection.SiloToSilo=
host.server_1   | Messaging.Received.Bytes.Header.Current=0
host.server_1   | Messaging.Received.Bytes.Total.Current=0
host.server_1   | Messaging.Received.Direction.OneWay.Current=0
host.server_1   | Messaging.Received.Direction.Request.Current=0
host.server_1   | Messaging.Received.Direction.Response.Current=0
host.server_1   | Messaging.Received.Messages.Total.Current=0
host.server_1   | Messaging.Received.MessageSizeHistogram.Bytes=
host.server_1   | Messaging.Rejected.Request.Current=47
host.server_1   | Messaging.Rerouted.OneWay.Current=0
host.server_1   | Messaging.Rerouted.Request.Current=0
host.server_1   | Messaging.Rerouted.Response.Current=0
host.server_1   | Messaging.Sent.BatchSize.PerSocketDirection.GatewayToClient=0.000
host.server_1   | Messaging.Sent.BatchSize.PerSocketDirection.SiloToSilo=0.000
host.server_1   | Messaging.Sent.BatchSizeBytesHistogram.Bytes.PerSocketDirection.GatewayToClient=
host.server_1   | Messaging.Sent.BatchSizeBytesHistogram.Bytes.PerSocketDirection.SiloToSilo=
host.server_1   | Messaging.Sent.Bytes.Header.Current=0
host.server_1   | Messaging.Sent.Bytes.Total.Current=0
host.server_1   | Messaging.Sent.Direction.OneWay.Current=0
host.server_1   | Messaging.Sent.Direction.Request.Current=0
host.server_1   | Messaging.Sent.Direction.Response.Current=0
host.server_1   | Messaging.Sent.Failed.Request.Current=27
host.server_1   | Messaging.Sent.LocalMessages.Current=24
host.server_1   | Messaging.Sent.Messages.Total.Current=0
host.server_1   | Messaging.Sent.MessageSizeHistogram.Bytes=
host.server_1   | Networking.Sockets.GatewayToClient.Duplex.Closed.Current=0
host.server_1   | Networking.Sockets.GatewayToClient.Duplex.Opened.Current=0
host.server_1   | Networking.Sockets.Silo.Receiving.Closed.Current=0
host.server_1   | Networking.Sockets.Silo.Receiving.Opened.Current=0
host.server_1   | Networking.Sockets.Silo.Sending.Closed.Current=0
host.server_1   | Networking.Sockets.Silo.Sending.Opened.Current=0
host.server_1   | Queues.QueueSize.Instantaneous.Scheduler.LevelOne=0
host.server_1   | Reminders.AverageTardiness.Seconds=0 Secs
host.server_1   | Reminders.NumberOfActiveReminders=1
host.server_1   | Reminders.TicksDelivered.Current=0
host.server_1   | Runtime.IsOverloaded=False
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.GatewayAcceptor.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.GatewayClientCleanupAgent.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.IncomingMessageAcceptor.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.IncomingMessageAgent.Current=3
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Messaging.SiloMessageSender.Current=0
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Scheduler.WorkerPoolThread.Current=5
host.server_1   | Runtime.Threads.AsynchAgent.Runtime.Watchdog.Current=1
host.server_1   | Runtime.Threads.AsynchAgent.TotalThreadsCreated.Current=16
host.server_1   | Scheduler.NumLongQueueWaitTimes.Current=0
host.server_1   | Scheduler.NumLongRunningTurns.Current=0
host.server_1   | Scheduler.WorkItemGroupCount=14
host.server_1   | Serialization.BufferPool.AllocatedBuffers.Current=250
host.server_1   | Serialization.BufferPool.BuffersInPool=250
host.server_1   | Serialization.BufferPool.CheckedInBuffers.Current=250
host.server_1   | Serialization.BufferPool.CheckedOutBuffers.Current=250
host.server_1   | Serialization.BufferPool.DroppedBuffers.Current=0
host.server_1   | Serialization.BufferPool.DroppedTooLargeBuffers.Current=0
host.server_1   | Serialization.BufferPool.InUse.AllocatedAndNotInPool_Buffers=0
host.server_1   | Serialization.BufferPool.InUse.CheckedOutAndNotCheckedIn_Buffers=0
host.server_1   | Silo.StartTime=2018-06-12 09:45:10.221 GMT
host.server_1   | Storage.Activate.Errors.Current=0
host.server_1   | Storage.Activate.Total.Current=0
host.server_1   | Storage.Clear.Errors.Current=0
host.server_1   | Storage.Clear.Latency=0 Secs
host.server_1   | Storage.Clear.Total.Current=0
host.server_1   | Storage.Read.Errors.Current=0
host.server_1   | Storage.Read.Latency=0 Secs
host.server_1   | Storage.Read.Total.Current=0
host.server_1   | Storage.Write.Errors.Current=0
host.server_1   | Storage.Write.Latency=0 Secs
host.server_1   | Storage.Write.Total.Current=0
host.server_1   | SystemTarget..Current=4
host.server_1   | Transactions.Abort.Total.Current=0
host.server_1   | Transactions.Commit.Completed.Current=0
host.server_1   | Transactions.Commit.InDoubt.Current=0
host.server_1   | Transactions.Commit.QueueLength.Current=0
host.server_1   | Transactions.Commit.Request.Current=0
host.server_1   | Transactions.Start.Completed.Current=0
host.server_1   | Transactions.Start.QueueLength.Current=0
host.server_1   | Transactions.Start.Request.Current=0
host.server_1   | Watchdog.NumHealthChecks.Current=0
host.server_1   |
host.server_1   | [12:45:21 INF] Lifecycle observer Orleans.Runtime.Silo stopped in stage 2000 which took 44 Milliseconds.
host.server_1   | [12:45:21 INF] Stopping lifecycle stage 2000 took 45 Milliseconds
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 that runs on managed thread 10
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 that runs on managed thread 9
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 that runs on managed thread 11
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.5 that runs on managed thread 7
host.server_1   | [12:45:21 INF] Stopping AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 that runs on managed thread 8
host.server_1   | [12:45:21 INF] OrleansTaskScheduler.PrintStatistics(): RunQueue=0 WorkItems=14 Directory:
host.server_1   | [--System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=33; Total processed=33; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-12:Queued=0; Detailed SchedulingContext=&lt;[LowPrioritySystemTarget: S172.26.83.96:11111:266492710*stg/0/00000000@S00000000] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/10/0000000aWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=3; Total processed=3; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-5:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #48: . Reason = Recent (00:00:00.0937146 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 48 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a-&gt;S172.26.83.96:11111:266492710*stg/10/0000000a@S0000000a #48: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/11/0000000bWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=4; Total processed=4; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-6:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/11/0000000b@S0000000b] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/12/0000000cWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-2:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/12/0000000c@S0000000c] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/13/0000000dWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=2; Total processed=2; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-8:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/13/0000000d@S0000000d] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/14/0000000eWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=67; Total processed=67; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-13:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #49: . Reason = Recent (00:00:00.1249664 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 49 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a-&gt;S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e #49: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/15/0000000fWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=34; Total processed=34; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-10:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f-&gt;S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f #50: . Reason = Recent (00:00:00.1874086 ago at 2018-06-12 09:45:21.322 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 50 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/15/0000000f@S0000000f-&gt;S172.26.83.96:11111:266492710*stg/15/0000000f@S0000000f #50: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/17/00000011WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=1; Total processed=1; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-9:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/17/00000011@S00000011] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/19/00000013WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-14:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/19/00000013@S00000013] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=76; Total processed=76; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-1:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/20/00000014@S00000014] CurrentlyExecuting=Unrecoverable Rejection (info:  Orleans.Runtime.OrleansMessageRejectionException: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/14/0000000e@S0000000e-&gt;S172.26.95.237:11111:266481757*stg/10/0000000a@S0000000a #46: . Reason = Recent (00:00:00.0312286 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 46 without sending. CONNECTION_RETRY_DELAY = 00:00:01.
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;LookupAsync&gt;d__112.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem`1.&lt;Execute&gt;d__8.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.RandomPlacementDirector.&lt;OnSelectActivation&gt;d__1.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Placement.PlacementDirectorsManager.&lt;SelectOrAddActivation&gt;d__10.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;AddressMessageAsync&gt;d__41.MoveNext()
host.server_1   | --- End of stack trace from previous location where exception was thrown ---
host.server_1   |    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
host.server_1   |    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
host.server_1   |    at Orleans.Runtime.Dispatcher.&lt;&gt;c__DisplayClass37_0.&lt;&lt;AsyncSendMessage&gt;b__1&gt;d.MoveNext()) Response S172.26.83.96:11111:266492710*grn/B3628901/00000000+Default-&gt;S172.26.83.96:11111:266492710*stg/20/00000014@S00000014 #44: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/22/00000016WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=14; Total processed=14; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-4:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/22/00000016@S00000016] CurrentlyExecuting=Transient Rejection (info: Silo S172.26.83.96:11111:266492710 is rejecting message: Request S172.26.83.96:11111:266492710*stg/22/00000016@S00000016-&gt;S172.26.95.237:11111:266481757*stg/22/00000016@S00000016 #8: . Reason = Recent (00:00:00 ago at 2018-06-12 09:45:21.353 GMT) connection failure trying to reach target silo S172.26.95.237:11111:266481757. Going to drop Request msg 8 without sending. CONNECTION_RETRY_DELAY = 00:00:01.) Response S172.26.95.237:11111:266481757*stg/22/00000016@S00000016-&gt;S172.26.83.96:11111:266492710*stg/22/00000016@S00000016 #8: &gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/24/00000018WorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-7:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/24/00000018@S00000018] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/27/0000001bWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=0; Total processed=0; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-3:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/27/0000001b@S0000001b] CurrentlyExecuting=null&gt;
host.server_1   | --System*WorkItemGroup:Name=*stg/28/0000001cWorkGroupStatus=Waiting. Currently QueuedWorkItems=0; Total EnQueued=656; Total processed=656; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-11:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S172.26.83.96:11111:266492710*stg/28/0000001c@S0000001c] CurrentlyExecuting=null&gt;]
host.server_1   | [12:45:21 INF] Silo Stopped
host.server_1   | [12:45:21 WRN] Process is exiting
host.server_1   | [12:45:21 INF] Silo termination is in progress - Will wait for it to finish
host.server_1 exited with code 1

&lt;/pre&gt;
&lt;/details&gt;</Title_Description>
    <Label>P4</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>12/06/2018 10:33:43 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4678</IssueLabelID>
    <Title>Help generating documents from code comments</Title>
    <Description>Has anyone successfully used a document generator like DocFX to create documents from the comments in the Orleans code? 
If so would you be willing to tell me exactly what you did?</Description>
    <Title_Description>Help generating documents from code comments Has anyone successfully used a document generator like DocFX to create documents from the comments in the Orleans code? 
If so would you be willing to tell me exactly what you did?</Title_Description>
    <Label>P2</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4675</IssueLabelID>
    <Title>Documentation for GrainServices</Title>
    <Description>@JillHeaden I made this during a gitter conversation hopefully it'll be of some use to whoever's making Orleans documentation :)

https://docs.google.com/document/d/1JW8nJW8yK7ZhzO_pMWgWUfMNMq8og90qBmCWdOaX9iQ/edit#</Description>
    <Title_Description>Documentation for GrainServices @JillHeaden I made this during a gitter conversation hopefully it'll be of some use to whoever's making Orleans documentation :)

https://docs.google.com/document/d/1JW8nJW8yK7ZhzO_pMWgWUfMNMq8og90qBmCWdOaX9iQ/edit#</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4674</IssueLabelID>
    <Title>Remove dead code that used to track extended statistics</Title>
    <Description>Fixes #4494.</Description>
    <Title_Description>Remove dead code that used to track extended statistics Fixes #4494.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4672</IssueLabelID>
    <Title>Remove unused settings MaxPendingWorkItemsHardLimit in SchedulingOptions</Title>
    <Description>MaxPendingWorkItemsHardLimit is not used. No reason for it to be exposed through SchedulingOptions</Description>
    <Title_Description>Remove unused settings MaxPendingWorkItemsHardLimit in SchedulingOptions MaxPendingWorkItemsHardLimit is not used. No reason for it to be exposed through SchedulingOptions</Title_Description>
    <Label>breaking-change</Label>
    <Assignee>xiazen</Assignee>
    <CreatedAt>8/06/2018 10:11:40 PM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 11:35:54 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4669</IssueLabelID>
    <Title>Tutorial on Custom Grain Storage for 2.0</Title>
    <Description>This is a tutorial on how to create a custom grain storage for 2.0.

It is taking as base the previous document on storage provider 1.5 but updated to follow the current grain storage implementation found in Azure persistence and AWS persistence

It is explaining implementation of `IGrainStorage` and `ILifecycleParticipant&lt;ISiloLifecycle&gt;`. It also explains how to create the factory and the extensions in order to make the grain storage registration available on the `ISiloHostBuilder`.

_I am not sure if this is the right place to merge could you please advise and I will move the tutorial. Thanks!_</Description>
    <Title_Description>Tutorial on Custom Grain Storage for 2.0 This is a tutorial on how to create a custom grain storage for 2.0.

It is taking as base the previous document on storage provider 1.5 but updated to follow the current grain storage implementation found in Azure persistence and AWS persistence

It is explaining implementation of `IGrainStorage` and `ILifecycleParticipant&lt;ISiloLifecycle&gt;`. It also explains how to create the factory and the extensions in order to make the grain storage registration available on the `ISiloHostBuilder`.

_I am not sure if this is the right place to merge could you please advise and I will move the tutorial. Thanks!_</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4668</IssueLabelID>
    <Title>Fix wire backward compatibility</Title>
    <Description>Addresses https://github.com/dotnet/orleans/issues/4666.</Description>
    <Title_Description>Fix wire backward compatibility Addresses https://github.com/dotnet/orleans/issues/4666.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4667</IssueLabelID>
    <Title>Fixes for v1.5.4</Title>
    <Description>
    </Description>
    <Title_Description>Fixes for v1.5.4 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4666</IssueLabelID>
    <Title>#4479 broke Silo backward compatibility</Title>
    <Description>#4479 introduced a breaking change in the wire protocol between silos.

Not sure if it could be fixed easily or if we could just revert this change.

@dVakulen?

</Description>
    <Title_Description>#4479 broke Silo backward compatibility #4479 introduced a breaking change in the wire protocol between silos.

Not sure if it could be fixed easily or if we could just revert this change.

@dVakulen?

</Title_Description>
    <Label>bug</Label>
    <Assignee>dVakulen</Assignee>
    <CreatedAt>7/06/2018 10:00:53 PM +00:00</CreatedAt>
    <ClosedAt>14/06/2018 9:26:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4664</IssueLabelID>
    <Title>Problem starting single silo cluster after ungraceful silo shutdown</Title>
    <Description>The default cluster membership options will have it take 10 minutes of failing to contact another silo before it can be marked dead but only 5 minutes for a new silo to attempt to join a cluster. This results in a 5 minute window where a new silo can't join the cluster if the previous silo(s) was ungracefully shutdown.
I can certainly change the timeouts in our application but I'm a) not super familiar with their function and b) wondering if the defaults should prevent that situation.

The other problem is that the new silo continues to run after failing to join and doesn't seem to try again. Perhaps I am missing some configuration or a try/catch but I would like to not leave a silo around in a broken state.</Description>
    <Title_Description>Problem starting single silo cluster after ungraceful silo shutdown The default cluster membership options will have it take 10 minutes of failing to contact another silo before it can be marked dead but only 5 minutes for a new silo to attempt to join a cluster. This results in a 5 minute window where a new silo can't join the cluster if the previous silo(s) was ungracefully shutdown.
I can certainly change the timeouts in our application but I'm a) not super familiar with their function and b) wondering if the defaults should prevent that situation.

The other problem is that the new silo continues to run after failing to join and doesn't seem to try again. Perhaps I am missing some configuration or a try/catch but I would like to not leave a silo around in a broken state.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4662</IssueLabelID>
    <Title>Orleans 1.5.2 bug - GrainStateStorageBridge loses exception callstack</Title>
    <Description>Hi

I've looked into code of `GrainStateStorageBridge` and in the method `WriteStateAsync` found that if an `OrleansException` is caught is won't be wrapped in an `OrleansException` and will later thrown as is in a way that loses the original callstack which is a bug:

```
public async Task WriteStateAsync()
    {
      Stopwatch sw = Stopwatch.StartNew();
      GrainReference grainRef = this.baseGrain.GrainReference;
      Exception exception;
      try
      {
        await this.store.WriteStateAsync(this.grainTypeName grainRef this.statefulGrain.GrainState);
        StorageStatisticsGroup.OnStorageWrite(this.store this.grainTypeName grainRef sw.Elapsed);
        exception = (Exception) null;
      }
      catch (Exception ex)
      {
        exception = ex;
      }
      if (exception != null)
      {
        StorageStatisticsGroup.OnStorageWriteError(this.store this.grainTypeName grainRef);
        string message = this.MakeErrorMsg("WriteState" exception);
        this.store.Log.Error(102203 message exception);
        if (!(exception is OrleansException))
          exception = (Exception) new OrleansException(message exception);
      }
      sw.Stop();
      if (exception != null)
        throw exception;
    }
```</Description>
    <Title_Description>Orleans 1.5.2 bug - GrainStateStorageBridge loses exception callstack Hi

I've looked into code of `GrainStateStorageBridge` and in the method `WriteStateAsync` found that if an `OrleansException` is caught is won't be wrapped in an `OrleansException` and will later thrown as is in a way that loses the original callstack which is a bug:

```
public async Task WriteStateAsync()
    {
      Stopwatch sw = Stopwatch.StartNew();
      GrainReference grainRef = this.baseGrain.GrainReference;
      Exception exception;
      try
      {
        await this.store.WriteStateAsync(this.grainTypeName grainRef this.statefulGrain.GrainState);
        StorageStatisticsGroup.OnStorageWrite(this.store this.grainTypeName grainRef sw.Elapsed);
        exception = (Exception) null;
      }
      catch (Exception ex)
      {
        exception = ex;
      }
      if (exception != null)
      {
        StorageStatisticsGroup.OnStorageWriteError(this.store this.grainTypeName grainRef);
        string message = this.MakeErrorMsg("WriteState" exception);
        this.store.Log.Error(102203 message exception);
        if (!(exception is OrleansException))
          exception = (Exception) new OrleansException(message exception);
      }
      sw.Stop();
      if (exception != null)
        throw exception;
    }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4661</IssueLabelID>
    <Title>Lock Microsoft.AzureEventHubs version to 1.0.3</Title>
    <Description>Use nuget exact version match because Microsoft.Orleans.OrleansServiceBus will get runtime errors if a higher version of Microsoft.AzureEventHubs is referenced.</Description>
    <Title_Description>Lock Microsoft.AzureEventHubs version to 1.0.3 Use nuget exact version match because Microsoft.Orleans.OrleansServiceBus will get runtime errors if a higher version of Microsoft.AzureEventHubs is referenced.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4660</IssueLabelID>
    <Title>Make LifecycleSubject logging less verbose</Title>
    <Description>For #4659 </Description>
    <Title_Description>Make LifecycleSubject logging less verbose For #4659 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4659</IssueLabelID>
    <Title>Logging is too verbose for LifecycleSubject</Title>
    <Description>Currently both silo and grain has a lifecycle  and they both uses `LifecycleSubject` class. But in LifecycleSubject class it would record how long each stage took and log the timelapse as INFO level message. This is fine for silo lifecycle. but too verbose for grain lifecycle logging. Suggest 
- downgrade the logging from INFO to VERBOS for grain lifecycle or 
- turn grain lifecycle stage timelapse logging into some statistics 


</Description>
    <Title_Description>Logging is too verbose for LifecycleSubject Currently both silo and grain has a lifecycle  and they both uses `LifecycleSubject` class. But in LifecycleSubject class it would record how long each stage took and log the timelapse as INFO level message. This is fine for silo lifecycle. but too verbose for grain lifecycle logging. Suggest 
- downgrade the logging from INFO to VERBOS for grain lifecycle or 
- turn grain lifecycle stage timelapse logging into some statistics 


</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4658</IssueLabelID>
    <Title>Expected GrainFactory behavior in a heterogeneous silos environment?</Title>
    <Description>Hi

I've set up [heterogeneous silos](http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html) and verified that a client indeed doesn't need to know where grains are hosted (and that's fine).

However the scenario of agnostic grain invocation fails with the following setup:

- The environment is a cluster (I've used [Consul](https://www.consul.io/) as a membership provider)
- First silo has one grain of type 'A' (in my case it's a simple 'Hello' grain)
- Second silo has one grain of type 'B' (a simple 'AnotherHello' grain)
- Both interfaces and implementations are isolated (one assembly for each artifact - 4 projects)

The first grain 'A' has one responsibility to find and invoke grain 'B'. Grain 'B' logs a simple message ('AnotherHello').

The client begin the call chain by invoking 'A'.

When control hits 'A' it tries to resolve 'B' by using `GrainFactory` however the `GrainFactory` throws an exception saying that the implementation for 'B' is unknown.

I suspect that `GrainFactory` makes a look-up inside the hosting silo but not beyond (e.g. in the cluster) because if the silo host both 'A' and 'B' then `GrainFactory` finds the reference and everything works fine.

Is this correct interpretation of `GrainFactory` or is this unexpected behavior? If this is the expected behavior of `GrainFactory` then grains have to know what grains are hosted in the silo (agnostic grain invocation won't work) to avoid generating the exception.

Kind regards
Jan
</Description>
    <Title_Description>Expected GrainFactory behavior in a heterogeneous silos environment? Hi

I've set up [heterogeneous silos](http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Heterogeneous-Silos.html) and verified that a client indeed doesn't need to know where grains are hosted (and that's fine).

However the scenario of agnostic grain invocation fails with the following setup:

- The environment is a cluster (I've used [Consul](https://www.consul.io/) as a membership provider)
- First silo has one grain of type 'A' (in my case it's a simple 'Hello' grain)
- Second silo has one grain of type 'B' (a simple 'AnotherHello' grain)
- Both interfaces and implementations are isolated (one assembly for each artifact - 4 projects)

The first grain 'A' has one responsibility to find and invoke grain 'B'. Grain 'B' logs a simple message ('AnotherHello').

The client begin the call chain by invoking 'A'.

When control hits 'A' it tries to resolve 'B' by using `GrainFactory` however the `GrainFactory` throws an exception saying that the implementation for 'B' is unknown.

I suspect that `GrainFactory` makes a look-up inside the hosting silo but not beyond (e.g. in the cluster) because if the silo host both 'A' and 'B' then `GrainFactory` finds the reference and everything works fine.

Is this correct interpretation of `GrainFactory` or is this unexpected behavior? If this is the expected behavior of `GrainFactory` then grains have to know what grains are hosted in the silo (agnostic grain invocation won't work) to avoid generating the exception.

Kind regards
Jan
</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4657</IssueLabelID>
    <Title>Cannot configure MessagingOptions.ResponseTimeoutWithDebugger via builder extension methods</Title>
    <Description>Perhaps I simply can't find the means but it doesn't seem possible to use either the legacy ClientConfiguration or a new method to set MessagingOptions.ResponseTimeoutWithDebugger. The "Messaging" option in client configuration .xml's are from MessagingConfiguration which doesn't support the field.

As a workaround I am simply post configuring the ClientMessagingOptions:
```
var client = new ClientBuilder()
    .UseConfiguration(config)
    .ConfigureApplicationParts(appParts =&gt;
    {
        appParts.AddFromApplicationBaseDirectory().WithReferences();
        appParts.AddFromAppDomain().WithReferences();
    })
#if DEBUG
    .ConfigureServices(s =&gt; s.PostConfigure&lt;ClientMessagingOptions&gt;(options =&gt; options.ResponseTimeoutWithDebugger = TimeSpan.FromSeconds(15)))
#endif
    .Build();
```</Description>
    <Title_Description>Cannot configure MessagingOptions.ResponseTimeoutWithDebugger via builder extension methods Perhaps I simply can't find the means but it doesn't seem possible to use either the legacy ClientConfiguration or a new method to set MessagingOptions.ResponseTimeoutWithDebugger. The "Messaging" option in client configuration .xml's are from MessagingConfiguration which doesn't support the field.

As a workaround I am simply post configuring the ClientMessagingOptions:
```
var client = new ClientBuilder()
    .UseConfiguration(config)
    .ConfigureApplicationParts(appParts =&gt;
    {
        appParts.AddFromApplicationBaseDirectory().WithReferences();
        appParts.AddFromAppDomain().WithReferences();
    })
#if DEBUG
    .ConfigureServices(s =&gt; s.PostConfigure&lt;ClientMessagingOptions&gt;(options =&gt; options.ResponseTimeoutWithDebugger = TimeSpan.FromSeconds(15)))
#endif
    .Build();
```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4656</IssueLabelID>
    <Title>Legacy UseConfiguration doesn't properly set DynamoDBReminderStorageOptions</Title>
    <Description>Upgrading from 2.0.0-beta3 I've observed:

&gt; Orleans.Runtime.OrleansLifecycleCanceledException: 'Lifecycle start canceled due to errors at stage 20000'

&gt; InnerException | {System.ArgumentNullException: Value cannot be null. Parameter name: service    at Orleans.Reminders.DynamoDB.DynamoDBStorage..ctor(ILoggerFactory loggerFactory String service String accessKey String secretKey Int32 readCapacityUnits Int32 writeCapacityUnits)    at Orleans.Reminders.DynamoDB.DynamoDBReminderTable.Init()    at Orleans.Runtime.ReminderService.LocalReminderService.&lt;Start&gt;d__16.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;&lt;OnActiveStart&gt;g__StartReminderService73_0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;d__73.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()} | System.Exception {System.ArgumentNullException}

This seems to be caused by the DynamoDBReminderStorageOptions object not properly being configured when using the legacy extension method UseConfiguration. DynamoDBClusteringOptions does get properly set however.

After manually setting these fields via UseDynamoDBReminderService() everything works:
```C#
DynamoDBClusteringOptions clusteringOptions = null;
var siloBuilder = new SiloHostBuilder()
    .ConfigureApplicationParts(appParts =&gt;
    {
        appParts.AddFromApplicationBaseDirectory().WithReferences();
        appParts.AddFromAppDomain().WithReferences();
    })
    .UseConfiguration(config)
    .UseDynamoDBClustering((DynamoDBClusteringOptions options) =&gt;
    {
        // We don't need to do configuring in here because the legacy
        // .UseConfiguration still handles it for us (for now)
        clusteringOptions = options;
    })
    .UseDynamoDBReminderService((DynamoDBReminderStorageOptions options) =&gt;
    {
        // Unfortunately there's seems to be a a bug in Orleans that doesn't
        // propagate the same clustering options to the reminder storage options
        options.Service = clusteringOptions.Service;
        options.AccessKey = clusteringOptions.AccessKey;
        options.SecretKey = clusteringOptions.SecretKey;
    });
```
</Description>
    <Title_Description>Legacy UseConfiguration doesn't properly set DynamoDBReminderStorageOptions Upgrading from 2.0.0-beta3 I've observed:

&gt; Orleans.Runtime.OrleansLifecycleCanceledException: 'Lifecycle start canceled due to errors at stage 20000'

&gt; InnerException | {System.ArgumentNullException: Value cannot be null. Parameter name: service    at Orleans.Reminders.DynamoDB.DynamoDBStorage..ctor(ILoggerFactory loggerFactory String service String accessKey String secretKey Int32 readCapacityUnits Int32 writeCapacityUnits)    at Orleans.Reminders.DynamoDB.DynamoDBReminderTable.Init()    at Orleans.Runtime.ReminderService.LocalReminderService.&lt;Start&gt;d__16.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;&lt;OnActiveStart&gt;g__StartReminderService73_0&gt;d.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;StartAsyncTaskWithPerfAnalysis&gt;d__69.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.Silo.&lt;OnActiveStart&gt;d__73.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.&lt;OnStart&gt;d__9.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.LifecycleSubject.&lt;WrapExecution&gt;d__8.MoveNext() --- End of stack trace from previous location where exception was thrown ---    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)    at Orleans.LifecycleSubject.&lt;OnStart&gt;d__4.MoveNext()} | System.Exception {System.ArgumentNullException}

This seems to be caused by the DynamoDBReminderStorageOptions object not properly being configured when using the legacy extension method UseConfiguration. DynamoDBClusteringOptions does get properly set however.

After manually setting these fields via UseDynamoDBReminderService() everything works:
```C#
DynamoDBClusteringOptions clusteringOptions = null;
var siloBuilder = new SiloHostBuilder()
    .ConfigureApplicationParts(appParts =&gt;
    {
        appParts.AddFromApplicationBaseDirectory().WithReferences();
        appParts.AddFromAppDomain().WithReferences();
    })
    .UseConfiguration(config)
    .UseDynamoDBClustering((DynamoDBClusteringOptions options) =&gt;
    {
        // We don't need to do configuring in here because the legacy
        // .UseConfiguration still handles it for us (for now)
        clusteringOptions = options;
    })
    .UseDynamoDBReminderService((DynamoDBReminderStorageOptions options) =&gt;
    {
        // Unfortunately there's seems to be a a bug in Orleans that doesn't
        // propagate the same clustering options to the reminder storage options
        options.Service = clusteringOptions.Service;
        options.AccessKey = clusteringOptions.AccessKey;
        options.SecretKey = clusteringOptions.SecretKey;
    });
```
</Title_Description>
    <Label>P4</Label>
    <Assignee>xiazen</Assignee>
    <CreatedAt>6/06/2018 2:32:21 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4655</IssueLabelID>
    <Title>How to debug deadlocks in orleans 2.0 ? (Target History)</Title>
    <Description>When running into deadlocks due to circular references or other reasons orleans gets stuck until it eventualy times out with a TimeoutException.

In orleans 1.5 it used to give an error including the grain/method name that got stuck in readable form in the target history.

In orleans 2.0 I just get something like this:

![image](https://user-images.githubusercontent.com/20849443/41015805-3f19c518-698f-11e8-94d7-241a99b7c243.png)

I have no idea how to debug this in a sane way to find which method got stuck.

Is there some kind of setting I can use to get better error messages?</Description>
    <Title_Description>How to debug deadlocks in orleans 2.0 ? (Target History) When running into deadlocks due to circular references or other reasons orleans gets stuck until it eventualy times out with a TimeoutException.

In orleans 1.5 it used to give an error including the grain/method name that got stuck in readable form in the target history.

In orleans 2.0 I just get something like this:

![image](https://user-images.githubusercontent.com/20849443/41015805-3f19c518-698f-11e8-94d7-241a99b7c243.png)

I have no idea how to debug this in a sane way to find which method got stuck.

Is there some kind of setting I can use to get better error messages?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4654</IssueLabelID>
    <Title>The target silo became unavailable for message.  The silo appears to be running.</Title>
    <Description>I've upgraded to Orleans 2.0 and I'm able to successfully run the silo and client web application on my dev machine. The client application is able to connect to the silo obtain grains all seems to work fine. When i deploy the silo and client application to our dev server I'm getting the "The target silo became unavailable for message" exception when trying to connect to the silo. I know that this can happen if the silo isn't yet ready for connections so we have a retry mechanism when connecting however the silo appears to be running and doing work (reminders are firing and such). I've read through https://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Troubleshooting-Deployments.html to no avail.

Here is the code used to configure the silo
`private static ISiloHost CreateSiloHost()
        {
            var siloHostBuilder = new SiloHostBuilder();
            var invariant = ConfigurationManager.ConnectionStrings["BackingStore"].ProviderName;
            var connectionString = ConfigurationManager.ConnectionStrings["BackingStore"].ConnectionString;

            var appSettings = BuildApplicationSettings();

            Log.Logger = Startup.CreateLogger();

            siloHostBuilder.UseServiceProviderFactory(services =&gt;
            {
                var builder = new ContainerBuilder();

                builder.RegisterLogger(Log.Logger true);
                builder.RegisterModule&lt;DataModule&gt;();
                builder.RegisterModule&lt;ServiceModule&gt;();
                builder.Populate(services);
                var container = builder.Build();
                return container.Resolve&lt;IServiceProvider&gt;();
            })
            .AddSimpleMessageStreamProvider("SMSProvider")
            .Configure&lt;ClusterOptions&gt;(options =&gt;
            {
                options.ClusterId = "ClusterID";
                options.ServiceId = "ServiceID";
            })
            .ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)
            .UseAdoNetClustering(options =&gt;
            {
                options.Invariant = invariant;
                options.ConnectionString = connectionString;
            })
            .UseAdoNetReminderService(options =&gt;
            {
                options.Invariant = invariant;
                options.ConnectionString = connectionString;
            })
            .AddAdoNetGrainStorage("PubSubStore" op =&gt;
            {
                op.ConnectionString = connectionString;
                op.Invariant = invariant;
            })
            .AddAdoNetGrainStorageAsDefault(op =&gt;
            {
                op.ConnectionString = connectionString;
                op.Invariant = invariant;
            })
            .ConfigureLogging(lb =&gt;
            {
                lb.AddConsole();
                lb.AddSerilog(Log.Logger);
            })
            .ConfigureApplicationParts(c =&gt;
                c.AddApplicationPart(typeof(IFeatureManagementStartupGrain).Assembly).WithReferences())
            .Configure&lt;MessagingOptions&gt;(options =&gt;
            {
                options.ResponseTimeout = appSettings.ResponseTimeout;
                options.ResendOnTimeout = appSettings.ResendOnTimeout;
                options.MaxResendCount = appSettings.MaxResendCount;
            })
            //This will bootstrap all of the grains.  The logs show that the reminders are firing
            .AddStartupTask&lt;GrainStartupTask&gt;();

            return siloHostBuilder.Build();
        }`

Here is the code in the client:
`public static IGrainFactory BuildGrainFactory()
        {
            IClusterClient client = null;

            var invariant = ConfigurationManager.ConnectionStrings["BackingStore"].ProviderName;
            var connectionString = ConfigurationManager.ConnectionStrings["BackingStore"].ConnectionString;

            var result = Policy.Handle&lt;Orleans.Runtime.SiloUnavailableException&gt;().Or&lt;System.AggregateException&gt;()
                .WaitAndRetry(10 r =&gt; TimeSpan.FromSeconds(Math.Pow(2 r)))
                .ExecuteAndCapture(() =&gt;
                {
                    try
                    {
                        client = new ClientBuilder()
                        .Configure&lt;ClusterOptions&gt;(options =&gt;
                        {
                            options.ClusterId = "ClusterID";
                            options.ServiceId = "ServiceID";
                        })
                        .UseAdoNetClustering(options =&gt;
                        {
                            options.Invariant = invariant;
                            options.ConnectionString = connectionString;
                        })
                        .AddSimpleMessageStreamProvider("SMSProvider")
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IFeatureManagementGrain).Assembly))
                        .Build();

                        client.Connect().Wait();
                    }
                    catch (AggregateException ex)
                    {
                        Log.Logger.Error(ex "Failed to initialize orleans client");

                        if (ex.InnerException is SiloUnavailableException siloUnavailableException)
                        {
                            Log.Logger.Error(ex.InnerException "Failed to initialize orleans client");
                            client.Dispose();
                            throw;
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Logger.Error(ex "Failed to initialize orleans client");
                    }
                });

            if (result.Outcome == OutcomeType.Failure)
            {
                Log.Logger.Error("Failed to initialize the Orleans client");
            }

            return client;
        }`

Please note when I revert back to our orleans 1.5 application on the DEV server everything works so it shouldn't be a network connectivity issue on the server.  Here are the logs of the silo starting.
[OrleansDebugLog.xlsx](https://github.com/dotnet/orleans/files/2073614/OrleansDebugLog.xlsx)

Here is the exception from the client:

&gt; "The target silo became unavailable for message: Request *cli/d0621ab9@97ba6db4-&gt;S10.10.92.113:30000:265920396*stg/17/00000011@S00000011 #10: . Target History is: &lt;S10.10.92.113:30000:265920396:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help." Data: {…} InnerException: null TargetSite: "Void Throw()" StackTrace: "   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;b__58_2&gt;d.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 249\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 269\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__58.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 252\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__57.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 193\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.ClusterClient.&lt;Connect&gt;d__19.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Core\\ClusterClient.cs:line 120" HelpLink: null Source: "mscorlib" HResult: -2146233088 Type: "Orleans.Runtime.SiloUnavailableException"}

 Any suggestions on how I can debug this issue?  Thanks!</Description>
    <Title_Description>The target silo became unavailable for message.  The silo appears to be running. I've upgraded to Orleans 2.0 and I'm able to successfully run the silo and client web application on my dev machine. The client application is able to connect to the silo obtain grains all seems to work fine. When i deploy the silo and client application to our dev server I'm getting the "The target silo became unavailable for message" exception when trying to connect to the silo. I know that this can happen if the silo isn't yet ready for connections so we have a retry mechanism when connecting however the silo appears to be running and doing work (reminders are firing and such). I've read through https://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Troubleshooting-Deployments.html to no avail.

Here is the code used to configure the silo
`private static ISiloHost CreateSiloHost()
        {
            var siloHostBuilder = new SiloHostBuilder();
            var invariant = ConfigurationManager.ConnectionStrings["BackingStore"].ProviderName;
            var connectionString = ConfigurationManager.ConnectionStrings["BackingStore"].ConnectionString;

            var appSettings = BuildApplicationSettings();

            Log.Logger = Startup.CreateLogger();

            siloHostBuilder.UseServiceProviderFactory(services =&gt;
            {
                var builder = new ContainerBuilder();

                builder.RegisterLogger(Log.Logger true);
                builder.RegisterModule&lt;DataModule&gt;();
                builder.RegisterModule&lt;ServiceModule&gt;();
                builder.Populate(services);
                var container = builder.Build();
                return container.Resolve&lt;IServiceProvider&gt;();
            })
            .AddSimpleMessageStreamProvider("SMSProvider")
            .Configure&lt;ClusterOptions&gt;(options =&gt;
            {
                options.ClusterId = "ClusterID";
                options.ServiceId = "ServiceID";
            })
            .ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)
            .UseAdoNetClustering(options =&gt;
            {
                options.Invariant = invariant;
                options.ConnectionString = connectionString;
            })
            .UseAdoNetReminderService(options =&gt;
            {
                options.Invariant = invariant;
                options.ConnectionString = connectionString;
            })
            .AddAdoNetGrainStorage("PubSubStore" op =&gt;
            {
                op.ConnectionString = connectionString;
                op.Invariant = invariant;
            })
            .AddAdoNetGrainStorageAsDefault(op =&gt;
            {
                op.ConnectionString = connectionString;
                op.Invariant = invariant;
            })
            .ConfigureLogging(lb =&gt;
            {
                lb.AddConsole();
                lb.AddSerilog(Log.Logger);
            })
            .ConfigureApplicationParts(c =&gt;
                c.AddApplicationPart(typeof(IFeatureManagementStartupGrain).Assembly).WithReferences())
            .Configure&lt;MessagingOptions&gt;(options =&gt;
            {
                options.ResponseTimeout = appSettings.ResponseTimeout;
                options.ResendOnTimeout = appSettings.ResendOnTimeout;
                options.MaxResendCount = appSettings.MaxResendCount;
            })
            //This will bootstrap all of the grains.  The logs show that the reminders are firing
            .AddStartupTask&lt;GrainStartupTask&gt;();

            return siloHostBuilder.Build();
        }`

Here is the code in the client:
`public static IGrainFactory BuildGrainFactory()
        {
            IClusterClient client = null;

            var invariant = ConfigurationManager.ConnectionStrings["BackingStore"].ProviderName;
            var connectionString = ConfigurationManager.ConnectionStrings["BackingStore"].ConnectionString;

            var result = Policy.Handle&lt;Orleans.Runtime.SiloUnavailableException&gt;().Or&lt;System.AggregateException&gt;()
                .WaitAndRetry(10 r =&gt; TimeSpan.FromSeconds(Math.Pow(2 r)))
                .ExecuteAndCapture(() =&gt;
                {
                    try
                    {
                        client = new ClientBuilder()
                        .Configure&lt;ClusterOptions&gt;(options =&gt;
                        {
                            options.ClusterId = "ClusterID";
                            options.ServiceId = "ServiceID";
                        })
                        .UseAdoNetClustering(options =&gt;
                        {
                            options.Invariant = invariant;
                            options.ConnectionString = connectionString;
                        })
                        .AddSimpleMessageStreamProvider("SMSProvider")
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IFeatureManagementGrain).Assembly))
                        .Build();

                        client.Connect().Wait();
                    }
                    catch (AggregateException ex)
                    {
                        Log.Logger.Error(ex "Failed to initialize orleans client");

                        if (ex.InnerException is SiloUnavailableException siloUnavailableException)
                        {
                            Log.Logger.Error(ex.InnerException "Failed to initialize orleans client");
                            client.Dispose();
                            throw;
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Logger.Error(ex "Failed to initialize orleans client");
                    }
                });

            if (result.Outcome == OutcomeType.Failure)
            {
                Log.Logger.Error("Failed to initialize the Orleans client");
            }

            return client;
        }`

Please note when I revert back to our orleans 1.5 application on the DEV server everything works so it shouldn't be a network connectivity issue on the server.  Here are the logs of the silo starting.
[OrleansDebugLog.xlsx](https://github.com/dotnet/orleans/files/2073614/OrleansDebugLog.xlsx)

Here is the exception from the client:

&gt; "The target silo became unavailable for message: Request *cli/d0621ab9@97ba6db4-&gt;S10.10.92.113:30000:265920396*stg/17/00000011@S00000011 #10: . Target History is: &lt;S10.10.92.113:30000:265920396:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help." Data: {…} InnerException: null TargetSite: "Void Throw()" StackTrace: "   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;b__58_2&gt;d.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 249\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 269\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__58.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 252\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__57.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Runtime\\OutsideRuntimeClient.cs:line 193\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Orleans.ClusterClient.&lt;Connect&gt;d__19.MoveNext() in D:\\build\\agent\\_work\\18\\s\\src\\Orleans.Core\\Core\\ClusterClient.cs:line 120" HelpLink: null Source: "mscorlib" HResult: -2146233088 Type: "Orleans.Runtime.SiloUnavailableException"}

 Any suggestions on how I can debug this issue?  Thanks!</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4652</IssueLabelID>
    <Title>Orleans - Consul clustering</Title>
    <Description>
We have been able to successfully integrate Consul for Orleans clustering. But recently we enabled ACL (Access Control List) to restrict the access to data and api and generated a acl master token and acl agent token.

Do you have an sample of passing the token from the Orleans Silo application.

var builder = new SiloHostBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Cluster1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .UseConsulClustering(gatewayOptions =&gt;
                    {
                        gatewayOptions.Address =   new Uri("http://10.203.xxx.xx:8500/");
                    })
                    .ConfigureEndpoints(siloPort: 11112) 
                        gatewayPort: 30002 hostname: Dns.GetHostName() )
                    .AddMemoryGrainStorageAsDefault();

</Description>
    <Title_Description>Orleans - Consul clustering 
We have been able to successfully integrate Consul for Orleans clustering. But recently we enabled ACL (Access Control List) to restrict the access to data and api and generated a acl master token and acl agent token.

Do you have an sample of passing the token from the Orleans Silo application.

var builder = new SiloHostBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Cluster1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .UseConsulClustering(gatewayOptions =&gt;
                    {
                        gatewayOptions.Address =   new Uri("http://10.203.xxx.xx:8500/");
                    })
                    .ConfigureEndpoints(siloPort: 11112) 
                        gatewayPort: 30002 hostname: Dns.GetHostName() )
                    .AddMemoryGrainStorageAsDefault();

</Title_Description>
    <Label>enhancement</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>5/06/2018 2:47:37 PM +00:00</CreatedAt>
    <ClosedAt>7/09/2018 7:09:23 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4651</IssueLabelID>
    <Title>Overridden method OnDeactivateAsync not called if CollectionAge set in seconds range</Title>
    <Description>Dependencies:

```
    &lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Core.Abstractions" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansCodeGenerator.Build" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansConsulUtils" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansProviders" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Server" Version="2.0.3" /&gt;
```

Silo host configuration:
```
                .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
                {
                    // Set the value of CollectionAge to 10 minutes for all grain
                    options.CollectionAge = TimeSpan.FromMinutes(10);
                    // Override the value of CollectionAge to 5 minutes for MyGrainImplementation
                    options.ClassSpecificCollectionAge[typeof(SessionGrain).FullName] = TimeSpan.FromSeconds(30);
                })
```

Overridden  grain methods:
```
        public override async Task OnActivateAsync()
        {
            _session = await _sessionRepository.Get(Guid.NewGuid());
        }

        public override async Task OnDeactivateAsync()
        {
            await _sessionRepository.Save(_session);
        }
```

With TimeSpan.FromMinutes( ... ); OnDeactivateAsync work as expected. </Description>
    <Title_Description>Overridden method OnDeactivateAsync not called if CollectionAge set in seconds range Dependencies:

```
    &lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Core.Abstractions" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansCodeGenerator.Build" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansConsulUtils" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansProviders" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Server" Version="2.0.3" /&gt;
```

Silo host configuration:
```
                .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
                {
                    // Set the value of CollectionAge to 10 minutes for all grain
                    options.CollectionAge = TimeSpan.FromMinutes(10);
                    // Override the value of CollectionAge to 5 minutes for MyGrainImplementation
                    options.ClassSpecificCollectionAge[typeof(SessionGrain).FullName] = TimeSpan.FromSeconds(30);
                })
```

Overridden  grain methods:
```
        public override async Task OnActivateAsync()
        {
            _session = await _sessionRepository.Get(Guid.NewGuid());
        }

        public override async Task OnDeactivateAsync()
        {
            await _sessionRepository.Save(_session);
        }
```

With TimeSpan.FromMinutes( ... ); OnDeactivateAsync work as expected. </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4650</IssueLabelID>
    <Title>Runtime code generation does not support unicode characters like Ø</Title>
    <Description>When the code is running in the silo this happens:

```printf "hello ÆØÅ"``` outputs hello ???

function names with "exotic" characters is also undefined. If I make a function with en `é` in the name it's broken in the silo. 

I use F# for all the code therefor I reference `Microsoft.Orleans.OrleansCodeGenerator` _not_ `Microsoft.Orleans.OrleansCodeGenerator.Build`.</Description>
    <Title_Description>Runtime code generation does not support unicode characters like Ø When the code is running in the silo this happens:

```printf "hello ÆØÅ"``` outputs hello ???

function names with "exotic" characters is also undefined. If I make a function with en `é` in the name it's broken in the silo. 

I use F# for all the code therefor I reference `Microsoft.Orleans.OrleansCodeGenerator` _not_ `Microsoft.Orleans.OrleansCodeGenerator.Build`.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4647</IssueLabelID>
    <Title>The question of Orleans memory?</Title>
    <Description>Why does the amount of memory that goes into my Orleans service go up all the way to about 500M？

code：
 siloHost = new SiloHostBuilder()
              .Configure&lt;ClusterOptions&gt;(options =&gt;
              {
                  options.ClusterId = clusterId;
                  options.ServiceId = serviceId;

              })
                 .UsePerfCounterEnvironmentStatistics()
               // .UseEnvironment(environment)
                //.ConfigureHostConfiguration(option=&gt; {

                //})
                // .ConfigureEndpoints(System.Net.Dns.GetHostName() int.Parse(siloPort) int.Parse(gatewayPort))
                .Configure&lt;EndpointOptions&gt;(options =&gt;
                {
                    options.AdvertisedIPAddress = GetLocalIp();// IPAddress.Parse("192.168.11.143") ;
                    options.GatewayPort = int.Parse(gatewayPort);
                    options.SiloPort = int.Parse(siloPort);
                })
              //.Configure&lt;LoadSheddingOptions&gt;(op =&gt;
              //{
              //    op.LoadSheddingEnabled = true;
              //    op.LoadSheddingLimit = 90;
              //})
              .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
              {
                  //配置grain的回收
                  options.CollectionAge = TimeSpan.FromMinutes(10);
                  options.CollectionQuantum = TimeSpan.FromMinutes(5);
              })
              //.Configure&lt;PerformanceTuningOptions&gt;(option =&gt;
              //{
              //    option.UseNagleAlgorithm = true;
              //    option.MinDotNetThreadPoolSize = 90;
              //})

              .UseAdoNetClustering(options =&gt;
              {
                  options.ConnectionString = DBConnStr;
                  options.Invariant = "System.Data.SqlClient";
              })
              // .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IProduct).Assembly).WithReferences())
              .ConfigureLogging(logging =&gt;
              {
                  logging.AddFile(logPath + $"\\OrleansSilos -{ DateTime.Now.ToString("yyyy.MM.dd")}.txt");
                  logging.SetMinimumLevel((LogLevel) Enum.Parse(typeof(LogLevel) logLevel));
              })
              .Build();
            siloHost.StartAsync().Wait();</Description>
    <Title_Description>The question of Orleans memory? Why does the amount of memory that goes into my Orleans service go up all the way to about 500M？

code：
 siloHost = new SiloHostBuilder()
              .Configure&lt;ClusterOptions&gt;(options =&gt;
              {
                  options.ClusterId = clusterId;
                  options.ServiceId = serviceId;

              })
                 .UsePerfCounterEnvironmentStatistics()
               // .UseEnvironment(environment)
                //.ConfigureHostConfiguration(option=&gt; {

                //})
                // .ConfigureEndpoints(System.Net.Dns.GetHostName() int.Parse(siloPort) int.Parse(gatewayPort))
                .Configure&lt;EndpointOptions&gt;(options =&gt;
                {
                    options.AdvertisedIPAddress = GetLocalIp();// IPAddress.Parse("192.168.11.143") ;
                    options.GatewayPort = int.Parse(gatewayPort);
                    options.SiloPort = int.Parse(siloPort);
                })
              //.Configure&lt;LoadSheddingOptions&gt;(op =&gt;
              //{
              //    op.LoadSheddingEnabled = true;
              //    op.LoadSheddingLimit = 90;
              //})
              .Configure&lt;GrainCollectionOptions&gt;(options =&gt;
              {
                  //配置grain的回收
                  options.CollectionAge = TimeSpan.FromMinutes(10);
                  options.CollectionQuantum = TimeSpan.FromMinutes(5);
              })
              //.Configure&lt;PerformanceTuningOptions&gt;(option =&gt;
              //{
              //    option.UseNagleAlgorithm = true;
              //    option.MinDotNetThreadPoolSize = 90;
              //})

              .UseAdoNetClustering(options =&gt;
              {
                  options.ConnectionString = DBConnStr;
                  options.Invariant = "System.Data.SqlClient";
              })
              // .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IProduct).Assembly).WithReferences())
              .ConfigureLogging(logging =&gt;
              {
                  logging.AddFile(logPath + $"\\OrleansSilos -{ DateTime.Now.ToString("yyyy.MM.dd")}.txt");
                  logging.SetMinimumLevel((LogLevel) Enum.Parse(typeof(LogLevel) logLevel));
              })
              .Build();
            siloHost.StartAsync().Wait();</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4646</IssueLabelID>
    <Title>Orleans 1.5.2 - Grain doesn't de-activate on InconsistentStateException from timer tick</Title>
    <Description>Hi I have a grain that performs periodic work using a grain timer (not reminder) and I noticed in Orleans code that only grain messages are checked for `InconsistentStateException` in order to de-activate the grain but for timer ticks it's not the case. I find it a bug since I expect the de-activation behavior to take place for timers as well.</Description>
    <Title_Description>Orleans 1.5.2 - Grain doesn't de-activate on InconsistentStateException from timer tick Hi I have a grain that performs periodic work using a grain timer (not reminder) and I noticed in Orleans code that only grain messages are checked for `InconsistentStateException` in order to de-activate the grain but for timer ticks it's not the case. I find it a bug since I expect the de-activation behavior to take place for timers as well.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4645</IssueLabelID>
    <Title>Update Dependency-Injection.md</Title>
    <Description>fixed the typo.</Description>
    <Title_Description>Update Dependency-Injection.md fixed the typo.</Title_Description>
    <Label>documentation</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4637</IssueLabelID>
    <Title>Orleans Client 1.5.2 issue with .NET PerformanceCounter constructor</Title>
    <Description>We (@amccool) have a Windows Service that is an Orleans Client. The service startup initializes the Orleans Client and on some VMs this is causing a timeout (from the Service Control Manager) and silent failure - no errors in logs (Orleans/text) no Windows Event other than the usual System one: "A timeout was reached (30000 milliseconds) while waiting for the XXX service to connect".

The program never has this issue when you run it on a command line it only fails like this as a service. The service is running as "SYSTEM" but changing the "Log On" has no effect . The program does not have this problem on every VM nor on my development machine.

I tracked the error down to the class RuntimeStatisticsGroup and its InitCpuMemoryCounters method. This line:
`cpuCounterPF = new PerformanceCounter("Processor" "% Processor Time" "_Total" true);`
Orleans 1.5.2 sources [HERE](https://github.com/dotnet/orleans/blob/d5ea8dc4e0ef104562a05fe05ce9a3abb181c271/src/Orleans/Statistics/RuntimeStatisticsGroup.cs#L89).
_sometimes_ does not return within 30 seconds; pretty much ever-other-time I start the service about 50% of the time.

I found this related issue on [MSDN](https://social.msdn.microsoft.com/Forums/en-US/cd6adebf-231d-40a8-842f-ba06e849889e/ccli-performancecounter-constructor-is-really-slow?forum=vcgeneral).

Sure enough if I hack the Orleans source to use the empty/default constructor then the service does not timeout on that line although I assume we would still eventually run into some kind of timeout once "NextValue" gets called - I haven't mangled my copy of the Orleans Client to test that yet. My hope would be that I can get the service started and whatever failure happens after that would at least get logged.

Is there some way to configure the ClientConfiguration to disable the Performance Counter setup? Windows Performance Counters are notoriously fragile and hard to work with...
</Description>
    <Title_Description>Orleans Client 1.5.2 issue with .NET PerformanceCounter constructor We (@amccool) have a Windows Service that is an Orleans Client. The service startup initializes the Orleans Client and on some VMs this is causing a timeout (from the Service Control Manager) and silent failure - no errors in logs (Orleans/text) no Windows Event other than the usual System one: "A timeout was reached (30000 milliseconds) while waiting for the XXX service to connect".

The program never has this issue when you run it on a command line it only fails like this as a service. The service is running as "SYSTEM" but changing the "Log On" has no effect . The program does not have this problem on every VM nor on my development machine.

I tracked the error down to the class RuntimeStatisticsGroup and its InitCpuMemoryCounters method. This line:
`cpuCounterPF = new PerformanceCounter("Processor" "% Processor Time" "_Total" true);`
Orleans 1.5.2 sources [HERE](https://github.com/dotnet/orleans/blob/d5ea8dc4e0ef104562a05fe05ce9a3abb181c271/src/Orleans/Statistics/RuntimeStatisticsGroup.cs#L89).
_sometimes_ does not return within 30 seconds; pretty much ever-other-time I start the service about 50% of the time.

I found this related issue on [MSDN](https://social.msdn.microsoft.com/Forums/en-US/cd6adebf-231d-40a8-842f-ba06e849889e/ccli-performancecounter-constructor-is-really-slow?forum=vcgeneral).

Sure enough if I hack the Orleans source to use the empty/default constructor then the service does not timeout on that line although I assume we would still eventually run into some kind of timeout once "NextValue" gets called - I haven't mangled my copy of the Orleans Client to test that yet. My hope would be that I can get the service started and whatever failure happens after that would at least get logged.

Is there some way to configure the ClientConfiguration to disable the Performance Counter setup? Windows Performance Counters are notoriously fragile and hard to work with...
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4636</IssueLabelID>
    <Title>[Migration from 1.4.2 to 2.0] Could there be incompatibility issues during deployment when upgrade is taking place?</Title>
    <Description>We are currently using Orleans 1.4.2 and upgrading the solution to Orleans 2.0.0. Ours is an Azure Cloud Service with multiple client and Silo instances.
When we will be deploying the latest build with upgraded version of Orleans there could be some instances still up and working on Orleans 1.4.2 while others on 2.0.0. The concern is the potential incompatibility between these instances (could be because of a change in wire protocol or something else). It would be great if you can help in highlighting any such potential incompatibility and possible workarounds.

Thanks</Description>
    <Title_Description>[Migration from 1.4.2 to 2.0] Could there be incompatibility issues during deployment when upgrade is taking place? We are currently using Orleans 1.4.2 and upgrading the solution to Orleans 2.0.0. Ours is an Azure Cloud Service with multiple client and Silo instances.
When we will be deploying the latest build with upgraded version of Orleans there could be some instances still up and working on Orleans 1.4.2 while others on 2.0.0. The concern is the potential incompatibility between these instances (could be because of a change in wire protocol or something else). It would be great if you can help in highlighting any such potential incompatibility and possible workarounds.

Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4635</IssueLabelID>
    <Title>AlwaysInterleave mode request timeout?</Title>
    <Description>This problem occurs when traffic suddenly rises，All requested Grain PrimaryKeys are the same.

Interface：
```
        [AlwaysInterleave]
        Task&lt;TState&gt; ReadAsync();
```
Implement：
```
        public Task&lt;TState&gt; ReadAsync()
        {
            return Task.FromResult(base.State);
        }
```


Error log:

`
018-05-29 13:30:35.746 +08:00 [fail] Zop.Exceptions.OrleansExceptionsFiltered[0]:
 OrderService
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: 
IsAlwaysInterleave Request S127.0.0.1:33333:265198457*grn/99927672/40821000@c8dbbd98-&gt;S127.0.0.1:33333:265198457*grn/9392906E/00002712@4a585d85 #1000057: . Target History is: &lt;S127.0.0.1:33333:265198457:*grn/9392906E/00002712:@4a585d85&gt;.
`</Description>
    <Title_Description>AlwaysInterleave mode request timeout? This problem occurs when traffic suddenly rises，All requested Grain PrimaryKeys are the same.

Interface：
```
        [AlwaysInterleave]
        Task&lt;TState&gt; ReadAsync();
```
Implement：
```
        public Task&lt;TState&gt; ReadAsync()
        {
            return Task.FromResult(base.State);
        }
```


Error log:

`
018-05-29 13:30:35.746 +08:00 [fail] Zop.Exceptions.OrleansExceptionsFiltered[0]:
 OrderService
System.TimeoutException: Response did not arrive on time in 00:00:30 for message: 
IsAlwaysInterleave Request S127.0.0.1:33333:265198457*grn/99927672/40821000@c8dbbd98-&gt;S127.0.0.1:33333:265198457*grn/9392906E/00002712@4a585d85 #1000057: . Target History is: &lt;S127.0.0.1:33333:265198457:*grn/9392906E/00002712:@4a585d85&gt;.
`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4634</IssueLabelID>
    <Title>how do build distrubuted base on orleans framewrok</Title>
    <Description>
    </Description>
    <Title_Description>how do build distrubuted base on orleans framewrok </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/05/2018 4:35:38 AM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 6:03:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4630</IssueLabelID>
    <Title>Silo Dead</Title>
    <Description>In a two silos cluster we got the following in the log of one of them
[2018-05-26 22:14:34.069 GMT    44	WARNING	100150	Watchdog	10.1.0.6:22222]	.NET Runtime Platform stalled for 00:00:02.3323971 - possibly GC? We are now using total of 487MB memory. gc=330899 131795 2104	
after that with about three minutes the silo failed.
this is a log of this silo

[----APP-01-2018-05-24-11.39.24.307Z.zip](https://github.com/dotnet/orleans/files/2042566/----APP-01-2018-05-24-11.39.24.307Z.zip)

the other silo log is
[APP-01-2018-05-24-11.39.29.339Z.zip](https://github.com/dotnet/orleans/files/2042568/APP-01-2018-05-24-11.39.29.339Z.zip)

</Description>
    <Title_Description>Silo Dead In a two silos cluster we got the following in the log of one of them
[2018-05-26 22:14:34.069 GMT    44	WARNING	100150	Watchdog	10.1.0.6:22222]	.NET Runtime Platform stalled for 00:00:02.3323971 - possibly GC? We are now using total of 487MB memory. gc=330899 131795 2104	
after that with about three minutes the silo failed.
this is a log of this silo

[----APP-01-2018-05-24-11.39.24.307Z.zip](https://github.com/dotnet/orleans/files/2042566/----APP-01-2018-05-24-11.39.24.307Z.zip)

the other silo log is
[APP-01-2018-05-24-11.39.29.339Z.zip](https://github.com/dotnet/orleans/files/2042568/APP-01-2018-05-24-11.39.29.339Z.zip)

</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/05/2018 11:36:14 AM +00:00</CreatedAt>
    <ClosedAt>8/06/2018 7:53:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4629</IssueLabelID>
    <Title>Optimize removing consumed buffers from read buffer</Title>
    <Description>Remove O(n^2) buffer cleanup logic.</Description>
    <Title_Description>Optimize removing consumed buffers from read buffer Remove O(n^2) buffer cleanup logic.</Title_Description>
    <Label>performance</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4628</IssueLabelID>
    <Title>Cleanup pass on Transaction abstractions and public surface.</Title>
    <Description>- Removed leftover code from singleton TM.
- Moves agent abtraction from core to runtime abstractions
- Cleaned up agent initialization and usage pattern
- Reduced public surface of transactional state abstraction
- Moved transaction info out of abstractions
- Removed old unsused logging errorcodes.
- Moved serialization generation assembly statements to files that defined the serializable classes.</Description>
    <Title_Description>Cleanup pass on Transaction abstractions and public surface. - Removed leftover code from singleton TM.
- Moves agent abtraction from core to runtime abstractions
- Cleaned up agent initialization and usage pattern
- Reduced public surface of transactional state abstraction
- Moved transaction info out of abstractions
- Removed old unsused logging errorcodes.
- Moved serialization generation assembly statements to files that defined the serializable classes.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4625</IssueLabelID>
    <Title>Orleans Documentation Tech Writer</Title>
    <Description>Hi! My name is Jill Headen and I've been brought onto the Orleans team at Microsoft to improve the documentation for this project. I thought I'd start out by asking you what you want. Please feel free to send me suggestions ideas links etc. 
I'm in the process of setting up my development environment and getting some hands-on experience with Orleans so if you have tips for me about that please let me know. 

Update:
As I work through the Documentation-tagged issues I am going to compile general reminders for myself here such as:

- add "last edited: 5 June 2018" information to the bottom of my edited pages.
</Description>
    <Title_Description>Orleans Documentation Tech Writer Hi! My name is Jill Headen and I've been brought onto the Orleans team at Microsoft to improve the documentation for this project. I thought I'd start out by asking you what you want. Please feel free to send me suggestions ideas links etc. 
I'm in the process of setting up my development environment and getting some hands-on experience with Orleans so if you have tips for me about that please let me know. 

Update:
As I work through the Documentation-tagged issues I am going to compile general reminders for myself here such as:

- add "last edited: 5 June 2018" information to the bottom of my edited pages.
</Title_Description>
    <Label>documentation</Label>
    <Assignee>JillHeaden</Assignee>
    <CreatedAt>24/05/2018 3:48:33 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4624</IssueLabelID>
    <Title>environment connections</Title>
    <Description>server
   var siloPort = 20028;
            int gatewayPort = 30020;
            var siloAddress = IPAddress.Parse("0.0.0.0");// IPAddress.Loopback;
            var builder = new SiloHostBuilder()
                .UseEnvironment("Development")
                 .Configure&lt;ClusterOptions&gt;(options =&gt;
                 {
                     options.ClusterId = "test1";
                     options.ServiceId = "test1";
                 })
                .UseDevelopmentClustering(options =&gt; options.PrimarySiloEndpoint = new IPEndPoint(siloAddress siloPort))
                .ConfigureEndpoints(siloAddress siloPort gatewayPort)
                 .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(Test).Assembly).WithReferences());

client 
   var siloAddress = "127.0.0.1"; //IPAddress.Loopback; 
                    var gatewayPort = 30020;
                    var uri = (new IPEndPoint(IPAddress.Parse(siloAddress) gatewayPort)).ToGatewayUri();
                    client = new ClientBuilder()
                        .ConfigureDefaults()
                       // .UseLocalhostClustering(gatewayPort)
                       .Configure&lt;ClusterOptions&gt;(opt =&gt;
                       {
                           opt.ClusterId = "test1";
                           opt.ServiceId = "test1";
                       })
                        ////集群
                        .UseStaticClustering(options =&gt; options.Gateways.Add(uri))//集群  
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITest).Assembly).WithReferences())

server
 var siloAddress = IPAddress.Parse("0.0.0.0");      Can connect but cannot get information
 var siloAddress=IPAddress.Loopback;     Cannot connect service Should be server port listening failed

can you tell me the reason？
I want to test the deployment of the production environment，A silo A client silo is deployed on the server，Local test is normal access

</Description>
    <Title_Description>environment connections server
   var siloPort = 20028;
            int gatewayPort = 30020;
            var siloAddress = IPAddress.Parse("0.0.0.0");// IPAddress.Loopback;
            var builder = new SiloHostBuilder()
                .UseEnvironment("Development")
                 .Configure&lt;ClusterOptions&gt;(options =&gt;
                 {
                     options.ClusterId = "test1";
                     options.ServiceId = "test1";
                 })
                .UseDevelopmentClustering(options =&gt; options.PrimarySiloEndpoint = new IPEndPoint(siloAddress siloPort))
                .ConfigureEndpoints(siloAddress siloPort gatewayPort)
                 .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(Test).Assembly).WithReferences());

client 
   var siloAddress = "127.0.0.1"; //IPAddress.Loopback; 
                    var gatewayPort = 30020;
                    var uri = (new IPEndPoint(IPAddress.Parse(siloAddress) gatewayPort)).ToGatewayUri();
                    client = new ClientBuilder()
                        .ConfigureDefaults()
                       // .UseLocalhostClustering(gatewayPort)
                       .Configure&lt;ClusterOptions&gt;(opt =&gt;
                       {
                           opt.ClusterId = "test1";
                           opt.ServiceId = "test1";
                       })
                        ////集群
                        .UseStaticClustering(options =&gt; options.Gateways.Add(uri))//集群  
                        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ITest).Assembly).WithReferences())

server
 var siloAddress = IPAddress.Parse("0.0.0.0");      Can connect but cannot get information
 var siloAddress=IPAddress.Loopback;     Cannot connect service Should be server port listening failed

can you tell me the reason？
I want to test the deployment of the production environment，A silo A client silo is deployed on the server，Local test is normal access

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4622</IssueLabelID>
    <Title>SiloHost ResponseTimeout won't let me change it from 30 seconds</Title>
    <Description>We have some grain methods that take longer than 30 seconds to execute so I am trying to set the response timeout to 2 minutes. I set it on the config.Globals.ResponseTimeout and pass that config object to the SiloHost and then call InitializeOrleansSilo(). Which runs and resets the ResponseTimeout back to 30 seconds.

We've tried setting it in our config.xml file as well to no avail. What am I doing wrong here?</Description>
    <Title_Description>SiloHost ResponseTimeout won't let me change it from 30 seconds We have some grain methods that take longer than 30 seconds to execute so I am trying to set the response timeout to 2 minutes. I set it on the config.Globals.ResponseTimeout and pass that config object to the SiloHost and then call InitializeOrleansSilo(). Which runs and resets the ResponseTimeout back to 30 seconds.

We've tried setting it in our config.xml file as well to no avail. What am I doing wrong here?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4621</IssueLabelID>
    <Title>Stream data adapter</Title>
    <Description>Custom handling of the conversion of application data to and from the underlying queue is a common concern for users of  Orleans persistent streams.  There are many reasons for this:

* The default conversion logic does not handle schema changes for event data or changes to the Orleans data structures so if an application alters the contents of the persisted events or the Orleans team changes how the events are wrapped the old events will become unreadable.
* Without changes to the conversion application developers cannot read/process events using streaming for pre-existing queues or data written to queues by other processes.
* Without changes to the conversion application developers cannot write events in formats suitable for pre-existing systems or external consumers.

Some stream providers like azure queue memory and eventhub provide some support for custom data conversion but there is no common pattern and some patterns are quite painful.

Given that **_every_** internal service using Orleans persistent streams has had to customize their handling of queue data for one of the above reasons and in every case it’s made the use of Orleans persistent stream significantly more complicated I am of the opinion that addressing this should be a fairly high priority.</Description>
    <Title_Description>Stream data adapter Custom handling of the conversion of application data to and from the underlying queue is a common concern for users of  Orleans persistent streams.  There are many reasons for this:

* The default conversion logic does not handle schema changes for event data or changes to the Orleans data structures so if an application alters the contents of the persisted events or the Orleans team changes how the events are wrapped the old events will become unreadable.
* Without changes to the conversion application developers cannot read/process events using streaming for pre-existing queues or data written to queues by other processes.
* Without changes to the conversion application developers cannot write events in formats suitable for pre-existing systems or external consumers.

Some stream providers like azure queue memory and eventhub provide some support for custom data conversion but there is no common pattern and some patterns are quite painful.

Given that **_every_** internal service using Orleans persistent streams has had to customize their handling of queue data for one of the above reasons and in every case it’s made the use of Orleans persistent stream significantly more complicated I am of the opinion that addressing this should be a fairly high priority.</Title_Description>
    <Label>P2</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4620</IssueLabelID>
    <Title>Error when client tries to communicate with silo: Gateway received unexpected non-proxied connection</Title>
    <Description>Please see this repo that should help replicate the issue. The README should explain the issue and reproduction steps in detail:

https://github.com/petargyurov/orleans-gateway-issue/tree/master

There has been some discussion on Gitter with @benjaminpetit already.


Thanks.</Description>
    <Title_Description>Error when client tries to communicate with silo: Gateway received unexpected non-proxied connection Please see this repo that should help replicate the issue. The README should explain the issue and reproduction steps in detail:

https://github.com/petargyurov/orleans-gateway-issue/tree/master

There has been some discussion on Gitter with @benjaminpetit already.


Thanks.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4618</IssueLabelID>
    <Title>Skip TransactionWillRecoverAfterRandomSiloUnGracefulShutdown (see #4617)</Title>
    <Description>I see this failing a lot in VSO</Description>
    <Title_Description>Skip TransactionWillRecoverAfterRandomSiloUnGracefulShutdown (see #4617) I see this failing a lot in VSO</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4617</IssueLabelID>
    <Title>[Test] TransactionWillRecoverAfterRandomSiloUnGracefulShutdown fails frequently</Title>
    <Description>
    </Description>
    <Title_Description>[Test] TransactionWillRecoverAfterRandomSiloUnGracefulShutdown fails frequently </Title_Description>
    <Label>P1</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4614</IssueLabelID>
    <Title>Added correctness checks to recovery testing</Title>
    <Description>
    </Description>
    <Title_Description>Added correctness checks to recovery testing </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4612</IssueLabelID>
    <Title>WriteStateAsync() works a lot slower since upgrading to Orleans2</Title>
    <Description>Since upgrading to Orleans2 we have had general slowness in writing grain state. We tried to pin down the issue and we gauged the time it took for us to write jsons of about 1mb each to azure blob storage and the mean went up from about 100ms to 400ms in peak times. 
We looked in the blob storage to see if the data got any larger but it was about the same size (1mb).
We suspected the upgrade to orleans2 to be the cause and when we downgraded back to orleans1 the write time got back to normal (this was the only change we made) so if the cause was something else the downgrade should not have effected this.

This is the graph of the `writeStateAsync()` time from one of our grains "expert-grain":
![screen shot 2018-05-20 at 15 11 21](https://user-images.githubusercontent.com/10612685/40278772-1790bb16-5c40-11e8-902e-57e1159c0be7.png)


We noticed that after restarting the nodes the write time goes down for a few hours before going up again (we used a script to restart the nodes every 4 hours for that reason).

Any suggestions to how we can investigate this further?</Description>
    <Title_Description>WriteStateAsync() works a lot slower since upgrading to Orleans2 Since upgrading to Orleans2 we have had general slowness in writing grain state. We tried to pin down the issue and we gauged the time it took for us to write jsons of about 1mb each to azure blob storage and the mean went up from about 100ms to 400ms in peak times. 
We looked in the blob storage to see if the data got any larger but it was about the same size (1mb).
We suspected the upgrade to orleans2 to be the cause and when we downgraded back to orleans1 the write time got back to normal (this was the only change we made) so if the cause was something else the downgrade should not have effected this.

This is the graph of the `writeStateAsync()` time from one of our grains "expert-grain":
![screen shot 2018-05-20 at 15 11 21](https://user-images.githubusercontent.com/10612685/40278772-1790bb16-5c40-11e8-902e-57e1159c0be7.png)


We noticed that after restarting the nodes the write time goes down for a few hours before going up again (we used a script to restart the nodes every 4 hours for that reason).

Any suggestions to how we can investigate this further?</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4611</IssueLabelID>
    <Title>How to deploy Orleans client and silos to SF as containers?</Title>
    <Description>How to deploy Orleans client and silos to SF as containers?
The question is how to configure the cluster and gateway settings?
I haven't find any sample. 

Thanks</Description>
    <Title_Description>How to deploy Orleans client and silos to SF as containers? How to deploy Orleans client and silos to SF as containers?
The question is how to configure the cluster and gateway settings?
I haven't find any sample. 

Thanks</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4610</IssueLabelID>
    <Title>memory consumption non equal</Title>
    <Description>i have two silos running on the same machine with sql membership database one of the two silos is consuming more memory  than the other(14 g and .9 g)
while the grains are balanced nearly equal 
is there some silo responsible for some function that i do not know about ?
i know there is no primary concept in case of membership database.
why is this happening ?

</Description>
    <Title_Description>memory consumption non equal i have two silos running on the same machine with sql membership database one of the two silos is consuming more memory  than the other(14 g and .9 g)
while the grains are balanced nearly equal 
is there some silo responsible for some function that i do not know about ?
i know there is no primary concept in case of membership database.
why is this happening ?

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4607</IssueLabelID>
    <Title>SerializationManager measures ticks not milliseconds</Title>
    <Description>The serialization manager measures the ticks: https://github.com/dotnet/orleans/blob/e87f0e458d36dccf145de06295475831331ff0bf/src/Orleans.Core/Serialization/SerializationManager.cs#L609

But the counter says: Serialization.Body.DeepCopy.Milliseconds.Current
</Description>
    <Title_Description>SerializationManager measures ticks, not milliseconds The serialization manager measures the ticks: https://github.com/dotnet/orleans/blob/e87f0e458d36dccf145de06295475831331ff0bf/src/Orleans.Core/Serialization/SerializationManager.cs#L609

But the counter says: Serialization.Body.DeepCopy.Milliseconds.Current
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4604</IssueLabelID>
    <Title>Cluster-to-Cluster communication extensibility</Title>
    <Description>I want to use Orleans Multi-cluster feature but I am hitting a road block.  I want to build a primary and failover cluster and use event sourcing to synchronize the cluster.  The problem is that I cannot set up a VPN between the two cluster.  Being able to synchronized clusters without an exposed gateway is a very valid and important scenario.

I was trying to figure out if I can extend and plug in an alternate ILogConsistencyProtocolGateway which will make calls to the other cluster through [Service Bus relays](https://docs.microsoft.com/en-us/azure/service-bus-relay/relay-hybrid-connections-http-requests-dotnet-get-started).  I difficulty because some interfaces are internal only.

What I am looking for is to be able to write implementations for the interfaces below and override the default implementation.  This was I can use other technologies proxy or relay the calls into the remote cluster.

```
    public interface IClusterMessageForwarder
    {
        Task&lt;ILogConsistencyProtocolMessage&gt; ForwardMessageToCluster(string clusterId string grainId ILogConsistencyProtocolMessage payload);
    }
```
```
    public interface IClusterMessageReceiver
    {
        Task&lt;ILogConsistencyProtocolMessage&gt; ReceiveMessage(string grainIdStr ILogConsistencyProtocolMessage payload);
    }
```

</Description>
    <Title_Description>Cluster-to-Cluster communication extensibility I want to use Orleans Multi-cluster feature but I am hitting a road block.  I want to build a primary and failover cluster and use event sourcing to synchronize the cluster.  The problem is that I cannot set up a VPN between the two cluster.  Being able to synchronized clusters without an exposed gateway is a very valid and important scenario.

I was trying to figure out if I can extend and plug in an alternate ILogConsistencyProtocolGateway which will make calls to the other cluster through [Service Bus relays](https://docs.microsoft.com/en-us/azure/service-bus-relay/relay-hybrid-connections-http-requests-dotnet-get-started).  I difficulty because some interfaces are internal only.

What I am looking for is to be able to write implementations for the interfaces below and override the default implementation.  This was I can use other technologies proxy or relay the calls into the remote cluster.

```
    public interface IClusterMessageForwarder
    {
        Task&lt;ILogConsistencyProtocolMessage&gt; ForwardMessageToCluster(string clusterId string grainId ILogConsistencyProtocolMessage payload);
    }
```
```
    public interface IClusterMessageReceiver
    {
        Task&lt;ILogConsistencyProtocolMessage&gt; ReceiveMessage(string grainIdStr ILogConsistencyProtocolMessage payload);
    }
```

</Title_Description>
    <Label>enhancement</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4603</IssueLabelID>
    <Title>Test MetaData can be (de)serialzied</Title>
    <Description>
    </Description>
    <Title_Description>Test MetaData can be (de)serialzied </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4602</IssueLabelID>
    <Title>Enable tx recovery tests</Title>
    <Description>I forgot to enable these tests..</Description>
    <Title_Description>Enable tx recovery tests I forgot to enable these tests..</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4601</IssueLabelID>
    <Title>NuGet Client and Server Collections not updated with 2.0.3 release</Title>
    <Description>The 2.0.3 release was a patch update that published updated packages for the code generator and runtime/core. If the Microsoft.Orleans.Server and/or Microsoft.Orleans.Client collections are used to provide the runtime then the code generator is updated but the runtime is not.

Behavior: When updating to the latest versions a mismatch is created and attempting to run with the two different versions causes an exception to be thrown:
`System.AggregateException: 'One or more errors occurred. (Field not found: 'Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured'.)'` with code that works fine with the 2.0.0 generator.

Expected: Server and Client collections should be updated anytime a "child" package is updated</Description>
    <Title_Description>NuGet Client and Server Collections not updated with 2.0.3 release The 2.0.3 release was a patch update that published updated packages for the code generator and runtime/core. If the Microsoft.Orleans.Server and/or Microsoft.Orleans.Client collections are used to provide the runtime then the code generator is updated but the runtime is not.

Behavior: When updating to the latest versions a mismatch is created and attempting to run with the two different versions causes an exception to be thrown:
`System.AggregateException: 'One or more errors occurred. (Field not found: 'Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured'.)'` with code that works fine with the 2.0.0 generator.

Expected: Server and Client collections should be updated anytime a "child" package is updated</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4600</IssueLabelID>
    <Title>Grain activation</Title>
    <Description>Hello
Few queries on grain activation:

1) Lets assume we have an application deployed in a cluster of three silos. Client connected to a silo and have grain activation with it. And now if that silo goes down for some reason does orleans framework create entirely new grain activation in other silo? Will grain have new primary key?
2) I have been experimenting explict stream subscription with RabbitMQ. 

	And my application looke likes this:
	**SILOHOST** 

			1.  CommandBusGrain 	
                             1.  OnactivateAsync creates a stream (stream id: GUID.Empty)
                             2.  Register method does subscription to the stream
                             3.  Send method publish message to stream (that is _stream.OnNextAsync(msg))
			2.  On silo startup
                             1.  calls CommandBusGrain register method to initiate subscription
			
			
    **SILO Client**

			1.  Create CommandBusGrain reference (Graind id: GUID.Empty)
			2.  Triggers "Send" method to publish message.

		
     This works fine but I need some suggestion on whether to call grain method to publish message to 
     the stream or create stream reference in the client and publish message directly to stream instead of 
     calling grain.
     Which one would be a better implementation?</Description>
    <Title_Description>Grain activation Hello
Few queries on grain activation:

1) Lets assume we have an application deployed in a cluster of three silos. Client connected to a silo and have grain activation with it. And now if that silo goes down for some reason does orleans framework create entirely new grain activation in other silo? Will grain have new primary key?
2) I have been experimenting explict stream subscription with RabbitMQ. 

	And my application looke likes this:
	**SILOHOST** 

			1.  CommandBusGrain 	
                             1.  OnactivateAsync creates a stream (stream id: GUID.Empty)
                             2.  Register method does subscription to the stream
                             3.  Send method publish message to stream (that is _stream.OnNextAsync(msg))
			2.  On silo startup
                             1.  calls CommandBusGrain register method to initiate subscription
			
			
    **SILO Client**

			1.  Create CommandBusGrain reference (Graind id: GUID.Empty)
			2.  Triggers "Send" method to publish message.

		
     This works fine but I need some suggestion on whether to call grain method to publish message to 
     the stream or create stream reference in the client and publish message directly to stream instead of 
     calling grain.
     Which one would be a better implementation?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/05/2018 4:23:26 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 4:17:03 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4598</IssueLabelID>
    <Title>Fix bug where Issue is never assigned and retry delays never happen</Title>
    <Description>The class is RecordedConnectionIssue never assigns the Issue property which causes DelayBeforeRetry() to never delay.</Description>
    <Title_Description>Fix bug where Issue is never assigned and retry delays never happen The class is RecordedConnectionIssue never assigns the Issue property which causes DelayBeforeRetry() to never delay.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4596</IssueLabelID>
    <Title>Remove unused tx metrics</Title>
    <Description>TransactionsStatisticsGroup.cs  was used by single TM and is currently not used in the system. delete to clean the code base up </Description>
    <Title_Description>Remove unused tx metrics TransactionsStatisticsGroup.cs  was used by single TM and is currently not used in the system. delete to clean the code base up </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4595</IssueLabelID>
    <Title>Transaction concurrency tests</Title>
    <Description>- failing against memory storage unclear why.  Tests disabled will open bug</Description>
    <Title_Description>Transaction concurrency tests - failing against memory storage unclear why.  Tests disabled will open bug</Title_Description>
    <Label>testing</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4594</IssueLabelID>
    <Title>EHStatistics_MonitorCalledAccordingly intermitently failing</Title>
    <Description>ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.EHStatistics_MonitorCalledAccordingly fails intermittently.

Stacktrace
MESSAGE:
Assert.True() Failure\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.AssertCacheMonitorCallCounters(CacheMonitorCounters totalCacheMonitorCallCounters) in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 118 at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.&lt;EHStatistics_MonitorCalledAccordingly&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 103 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>EHStatistics_MonitorCalledAccordingly intermitently failing ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.EHStatistics_MonitorCalledAccordingly fails intermittently.

Stacktrace
MESSAGE:
Assert.True() Failure\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.AssertCacheMonitorCallCounters(CacheMonitorCounters totalCacheMonitorCallCounters) in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 118 at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.&lt;EHStatistics_MonitorCalledAccordingly&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 103 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>15/05/2018 2:40:39 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4593</IssueLabelID>
    <Title>Unexpected token '100' introducing type specifier</Title>
    <Description>We're getting strange error from our web app that uses Orleans.Client. The strange thing is that app works it calls Orleans cluster and gets response but spikes to ~50% cpu every 5 minutes and writes this error to log every second or so.
```
Unable to connect to silo "System.Runtime.Serialization.SerializationException: Unexpected token '100' introducing type specifier
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t BinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReference.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__65.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__64.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.ClusterClient.&lt;Connect&gt;d__24.MoveNext()
```</Description>
    <Title_Description>Unexpected token '100' introducing type specifier We're getting strange error from our web app that uses Orleans.Client. The strange thing is that app works it calls Orleans cluster and gets response but spikes to ~50% cpu every 5 minutes and writes this error to log every second or so.
```
Unable to connect to silo "System.Runtime.Serialization.SerializationException: Unexpected token '100' introducing type specifier
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t BinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReference.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__65.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__64.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.ClusterClient.&lt;Connect&gt;d__24.MoveNext()
```</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4592</IssueLabelID>
    <Title>Fix tx recovery test intermittent failure</Title>
    <Description>- removed unused testing method for old singleTM
- change stop silo method from ungracefully shutdown to gracefully shutdown. Recovery tests was failed before because silos are shutdown ungracefully and alive silos somehow still keep sending those requests to the dead silo and get time out exception back. So I think it is failing because clustering isn't recovering from ungracefully shutdown instead of tx isn't recovering. So to tests tx recovery in a clean box I think shutdown silo gracefully is the right way. In this way tx will be the only one which need to recovery the test won't be testing clustering recovery. </Description>
    <Title_Description>Fix tx recovery test intermittent failure - removed unused testing method for old singleTM
- change stop silo method from ungracefully shutdown to gracefully shutdown. Recovery tests was failed before because silos are shutdown ungracefully and alive silos somehow still keep sending those requests to the dead silo and get time out exception back. So I think it is failing because clustering isn't recovering from ungracefully shutdown instead of tx isn't recovering. So to tests tx recovery in a clean box I think shutdown silo gracefully is the right way. In this way tx will be the only one which need to recovery the test won't be testing clustering recovery. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4591</IssueLabelID>
    <Title>Generate correct serializer for TransactionParticipantExtensionWrapper</Title>
    <Description>TransactionParticipantExtensionWrapper is serialized as part of StorageBatch Metadata need to generate correct serializer for it otherwise gets serialization exception when trying to (de)serialization StorageBatch Metadata</Description>
    <Title_Description>Generate correct serializer for TransactionParticipantExtensionWrapper TransactionParticipantExtensionWrapper is serialized as part of StorageBatch Metadata need to generate correct serializer for it otherwise gets serialization exception when trying to (de)serialization StorageBatch Metadata</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4589</IssueLabelID>
    <Title>Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured</Title>
    <Description>Hi

When I was trying using local development configuration to set up a server I got an error `Field not found: 'Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured'`. It is very strange because I did set ClusterId both in `UseLocalhostClustering` and `Configure&lt;ClusterOptions&gt;`. 

Here is my server main code

```csharp
       static async Task Main(string[] args)
        {
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            ISiloHostBuilder siloBuilder = new SiloHostBuilder()
                .UseLocalhostClustering(clusterId: "tpdt-dev")
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "HelloWorldApp";
                })
                .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
                .ConfigureLogging(
                    logging =&gt; logging.AddConsole());
            ISiloHost silo = siloBuilder.Build();
            await silo.StartAsync();

            Console.WriteLine("Press Enter to close.");
            // wait here
            Console.ReadLine();

            // shut the silo down after we are done.
            await silo.StopAsync();
        }
```

And the sentry exception log is https://sentry.io/share/issue/d4d5026ae2ca44f29528d1b3d784f763/ .

Thank you.</Description>
    <Title_Description>Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured Hi

When I was trying using local development configuration to set up a server I got an error `Field not found: 'Orleans.Configuration.Validators.ClientClusteringValidator.ClusterIdNotConfigured'`. It is very strange because I did set ClusterId both in `UseLocalhostClustering` and `Configure&lt;ClusterOptions&gt;`. 

Here is my server main code

```csharp
       static async Task Main(string[] args)
        {
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            ISiloHostBuilder siloBuilder = new SiloHostBuilder()
                .UseLocalhostClustering(clusterId: "tpdt-dev")
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "dev";
                    options.ServiceId = "HelloWorldApp";
                })
                .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
                .ConfigureLogging(
                    logging =&gt; logging.AddConsole());
            ISiloHost silo = siloBuilder.Build();
            await silo.StartAsync();

            Console.WriteLine("Press Enter to close.");
            // wait here
            Console.ReadLine();

            // shut the silo down after we are done.
            await silo.StopAsync();
        }
```

And the sentry exception log is https://sentry.io/share/issue/d4d5026ae2ca44f29528d1b3d784f763/ .

Thank you.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4588</IssueLabelID>
    <Title>Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0?</Title>
    <Description>Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0?

It is available for v2.0.0-rc2 but not v2.0.0.</Description>
    <Title_Description>Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0? Why is Microsoft.Orleans.Clustering.ServiceFabric not available for v2.0.0?

It is available for v2.0.0-rc2 but not v2.0.0.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4585</IssueLabelID>
    <Title>code generation fails with dotnet 2.1 rc1</Title>
    <Description>This is a console app. 

Orleans-CodeGen - Generating file C:\Games\aigame\Game\Server\obj\Debug\netcoreapp2.1\Server.orleans.g.cs
1&gt;-- Code Generation FAILED --
1&gt;
1&gt;Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
1&gt;   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
1&gt;   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
1&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
1&gt;   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
1&gt;   at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
1&gt;   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
1&gt;   at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\AssemblyAttributeFeatureProvider.cs:line 41
1&gt;   at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManager.cs:line 49
1&gt;   at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManagerExtensions.cs:line 60
1&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator..ctor(IApplicationPartManager partManager ILoggerFactory loggerFactory) in D:\build\agent\_work\18\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 43
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
1&gt;C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(765): error MSB3073: The command ""dotnet" "C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netcoreapp2.1\codegen\Server.orleans.g.args.txt"" exited with code 3.
1&gt;Done building project "Server.csproj" -- FAILED.</Description>
    <Title_Description>code generation fails with dotnet 2.1 rc1 This is a console app. 

Orleans-CodeGen - Generating file C:\Games\aigame\Game\Server\obj\Debug\netcoreapp2.1\Server.orleans.g.cs
1&gt;-- Code Generation FAILED --
1&gt;
1&gt;Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime Version=4.2.1.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
1&gt;   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
1&gt;   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
1&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
1&gt;   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly RuntimeType caType)
1&gt;   at System.Attribute.GetCustomAttributes(Assembly element Type attributeType Boolean inherit)
1&gt;   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
1&gt;   at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\AssemblyAttributeFeatureProvider.cs:line 41
1&gt;   at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManager.cs:line 49
1&gt;   at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManagerExtensions.cs:line 60
1&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator..ctor(IApplicationPartManager partManager ILoggerFactory loggerFactory) in D:\build\agent\_work\18\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 43
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
1&gt;C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(765): error MSB3073: The command ""dotnet" "C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netcoreapp2.1\codegen\Server.orleans.g.args.txt"" exited with code 3.
1&gt;Done building project "Server.csproj" -- FAILED.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4584</IssueLabelID>
    <Title>Microsoft.Orleans.OrleansCodeGenerator.Build and IntelliSense</Title>
    <Description>Hello.

I want to show the problem by an example because it is difficult for me to describe it.

In the project I created the MyGrain class and the interface IMyGrain MyGrain (heir Grain) and when I write the code the studio tells me where I made a mistake (ctrl+. "Quick actions and refactorings") but as soon as I install the package Microsoft.Orleans.OrleansCodeGenerator.Build all the hints disappear and "quick actions and refactorings" does not work. 
All hints related to the work of the text analyzer (code) in the visual studio are lost.

Here is a link to the project where you can check it by simply running commands:
[https://github.com/amarf/OrleansBug]()
**install-package Microsoft.Orleans.OrleansCodeGenerator.Build
uninstall-package Microsoft.Orleans.OrleansCodeGenerator.Build**

PS. After executing the uninstall-package command the studio is working normally</Description>
    <Title_Description>Microsoft.Orleans.OrleansCodeGenerator.Build and IntelliSense Hello.

I want to show the problem by an example because it is difficult for me to describe it.

In the project I created the MyGrain class and the interface IMyGrain MyGrain (heir Grain) and when I write the code the studio tells me where I made a mistake (ctrl+. "Quick actions and refactorings") but as soon as I install the package Microsoft.Orleans.OrleansCodeGenerator.Build all the hints disappear and "quick actions and refactorings" does not work. 
All hints related to the work of the text analyzer (code) in the visual studio are lost.

Here is a link to the project where you can check it by simply running commands:
[https://github.com/amarf/OrleansBug]()
**install-package Microsoft.Orleans.OrleansCodeGenerator.Build
uninstall-package Microsoft.Orleans.OrleansCodeGenerator.Build**

PS. After executing the uninstall-package command the studio is working normally</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4583</IssueLabelID>
    <Title>Azure transaction benchmark</Title>
    <Description>Added transaction benchmark that runs against azure storage.
Fixed bugs in transaction bentchmark.</Description>
    <Title_Description>Azure transaction benchmark Added transaction benchmark that runs against azure storage.
Fixed bugs in transaction bentchmark.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4581</IssueLabelID>
    <Title>Clock skew transaction testing</Title>
    <Description>Ensure transaction timestamps work correctly even with clock skew and system time changes.</Description>
    <Title_Description>Clock skew transaction testing Ensure transaction timestamps work correctly even with clock skew and system time changes.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4580</IssueLabelID>
    <Title>Multi tenency DI</Title>
    <Description>We are looking into implementing multi-tenancy with DI do you have any recommendations? Is possible?

What we like to achieve
 
 - Replace some services based on the tenant (which we will handle ofc)
 - When Grain is initiated it will have the specified tenant so constructor injection will work

I just had did this for aspnetcore by using [Grace](https://github.com/ipjohnson/Grace/) (DI container) which supports child containers.

 Basically what I had to do in order to integrate in aspnet is:
 - Implement custom middleware (which most of the time should be one of the first one)
 - Implement some kind of Tenant resolver which in our case would resolve via domain
 - Replace aspnet `HttpContext.RequestService` with the our child container.

As far as i know in Orleans its not possible to implement something as I did in aspnet.</Description>
    <Title_Description>Multi tenency DI We are looking into implementing multi-tenancy with DI do you have any recommendations? Is possible?

What we like to achieve
 
 - Replace some services based on the tenant (which we will handle ofc)
 - When Grain is initiated it will have the specified tenant so constructor injection will work

I just had did this for aspnetcore by using [Grace](https://github.com/ipjohnson/Grace/) (DI container) which supports child containers.

 Basically what I had to do in order to integrate in aspnet is:
 - Implement custom middleware (which most of the time should be one of the first one)
 - Implement some kind of Tenant resolver which in our case would resolve via domain
 - Replace aspnet `HttpContext.RequestService` with the our child container.

As far as i know in Orleans its not possible to implement something as I did in aspnet.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4579</IssueLabelID>
    <Title>Add dependency in nuget package Microsoft.Orleans.OrleansCodeGenerator.Build on Microsoft.Orleans.Core.Abstractions</Title>
    <Description>
    </Description>
    <Title_Description>Add dependency in nuget package Microsoft.Orleans.OrleansCodeGenerator.Build on Microsoft.Orleans.Core.Abstractions </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4577</IssueLabelID>
    <Title>Sanitize "." for Azure Queue name and make Queue name configurable</Title>
    <Description>I'm getting exceptions when project name isn't so long or contains "." for example name is "SiloHost.NetCore".

1. Make Azure Queue name configurable or partially configurable. For example for case when silo host is SF service my queue name is "fabric--distrtestapplication-silohost.netcore-azurequeueprovider-0".  It contains 66 symbols instead of max allowed. I want to remove or configure "fabric--" prefix or something else.

2. Sanitize "." with dash "-" as other symbols in AzureQueueDataManager.SanitizeQueueName.</Description>
    <Title_Description>Sanitize "." for Azure Queue name and make Queue name configurable I'm getting exceptions when project name isn't so long or contains "." for example name is "SiloHost.NetCore".

1. Make Azure Queue name configurable or partially configurable. For example for case when silo host is SF service my queue name is "fabric--distrtestapplication-silohost.netcore-azurequeueprovider-0".  It contains 66 symbols instead of max allowed. I want to remove or configure "fabric--" prefix or something else.

2. Sanitize "." with dash "-" as other symbols in AzureQueueDataManager.SanitizeQueueName.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4576</IssueLabelID>
    <Title>Lots of warnings after using UseAdoNetReminderService</Title>
    <Description>Lots of warnings after using UseAdoNetReminderService，Guess #4505  is related to himdo with him

![image](https://user-images.githubusercontent.com/28291464/39905610-ae8f9744-5510-11e8-8ff9-63eca7bdbcdc.png)
</Description>
    <Title_Description>Lots of warnings after using UseAdoNetReminderService Lots of warnings after using UseAdoNetReminderService，Guess #4505  is related to himdo with him

![image](https://user-images.githubusercontent.com/28291464/39905610-ae8f9744-5510-11e8-8ff9-63eca7bdbcdc.png)
</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>lfzm</Assignee>
    <CreatedAt>11/05/2018 3:45:01 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4575</IssueLabelID>
    <Title>HashBasedPlacement</Title>
    <Description>Hello

Any documentation available on HashBasedPlacement strategy implementation and how it works?

Thanks</Description>
    <Title_Description>HashBasedPlacement Hello

Any documentation available on HashBasedPlacement strategy implementation and how it works?

Thanks</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4573</IssueLabelID>
    <Title>Fix Dependency Injection without changing Abstractions project</Title>
    <Description>
    </Description>
    <Title_Description>Fix Dependency Injection without changing Abstractions project </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4572</IssueLabelID>
    <Title>Using IoT Hub with streams</Title>
    <Description>My goal is to read events from an IoT Hub and process those events in grains. I wasn't able to find docs on this anywhere but would be grateful if someone would point me in the right direction.

I've used the following code to configure the connection to the IoT Hub. I'm using the Event Hub compatible endpoint.

```
.AddEventHubStreams("EventHubProvider" shConfig =&gt;
{
	shConfig.ConfigureEventHub(opts =&gt;
	{
		opts.Configure(options =&gt;
		{
			options.ConnectionString = "Endpoint=event hub compatible endpoint -- &lt;SNIP&gt; --";
			options.ConsumerGroup = "MyConsumerGroup";
			options.Path = "EventHubCompatibleName";
		});
	})
	.UseEventHubCheckpointer(opts =&gt; opts.Configure(options =&gt;
	{
		options.ConnectionString = "DefaultEndpointsProtocol=https;AccountName= -- &lt;SNIP&gt; --"
	}));
});
```

I've created a simple grain and wired it to an implicit stream. However I'm not sure what namespace to use?

`[ImplicitStreamSubscription("WhatShouldThisBe?"]`

When I startup the Silo host Orleans connects and begins reading messages:

```
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.hub-myHub.20[0]
      Starting to read latest messages from EventHub partition hub-myHub-20 at offset 29716696
```

When a message is received an exception is throw in the `EventHubDataAdapter` because partition key is null in the event data:

```
public virtual StreamPosition GetStreamPosition(EventData queueMessage)
        {
            Guid streamGuid =
            Guid.Parse(queueMessage.SystemProperties.PartitionKey); // PartitionKey is null
...
}

```

My intended design is to have a grain per device and have those grains implicitly wired to a stream based on device ID. How should I setup the grain? What does the stream config look like (e.g. namespace and GUID)?

Best
Andrew
</Description>
    <Title_Description>Using IoT Hub with streams My goal is to read events from an IoT Hub and process those events in grains. I wasn't able to find docs on this anywhere but would be grateful if someone would point me in the right direction.

I've used the following code to configure the connection to the IoT Hub. I'm using the Event Hub compatible endpoint.

```
.AddEventHubStreams("EventHubProvider" shConfig =&gt;
{
	shConfig.ConfigureEventHub(opts =&gt;
	{
		opts.Configure(options =&gt;
		{
			options.ConnectionString = "Endpoint=event hub compatible endpoint -- &lt;SNIP&gt; --";
			options.ConsumerGroup = "MyConsumerGroup";
			options.Path = "EventHubCompatibleName";
		});
	})
	.UseEventHubCheckpointer(opts =&gt; opts.Configure(options =&gt;
	{
		options.ConnectionString = "DefaultEndpointsProtocol=https;AccountName= -- &lt;SNIP&gt; --"
	}));
});
```

I've created a simple grain and wired it to an implicit stream. However I'm not sure what namespace to use?

`[ImplicitStreamSubscription("WhatShouldThisBe?"]`

When I startup the Silo host Orleans connects and begins reading messages:

```
info: Orleans.ServiceBus.Providers.EventHubAdapterReceiver.hub-myHub.20[0]
      Starting to read latest messages from EventHub partition hub-myHub-20 at offset 29716696
```

When a message is received an exception is throw in the `EventHubDataAdapter` because partition key is null in the event data:

```
public virtual StreamPosition GetStreamPosition(EventData queueMessage)
        {
            Guid streamGuid =
            Guid.Parse(queueMessage.SystemProperties.PartitionKey); // PartitionKey is null
...
}

```

My intended design is to have a grain per device and have those grains implicitly wired to a stream based on device ID. How should I setup the grain? What does the stream config look like (e.g. namespace and GUID)?

Best
Andrew
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4571</IssueLabelID>
    <Title>[WIP] Implementation of a DynamoDB-based gossip channel</Title>
    <Description>Hi

This is an attempt to bring DynamoDB as a gossip channel.
Still a work-in-progress but I think that some of the main components are now built.

Design is heavily inspired from the already-existing Azure-based gossip channel. I tried to keep the same conventions but feel free to ask me some changes if this does not comply with your dev rules.

Work is not over yet as
- not a single test has been done :)
- I have not yet used DynamoDB before so there may be design errors
- the gossip channel still has to be registered in the MultiClusterGossipChannelFactory

I have made the choice to split data into two different tables: one for the configuration and one for the gateway. This is not the way it has been implemented in the Azure channel but I am not at all familiar with AzureTable.
This may or may be not a good choice feel free to comment

Also a LegacyDynamoDBMembershipConfigurator has been used to parse DynamoDB connection string. I have to so as IGossipChannel's Initialize makes it mandatory. There may be better ways to do that</Description>
    <Title_Description>[WIP] Implementation of a DynamoDB-based gossip channel Hi

This is an attempt to bring DynamoDB as a gossip channel.
Still a work-in-progress but I think that some of the main components are now built.

Design is heavily inspired from the already-existing Azure-based gossip channel. I tried to keep the same conventions but feel free to ask me some changes if this does not comply with your dev rules.

Work is not over yet as
- not a single test has been done :)
- I have not yet used DynamoDB before so there may be design errors
- the gossip channel still has to be registered in the MultiClusterGossipChannelFactory

I have made the choice to split data into two different tables: one for the configuration and one for the gateway. This is not the way it has been implemented in the Azure channel but I am not at all familiar with AzureTable.
This may or may be not a good choice feel free to comment

Also a LegacyDynamoDBMembershipConfigurator has been used to parse DynamoDB connection string. I have to so as IGossipChannel's Initialize makes it mandatory. There may be better ways to do that</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4570</IssueLabelID>
    <Title>Orleans 1.5 IManagementGrain.GetRuntimeStatistics returns incorrect value for memory usage</Title>
    <Description>Orleans 1.5.

An issue has been raised on the OrleansDashboard where memory usage is reported to be a large negative number. 

https://github.com/OrleansContrib/OrleansDashboard/issues/140

The percentage is calculated with this formula: `(TotalPhysicalMemory ?? 0) - (AvailableMemory ?? 0)`

So perhaps TotalPhysicalMemory is not being set?

Should 'MemoryUsage` be used instead?

It's interesting to note that AvailableMemory is a float? and MemoryUsage and TotalPhysicalMemory are both long?.

All values are passed straight through the dashboard API without being stored on alternative variables.

I haven't got a repro.</Description>
    <Title_Description>Orleans 1.5 IManagementGrain.GetRuntimeStatistics returns incorrect value for memory usage Orleans 1.5.

An issue has been raised on the OrleansDashboard where memory usage is reported to be a large negative number. 

https://github.com/OrleansContrib/OrleansDashboard/issues/140

The percentage is calculated with this formula: `(TotalPhysicalMemory ?? 0) - (AvailableMemory ?? 0)`

So perhaps TotalPhysicalMemory is not being set?

Should 'MemoryUsage` be used instead?

It's interesting to note that AvailableMemory is a float? and MemoryUsage and TotalPhysicalMemory are both long?.

All values are passed straight through the dashboard API without being stored on alternative variables.

I haven't got a repro.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4568</IssueLabelID>
    <Title>Transactions simplified to use distributed transaction manager only.</Title>
    <Description>Removed singleton transaction manager and abstractions related to that pattern.
Still work in progress as it should be rebased on Sebastian's transaction storage work once that goes in.

Removed dynamoDb transaction work because there was nothing left once log storage was removed.  Related assemblies and tests are still under source control and can be brought back if/when transactional storage impl is introduced.</Description>
    <Title_Description>Transactions simplified to use distributed transaction manager only. Removed singleton transaction manager and abstractions related to that pattern.
Still work in progress as it should be rebased on Sebastian's transaction storage work once that goes in.

Removed dynamoDb transaction work because there was nothing left once log storage was removed.  Related assemblies and tests are still under source control and can be brought back if/when transactional storage impl is introduced.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4567</IssueLabelID>
    <Title>Fix tests on partial builds</Title>
    <Description>Bump up version of Azure extension packages and fix versions of some references.</Description>
    <Title_Description>Fix tests on partial builds Bump up version of Azure extension packages and fix versions of some references.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4566</IssueLabelID>
    <Title>Azure table transactional storage for distributed TM</Title>
    <Description>New implementation for Azure table transactional storage for distributed TM.
Supports arbitrarily sized batches.

Passes existing transactions tests (NOTE: fails on devstorage must use actual Azure table).
Testing is somewhat incomplete we still need more tests to exercise all the recovery situations.</Description>
    <Title_Description>Azure table transactional storage for distributed TM New implementation for Azure table transactional storage for distributed TM.
Supports arbitrarily sized batches.

Passes existing transactions tests (NOTE: fails on devstorage must use actual Azure table).
Testing is somewhat incomplete we still need more tests to exercise all the recovery situations.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4563</IssueLabelID>
    <Title>Incorrect docs about ObserverSubscriptionManager&lt;T&gt; in 2.0</Title>
    <Description>`ObserverSubscriptionManager&lt;T&gt;` has been moved to legacy package thus docs regarding Observers should be updated accordingly.
note that equivalent class has already been introduced at https://github.com/dotnet/orleans/issues/4378

Page that should be updated:
https://dotnet.github.io/orleans/Documentation/Core-Features/Observers.html</Description>
    <Title_Description>Incorrect docs about ObserverSubscriptionManager&lt;T&gt; in 2.0 `ObserverSubscriptionManager&lt;T&gt;` has been moved to legacy package thus docs regarding Observers should be updated accordingly.
note that equivalent class has already been introduced at https://github.com/dotnet/orleans/issues/4378

Page that should be updated:
https://dotnet.github.io/orleans/Documentation/Core-Features/Observers.html</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4562</IssueLabelID>
    <Title>Support of ValueTask as a grain method return type</Title>
    <Description>#2480
Added support of ValueTask as a return type of grain method.
It's a first step of ValueTask support. For now it's just allow users to use ValueTask as a return type to improve their grain performance. Later on we can try to improve our own performance by using ValueTask instead of Task.
Even so if users start using ValueTask they will have more freedom of writing their code and when we implement full support of ValueTask they will suddenly fill performance improvement without need of changing their code.</Description>
    <Title_Description>Support of ValueTask as a grain method return type #2480
Added support of ValueTask as a return type of grain method.
It's a first step of ValueTask support. For now it's just allow users to use ValueTask as a return type to improve their grain performance. Later on we can try to improve our own performance by using ValueTask instead of Task.
Even so if users start using ValueTask they will have more freedom of writing their code and when we implement full support of ValueTask they will suddenly fill performance improvement without need of changing their code.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4561</IssueLabelID>
    <Title>TransactionAgent: avoid checking for work if transactions are not in use</Title>
    <Description>Currently the TransactionAgent will start when the silo starts and wake up and check for work every 10ms even if transactions are not configured or being used</Description>
    <Title_Description>TransactionAgent: avoid checking for work if transactions are not in use Currently the TransactionAgent will start when the silo starts and wake up and check for work every 10ms even if transactions are not configured or being used</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4560</IssueLabelID>
    <Title>Fixes for v2.0.3 release</Title>
    <Description>
    </Description>
    <Title_Description>Fixes for v2.0.3 release </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4559</IssueLabelID>
    <Title>Bump up versions of legacy packages for partial builds</Title>
    <Description>Bump up versions of legacy packages for partial builds due to changes in #4515</Description>
    <Title_Description>Bump up versions of legacy packages for partial builds Bump up versions of legacy packages for partial builds due to changes in #4515</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4558</IssueLabelID>
    <Title>Remove saving of minidumps</Title>
    <Description>Fixes #4545.

Remove saving of minidumps because that functionality is platform specific.</Description>
    <Title_Description>Remove saving of minidumps Fixes #4545.

Remove saving of minidumps because that functionality is platform specific.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4557</IssueLabelID>
    <Title>Azure retry policy in Orleans</Title>
    <Description>Pretty much the same issue as "Json serialization settings in Orleans" #4555 but with azure table retry policies.</Description>
    <Title_Description>Azure retry policy in Orleans Pretty much the same issue as "Json serialization settings in Orleans" #4555 but with azure table retry policies.</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>4/05/2018 9:41:51 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4556</IssueLabelID>
    <Title>Default provider pattern</Title>
    <Description>In the legacy provider model providers could be acquired by name or a system could request the default.  The default was the provider named “Default”.  When we moved to using dependency injection where keyed services were used instead of provider managers systems could resolve the provider by name as a keyed service or by the service type to get the default.
For example:

            IGrainStorage storageProvider = string.IsNullOrEmpty(providerName)
                ? services.GetServiceByName&lt;IGrainStorage&gt;(providerName)  // get by name or
                : services.GetService&lt;IGrainStorage&gt;(); // get default

To support the legacy naming conventions we continued using the pattern wherein naming a provider “Default” would signal that it’s the default provider.  This is supported by adding a mapping of the provider interface to the ‘default’ named service into the container.  Something like:

            services.TryAddSingleton&lt;IGrainStorage&gt;(sp =&gt; sp.GetServiceByName&lt;IGrainStorage&gt;(ProviderConstants.DEFAULT_STORAGE_PROVIDER_NAME));

This works but has some peculiarities.

* Users may not know about this rule and name a provider “Default” without knowing that name has special meaning in the system.
* Users may not register a default in which the default would always be null (or throw if GetRequiredServiceByName was called).
* The mapping to the default may be registered in the container multiple times which does no harm but is wasteful.

Questions:
Do we want to continue to support default providers?
If so how do we want them to work?
Does the above pattern fit our needs?
Is there a better pattern?
</Description>
    <Title_Description>Default provider pattern In the legacy provider model providers could be acquired by name or a system could request the default.  The default was the provider named “Default”.  When we moved to using dependency injection where keyed services were used instead of provider managers systems could resolve the provider by name as a keyed service or by the service type to get the default.
For example:

            IGrainStorage storageProvider = string.IsNullOrEmpty(providerName)
                ? services.GetServiceByName&lt;IGrainStorage&gt;(providerName)  // get by name or
                : services.GetService&lt;IGrainStorage&gt;(); // get default

To support the legacy naming conventions we continued using the pattern wherein naming a provider “Default” would signal that it’s the default provider.  This is supported by adding a mapping of the provider interface to the ‘default’ named service into the container.  Something like:

            services.TryAddSingleton&lt;IGrainStorage&gt;(sp =&gt; sp.GetServiceByName&lt;IGrainStorage&gt;(ProviderConstants.DEFAULT_STORAGE_PROVIDER_NAME));

This works but has some peculiarities.

* Users may not know about this rule and name a provider “Default” without knowing that name has special meaning in the system.
* Users may not register a default in which the default would always be null (or throw if GetRequiredServiceByName was called).
* The mapping to the default may be registered in the container multiple times which does no harm but is wasteful.

Questions:
Do we want to continue to support default providers?
If so how do we want them to work?
Does the above pattern fit our needs?
Is there a better pattern?
</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4555</IssueLabelID>
    <Title>Json serialization settings in Orleans</Title>
    <Description>Several Orleans systems/components use json serialization.  Orleans sets up its own default json settings and some systems allow certain overrides of this default.  Much of this seems to have been setup before the introduction of dependency injection names services or options and has some shortcomings.

•	Unclear why default settings are necessary.  Do we need a default or should each system just provide its own settings.
•	Not discoverable.  How do users know we have default json settings.
•	No way to modify the default.  Only per component overrides are provided.
•	Ease of use.  To get the default settings one needs a type resolver and grain interface both of which have internal implementations.

Suggest examination of whether a global default is necessary and if necessary a refactor of how it is configured used and overridden.
</Description>
    <Title_Description>Json serialization settings in Orleans Several Orleans systems/components use json serialization.  Orleans sets up its own default json settings and some systems allow certain overrides of this default.  Much of this seems to have been setup before the introduction of dependency injection names services or options and has some shortcomings.

•	Unclear why default settings are necessary.  Do we need a default or should each system just provide its own settings.
•	Not discoverable.  How do users know we have default json settings.
•	No way to modify the default.  Only per component overrides are provided.
•	Ease of use.  To get the default settings one needs a type resolver and grain interface both of which have internal implementations.

Suggest examination of whether a global default is necessary and if necessary a refactor of how it is configured used and overridden.
</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>4/05/2018 9:17:59 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4554</IssueLabelID>
    <Title>Orleans Persistence</Title>
    <Description>Orleans persists state for many reasons both in the core framework and extension libraries.  Persistent state introduces several concerns among which are:

•	Data partitioning.
•	Schema changes.
•	Supported backend storage systems.
•	Data migration and management tools.
•	Custom serialization.

Of the above issues some are addressed some are addressed inconsistently and others are not addressed.  This introduces risk to developers using Orleans because the ease of use hides the complexity associated with persisting state in an evolving production service.  The responsibility ultimately lives with the service developer but the way Orleans manages persistent state offers little to help developers be successful and can in some ways hinder them by hiding the risks.  Without addressing these concerns adding new features like Transactions or Indexing are more difficult and aggravate the problem while refactoring systems which have strong dependencies on storage like streaming or reminders are significantly hindered.

This issue is intended as a starting point for resolving these issues.  The problems are beyond what should be covered in a single issue so I suggest this thread be focused on identifying issues that need be solved which should be spun off as separate issues to be resolved independently.

To start the conversation:

*Data Partitioning*
Currently each silo is part of a cluster which is identified by a service Id which identifies the type of service running on the cluster and should remain constant through the life time of the service and a cluster Id which identifies a deployment of the service.  Storage is partitioned by the service Id.

*Schema Changes*
Storage is inconsistent in how data schemas are translated to storage but most persistence logic uses Orleans serialization to convert complex objects to byte arrays to be stored.  This does not support changes to the persisted state’s schema.  This both limits the Orleans team’s ability to improve Orleans without introducing breaking changes to customers (for which few options are available to work around) as well as application developers ability to modify their own persisted data schema’s when persisted using Orleans features.

*Supported backend storage systems*
We support abstractions for various components which allow for integration with different backends.  However these abstractions are not well defined enough for engineers to implement or program against them with clear expected behaviors.  For instance supported state size error handling and monitoring expectations are often unspecified and vary per implementation.  In more recent additions we’ve attempted to add test harnesses which can be used to vet the behaviors of implementations in an effort to standardize and formalize these abstraction layers but there is still much to be done.

*Data migration and management tools*
There is little to no support for cleaning up migrating or managing persisted state outside the context of the public abstractions.

*Custom serialization*
Custom serializers are primarily supported via the extensibility points in the serialization manager but the serialization manager was initially and primarily intended for networking serialization not storage which has different requirements.  Some other patterns have been attempted for special cases like streaming but no storage specific custom serialization pattern is in use uniformly in the system.

Thought/comments?
What did I miss or get wrong?
</Description>
    <Title_Description>Orleans Persistence Orleans persists state for many reasons both in the core framework and extension libraries.  Persistent state introduces several concerns among which are:

•	Data partitioning.
•	Schema changes.
•	Supported backend storage systems.
•	Data migration and management tools.
•	Custom serialization.

Of the above issues some are addressed some are addressed inconsistently and others are not addressed.  This introduces risk to developers using Orleans because the ease of use hides the complexity associated with persisting state in an evolving production service.  The responsibility ultimately lives with the service developer but the way Orleans manages persistent state offers little to help developers be successful and can in some ways hinder them by hiding the risks.  Without addressing these concerns adding new features like Transactions or Indexing are more difficult and aggravate the problem while refactoring systems which have strong dependencies on storage like streaming or reminders are significantly hindered.

This issue is intended as a starting point for resolving these issues.  The problems are beyond what should be covered in a single issue so I suggest this thread be focused on identifying issues that need be solved which should be spun off as separate issues to be resolved independently.

To start the conversation:

*Data Partitioning*
Currently each silo is part of a cluster which is identified by a service Id which identifies the type of service running on the cluster and should remain constant through the life time of the service and a cluster Id which identifies a deployment of the service.  Storage is partitioned by the service Id.

*Schema Changes*
Storage is inconsistent in how data schemas are translated to storage but most persistence logic uses Orleans serialization to convert complex objects to byte arrays to be stored.  This does not support changes to the persisted state’s schema.  This both limits the Orleans team’s ability to improve Orleans without introducing breaking changes to customers (for which few options are available to work around) as well as application developers ability to modify their own persisted data schema’s when persisted using Orleans features.

*Supported backend storage systems*
We support abstractions for various components which allow for integration with different backends.  However these abstractions are not well defined enough for engineers to implement or program against them with clear expected behaviors.  For instance supported state size error handling and monitoring expectations are often unspecified and vary per implementation.  In more recent additions we’ve attempted to add test harnesses which can be used to vet the behaviors of implementations in an effort to standardize and formalize these abstraction layers but there is still much to be done.

*Data migration and management tools*
There is little to no support for cleaning up migrating or managing persisted state outside the context of the public abstractions.

*Custom serialization*
Custom serializers are primarily supported via the extensibility points in the serialization manager but the serialization manager was initially and primarily intended for networking serialization not storage which has different requirements.  Some other patterns have been attempted for special cases like streaming but no storage specific custom serialization pattern is in use uniformly in the system.

Thought/comments?
What did I miss or get wrong?
</Title_Description>
    <Label>P2</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>4/05/2018 8:59:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4553</IssueLabelID>
    <Title>orleans silo using zookeeper clustering.</Title>
    <Description>i want to run orleans silo with zookeeper. i downloaded the doker image of ZK and run it on a container. i did not get any sample code to connect ZK. Please provide any sample for client and silo. i already running same with azure table. i did not found any documentation for it if you have please provide me.</Description>
    <Title_Description>orleans silo using zookeeper clustering. i want to run orleans silo with zookeeper. i downloaded the doker image of ZK and run it on a container. i did not get any sample code to connect ZK. Please provide any sample for client and silo. i already running same with azure table. i did not found any documentation for it if you have please provide me.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/05/2018 11:31:50 AM +00:00</CreatedAt>
    <ClosedAt>20/05/2019 2:21:40 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4552</IssueLabelID>
    <Title>Add Client/SiloHost builder delegate to legacy GrainClient and SIlo/AzureSilo</Title>
    <Description>Since now providers need to be configured using the builder pattern developer stuck with the legacy Silo and GrainClient can no longer configure thingks like storage or stream providers.

This PR enable them to configure it so transition is more easy.</Description>
    <Title_Description>Add Client/SiloHost builder delegate to legacy GrainClient and SIlo/AzureSilo Since now providers need to be configured using the builder pattern developer stuck with the legacy Silo and GrainClient can no longer configure thingks like storage or stream providers.

This PR enable them to configure it so transition is more easy.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4551</IssueLabelID>
    <Title>There is no support plan for the Http protocol？</Title>
    <Description>There is no support plan for the Http protocol？</Description>
    <Title_Description>There is no support plan for the Http protocol？ There is no support plan for the Http protocol？</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>3/05/2018 3:49:39 AM +00:00</CreatedAt>
    <ClosedAt>24/05/2018 2:00:24 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4549</IssueLabelID>
    <Title>[doc] Links need updating</Title>
    <Description>This thread concerns [Links](https://dotnet.github.io/orleans/Community/Links.html) part of the documentation under the Community section.

* Several of the links listed are broken (result in 404). They should either be removed or replaced with internet archive equivalent links.
* They are in no particular order so it's hard to determine which are historical and which are still relevant today. They should be categorised better.</Description>
    <Title_Description>[doc] Links need updating This thread concerns [Links](https://dotnet.github.io/orleans/Community/Links.html) part of the documentation under the Community section.

* Several of the links listed are broken (result in 404). They should either be removed or replaced with internet archive equivalent links.
* They are in no particular order so it's hard to determine which are historical and which are still relevant today. They should be categorised better.</Title_Description>
    <Label>P1</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4548</IssueLabelID>
    <Title>[doc] Ideas for Contributions needs updating</Title>
    <Description>This thread concerns [Ideas for Contributions](https://dotnet.github.io/orleans/Community/Ideas-for-Contributions.html) which is part of the documentation under Community.

* What is OrleansMonitor? Some earlier incarnation of the OrleansDashboard?
* Port Orleans to coreclr - does this mean .NET Core? (which obviously would be resolved as of 2.0)

Not sure what other points may be obsolete and what others may be worth adding.</Description>
    <Title_Description>[doc] Ideas for Contributions needs updating This thread concerns [Ideas for Contributions](https://dotnet.github.io/orleans/Community/Ideas-for-Contributions.html) which is part of the documentation under Community.

* What is OrleansMonitor? Some earlier incarnation of the OrleansDashboard?
* Port Orleans to coreclr - does this mean .NET Core? (which obviously would be resolved as of 2.0)

Not sure what other points may be obsolete and what others may be worth adding.</Title_Description>
    <Label>P2</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4547</IssueLabelID>
    <Title>Create Basic Clustering Sample</Title>
    <Description>With the 2.0 release I am seeing more and more demand for examples of how to do things in Orleans 2.0. I have partly addressed this for initial "getting started" through the articles on my own blog. However there is a lot of value in having more [samples](https://github.com/dotnet/orleans/tree/master/Samples/2.0)  and [tutorials](https://dotnet.github.io/orleans/Tutorials/index.html). This is because while the docs serve as a comprehensive reference on how Orleans works newcomers learn better when they can be taken through the concepts step by step.

To this end a tutorial is better for a newcomer than comprehensive documentation. And a sample that demonstrates just one thing (e.g. clustering or persistence or reminders) is better than a full-blown application demonstrating everything working together.

I've been asked on my [basic clustering](http://gigi.nullneuron.net/gigilabs/your-first-microsoft-orleans-cluster/) article (written for Orleans 1.4.2) how to do the same for 2.0 i.e. very basic unreliable MembershipTableGrain clustering.

A sample for this would great to have for 2.0 because clustering is typically what newcomers want to try out after they've mastered the basics and before they move onto more reliable clustering options. And it can be a bit of a pain to set up the first time so it would save them a bit of hassle. Also the fact that it uses built-in (even if unreliable) clustering means that people can focus on learning Orleans concepts and defer the need to get into any store-specific details.</Description>
    <Title_Description>Create Basic Clustering Sample With the 2.0 release I am seeing more and more demand for examples of how to do things in Orleans 2.0. I have partly addressed this for initial "getting started" through the articles on my own blog. However there is a lot of value in having more [samples](https://github.com/dotnet/orleans/tree/master/Samples/2.0)  and [tutorials](https://dotnet.github.io/orleans/Tutorials/index.html). This is because while the docs serve as a comprehensive reference on how Orleans works newcomers learn better when they can be taken through the concepts step by step.

To this end a tutorial is better for a newcomer than comprehensive documentation. And a sample that demonstrates just one thing (e.g. clustering or persistence or reminders) is better than a full-blown application demonstrating everything working together.

I've been asked on my [basic clustering](http://gigi.nullneuron.net/gigilabs/your-first-microsoft-orleans-cluster/) article (written for Orleans 1.4.2) how to do the same for 2.0 i.e. very basic unreliable MembershipTableGrain clustering.

A sample for this would great to have for 2.0 because clustering is typically what newcomers want to try out after they've mastered the basics and before they move onto more reliable clustering options. And it can be a bit of a pain to set up the first time so it would save them a bit of hassle. Also the fact that it uses built-in (even if unreliable) clustering means that people can focus on learning Orleans concepts and defer the need to get into any store-specific details.</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>2/05/2018 8:20:27 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4546</IssueLabelID>
    <Title>How to register a BootstrapProvider in Orleans 2.0 programmatically?</Title>
    <Description>Hi
With Orleans 1.x.x we used to register a BootstrapProvider in OrleansConfiguration.xml as below:
```xml
    &lt;BootstrapProviders&gt;
      &lt;Provider Type="MyNamespace.OrleansHostWorkerRoleBoostrapProvider"
                Name="OrleansHostWorkerRoleBoostrapProvider"
                InstanceCount="1"/&gt;
    &lt;/BootstrapProviders&gt;
```

With Orleans 2.0 `IBootstrapProvider` is now in Legacy library. We do not want to use the Legacy library for configurations. Also I do not see any new service to register a bootstarp provider. I might need to replace `IBootstapProvider` with `IProvider` and register `OrleansHostWorkerRoleBoostrapProvider` as a service using `SiloHostBuilder` but didn't get any example or code sample for that. I need your guidance here to register a BootstrapProvider.
Thanks.</Description>
    <Title_Description>How to register a BootstrapProvider in Orleans 2.0 programmatically? Hi
With Orleans 1.x.x we used to register a BootstrapProvider in OrleansConfiguration.xml as below:
```xml
    &lt;BootstrapProviders&gt;
      &lt;Provider Type="MyNamespace.OrleansHostWorkerRoleBoostrapProvider"
                Name="OrleansHostWorkerRoleBoostrapProvider"
                InstanceCount="1"/&gt;
    &lt;/BootstrapProviders&gt;
```

With Orleans 2.0 `IBootstrapProvider` is now in Legacy library. We do not want to use the Legacy library for configurations. Also I do not see any new service to register a bootstarp provider. I might need to replace `IBootstapProvider` with `IProvider` and register `OrleansHostWorkerRoleBoostrapProvider` as a service using `SiloHostBuilder` but didn't get any example or code sample for that. I need your guidance here to register a BootstrapProvider.
Thanks.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4544</IssueLabelID>
    <Title>Disable multi-state transactional grain tests</Title>
    <Description>Disable multi-state transactional grain tests for singleton transaction manager tests.</Description>
    <Title_Description>Disable multi-state transactional grain tests Disable multi-state transactional grain tests for singleton transaction manager tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4543</IssueLabelID>
    <Title>Update tests for distributed TM to use multiple states</Title>
    <Description>Now distributed TM also has tests that use multiple states per grain.

(I basically just copied the pattern in Orleans.Transactions.Tests/Grains/MultiStateTransactionalGrains.cs over to Orleans.Transactions.Tests/DistributedTM/MultiStateTransactionalGrain.cs)
</Description>
    <Title_Description>Update tests for distributed TM to use multiple states Now distributed TM also has tests that use multiple states per grain.

(I basically just copied the pattern in Orleans.Transactions.Tests/Grains/MultiStateTransactionalGrains.cs over to Orleans.Transactions.Tests/DistributedTM/MultiStateTransactionalGrain.cs)
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4541</IssueLabelID>
    <Title>Rearrange test projects and make them support partial build</Title>
    <Description>
    </Description>
    <Title_Description>Rearrange test projects and make them support partial build </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4540</IssueLabelID>
    <Title>Question about  Item System*WorkItemGroup:Name=*stg/28/0000001c</Title>
    <Description>I got much warning infomation on my application that base on Orleans 2.0 
```
2018/05/01 08:27:44.717|WARN|Queue wait time of 00:00:10.0157850 for Item System*WorkItemGroup:Name=*stg/28/`0000001c`WorkGroupStatus=Runnable |Runtime.Scheduler.WorkerPoolThread/System.9|EventId_Id=101201 EventId_Name= EventId=101201
```
 I noticed that `System*WorkItemGroup:Name=*stg/28/0000001c` maybe the  [TransactionAgentSystemTargetId](https://github.com/dotnet/orleans/blob/ba5531ba90053bb2f799c5ce36e90e8db6b94a93/src/Orleans.Core/Runtime/Constants.cs#L46)  but I never use any `TransactionAgentSystemTarget` on my system  why is this  ? 
</Description>
    <Title_Description>Question about  Item System*WorkItemGroup:Name=*stg/28/0000001c I got much warning infomation on my application that base on Orleans 2.0 
```
2018/05/01 08:27:44.717|WARN|Queue wait time of 00:00:10.0157850 for Item System*WorkItemGroup:Name=*stg/28/`0000001c`WorkGroupStatus=Runnable |Runtime.Scheduler.WorkerPoolThread/System.9|EventId_Id=101201 EventId_Name= EventId=101201
```
 I noticed that `System*WorkItemGroup:Name=*stg/28/0000001c` maybe the  [TransactionAgentSystemTargetId](https://github.com/dotnet/orleans/blob/ba5531ba90053bb2f799c5ce36e90e8db6b94a93/src/Orleans.Core/Runtime/Constants.cs#L46)  but I never use any `TransactionAgentSystemTarget` on my system  why is this  ? 
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4539</IssueLabelID>
    <Title>Add transaction recoverbility test runner</Title>
    <Description>- Add transaction recoverability test runners. 
- Add transaction recoverability tests running against single TM. currently isn't included into functional or bvt because single TM has recoverability problems  so the tests isn't passing. But it is higher priority to get the test runner merged in so we can test the new distributed TM. If you don't like it I can remove the actual tests.</Description>
    <Title_Description>Add transaction recoverbility test runner - Add transaction recoverability test runners. 
- Add transaction recoverability tests running against single TM. currently isn't included into functional or bvt because single TM has recoverability problems  so the tests isn't passing. But it is higher priority to get the test runner merged in so we can test the new distributed TM. If you don't like it I can remove the actual tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4538</IssueLabelID>
    <Title>Azure table TransactionalStateStorage</Title>
    <Description>
    </Description>
    <Title_Description>Azure table TransactionalStateStorage </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4537</IssueLabelID>
    <Title>Document placement policies</Title>
    <Description>Dear Orleans Team

I have been trouble shooting my application for the past 2 months because I wasn't gaining any benefit from adding additional silos. Can you create a topic in your documentation regarding placement location [PreferLocalPlacement] and so on. My problem was that every time Grain A was called by my clients Grain A had to call 3 instances of Grain B when placement was set to random these were activated on the different silos but when I changed Grain B to prefer local placement it always activated them with Grain A so the RPCs where minimized.

I have looked through the entire documentation (I am pretty sure it is mentioned in one of the scientific papers published or a blog post somewhere since that was the only reason I ended up thinking about it).

I found this description today that saved my day. http://richorama.github.io/blog/2015/01/02/grain-placement-in-orleans/</Description>
    <Title_Description>Document placement policies Dear Orleans Team

I have been trouble shooting my application for the past 2 months because I wasn't gaining any benefit from adding additional silos. Can you create a topic in your documentation regarding placement location [PreferLocalPlacement] and so on. My problem was that every time Grain A was called by my clients Grain A had to call 3 instances of Grain B when placement was set to random these were activated on the different silos but when I changed Grain B to prefer local placement it always activated them with Grain A so the RPCs where minimized.

I have looked through the entire documentation (I am pretty sure it is mentioned in one of the scientific papers published or a blog post somewhere since that was the only reason I ended up thinking about it).

I found this description today that saved my day. http://richorama.github.io/blog/2015/01/02/grain-placement-in-orleans/</Title_Description>
    <Label>P1</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>30/04/2018 9:45:05 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4536</IssueLabelID>
    <Title>Regression on ClusterClient</Title>
    <Description>The ClusterClient seems very persnickety when it comes to maintaining a connection

`Client is not initialized. Current client state is Starting.`

This just seems to happen randomly during the lifecycle of a ClusterClient and there is no way for the ClusterClient to recover it just needs to be torn down and replaced which means major rearchitecting my application.</Description>
    <Title_Description>Regression on ClusterClient The ClusterClient seems very persnickety when it comes to maintaining a connection

`Client is not initialized. Current client state is Starting.`

This just seems to happen randomly during the lifecycle of a ClusterClient and there is no way for the ClusterClient to recover it just needs to be torn down and replaced which means major rearchitecting my application.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4535</IssueLabelID>
    <Title>Revert GrainReference.FromKeyString() back to internal</Title>
    <Description>Revert `GrainReference.FromKeyString()` back to internal and expose it via `Utils.FromKeyString()` instead so that Orleans.Abstractions don't need to get updated.

This is a follow-up to #3820. It changed `GrainReference.FromKeyString()` from `internal` to `public` and that now requires us to update the `Core.Abstractions` package which we'd prefer not to.

This change is a workaround that allows us to avoid updating abstractions unnecessarily.</Description>
    <Title_Description>Revert GrainReference.FromKeyString() back to internal Revert `GrainReference.FromKeyString()` back to internal and expose it via `Utils.FromKeyString()` instead so that Orleans.Abstractions don't need to get updated.

This is a follow-up to #3820. It changed `GrainReference.FromKeyString()` from `internal` to `public` and that now requires us to update the `Core.Abstractions` package which we'd prefer not to.

This change is a workaround that allows us to avoid updating abstractions unnecessarily.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4534</IssueLabelID>
    <Title>Unit Testing &amp; OrleansTestKit Path Forward</Title>
    <Description>We have been discussing our testing strategy internally and would like to see if anyone else has opinions on how we can make testing better in Orleans. We are thinking about using a similar API to the one I created in OrleansTestKit but run it within the actual Orleans runtime. The OrleansTestKit is able to run tests for many simple use cases however it will not support more complex grain that are deeply integrated with Orleans for example Lifecycle events. There are many other things that Orleans does that would not be able to be tested inside the TestKit. Rather than spending more time emulating Orleans behaviors we are thinking about a new approach that would allow the same assertions that exist within the current TestKit but would allow grain code to execute exactly as it does when running in a real silo.

 In reality most of this proposal is just to allow developers to assert grain state  grain calls to other grains and provide a way for a developer configure a mock grain that will return the desired value or exception when a grain is called.

What would need to be built:

**Storage provider**
- Assert the current grain state
- Setup the grain state prior to activation

**Stream provider**
- Assert that a grain is subscribed to a specific stream
- Assert that a grain sends the proper message on a stream
- Assert that a grain received a message from a stream without error
- Assert that a grain unsubscribed from a specific stream

**Reminder Provider**
- Assert that a reminder was registered for the correct time
- Fire a reminder on demand from within a test 

**Mock Grain Call Filter**
- Assert that another grain was called with the correct values
- Intercept grain-to-grain method calls and return a specific value or throw an exception

**Other**
- Deactivate a grain on demand
- Activate a grain on demand

Please let me know if you have other things that you would like exposed and we can talk about a roadmap to build out these features. We are going to start prototyping some of these behaviors this week to see how they work in practice.</Description>
    <Title_Description>Unit Testing &amp; OrleansTestKit Path Forward We have been discussing our testing strategy internally and would like to see if anyone else has opinions on how we can make testing better in Orleans. We are thinking about using a similar API to the one I created in OrleansTestKit but run it within the actual Orleans runtime. The OrleansTestKit is able to run tests for many simple use cases however it will not support more complex grain that are deeply integrated with Orleans for example Lifecycle events. There are many other things that Orleans does that would not be able to be tested inside the TestKit. Rather than spending more time emulating Orleans behaviors we are thinking about a new approach that would allow the same assertions that exist within the current TestKit but would allow grain code to execute exactly as it does when running in a real silo.

 In reality most of this proposal is just to allow developers to assert grain state  grain calls to other grains and provide a way for a developer configure a mock grain that will return the desired value or exception when a grain is called.

What would need to be built:

**Storage provider**
- Assert the current grain state
- Setup the grain state prior to activation

**Stream provider**
- Assert that a grain is subscribed to a specific stream
- Assert that a grain sends the proper message on a stream
- Assert that a grain received a message from a stream without error
- Assert that a grain unsubscribed from a specific stream

**Reminder Provider**
- Assert that a reminder was registered for the correct time
- Fire a reminder on demand from within a test 

**Mock Grain Call Filter**
- Assert that another grain was called with the correct values
- Intercept grain-to-grain method calls and return a specific value or throw an exception

**Other**
- Deactivate a grain on demand
- Activate a grain on demand

Please let me know if you have other things that you would like exposed and we can talk about a roadmap to build out these features. We are going to start prototyping some of these behaviors this week to see how they work in practice.</Title_Description>
    <Label>design-review</Label>
    <Assignee>dsarfati</Assignee>
    <CreatedAt>30/04/2018 6:50:45 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4532</IssueLabelID>
    <Title>DI documentation incorrect client sample</Title>
    <Description>This concerns the [Dependency Injection](https://dotnet.github.io/orleans/Documentation/Core-Features/Dependency-Injection.html) documentation page for Orleans 2.0.

There's this code sample that shows how the _client_ should be configured to use DI:

![image](https://user-images.githubusercontent.com/13241564/39409406-6d25766a-4bde-11e8-9cbf-1b2a2be293cb.png)


It seems to be a direct copy/paste from the sample above which is for the silo. The name of the builder variable was changed but the rest was left the same.</Description>
    <Title_Description>DI documentation incorrect client sample This concerns the [Dependency Injection](https://dotnet.github.io/orleans/Documentation/Core-Features/Dependency-Injection.html) documentation page for Orleans 2.0.

There's this code sample that shows how the _client_ should be configured to use DI:

![image](https://user-images.githubusercontent.com/13241564/39409406-6d25766a-4bde-11e8-9cbf-1b2a2be293cb.png)


It seems to be a direct copy/paste from the sample above which is for the silo. The name of the builder variable was changed but the rest was left the same.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4531</IssueLabelID>
    <Title>Grain timeouts</Title>
    <Description>Hi. I want to use grain with different lifetime by type. Some my grains execute so long and this normal. Then i call grain from client i can registered standardClient and longTimeLive client but i can do this inside silo host. When i cal my grain A from grain B i want that grain B can wait A more that another grains. How i can do this?</Description>
    <Title_Description>Grain timeouts Hi. I want to use grain with different lifetime by type. Some my grains execute so long and this normal. Then i call grain from client i can registered standardClient and longTimeLive client but i can do this inside silo host. When i cal my grain A from grain B i want that grain B can wait A more that another grains. How i can do this?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/04/2018 4:59:19 PM +00:00</CreatedAt>
    <ClosedAt>19/06/2018 2:30:08 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4530</IssueLabelID>
    <Title>Error during serialization of Entity Framework objects</Title>
    <Description>If Lazy Load enabled in EF the serialization process throws ArgumentException: Invalid token for impersonation - it cannot be duplicated error

```c#
var order = db.ORDERS.FirstOrDefault();
await GrainFactory.GetGrain&lt;IOrderProcessor&gt;().Execute(order);

```

```
System.Reflection.TargetInvocationException
  HResult=0x80131604
  Message=Exception has been thrown by the target of an invocation.
  Source=mscorlib
  StackTrace:
   at System.RuntimeMethodHandle.SerializationInvoke(IRuntimeMethodInfo method Object target SerializationInfo info StreamingContext&amp; context)
   at System.Runtime.Serialization.ObjectManager.CompleteISerializableObject(Object obj SerializationInfo info StreamingContext context)
   at System.Runtime.Serialization.ObjectManager.FixupSpecialObject(ObjectHolder holder)
   at System.Runtime.Serialization.ObjectManager.DoFixups()
   at System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(HeaderHandler handler __BinaryParser serParser Boolean fCheck Boolean isCrossAppDomain IMethodCallMessage methodCallMessage)
   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream HeaderHandler handler Boolean fCheck Boolean isCrossAppDomain IMethodCallMessage methodCallMessage)
   at Orleans.Serialization.BinaryFormatterSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.BuiltInTypes.&lt;&gt;c__DisplayClass12_0`1.&lt;DeepCopyList&gt;b__0(T element)
   at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index IEnumerable`1 collection)
   at Orleans.Serialization.BuiltInTypes.DeepCopyList[T](Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopy(Object original)
   at Orleans.Runtime.GrainReferenceRuntime.InvokeMethodAsync[T](GrainReference reference Int32 methodId Object[] arguments InvokeMethodOptions options SiloAddress silo)
   at PIfle.Server.Abstractions.OrleansCodeGenAssigmentPDGrainServiceReference.Run(List`1 newOrders)
 
Inner Exception 1:
ArgumentException: Invalid token for impersonation - it cannot be duplicated

```</Description>
    <Title_Description>Error during serialization of Entity Framework objects If Lazy Load enabled in EF the serialization process throws ArgumentException: Invalid token for impersonation - it cannot be duplicated error

```c#
var order = db.ORDERS.FirstOrDefault();
await GrainFactory.GetGrain&lt;IOrderProcessor&gt;().Execute(order);

```

```
System.Reflection.TargetInvocationException
  HResult=0x80131604
  Message=Exception has been thrown by the target of an invocation.
  Source=mscorlib
  StackTrace:
   at System.RuntimeMethodHandle.SerializationInvoke(IRuntimeMethodInfo method Object target SerializationInfo info StreamingContext&amp; context)
   at System.Runtime.Serialization.ObjectManager.CompleteISerializableObject(Object obj SerializationInfo info StreamingContext context)
   at System.Runtime.Serialization.ObjectManager.FixupSpecialObject(ObjectHolder holder)
   at System.Runtime.Serialization.ObjectManager.DoFixups()
   at System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(HeaderHandler handler __BinaryParser serParser Boolean fCheck Boolean isCrossAppDomain IMethodCallMessage methodCallMessage)
   at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream HeaderHandler handler Boolean fCheck Boolean isCrossAppDomain IMethodCallMessage methodCallMessage)
   at Orleans.Serialization.BinaryFormatterSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.ILBasedSerializer.DeepCopy(Object source ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.BuiltInTypes.&lt;&gt;c__DisplayClass12_0`1.&lt;DeepCopyList&gt;b__0(T element)
   at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()
   at System.Collections.Generic.List`1.InsertRange(Int32 index IEnumerable`1 collection)
   at Orleans.Serialization.BuiltInTypes.DeepCopyList[T](Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original ICopyContext context)
   at Orleans.Serialization.SerializationManager.DeepCopy(Object original)
   at Orleans.Runtime.GrainReferenceRuntime.InvokeMethodAsync[T](GrainReference reference Int32 methodId Object[] arguments InvokeMethodOptions options SiloAddress silo)
   at PIfle.Server.Abstractions.OrleansCodeGenAssigmentPDGrainServiceReference.Run(List`1 newOrders)
 
Inner Exception 1:
ArgumentException: Invalid token for impersonation - it cannot be duplicated

```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4528</IssueLabelID>
    <Title>Orleans 2.0 documentation page inaccuracies</Title>
    <Description>This thread relates to the [Orleans 2.0 documentation page](https://dotnet.github.io/orleans/Documentation/Orleans-2.0.html).

&gt; Explicit programmatic specification of application assemblies that replaces automatic scanning of folders by the Orleans runtime upon silo or client initialization. Orleans will still automatically find relevant types such as grain interfaces and classes serializers etc. in the specified assemblies but **it will not anymore try to load every assembly it can find in the folder**. An optional helper method for loading all assemblies in the folder is provided for backward compatibility. See Configuration and Migration sections for more details.

I thought that automatic scanning for assemblies was the default behaviour - ref [Application Parts documentation](https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html#application-parts) and https://github.com/dotnet/orleans/issues/4420#issuecomment-379962127 .

&gt; Overhaul of code generation. **While mostly invisible for developer** code generation became much more robust in handling serialization of various possible types. Special handling is required for F# assemblies. See Code generation section for more details.

Code generation is not very invisible given that Orleans won't work without it - ref https://github.com/dotnet/orleans/issues/4417 .</Description>
    <Title_Description>Orleans 2.0 documentation page inaccuracies This thread relates to the [Orleans 2.0 documentation page](https://dotnet.github.io/orleans/Documentation/Orleans-2.0.html).

&gt; Explicit programmatic specification of application assemblies that replaces automatic scanning of folders by the Orleans runtime upon silo or client initialization. Orleans will still automatically find relevant types such as grain interfaces and classes serializers etc. in the specified assemblies but **it will not anymore try to load every assembly it can find in the folder**. An optional helper method for loading all assemblies in the folder is provided for backward compatibility. See Configuration and Migration sections for more details.

I thought that automatic scanning for assemblies was the default behaviour - ref [Application Parts documentation](https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html#application-parts) and https://github.com/dotnet/orleans/issues/4420#issuecomment-379962127 .

&gt; Overhaul of code generation. **While mostly invisible for developer** code generation became much more robust in handling serialization of various possible types. Special handling is required for F# assemblies. See Code generation section for more details.

Code generation is not very invisible given that Orleans won't work without it - ref https://github.com/dotnet/orleans/issues/4417 .</Title_Description>
    <Label>P1</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4527</IssueLabelID>
    <Title>This problem has not been resolved in 2.0.【#4178】</Title>
    <Description>@ReubenBond  This problem has not been resolved in 2.0.#4178。</Description>
    <Title_Description>This problem has not been resolved in 2.0.【#4178】 @ReubenBond  This problem has not been resolved in 2.0.#4178。</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4525</IssueLabelID>
    <Title>Orleans Client in front end web server - Setup</Title>
    <Description>Scenario: I've got a front end web api which is going to invoke the grain to execute the business logic.

In Orleans 1.5 GrainClient once initialized it was available across basically I had the client initialization code in by WebApiConfig class.

 GrainClient.Initialize(HttpContext.Current.Server.MapPath("OrleansConfiguration.xml"));

And in my end point I would simply access the GrainClient static class to create the grain factory and all the method like this.

 public async Task&lt;HttpResponseMessage&gt; HealthCheckGrain()
 {
     GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0).SayHello("Test");
}

Since 2.0 doesn't have this how can I initialize the client once and then use the same client again to invoke the grain or is it expected to create the client each time you invoke the grain.</Description>
    <Title_Description>Orleans Client in front end web server - Setup Scenario: I've got a front end web api which is going to invoke the grain to execute the business logic.

In Orleans 1.5 GrainClient once initialized it was available across basically I had the client initialization code in by WebApiConfig class.

 GrainClient.Initialize(HttpContext.Current.Server.MapPath("OrleansConfiguration.xml"));

And in my end point I would simply access the GrainClient static class to create the grain factory and all the method like this.

 public async Task&lt;HttpResponseMessage&gt; HealthCheckGrain()
 {
     GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0).SayHello("Test");
}

Since 2.0 doesn't have this how can I initialize the client once and then use the same client again to invoke the grain or is it expected to create the client each time you invoke the grain.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/04/2018 9:44:15 PM +00:00</CreatedAt>
    <ClosedAt>1/05/2018 9:55:35 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4524</IssueLabelID>
    <Title>Error on type 'MessageCenter'.  The requested address is not valid in its context</Title>
    <Description>After moving to the V2.0 from v2-rc3 several developers get the "The requested address is not valid in its context" error. At several devs all works as expected. We use the ado.net clustering.
From this message is not clear where is a problem

```
2018-04-27 16:30:33.777 +03:00 [WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-04-27 16:30:33.848 +03:00 [INF] Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.
2018-04-27 16:30:34.455 +03:00 [INF] Silo starting with GC settings: ServerGC=false GCLatencyMode=Interactive
2018-04-27 16:30:34.455 +03:00 [WRN] Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-04-27 16:30:34.458 +03:00 [WRN] Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-04-27 16:30:34.464 +03:00 [INF] -------------- Initializing silo on host RIfle MachineName RIfle at 169.254.45.213:11111 gen 262531833 --------------
2018-04-27 16:30:34.467 +03:00 [INF] Starting silo Silo_e5667
2018-04-27 16:31:47.657 +03:00 [ERR] An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = SiloWrapper (ReflectionActivator) Services = [Orleans.Hosting.ISiloHost] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.)
Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. 
See the inner exception for details. Registration: Activator = SiloWrapper (ReflectionActivator) 
Services = [Orleans.Hosting.ISiloHost] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared 
Ownership = OwnedByLifetimeScope ---&gt; An error occurred during the activation of a particular registration. 
See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; 
An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. 
---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope 
---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' 
Error on type 'MessageCenter'. 
---&gt; The requested address is not valid in its context (See inner exception for details.) 
(See inner exception for details.) (See inner exception for details.) (See inner exception for details.) 
(See inner exception for details.) 
---&gt; Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) ---&gt; System.Net.Sockets.SocketException: The requested address is not valid in its context
   at System.Net.Sockets.Socket.DoBind(EndPoint endPointSnapshot SocketAddress socketAddress)
   at System.Net.Sockets.Socket.Bind(EndPoint localEP)
   at Orleans.Runtime.SocketManager.GetAcceptingSocketForEndpoint(IPEndPoint address)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor..ctor(MessageCenter msgCtr IPEndPoint here SocketDirection socketDirection MessageFactory messageFactory SerializationManager serializationManager ExecutorService executorService ILoggerFactory loggerFactory)
   at Orleans.Runtime.Messaging.MessageCenter.Initialize(IOptions`1 endpointOptions IOptions`1 messagingOptions IOptions`1 networkingOptions)
   at Orleans.Runtime.Messaging.MessageCenter..ctor(ILocalSiloDetails siloDetails IOptions`1 endpointOptions IOptions`1 messagingOptions IOptions`1 networkingOptions SerializationManager serializationManager MessageFactory messageFactory Factory`2 gatewayFactory ExecutorService executorService ILoggerFactory loggerFactory)
   at lambda_method(Closure  Object[] )
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   --- End of inner exception stack trace ---
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetRequiredService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Runtime.Silo..ctor(ILocalSiloDetails siloDetails IServiceProvider services)
   at lambda_method(Closure  Object[] )
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   --- End of inner exception stack trace ---
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetRequiredService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at PApp.Server.Host.Program.BuildSilo()
   at PApp.Server.Host.Program.Main(String[] args)
2018-04-27 16:31:47.724 +03:00 [INF] Silo Stopping...
2018-04-27 16:31:47.725 +03:00 [INF] Silo Stopped
2018-04-27 16:32:45.710 +03:00 [WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-04-27 16:32:45.789 +03:00 [INF] Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.
2018-04-27 16:32:46.290 +03:00 [INF] Silo starting with GC settings: ServerGC=false GCLatencyMode=Interactive
2018-04-27 16:32:46.292 +03:00 [WRN] Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-04-27 16:32:46.293 +03:00 [WRN] Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-04-27 16:32:46.299 +03:00 [INF] -------------- Initializing silo on host RIfle MachineName RIfle at 169.254.45.213:11111 gen 262531965 --------------
2018-04-27 16:32:46.301 +03:00 [INF] Starting silo Silo_e8a96

```

</Description>
    <Title_Description>Error on type 'MessageCenter'.  The requested address is not valid in its context After moving to the V2.0 from v2-rc3 several developers get the "The requested address is not valid in its context" error. At several devs all works as expected. We use the ado.net clustering.
From this message is not clear where is a problem

```
2018-04-27 16:30:33.777 +03:00 [WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-04-27 16:30:33.848 +03:00 [INF] Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.
2018-04-27 16:30:34.455 +03:00 [INF] Silo starting with GC settings: ServerGC=false GCLatencyMode=Interactive
2018-04-27 16:30:34.455 +03:00 [WRN] Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-04-27 16:30:34.458 +03:00 [WRN] Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-04-27 16:30:34.464 +03:00 [INF] -------------- Initializing silo on host RIfle MachineName RIfle at 169.254.45.213:11111 gen 262531833 --------------
2018-04-27 16:30:34.467 +03:00 [INF] Starting silo Silo_e5667
2018-04-27 16:31:47.657 +03:00 [ERR] An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = SiloWrapper (ReflectionActivator) Services = [Orleans.Hosting.ISiloHost] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.)
Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. 
See the inner exception for details. Registration: Activator = SiloWrapper (ReflectionActivator) 
Services = [Orleans.Hosting.ISiloHost] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared 
Ownership = OwnedByLifetimeScope ---&gt; An error occurred during the activation of a particular registration. 
See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; 
An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. 
---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope 
---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' 
Error on type 'MessageCenter'. 
---&gt; The requested address is not valid in its context (See inner exception for details.) 
(See inner exception for details.) (See inner exception for details.) (See inner exception for details.) 
(See inner exception for details.) 
---&gt; Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = Silo (ReflectionActivator) Services = [Orleans.Runtime.Silo] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails System.IServiceProvider)' on type 'Silo'. ---&gt; An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = MessageCenter (ReflectionActivator) Services = [Orleans.Runtime.Messaging.MessageCenter] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope ---&gt; An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) (See inner exception for details.) ---&gt; Autofac.Core.DependencyResolutionException: An exception was thrown while invoking the constructor 'Void .ctor(Orleans.Runtime.ILocalSiloDetails Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.EndpointOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.SiloMessagingOptions] Microsoft.Extensions.Options.IOptions`1[Orleans.Configuration.NetworkingOptions] Orleans.Serialization.SerializationManager Orleans.Runtime.MessageFactory Orleans.Factory`2[Orleans.Runtime.Messaging.MessageCenterOrleans.Runtime.Messaging.Gateway] Orleans.Runtime.ExecutorService Microsoft.Extensions.Logging.ILoggerFactory)' on type 'MessageCenter'. ---&gt; The requested address is not valid in its context (See inner exception for details.) ---&gt; System.Net.Sockets.SocketException: The requested address is not valid in its context
   at System.Net.Sockets.Socket.DoBind(EndPoint endPointSnapshot SocketAddress socketAddress)
   at System.Net.Sockets.Socket.Bind(EndPoint localEP)
   at Orleans.Runtime.SocketManager.GetAcceptingSocketForEndpoint(IPEndPoint address)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor..ctor(MessageCenter msgCtr IPEndPoint here SocketDirection socketDirection MessageFactory messageFactory SerializationManager serializationManager ExecutorService executorService ILoggerFactory loggerFactory)
   at Orleans.Runtime.Messaging.MessageCenter.Initialize(IOptions`1 endpointOptions IOptions`1 messagingOptions IOptions`1 networkingOptions)
   at Orleans.Runtime.Messaging.MessageCenter..ctor(ILocalSiloDetails siloDetails IOptions`1 endpointOptions IOptions`1 messagingOptions IOptions`1 networkingOptions SerializationManager serializationManager MessageFactory messageFactory Factory`2 gatewayFactory ExecutorService executorService ILoggerFactory loggerFactory)
   at lambda_method(Closure  Object[] )
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   --- End of inner exception stack trace ---
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetRequiredService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Runtime.Silo..ctor(ILocalSiloDetails siloDetails IServiceProvider services)
   at lambda_method(Closure  Object[] )
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   --- End of inner exception stack trace ---
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()
   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context IEnumerable`1 parameters)
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   --- End of inner exception stack trace ---
   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)
   at Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(Guid id Func`1 creator)
   at Autofac.Core.Resolving.InstanceLookup.Execute()
   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration IEnumerable`1 parameters)
   at Autofac.ResolutionExtensions.TryResolveService(IComponentContext context Service service IEnumerable`1 parameters Object&amp; instance)
   at Autofac.ResolutionExtensions.ResolveService(IComponentContext context Service service IEnumerable`1 parameters)
   at Autofac.Extensions.DependencyInjection.AutofacServiceProvider.GetRequiredService(Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at PApp.Server.Host.Program.BuildSilo()
   at PApp.Server.Host.Program.Main(String[] args)
2018-04-27 16:31:47.724 +03:00 [INF] Silo Stopping...
2018-04-27 16:31:47.725 +03:00 [INF] Silo Stopped
2018-04-27 16:32:45.710 +03:00 [WRN] No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet
2018-04-27 16:32:45.789 +03:00 [INF] Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.
2018-04-27 16:32:46.290 +03:00 [INF] Silo starting with GC settings: ServerGC=false GCLatencyMode=Interactive
2018-04-27 16:32:46.292 +03:00 [WRN] Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
2018-04-27 16:32:46.293 +03:00 [WRN] Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
2018-04-27 16:32:46.299 +03:00 [INF] -------------- Initializing silo on host RIfle MachineName RIfle at 169.254.45.213:11111 gen 262531965 --------------
2018-04-27 16:32:46.301 +03:00 [INF] Starting silo Silo_e8a96

```

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4523</IssueLabelID>
    <Title>Orleans call grain within a grain</Title>
    <Description>I've got a requirement to call a grain within a grain. I had tried this in version 1.5 not sure how it works in 2.0. If somebody can provide a sample it would be great. This was what I was trying.

 public class CustomerRule : Grain ICustomerRule
{
    private ISomeGrain _someGrain;
    public override async Task OnActivateAsync()
        {
              _someGrain = GrainFactory.GetGrain&lt;ISomeGrain&gt;(this.GetPrimaryKeyString());
              await base.OnActivateAsync();
         }
     public Task&lt;bool&gt; TestHello(GrainCancellationToken tc string customer)
     {
               var string =  _someGrain.SayHello(tc customer);
              return Task.FromResult(string);
      }
}

Due to some reason SayHello() is not being invoked. 
</Description>
    <Title_Description>Orleans call grain within a grain I've got a requirement to call a grain within a grain. I had tried this in version 1.5 not sure how it works in 2.0. If somebody can provide a sample it would be great. This was what I was trying.

 public class CustomerRule : Grain ICustomerRule
{
    private ISomeGrain _someGrain;
    public override async Task OnActivateAsync()
        {
              _someGrain = GrainFactory.GetGrain&lt;ISomeGrain&gt;(this.GetPrimaryKeyString());
              await base.OnActivateAsync();
         }
     public Task&lt;bool&gt; TestHello(GrainCancellationToken tc string customer)
     {
               var string =  _someGrain.SayHello(tc customer);
              return Task.FromResult(string);
      }
}

Due to some reason SayHello() is not being invoked. 
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/04/2018 5:19:10 PM +00:00</CreatedAt>
    <ClosedAt>27/04/2018 9:15:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4522</IssueLabelID>
    <Title>Running on dotnetcore on Windows Subsystem for Linux</Title>
    <Description>* Standard Ubuntu on Windows 10 **Windows Subsytem for Linux** (WSL )
* Installed dotnecore SDK as per 
* * https://www.microsoft.com/net/learn/get-started/linux/ubuntu16-04
* * Version 2.1.105
* Simple Hello world project compiled on the Ubuntu WSL using `dotnet restore` and `dotnet run`
* _Tested on Ubuntu 16.04 on Virtualbox and this does not happen. It is specific to WSL_

Project configuration for Silo which will not start

  ```
   var silo = new SiloHostBuilder()
               // Clustering information
               .Configure&lt;ClusterOptions&gt;(options =&gt;
               {
                   options.ClusterId = "my-first-cluster";
                    options.ServiceId = "MyAwesomeOrleansService";
               })
               // Clustering provider
               .UseAzureStorageClustering(options =&gt; options.ConnectionString = azureTableConnectionString)
               // Endpoints
               .ConfigureEndpoints(siloPort: Int32.Parse(args[1]) gatewayPort: Int32.Parse(args[2]))
               //.ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)
               // Now create the silo!
               .ConfigureLogging(logging =&gt; logging.AddConsole())
               .Build();
```

Exception Aggregate 

&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.

```
Unhandled Exception: System.AggregateException: One or more errors occurred. (An error was encountered while querying information from the operating system.) ---&gt; System.Net.NetworkInformation.NetworkInformationException: An error was encountered while querying information from the operating system. ---&gt; System.AggregateException: One or more errors occurred. (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) ---&gt; System.IO.DirectoryNotFoundException: Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.
   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo String path Boolean isDirectory Func`2 errorRewriter)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path OpenFlags flags Int32 mode)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
   at System.IO.StreamReader..ctor(String path Encoding encoding Boolean detectEncodingFromByteOrderMarks Int32 bufferSize)
   at System.IO.StreamReader..ctor(String path Encoding encoding Boolean detectEncodingFromByteOrderMarks)
   at System.IO.File.InternalReadAllText(String path Encoding encoding)
   at System.IO.File.ReadAllText(String path)
   at System.Net.NetworkInformation.StringParsingHelpers.ParseRawIntFile(String filePath)
   at System.Net.NetworkInformation.LinuxIPv4InterfaceProperties.GetIsForwardingEnabled()
   at System.Net.NetworkInformation.LinuxIPv4InterfaceProperties..ctor(LinuxNetworkInterface linuxNetworkInterface)
   at System.Net.NetworkInformation.LinuxIPInterfaceProperties..ctor(LinuxNetworkInterface lni)
   at System.Net.NetworkInformation.LinuxNetworkInterface..ctor(String name)
   at System.Net.NetworkInformation.LinuxNetworkInterface.GetOrCreate(Dictionary`2 interfaces String name)
   at System.Net.NetworkInformation.LinuxNetworkInterface.&lt;&gt;c__DisplayClass5_0.&lt;GetLinuxNetworkInterfaces&gt;b__2(String name LinkLayerAddressInfo* llAddr)
   --- End of inner exception stack trace ---
   --- End of inner exception stack trace ---
   at System.Net.NetworkInformation.LinuxNetworkInterface.GetLinuxNetworkInterfaces()
   at Orleans.Runtime.Configuration.ConfigUtilities.&lt;ResolveIPAddress&gt;d__18.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at Orleans.Hosting.EndpointOptionsExtensions.ConfigureEndpoints(ISiloHostBuilder builder Int32 siloPort Int32 gatewayPort AddressFamily addressFamily Boolean listenOnAnyHostAddress)
   at Kula1Orleans.SiloHost.Program.&lt;Main&gt;d__0.MoveNext() in /mnt/c/Users/piotr.kula/source/repos/Kula1Orleans/Kula1Orleans.SiloHost/Program.cs:line 17
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Kula1Orleans.SiloHost.Program.&lt;Main&gt;(String[] args)

```

There is a related issue on marked as BUG

https://github.com/dotnet/corefx/issues/22048

Any work around to get this working or should I not push my luck with WSL ?



</Description>
    <Title_Description>Running on dotnetcore on Windows Subsystem for Linux * Standard Ubuntu on Windows 10 **Windows Subsytem for Linux** (WSL )
* Installed dotnecore SDK as per 
* * https://www.microsoft.com/net/learn/get-started/linux/ubuntu16-04
* * Version 2.1.105
* Simple Hello world project compiled on the Ubuntu WSL using `dotnet restore` and `dotnet run`
* _Tested on Ubuntu 16.04 on Virtualbox and this does not happen. It is specific to WSL_

Project configuration for Silo which will not start

  ```
   var silo = new SiloHostBuilder()
               // Clustering information
               .Configure&lt;ClusterOptions&gt;(options =&gt;
               {
                   options.ClusterId = "my-first-cluster";
                    options.ServiceId = "MyAwesomeOrleansService";
               })
               // Clustering provider
               .UseAzureStorageClustering(options =&gt; options.ConnectionString = azureTableConnectionString)
               // Endpoints
               .ConfigureEndpoints(siloPort: Int32.Parse(args[1]) gatewayPort: Int32.Parse(args[2]))
               //.ConfigureEndpoints(siloPort: 11111 gatewayPort: 30000)
               // Now create the silo!
               .ConfigureLogging(logging =&gt; logging.AddConsole())
               .Build();
```

Exception Aggregate 

&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'
&gt; Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.

```
Unhandled Exception: System.AggregateException: One or more errors occurred. (An error was encountered while querying information from the operating system.) ---&gt; System.Net.NetworkInformation.NetworkInformationException: An error was encountered while querying information from the operating system. ---&gt; System.AggregateException: One or more errors occurred. (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) (Could not find a part of the path '/proc/sys/net/ipv4/conf/lo/forwarding'.) ---&gt; System.IO.DirectoryNotFoundException: Could not find a part of the path '/proc/sys/net/ipv4/conf/eth0/forwarding'.
   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo String path Boolean isDirectory Func`2 errorRewriter)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path OpenFlags flags Int32 mode)
   at System.IO.FileStream..ctor(String path FileMode mode FileAccess access FileShare share Int32 bufferSize FileOptions options)
   at System.IO.StreamReader..ctor(String path Encoding encoding Boolean detectEncodingFromByteOrderMarks Int32 bufferSize)
   at System.IO.StreamReader..ctor(String path Encoding encoding Boolean detectEncodingFromByteOrderMarks)
   at System.IO.File.InternalReadAllText(String path Encoding encoding)
   at System.IO.File.ReadAllText(String path)
   at System.Net.NetworkInformation.StringParsingHelpers.ParseRawIntFile(String filePath)
   at System.Net.NetworkInformation.LinuxIPv4InterfaceProperties.GetIsForwardingEnabled()
   at System.Net.NetworkInformation.LinuxIPv4InterfaceProperties..ctor(LinuxNetworkInterface linuxNetworkInterface)
   at System.Net.NetworkInformation.LinuxIPInterfaceProperties..ctor(LinuxNetworkInterface lni)
   at System.Net.NetworkInformation.LinuxNetworkInterface..ctor(String name)
   at System.Net.NetworkInformation.LinuxNetworkInterface.GetOrCreate(Dictionary`2 interfaces String name)
   at System.Net.NetworkInformation.LinuxNetworkInterface.&lt;&gt;c__DisplayClass5_0.&lt;GetLinuxNetworkInterfaces&gt;b__2(String name LinkLayerAddressInfo* llAddr)
   --- End of inner exception stack trace ---
   --- End of inner exception stack trace ---
   at System.Net.NetworkInformation.LinuxNetworkInterface.GetLinuxNetworkInterfaces()
   at Orleans.Runtime.Configuration.ConfigUtilities.&lt;ResolveIPAddress&gt;d__18.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at Orleans.Hosting.EndpointOptionsExtensions.ConfigureEndpoints(ISiloHostBuilder builder Int32 siloPort Int32 gatewayPort AddressFamily addressFamily Boolean listenOnAnyHostAddress)
   at Kula1Orleans.SiloHost.Program.&lt;Main&gt;d__0.MoveNext() in /mnt/c/Users/piotr.kula/source/repos/Kula1Orleans/Kula1Orleans.SiloHost/Program.cs:line 17
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Kula1Orleans.SiloHost.Program.&lt;Main&gt;(String[] args)

```

There is a related issue on marked as BUG

https://github.com/dotnet/corefx/issues/22048

Any work around to get this working or should I not push my luck with WSL ?



</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4519</IssueLabelID>
    <Title>Feature request: IActivationFilter</Title>
    <Description>In obit you have this extension interface: https://github.com/orbit/orbit/blob/master/actors/core/src/main/java/cloud/orbit/actors/extensions/LifetimeExtension.java 

I thing it would be great to introduce IActionFilter with a similar signature to IIncomingGrainCallFilter.

Use cases:

1. Custom storage solutions
2. Logging
3. Exception handling
4. Integration to Orleans Dashboard</Description>
    <Title_Description>Feature request: IActivationFilter In obit you have this extension interface: https://github.com/orbit/orbit/blob/master/actors/core/src/main/java/cloud/orbit/actors/extensions/LifetimeExtension.java 

I thing it would be great to introduce IActionFilter with a similar signature to IIncomingGrainCallFilter.

Use cases:

1. Custom storage solutions
2. Logging
3. Exception handling
4. Integration to Orleans Dashboard</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4518</IssueLabelID>
    <Title>[2.0] Grain inherits IGrainWithStringKey  but IsPrimaryKeyBasedOnLong returns True </Title>
    <Description>  Grain inherits IGrainWithStringKey  but IsPrimaryKeyBasedOnLong returns True .
@ReubenBond @sergeybykov 

![image](https://user-images.githubusercontent.com/28291464/39353879-87ffcd2c-4a3b-11e8-84c6-e5e65bda53e7.png)
</Description>
    <Title_Description>[2.0] Grain inherits IGrainWithStringKey , but IsPrimaryKeyBasedOnLong returns True    Grain inherits IGrainWithStringKey  but IsPrimaryKeyBasedOnLong returns True .
@ReubenBond @sergeybykov 

![image](https://user-images.githubusercontent.com/28291464/39353879-87ffcd2c-4a3b-11e8-84c6-e5e65bda53e7.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4517</IssueLabelID>
    <Title>Enabling DeadlockDetection will cause an Exception</Title>
    <Description>This file should be move to Orleans.Runtime.Abstraction/Messaging. Otherwise when DetectDeadlock is enabled it will get an exception

`
"Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved. at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in E:\Perforce\luxiang_dev_backend\Code\CryCloud\Scheduler\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425 at 
`
https://github.com/dotnet/orleans/blob/426a4b4c09a23b5e99a87700c6b496bfb8c07154/src/Orleans.Runtime/Messaging/RequestInvocationHistory.cs#L7</Description>
    <Title_Description>Enabling DeadlockDetection will cause an Exception This file should be move to Orleans.Runtime.Abstraction/Messaging. Otherwise when DetectDeadlock is enabled it will get an exception

`
"Orleans.Runtime.RequestInvocationHistory" is invalid: Type string "Orleans.Runtime.RequestInvocationHistory" cannot be resolved. at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager) in E:\Perforce\luxiang_dev_backend\Code\CryCloud\Scheduler\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs:line 425 at 
`
https://github.com/dotnet/orleans/blob/426a4b4c09a23b5e99a87700c6b496bfb8c07154/src/Orleans.Runtime/Messaging/RequestInvocationHistory.cs#L7</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4515</IssueLabelID>
    <Title>Non static statistics: Round 1</Title>
    <Description>Note that this is based upon #4509
Fixes #4499

Submitting for CI testing but it passed in VSO already.

This starts the process of removing statics from the statistics system. It doesn't complete the process but it is already enough to fix initialization order problems like we see in #4499.</Description>
    <Title_Description>Non static statistics: Round 1 Note that this is based upon #4509
Fixes #4499

Submitting for CI testing but it passed in VSO already.

This starts the process of removing statics from the statistics system. It doesn't complete the process but it is already enough to fix initialization order problems like we see in #4499.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4509</IssueLabelID>
    <Title>Consolidate SiloStatisticsOptions and ClientStatisticsOptions</Title>
    <Description>The options system doesn't handle inheritance.
The divide between `SiloStatisticsOptions` and `ClientStatisticsOptions` complicates things unnecessarily.

Also split out `DeploymentLoadPublishingOptions`</Description>
    <Title_Description>Consolidate SiloStatisticsOptions and ClientStatisticsOptions The options system doesn't handle inheritance.
The divide between `SiloStatisticsOptions` and `ClientStatisticsOptions` complicates things unnecessarily.

Also split out `DeploymentLoadPublishingOptions`</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4508</IssueLabelID>
    <Title>Fix Exception thrown in MembershipOracle.TryToSuspectOrKill</Title>
    <Description>Related issue: #4507 

This is the bare minimum fix to avoid any exception at runtime because of logging in Orleans. We will need to do several passes to remove entirely numbered format string.</Description>
    <Title_Description>Fix Exception thrown in MembershipOracle.TryToSuspectOrKill Related issue: #4507 

This is the bare minimum fix to avoid any exception at runtime because of logging in Orleans. We will need to do several passes to remove entirely numbered format string.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4507</IssueLabelID>
    <Title>Exception thrown in MembershipOracle.TryToSuspectOrKill when debug level set to Debug</Title>
    <Description>The following line is incorrect:

``` csharp
if (logger.IsEnabled(LogLevel.Debug)) logger.Debug("-TryToSuspectOrKill {0}: The current status of {0} in the table is {1} its entry is {2}" entry.SiloAddress.ToLongString() entry.Status entry.ToFullString());
````

The parameter `format` does not follow the behavior of `String.Format` so it will throw an exception "System.FormatException : Index (zero based) must be greater than or equal to zero and less than the size of the argument list".

Format should respect this format: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.1&amp;tabs=aspnetcore2x#log-message-template

We need to do a pass in Orleans codebase to see if we did the same mistake in other places.
</Description>
    <Title_Description>Exception thrown in MembershipOracle.TryToSuspectOrKill when debug level set to Debug The following line is incorrect:

``` csharp
if (logger.IsEnabled(LogLevel.Debug)) logger.Debug("-TryToSuspectOrKill {0}: The current status of {0} in the table is {1} its entry is {2}" entry.SiloAddress.ToLongString() entry.Status entry.ToFullString());
````

The parameter `format` does not follow the behavior of `String.Format` so it will throw an exception "System.FormatException : Index (zero based) must be greater than or equal to zero and less than the size of the argument list".

Format should respect this format: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.1&amp;tabs=aspnetcore2x#log-message-template

We need to do a pass in Orleans codebase to see if we did the same mistake in other places.
</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>24/04/2018 10:23:28 PM +00:00</CreatedAt>
    <ClosedAt>5/06/2018 3:52:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4506</IssueLabelID>
    <Title>Metrics Documentation Community Effort</Title>
    <Description>The Orleans Telemetry interface outputs a lot of metrics. Some are crucial some are less useful (and it depends on your needs).

As it stands there is no centralized space where these are documented and one shouldn't have to do guesswork to figure out which metrics they need to track. Some are self explanatory (`Runtime.CpuUsage.Current`) but some if not most are not (`Grain.DBCloud.ActorCollection.MeasureScales.Grains.MeasureScaleProxyGrain.Current`). Explanation of units is a particular issue.

We are currently beginning to build our backend with Orleans and are carrying out investigations into which metrics are useful. This would work would be beneficial to others and we implore those who already track certain metrics on their projects to contribute.

## Proposal
The overall goal is to enrich the official docs with more information on telemetry and internal metrics.

- Provide an explanation for each metric (what it tracks units etc...)
- Provide a list of **recommended** (crucial)  and optional metrics to track
- Provide use-cases and examples of **custom metric** implementations

I am not sure what the best place for user submitted examples would be but it would be a great addition to have.

From a little digging around and mostly from #3065 we can start with this list of seemingly useful metrics:

`App.Requests.Latency.Average.Millis`
`App.Requests.LatencyHistogram.Millis`
`App.Requests.TimedOut.Current`
`Catalog.Activation.CurrentCount`
`Grain.*.Current` (quite a lot of these would be great to know more about this)
`Runtime.CpuUsage.Current`
`Runtime.GC.GenSizesKb`
`Runtime.GC.LargeObjectHeapSizeKb`
`Runtime.GC.PercentOfTimeInGC`
`Runtime.Memory.AvailableMemoryMb.Current`
`Runtime.Memory.TotalPhysicalMemoryMb.Current`
`Runtime.GC.TotalMemoryKb.Current`
`Runtime.Threads.AsynchAgent.TotalThreadsCreated.Current`
`Scheduler.NumLongRunningTurns.Current`
 
And I am including this definition from @sergeybykov as well:

&gt; In general Current is the latest value of the counter and Delta is the change in its value since the last time metrics were reported. By default metrics are reported every 5 minutes. So deltas give a rough idea of the counters' velocity.

also:

&gt; Storage.* counters except for .Latency simply count invocations of the corresponding methods and their failures.

It would be good to start providing worded definitions and units for these as most are relatively clear in their functionality. 

To stress once more this work would be greatly improved if it was a community effort 😃 **What is the best way/place to start contributing to this?**
________________________________________________________________________________________
</Description>
    <Title_Description>Metrics Documentation Community Effort The Orleans Telemetry interface outputs a lot of metrics. Some are crucial some are less useful (and it depends on your needs).

As it stands there is no centralized space where these are documented and one shouldn't have to do guesswork to figure out which metrics they need to track. Some are self explanatory (`Runtime.CpuUsage.Current`) but some if not most are not (`Grain.DBCloud.ActorCollection.MeasureScales.Grains.MeasureScaleProxyGrain.Current`). Explanation of units is a particular issue.

We are currently beginning to build our backend with Orleans and are carrying out investigations into which metrics are useful. This would work would be beneficial to others and we implore those who already track certain metrics on their projects to contribute.

## Proposal
The overall goal is to enrich the official docs with more information on telemetry and internal metrics.

- Provide an explanation for each metric (what it tracks units etc...)
- Provide a list of **recommended** (crucial)  and optional metrics to track
- Provide use-cases and examples of **custom metric** implementations

I am not sure what the best place for user submitted examples would be but it would be a great addition to have.

From a little digging around and mostly from #3065 we can start with this list of seemingly useful metrics:

`App.Requests.Latency.Average.Millis`
`App.Requests.LatencyHistogram.Millis`
`App.Requests.TimedOut.Current`
`Catalog.Activation.CurrentCount`
`Grain.*.Current` (quite a lot of these would be great to know more about this)
`Runtime.CpuUsage.Current`
`Runtime.GC.GenSizesKb`
`Runtime.GC.LargeObjectHeapSizeKb`
`Runtime.GC.PercentOfTimeInGC`
`Runtime.Memory.AvailableMemoryMb.Current`
`Runtime.Memory.TotalPhysicalMemoryMb.Current`
`Runtime.GC.TotalMemoryKb.Current`
`Runtime.Threads.AsynchAgent.TotalThreadsCreated.Current`
`Scheduler.NumLongRunningTurns.Current`
 
And I am including this definition from @sergeybykov as well:

&gt; In general Current is the latest value of the counter and Delta is the change in its value since the last time metrics were reported. By default metrics are reported every 5 minutes. So deltas give a rough idea of the counters' velocity.

also:

&gt; Storage.* counters except for .Latency simply count invocations of the corresponding methods and their failures.

It would be good to start providing worded definitions and units for these as most are relatively clear in their functionality. 

To stress once more this work would be greatly improved if it was a community effort 😃 **What is the best way/place to start contributing to this?**
________________________________________________________________________________________
</Title_Description>
    <Label>P2</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4505</IssueLabelID>
    <Title>Orleans gets slower over time</Title>
    <Description>Hi

it is a little bit vague but I have the impression that Orleans gets slower over time.

My specs are:

* .NET Core 2.0
* Running on Kubernetes in GCloud 2 Nodes/Silos
* Co-Hosted with ASP.NET Core

I have a very simple grain that just returns the snapshot (my own state system):

https://github.com/Squidex/squidex/blob/master/src/Squidex.Domain.Apps.Entities/Schemas/SchemaGrain.cs#L305

I use my own serializer with JSON.NET and my benchmarks show that the serialization takes 2-3 ms usually. I also tested it with 100x larger states that expected and the performance is great.

I added some profiling to the client side and I have experienced that the call takes 4-5 ms after I deploy it and several days later up to 200ms or even more (the max I have seen is 10seconds).

I also checked my MongoDB logs where I save all slow queries and there is nothing related.

I am a little bit lost.</Description>
    <Title_Description>Orleans gets slower over time Hi

it is a little bit vague but I have the impression that Orleans gets slower over time.

My specs are:

* .NET Core 2.0
* Running on Kubernetes in GCloud 2 Nodes/Silos
* Co-Hosted with ASP.NET Core

I have a very simple grain that just returns the snapshot (my own state system):

https://github.com/Squidex/squidex/blob/master/src/Squidex.Domain.Apps.Entities/Schemas/SchemaGrain.cs#L305

I use my own serializer with JSON.NET and my benchmarks show that the serialization takes 2-3 ms usually. I also tested it with 100x larger states that expected and the performance is great.

I added some profiling to the client side and I have experienced that the call takes 4-5 ms after I deploy it and several days later up to 200ms or even more (the max I have seen is 10seconds).

I also checked my MongoDB logs where I save all slow queries and there is nothing related.

I am a little bit lost.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4502</IssueLabelID>
    <Title>Archive transaction logs</Title>
    <Description>- Archive transaction logs
- Add minimum query API
- Add minimum testing on the feature


Since no enough information for me to know which queries will be most useful so I didn't add any specific query API just the general API which takes a `TableQuery`</Description>
    <Title_Description>Archive transaction logs - Archive transaction logs
- Add minimum query API
- Add minimum testing on the feature


Since no enough information for me to know which queries will be most useful so I didn't add any specific query API just the general API which takes a `TableQuery`</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4501</IssueLabelID>
    <Title>Orleans on Azure Container Instances?</Title>
    <Description>Is it possible to run Orleans on Azure Container Instances?

The main reason I would want to use Orleans is to save costs as something like Cosmos DB is very expensive. Here is a [quote](https://azure.com/e/513c4c8421424d0ebdb94b9dfc51b796) from the Azure pricing calculator comparing AKS to Azure Container Instances. Azure Container Instances is an order of magnitude cheaper.

My understanding is that it's not recommended to expose Orleans to the internet which is what you'd be doing if you used Azure Container Instances. I'm also not sure how you'd secure it.</Description>
    <Title_Description>Orleans on Azure Container Instances? Is it possible to run Orleans on Azure Container Instances?

The main reason I would want to use Orleans is to save costs as something like Cosmos DB is very expensive. Here is a [quote](https://azure.com/e/513c4c8421424d0ebdb94b9dfc51b796) from the Azure pricing calculator comparing AKS to Azure Container Instances. Azure Container Instances is an order of magnitude cheaper.

My understanding is that it's not recommended to expose Orleans to the internet which is what you'd be doing if you used Azure Container Instances. I'm also not sure how you'd secure it.</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4500</IssueLabelID>
    <Title>[2.0] Build-time Code Generation fails when referencing a project that contains service references.</Title>
    <Description>As above. With a library targeting .NET Standard 2.0 a grain interface project references a project that contains a service reference leading to the following build-time error:

```
13&gt;Orleans-CodeGen - Generating file C:\&lt;company&gt;\&lt;project&gt;.ExecutionGrains.Interfaces\obj\Debug\netstandard2.0\&lt;project&gt;.ExecutionGrains.Interfaces.orleans.g.cs
13&gt;warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
13&gt;      Exception loading types from assembly '&lt;project&gt;.Models Version=1.0.0.0 Culture=neutral PublicKeyToken=null':
13&gt;      Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13&gt;         at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13&gt;         at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13&gt;         at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution..
13&gt;System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13&gt;   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13&gt;   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13&gt;   at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13&gt;-- Code Generation FAILED --
13&gt;
13&gt;Exc level 0: System.ArgumentException: A BadImageFormatException has been thrown while parsing the signature. This is likely due to lack of a generic context. Ensure genericTypeArguments and genericMethodArguments are provided and contain enough context.
13&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
13&gt;   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
13&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
13&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type RuntimeType caType Boolean inherit)
13&gt;   at System.Attribute.GetCustomAttributes(MemberInfo element Type type Boolean inherit)
13&gt;   at System.Attribute.GetCustomAttribute(MemberInfo element Type attributeType Boolean inherit)
13&gt;   at System.Reflection.CustomAttributeExtensions.GetCustomAttribute[T](MemberInfo element)
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.AddSerializationTypes(SerializationTypeDescriptions serializationTypes Assembly targetAssembly List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 434
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateCode(Assembly targetAssembly List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 327
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateSourceForAssembly(Assembly input) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 162
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
13&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
13&gt;Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
13&gt;   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
13&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
13&gt;Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(765): error MSB3073: The command ""dotnet" "C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netstandard2.0\codegen\&lt;project&gt;.ExecutionGrains.Interfaces.orleans.g.args.txt"" exited with code 3.
13&gt;Done building project "&lt;project&gt;.ExecutionGrains.Interfaces.csproj" -- FAILED.
```</Description>
    <Title_Description>[2.0] Build-time Code Generation fails when referencing a project that contains service references. As above. With a library targeting .NET Standard 2.0 a grain interface project references a project that contains a service reference leading to the following build-time error:

```
13&gt;Orleans-CodeGen - Generating file C:\&lt;company&gt;\&lt;project&gt;.ExecutionGrains.Interfaces\obj\Debug\netstandard2.0\&lt;project&gt;.ExecutionGrains.Interfaces.orleans.g.cs
13&gt;warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
13&gt;      Exception loading types from assembly '&lt;project&gt;.Models Version=1.0.0.0 Culture=neutral PublicKeyToken=null':
13&gt;      Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13&gt;         at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13&gt;         at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13&gt;         at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;      Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;      Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution..
13&gt;System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
13&gt;   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
13&gt;   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
13&gt;   at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent2\_work\8\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
13&gt;-- Code Generation FAILED --
13&gt;
13&gt;Exc level 0: System.ArgumentException: A BadImageFormatException has been thrown while parsing the signature. This is likely due to lack of a generic context. Ensure genericTypeArguments and genericMethodArguments are provided and contain enough context.
13&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
13&gt;   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord MetadataImport scope Assembly&amp; lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object[] attributes IList derivedAttributes RuntimeType&amp; attributeType IRuntimeMethodInfo&amp; ctor Boolean&amp; ctorHasParameters Boolean&amp; isVarArg)
13&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule Int32 decoratedMetadataToken Int32 pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent)
13&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type RuntimeType caType Boolean inherit)
13&gt;   at System.Attribute.GetCustomAttributes(MemberInfo element Type type Boolean inherit)
13&gt;   at System.Attribute.GetCustomAttribute(MemberInfo element Type attributeType Boolean inherit)
13&gt;   at System.Reflection.CustomAttributeExtensions.GetCustomAttribute[T](MemberInfo element)
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.AddSerializationTypes(SerializationTypeDescriptions serializationTypes Assembly targetAssembly List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 434
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateCode(Assembly targetAssembly List`1 assemblies) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 327
13&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator.GenerateSourceForAssembly(Assembly input) in D:\build\agent2\_work\8\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 162
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly LogLevel logLevel)
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
13&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
13&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
13&gt;Exc level 1: System.BadImageFormatException: Could not load file or assembly 'System.ServiceModel.Primitives Version=4.5.0.0 Culture=neutral PublicKeyToken=cc7b13ffcd2ddd51'. Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context. (Exception from HRESULT: 0x80131058)
13&gt;   at System.ModuleHandle.ResolveType(RuntimeModule module Int32 typeToken IntPtr* typeInstArgs Int32 typeInstCount IntPtr* methodInstArgs Int32 methodInstCount ObjectHandleOnStack type)
13&gt;   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module Int32 typeToken RuntimeTypeHandle[] typeInstantiationContext RuntimeTypeHandle[] methodInstantiationContext)
13&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken Type[] genericTypeArguments Type[] genericMethodArguments)
13&gt;Exc level 2: System.BadImageFormatException: Cannot load a reference assembly for execution.
13&gt;C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(765): error MSB3073: The command ""dotnet" "C:\Users\user\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.0\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netstandard2.0\codegen\&lt;project&gt;.ExecutionGrains.Interfaces.orleans.g.args.txt"" exited with code 3.
13&gt;Done building project "&lt;project&gt;.ExecutionGrains.Interfaces.csproj" -- FAILED.
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4499</IssueLabelID>
    <Title>StatisticsLevel.Verbose causes serialization exceptions</Title>
    <Description>
- Orleans 2.0

**config:**
``` csharp
client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = clusterId;
        options.ServiceId = ServiceId.ToString();
    })
    .Configure&lt;ClientStatisticsOptions&gt;(options =&gt;
    {
        options.CollectionLevel = StatisticsLevel.Verbose;
    })
    .UseZooKeeperClustering((ZooKeeperGatewayListProviderOptions options) =&gt;
    {
        options.ConnectionString = zookeeper;
    })
    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ISampleGrain).Assembly))
    .ConfigureLogging(logging=&gt;logging.AddConsole())
    .Build();
```


**log:**
&gt; warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://10.0.1.18:10300/262055360[100159]                               
      Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360.                                      
System.NullReferenceException: Object reference not set to an instance of an object.                                            
   at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers SerializationContext context)
   at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
   at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
warn: Orleans.OutsideRuntimeClient[104202]                                                                                      
      Refresh the GrainTypeResolver failed. WIll be retried after                                                               
Orleans.Runtime.OrleansMessageRejectionException: Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360. System.NullReferenceException: Object reference not set to an instance of an object.
    at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers SerializationContext context)
    at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
    at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()                                                            
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)                            
    at Orleans.Runtime.OutgoingCallInvoker.&lt;Invoke&gt;d__21.MoveNext()     

                                                         </Description>
    <Title_Description>StatisticsLevel.Verbose causes serialization exceptions 
- Orleans 2.0

**config:**
``` csharp
client = new ClientBuilder()
    .Configure&lt;ClusterOptions&gt;(options =&gt;
    {
        options.ClusterId = clusterId;
        options.ServiceId = ServiceId.ToString();
    })
    .Configure&lt;ClientStatisticsOptions&gt;(options =&gt;
    {
        options.CollectionLevel = StatisticsLevel.Verbose;
    })
    .UseZooKeeperClustering((ZooKeeperGatewayListProviderOptions options) =&gt;
    {
        options.ConnectionString = zookeeper;
    })
    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ISampleGrain).Assembly))
    .ConfigureLogging(logging=&gt;logging.AddConsole())
    .Build();
```


**log:**
&gt; warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://10.0.1.18:10300/262055360[100159]                               
      Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360.                                      
System.NullReferenceException: Object reference not set to an instance of an object.                                            
   at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers SerializationContext context)
   at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
   at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
warn: Orleans.OutsideRuntimeClient[104202]                                                                                      
      Refresh the GrainTypeResolver failed. WIll be retried after                                                               
Orleans.Runtime.OrleansMessageRejectionException: Unexpected error serializing message to gateway gwy.tcp://10.0.1.18:10300/262055360. System.NullReferenceException: Object reference not set to an instance of an object.
    at Orleans.Serialization.SerializationManager.SerializeMessageHeaders(HeadersContainer headers SerializationContext context)
    at Orleans.Runtime.Message.Serialize(SerializationManager serializationManager Int32&amp; headerLengthOut Int32&amp; bodyLengthOut)
    at Orleans.Messaging.OutgoingMessageSender.Process(Message msg)                                                              
    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()                                                            
    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)                            
    at Orleans.Runtime.OutgoingCallInvoker.&lt;Invoke&gt;d__21.MoveNext()     

                                                         </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4498</IssueLabelID>
    <Title>[2.0] TestCluster .Deploy() / SiloHost.StartAsync().Wait() never return.</Title>
    <Description>Using Orleans 2.0 with .NET Core 2.0 I have a TestCluster set up as an xunit collection fixture:

```
    [CollectionDefinition("Orleans TestCluster")]
    public class OrleansTestHelperCollection : ICollectionFixture&lt;OrleansTestHelper&gt; { }


    public class OrleansTestHelper : IDisposable
    {
        public TestCluster Cluster { get; set; }
        
        public OrleansTestHelper()
        {
            var builder = new TestClusterBuilder(1);
            this.Cluster = builder.Build();
            Cluster.Deploy();
        }

        public void Dispose()
        {
            Cluster.StopAllSilos();
        }
    }
```

When debugging or executing the unit test the program will never move past Cluster.Deploy() - instead hanging indefinitely. The silo is created with the following logs:

```
[2018-04-20 10:18:47.259 GMT 12	Information	0	Orleans.Runtime.Scheduler.OrleansTaskScheduler]	Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.	
[2018-04-20 10:18:47.485 GMT 12	Information	100404	Orleans.Runtime.Silo]	Silo starting with GC settings: ServerGC=False GCLatencyMode=Interactive	
[2018-04-20 10:18:47.485 GMT 12	Warning	100405	Orleans.Runtime.Silo]	Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;	
[2018-04-20 10:18:47.485 GMT 12	Warning	100405	Orleans.Runtime.Silo]	Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).	
[2018-04-20 10:18:47.485 GMT 12	Information	100403	Orleans.Runtime.Silo]	-------------- Initializing silo on host OptikaLap37 MachineName OPTIKALAP37 at 127.0.0.1:27112 gen 261915527 --------------	
[2018-04-20 10:18:47.485 GMT 12	Information	100415	Orleans.Runtime.Silo]	Starting silo Primary	
[2018-04-20 10:18:47.616 GMT 12	Information	101010	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:27112	
[2018-04-20 10:18:47.650 GMT 12	Information	101010	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:43228	
[2018-04-20 10:18:47.717 GMT 12	Information	0	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	Starting VirtualBucketsRingProvider on silo S127.0.0.1:27112:261915527/x15AC0530.	
[2018-04-20 10:18:47.748 GMT 12	Information	103003	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	Added Server S127.0.0.1:27112:261915527/x15AC0530. Current view: [S127.0.0.1:27112:261915527 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]	
[2018-04-20 10:18:47.749 GMT 12	Information	103005	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	-NotifyLocalRangeSubscribers about old &lt;(0 0] Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True	
[2018-04-20 10:18:47.771 GMT 12	Information	0	Orleans.Runtime.Silo]	Skip multicluster oracle creation (no multicluster network configured)	
[2018-04-20 10:18:47.776 GMT 12	Information	100422	Orleans.Runtime.Silo]	-------------- Started silo S127.0.0.1:27112:261915527 ConsistentHashCode 15AC0530 --------------	
[2018-04-20 10:18:47.810 GMT 18	Information	0	Runtime.Scheduler.WorkerPoolThread/System.9]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.9 on managed thread 18	
[2018-04-20 10:18:47.810 GMT 20	Information	0	Runtime.Scheduler.WorkerPoolThread/1]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 on managed thread 20	
[2018-04-20 10:18:47.810 GMT 19	Information	0	Runtime.Scheduler.WorkerPoolThread/0]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 on managed thread 19	
[2018-04-20 10:18:47.810 GMT 22	Information	0	Runtime.Scheduler.WorkerPoolThread/3]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 on managed thread 22	
[2018-04-20 10:18:47.810 GMT 21	Information	0	Runtime.Scheduler.WorkerPoolThread/2]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 on managed thread 21	
[2018-04-20 10:18:47.812 GMT 23	Information	0	Runtime.Scheduler.WorkerPoolThread/4]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/4 on managed thread 23	
[2018-04-20 10:18:47.816 GMT 24	Information	0	Runtime.Scheduler.WorkerPoolThread/5]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/5 on managed thread 24	
[2018-04-20 10:18:47.817 GMT 12	Information	100452	Orleans.Runtime.Silo]	Start Scheduler took 25 Milliseconds to finish	
[2018-04-20 10:18:47.820 GMT 25	Information	0	Runtime.Scheduler.WorkerPoolThread/6]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/6 on managed thread 25	
[2018-04-20 10:18:47.823 GMT 26	Information	0	Runtime.Scheduler.WorkerPoolThread/7]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/7 on managed thread 26	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage -2147483648: Orleans.Runtime.SiloOptionsLogger	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 4000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 8000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 10000: Orleans.Runtime.Versions.GrainVersionStore	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 19999: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 20000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.868 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ActivationCountBasedPlacementOptions: 
ChooseOutOf: 2
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ClusterMembershipOptions: 
NumMissedTableIAmAliveLimit: 2
LivenessEnabled: True
ProbeTimeout: 00:00:10
TableRefreshTimeout: 00:01:00
DeathVoteExpirationTimeout: 00:02:00
IAmAliveTablePublishTimeout: 00:05:00
MaxJoinAttemptTime: 00:05:00
ExpectedClusterSize: 20
ValidateInitialConnectivity: True
UseLivenessGossip: True
NumProbedSilos: 3
NumMissedProbesLimit: 3
NumVotesForDeathDeclaration: 2
IsRunningAsUnitTest: False
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ConsistentRingOptions: 
NumVirtualBucketsConsistentRing: 30
UseVirtualBucketsConsistentRing: True
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.EndpointOptions: 
AdvertisedIPAddress: 127.0.0.1
SiloPort: 27112
GatewayPort: 43228
SiloListeningEndpoint: 
GatewayListeningEndpoint: 
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainCollectionOptions: 
CollectionQuantum: 00:01:00
CollectionAge: 02:00:00
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainDirectoryOptions: 
CachingStrategy: Adaptive
CacheSize: 1000000
InitialCacheTTL: 00:00:30
MaximumCacheTTL: 00:04:00
CacheTTLExtensionFactor: 2
LazyDeregistrationDelay: 00:01:00
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainVersioningOptions: 
DefaultCompatibilityStrategy: BackwardCompatible
DefaultVersionSelectorStrategy: AllCompatibleVersions
	
[2018-04-20 10:18:47.873 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.LoadSheddingOptions: 
LoadSheddingEnabled: False
LoadSheddingLimit: 95
	
[2018-04-20 10:18:47.873 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.MultiClusterOptions: 
HasMultiClusterNetwork: False
MaxMultiClusterGateways: 10
BackgroundGossipInterval: 00:00:30
UseGlobalSingleInstanceByDefault: True
GlobalSingleInstanceNumberRetries: 10
GlobalSingleInstanceRetryInterval: 00:00:30
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.NetworkingOptions: 
OpenConnectionTimeout: 00:00:05
MaxSocketAge: 10675199.02:48:05.4775807
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.PerformanceTuningOptions: 
DefaultConnectionLimit: 200
Expect100Continue: False
UseNagleAlgorithm: False
MinDotNetThreadPoolSize: 200
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ProcessExitHandlingOptions: 
FastKillOnProcessExit: True
	
[2018-04-20 10:18:47.875 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SchedulingOptions: 
PerformDeadlockDetection: False
AllowCallChainReentrancy: True
MaxActiveThreads: 8
DelayWarningThreshold: 00:00:10
ActivationSchedulingQuantum: 00:00:00.1000000
TurnWarningLengthThreshold: 00:00:00.2000000
MaxPendingWorkItemsSoftLimit: 0
MaxPendingWorkItemsHardLimit: 0
EnableWorkerThreadInjection: False
	
[2018-04-20 10:18:47.875 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SerializationProviderOptions: 
FallbackSerializationProvider: 
	
[2018-04-20 10:18:47.877 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloMessagingOptions: 
SiloSenderQueues: 8
GatewaySenderQueues: 8
MaxForwardCount: 2
ClientDropTimeout: 00:01:00
ClientRegistrationRefresh: 00:05:00
MaxEnqueuedRequestsSoftLimit: 0
MaxEnqueuedRequestsHardLimit: 0
MaxEnqueuedRequestsSoftLimit_StatelessWorker: 0
MaxEnqueuedRequestsHardLimit_StatelessWorker: 0
MaxRequestProcessingTime: 02:00:00
AssumeHomogenousSilosForTesting: False
ResponseTimeout: 00:30:00
ResponseTimeoutWithDebugger: 00:30:00
MaxResendCount: 0
ResendOnTimeout: False
DropExpiredMessages: True
BufferPoolBufferSize: 4096
BufferPoolMaxSize: 10000
BufferPoolPreallocationSize: 250
PropagateActivityId: False
	
[2018-04-20 10:18:47.877 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloOptions: 
SiloName: Primary
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloStatisticsOptions: 
DeploymentLoadPublisherRefreshTime: 00:00:01
PerfCountersWriteInterval: 00:00:30
LogWriteInterval: 00:05:00
CollectionLevel: Info
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.TelemetryOptions: 
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.TypeManagementOptions: 
TypeMapRefreshInterval: 00:01:00
	
[2018-04-20 10:18:47.878 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.SiloOptionsLogger started in stage -2147483648 which took 23 Milliseconds.	
[2018-04-20 10:18:47.878 GMT 26	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage -2147483648 took 27 Milliseconds	
[2018-04-20 10:18:47.881 GMT 8	Information	100401	Orleans.Runtime.Silo]	Silo Start()	
[2018-04-20 10:18:47.883 GMT 8	Information	100430	Orleans.Runtime.Silo]	Configured ThreadPool.SetMinThreads() to values: 200200. Previous values are: 88.	
[2018-04-20 10:18:47.883 GMT 8	Information	100436	Orleans.Runtime.Silo]	Configured .NET ServicePointManager to Expect100Continue=False DefaultConnectionLimit=200 UseNagleAlgorithm=False to improve Azure storage performance.	
[2018-04-20 10:18:47.883 GMT 8	Information	100452	Orleans.Runtime.Silo]	ConfigureThreadPoolAndServicePointSettings took 2 Milliseconds to finish	
[2018-04-20 10:18:47.887 GMT 26	Information	101711	Orleans.Runtime.GrainTypeManager]	Loaded grain type summary for 9 types: 
Grain class Orleans.Providers.Orleans.Providers.MemoryStreamQueueGrain [1359359215 (0x51062CEF)] from OrleansProviders.dll implementing interfaces: Orleans.Providers.IMemoryStreamQueueGrain [1158152105 (0x4507FFA9)]
Grain class Orleans.Runtime.Development.Orleans.Runtime.Development.DevelopmentLeaseProviderGrain [940524075 (0x380F422B)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.Development.IDevelopmentLeaseProviderGrain [-1234611069 (0xB6695483)]
Grain class Orleans.Runtime.Management.Orleans.Runtime.Management.ManagementGrain [1954798034 (0x7483D9D2)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.IManagementGrain [-1734666656 (0x989B1660)]
Grain class Orleans.Runtime.MembershipService.Orleans.Runtime.MembershipService.GrainBasedMembershipTableGrain [388921186 (0x172E7762)] from Orleans.Runtime.dll implementing interfaces: Orleans.IMembershipTableGrain [-1256503757 (0xB51B4633)]
Grain class Orleans.Runtime.ReminderService.Orleans.Runtime.ReminderService.GrainBasedReminderTable [-55315191 (0xFCB3F509)] from Orleans.Runtime.dll implementing interfaces: Orleans.IReminderTableGrain [-1135060418 (0xBC585A3E)]
Grain class Orleans.Runtime.Versions.Orleans.Runtime.Versions.VersionStoreGrain [331003096 (0x13BAB4D8)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.Versions.IVersionStoreGrain [-297600501 (0xEE42FA0B)] Orleans.IGrainWithStringKey [-1277021679 (0xB3E23211)]
Grain class Orleans.Storage.Orleans.Storage.MemoryStorageGrain [819348208 (0x30D642F0)] from OrleansProviders.dll implementing interfaces: Orleans.Storage.IMemoryStorageGrain [577125491 (0x22663C73)]
Grain class Orleans.Streams.Orleans.Streams.PubSubRendezvousGrain [1903070868 (0x716E8E94)] from Orleans.Runtime.dll implementing interfaces: Orleans.Streams.IPubSubRendezvousGrain [1746702088 (0x681C8F08)]
Grain class Orleans.TestingHost.Orleans.TestingHost.StorageFaultGrain [165808213 (0x9E20855)] from Orleans.TestingHost.dll implementing interfaces: Orleans.TestingHost.IStorageFaultGrain [-1063077025 (0xC0A2BB5F)] Orleans.IGrainWithStringKey [-1277021679 (0xB3E23211)]
	
[2018-04-20 10:18:47.891 GMT 26	Information	100452	Orleans.Runtime.InsideRuntimeClient]	Start InsideRuntimeClient took 8 Milliseconds	
[2018-04-20 10:18:47.891 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.InsideRuntimeClient started in stage 2000 which took 9 Milliseconds.	
[2018-04-20 10:18:47.893 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 2000 which took 14 Milliseconds.	
[2018-04-20 10:18:47.893 GMT 26	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 2000 took 14 Milliseconds	
[2018-04-20 10:18:47.900 GMT 27	Information	0	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAcceptor on managed thread 27	
[2018-04-20 10:18:47.901 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start Message center took 4 Milliseconds to finish	
[2018-04-20 10:18:47.904 GMT 28	Information	0	Runtime.Messaging.SiloMessageSender/PingSender]	Starting AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender on managed thread 28	
[2018-04-20 10:18:47.907 GMT 29	Information	0	Runtime.Messaging.SiloMessageSender/SystemSender]	Starting AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender on managed thread 29	
[2018-04-20 10:18:47.909 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start Incoming message agents took 6 Milliseconds to finish	
[2018-04-20 10:18:47.913 GMT 30	Information	0	Runtime.Messaging.IncomingMessageAgent/Ping]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Ping on managed thread 30	
[2018-04-20 10:18:47.913 GMT 31	Information	0	Runtime.Messaging.IncomingMessageAgent/System]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/System on managed thread 31	
[2018-04-20 10:18:47.915 GMT 32	Information	0	Runtime.Messaging.IncomingMessageAgent/Application]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Application on managed thread 32	
[2018-04-20 10:18:47.915 GMT 8	Information	0	Orleans.Runtime.GrainDirectory.LocalGrainDirectory]	Start	
[2018-04-20 10:18:47.916 GMT 27	Information	100328	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Stopping AsyncAgent Runtime.Messaging.IncomingMessageAcceptor that runs on managed thread 27	
[2018-04-20 10:18:47.917 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start local grain directory took 7 Milliseconds to finish	
[2018-04-20 10:18:47.920 GMT 33	Information	0	Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1]	Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 33	
[2018-04-20 10:18:47.922 GMT 34	Information	0	Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer]	Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 34	
[2018-04-20 10:18:47.931 GMT 8	Information	100452	Orleans.Runtime.Silo]	Init implicit stream subscribe table took 11 Milliseconds to finish	
[2018-04-20 10:18:47.931 GMT 34	Information	100328	Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer]	Stopping AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer that runs on managed thread 34	
[2018-04-20 10:18:47.983 GMT 10	Information	100452	Orleans.Runtime.Silo]	Create system targets and inject dependencies took 46 Milliseconds to finish	
[2018-04-20 10:18:48.000 GMT 20	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 107 Milliseconds.	
[2018-04-20 10:18:48.000 GMT 20	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 4000 took 107 Milliseconds	
[2018-04-20 10:18:48.012 GMT 13	Information	100452	Orleans.Runtime.Silo]	Init transaction agent took 4 Milliseconds to finish	
[2018-04-20 10:18:48.016 GMT 13	Information	100452	Orleans.Runtime.Silo]	Init grain services took 2 Milliseconds to finish	
[2018-04-20 10:18:48.017 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#1: memory=12MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:18:48.020 GMT 18	Information	100508	Orleans.Runtime.Catalog]	After collection#1: memory=12MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0104148.	
[2018-04-20 10:18:48.022 GMT 22	Information	100603	Orleans.Runtime.MembershipService.MembershipOracleData]	MembershipOracle starting on host = OptikaLap37 address = S127.0.0.1:27112:261915527 at 2018-04-20 10:18:47.280 GMT backOffMax = 00:00:20	
[2018-04-20 10:18:48.027 GMT 22	Information	100635	Orleans.Runtime.MembershipService.GrainBasedMembershipTable]	Creating membership table grain	
[2018-04-20 10:18:48.091 GMT 24	Information	100637	Orleans.Runtime.MembershipService.GrainBasedMembershipTableGrain]	GrainBasedMembershipTable Activated.	
[2018-04-20 10:18:48.091 GMT 24	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 2000 took 1 Milliseconds	
[2018-04-20 10:18:48.199 GMT 18	Information	100631	Orleans.Runtime.MembershipService.GrainBasedMembershipTable]	-Connected to membership table provider.	
[2018-04-20 10:18:52.788 GMT 18	Information	100652	Orleans.Runtime.MembershipService.MembershipOracleData]	-CleanupTable called on silo startup. Membership table 0 silos 0 are Active 0 are Dead Version=&lt;0 0&gt;. All silos: []	
[2018-04-20 10:18:52.862 GMT 18	Information	100660	Orleans.Runtime.MembershipService.MembershipOracleData]	Starting IAmAliveUpdateTimer.	
[2018-04-20 10:18:52.873 GMT 16	Information	100452	Orleans.Runtime.Silo]	Starting local silo status oracle took 4857 Milliseconds to finish	
[2018-04-20 10:18:52.883 GMT 25	Information	0	Orleans.Runtime.TypeManager]	OnRefreshClusterMapTimer: refresh start	
[2018-04-20 10:18:52.886 GMT 8	Information	100452	Orleans.Runtime.Silo]	Init type manager took 12 Milliseconds to finish	
[2018-04-20 10:18:52.887 GMT 8	Information	100702	Orleans.Runtime.CounterStatistic]	Starting Windows perf counter stats collection with frequency=00:00:30	
[2018-04-20 10:18:52.887 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start silo statistics took 1 Milliseconds to finish	
[2018-04-20 10:18:52.893 GMT 18	Information	0	Orleans.Runtime.DeploymentLoadPublisher]	Starting DeploymentLoadPublisher.	
[2018-04-20 10:18:52.905 GMT 18	Information	0	Orleans.Runtime.DeploymentLoadPublisher]	Started DeploymentLoadPublisher.	
[2018-04-20 10:18:52.905 GMT 10	Information	100452	Orleans.Runtime.Silo]	Start deployment load collector took 18 Milliseconds to finish	
[2018-04-20 10:18:52.906 GMT 10	Information	0	Orleans.Runtime.Watchdog]	Starting Silo Watchdog.	
[2018-04-20 10:18:52.917 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 8000 which took 4916 Milliseconds.	
[2018-04-20 10:18:52.917 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 8000 took 4917 Milliseconds	
[2018-04-20 10:18:52.920 GMT 35	Information	0	Runtime.Watchdog]	Starting AsyncAgent Runtime.Watchdog on managed thread 35	
[2018-04-20 10:18:52.920 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore started in stage 10000 which took 2 Milliseconds.	
[2018-04-20 10:18:52.920 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 10000 took 2 Milliseconds	
[2018-04-20 10:18:52.928 GMT 14	Information	100452	Orleans.Runtime.Silo]	Start gateway took 5 Milliseconds to finish	
[2018-04-20 10:18:52.953 GMT 36	Information	0	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Starting AsyncAgent Runtime.Messaging.GatewayAcceptor on managed thread 36	
[2018-04-20 10:18:52.953 GMT 37	Information	0	Runtime.Messaging.GatewayClientCleanupAgent]	Starting AsyncAgent Runtime.Messaging.GatewayClientCleanupAgent on managed thread 37	
[2018-04-20 10:18:52.953 GMT 36	Information	100328	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Stopping AsyncAgent Runtime.Messaging.GatewayAcceptor that runs on managed thread 36	
[2018-04-20 10:18:52.965 GMT 18	Information	100604	Orleans.Runtime.MembershipService.MembershipOracleData]	-BecomeActive	
[2018-04-20 10:18:52.971 GMT 18	Information	100614	Orleans.Runtime.MembershipService.MembershipOracleData]	About to send pings to 0 nodes in order to validate communication in the Joining state. Pinged nodes = []	
[2018-04-20 10:18:52.981 GMT 18	Information	100634	Orleans.Runtime.MembershipService.MembershipOracleData]	-ReadAll (called from BecomeActive) Membership table 1 silos 1 are Active 0 are Dead Version=&lt;2 5&gt;. All silos: [SiloAddress=S127.0.0.1:27112:261915527 SiloName=Primary Status=Active]	
[2018-04-20 10:18:52.982 GMT 18	Information	100605	Orleans.Runtime.MembershipService.MembershipOracleData]	-Finished BecomeActive.	
[2018-04-20 10:18:52.983 GMT 8	Information	100452	Orleans.Runtime.Silo]	Starting local silo status oracle took 54 Milliseconds to finish	
[2018-04-20 10:18:52.983 GMT 25	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 19999 which took 62 Milliseconds.	
[2018-04-20 10:18:52.983 GMT 25	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 19999 took 62 Milliseconds	
[2018-04-20 10:18:52.997 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 20000 which took 14 Milliseconds.	
[2018-04-20 10:18:52.997 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 20000 took 14 Milliseconds	
[2018-04-20 10:19:48.025 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#2: memory=12MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:19:48.027 GMT 18	Information	100508	Orleans.Runtime.Catalog]	After collection#2: memory=12MB #activations=1 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0020846.	
[2018-04-20 10:19:52.885 GMT 18	Information	0	Orleans.Runtime.TypeManager]	OnRefreshClusterMapTimer: refresh start	
[2018-04-20 10:20:48.032 GMT 22	Information	100507	Orleans.Runtime.Catalog]	Before collection#3: memory=13MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:20:48.032 GMT 22	Information	100508	Orleans.Runtime.Catalog]	After collection#3: memory=13MB #activations=1 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0004580.	
[2018-04-20 10:21:48.042 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#4: memory=14MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	

```

I have tried:
- Using an ADONET provider for clustering (created tables and registered properly but also did not progress)
- Manually setting BaseSilo/GatewayPort
- Moving the code out of the xunit fixture
- Moving the code out of the xunit fixture and using DeployAsync() instead
- Changing the number of silos initially created
- Probably a number of other things.

None of it worked - still hangs on Deploy(). I'm also unable to step into Deploy() to see where it's getting hung up even though I have the pdbs loaded.

EDIT:

The same issue also occurs using the start SiloHost/Client functions:

```
var builder = new SiloHostBuilder();
            builder.UseLocalhostClustering();
            builder.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AkumenGrain).Assembly).WithCodeGeneration());
            builder.ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Debug).AddDebug());
            SiloHost = builder.Build();

            // start the silo
            SiloHost.StartAsync().Wait();

            var clientBuilder = new ClientBuilder();
            clientBuilder.UseLocalhostClustering();
            clientBuilder.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AkumenGrain).Assembly).WithCodeGeneration());
            builder.ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Debug).AddDebug());
            Client = clientBuilder.Build();

            // start the client
            Client.Connect().Wait();
```

As per @ReubenBond's suggestion changing it to `Task.Run(() =&gt; SiloHost.StartAsync()).Wait();` allows it to continue successfully.</Description>
    <Title_Description>[2.0] TestCluster .Deploy() / SiloHost.StartAsync().Wait() never return. Using Orleans 2.0 with .NET Core 2.0 I have a TestCluster set up as an xunit collection fixture:

```
    [CollectionDefinition("Orleans TestCluster")]
    public class OrleansTestHelperCollection : ICollectionFixture&lt;OrleansTestHelper&gt; { }


    public class OrleansTestHelper : IDisposable
    {
        public TestCluster Cluster { get; set; }
        
        public OrleansTestHelper()
        {
            var builder = new TestClusterBuilder(1);
            this.Cluster = builder.Build();
            Cluster.Deploy();
        }

        public void Dispose()
        {
            Cluster.StopAllSilos();
        }
    }
```

When debugging or executing the unit test the program will never move past Cluster.Deploy() - instead hanging indefinitely. The silo is created with the following logs:

```
[2018-04-20 10:18:47.259 GMT 12	Information	0	Orleans.Runtime.Scheduler.OrleansTaskScheduler]	Starting OrleansTaskScheduler with 8 Max Active application Threads and 1 system thread.	
[2018-04-20 10:18:47.485 GMT 12	Information	100404	Orleans.Runtime.Silo]	Silo starting with GC settings: ServerGC=False GCLatencyMode=Interactive	
[2018-04-20 10:18:47.485 GMT 12	Warning	100405	Orleans.Runtime.Silo]	Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;	
[2018-04-20 10:18:47.485 GMT 12	Warning	100405	Orleans.Runtime.Silo]	Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).	
[2018-04-20 10:18:47.485 GMT 12	Information	100403	Orleans.Runtime.Silo]	-------------- Initializing silo on host OptikaLap37 MachineName OPTIKALAP37 at 127.0.0.1:27112 gen 261915527 --------------	
[2018-04-20 10:18:47.485 GMT 12	Information	100415	Orleans.Runtime.Silo]	Starting silo Primary	
[2018-04-20 10:18:47.616 GMT 12	Information	101010	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:27112	
[2018-04-20 10:18:47.650 GMT 12	Information	101010	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:43228	
[2018-04-20 10:18:47.717 GMT 12	Information	0	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	Starting VirtualBucketsRingProvider on silo S127.0.0.1:27112:261915527/x15AC0530.	
[2018-04-20 10:18:47.748 GMT 12	Information	103003	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	Added Server S127.0.0.1:27112:261915527/x15AC0530. Current view: [S127.0.0.1:27112:261915527 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]	
[2018-04-20 10:18:47.749 GMT 12	Information	103005	Orleans.Runtime.ConsistentRing.VirtualBucketsRingProvider]	-NotifyLocalRangeSubscribers about old &lt;(0 0] Size=x100000000 %Ring=100.000%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True	
[2018-04-20 10:18:47.771 GMT 12	Information	0	Orleans.Runtime.Silo]	Skip multicluster oracle creation (no multicluster network configured)	
[2018-04-20 10:18:47.776 GMT 12	Information	100422	Orleans.Runtime.Silo]	-------------- Started silo S127.0.0.1:27112:261915527 ConsistentHashCode 15AC0530 --------------	
[2018-04-20 10:18:47.810 GMT 18	Information	0	Runtime.Scheduler.WorkerPoolThread/System.9]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/System.9 on managed thread 18	
[2018-04-20 10:18:47.810 GMT 20	Information	0	Runtime.Scheduler.WorkerPoolThread/1]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/1 on managed thread 20	
[2018-04-20 10:18:47.810 GMT 19	Information	0	Runtime.Scheduler.WorkerPoolThread/0]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/0 on managed thread 19	
[2018-04-20 10:18:47.810 GMT 22	Information	0	Runtime.Scheduler.WorkerPoolThread/3]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/3 on managed thread 22	
[2018-04-20 10:18:47.810 GMT 21	Information	0	Runtime.Scheduler.WorkerPoolThread/2]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/2 on managed thread 21	
[2018-04-20 10:18:47.812 GMT 23	Information	0	Runtime.Scheduler.WorkerPoolThread/4]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/4 on managed thread 23	
[2018-04-20 10:18:47.816 GMT 24	Information	0	Runtime.Scheduler.WorkerPoolThread/5]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/5 on managed thread 24	
[2018-04-20 10:18:47.817 GMT 12	Information	100452	Orleans.Runtime.Silo]	Start Scheduler took 25 Milliseconds to finish	
[2018-04-20 10:18:47.820 GMT 25	Information	0	Runtime.Scheduler.WorkerPoolThread/6]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/6 on managed thread 25	
[2018-04-20 10:18:47.823 GMT 26	Information	0	Runtime.Scheduler.WorkerPoolThread/7]	Starting AsyncAgent Runtime.Scheduler.WorkerPoolThread/7 on managed thread 26	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage -2147483648: Orleans.Runtime.SiloOptionsLogger	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 4000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 8000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 10000: Orleans.Runtime.Versions.GrainVersionStore	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 19999: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.845 GMT 26	Information	100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 20000: Orleans.Runtime.Silo	
[2018-04-20 10:18:47.868 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ActivationCountBasedPlacementOptions: 
ChooseOutOf: 2
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ClusterMembershipOptions: 
NumMissedTableIAmAliveLimit: 2
LivenessEnabled: True
ProbeTimeout: 00:00:10
TableRefreshTimeout: 00:01:00
DeathVoteExpirationTimeout: 00:02:00
IAmAliveTablePublishTimeout: 00:05:00
MaxJoinAttemptTime: 00:05:00
ExpectedClusterSize: 20
ValidateInitialConnectivity: True
UseLivenessGossip: True
NumProbedSilos: 3
NumMissedProbesLimit: 3
NumVotesForDeathDeclaration: 2
IsRunningAsUnitTest: False
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ConsistentRingOptions: 
NumVirtualBucketsConsistentRing: 30
UseVirtualBucketsConsistentRing: True
	
[2018-04-20 10:18:47.870 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.EndpointOptions: 
AdvertisedIPAddress: 127.0.0.1
SiloPort: 27112
GatewayPort: 43228
SiloListeningEndpoint: 
GatewayListeningEndpoint: 
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainCollectionOptions: 
CollectionQuantum: 00:01:00
CollectionAge: 02:00:00
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainDirectoryOptions: 
CachingStrategy: Adaptive
CacheSize: 1000000
InitialCacheTTL: 00:00:30
MaximumCacheTTL: 00:04:00
CacheTTLExtensionFactor: 2
LazyDeregistrationDelay: 00:01:00
	
[2018-04-20 10:18:47.872 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.GrainVersioningOptions: 
DefaultCompatibilityStrategy: BackwardCompatible
DefaultVersionSelectorStrategy: AllCompatibleVersions
	
[2018-04-20 10:18:47.873 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.LoadSheddingOptions: 
LoadSheddingEnabled: False
LoadSheddingLimit: 95
	
[2018-04-20 10:18:47.873 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.MultiClusterOptions: 
HasMultiClusterNetwork: False
MaxMultiClusterGateways: 10
BackgroundGossipInterval: 00:00:30
UseGlobalSingleInstanceByDefault: True
GlobalSingleInstanceNumberRetries: 10
GlobalSingleInstanceRetryInterval: 00:00:30
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.NetworkingOptions: 
OpenConnectionTimeout: 00:00:05
MaxSocketAge: 10675199.02:48:05.4775807
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.PerformanceTuningOptions: 
DefaultConnectionLimit: 200
Expect100Continue: False
UseNagleAlgorithm: False
MinDotNetThreadPoolSize: 200
	
[2018-04-20 10:18:47.874 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.ProcessExitHandlingOptions: 
FastKillOnProcessExit: True
	
[2018-04-20 10:18:47.875 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SchedulingOptions: 
PerformDeadlockDetection: False
AllowCallChainReentrancy: True
MaxActiveThreads: 8
DelayWarningThreshold: 00:00:10
ActivationSchedulingQuantum: 00:00:00.1000000
TurnWarningLengthThreshold: 00:00:00.2000000
MaxPendingWorkItemsSoftLimit: 0
MaxPendingWorkItemsHardLimit: 0
EnableWorkerThreadInjection: False
	
[2018-04-20 10:18:47.875 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SerializationProviderOptions: 
FallbackSerializationProvider: 
	
[2018-04-20 10:18:47.877 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloMessagingOptions: 
SiloSenderQueues: 8
GatewaySenderQueues: 8
MaxForwardCount: 2
ClientDropTimeout: 00:01:00
ClientRegistrationRefresh: 00:05:00
MaxEnqueuedRequestsSoftLimit: 0
MaxEnqueuedRequestsHardLimit: 0
MaxEnqueuedRequestsSoftLimit_StatelessWorker: 0
MaxEnqueuedRequestsHardLimit_StatelessWorker: 0
MaxRequestProcessingTime: 02:00:00
AssumeHomogenousSilosForTesting: False
ResponseTimeout: 00:30:00
ResponseTimeoutWithDebugger: 00:30:00
MaxResendCount: 0
ResendOnTimeout: False
DropExpiredMessages: True
BufferPoolBufferSize: 4096
BufferPoolMaxSize: 10000
BufferPoolPreallocationSize: 250
PropagateActivityId: False
	
[2018-04-20 10:18:47.877 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloOptions: 
SiloName: Primary
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.SiloStatisticsOptions: 
DeploymentLoadPublisherRefreshTime: 00:00:01
PerfCountersWriteInterval: 00:00:30
LogWriteInterval: 00:05:00
CollectionLevel: Info
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.TelemetryOptions: 
	
[2018-04-20 10:18:47.878 GMT 26	Information	0	Orleans.Runtime.SiloOptionsLogger]	Configuration Orleans.Configuration.TypeManagementOptions: 
TypeMapRefreshInterval: 00:01:00
	
[2018-04-20 10:18:47.878 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.SiloOptionsLogger started in stage -2147483648 which took 23 Milliseconds.	
[2018-04-20 10:18:47.878 GMT 26	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage -2147483648 took 27 Milliseconds	
[2018-04-20 10:18:47.881 GMT 8	Information	100401	Orleans.Runtime.Silo]	Silo Start()	
[2018-04-20 10:18:47.883 GMT 8	Information	100430	Orleans.Runtime.Silo]	Configured ThreadPool.SetMinThreads() to values: 200200. Previous values are: 88.	
[2018-04-20 10:18:47.883 GMT 8	Information	100436	Orleans.Runtime.Silo]	Configured .NET ServicePointManager to Expect100Continue=False DefaultConnectionLimit=200 UseNagleAlgorithm=False to improve Azure storage performance.	
[2018-04-20 10:18:47.883 GMT 8	Information	100452	Orleans.Runtime.Silo]	ConfigureThreadPoolAndServicePointSettings took 2 Milliseconds to finish	
[2018-04-20 10:18:47.887 GMT 26	Information	101711	Orleans.Runtime.GrainTypeManager]	Loaded grain type summary for 9 types: 
Grain class Orleans.Providers.Orleans.Providers.MemoryStreamQueueGrain [1359359215 (0x51062CEF)] from OrleansProviders.dll implementing interfaces: Orleans.Providers.IMemoryStreamQueueGrain [1158152105 (0x4507FFA9)]
Grain class Orleans.Runtime.Development.Orleans.Runtime.Development.DevelopmentLeaseProviderGrain [940524075 (0x380F422B)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.Development.IDevelopmentLeaseProviderGrain [-1234611069 (0xB6695483)]
Grain class Orleans.Runtime.Management.Orleans.Runtime.Management.ManagementGrain [1954798034 (0x7483D9D2)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.IManagementGrain [-1734666656 (0x989B1660)]
Grain class Orleans.Runtime.MembershipService.Orleans.Runtime.MembershipService.GrainBasedMembershipTableGrain [388921186 (0x172E7762)] from Orleans.Runtime.dll implementing interfaces: Orleans.IMembershipTableGrain [-1256503757 (0xB51B4633)]
Grain class Orleans.Runtime.ReminderService.Orleans.Runtime.ReminderService.GrainBasedReminderTable [-55315191 (0xFCB3F509)] from Orleans.Runtime.dll implementing interfaces: Orleans.IReminderTableGrain [-1135060418 (0xBC585A3E)]
Grain class Orleans.Runtime.Versions.Orleans.Runtime.Versions.VersionStoreGrain [331003096 (0x13BAB4D8)] from Orleans.Runtime.dll implementing interfaces: Orleans.Runtime.Versions.IVersionStoreGrain [-297600501 (0xEE42FA0B)] Orleans.IGrainWithStringKey [-1277021679 (0xB3E23211)]
Grain class Orleans.Storage.Orleans.Storage.MemoryStorageGrain [819348208 (0x30D642F0)] from OrleansProviders.dll implementing interfaces: Orleans.Storage.IMemoryStorageGrain [577125491 (0x22663C73)]
Grain class Orleans.Streams.Orleans.Streams.PubSubRendezvousGrain [1903070868 (0x716E8E94)] from Orleans.Runtime.dll implementing interfaces: Orleans.Streams.IPubSubRendezvousGrain [1746702088 (0x681C8F08)]
Grain class Orleans.TestingHost.Orleans.TestingHost.StorageFaultGrain [165808213 (0x9E20855)] from Orleans.TestingHost.dll implementing interfaces: Orleans.TestingHost.IStorageFaultGrain [-1063077025 (0xC0A2BB5F)] Orleans.IGrainWithStringKey [-1277021679 (0xB3E23211)]
	
[2018-04-20 10:18:47.891 GMT 26	Information	100452	Orleans.Runtime.InsideRuntimeClient]	Start InsideRuntimeClient took 8 Milliseconds	
[2018-04-20 10:18:47.891 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.InsideRuntimeClient started in stage 2000 which took 9 Milliseconds.	
[2018-04-20 10:18:47.893 GMT 26	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 2000 which took 14 Milliseconds.	
[2018-04-20 10:18:47.893 GMT 26	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 2000 took 14 Milliseconds	
[2018-04-20 10:18:47.900 GMT 27	Information	0	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAcceptor on managed thread 27	
[2018-04-20 10:18:47.901 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start Message center took 4 Milliseconds to finish	
[2018-04-20 10:18:47.904 GMT 28	Information	0	Runtime.Messaging.SiloMessageSender/PingSender]	Starting AsyncAgent Runtime.Messaging.SiloMessageSender/PingSender on managed thread 28	
[2018-04-20 10:18:47.907 GMT 29	Information	0	Runtime.Messaging.SiloMessageSender/SystemSender]	Starting AsyncAgent Runtime.Messaging.SiloMessageSender/SystemSender on managed thread 29	
[2018-04-20 10:18:47.909 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start Incoming message agents took 6 Milliseconds to finish	
[2018-04-20 10:18:47.913 GMT 30	Information	0	Runtime.Messaging.IncomingMessageAgent/Ping]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Ping on managed thread 30	
[2018-04-20 10:18:47.913 GMT 31	Information	0	Runtime.Messaging.IncomingMessageAgent/System]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/System on managed thread 31	
[2018-04-20 10:18:47.915 GMT 32	Information	0	Runtime.Messaging.IncomingMessageAgent/Application]	Starting AsyncAgent Runtime.Messaging.IncomingMessageAgent/Application on managed thread 32	
[2018-04-20 10:18:47.915 GMT 8	Information	0	Orleans.Runtime.GrainDirectory.LocalGrainDirectory]	Start	
[2018-04-20 10:18:47.916 GMT 27	Information	100328	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Stopping AsyncAgent Runtime.Messaging.IncomingMessageAcceptor that runs on managed thread 27	
[2018-04-20 10:18:47.917 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start local grain directory took 7 Milliseconds to finish	
[2018-04-20 10:18:47.920 GMT 33	Information	0	Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1]	Starting AsyncAgent Runtime.GrainDirectory.AdaptiveDirectoryCacheMaintainer`1 on managed thread 33	
[2018-04-20 10:18:47.922 GMT 34	Information	0	Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer]	Starting AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer on managed thread 34	
[2018-04-20 10:18:47.931 GMT 8	Information	100452	Orleans.Runtime.Silo]	Init implicit stream subscribe table took 11 Milliseconds to finish	
[2018-04-20 10:18:47.931 GMT 34	Information	100328	Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer]	Stopping AsyncAgent Runtime.GrainDirectory.GlobalSingleInstanceActivationMaintainer that runs on managed thread 34	
[2018-04-20 10:18:47.983 GMT 10	Information	100452	Orleans.Runtime.Silo]	Create system targets and inject dependencies took 46 Milliseconds to finish	
[2018-04-20 10:18:48.000 GMT 20	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 4000 which took 107 Milliseconds.	
[2018-04-20 10:18:48.000 GMT 20	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 4000 took 107 Milliseconds	
[2018-04-20 10:18:48.012 GMT 13	Information	100452	Orleans.Runtime.Silo]	Init transaction agent took 4 Milliseconds to finish	
[2018-04-20 10:18:48.016 GMT 13	Information	100452	Orleans.Runtime.Silo]	Init grain services took 2 Milliseconds to finish	
[2018-04-20 10:18:48.017 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#1: memory=12MB #activations=0 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:18:48.020 GMT 18	Information	100508	Orleans.Runtime.Catalog]	After collection#1: memory=12MB #activations=0 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0104148.	
[2018-04-20 10:18:48.022 GMT 22	Information	100603	Orleans.Runtime.MembershipService.MembershipOracleData]	MembershipOracle starting on host = OptikaLap37 address = S127.0.0.1:27112:261915527 at 2018-04-20 10:18:47.280 GMT backOffMax = 00:00:20	
[2018-04-20 10:18:48.027 GMT 22	Information	100635	Orleans.Runtime.MembershipService.GrainBasedMembershipTable]	Creating membership table grain	
[2018-04-20 10:18:48.091 GMT 24	Information	100637	Orleans.Runtime.MembershipService.GrainBasedMembershipTableGrain]	GrainBasedMembershipTable Activated.	
[2018-04-20 10:18:48.091 GMT 24	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 2000 took 1 Milliseconds	
[2018-04-20 10:18:48.199 GMT 18	Information	100631	Orleans.Runtime.MembershipService.GrainBasedMembershipTable]	-Connected to membership table provider.	
[2018-04-20 10:18:52.788 GMT 18	Information	100652	Orleans.Runtime.MembershipService.MembershipOracleData]	-CleanupTable called on silo startup. Membership table 0 silos 0 are Active 0 are Dead Version=&lt;0 0&gt;. All silos: []	
[2018-04-20 10:18:52.862 GMT 18	Information	100660	Orleans.Runtime.MembershipService.MembershipOracleData]	Starting IAmAliveUpdateTimer.	
[2018-04-20 10:18:52.873 GMT 16	Information	100452	Orleans.Runtime.Silo]	Starting local silo status oracle took 4857 Milliseconds to finish	
[2018-04-20 10:18:52.883 GMT 25	Information	0	Orleans.Runtime.TypeManager]	OnRefreshClusterMapTimer: refresh start	
[2018-04-20 10:18:52.886 GMT 8	Information	100452	Orleans.Runtime.Silo]	Init type manager took 12 Milliseconds to finish	
[2018-04-20 10:18:52.887 GMT 8	Information	100702	Orleans.Runtime.CounterStatistic]	Starting Windows perf counter stats collection with frequency=00:00:30	
[2018-04-20 10:18:52.887 GMT 8	Information	100452	Orleans.Runtime.Silo]	Start silo statistics took 1 Milliseconds to finish	
[2018-04-20 10:18:52.893 GMT 18	Information	0	Orleans.Runtime.DeploymentLoadPublisher]	Starting DeploymentLoadPublisher.	
[2018-04-20 10:18:52.905 GMT 18	Information	0	Orleans.Runtime.DeploymentLoadPublisher]	Started DeploymentLoadPublisher.	
[2018-04-20 10:18:52.905 GMT 10	Information	100452	Orleans.Runtime.Silo]	Start deployment load collector took 18 Milliseconds to finish	
[2018-04-20 10:18:52.906 GMT 10	Information	0	Orleans.Runtime.Watchdog]	Starting Silo Watchdog.	
[2018-04-20 10:18:52.917 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 8000 which took 4916 Milliseconds.	
[2018-04-20 10:18:52.917 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 8000 took 4917 Milliseconds	
[2018-04-20 10:18:52.920 GMT 35	Information	0	Runtime.Watchdog]	Starting AsyncAgent Runtime.Watchdog on managed thread 35	
[2018-04-20 10:18:52.920 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Versions.GrainVersionStore started in stage 10000 which took 2 Milliseconds.	
[2018-04-20 10:18:52.920 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 10000 took 2 Milliseconds	
[2018-04-20 10:18:52.928 GMT 14	Information	100452	Orleans.Runtime.Silo]	Start gateway took 5 Milliseconds to finish	
[2018-04-20 10:18:52.953 GMT 36	Information	0	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Starting AsyncAgent Runtime.Messaging.GatewayAcceptor on managed thread 36	
[2018-04-20 10:18:52.953 GMT 37	Information	0	Runtime.Messaging.GatewayClientCleanupAgent]	Starting AsyncAgent Runtime.Messaging.GatewayClientCleanupAgent on managed thread 37	
[2018-04-20 10:18:52.953 GMT 36	Information	100328	Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Stopping AsyncAgent Runtime.Messaging.GatewayAcceptor that runs on managed thread 36	
[2018-04-20 10:18:52.965 GMT 18	Information	100604	Orleans.Runtime.MembershipService.MembershipOracleData]	-BecomeActive	
[2018-04-20 10:18:52.971 GMT 18	Information	100614	Orleans.Runtime.MembershipService.MembershipOracleData]	About to send pings to 0 nodes in order to validate communication in the Joining state. Pinged nodes = []	
[2018-04-20 10:18:52.981 GMT 18	Information	100634	Orleans.Runtime.MembershipService.MembershipOracleData]	-ReadAll (called from BecomeActive) Membership table 1 silos 1 are Active 0 are Dead Version=&lt;2 5&gt;. All silos: [SiloAddress=S127.0.0.1:27112:261915527 SiloName=Primary Status=Active]	
[2018-04-20 10:18:52.982 GMT 18	Information	100605	Orleans.Runtime.MembershipService.MembershipOracleData]	-Finished BecomeActive.	
[2018-04-20 10:18:52.983 GMT 8	Information	100452	Orleans.Runtime.Silo]	Starting local silo status oracle took 54 Milliseconds to finish	
[2018-04-20 10:18:52.983 GMT 25	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 19999 which took 62 Milliseconds.	
[2018-04-20 10:18:52.983 GMT 25	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 19999 took 62 Milliseconds	
[2018-04-20 10:18:52.997 GMT 18	Information	100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Runtime.Silo started in stage 20000 which took 14 Milliseconds.	
[2018-04-20 10:18:52.997 GMT 18	Information	100452	Orleans.LifecycleSubject]	Starting lifecycle stage 20000 took 14 Milliseconds	
[2018-04-20 10:19:48.025 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#2: memory=12MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:19:48.027 GMT 18	Information	100508	Orleans.Runtime.Catalog]	After collection#2: memory=12MB #activations=1 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0020846.	
[2018-04-20 10:19:52.885 GMT 18	Information	0	Orleans.Runtime.TypeManager]	OnRefreshClusterMapTimer: refresh start	
[2018-04-20 10:20:48.032 GMT 22	Information	100507	Orleans.Runtime.Catalog]	Before collection#3: memory=13MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	
[2018-04-20 10:20:48.032 GMT 22	Information	100508	Orleans.Runtime.Catalog]	After collection#3: memory=13MB #activations=1 collected 0 activations collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt; collection time=00:00:00.0004580.	
[2018-04-20 10:21:48.042 GMT 18	Information	100507	Orleans.Runtime.Catalog]	Before collection#4: memory=14MB #activations=1 collector=&lt;#Activations=0 #Buckets=0 buckets=[]&gt;.	

```

I have tried:
- Using an ADONET provider for clustering (created tables and registered properly but also did not progress)
- Manually setting BaseSilo/GatewayPort
- Moving the code out of the xunit fixture
- Moving the code out of the xunit fixture and using DeployAsync() instead
- Changing the number of silos initially created
- Probably a number of other things.

None of it worked - still hangs on Deploy(). I'm also unable to step into Deploy() to see where it's getting hung up even though I have the pdbs loaded.

EDIT:

The same issue also occurs using the start SiloHost/Client functions:

```
var builder = new SiloHostBuilder();
            builder.UseLocalhostClustering();
            builder.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AkumenGrain).Assembly).WithCodeGeneration());
            builder.ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Debug).AddDebug());
            SiloHost = builder.Build();

            // start the silo
            SiloHost.StartAsync().Wait();

            var clientBuilder = new ClientBuilder();
            clientBuilder.UseLocalhostClustering();
            clientBuilder.ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(AkumenGrain).Assembly).WithCodeGeneration());
            builder.ConfigureLogging(logging =&gt; logging.SetMinimumLevel(LogLevel.Debug).AddDebug());
            Client = clientBuilder.Build();

            // start the client
            Client.Connect().Wait();
```

As per @ReubenBond's suggestion changing it to `Task.Run(() =&gt; SiloHost.StartAsync()).Wait();` allows it to continue successfully.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4496</IssueLabelID>
    <Title>Golden path multi-resource transactional grain testing</Title>
    <Description>Add golden path tests for transactional grains which consist of 2 and TransactionTestConstants.MaxCoordinatedTransactions transactional resources.</Description>
    <Title_Description>Golden path multi-resource transactional grain testing Add golden path tests for transactional grains which consist of 2 and TransactionTestConstants.MaxCoordinatedTransactions transactional resources.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4491</IssueLabelID>
    <Title>Update Bond serialization provider to allow customizing protocol</Title>
    <Description>Currently the Bond serialization provider does not allow the user to select the protocol being used and is using SimpleBinary which is *not* version tolerant. Hence the protocol should be configurable and the documentation should clearly state that this option needs to be configured for version-tolerant serialization.</Description>
    <Title_Description>Update Bond serialization provider to allow customizing protocol Currently the Bond serialization provider does not allow the user to select the protocol being used and is using SimpleBinary which is *not* version tolerant. Hence the protocol should be configurable and the documentation should clearly state that this option needs to be configured for version-tolerant serialization.</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4488</IssueLabelID>
    <Title>Remove unused method and namespaces</Title>
    <Description>Remove unused method and namespaces
</Description>
    <Title_Description>Remove unused method and namespaces Remove unused method and namespaces
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4487</IssueLabelID>
    <Title>Don't generate serializers for foreign types in Orleans.Streaming.EventHubs</Title>
    <Description>
    </Description>
    <Title_Description>Don't generate serializers for foreign types in Orleans.Streaming.EventHubs </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4486</IssueLabelID>
    <Title>iis8 + orleans error!!!!!</Title>
    <Description>[2018-04-18 04:12:12.646 GMT 37	Information	100313	Orleans.OutsideRuntimeClient]	---------- Initializing OutsideRuntimeClient on ljsvr-2-27 at 192.168.2.27 Client Id = *cli/6c8ed7a4 ----------	
[2018-04-18 04:12:12.649 GMT 37	Information	100314	Orleans.OutsideRuntimeClient]	---------- Starting OutsideRuntimeClient with runtime Version='2.0.0. Commit Hash: 89ebbe67d2266b24b34e704935fe70577d30408a (Release).' in AppDomain=&lt;AppDomain.Id=8 AppDomain.FriendlyName=/LM/W3SVC/57/ROOT/testmallol-7-131684983183817379&gt;	
[2018-04-18 04:12:12.810 GMT 65	Information	101309	Orleans.Messaging.GatewayManager]	Found 2 knownGateways from Gateway listProvider [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]	
[2018-04-18 04:12:12.883 GMT 65	Warning	100178	Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://192.168.2.27:30000/261709551]	Unable to connect to gateway at address gwy.tcp://192.168.2.27:30000/261709551 on trial 0 (Exception: 未能加载文件或程序集“System.Runtime.InteropServices.RuntimeInformation Version=0.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a”或它的某一个依赖项。找到的程序集清单定义与程序集引用不匹配。 (异常来自 HRESULT:0x80131040))	
[2018-04-18 04:12:12.885 GMT 65	Warning	100913	Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://192.168.2.27:30000/261709551]	Marking gateway at address gwy.tcp://192.168.2.27:30000/261709551 as Disconnected	
[2018-04-18 04:12:12.892 GMT 50	Information	101309	Orleans.Messaging.GatewayManager]	Refreshed the live Gateway list. Found 2 gateways from Gateway listProvider: [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]. Picked only known live out of them. Now has 2 live Gateways: [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]. Previous refresh time was = 04/18/2018 04:12:12	</Description>
    <Title_Description>iis8 + orleans error!!!!! [2018-04-18 04:12:12.646 GMT 37	Information	100313	Orleans.OutsideRuntimeClient]	---------- Initializing OutsideRuntimeClient on ljsvr-2-27 at 192.168.2.27 Client Id = *cli/6c8ed7a4 ----------	
[2018-04-18 04:12:12.649 GMT 37	Information	100314	Orleans.OutsideRuntimeClient]	---------- Starting OutsideRuntimeClient with runtime Version='2.0.0. Commit Hash: 89ebbe67d2266b24b34e704935fe70577d30408a (Release).' in AppDomain=&lt;AppDomain.Id=8 AppDomain.FriendlyName=/LM/W3SVC/57/ROOT/testmallol-7-131684983183817379&gt;	
[2018-04-18 04:12:12.810 GMT 65	Information	101309	Orleans.Messaging.GatewayManager]	Found 2 knownGateways from Gateway listProvider [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]	
[2018-04-18 04:12:12.883 GMT 65	Warning	100178	Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://192.168.2.27:30000/261709551]	Unable to connect to gateway at address gwy.tcp://192.168.2.27:30000/261709551 on trial 0 (Exception: 未能加载文件或程序集“System.Runtime.InteropServices.RuntimeInformation Version=0.0.0.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a”或它的某一个依赖项。找到的程序集清单定义与程序集引用不匹配。 (异常来自 HRESULT:0x80131040))	
[2018-04-18 04:12:12.885 GMT 65	Warning	100913	Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://192.168.2.27:30000/261709551]	Marking gateway at address gwy.tcp://192.168.2.27:30000/261709551 as Disconnected	
[2018-04-18 04:12:12.892 GMT 50	Information	101309	Orleans.Messaging.GatewayManager]	Refreshed the live Gateway list. Found 2 gateways from Gateway listProvider: [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]. Picked only known live out of them. Now has 2 live Gateways: [gwy.tcp://192.168.2.15:30000/261655706 gwy.tcp://192.168.2.27:30000/261709551]. Previous refresh time was = 04/18/2018 04:12:12	</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4485</IssueLabelID>
    <Title>Rearrange test projects for easier consolidation of references</Title>
    <Description>This is another step toward enabling partial builds for patch releases.</Description>
    <Title_Description>Rearrange test projects for easier consolidation of references This is another step toward enabling partial builds for patch releases.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4480</IssueLabelID>
    <Title>Add autofac DI tests</Title>
    <Description>both internal and external customer has reported they are using Autofac with Orleans. In theory Orleans should work with Autofac after fix #4453  I just want to ensure it really worksby adding DI tests running against Autofac DI container. </Description>
    <Title_Description>Add autofac DI tests both internal and external customer has reported they are using Autofac with Orleans. In theory Orleans should work with Autofac after fix #4453  I just want to ensure it really worksby adding DI tests running against Autofac DI container. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4479</IssueLabelID>
    <Title> Convert IMembershipTableGrain into a SystemTarget</Title>
    <Description>Addresses https://github.com/dotnet/orleans/issues/3129. </Description>
    <Title_Description> Convert IMembershipTableGrain into a SystemTarget Addresses https://github.com/dotnet/orleans/issues/3129. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4478</IssueLabelID>
    <Title>Is it possible to configure silo using DNS name instead of IP address</Title>
    <Description>Team
Below is code snippet for Silo host. Is there any option where I can configure endpoint using DNS name instead of IP address.

            var siloPort = Convert.ToInt32(ConfigurationManager.AppSettings["SiloPort"]);
            var gatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings["GatewayPort"]);
            var advertisedIp = IPAddress.Parse(ConfigurationManager.AppSettings["AdvertisedIP"]);
            var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = ConfigurationManager.AppSettings("CLUSTER_ID");
                    options.ServiceId = ConfigurationManager.AppSettings("SERVICE_ID");
                })
                .ConfigureEndpoints(siloPort: siloPort gatewayPort: gatewayPort advertisedIP: advertisedIp)
                .UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings("ServiceDiscoverEndPoint"));
                })

Thanks</Description>
    <Title_Description>Is it possible to configure silo using DNS name instead of IP address Team
Below is code snippet for Silo host. Is there any option where I can configure endpoint using DNS name instead of IP address.

            var siloPort = Convert.ToInt32(ConfigurationManager.AppSettings["SiloPort"]);
            var gatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings["GatewayPort"]);
            var advertisedIp = IPAddress.Parse(ConfigurationManager.AppSettings["AdvertisedIP"]);
            var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = ConfigurationManager.AppSettings("CLUSTER_ID");
                    options.ServiceId = ConfigurationManager.AppSettings("SERVICE_ID");
                })
                .ConfigureEndpoints(siloPort: siloPort gatewayPort: gatewayPort advertisedIP: advertisedIp)
                .UseConsulClustering(gatewayOptions =&gt;
                {
                    gatewayOptions.Address =
                        new Uri(ConfigurationManager.AppSettings("ServiceDiscoverEndPoint"));
                })

Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>16/04/2018 9:16:38 PM +00:00</CreatedAt>
    <ClosedAt>18/04/2018 2:54:36 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4477</IssueLabelID>
    <Title>Orleans Core public surface insufficient for extension development</Title>
    <Description>External and application engineers cannot build extension libraries on Orleans without access to internals.  This is evidenced by our internally maintained extension libraries many of which require access to Orleans Core internals.

[assembly: InternalsVisibleTo("Orleans.Clustering.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Clustering.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Hosting.AzureCloudServices")]
[assembly: InternalsVisibleTo("Orleans.Persistence.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Persistence.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Reminders.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Reminders.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Streaming.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Streaming.EventHubs")]
[assembly: InternalsVisibleTo("Orleans.Streaming.SQS")]
[assembly: InternalsVisibleTo("Orleans.TelemetryConsumers.Counters")]
[assembly: InternalsVisibleTo("Orleans.Transactions.DynamoDB")]

Internal access needs be removed for extension libraries.  Where extension libraries currently require internal access either alternate solutions need be found or the accessed capabilities need be exposed in maintainable public apis.
</Description>
    <Title_Description>Orleans Core public surface insufficient for extension development External and application engineers cannot build extension libraries on Orleans without access to internals.  This is evidenced by our internally maintained extension libraries many of which require access to Orleans Core internals.

[assembly: InternalsVisibleTo("Orleans.Clustering.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Clustering.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Hosting.AzureCloudServices")]
[assembly: InternalsVisibleTo("Orleans.Persistence.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Persistence.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Reminders.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Reminders.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Streaming.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Streaming.EventHubs")]
[assembly: InternalsVisibleTo("Orleans.Streaming.SQS")]
[assembly: InternalsVisibleTo("Orleans.TelemetryConsumers.Counters")]
[assembly: InternalsVisibleTo("Orleans.Transactions.DynamoDB")]

Internal access needs be removed for extension libraries.  Where extension libraries currently require internal access either alternate solutions need be found or the accessed capabilities need be exposed in maintainable public apis.
</Title_Description>
    <Label>P2</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4476</IssueLabelID>
    <Title>changed framework to netcoreapp2.0</Title>
    <Description>The example uses .NET Framework 4.6.2. Changing it makes it easier for
others to get started; updated readme to reflect changes.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Description>
    <Title_Description>changed framework to netcoreapp2.0 The example uses .NET Framework 4.6.2. Changing it makes it easier for
others to get started; updated readme to reflect changes.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4475</IssueLabelID>
    <Title>Question: Removing grain from data store</Title>
    <Description>Hi

What is the best way to remove a grain from data store (when the grain is not needed anymore)? The documentation describes how to persist read and write - but not to remove from store.

Kind regards
Jan</Description>
    <Title_Description>Question: Removing grain from data store Hi

What is the best way to remove a grain from data store (when the grain is not needed anymore)? The documentation describes how to persist read and write - but not to remove from store.

Kind regards
Jan</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/04/2018 5:07:00 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4473</IssueLabelID>
    <Title>TestCluster ignores UserLocalhostClustering</Title>
    <Description>I'm trying to set up TestCluster:

```
    public class SiloConfigurator: ISiloBuilderConfigurator
    {
        public void Configure(ISiloHostBuilder builder)
        {
            builder
                .UseLocalhostClustering(siloPort: 1000 gatewayPort: 1001);
        }
    }

    public class ClientConfigurator: IClientBuilderConfigurator
    {
        public virtual void Configure(IConfiguration configuration IClientBuilder builder)
        {
            builder
                .UseLocalhostClustering(gatewayPort: 1001);
        }
    }

            var builder = new TestClusterBuilder(1);
            builder.AddSiloBuilderConfigurator&lt;SiloConfigurator&gt;();
            builder.AddClientBuilderConfigurator&lt;ClientConfigurator&gt;();
            
            var cluster = builder.Build();
            if (cluster.Primary == null)
                cluster.Deploy();
```
But in logs I see this:
```
Orleans.Runtime.Silo]	-------------- Initializing silo on host mara MachineName MARA at 127.0.0.1:24412 gen 261564242 --------------	
Orleans.Runtime.Silo]	Starting silo Primary	
Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:24412	
Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:43788
...

Orleans.Runtime.MembershipService.MembershipOracleData]	MembershipOracle starting on host = mara address = S127.0.0.1:24412:261564242 at 2018-04-16 08:44:02.253 GMT backOffMax = 00:00:02	
Runtime.Messaging.SiloMessageSender/SystemSender]	Exception getting a sending socket to endpoint S127.0.0.1:1000:0	
Exc level 0: Orleans.Runtime.OrleansException: Could not connect to 127.0.0.1:1000: ConnectionRefused
```

1. Cluster is started on some random port instead of configured by ISiloBuilderConfigurator
2. Client tries to connect to SiloPort instead of GatewayPort. 

And it starts working when I add these lines to override testcluster options:
```
            var builder = new TestClusterBuilder(1);
            builder.Options.BaseSiloPort = 1000; // this works while ISiloBuilderConfigurator does not
            builder.Options.BaseGatewayPort = 1001; 
            builder.AddSiloBuilderConfigurator&lt;TSiloConfigurator&gt;();
            builder.AddClientBuilderConfigurator&lt;TClientConfigurator&gt;();
```</Description>
    <Title_Description>TestCluster ignores UserLocalhostClustering I'm trying to set up TestCluster:

```
    public class SiloConfigurator: ISiloBuilderConfigurator
    {
        public void Configure(ISiloHostBuilder builder)
        {
            builder
                .UseLocalhostClustering(siloPort: 1000 gatewayPort: 1001);
        }
    }

    public class ClientConfigurator: IClientBuilderConfigurator
    {
        public virtual void Configure(IConfiguration configuration IClientBuilder builder)
        {
            builder
                .UseLocalhostClustering(gatewayPort: 1001);
        }
    }

            var builder = new TestClusterBuilder(1);
            builder.AddSiloBuilderConfigurator&lt;SiloConfigurator&gt;();
            builder.AddClientBuilderConfigurator&lt;ClientConfigurator&gt;();
            
            var cluster = builder.Build();
            if (cluster.Primary == null)
                cluster.Deploy();
```
But in logs I see this:
```
Orleans.Runtime.Silo]	-------------- Initializing silo on host mara MachineName MARA at 127.0.0.1:24412 gen 261564242 --------------	
Orleans.Runtime.Silo]	Starting silo Primary	
Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:24412	
Orleans.Runtime.Messaging.IncomingMessageAcceptor]	Opened a listening socket at address 127.0.0.1:43788
...

Orleans.Runtime.MembershipService.MembershipOracleData]	MembershipOracle starting on host = mara address = S127.0.0.1:24412:261564242 at 2018-04-16 08:44:02.253 GMT backOffMax = 00:00:02	
Runtime.Messaging.SiloMessageSender/SystemSender]	Exception getting a sending socket to endpoint S127.0.0.1:1000:0	
Exc level 0: Orleans.Runtime.OrleansException: Could not connect to 127.0.0.1:1000: ConnectionRefused
```

1. Cluster is started on some random port instead of configured by ISiloBuilderConfigurator
2. Client tries to connect to SiloPort instead of GatewayPort. 

And it starts working when I add these lines to override testcluster options:
```
            var builder = new TestClusterBuilder(1);
            builder.Options.BaseSiloPort = 1000; // this works while ISiloBuilderConfigurator does not
            builder.Options.BaseGatewayPort = 1001; 
            builder.AddSiloBuilderConfigurator&lt;TSiloConfigurator&gt;();
            builder.AddClientBuilderConfigurator&lt;TClientConfigurator&gt;();
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4469</IssueLabelID>
    <Title>Add serviceId parameters to ClientBuilder/ServiceHostBuilder helper methods</Title>
    <Description>Fix for #4468 

With this PR test failures from PR #4450 should be gone.

I added check to not override ClusterId/ServiceId set from this methods if they were set explicitely by a call to `Configure&lt;ClusterOptions&gt;` before calling them.</Description>
    <Title_Description>Add serviceId parameters to ClientBuilder/ServiceHostBuilder helper methods Fix for #4468 

With this PR test failures from PR #4450 should be gone.

I added check to not override ClusterId/ServiceId set from this methods if they were set explicitely by a call to `Configure&lt;ClusterOptions&gt;` before calling them.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4466</IssueLabelID>
    <Title>Question - Heterogenous Silo configuration in runtime</Title>
    <Description>Hello guys 
is it possible to make Heterogenous Silos configuration by supplying the same build package with all grain implementations but configuring which parts to host by AddApplicationParts or any similar way (but still referencing all grains)?
We are just considering to supply the silo with some config and select required set of grains ( and dependent services to inject etc. ) to host when starting the silo. 
It will be very useful if you have the silo capable of hosting N feature-sets and when the demand arises for some parts of functionality/services you can choose for which features you need to allocate more resources (and resource configurations required) and start additional silos only for these instead of running the one big silo.

</Description>
    <Title_Description>Question - Heterogenous Silo configuration in runtime Hello guys 
is it possible to make Heterogenous Silos configuration by supplying the same build package with all grain implementations but configuring which parts to host by AddApplicationParts or any similar way (but still referencing all grains)?
We are just considering to supply the silo with some config and select required set of grains ( and dependent services to inject etc. ) to host when starting the silo. 
It will be very useful if you have the silo capable of hosting N feature-sets and when the demand arises for some parts of functionality/services you can choose for which features you need to allocate more resources (and resource configurations required) and start additional silos only for these instead of running the one big silo.

</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4463</IssueLabelID>
    <Title>Copy elements in-place in InvokeMethodAsync</Title>
    <Description>Arguments passed to `InvokeMethodAsync` (from generated GrainReference code) are copied in-place: i.e without creating a new argument array. This saves some cost in making calls without breaking semantics (reference equality between arguments). It saves one allocation per call and avoids invoking DeepCopyHelper for the array.

The distributed tests are too noisy for such a minor fix:

| Test | Run 1 | Run 2 | Run 3 | Run 4 | Master
|-|-|-|-|-|-|
| NightlyLoadTest | 235957 | 233753 | 239428 | 244787 | 240383
| ActivationCollectorStressTest | 256907 | 253961 | 261432 | 260869 | 250575
| PingLoadTest_LocalReentrant | 151081 | 146504 | 151071 | 137274 | 151688
| PingLoadTest_RandomReentrant_MultiSilos | 474047 | 271112 | 270071 | 285268 | 338229

cc @dVakulen
</Description>
    <Title_Description>Copy elements in-place in InvokeMethodAsync Arguments passed to `InvokeMethodAsync` (from generated GrainReference code) are copied in-place: i.e without creating a new argument array. This saves some cost in making calls without breaking semantics (reference equality between arguments). It saves one allocation per call and avoids invoking DeepCopyHelper for the array.

The distributed tests are too noisy for such a minor fix:

| Test | Run 1 | Run 2 | Run 3 | Run 4 | Master
|-|-|-|-|-|-|
| NightlyLoadTest | 235957 | 233753 | 239428 | 244787 | 240383
| ActivationCollectorStressTest | 256907 | 253961 | 261432 | 260869 | 250575
| PingLoadTest_LocalReentrant | 151081 | 146504 | 151071 | 137274 | 151688
| PingLoadTest_RandomReentrant_MultiSilos | 474047 | 271112 | 270071 | 285268 | 338229

cc @dVakulen
</Title_Description>
    <Label>performance</Label>
    <Assignee>dVakulen</Assignee>
    <CreatedAt>13/04/2018 12:21:39 AM +00:00</CreatedAt>
    <ClosedAt>13/04/2018 2:02:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4461</IssueLabelID>
    <Title>Move test grain interfaces and classes to Grains subdirectory</Title>
    <Description>This is on top of #4460 to consolidate test grain interfaces and classes.</Description>
    <Title_Description>Move test grain interfaces and classes to Grains subdirectory This is on top of #4460 to consolidate test grain interfaces and classes.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4458</IssueLabelID>
    <Title>Questions related to reliability</Title>
    <Description>Your implementation of the Actor pattern is obviously more geared around intuitiveness and implicit reliability than other implementations.  I do really like how intuitive things are however have 2 questions:

1. You obviously support streams which means one grain can fire off some request into a stream and then exit.  My question is; should streams be optional?  My understanding from reading the docs is that the most simple and intuitive route to follow is to not use them and to block (asynchronously) while dependant grains execute. However I think that I could easily get into more trouble using Orleans in this way than I would by developing traditional locking code.

Say I have a Grain A which depends on Grain B which depends on Grain C etc.  If Grain C maintains state but A and B don't then are potential activations of A and B blocked until C completes even though work could be performed in A and B during this period - perhaps A and B don't even always lead to C.

Hopefully it's clear what I'm trying to say.  In a sentence it makes perfect sense to make grains atomic however I'm not so sure about chains of grains.  

Have I misinterpreted the architecture? Assuming I haven't I'll repeat that I know I can use streams and there will be certain patterns I can follow to help me here.  I'm just wondering if there is any value in going the simple/intuitive route (if indeed it's better than a more traditional approach)?

2. I understand why streams are reliable and it's very nice to have this.  I'm not clear how to best use them though.  I'll give an example to demonstrate my question - along with some extra detail so you can correct me if I'm missing something fundamental:

Grain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations).  Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message).  I'm assuming I have to build checks into my system for this type of thing?

If it is the case that I've got to build these checks into my system I'm wondering if it's worth paying the cost for the reliable stream?</Description>
    <Title_Description>Questions related to reliability Your implementation of the Actor pattern is obviously more geared around intuitiveness and implicit reliability than other implementations.  I do really like how intuitive things are however have 2 questions:

1. You obviously support streams which means one grain can fire off some request into a stream and then exit.  My question is; should streams be optional?  My understanding from reading the docs is that the most simple and intuitive route to follow is to not use them and to block (asynchronously) while dependant grains execute. However I think that I could easily get into more trouble using Orleans in this way than I would by developing traditional locking code.

Say I have a Grain A which depends on Grain B which depends on Grain C etc.  If Grain C maintains state but A and B don't then are potential activations of A and B blocked until C completes even though work could be performed in A and B during this period - perhaps A and B don't even always lead to C.

Hopefully it's clear what I'm trying to say.  In a sentence it makes perfect sense to make grains atomic however I'm not so sure about chains of grains.  

Have I misinterpreted the architecture? Assuming I haven't I'll repeat that I know I can use streams and there will be certain patterns I can follow to help me here.  I'm just wondering if there is any value in going the simple/intuitive route (if indeed it's better than a more traditional approach)?

2. I understand why streams are reliable and it's very nice to have this.  I'm not clear how to best use them though.  I'll give an example to demonstrate my question - along with some extra detail so you can correct me if I'm missing something fundamental:

Grain A posts a message to Stream A (it blocks while it's posting to the stream but after this can then return and handle further activations).  Now if for whatever reason the message posted to the stream isn't processed as expected (e.g. the grain which consumes the message doesn't die but somehow drops the message).  I'm assuming I have to build checks into my system for this type of thing?

If it is the case that I've got to build these checks into my system I'm wondering if it's worth paying the cost for the reliable stream?</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>12/04/2018 1:00:14 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 9:55:47 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4455</IssueLabelID>
    <Title>Azure blob storage provider: respect UseJson setting</Title>
    <Description>Fixes #4439 

Submitted for testing</Description>
    <Title_Description>Azure blob storage provider: respect UseJson setting Fixes #4439 

Submitted for testing</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4454</IssueLabelID>
    <Title>Question - Orleans real world usage scenario.</Title>
    <Description>Hi.
I'm new to orleans. I wonder if there are any useful scenarios using Orleans.
The only scenario i can think of this moment is ticketing service.
One of my customers have ticketing service for concerts.
When they host famous singer's concert they receive lots of traffic in
very short amounts of time like Ddos attacks.
As a results sometimes bottleneck is web servers sometimes it's database.
I think Orleans will help to mitigate this situation.
So i have two questions.

1.  Are there any other useful scenarios ?
2.  If I had to convert a traditional three-tier(webapidb) application into Orleans 
    what would it be changed? I know that this is a broad question but please give me 
    any descriptions or link to help me understand the general idea.
   (ex - Azure's table storage is recommended than traditional Relational Database)

Thanks.
      


</Description>
    <Title_Description>Question - Orleans real world usage scenario. Hi.
I'm new to orleans. I wonder if there are any useful scenarios using Orleans.
The only scenario i can think of this moment is ticketing service.
One of my customers have ticketing service for concerts.
When they host famous singer's concert they receive lots of traffic in
very short amounts of time like Ddos attacks.
As a results sometimes bottleneck is web servers sometimes it's database.
I think Orleans will help to mitigate this situation.
So i have two questions.

1.  Are there any other useful scenarios ?
2.  If I had to convert a traditional three-tier(webapidb) application into Orleans 
    what would it be changed? I know that this is a broad question but please give me 
    any descriptions or link to help me understand the general idea.
   (ex - Azure's table storage is recommended than traditional Relational Database)

Thanks.
      


</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>12/04/2018 1:30:29 AM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 3:41:04 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4452</IssueLabelID>
    <Title>Update stream-extensibility section docs</Title>
    <Description>fix for #4434 . the section is outdated still in the 1.5 and before state. </Description>
    <Title_Description>Update stream-extensibility section docs fix for #4434 . the section is outdated still in the 1.5 and before state. </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4450</IssueLabelID>
    <Title>Add validator for ClusterOptions</Title>
    <Description>Currently we check that `ClusterId` is set but not `ServiceId`. I added a validator to test this.</Description>
    <Title_Description>Add validator for ClusterOptions Currently we check that `ClusterId` is set but not `ServiceId`. I added a validator to test this.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4449</IssueLabelID>
    <Title>why my orleans being slow with 3 node?</Title>
    <Description>when 1 node was running the client is fast
when 3 node was running the client is fast At first， but being slow after A few minutes。

 const string connectionString = "Server=192.168.2.113;Database=TestOrleans;User Id=sa;Password=sa;";

            //  var  configuration = new ConfigurationBuilder()
            //   .AddJsonFile("HostSettings.json" true true)
            //   .Build();
            //var port=  configuration.GetValue&lt;int&gt;("configProperties:Net.Port");
            //var gatePort=  configuration.GetValue&lt;int&gt;("configProperties:GateWay.Port");
            var netport = System.Configuration.ConfigurationManager.AppSettings["netport"];
            var gatewayport = System.Configuration.ConfigurationManager.AppSettings["gatewayport"];

            var silo = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "mycluster";
                    options.ServiceId = "product";
                    
                })
                .Configure &lt;GrainCollectionOptions&gt;(options=&gt; {
                    //配置grain的回收
                    options.CollectionAge = TimeSpan.FromMinutes(10);
                    options.CollectionQuantum = TimeSpan.FromMinutes(5);
                })
                .UseAdoNetClustering(options =&gt;
                {
                    options.ConnectionString = connectionString;
                    options.Invariant = "System.Data.SqlClient";
                })
                
                .ConfigureEndpoints(System.Net.Dns.GetHostName()int .Parse( netport)int .Parse( gatewayport))
                
                .ConfigureLogging(logging =&gt;logging.SetMinimumLevel(LogLevel.Warning).AddConsole())
                // .ConfigureLogging(builder =&gt; builder.SetMinimumLevel(LogLevel.Warning).AddConsole())
                .Build();

            silo.StartAsync().Wait();
            Console.WriteLine("启动成功");
            Console.Read();
            silo.Dispose();
</Description>
    <Title_Description>why my orleans being slow with 3 node? when 1 node was running the client is fast
when 3 node was running the client is fast At first， but being slow after A few minutes。

 const string connectionString = "Server=192.168.2.113;Database=TestOrleans;User Id=sa;Password=sa;";

            //  var  configuration = new ConfigurationBuilder()
            //   .AddJsonFile("HostSettings.json" true true)
            //   .Build();
            //var port=  configuration.GetValue&lt;int&gt;("configProperties:Net.Port");
            //var gatePort=  configuration.GetValue&lt;int&gt;("configProperties:GateWay.Port");
            var netport = System.Configuration.ConfigurationManager.AppSettings["netport"];
            var gatewayport = System.Configuration.ConfigurationManager.AppSettings["gatewayport"];

            var silo = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt;
                {
                    options.ClusterId = "mycluster";
                    options.ServiceId = "product";
                    
                })
                .Configure &lt;GrainCollectionOptions&gt;(options=&gt; {
                    //配置grain的回收
                    options.CollectionAge = TimeSpan.FromMinutes(10);
                    options.CollectionQuantum = TimeSpan.FromMinutes(5);
                })
                .UseAdoNetClustering(options =&gt;
                {
                    options.ConnectionString = connectionString;
                    options.Invariant = "System.Data.SqlClient";
                })
                
                .ConfigureEndpoints(System.Net.Dns.GetHostName()int .Parse( netport)int .Parse( gatewayport))
                
                .ConfigureLogging(logging =&gt;logging.SetMinimumLevel(LogLevel.Warning).AddConsole())
                // .ConfigureLogging(builder =&gt; builder.SetMinimumLevel(LogLevel.Warning).AddConsole())
                .Build();

            silo.StartAsync().Wait();
            Console.WriteLine("启动成功");
            Console.Read();
            silo.Dispose();
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>11/04/2018 10:05:05 AM +00:00</CreatedAt>
    <ClosedAt>8/05/2018 4:13:51 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4448</IssueLabelID>
    <Title>One or more errors occurred. (Not connected to a gateway)</Title>
    <Description>Hi

We are running 2 small sized worker roles (Orleans 2.0) and client app service (ASP.Net core) also networked as per the [documentation](http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html) App service and orleans silo(cloudservice) share same vNET and configured the subnet of vNET to Network security group. Both workerrole and appservice use same clusterId and serviceId.

While trying to connect from azure app service(client) to orleans silo(workerrole) am getting an error in client as "Not connected to a gateway" can someone help me what configurations should do to resolve this?

Below is the error log

An error occurred while starting the application.
AggregateException: One or more errors occurred. (Not connected to a gateway)
System.Threading.Tasks.Task.ThrowIfExceptional(bool includeTaskCanceledExceptions)

OrleansException: Not connected to a gateway
Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()

AggregateException: One or more errors occurred. (Not connected to a gateway)
System.Threading.Tasks.Task.ThrowIfExceptional(bool includeTaskCanceledExceptions)
System.Threading.Tasks.Task.Wait(int millisecondsTimeout CancellationToken cancellationToken)
NetCoreSPA.Startup+&lt;&gt;c__DisplayClass5_0.&lt;ConfigureServices&gt;b__0(IServiceProvider sp) in Startup.cs
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitFactory(FactoryCallSite factoryCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor.VisitCallSite(IServiceCallSite callSite TArgument argument)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitSingleton(SingletonCallSite singletonCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor.VisitCallSite(IServiceCallSite callSite TArgument argument)
Microsoft.Extensions.DependencyInjection.ServiceProvider+&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType)
Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService&lt;T&gt;(IServiceProvider provider)
NetCoreSPA.Startup.Configure(IApplicationBuilder app IHostingEnvironment env) in Startup.cs
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
Microsoft.AspNetCore.Hosting.ConventionBasedStartup.Configure(IApplicationBuilder app)
Microsoft.AspNetCore.Server.IISIntegration.IISSetupFilter+&lt;&gt;c__DisplayClass3_0.&lt;Configure&gt;b__0(IApplicationBuilder app)
Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter+&lt;&gt;c__DisplayClass0_0.&lt;Configure&gt;b__0(IApplicationBuilder builder)
Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()

Show raw exception details
OrleansException: Not connected to a gateway
Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
Orleans.OutsideRuntimeClient+&lt;StreamingInitialize&gt;d__56.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;StartInternal&gt;d__58.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;Start&gt;d__57.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.ClusterClient+&lt;Connect&gt;d__19.MoveNext()

Show raw exception details
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__58.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__57.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.ClusterClient.&lt;Connect&gt;d__19.MoveNext()


![image](https://user-images.githubusercontent.com/37177494/38605000-b70a555a-3d8f-11e8-9563-3f0d0b69ff52.png)
</Description>
    <Title_Description>One or more errors occurred. (Not connected to a gateway) Hi

We are running 2 small sized worker roles (Orleans 2.0) and client app service (ASP.Net core) also networked as per the [documentation](http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Using-Azure-Web-Apps.html) App service and orleans silo(cloudservice) share same vNET and configured the subnet of vNET to Network security group. Both workerrole and appservice use same clusterId and serviceId.

While trying to connect from azure app service(client) to orleans silo(workerrole) am getting an error in client as "Not connected to a gateway" can someone help me what configurations should do to resolve this?

Below is the error log

An error occurred while starting the application.
AggregateException: One or more errors occurred. (Not connected to a gateway)
System.Threading.Tasks.Task.ThrowIfExceptional(bool includeTaskCanceledExceptions)

OrleansException: Not connected to a gateway
Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()

AggregateException: One or more errors occurred. (Not connected to a gateway)
System.Threading.Tasks.Task.ThrowIfExceptional(bool includeTaskCanceledExceptions)
System.Threading.Tasks.Task.Wait(int millisecondsTimeout CancellationToken cancellationToken)
NetCoreSPA.Startup+&lt;&gt;c__DisplayClass5_0.&lt;ConfigureServices&gt;b__0(IServiceProvider sp) in Startup.cs
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitFactory(FactoryCallSite factoryCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor.VisitCallSite(IServiceCallSite callSite TArgument argument)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitSingleton(SingletonCallSite singletonCallSite ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteVisitor.VisitCallSite(IServiceCallSite callSite TArgument argument)
Microsoft.Extensions.DependencyInjection.ServiceProvider+&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(Type serviceType)
Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService&lt;T&gt;(IServiceProvider provider)
NetCoreSPA.Startup.Configure(IApplicationBuilder app IHostingEnvironment env) in Startup.cs
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
Microsoft.AspNetCore.Hosting.ConventionBasedStartup.Configure(IApplicationBuilder app)
Microsoft.AspNetCore.Server.IISIntegration.IISSetupFilter+&lt;&gt;c__DisplayClass3_0.&lt;Configure&gt;b__0(IApplicationBuilder app)
Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter+&lt;&gt;c__DisplayClass0_0.&lt;Configure&gt;b__0(IApplicationBuilder builder)
Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()

Show raw exception details
OrleansException: Not connected to a gateway
Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
Orleans.OutsideRuntimeClient+&lt;StreamingInitialize&gt;d__56.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;StartInternal&gt;d__58.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.OutsideRuntimeClient+&lt;Start&gt;d__57.MoveNext()
System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Orleans.ClusterClient+&lt;Connect&gt;d__19.MoveNext()

Show raw exception details
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;StartInternal&gt;d__58.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;Start&gt;d__57.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.ClusterClient.&lt;Connect&gt;d__19.MoveNext()


![image](https://user-images.githubusercontent.com/37177494/38605000-b70a555a-3d8f-11e8-9563-3f0d0b69ff52.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4446</IssueLabelID>
    <Title>Proposal for fine-grain control of package versions</Title>
    <Description>This is a proposal for #4445.

https://github.com/dotnet/orleans/commit/4d9e8de210f8542a5b8533dd0f74b98be2825b78 defines the build variables.

https://github.com/dotnet/orleans/commit/0689e7ff27cb613eb257cae4325f84736795f7fd moves intra-solution project references from .csproj files into per-directory `Directory
.Build.props` files and conditions them to either point to a .csproj or to a NuGet package.

https://github.com/dotnet/orleans/commit/1c8c1574479b0b9a9a71a2142c87004dd0d97f42 sets the target version for `Core` and `Runtime` to 2.1.0 for the next minor release.</Description>
    <Title_Description>Proposal for fine-grain control of package versions This is a proposal for #4445.

https://github.com/dotnet/orleans/commit/4d9e8de210f8542a5b8533dd0f74b98be2825b78 defines the build variables.

https://github.com/dotnet/orleans/commit/0689e7ff27cb613eb257cae4325f84736795f7fd moves intra-solution project references from .csproj files into per-directory `Directory
.Build.props` files and conditions them to either point to a .csproj or to a NuGet package.

https://github.com/dotnet/orleans/commit/1c8c1574479b0b9a9a71a2142c87004dd0d97f42 sets the target version for `Core` and `Runtime` to 2.1.0 for the next minor release.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4443</IssueLabelID>
    <Title>High memory consumption by SerializationContext in SerializationManager</Title>
    <Description>I noticed memory slowly being exhausted on client side servers.  A process dump from one server shows over 5GB of memory for SerializationContext records.  This averages 11MB / instance.

Count    TotalSize        Class Name
480        5629484224  System.Collections.Generic.Dictionary`2+Entry[[System.Object mscorlib][Orleans.Serialization.SerializationContext+Record Orleans]][]

Running !gcroot on a couple of these instances shows they are coming from the serializationContext field in the SerializationManager class.

00000007652bdd50 00007fff7c103534 Orleans.Messaging.ProxiedMessageCenter.WaitMessage(Categories System.Threading.CancellationToken)
        rbp+10: 00000007652bddb0
            -&gt;  0000010b15165fd8 Orleans.Messaging.ProxiedMessageCenter
            -&gt;  0000010794ebad60 Orleans.Serialization.SerializationManager
            -&gt;  0000010794ebaee0 System.Threading.ThreadLocal`1[[Orleans.Serialization.SerializationContext Orleans]]
            -&gt;  0000010794ebaf08 System.Threading.ThreadLocal`1+LinkedSlot[[Orleans.Serialization.SerializationContext Orleans]]
            -&gt;  0000010b1cde8998 System.Threading.ThreadLocal`1+LinkedSlot[[Orleans.Serialization.SerializationContext Orleans]]
.....

This process dump showed 591 background threads and based on the count above a lot of these seem to have an Orleans serialization context in thread local storage.  Would it be more memory efficient to keep a pool of SerializationContexts inside the SerializationManager instead of using ThreadLocal storage?  

Our application does have objects with large serialization subgraphs but even if we reduced this from an average of 11MB to say 2MB if there are 500 threads with a SerializationContext in local storage we're still looking at 1GB of consumed memory.  We don't create threads and most of the threads in the process dump are marked (Threadpool Worker) so I'm not sure we have a good way to reduce thread count.</Description>
    <Title_Description>High memory consumption by SerializationContext in SerializationManager I noticed memory slowly being exhausted on client side servers.  A process dump from one server shows over 5GB of memory for SerializationContext records.  This averages 11MB / instance.

Count    TotalSize        Class Name
480        5629484224  System.Collections.Generic.Dictionary`2+Entry[[System.Object mscorlib][Orleans.Serialization.SerializationContext+Record Orleans]][]

Running !gcroot on a couple of these instances shows they are coming from the serializationContext field in the SerializationManager class.

00000007652bdd50 00007fff7c103534 Orleans.Messaging.ProxiedMessageCenter.WaitMessage(Categories System.Threading.CancellationToken)
        rbp+10: 00000007652bddb0
            -&gt;  0000010b15165fd8 Orleans.Messaging.ProxiedMessageCenter
            -&gt;  0000010794ebad60 Orleans.Serialization.SerializationManager
            -&gt;  0000010794ebaee0 System.Threading.ThreadLocal`1[[Orleans.Serialization.SerializationContext Orleans]]
            -&gt;  0000010794ebaf08 System.Threading.ThreadLocal`1+LinkedSlot[[Orleans.Serialization.SerializationContext Orleans]]
            -&gt;  0000010b1cde8998 System.Threading.ThreadLocal`1+LinkedSlot[[Orleans.Serialization.SerializationContext Orleans]]
.....

This process dump showed 591 background threads and based on the count above a lot of these seem to have an Orleans serialization context in thread local storage.  Would it be more memory efficient to keep a pool of SerializationContexts inside the SerializationManager instead of using ThreadLocal storage?  

Our application does have objects with large serialization subgraphs but even if we reduced this from an average of 11MB to say 2MB if there are 500 threads with a SerializationContext in local storage we're still looking at 1GB of consumed memory.  We don't create threads and most of the threads in the process dump are marked (Threadpool Worker) so I'm not sure we have a good way to reduce thread count.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4442</IssueLabelID>
    <Title>StructureMap and Orleans</Title>
    <Description>Hi! I try to integrate the StructureMap in Orleans (v 2.0.0).

I use the following code:

```cs
var builder = new SiloHostBuilder()
    .UseServiceProviderFactory(new StructureMapServiceProviderFactory(new MyRegistry());
```

`StructureMapServiceProviderFactory` implements a method:
```cs
public Registry CreateBuilder(IServiceCollection services)
{
    var registry = Registry ?? new Registry();
    registry.Populate(services);
    return registry;
}
```

But call to `registry.Populate(services)` throws an exception:
"Specified argument was out of the range of valid values.
Parameter name: Orleans.Runtime.StatelessWorkerPlacement must have at least one public constructor to be plugged in by StructureMap".

So what is the correct way to inject StructureMap into Orleans DI framework?</Description>
    <Title_Description>StructureMap and Orleans Hi! I try to integrate the StructureMap in Orleans (v 2.0.0).

I use the following code:

```cs
var builder = new SiloHostBuilder()
    .UseServiceProviderFactory(new StructureMapServiceProviderFactory(new MyRegistry());
```

`StructureMapServiceProviderFactory` implements a method:
```cs
public Registry CreateBuilder(IServiceCollection services)
{
    var registry = Registry ?? new Registry();
    registry.Populate(services);
    return registry;
}
```

But call to `registry.Populate(services)` throws an exception:
"Specified argument was out of the range of valid values.
Parameter name: Orleans.Runtime.StatelessWorkerPlacement must have at least one public constructor to be plugged in by StructureMap".

So what is the correct way to inject StructureMap into Orleans DI framework?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4441</IssueLabelID>
    <Title>Large Number of threads</Title>
    <Description>is a large number of threads used by a silo an indication of blocking IO operation ?
and what could be else  causing such ?

by large number i mean 600 threads per silo

</Description>
    <Title_Description>Large Number of threads is a large number of threads used by a silo an indication of blocking IO operation ?
and what could be else  causing such ?

by large number i mean 600 threads per silo

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4439</IssueLabelID>
    <Title>Azure blob storage provider ignores UseJson option</Title>
    <Description>Currently the provider does not access the UseJson property and will always use JSON for serialization.</Description>
    <Title_Description>Azure blob storage provider ignores UseJson option Currently the provider does not access the UseJson property and will always use JSON for serialization.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4438</IssueLabelID>
    <Title>Clarify UseDevelopmentClustering and UseLocalhostClustering</Title>
    <Description>Fixes #4421
</Description>
    <Title_Description>Clarify UseDevelopmentClustering and UseLocalhostClustering Fixes #4421
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4437</IssueLabelID>
    <Title>[2.0][question] Is it possible to opt out (partially) from CodeGen?</Title>
    <Description>When I have a custom serializer for the grain state is it necessary to generate anything for it?

Currently I refer System.Activities + related .dll-s codegen goes berserk and generates the whole world and beyond it generates 2k lines of code even for `System.Func`. But when I use XAML and there are generated .cs files from XAML it generates 5k lines. The generation is slow the build is slow the startup is slow. :(

[2k line repro](https://github.com/OrleansContrib/Orleans.Activities/tree/samples-master)
[2k line repro "permalink"](https://github.com/OrleansContrib/Orleans.Activities/tree/577e7651df59e8d80dfda3642a059e4ec8ca7a2b)
**NOTE:** This is the plain/coded (.cs) activity version. This version runs.

[5k line repro](https://github.com/lmagyar/Orleans.Activities/tree/samples-xaml)
[5k line repro "permalink"](https://github.com/lmagyar/Orleans.Activities/tree/75f54b293bd06a1a71d4ce490e864117b7d5571d)
**NOTE:** This is the designed (.xaml) activity version. *It builds but won't run! Xaml codegen is another Vietnam.* :/ WIP

The HelloGrain's State:
```
    public class WorkflowState : IWorkflowState
    {
        public IDictionary&lt;XName InstanceValue&gt; InstanceValues { get; set; }
        public WorkflowIdentity WorkflowDefinitionIdentity { get; set; }
    }
```

There is a custom serializer in the Orleans.Activities NuGet pkg for the first field (the other is a string/int bag). The InstanceValue dictionary contains eg. the WF state depends heavily on the DataContract/DataMember world there is a good chance it will always require a custom serializer.
```
    [Serializer(typeof(Dictionary&lt;XName InstanceValue&gt;))]
    public static class InstanceValueDictionarySerializer
    { ... }
```
**NOTE:** It refers the `Dictionary` class not the `IDictionary` interface.

Is it somehow possible to opt out on some level from codegen? Eg. opt out the complete chain starting from System.Activities and other assemblies and optionally opt in some simple types???</Description>
    <Title_Description>[2.0][question] Is it possible to opt out (partially) from CodeGen? When I have a custom serializer for the grain state is it necessary to generate anything for it?

Currently I refer System.Activities + related .dll-s codegen goes berserk and generates the whole world and beyond it generates 2k lines of code even for `System.Func`. But when I use XAML and there are generated .cs files from XAML it generates 5k lines. The generation is slow the build is slow the startup is slow. :(

[2k line repro](https://github.com/OrleansContrib/Orleans.Activities/tree/samples-master)
[2k line repro "permalink"](https://github.com/OrleansContrib/Orleans.Activities/tree/577e7651df59e8d80dfda3642a059e4ec8ca7a2b)
**NOTE:** This is the plain/coded (.cs) activity version. This version runs.

[5k line repro](https://github.com/lmagyar/Orleans.Activities/tree/samples-xaml)
[5k line repro "permalink"](https://github.com/lmagyar/Orleans.Activities/tree/75f54b293bd06a1a71d4ce490e864117b7d5571d)
**NOTE:** This is the designed (.xaml) activity version. *It builds but won't run! Xaml codegen is another Vietnam.* :/ WIP

The HelloGrain's State:
```
    public class WorkflowState : IWorkflowState
    {
        public IDictionary&lt;XName InstanceValue&gt; InstanceValues { get; set; }
        public WorkflowIdentity WorkflowDefinitionIdentity { get; set; }
    }
```

There is a custom serializer in the Orleans.Activities NuGet pkg for the first field (the other is a string/int bag). The InstanceValue dictionary contains eg. the WF state depends heavily on the DataContract/DataMember world there is a good chance it will always require a custom serializer.
```
    [Serializer(typeof(Dictionary&lt;XName InstanceValue&gt;))]
    public static class InstanceValueDictionarySerializer
    { ... }
```
**NOTE:** It refers the `Dictionary` class not the `IDictionary` interface.

Is it somehow possible to opt out on some level from codegen? Eg. opt out the complete chain starting from System.Activities and other assemblies and optionally opt in some simple types???</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4436</IssueLabelID>
    <Title>Issues with IClusterClient</Title>
    <Description>1. Should we call `Close()` or `Dispose()` to clean up the client or both?
2. IClusterClient has an awaitable `Connect()` method whereas ISiloHost has an awaitable `StartAsync()`. That -Async() suffix is inconsistent. I know Microsoft recommends the -Async() suffix but the Orleans team had decided against it a while back. Either way it should be consistent. Personally I prefer the -Async() suffix as it is immediately recognisable as needing an `await` (or other Task-based approach).</Description>
    <Title_Description>Issues with IClusterClient 1. Should we call `Close()` or `Dispose()` to clean up the client or both?
2. IClusterClient has an awaitable `Connect()` method whereas ISiloHost has an awaitable `StartAsync()`. That -Async() suffix is inconsistent. I know Microsoft recommends the -Async() suffix but the Orleans team had decided against it a while back. Either way it should be consistent. Personally I prefer the -Async() suffix as it is immediately recognisable as needing an `await` (or other Task-based approach).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4434</IssueLabelID>
    <Title>Orleans Streams Extensibility: Writing a Custom Queue Adapter for 2.0</Title>
    <Description>Team
Please guide me how to implement custom stream provider.

Below documentation doesn't seems to be correct for Orleans 2.0.
https://dotnet.github.io/orleans/Documentation/Orleans-Streams/Streams-Extensibility.html

Step 4: as per above link
4. Declare public class MyQueueStreamProvider : PersistentStreamProvider&lt;MyQueueFactory&gt;. This is your new Stream Provider.

Thanks</Description>
    <Title_Description>Orleans Streams Extensibility: Writing a Custom Queue Adapter for 2.0 Team
Please guide me how to implement custom stream provider.

Below documentation doesn't seems to be correct for Orleans 2.0.
https://dotnet.github.io/orleans/Documentation/Orleans-Streams/Streams-Extensibility.html

Step 4: as per above link
4. Declare public class MyQueueStreamProvider : PersistentStreamProvider&lt;MyQueueFactory&gt;. This is your new Stream Provider.

Thanks</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4431</IssueLabelID>
    <Title>NullReferenceException when Silo is configured to use EventHub</Title>
    <Description>We're trying to use `Orleans.ServiceBus.Providers` and connect to EventHub.

After updating from 2.0.0 rc2 to 2.0.0 final the following is observed:

On silo startup we get this exception:
```
fail: Orleans.Streams.*stg/9217687724268098230/d77a92b6.series[103303]
      QueueAdapterReceiver series-0-0x00000000 failed to Initialize.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.ServiceBus.Providers.EventHubCheckpointerFactory.Create(String partition)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.&lt;Initialize&gt;d__21.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;SafeExecute&gt;d__10.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;LogException&gt;d__9.MoveNext()
```

then finally the log is filled with these:
```
fail: Orleans.Streams.*stg/11935023428790472333/f3054e8d.series[103312]
      Giving up reading from queue series-1 after retry attempts 6
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetMaxAddCount()
   at Orleans.Streams.PersistentStreamPullingAgent.&lt;AsyncTimerCallback&gt;d__35.MoveNext()
```

This is the config (in f# I'm sorry):

```
module StreamConfig = 
    let configureEventHubOptions =
        new Action&lt;EventHubOptions&gt;(fun options -&gt;
                    options.ConnectionString &lt;- "Endpoint=..."
                    options.ConsumerGroup &lt;-"prsiloquestionmark" //https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-features
                    options.Path &lt;- "series"
        )
    let configureDefaultCheckpointer =
        new Action&lt;AzureTableStreamCheckpointerOptions&gt;(fun options -&gt;
            options.ConnectionString &lt;- "DefaultEndpointsProtocol=..."
            options.TableName &lt;- "series"
            options.PersistInterval &lt;- TimeSpan.FromSeconds(10.)
        )
...
.AddEventHubStreams("series" StreamConfig.configureEventHubOptions StreamConfig.configureDefaultCheckpointer)
...


```



</Description>
    <Title_Description>NullReferenceException when Silo is configured to use EventHub We're trying to use `Orleans.ServiceBus.Providers` and connect to EventHub.

After updating from 2.0.0 rc2 to 2.0.0 final the following is observed:

On silo startup we get this exception:
```
fail: Orleans.Streams.*stg/9217687724268098230/d77a92b6.series[103303]
      QueueAdapterReceiver series-0-0x00000000 failed to Initialize.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.ServiceBus.Providers.EventHubCheckpointerFactory.Create(String partition)
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.&lt;Initialize&gt;d__21.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;SafeExecute&gt;d__10.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;LogException&gt;d__9.MoveNext()
```

then finally the log is filled with these:
```
fail: Orleans.Streams.*stg/11935023428790472333/f3054e8d.series[103312]
      Giving up reading from queue series-1 after retry attempts 6
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.GetMaxAddCount()
   at Orleans.Streams.PersistentStreamPullingAgent.&lt;AsyncTimerCallback&gt;d__35.MoveNext()
```

This is the config (in f# I'm sorry):

```
module StreamConfig = 
    let configureEventHubOptions =
        new Action&lt;EventHubOptions&gt;(fun options -&gt;
                    options.ConnectionString &lt;- "Endpoint=..."
                    options.ConsumerGroup &lt;-"prsiloquestionmark" //https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-features
                    options.Path &lt;- "series"
        )
    let configureDefaultCheckpointer =
        new Action&lt;AzureTableStreamCheckpointerOptions&gt;(fun options -&gt;
            options.ConnectionString &lt;- "DefaultEndpointsProtocol=..."
            options.TableName &lt;- "series"
            options.PersistInterval &lt;- TimeSpan.FromSeconds(10.)
        )
...
.AddEventHubStreams("series" StreamConfig.configureEventHubOptions StreamConfig.configureDefaultCheckpointer)
...


```



</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4428</IssueLabelID>
    <Title>[2.0]Orleans does not have an instance or document for unit testing. Only 1.5 versions of the document seem to be outdated.</Title>
    <Description>Orleans does not have an instance or document for unit testing. Only 1.5 versions of the document seem to be outdated.</Description>
    <Title_Description>[2.0]Orleans does not have an instance or document for unit testing. Only 1.5 versions of the document seem to be outdated. Orleans does not have an instance or document for unit testing. Only 1.5 versions of the document seem to be outdated.</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4427</IssueLabelID>
    <Title>ClusterClient.Connect() retryFilter causes NullReferenceException</Title>
    <Description>Introduced with #4161.

First bug (?): When client tries to connect but fails in `OutsideRuntimeClient.StartInternal` inside the first `ExecuteWithRetries` it throws `OrleansException` instead of `SiloUnavailableException`.

Second bug: Later in this StartInternal after another connection error when the filter returns true it retries successfully but at the first `GetGrain()` call it throws a `NullReferenceException` somewhere inside.

Based on this:
```
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
```
It's some streaming reconnection error. It seems when there is a streaming connection issue it's still better to recreate the whole client. :(

See the repro at [lmagyar/ClientConnectRetryFilterBugRepro](https://github.com/lmagyar/ClientConnectRetryFilterBugRepro) it's basically a vanilla HelloWorld that uses runtime codegen to be slow enough. Start client manually wait 2 seconds start silo you have to try it several times to be successful to repro. See output below.

```

Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\bin\Debug&gt;Orleans.Activities.Samples.HelloWorld.DevClusterClient.exe
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on XXX at XXX Client Id = *cli/53be99bc ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.0. Commit Hash: 89ebbe67d2266b24b34e704935fe70577d30408a (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=Orleans.Activities.Samples.HelloWorld.DevClusterClient.exe&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:41
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:42
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/53be99bc@43dd8d83-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/53be99bc@43dd8d83 #2:
warn: Orleans.OutsideRuntimeClient[104202]
      Refresh the GrainTypeResolver failed. WIll be retried after
Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/53be99bc@43dd8d83-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;RefreshGrainTypeResolver&gt;d__59.MoveNext()


****************************************************************
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
****************************************************************


Attempt 1 of 5 failed to initialize the Orleans client.

warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:43
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100908]
      Connected to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0.
info: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[0]
      Starting AsyncAgent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 on managed thread 12
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[0]
      Starting AsyncAgent Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0 on managed thread 13
info: Orleans.OutsideRuntimeClient[100929]
      ---------- Started OutsideRuntimeClient with Global Client ID: CXXX:0:-260926481*cli/53be99bc@43dd8d83 client GUID ID: *cli/53be99bc
info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClientMessagingOptions:
      ClientSenderBuckets: 8192
      PreferredFamily: InterNetwork
      NetworkInterfaceName:
      ResponseTimeout: 00:00:30
      ResponseTimeoutWithDebugger: 00:30:00
      MaxResendCount: 0
      ResendOnTimeout: False
      DropExpiredMessages: True
      BufferPoolBufferSize: 4096
      BufferPoolMaxSize: 10000
      BufferPoolPreallocationSize: 250
      PropagateActivityId: False

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClientStatisticsOptions:
      PerfCountersWriteInterval: -00:00:00.0010000
      LogWriteInterval: 00:05:00
      CollectionLevel: Info

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClusterOptions:
      ClusterId: dev
      ServiceId:

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.NetworkingOptions:
      OpenConnectionTimeout: 00:00:05
      MaxSocketAge: 10675199.02:48:05.4775807

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.StaticGatewayListProviderOptions:
      Gateways.0: gwy.tcp://127.0.0.1:30000/0

info: Orleans.LifecycleSubject[100452]
      Starting lifecycle stage -2147483648 took 22 Milliseconds
Client successfully connected to silo host.


****************************************************************
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
   at Orleans.GrainFactory.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
   at Orleans.ClusterClient.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
   at DevClusterClient.Program.&lt;DoClientWorkAsync&gt;d__6.MoveNext() in Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\Program.cs:line 120
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at DevClusterClient.Program.&lt;Main&gt;d__1.MoveNext() in Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\Program.cs:line 28
****************************************************************

Press Enter to terminate...
```</Description>
    <Title_Description>ClusterClient.Connect() retryFilter causes NullReferenceException Introduced with #4161.

First bug (?): When client tries to connect but fails in `OutsideRuntimeClient.StartInternal` inside the first `ExecuteWithRetries` it throws `OrleansException` instead of `SiloUnavailableException`.

Second bug: Later in this StartInternal after another connection error when the filter returns true it retries successfully but at the first `GetGrain()` call it throws a `NullReferenceException` somewhere inside.

Based on this:
```
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
```
It's some streaming reconnection error. It seems when there is a streaming connection issue it's still better to recreate the whole client. :(

See the repro at [lmagyar/ClientConnectRetryFilterBugRepro](https://github.com/lmagyar/ClientConnectRetryFilterBugRepro) it's basically a vanilla HelloWorld that uses runtime codegen to be slow enough. Start client manually wait 2 seconds start silo you have to try it several times to be successful to repro. See output below.

```

Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\bin\Debug&gt;Orleans.Activities.Samples.HelloWorld.DevClusterClient.exe
info: Orleans.OutsideRuntimeClient[100313]
      ---------- Initializing OutsideRuntimeClient on XXX at XXX Client Id = *cli/53be99bc ----------
info: Orleans.OutsideRuntimeClient[100314]
      ---------- Starting OutsideRuntimeClient with runtime Version='2.0.0. Commit Hash: 89ebbe67d2266b24b34e704935fe70577d30408a (Release).' in AppDomain=&lt;AppDomain.Id=1 AppDomain.FriendlyName=Orleans.Activities.Samples.HelloWorld.DevClusterClient.exe&gt;
info: Orleans.Messaging.GatewayManager[101309]
      Found 1 knownGateways from Gateway listProvider [gwy.tcp://127.0.0.1:30000/0]
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:41
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100178]
      Unable to connect to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 1 (Exception: Could not connect to 127.0.0.1:30000: ConnectionRefused)
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100913]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Disconnected
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:42
warn: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100912]
      Marking gateway at address gwy.tcp://127.0.0.1:30000/0 as Dead in my client local gateway list.
warn: Orleans.Runtime.CallbackData[100157]
      The target silo became unavailable for message: Request *cli/53be99bc@43dd8d83-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help. About to break its promise.
warn: Orleans.OutsideRuntimeClient[100011]
      No callback for response message: Unrecoverable Rejection (info: Target silo S127.0.0.1:30000:0 is unavailable) Response S127.0.0.1:30000:0*stg/17/00000011@S00000011-&gt;*cli/53be99bc@43dd8d83 #2:
warn: Orleans.OutsideRuntimeClient[104202]
      Refresh the GrainTypeResolver failed. WIll be retried after
Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/53be99bc@43dd8d83-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Target History is: &lt;S127.0.0.1:30000:0:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;RefreshGrainTypeResolver&gt;d__59.MoveNext()


****************************************************************
Orleans.Runtime.OrleansException: Not connected to a gateway
   at Orleans.Messaging.ClientMessageCenter.GetLiveGatewaySiloAddress()
   at Orleans.Messaging.ClientMessageCenter.GetImplicitStreamSubscriberTable(IInternalGrainFactory grainFactory)
   at Orleans.OutsideRuntimeClient.&lt;StreamingInitialize&gt;d__56.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OutsideRuntimeClient.&lt;&lt;StartInternal&gt;g__ExecuteWithRetries58_3&gt;d.MoveNext()
****************************************************************


Attempt 1 of 5 failed to initialize the Orleans client.

warn: Orleans.Messaging.GatewayManager[101321]
      All gateways have previously been marked as dead. Clearing the list of dead gateways to expedite reconnection.
info: Orleans.Messaging.GatewayManager[101309]
      Refreshed the live Gateway list. Found 1 gateways from Gateway listProvider: [gwy.tcp://127.0.0.1:30000/0]. Picked only known live out of them. Now has 1 live Gateways: [gwy.tcp://127.0.0.1:30000/0]. Previous refresh time was = 04/08/2018 23:34:43
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[100908]
      Connected to gateway at address gwy.tcp://127.0.0.1:30000/0 on trial 0.
info: Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0[0]
      Starting AsyncAgent Messaging.GatewayClientReceiver/gwy.tcp://127.0.0.1:30000/0 on managed thread 12
info: Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0[0]
      Starting AsyncAgent Messaging.GatewayConnection/GatewayClientSender_gwy.tcp://127.0.0.1:30000/0 on managed thread 13
info: Orleans.OutsideRuntimeClient[100929]
      ---------- Started OutsideRuntimeClient with Global Client ID: CXXX:0:-260926481*cli/53be99bc@43dd8d83 client GUID ID: *cli/53be99bc
info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClientMessagingOptions:
      ClientSenderBuckets: 8192
      PreferredFamily: InterNetwork
      NetworkInterfaceName:
      ResponseTimeout: 00:00:30
      ResponseTimeoutWithDebugger: 00:30:00
      MaxResendCount: 0
      ResendOnTimeout: False
      DropExpiredMessages: True
      BufferPoolBufferSize: 4096
      BufferPoolMaxSize: 10000
      BufferPoolPreallocationSize: 250
      PropagateActivityId: False

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClientStatisticsOptions:
      PerfCountersWriteInterval: -00:00:00.0010000
      LogWriteInterval: 00:05:00
      CollectionLevel: Info

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.ClusterOptions:
      ClusterId: dev
      ServiceId:

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.NetworkingOptions:
      OpenConnectionTimeout: 00:00:05
      MaxSocketAge: 10675199.02:48:05.4775807

info: Orleans.ClientOptionsLogger[0]
      Configuration Orleans.Configuration.StaticGatewayListProviderOptions:
      Gateways.0: gwy.tcp://127.0.0.1:30000/0

info: Orleans.LifecycleSubject[100452]
      Starting lifecycle stage -2147483648 took 22 Milliseconds
Client successfully connected to silo host.


****************************************************************
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
   at Orleans.GrainFactory.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
   at Orleans.ClusterClient.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
   at DevClusterClient.Program.&lt;DoClientWorkAsync&gt;d__6.MoveNext() in Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\Program.cs:line 120
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at DevClusterClient.Program.&lt;Main&gt;d__1.MoveNext() in Z:\Local\GitHub\lmagyar\ClientConnectRetryFilterBugRepro\src\Orleans.Activities.Samples.HelloWorld.DevClusterClient\Program.cs:line 28
****************************************************************

Press Enter to terminate...
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4426</IssueLabelID>
    <Title>Azure Queues Orleans.Streams.QueueCacheMissException </Title>
    <Description>We are using 2.0.0 with Azure Queues we are getting a `QueueCacheMissException` on some of our streams while other streams are working as expected. We are basically using the default configuration to use streams with a small load. I found some info on configuring a cache size but I havent found any examples in the Tests or Samples.

```
Item not found in cache. Requested: [EventSequenceTokenV2: SeqNum=28 EventIndex=0]
 Low: [EventSequenceTokenV2: SeqNum=29 EventIndex=0] High: [EventSequenceTokenV2:
SeqNum=29 EventIndex=0]
```

```
Exception while retrying the 0th time reading from queue default-2
```

Configuration:
```
.AddAzureQueueStreams&lt;AzureQueueDataAdapterV2&gt;("Default" ob =&gt; ob.Configure(options =&gt;
                    {
                        options.ConnectionString = queueConnection;
                    }))
```</Description>
    <Title_Description>Azure Queues Orleans.Streams.QueueCacheMissException  We are using 2.0.0 with Azure Queues we are getting a `QueueCacheMissException` on some of our streams while other streams are working as expected. We are basically using the default configuration to use streams with a small load. I found some info on configuring a cache size but I havent found any examples in the Tests or Samples.

```
Item not found in cache. Requested: [EventSequenceTokenV2: SeqNum=28 EventIndex=0]
 Low: [EventSequenceTokenV2: SeqNum=29 EventIndex=0] High: [EventSequenceTokenV2:
SeqNum=29 EventIndex=0]
```

```
Exception while retrying the 0th time reading from queue default-2
```

Configuration:
```
.AddAzureQueueStreams&lt;AzureQueueDataAdapterV2&gt;("Default" ob =&gt; ob.Configure(options =&gt;
                    {
                        options.ConnectionString = queueConnection;
                    }))
```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4421</IssueLabelID>
    <Title>Local and Development clustering?</Title>
    <Description>`SiloHostBuilder` has the following two methods:

![image](https://user-images.githubusercontent.com/13241564/38455897-2294377c-3a76-11e8-8a3d-93a869c97bde.png)

I'm not sure if these are documented anywhere but the documentation we get in VS doesn't tell much about what they actually do:

* `UseLocalhostClustering()` says: "Configures a localhost silo for development and testing".
* `UseDevelopmentClustering()` says: "Configures the silo to use development-only clustering".

What is the difference between localhost and development clustering? What is involved in the "development and testing" configuration? What does "development-only" clustering mean?

The method docs should be improved to explain what they actually do and why there are two different methods for what seems to be the same thing. This should also be added to the online documentation if it is not already there.</Description>
    <Title_Description>Local and Development clustering? `SiloHostBuilder` has the following two methods:

![image](https://user-images.githubusercontent.com/13241564/38455897-2294377c-3a76-11e8-8a3d-93a869c97bde.png)

I'm not sure if these are documented anywhere but the documentation we get in VS doesn't tell much about what they actually do:

* `UseLocalhostClustering()` says: "Configures a localhost silo for development and testing".
* `UseDevelopmentClustering()` says: "Configures the silo to use development-only clustering".

What is the difference between localhost and development clustering? What is involved in the "development and testing" configuration? What does "development-only" clustering mean?

The method docs should be improved to explain what they actually do and why there are two different methods for what seems to be the same thing. This should also be added to the online documentation if it is not already there.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4420</IssueLabelID>
    <Title>Application Parts usability issues</Title>
    <Description>I think there are several areas where this new "Application Parts" concept can be improved.

First of all why "application parts"? As someone new to the term I see it as something very vague and unintuitive. What is an "application part" anyway? Is it just a location where grains are loaded or does it serve some additional purpose? Why was there the need to confuse people with a new term rather than just providing an API like `LoadGrains(...)`?

As a result of this I find the following code (from [here](https://github.com/dotnet/orleans/blob/master/Samples/2.0/HelloWorld/src/SiloHost/Program.cs) the Hello World sample) completely unreadable:

    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences())

Looking at this one wonders:

1. What is an "application part"?
2. Why do I give it an assembly?
3. What does `WithReferences()` do?

Well let's check out the method documentation:

![image](https://user-images.githubusercontent.com/13241564/38455761-aa8b1012-3a74-11e8-85f3-bb323411a625.png)

![image](https://user-images.githubusercontent.com/13241564/38455769-bf2421d0-3a74-11e8-893a-31da9eb28631.png)

![image](https://user-images.githubusercontent.com/13241564/38455773-dde649f4-3a74-11e8-8eee-541c730f616e.png)

![image](https://user-images.githubusercontent.com/13241564/38455780-ebde5308-3a74-11e8-9f5e-a20907dbcff2.png)

As it turns out [Application Parts documentation](https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html) is buried deep within the Deployment section of the documentation.

&gt; "Although this step is not technically required (if not configured Orleans will scan all assembly in the current folder) developers are encouraged to configure this. This step will help Orleans to load user assemblies and types. These assemblies are referred to as Application Parts. All Grains Grain Interfaces and Serializers are discovered using Application Parts."

If developers are encouraged to configure application parts then I believe they should be referenced in all documentation which describes setting up a basic silo. That includes the [Hello World sample documentation](https://dotnet.github.io/orleans/Documentation/Samples-Overview/Hello-World.html) and [Running the Application](https://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Running-the-Application.html) (although this needs to be cleaned up first as per #4416).</Description>
    <Title_Description>Application Parts usability issues I think there are several areas where this new "Application Parts" concept can be improved.

First of all why "application parts"? As someone new to the term I see it as something very vague and unintuitive. What is an "application part" anyway? Is it just a location where grains are loaded or does it serve some additional purpose? Why was there the need to confuse people with a new term rather than just providing an API like `LoadGrains(...)`?

As a result of this I find the following code (from [here](https://github.com/dotnet/orleans/blob/master/Samples/2.0/HelloWorld/src/SiloHost/Program.cs) the Hello World sample) completely unreadable:

    .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(HelloGrain).Assembly).WithReferences())

Looking at this one wonders:

1. What is an "application part"?
2. Why do I give it an assembly?
3. What does `WithReferences()` do?

Well let's check out the method documentation:

![image](https://user-images.githubusercontent.com/13241564/38455761-aa8b1012-3a74-11e8-85f3-bb323411a625.png)

![image](https://user-images.githubusercontent.com/13241564/38455769-bf2421d0-3a74-11e8-893a-31da9eb28631.png)

![image](https://user-images.githubusercontent.com/13241564/38455773-dde649f4-3a74-11e8-8eee-541c730f616e.png)

![image](https://user-images.githubusercontent.com/13241564/38455780-ebde5308-3a74-11e8-9f5e-a20907dbcff2.png)

As it turns out [Application Parts documentation](https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html) is buried deep within the Deployment section of the documentation.

&gt; "Although this step is not technically required (if not configured Orleans will scan all assembly in the current folder) developers are encouraged to configure this. This step will help Orleans to load user assemblies and types. These assemblies are referred to as Application Parts. All Grains Grain Interfaces and Serializers are discovered using Application Parts."

If developers are encouraged to configure application parts then I believe they should be referenced in all documentation which describes setting up a basic silo. That includes the [Hello World sample documentation](https://dotnet.github.io/orleans/Documentation/Samples-Overview/Hello-World.html) and [Running the Application](https://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Running-the-Application.html) (although this needs to be cleaned up first as per #4416).</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4419</IssueLabelID>
    <Title>Issues with Hello World sample documentation</Title>
    <Description>The [Hello World sample documentation](https://dotnet.github.io/orleans/Documentation/Samples-Overview/Hello-World.html) could use a few improvements:

1. Missing `var` before `client` in the third code sample.
2. Why use explicit interfaces? This only makes it harder for whoever wants to copy and paste the example as they have to clean up the namespace before they can use it.
3. It should mention any required dependencies (`Microsoft.Extensions.Logging.Console` in this case) as anyone not already familiar with that will be scratching his head and wondering why it's not working.
4. As per #4417 the code does not work if it all resides in the same project.

Additionally the interface/grain code samples can be simplified as follows:

    public interface IHello : IGrainWithIntegerKey
    {
        Task&lt;string&gt; SayHello(string greeting);
    }

    public class HelloGrain : Grain IHello
    {
        Task&lt;string&gt; IHello.SayHello(string greeting)
            =&gt; Task.FromResult($"You said: '{greeting}' I say: Hello!");
    }</Description>
    <Title_Description>Issues with Hello World sample documentation The [Hello World sample documentation](https://dotnet.github.io/orleans/Documentation/Samples-Overview/Hello-World.html) could use a few improvements:

1. Missing `var` before `client` in the third code sample.
2. Why use explicit interfaces? This only makes it harder for whoever wants to copy and paste the example as they have to clean up the namespace before they can use it.
3. It should mention any required dependencies (`Microsoft.Extensions.Logging.Console` in this case) as anyone not already familiar with that will be scratching his head and wondering why it's not working.
4. As per #4417 the code does not work if it all resides in the same project.

Additionally the interface/grain code samples can be simplified as follows:

    public interface IHello : IGrainWithIntegerKey
    {
        Task&lt;string&gt; SayHello(string greeting);
    }

    public class HelloGrain : Grain IHello
    {
        Task&lt;string&gt; IHello.SayHello(string greeting)
            =&gt; Task.FromResult($"You said: '{greeting}' I say: Hello!");
    }</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4418</IssueLabelID>
    <Title>Orleans not recognising ServerGC setting</Title>
    <Description>I am running Orleans in a .NET Core console app. The project is basically the same as #4417.

In order to turn on ServerGC I follow [this Stack Overflow answer](https://stackoverflow.com/a/44035370/983064) and add the following in my `.csproj` file:

    &lt;PropertyGroup&gt;
      &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
    &lt;/PropertyGroup&gt;

Despite this I still get the following warning:

&gt; info: Orleans.Runtime.Silo[100404]
&gt;       Silo starting with GC settings: ServerGC=False GCLatencyMode=Interactive
&gt; warn: Orleans.Runtime.Silo[100405]
&gt;       Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
&gt; warn: Orleans.Runtime.Silo[100405]
&gt;       Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).</Description>
    <Title_Description>Orleans not recognising ServerGC setting I am running Orleans in a .NET Core console app. The project is basically the same as #4417.

In order to turn on ServerGC I follow [this Stack Overflow answer](https://stackoverflow.com/a/44035370/983064) and add the following in my `.csproj` file:

    &lt;PropertyGroup&gt;
      &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
    &lt;/PropertyGroup&gt;

Despite this I still get the following warning:

&gt; info: Orleans.Runtime.Silo[100404]
&gt;       Silo starting with GC settings: ServerGC=False GCLatencyMode=Interactive
&gt; warn: Orleans.Runtime.Silo[100405]
&gt;       Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
&gt; warn: Orleans.Runtime.Silo[100405]
&gt;       Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4416</IssueLabelID>
    <Title>Running the Application documentation obsolete</Title>
    <Description>The [Running the Application](https://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Running-the-Application.html) documentation is obsolete probably based on Orleans 1.5 and does not work with Orleans 2.0.</Description>
    <Title_Description>Running the Application documentation obsolete The [Running the Application](https://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Running-the-Application.html) documentation is obsolete probably based on Orleans 1.5 and does not work with Orleans 2.0.</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4415</IssueLabelID>
    <Title>Startup Task fails when old member in membership table</Title>
    <Description>I cannot reproduce it yet but sometimes my application fails to start. When I have old members in the membership table I sometimes get this error:

```
S192.168.43.245:11111:260784881 is rejecting message: Request S192.168.43.245:11111:260784881*stg/14/0000000e@S0000000e-&gt;S191.168.43.245:11111:260780891*stg/10/0000000a@S0000000a #4: . Reason = Exception getting a sending socket to endpoint S191.168.43.245:11111:260780891
```

(I just changed the IP address of the entry to simulate it therefore the message might be not 100% correct). 

For me it seems that the startup tasks are running before the state of the old entries is clarified.  In my startup tasks I run a method on a grain to activate it.</Description>
    <Title_Description>Startup Task fails when old member in membership table I cannot reproduce it yet but sometimes my application fails to start. When I have old members in the membership table I sometimes get this error:

```
S192.168.43.245:11111:260784881 is rejecting message: Request S192.168.43.245:11111:260784881*stg/14/0000000e@S0000000e-&gt;S191.168.43.245:11111:260780891*stg/10/0000000a@S0000000a #4: . Reason = Exception getting a sending socket to endpoint S191.168.43.245:11111:260780891
```

(I just changed the IP address of the entry to simulate it therefore the message might be not 100% correct). 

For me it seems that the startup tasks are running before the state of the old entries is clarified.  In my startup tasks I run a method on a grain to activate it.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4414</IssueLabelID>
    <Title>Client hangs in 2.0</Title>
    <Description> In 2.0rc1 I used the following config. The client is co-hosted in the same process

```
// HOST
builder.UseMongoDBClustering()
builder.ConfigureEndpoints(Dns.GetHostName() 11111 40000 listenOnAnyHostAddress: true)

// Client
builder.UseLocalhostClustering(40000)
```

In 2.0 I see the following log entry and the client just hangs in  the connect method.

 ```
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101311]
Gateway received unexpected non-proxied connection from *sgn/01111111-1111-1111-1111-111111111111/11111111 at source address 127.0.0.1:51086
```

It works when I change it to:

    builder.ConfigureEndpoints(IPAddress.Loopback 11111 40000 listenOnAnyHostAddress: true)

But I have no idea how the advertised IP address is related to the client connection.</Description>
    <Title_Description>Client hangs in 2.0  In 2.0rc1 I used the following config. The client is co-hosted in the same process

```
// HOST
builder.UseMongoDBClustering()
builder.ConfigureEndpoints(Dns.GetHostName() 11111 40000 listenOnAnyHostAddress: true)

// Client
builder.UseLocalhostClustering(40000)
```

In 2.0 I see the following log entry and the client just hangs in  the connect method.

 ```
fail: Orleans.Runtime.Messaging.IncomingMessageAcceptor[101311]
Gateway received unexpected non-proxied connection from *sgn/01111111-1111-1111-1111-111111111111/11111111 at source address 127.0.0.1:51086
```

It works when I change it to:

    builder.ConfigureEndpoints(IPAddress.Loopback 11111 40000 listenOnAnyHostAddress: true)

But I have no idea how the advertised IP address is related to the client connection.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4413</IssueLabelID>
    <Title>Move Service Fabric projects to Azure folder</Title>
    <Description>For better code organization and to simplify future independent versioning of packages.</Description>
    <Title_Description>Move Service Fabric projects to Azure folder For better code organization and to simplify future independent versioning of packages.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4410</IssueLabelID>
    <Title>Issue in configuring Orleans Load balancing</Title>
    <Description>
I have 2 Silos running on 2 different ports and is using consul for clustering. Now I have multiple clients trying to connect to the host to invoke a grain but it seems the request is always going to the first silo. As soon as I bring the first Silo down the requests starts flowing to the 2nd Silo.

Not sure what I'm missing here any help is highly appreciated. Please find below the code for Silo host and the client. 

Silo Host configuration
+++++++++++++++
 var builder = new SiloHostBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Clust1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .UseConsulClustering(gatewayOptions =&gt;
                    {
                        gatewayOptions.Address =
                            new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    })
                    .Configure&lt;EndpointOptions&gt;(options =&gt;
                    {
                        options.SiloPort = Convert.ToInt32(ConfigurationManager.AppSettings["SiloPort"]);
                        options.GatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings["GatewayPort"]);
                        options.AdvertisedIPAddress =
                            IPAddress.Parse(ConfigurationManager.AppSettings["AdvertisedIPAddress"]);
                    })
                    .AddMemoryGrainStorageAsDefault();

                var host = builder.Build();
                host.StartAsync().Wait();

Client Configuration
+++++++++++++

 var builder = new SiloHostBuilder()
                    .UseLocalhostClustering()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Cluster1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback);
                var client = builder.Build();
                await client.StartAsync().Wait();




</Description>
    <Title_Description>Issue in configuring Orleans Load balancing 
I have 2 Silos running on 2 different ports and is using consul for clustering. Now I have multiple clients trying to connect to the host to invoke a grain but it seems the request is always going to the first silo. As soon as I bring the first Silo down the requests starts flowing to the 2nd Silo.

Not sure what I'm missing here any help is highly appreciated. Please find below the code for Silo host and the client. 

Silo Host configuration
+++++++++++++++
 var builder = new SiloHostBuilder()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Clust1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .UseConsulClustering(gatewayOptions =&gt;
                    {
                        gatewayOptions.Address =
                            new Uri(ConfigurationManager.AppSettings["ServiceDiscoverEndPoint"]);
                    })
                    .Configure&lt;EndpointOptions&gt;(options =&gt;
                    {
                        options.SiloPort = Convert.ToInt32(ConfigurationManager.AppSettings["SiloPort"]);
                        options.GatewayPort = Convert.ToInt32(ConfigurationManager.AppSettings["GatewayPort"]);
                        options.AdvertisedIPAddress =
                            IPAddress.Parse(ConfigurationManager.AppSettings["AdvertisedIPAddress"]);
                    })
                    .AddMemoryGrainStorageAsDefault();

                var host = builder.Build();
                host.StartAsync().Wait();

Client Configuration
+++++++++++++

 var builder = new SiloHostBuilder()
                    .UseLocalhostClustering()
                    .Configure&lt;ClusterOptions&gt;(options =&gt;
                    {
                        options.ClusterId = "Cluster1";
                        options.ServiceId = "Service1";
                    })
                    .UseServiceProviderFactory(HostStartUp.ConfigureServices)
                    .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback);
                var client = builder.Build();
                await client.StartAsync().Wait();




</Title_Description>
    <Label>P3</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4409</IssueLabelID>
    <Title>System.InvalidOperationException: 'Grain was created outside of the Orleans creation process and no runtime was specified.'</Title>
    <Description>Team

Am getting below exception while trying to call a grain in startup task during silohost generation:
System.InvalidOperationException: 'Grain was created outside of the Orleans creation process and no runtime was specified.'
Grain Constructor: Exception is thrown in first line : GetStreamProvider
public Aggregator()
        {
            var streamProvider = GetStreamProvider("samplestream");
            _stream = streamProvider.GetStream&lt;RequestMessage&gt;(Guid.NewGuid() "TestNamespace");
            this._observer = GrainFactory.GetGrain&lt;ITestObserver&gt;(Guid.Empty);
        }

Thanks</Description>
    <Title_Description>System.InvalidOperationException: 'Grain was created outside of the Orleans creation process and no runtime was specified.' Team

Am getting below exception while trying to call a grain in startup task during silohost generation:
System.InvalidOperationException: 'Grain was created outside of the Orleans creation process and no runtime was specified.'
Grain Constructor: Exception is thrown in first line : GetStreamProvider
public Aggregator()
        {
            var streamProvider = GetStreamProvider("samplestream");
            _stream = streamProvider.GetStream&lt;RequestMessage&gt;(Guid.NewGuid() "TestNamespace");
            this._observer = GrainFactory.GetGrain&lt;ITestObserver&gt;(Guid.Empty);
        }

Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4408</IssueLabelID>
    <Title>Move IHealthCheckable from Core.Abstractions to Core</Title>
    <Description>There is no need for IHealthCheckable to be in Core.Abstractions as it has nothing to do with developing grain code. If we don't move it we'll be forced to update the Core.Abstractions package in the next release which isn't really necessary.</Description>
    <Title_Description>Move IHealthCheckable from Core.Abstractions to Core There is no need for IHealthCheckable to be in Core.Abstractions as it has nothing to do with developing grain code. If we don't move it we'll be forced to update the Core.Abstractions package in the next release which isn't really necessary.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4407</IssueLabelID>
    <Title>DependencyResolutionException while using Autofac &amp; SMS</Title>
    <Description>Hello

After start using SMS in Host configuration I have been having below exceptions.  

Exception 1:
DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = IGrainStorage (DelegateActivator) Services = [Orleans.Storage.IGrainStorage] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope
Exception 2:
DependencyResolutionException: A delegate registered to create instances of 'Orleans.Storage.IGrainStorage' returned null.

Code Snippet:
var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = "TestCluster")
                .UseDevelopmentClustering(
                    options =&gt; options.PrimarySiloEndpoint = new IPEndPoint(siloAddress siloPort))
                .ConfigureEndpoints(siloAddress siloPort gatewayPort)
                .AddMemoryGrainStorage("PubSubStore")
                .AddSimpleMessageStreamProvider("Teststream")
                .UseServiceProviderFactory(Startup.ConfigureServices)
                .ConfigureApplicationParts(parts =&gt;
                    parts.AddApplicationPart(typeof(IEventAggregator).Assembly).WithReferences());

Startup:
  public static IServiceProvider ConfigureServices(IServiceCollection services)
        {
            var builder = new ContainerBuilder();
            builder.Populate(services);
            builder.RegisterModule&lt;TestModule&gt;();
            var container = builder.Build();
            //Create the IServiceProvider based on the container.
            return new AutofacServiceProvider(container);
        }</Description>
    <Title_Description>DependencyResolutionException while using Autofac &amp; SMS Hello

After start using SMS in Host configuration I have been having below exceptions.  

Exception 1:
DependencyResolutionException: An error occurred during the activation of a particular registration. See the inner exception for details. Registration: Activator = IGrainStorage (DelegateActivator) Services = [Orleans.Storage.IGrainStorage] Lifetime = Autofac.Core.Lifetime.RootScopeLifetime Sharing = Shared Ownership = OwnedByLifetimeScope
Exception 2:
DependencyResolutionException: A delegate registered to create instances of 'Orleans.Storage.IGrainStorage' returned null.

Code Snippet:
var builder = new SiloHostBuilder()
                .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = "TestCluster")
                .UseDevelopmentClustering(
                    options =&gt; options.PrimarySiloEndpoint = new IPEndPoint(siloAddress siloPort))
                .ConfigureEndpoints(siloAddress siloPort gatewayPort)
                .AddMemoryGrainStorage("PubSubStore")
                .AddSimpleMessageStreamProvider("Teststream")
                .UseServiceProviderFactory(Startup.ConfigureServices)
                .ConfigureApplicationParts(parts =&gt;
                    parts.AddApplicationPart(typeof(IEventAggregator).Assembly).WithReferences());

Startup:
  public static IServiceProvider ConfigureServices(IServiceCollection services)
        {
            var builder = new ContainerBuilder();
            builder.Populate(services);
            builder.RegisterModule&lt;TestModule&gt;();
            var container = builder.Build();
            //Create the IServiceProvider based on the container.
            return new AutofacServiceProvider(container);
        }</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4406</IssueLabelID>
    <Title>Remove hot string allocations in MessagingStatisticsGroup</Title>
    <Description>Avoids ~900 bytes of allocs per call.

Before:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 338.1 us | 254.3 us | 14.37 us | 3.4180 |  15.83 KB |

After:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 326.5 us | 85.51 us | 4.832 us | 3.4180 |  14.93 KB |

</Description>
    <Title_Description>Remove hot string allocations in MessagingStatisticsGroup Avoids ~900 bytes of allocs per call.

Before:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 338.1 us | 254.3 us | 14.37 us | 3.4180 |  15.83 KB |

After:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 326.5 us | 85.51 us | 4.832 us | 3.4180 |  14.93 KB |

</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>5/04/2018 10:12:50 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 10:39:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4405</IssueLabelID>
    <Title>Nullpointer exception when running ping benchmark in release mode</Title>
    <Description>debug mode runns fine but if i run ping benchmark in release i get this:

Running Ping benchmark
----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------


Unbehandelte Ausnahme: System.NullReferenceException: Der Objektverweis wurde nicht auf eine Objektinstanz festgelegt.
   bei Orleans.Serialization.FieldUtils.GetGetter(FieldInfo field) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\FieldUtils.cs:Zeile 12.
   bei OrleansGeneratedCode5C168FDA.OrleansCodeGenOrleans_Serialization_SerializationManagerSerializer..ctor(IFieldUtils fieldUtils) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Runtime\obj\Release\netstandard2.0\Orleans.Runtime.orleans.g.cs:Zeile 1733.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei Microsoft.Extensions.Internal.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   bei Orleans.Serialization.SerializationManager.InitializeSerializer(Type serializerType) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 242.
   bei Orleans.Serialization.SerializationManager.Register(Type type Type serializerType) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 445.
   bei Orleans.Serialization.SerializationManager.RegisterSerializers(SerializerFeature serializerFeature) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 204.
   bei Orleans.Serialization.SerializationManager.RegisterSerializers(IApplicationPartManager applicationPartManager) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 176.
   bei Orleans.Runtime.Silo..ctor(ILocalSiloDetails siloDetails IServiceProvider services) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Runtime\Silo\Silo.cs:Zeile 146.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   bei Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   bei Orleans.TestingHost.TestClusterHostFactory.CreateSiloHost(String hostName IEnumerable`1 configurationSources) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestClusterHostFactory.cs:Zeile 84.
   bei Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\InProcessSiloHandle.cs:Zeile 33.
   bei Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 482.
   bei Orleans.TestingHost.TestCluster.&lt;InitializeAsync&gt;d__56.MoveNext() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 433.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   bei Orleans.TestingHost.TestCluster.&lt;DeployAsync&gt;d__36.MoveNext() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 170.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   bei Orleans.TestingHost.TestCluster.Deploy() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 125.
   bei Benchmarks.Program.&lt;&gt;c.&lt;.cctor&gt;b__4_18() in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 78.
   bei Benchmarks.Program.RunBenchmark[T](String name Func`1 init Action`1 benchmarkAction Action`1 tearDown) in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 112.
   bei Benchmarks.Program.&lt;&gt;c.&lt;.cctor&gt;b__4_5() in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 82.
   bei Benchmarks.Program.Main(String[] args) in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 107.

</Description>
    <Title_Description>Nullpointer exception when running ping benchmark in release mode debug mode runns fine but if i run ping benchmark in release i get this:

Running Ping benchmark
----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------


Unbehandelte Ausnahme: System.NullReferenceException: Der Objektverweis wurde nicht auf eine Objektinstanz festgelegt.
   bei Orleans.Serialization.FieldUtils.GetGetter(FieldInfo field) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\FieldUtils.cs:Zeile 12.
   bei OrleansGeneratedCode5C168FDA.OrleansCodeGenOrleans_Serialization_SerializationManagerSerializer..ctor(IFieldUtils fieldUtils) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Runtime\obj\Release\netstandard2.0\Orleans.Runtime.orleans.g.cs:Zeile 1733.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei Microsoft.Extensions.Internal.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
   bei Orleans.Serialization.SerializationManager.InitializeSerializer(Type serializerType) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 242.
   bei Orleans.Serialization.SerializationManager.Register(Type type Type serializerType) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 445.
   bei Orleans.Serialization.SerializationManager.RegisterSerializers(SerializerFeature serializerFeature) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 204.
   bei Orleans.Serialization.SerializationManager.RegisterSerializers(IApplicationPartManager applicationPartManager) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Core\Serialization\SerializationManager.cs:Zeile 176.
   bei Orleans.Runtime.Silo..ctor(ILocalSiloDetails siloDetails IServiceProvider services) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.Runtime\Silo\Silo.cs:Zeile 146.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   bei Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   bei Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   bei Orleans.TestingHost.TestClusterHostFactory.CreateSiloHost(String hostName IEnumerable`1 configurationSources) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestClusterHostFactory.cs:Zeile 84.
   bei Orleans.TestingHost.InProcessSiloHandle.Create(String siloName IList`1 configurationSources) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\InProcessSiloHandle.cs:Zeile 33.
   bei Orleans.TestingHost.TestCluster.StartOrleansSilo(Int32 instanceNumber TestClusterOptions clusterOptions IReadOnlyList`1 configurationOverrides Boolean startSiloOnNewPort) in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 482.
   bei Orleans.TestingHost.TestCluster.&lt;InitializeAsync&gt;d__56.MoveNext() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 433.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   bei Orleans.TestingHost.TestCluster.&lt;DeployAsync&gt;d__36.MoveNext() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 170.
--- Ende der Stapelüberwachung vom vorhergehenden Ort an dem die Ausnahme ausgelöst wurde ---
   bei System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   bei System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   bei Orleans.TestingHost.TestCluster.Deploy() in C:\Users\Jan Eggers\Documents\orleans\src\Orleans.TestingHost\TestCluster.cs:Zeile 125.
   bei Benchmarks.Program.&lt;&gt;c.&lt;.cctor&gt;b__4_18() in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 78.
   bei Benchmarks.Program.RunBenchmark[T](String name Func`1 init Action`1 benchmarkAction Action`1 tearDown) in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 112.
   bei Benchmarks.Program.&lt;&gt;c.&lt;.cctor&gt;b__4_5() in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 82.
   bei Benchmarks.Program.Main(String[] args) in C:\Users\Jan Eggers\Documents\orleans\test\Benchmarks\Benchmarks\Program.cs:Zeile 107.

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4403</IssueLabelID>
    <Title>Unused Stopwatch instance in the Grain&lt;TGrainState&gt;.OnSetupState function </Title>
    <Description>There is unused Stopwatch instance in the Grain&lt;&gt;.OnSetupState function. It should be commented out until StorageStatisticsGroup is commented

```c#
private async Task OnSetupState(CancellationToken ct)
        {
            if (ct.IsCancellationRequested)
                return;
            this.storage = this.Runtime.GetStorage&lt;TGrainState&gt;(this);
            Stopwatch sw = Stopwatch.StartNew();
            try
            {
                await this.ReadStateAsync();
                sw.Stop();
                // TODO: find a way to reenable StorageStatisticsGroup here
                //StorageStatisticsGroup.OnStorageActivate(grainTypeName sw.Elapsed);
            }
            catch (Exception)
            {
                sw.Stop();
                // TODO: find a way to reenable StorageStatisticsGroup here
                //StorageStatisticsGroup.OnStorageActivateError(grainTypeName);
                throw;
            }
        }

```</Description>
    <Title_Description>Unused Stopwatch instance in the Grain&lt;TGrainState&gt;.OnSetupState function  There is unused Stopwatch instance in the Grain&lt;&gt;.OnSetupState function. It should be commented out until StorageStatisticsGroup is commented

```c#
private async Task OnSetupState(CancellationToken ct)
        {
            if (ct.IsCancellationRequested)
                return;
            this.storage = this.Runtime.GetStorage&lt;TGrainState&gt;(this);
            Stopwatch sw = Stopwatch.StartNew();
            try
            {
                await this.ReadStateAsync();
                sw.Stop();
                // TODO: find a way to reenable StorageStatisticsGroup here
                //StorageStatisticsGroup.OnStorageActivate(grainTypeName sw.Elapsed);
            }
            catch (Exception)
            {
                sw.Stop();
                // TODO: find a way to reenable StorageStatisticsGroup here
                //StorageStatisticsGroup.OnStorageActivateError(grainTypeName);
                throw;
            }
        }

```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4401</IssueLabelID>
    <Title>Getting a null reference error on ServiceId when I call GetReminder on a silo with no ServiceId</Title>
    <Description>Hey
I was using Orleans 2.0.0 Stable and have the following code in my grain
`
public async Task&lt;AsyncOperationResult&gt; SubmitOperation(OperationContext context Type asyncOperationType AsyncOperationInput operationInput)
{
            var grainId = this.GetPrimaryKeyString();

            var newOperationData = new AsyncOperationState
            {
                OperationType = asyncOperationType
                Input = operationInput
                Context = context
            };
			
            // Setup the lifeline reminder if it does not exist already
            IGrainReminder lifelineReminder = await this.GetReminder(OperationManagerGrain.ReminderName);
            if (lifelineReminder == null)
            {
                this.logger.LogInformation("[Grain {0}]: Setting up lifeline reminder." grainId);
                await this.RegisterOrUpdateReminder(OperationManagerGrain.ReminderName this.grainConfig.ReminderTickInitialDelay this.grainConfig.ReminderTickPeriod);
            }

            // Add the new operation to the persistent store
            this.logger.LogInformation("[Grain {0}]: Modifying the grain state to include the new operation to run: [id={1}; type={2}]" grainId newOperationData.Context.OperationId newOperationData.OperationType.Name);
            this.State.CurrentOperation = newOperationData;
            this.State.IdleReminderTicks = 0;
            await this.WriteStateAsync();

            // Launch the submitted operation
            this.logger.LogInformation("[Grain {0}]: launching the current operation." grainId);
            AsyncOperationResult submissionResult = await this.LaunchCurrentOperation();

            this.logger.LogInformation("[Grain {0}]: Returning ACK back to submitter." grainId);
            return submissionResult;
}
`
My silo initialization code is as follows:

`Program.silo = new SiloHostBuilder()
                .Configure(options =&gt; options.ClusterId = orleansConfig.ClusterId)
                .Configure&lt;ProcessExitHandlingOptions&gt;(o =&gt;
                {
                    o.FastKillOnProcessExit = true;
                })
                .UseAzureTableReminderService(options =&gt; options.ConnectionString = connectionString)
                .UseAzureStorageClustering(options =&gt;
                {
                    options.ConnectionString = connectionString;
                    options.MaxStorageBusyRetries = 3;
                })
                .AddAzureBlobGrainStorage("grainBlobStore" (AzureBlobStorageOptions options) =&gt;
                {
                    options.ConnectionString = connectionString;
                })
                .ConfigureGrainApplicationParts()
                .ConfigureEndpoints(siloPort: orleansConfig.SiloPort gatewayPort: orleansConfig.GatewayPort)
                .ConfigureServices((services) =&gt;
                {
                    // have some services here being initialized
                })
                .Build();`

If I were to queue two simultaneous job with the same grainId I am encountering the following error:
`warn: Orleans.Runtime.ReminderService.AzureBasedReminderTable[100846]
      Intermediate error reading row with grainId = GrainReference:*grn/2E596F41/00000000+67db82be-6884-48e0-aafe-9f7a9f37350e reminderName = LifelineReminder from table OrleansReminders.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Runtime.ReminderService.AzureBasedReminderTable.ConvertFromTableEntry(ReminderTableEntry tableEntry String eTag)
   at Orleans.Runtime.ReminderService.AzureBasedReminderTable.&lt;ReadRow&gt;d__14.MoveNext()
fail: Microsoft.MachineLearning.Common.AsyncOperationsFramework.AsyncOperationsManager[0]
      System.NullReferenceException: Object reference not set to an instance of an object.
         at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
         at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
         at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
      --- End of stack trace from previous location where exception was thrown ---
         at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
         at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
         at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult() `

I believe Orleans requires serviceid to be set but does not do a validation of this when I create my silo which leads to this issue down the line. We should add in validation that causes the silo init to break if serviceId is not passed in.</Description>
    <Title_Description>Getting a null reference error on ServiceId when I call GetReminder on a silo with no ServiceId Hey
I was using Orleans 2.0.0 Stable and have the following code in my grain
`
public async Task&lt;AsyncOperationResult&gt; SubmitOperation(OperationContext context Type asyncOperationType AsyncOperationInput operationInput)
{
            var grainId = this.GetPrimaryKeyString();

            var newOperationData = new AsyncOperationState
            {
                OperationType = asyncOperationType
                Input = operationInput
                Context = context
            };
			
            // Setup the lifeline reminder if it does not exist already
            IGrainReminder lifelineReminder = await this.GetReminder(OperationManagerGrain.ReminderName);
            if (lifelineReminder == null)
            {
                this.logger.LogInformation("[Grain {0}]: Setting up lifeline reminder." grainId);
                await this.RegisterOrUpdateReminder(OperationManagerGrain.ReminderName this.grainConfig.ReminderTickInitialDelay this.grainConfig.ReminderTickPeriod);
            }

            // Add the new operation to the persistent store
            this.logger.LogInformation("[Grain {0}]: Modifying the grain state to include the new operation to run: [id={1}; type={2}]" grainId newOperationData.Context.OperationId newOperationData.OperationType.Name);
            this.State.CurrentOperation = newOperationData;
            this.State.IdleReminderTicks = 0;
            await this.WriteStateAsync();

            // Launch the submitted operation
            this.logger.LogInformation("[Grain {0}]: launching the current operation." grainId);
            AsyncOperationResult submissionResult = await this.LaunchCurrentOperation();

            this.logger.LogInformation("[Grain {0}]: Returning ACK back to submitter." grainId);
            return submissionResult;
}
`
My silo initialization code is as follows:

`Program.silo = new SiloHostBuilder()
                .Configure(options =&gt; options.ClusterId = orleansConfig.ClusterId)
                .Configure&lt;ProcessExitHandlingOptions&gt;(o =&gt;
                {
                    o.FastKillOnProcessExit = true;
                })
                .UseAzureTableReminderService(options =&gt; options.ConnectionString = connectionString)
                .UseAzureStorageClustering(options =&gt;
                {
                    options.ConnectionString = connectionString;
                    options.MaxStorageBusyRetries = 3;
                })
                .AddAzureBlobGrainStorage("grainBlobStore" (AzureBlobStorageOptions options) =&gt;
                {
                    options.ConnectionString = connectionString;
                })
                .ConfigureGrainApplicationParts()
                .ConfigureEndpoints(siloPort: orleansConfig.SiloPort gatewayPort: orleansConfig.GatewayPort)
                .ConfigureServices((services) =&gt;
                {
                    // have some services here being initialized
                })
                .Build();`

If I were to queue two simultaneous job with the same grainId I am encountering the following error:
`warn: Orleans.Runtime.ReminderService.AzureBasedReminderTable[100846]
      Intermediate error reading row with grainId = GrainReference:*grn/2E596F41/00000000+67db82be-6884-48e0-aafe-9f7a9f37350e reminderName = LifelineReminder from table OrleansReminders.
System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.Runtime.ReminderService.AzureBasedReminderTable.ConvertFromTableEntry(ReminderTableEntry tableEntry String eTag)
   at Orleans.Runtime.ReminderService.AzureBasedReminderTable.&lt;ReadRow&gt;d__14.MoveNext()
fail: Microsoft.MachineLearning.Common.AsyncOperationsFramework.AsyncOperationsManager[0]
      System.NullReferenceException: Object reference not set to an instance of an object.
         at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
         at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
         at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
      --- End of stack trace from previous location where exception was thrown ---
         at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
         at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
         at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult() `

I believe Orleans requires serviceid to be set but does not do a validation of this when I create my silo which leads to this issue down the line. We should add in validation that causes the silo init to break if serviceId is not passed in.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4400</IssueLabelID>
    <Title>Documention of the logic behind of clusterclient.GetGrain&lt;ISomeGrain&gt;()</Title>
    <Description>I think we need a original rational explanation of  what happening when our cluster client send a request(
`GetGrain&lt;ISomeGrain&gt;()`
) to the silo.  i want to know what happed of the entire request.

These original rational knowledge should be documented.

when client started it get active gateways from `MembershipTable`  how client decide which gateway to process the request? how gateway forward the request to the correct silo?

when entire request process ends does orleans cache the `grain -&gt; bucket(grain list?) -&gt; gateway -&gt;  connection -&gt; silo`?

According to our test results when the client sends the message it seems that only 3 silos ( _i have 5 total_) opened the socket connection (in order to be effective I used **client per request**) and then close the connection(why 3?)</Description>
    <Title_Description>Documention of the logic behind of clusterclient.GetGrain&lt;ISomeGrain&gt;() I think we need a original rational explanation of  what happening when our cluster client send a request(
`GetGrain&lt;ISomeGrain&gt;()`
) to the silo.  i want to know what happed of the entire request.

These original rational knowledge should be documented.

when client started it get active gateways from `MembershipTable`  how client decide which gateway to process the request? how gateway forward the request to the correct silo?

when entire request process ends does orleans cache the `grain -&gt; bucket(grain list?) -&gt; gateway -&gt;  connection -&gt; silo`?

According to our test results when the client sends the message it seems that only 3 silos ( _i have 5 total_) opened the socket connection (in order to be effective I used **client per request**) and then close the connection(why 3?)</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>4/04/2018 7:58:29 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4399</IssueLabelID>
    <Title>Remove per-call timer allocation</Title>
    <Description>* Split `CallbackData` into `CallbackData` &amp; `SharedCallbackData` to reduce the weight of each `CallbackData` and the cost associated with creating it.
* Avoid starting a .NET Timer for every grain call instead use a single timer in the runtime client and expire calls in succession

The timer period is set to 1 second in this PR - I figure that is a fine interval but we could reduce it as we see fit or make it configurable.

These callback timers were causing significant contention (due to how .NET's Timer class is implemented) and allocating ~400 bytes per call

cc @dVakulen - we talked about this back in January &amp; Dmytro has an implementation of a timer wheel which may be suitable to use for Grain timers (which this PR doesn't address)</Description>
    <Title_Description>Remove per-call timer allocation * Split `CallbackData` into `CallbackData` &amp; `SharedCallbackData` to reduce the weight of each `CallbackData` and the cost associated with creating it.
* Avoid starting a .NET Timer for every grain call instead use a single timer in the runtime client and expire calls in succession

The timer period is set to 1 second in this PR - I figure that is a fine interval but we could reduce it as we see fit or make it configurable.

These callback timers were causing significant contention (due to how .NET's Timer class is implemented) and allocating ~400 bytes per call

cc @dVakulen - we talked about this back in January &amp; Dmytro has an implementation of a timer wheel which may be suitable to use for Grain timers (which this PR doesn't address)</Title_Description>
    <Label>performance</Label>
    <Assignee>dVakulen</Assignee>
    <CreatedAt>4/04/2018 6:45:10 AM +00:00</CreatedAt>
    <ClosedAt>22/06/2018 5:35:04 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4398</IssueLabelID>
    <Title>Use linked list for activation message queue</Title>
    <Description>* Instead of a `List&lt;T&gt;` use a `LinkedList&lt;T&gt;` for an activation's message queue.
* Responses are added to the front of the queue Requests are added to the back of the queue.</Description>
    <Title_Description>Use linked list for activation message queue * Instead of a `List&lt;T&gt;` use a `LinkedList&lt;T&gt;` for an activation's message queue.
* Responses are added to the front of the queue Requests are added to the back of the queue.</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>4/04/2018 4:57:39 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 10:39:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4397</IssueLabelID>
    <Title>Reduce allocations in IncomingMessageAgent</Title>
    <Description>Before: 15.84 KB/call
After: 15.75 KB/call</Description>
    <Title_Description>Reduce allocations in IncomingMessageAgent Before: 15.84 KB/call
After: 15.75 KB/call</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>4/04/2018 4:30:05 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 10:39:29 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4396</IssueLabelID>
    <Title>Avoid costly Message.GetTargetHistory() on gateway reroute</Title>
    <Description>Results in 1.5Kb less allocs per call and ~17us faster RTT

Before: 

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 375.3 us | 166.1 us | 9.387 us | 3.4180 |  15.83 KB |

After:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 353.9 us | 6.983 us | 13.78 us | 3.4180 |  14.28 KB |
</Description>
    <Title_Description>Avoid costly Message.GetTargetHistory() on gateway reroute Results in 1.5Kb less allocs per call and ~17us faster RTT

Before: 

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 375.3 us | 166.1 us | 9.387 us | 3.4180 |  15.83 KB |

After:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 353.9 us | 6.983 us | 13.78 us | 3.4180 |  14.28 KB |
</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>4/04/2018 4:19:36 AM +00:00</CreatedAt>
    <ClosedAt>16/04/2018 10:39:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4395</IssueLabelID>
    <Title>Reduce allocs in Interner</Title>
    <Description>This is a minor improvement one in a string of several to come. This change reduces the allocs for each call by approximately 300 bytes and reduces RTT (in proc) by ~21us on my machine.

Allocations are like paper cuts: too many and you bleed out.

For this and the other allocation related PRs the targets are found by profiling looking at hot spots and picking the low-hanging fruit.

Before:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 375.3 us | 166.1 us | 9.387 us | 3.4180 |  15.83 KB |

After "Reduce allocs in Interner" commit:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 360.5 us | 200.2 us | 11.31 us | 3.4180 |  15.66 KB |

After "Intern ActivationAddress" commit:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 354.4 us | 119.1 us | 6.731 us | 3.4180 |  15.54 KB |
</Description>
    <Title_Description>Reduce allocs in Interner This is a minor improvement one in a string of several to come. This change reduces the allocs for each call by approximately 300 bytes and reduces RTT (in proc) by ~21us on my machine.

Allocations are like paper cuts: too many and you bleed out.

For this and the other allocation related PRs the targets are found by profiling looking at hot spots and picking the low-hanging fruit.

Before:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 375.3 us | 166.1 us | 9.387 us | 3.4180 |  15.83 KB |

After "Reduce allocs in Interner" commit:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 360.5 us | 200.2 us | 11.31 us | 3.4180 |  15.66 KB |

After "Intern ActivationAddress" commit:

 Method |     Mean |    Error |   StdDev |  Gen 0 | Allocated |
------- |---------:|---------:|---------:|-------:|----------:|
   Ping | 354.4 us | 119.1 us | 6.731 us | 3.4180 |  15.54 KB |
</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>4/04/2018 3:44:22 AM +00:00</CreatedAt>
    <ClosedAt>5/04/2018 9:48:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4393</IssueLabelID>
    <Title>GrainTypeResolver is null</Title>
    <Description>Hello! After upgrading to Orleans 2.0 I've been having this problem almost random doesn't seems to be related to something in specific.
```
warn: Orleans.OutsideRuntimeClient[104202]
      Refresh the GrainTypeResolver failed. WIll be retried after
```
but even after the Orleans client connects I have a null reference for the GrainTypeResolver
![image](https://user-images.githubusercontent.com/8826013/38282047-9132e882-3773-11e8-8e40-84484ffc0473.png)

then when trying to get a grain it throws a NullReferenceException and the stack trace looks like this
```
at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)  
at Orleans.GrainFactory.GetGrain[TGrainInterface](String primaryKey String grainClassNamePrefix)  
at TuRuta.Web.Services.RoutesService..ctor(IClusterClient clusterClient) in C:\\Users\\migue\\source\\repos\\TuRuta\\src\\TuRuta\\TuRuta.Web\\Services\\RoutesService.cs:line 23
```

NOTE: I'm just supposing that all this three things are related I'm not sure if the warning logged has to do with everything else.

UPDATE: I'm using Azure TableStorage clusterting and seems that deleting the table of old registries helps to avoid the exception.</Description>
    <Title_Description>GrainTypeResolver is null Hello! After upgrading to Orleans 2.0 I've been having this problem almost random doesn't seems to be related to something in specific.
```
warn: Orleans.OutsideRuntimeClient[104202]
      Refresh the GrainTypeResolver failed. WIll be retried after
```
but even after the Orleans client connects I have a null reference for the GrainTypeResolver
![image](https://user-images.githubusercontent.com/8826013/38282047-9132e882-3773-11e8-8e40-84484ffc0473.png)

then when trying to get a grain it throws a NullReferenceException and the stack trace looks like this
```
at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)  
at Orleans.GrainFactory.GetGrain[TGrainInterface](String primaryKey String grainClassNamePrefix)  
at TuRuta.Web.Services.RoutesService..ctor(IClusterClient clusterClient) in C:\\Users\\migue\\source\\repos\\TuRuta\\src\\TuRuta\\TuRuta.Web\\Services\\RoutesService.cs:line 23
```

NOTE: I'm just supposing that all this three things are related I'm not sure if the warning logged has to do with everything else.

UPDATE: I'm using Azure TableStorage clusterting and seems that deleting the table of old registries helps to avoid the exception.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4391</IssueLabelID>
    <Title>Application Insights Telemetry failing to initialize</Title>
    <Description>I'm trying to add the Application Insights Telemetry to our 2.0 app and im getting the following exception 
```
System.InvalidOperationException: Unable to resolve service for type 'System.String' while attempting to activate 'Orleans.TelemetryConsumers.AI.AITelemetryConsumer'.
```
Looking at the code it looks like the only constructor on the `AITelemetryConsumer` takes a string causing the exception. Simply adding a DI compatible constructor should fix the issue. I'll submit a PR if this makes sense.</Description>
    <Title_Description>Application Insights Telemetry failing to initialize I'm trying to add the Application Insights Telemetry to our 2.0 app and im getting the following exception 
```
System.InvalidOperationException: Unable to resolve service for type 'System.String' while attempting to activate 'Orleans.TelemetryConsumers.AI.AITelemetryConsumer'.
```
Looking at the code it looks like the only constructor on the `AITelemetryConsumer` takes a string causing the exception. Simply adding a DI compatible constructor should fix the issue. I'll submit a PR if this makes sense.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4389</IssueLabelID>
    <Title>No implementation of IHostEnvironmentStatistics was found</Title>
    <Description>Warning	100708	Orleans.Runtime.NoOpHostEnvironmentStatistics]	No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet.

What should I write in StartSilo</Description>
    <Title_Description>No implementation of IHostEnvironmentStatistics was found Warning	100708	Orleans.Runtime.NoOpHostEnvironmentStatistics]	No implementation of IHostEnvironmentStatistics was found. Load shedding will not work yet.

What should I write in StartSilo</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4386</IssueLabelID>
    <Title>Unsubscribe from SMS stream fails with timeout</Title>
    <Description>I'm facing an issue when calling `UnsubscribeAsync` on SMS provider subscription instance in `OnDeactivateAsync` grain method. The internal call in PubSub grain timeouts (in release mode) or hangs when debugger is attached. 

```
[2018-03-31 16:17:39.623 GMT    22    ERROR      100516    Catalog    10.0.75.1:0]    !!!!!!!!!! Error calling grain's OnDeactivateAsync() method - Grain type = Conreign.Server.Gameplay.LobbyGrain Activation = [Activation: S127.0.0.1:22222:260208985*grn/1A5E3811/00000000+natalie4@ff4a47bf #GrainType=Conreign.Server.Gameplay.LobbyGrain Placement=RandomPlacement State=Deactivating]    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:22222:260208985*grn/1A5E3811/00000000+natalie4@ff4a47bf-&gt;S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #565: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterConsumer(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4:@29bfe78b&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.&lt;UnsubscribeAsync&gt;d__16.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Conreign.Server.Gameplay.LobbyGrain.&lt;OnDeactivateAsync&gt;d__15.MoveNext() in D:\Personal\Conreign\src\Conreign.Server\Gameplay\LobbyGrain.cs:line 93
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;CallGrainDeactivateAndCleanupStreams&gt;d__88.MoveNext()
[2018-03-31 16:17:39.685 GMT    23    ERROR      103413    PubSubRendezvousGrain-S127.0.0.1:22222:260208985-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+DefaultStream_conreign/rooms/natalie4-0xF69D9439    ]    !!!!!!!!!! Failed to unregister a stream consumer.  Stream: conreign/rooms/natalie4-00000000-0000-0000-0000-000000000000-DefaultStream SubscriptionId 435d4848-2050-4f3a-bfd7-54e6f460a839    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b-&gt;S127.0.0.1:22222:260208985*grn/E75B5B5B/00000000+natalie4@71f007aa #574: global::Orleans.Streams.IStreamProducerExtension:RemoveSubscriber(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/E75B5B5B/00000000+natalie4:@71f007aa&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;ExecuteProducerTask&gt;d__28.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;NotifyProducersOfRemovedSubscription&gt;d__26.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;UnregisterConsumer&gt;d__17.MoveNext()
[2018-03-31 16:17:39.722 GMT    22    INFO       100539    Catalog    10.0.75.1:0]    Done FinishDestroyActivations #0 - Destroyed 1 Activations.    
[2018-03-31 16:17:39.737 GMT    23    INFO       100540    Catalog    10.0.75.1:0]    DeactivateActivationOnIdle: [Activation: S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.    
[2018-03-31 16:17:39.728 GMT    21    WARNING    103402    SimpleMessageStreamProducer`1    10.0.75.1:0]    Ignoring unhandled exception during PubSub.UnregisterProducer    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:22222:260208985*grn/E75B5B5B/00000000+natalie4@71f007aa-&gt;S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #569: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4:@29bfe78b&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

Mentioned unsubscribe call can be seen here: https://github.com/smolyakoff/conreign/blob/feature/bots/src/Conreign.Server/Gameplay/LobbyGrain.cs#L93

I use a common helper for stream subscription which does conditional logic based on active subscription handles: https://github.com/smolyakoff/conreign/blob/feature/bots/src/Conreign.Server/Communication/StreamExtensions.cs#L14</Description>
    <Title_Description>Unsubscribe from SMS stream fails with timeout I'm facing an issue when calling `UnsubscribeAsync` on SMS provider subscription instance in `OnDeactivateAsync` grain method. The internal call in PubSub grain timeouts (in release mode) or hangs when debugger is attached. 

```
[2018-03-31 16:17:39.623 GMT    22    ERROR      100516    Catalog    10.0.75.1:0]    !!!!!!!!!! Error calling grain's OnDeactivateAsync() method - Grain type = Conreign.Server.Gameplay.LobbyGrain Activation = [Activation: S127.0.0.1:22222:260208985*grn/1A5E3811/00000000+natalie4@ff4a47bf #GrainType=Conreign.Server.Gameplay.LobbyGrain Placement=RandomPlacement State=Deactivating]    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:22222:260208985*grn/1A5E3811/00000000+natalie4@ff4a47bf-&gt;S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #565: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterConsumer(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4:@29bfe78b&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.StreamConsumer`1.&lt;UnsubscribeAsync&gt;d__16.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult()
   at Conreign.Server.Gameplay.LobbyGrain.&lt;OnDeactivateAsync&gt;d__15.MoveNext() in D:\Personal\Conreign\src\Conreign.Server\Gameplay\LobbyGrain.cs:line 93
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;CallGrainDeactivateAndCleanupStreams&gt;d__88.MoveNext()
[2018-03-31 16:17:39.685 GMT    23    ERROR      103413    PubSubRendezvousGrain-S127.0.0.1:22222:260208985-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+DefaultStream_conreign/rooms/natalie4-0xF69D9439    ]    !!!!!!!!!! Failed to unregister a stream consumer.  Stream: conreign/rooms/natalie4-00000000-0000-0000-0000-000000000000-DefaultStream SubscriptionId 435d4848-2050-4f3a-bfd7-54e6f460a839    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: IsAlwaysInterleave Request S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b-&gt;S127.0.0.1:22222:260208985*grn/E75B5B5B/00000000+natalie4@71f007aa #574: global::Orleans.Streams.IStreamProducerExtension:RemoveSubscriber(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/E75B5B5B/00000000+natalie4:@71f007aa&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;ExecuteProducerTask&gt;d__28.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;NotifyProducersOfRemovedSubscription&gt;d__26.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Streams.PubSubRendezvousGrain.&lt;UnregisterConsumer&gt;d__17.MoveNext()
[2018-03-31 16:17:39.722 GMT    22    INFO       100539    Catalog    10.0.75.1:0]    Done FinishDestroyActivations #0 - Destroyed 1 Activations.    
[2018-03-31 16:17:39.737 GMT    23    INFO       100540    Catalog    10.0.75.1:0]    DeactivateActivationOnIdle: [Activation: S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #GrainType=Orleans.Streams.PubSubRendezvousGrain Placement=RandomPlacement State=Deactivating] later when become idle.    
[2018-03-31 16:17:39.728 GMT    21    WARNING    103402    SimpleMessageStreamProducer`1    10.0.75.1:0]    Ignoring unhandled exception during PubSub.UnregisterProducer    
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:22222:260208985*grn/E75B5B5B/00000000+natalie4@71f007aa-&gt;S127.0.0.1:22222:260208985*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4@29bfe78b #569: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:22222:260208985:*grn/716E8E94/00000000+DefaultStream_conreign/rooms/natalie4:@29bfe78b&gt;.
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

Mentioned unsubscribe call can be seen here: https://github.com/smolyakoff/conreign/blob/feature/bots/src/Conreign.Server/Gameplay/LobbyGrain.cs#L93

I use a common helper for stream subscription which does conditional logic based on active subscription handles: https://github.com/smolyakoff/conreign/blob/feature/bots/src/Conreign.Server/Communication/StreamExtensions.cs#L14</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>2/04/2018 6:35:57 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4385</IssueLabelID>
    <Title>The type or namespace name 'GenericMethodInvoker' does not exist in the namespace 'Orleans.CodeGeneration' </Title>
    <Description>orleans2.0
ex:  `Task&lt;TResult&gt; Invoke&lt;TResult&gt;(object[] args);`
Error	CS0234	The type or namespace name 'GenericMethodInvoker' does not exist in the namespace 'Orleans.CodeGeneration' (are you missing an assembly reference?)

Do not support generics?

1.5.3 is ok</Description>
    <Title_Description>The type or namespace name 'GenericMethodInvoker' does not exist in the namespace 'Orleans.CodeGeneration'  orleans2.0
ex:  `Task&lt;TResult&gt; Invoke&lt;TResult&gt;(object[] args);`
Error	CS0234	The type or namespace name 'GenericMethodInvoker' does not exist in the namespace 'Orleans.CodeGeneration' (are you missing an assembly reference?)

Do not support generics?

1.5.3 is ok</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4384</IssueLabelID>
    <Title> Can I Use localhost clustering for multiple local silo?</Title>
    <Description>I have 2 silos if using AdoNet membership all works fine.
when switch to  localhost clustering my client throw some errors
`Cannot find an implementation class for grain interface`

 **Can I Use localhost clustering for a multiple local silo for development?** 

host config
```csharp
var endPoints = _options.Host.GetEndPoint();
_siloHostBuilder
    .UseLocalhostClustering(endPoints.siloPort endPoints.gatewayPort null _options.DeploymentId)
    .Configure&lt;ClusterOptions&gt;(opt =&gt;
        {
            opt.ClusterId = _options.DeploymentId;
            if (!string.IsNullOrWhiteSpace(_options.ServiceId))
                opt.ServiceId = _options.ServiceId;
        });
```

here is client code
```csharp
private async Task&lt;string&gt; DoClientWork()
        {
            // example of calling grains from the initialized client
            var userStateService = _client.GetGrain&lt;IUserStateService&lt;UserState int&gt;&gt;("test1");
            var state = await userStateService.GetUserState("admin");

            var cacheSrv = _client.GetGrain&lt;ICacheService&gt;("test2");
            var cacheVal = await cacheSrv.Get("cachekey");

            return $"{state} {cacheVal}";
        }
```</Description>
    <Title_Description> Can I Use localhost clustering for multiple local silo? I have 2 silos if using AdoNet membership all works fine.
when switch to  localhost clustering my client throw some errors
`Cannot find an implementation class for grain interface`

 **Can I Use localhost clustering for a multiple local silo for development?** 

host config
```csharp
var endPoints = _options.Host.GetEndPoint();
_siloHostBuilder
    .UseLocalhostClustering(endPoints.siloPort endPoints.gatewayPort null _options.DeploymentId)
    .Configure&lt;ClusterOptions&gt;(opt =&gt;
        {
            opt.ClusterId = _options.DeploymentId;
            if (!string.IsNullOrWhiteSpace(_options.ServiceId))
                opt.ServiceId = _options.ServiceId;
        });
```

here is client code
```csharp
private async Task&lt;string&gt; DoClientWork()
        {
            // example of calling grains from the initialized client
            var userStateService = _client.GetGrain&lt;IUserStateService&lt;UserState int&gt;&gt;("test1");
            var state = await userStateService.GetUserState("admin");

            var cacheSrv = _client.GetGrain&lt;ICacheService&gt;("test2");
            var cacheVal = await cacheSrv.Get("cachekey");

            return $"{state} {cacheVal}";
        }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4381</IssueLabelID>
    <Title>Looking source of TaskCanceledException [1.5.2]</Title>
    <Description>We are seeing this `TaskCanceledException` sporadically.   they seem to always be unobserved.
this is running a 3silo cluster on 1.5.2

`{
  "_index": "trace-2018-03-30-22"
  "_type": "doc"
  "_id": "AWJ5EmT5AD6OAjO5VISl"
  "_score": 1
  "_source": {
    "Severity": "Error"
    "LoggerType": "Runtime"
    "Caller": "UnobservedExceptionHandler"
    "Message": "UnobservedExceptionsHandlerClass Caught an UnobservedTaskException event sent by [Id=2092254 Status=Faulted]. Exception = \r\nExc level 0: System.AggregateException: A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result the unobserved exception was rethrown by the finalizer thread.\r\nExc level 1: System.Threading.Tasks.TaskCanceledException: The request was aborted"
    "IPEndPoint": "172.18.124.51:11111"
    "Exception": null
    "EventCode": 100005
    "UtcDateTime": "2018-03-30T22:41:11.1194856Z"
    "MachineName": "NCI-R5EAS01"
  }
  "fields": {
    "AggregateSource": [
      "UnobservedExceptionHandler"
    ]
    "AggregateLogLevel": [
      "Error"
    ]
    "UtcDateTime": [
      1522449671119
    ]
  }
}`

we will try to attach more details to like as we find them


The initial thought was that a grain call was made (maybe from client maybe from another grain) that causes many hundreds of new activation to occur and that time was a lengthy process.  However we haven't been able to deduce the exception.</Description>
    <Title_Description>Looking source of TaskCanceledException [1.5.2] We are seeing this `TaskCanceledException` sporadically.   they seem to always be unobserved.
this is running a 3silo cluster on 1.5.2

`{
  "_index": "trace-2018-03-30-22"
  "_type": "doc"
  "_id": "AWJ5EmT5AD6OAjO5VISl"
  "_score": 1
  "_source": {
    "Severity": "Error"
    "LoggerType": "Runtime"
    "Caller": "UnobservedExceptionHandler"
    "Message": "UnobservedExceptionsHandlerClass Caught an UnobservedTaskException event sent by [Id=2092254 Status=Faulted]. Exception = \r\nExc level 0: System.AggregateException: A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result the unobserved exception was rethrown by the finalizer thread.\r\nExc level 1: System.Threading.Tasks.TaskCanceledException: The request was aborted"
    "IPEndPoint": "172.18.124.51:11111"
    "Exception": null
    "EventCode": 100005
    "UtcDateTime": "2018-03-30T22:41:11.1194856Z"
    "MachineName": "NCI-R5EAS01"
  }
  "fields": {
    "AggregateSource": [
      "UnobservedExceptionHandler"
    ]
    "AggregateLogLevel": [
      "Error"
    ]
    "UtcDateTime": [
      1522449671119
    ]
  }
}`

we will try to attach more details to like as we find them


The initial thought was that a grain call was made (maybe from client maybe from another grain) that causes many hundreds of new activation to occur and that time was a lengthy process.  However we haven't been able to deduce the exception.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4378</IssueLabelID>
    <Title>what is the equivalent class of "ObserverSubscriptionManager" in Orleans 2.0</Title>
    <Description>what is equivalent class of "ObserverSubscriptionManager" in Orleans 2.0. If this is obsolete how do I implement client observer in 2.0? </Description>
    <Title_Description>what is the equivalent class of "ObserverSubscriptionManager" in Orleans 2.0 what is equivalent class of "ObserverSubscriptionManager" in Orleans 2.0. If this is obsolete how do I implement client observer in 2.0? </Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4374</IssueLabelID>
    <Title>Update doc page on grain garbage collection</Title>
    <Description>
    </Description>
    <Title_Description>Update doc page on grain garbage collection </Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>30/03/2018 6:15:38 PM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 10:15:20 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4373</IssueLabelID>
    <Title>Update transactions page</Title>
    <Description>
    </Description>
    <Title_Description>Update transactions page </Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>30/03/2018 6:02:18 PM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 11:10:56 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4372</IssueLabelID>
    <Title>Update reminders doc page</Title>
    <Description>
    </Description>
    <Title_Description>Update reminders doc page </Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>30/03/2018 5:50:04 PM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 10:36:42 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4371</IssueLabelID>
    <Title>Add a warning banner on all 1.5 doc pages</Title>
    <Description>I could have done it with paying with the template but since 1.5 and 2.0 share the same it was easier that way.</Description>
    <Title_Description>Add a warning banner on all 1.5 doc pages I could have done it with paying with the template but since 1.5 and 2.0 share the same it was easier that way.</Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>30/03/2018 5:26:52 PM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 11:09:18 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4370</IssueLabelID>
    <Title>I have some questions about Orleans Best Practices</Title>
    <Description>I've already read [this guide](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans20Best20Practices.pdf) but still have some questions. Please see the code bellow:

```csharp
[StorageProvider(ProviderName = "AzureTable")]
public class OfficeOrderTransaction : Grain&lt;OfficeOrderState&gt; IOfficeOrderTransaction
{
    private bool _inProgress = false;
    private ObserverSubscriptionManager&lt;IOfficeOrderObserver&gt; _subsManager;

    public override async Task OnActivateAsync()
    {
        Console.WriteLine($"Grain {nameof(ProductsGrain)} activated.");
        
        // We created the utility at activation time.
        _subsManager = new ObserverSubscriptionManager&lt;IOfficeOrderObserver&gt;();
        await base.OnActivateAsync();
    }

    public Task Continue()
    {
        // ReSharper disable once InvertIf
        if (State.State != TransactionState.Completed &amp;&amp; !_inProgress)
        {
            ExecuteTransaction();
        }

        return Task.CompletedTask;
    }

    public async Task&lt;bool&gt; Start(string subscriptionId)
    {
        if (State.State == TransactionState.Completed)
        {
            throw new InvalidOperationException();
        }

        State.SubscriptionId = subscriptionId;
        await WriteStateAsync();

        var client = GrainFactory.GetGrain&lt;IInProgressTransactionsQueue&gt;(nameof(IInProgressTransactionsQueue));
        await client.Put(this.GetPrimaryKey());

        ExecuteTransaction();

        return true;
    }

    // Clients call this to subscribe.
    public Task Subscribe(IOfficeOrderObserver observer)
    {
        _subsManager.Subscribe(observer);
        return Task.CompletedTask;
    }

    //Also clients use this to unsubscribe themselves to no longer receive the messages.
    public Task UnSubscribe(IOfficeOrderObserver observer)
    {
        _subsManager.Unsubscribe(observer);
        return Task.CompletedTask;
    }

    public Task&lt;TransactionState&gt; GetState()
    {
        return Task.FromResult(State.State);
    }

    private async void ExecuteTransaction()
    {
        _inProgress = true;

        // Step 1
        if (string.IsNullOrEmpty(State.ActionState) 
            || State.ActionState == nameof(Action1))
        {
            State.ActionState = nameof(Action1);
            await WriteStateAsync();

            await Action1();

            State.ActionState = nameof(Action2);
            await WriteStateAsync();

            ExecuteTransaction();
        }

        // Step 2
        else if (State.ActionState == nameof(Action2))
        {
            await Action2();
        }

        var grain = GrainFactory.GetGrain&lt;IProductGrain&gt;(long.Parse(State.SubscriptionId));
        await grain.Save("New product" "Sucessfuly created!");

        State.State = TransactionState.Completed;
        await WriteStateAsync();

        var streamProvider = GetStreamProvider("AzureQueueProvider");
        //Get the reference to a stream
        var stream = streamProvider.GetStream&lt;string&gt;(Guid.Empty "Test");
        await stream.OnNextAsync(State.SubscriptionId);

        _subsManager.Notify(s =&gt; s.ReceiveMessage(State.SubscriptionId));
    }

    private async Task Action1()
    {
        var client = GrainFactory.GetGrain&lt;IClient&gt;((default(int)));
        await client.IsBalanceEnought();
    }

    private async Task Action2()
    {
        var client = GrainFactory.GetGrain&lt;IPayment&gt;((default(int)));
        await client.Pay();
    }
}
```

I'm trying to organize long running transactional process (in the future maybe with compensating actions aka [saga/state machine/call it what you want] it doesn't matter).

1. I need to do some piece of work in the Start method.
2. After run some method (ExecuteTransaction) without waiting and immediately return some result (in this example value which will notify that process has been successfully started).

What is the right way to do it? Use async void method or one more additional grain? Is async void bad practice here?

Also sometimes I'm getting Orleans.Storage.TableStorageUpdateConditionNotSatisfiedException in the 
ExecuteTransaction() method. I put two breakpoints in this method:

1. At the beginning of method.
2. After block of // Step 2.

The second breakpoint hits two times without stack trace when first only once. How it is possible magic?
</Description>
    <Title_Description>I have some questions about Orleans Best Practices I've already read [this guide](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans20Best20Practices.pdf) but still have some questions. Please see the code bellow:

```csharp
[StorageProvider(ProviderName = "AzureTable")]
public class OfficeOrderTransaction : Grain&lt;OfficeOrderState&gt; IOfficeOrderTransaction
{
    private bool _inProgress = false;
    private ObserverSubscriptionManager&lt;IOfficeOrderObserver&gt; _subsManager;

    public override async Task OnActivateAsync()
    {
        Console.WriteLine($"Grain {nameof(ProductsGrain)} activated.");
        
        // We created the utility at activation time.
        _subsManager = new ObserverSubscriptionManager&lt;IOfficeOrderObserver&gt;();
        await base.OnActivateAsync();
    }

    public Task Continue()
    {
        // ReSharper disable once InvertIf
        if (State.State != TransactionState.Completed &amp;&amp; !_inProgress)
        {
            ExecuteTransaction();
        }

        return Task.CompletedTask;
    }

    public async Task&lt;bool&gt; Start(string subscriptionId)
    {
        if (State.State == TransactionState.Completed)
        {
            throw new InvalidOperationException();
        }

        State.SubscriptionId = subscriptionId;
        await WriteStateAsync();

        var client = GrainFactory.GetGrain&lt;IInProgressTransactionsQueue&gt;(nameof(IInProgressTransactionsQueue));
        await client.Put(this.GetPrimaryKey());

        ExecuteTransaction();

        return true;
    }

    // Clients call this to subscribe.
    public Task Subscribe(IOfficeOrderObserver observer)
    {
        _subsManager.Subscribe(observer);
        return Task.CompletedTask;
    }

    //Also clients use this to unsubscribe themselves to no longer receive the messages.
    public Task UnSubscribe(IOfficeOrderObserver observer)
    {
        _subsManager.Unsubscribe(observer);
        return Task.CompletedTask;
    }

    public Task&lt;TransactionState&gt; GetState()
    {
        return Task.FromResult(State.State);
    }

    private async void ExecuteTransaction()
    {
        _inProgress = true;

        // Step 1
        if (string.IsNullOrEmpty(State.ActionState) 
            || State.ActionState == nameof(Action1))
        {
            State.ActionState = nameof(Action1);
            await WriteStateAsync();

            await Action1();

            State.ActionState = nameof(Action2);
            await WriteStateAsync();

            ExecuteTransaction();
        }

        // Step 2
        else if (State.ActionState == nameof(Action2))
        {
            await Action2();
        }

        var grain = GrainFactory.GetGrain&lt;IProductGrain&gt;(long.Parse(State.SubscriptionId));
        await grain.Save("New product" "Sucessfuly created!");

        State.State = TransactionState.Completed;
        await WriteStateAsync();

        var streamProvider = GetStreamProvider("AzureQueueProvider");
        //Get the reference to a stream
        var stream = streamProvider.GetStream&lt;string&gt;(Guid.Empty "Test");
        await stream.OnNextAsync(State.SubscriptionId);

        _subsManager.Notify(s =&gt; s.ReceiveMessage(State.SubscriptionId));
    }

    private async Task Action1()
    {
        var client = GrainFactory.GetGrain&lt;IClient&gt;((default(int)));
        await client.IsBalanceEnought();
    }

    private async Task Action2()
    {
        var client = GrainFactory.GetGrain&lt;IPayment&gt;((default(int)));
        await client.Pay();
    }
}
```

I'm trying to organize long running transactional process (in the future maybe with compensating actions aka [saga/state machine/call it what you want] it doesn't matter).

1. I need to do some piece of work in the Start method.
2. After run some method (ExecuteTransaction) without waiting and immediately return some result (in this example value which will notify that process has been successfully started).

What is the right way to do it? Use async void method or one more additional grain? Is async void bad practice here?

Also sometimes I'm getting Orleans.Storage.TableStorageUpdateConditionNotSatisfiedException in the 
ExecuteTransaction() method. I put two breakpoints in this method:

1. At the beginning of method.
2. After block of // Step 2.

The second breakpoint hits two times without stack trace when first only once. How it is possible magic?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>30/03/2018 1:53:49 PM +00:00</CreatedAt>
    <ClosedAt>12/07/2018 6:09:28 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4369</IssueLabelID>
    <Title>Update Reentrancy docs</Title>
    <Description>cc @dVakulen if you want to take a look.</Description>
    <Title_Description>Update Reentrancy docs cc @dVakulen if you want to take a look.</Title_Description>
    <Label>documentation</Label>
    <Assignee>dVakulen</Assignee>
    <CreatedAt>30/03/2018 8:40:54 AM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 4:06:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4368</IssueLabelID>
    <Title>Rewrite code generation docs</Title>
    <Description>
    </Description>
    <Title_Description>Rewrite code generation docs </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>30/03/2018 5:06:37 AM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 4:05:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4366</IssueLabelID>
    <Title>Rewrite bootstrap docs</Title>
    <Description>I *did* rename the file this time. The old file/title was a bit too long. Tested locally</Description>
    <Title_Description>Rewrite bootstrap docs I *did* rename the file this time. The old file/title was a bit too long. Tested locally</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>30/03/2018 3:23:19 AM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 3:34:08 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4365</IssueLabelID>
    <Title>Update Interceptors.md</Title>
    <Description>
    </Description>
    <Title_Description>Update Interceptors.md </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>30/03/2018 2:59:28 AM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 3:11:45 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4364</IssueLabelID>
    <Title>Update Service-Fabric.md</Title>
    <Description>
    </Description>
    <Title_Description>Update Service-Fabric.md </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>30/03/2018 2:41:29 AM +00:00</CreatedAt>
    <ClosedAt>30/03/2018 3:11:04 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4358</IssueLabelID>
    <Title>Update samples section1</Title>
    <Description>- update outdated sample doc
- remove sample doc whose sample are not upgraded to 2.0 yet.

Update samples section2 will add docs for samples ServiceFabric and docker-aspnet core which doesn't have dosc in samples section before </Description>
    <Title_Description>Update samples section1 - update outdated sample doc
- remove sample doc whose sample are not upgraded to 2.0 yet.

Update samples section2 will add docs for samples ServiceFabric and docker-aspnet core which doesn't have dosc in samples section before </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4357</IssueLabelID>
    <Title>Fix reference to Microsoft.Orleans.Hosting.ServiceFabric in Microsoft.Orleans.ServiceFabric to 2.0.0</Title>
    <Description>Fix reference to Microsoft.Orleans.Hosting.ServiceFabric in Microsoft.Orleans.ServiceFabric to 2.0.0 version of the package so that it doesn't point to a non existing version of the package (2.0.1 or 2.0.2).</Description>
    <Title_Description>Fix reference to Microsoft.Orleans.Hosting.ServiceFabric in Microsoft.Orleans.ServiceFabric to 2.0.0 Fix reference to Microsoft.Orleans.Hosting.ServiceFabric in Microsoft.Orleans.ServiceFabric to 2.0.0 version of the package so that it doesn't point to a non existing version of the package (2.0.1 or 2.0.2).</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4356</IssueLabelID>
    <Title>Simplify top level structure of the docs</Title>
    <Description>Merge Installation menu into Getting Started.
Merge New in Orleans 2.0 into other top level submenus.</Description>
    <Title_Description>Simplify top level structure of the docs Merge Installation menu into Getting Started.
Merge New in Orleans 2.0 into other top level submenus.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/03/2018 8:23:00 PM +00:00</CreatedAt>
    <ClosedAt>29/03/2018 9:38:37 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4355</IssueLabelID>
    <Title>Add 2.0.0 final to What's New page</Title>
    <Description>
    </Description>
    <Title_Description>Add 2.0.0 final to What's New page </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/03/2018 4:46:21 PM +00:00</CreatedAt>
    <ClosedAt>29/03/2018 9:18:43 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4353</IssueLabelID>
    <Title>Multi cluster and practical use discussion</Title>
    <Description> assume that there are some 3 teams(A B C)
- team **A** provide silos with `Authentication and Authorization` and some User Services，its grain interface may be cluster A: `IAuthGrain`  
- team **B** provide `Order service`  its grain interface may be   cluster B: `IOrderGrain`
- team **C** provide  `Inventory service` its grain interface may be cluster C: `IInventoryGrain`
each team develops its own services independently，my question is:

1. How should they eventually integrate together？
2. Does each team's silo or other project must refference all of there grain interfaces?  A refference `IOrderGrain` 、`IInventoryGrain` and `IAuthGrain`? I think it's not always feasible.
3. What is the best practice in such a scene?  
use one cluster or multi cluster?  if multi cluster can orleans work on other cloud server?
each team must predefine there grain interfaces which will be refferenced（used） by other teams?</Description>
    <Title_Description>Multi cluster and practical use discussion  assume that there are some 3 teams(A B C)
- team **A** provide silos with `Authentication and Authorization` and some User Services，its grain interface may be cluster A: `IAuthGrain`  
- team **B** provide `Order service`  its grain interface may be   cluster B: `IOrderGrain`
- team **C** provide  `Inventory service` its grain interface may be cluster C: `IInventoryGrain`
each team develops its own services independently，my question is:

1. How should they eventually integrate together？
2. Does each team's silo or other project must refference all of there grain interfaces?  A refference `IOrderGrain` 、`IInventoryGrain` and `IAuthGrain`? I think it's not always feasible.
3. What is the best practice in such a scene?  
use one cluster or multi cluster?  if multi cluster can orleans work on other cloud server?
each team must predefine there grain interfaces which will be refferenced（used） by other teams?</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
    <CreatedAt>29/03/2018 2:53:44 PM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 10:36:26 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4350</IssueLabelID>
    <Title>Microsoft.Orleans.ServiceFabric meta package references non-released 2.0.0 package</Title>
    <Description>`Microsoft.Orleans.Clustering.ServiceFabric` was pulled from 2.0.0 and left at 2.0.0-rc2
However `Microsoft.Orleans.ServiceFabric` was bumped from rc2 to final.

I suppose options are to leave the meta package at rc2 or have it reference only `Microsoft.Orleans.Hosting.ServiceFabric` on 2.0.x
</Description>
    <Title_Description>Microsoft.Orleans.ServiceFabric meta package references non-released 2.0.0 package `Microsoft.Orleans.Clustering.ServiceFabric` was pulled from 2.0.0 and left at 2.0.0-rc2
However `Microsoft.Orleans.ServiceFabric` was bumped from rc2 to final.

I suppose options are to leave the meta package at rc2 or have it reference only `Microsoft.Orleans.Hosting.ServiceFabric` on 2.0.x
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4348</IssueLabelID>
    <Title>Add a note about the change in provider configuration in 2.0</Title>
    <Description>Add a note about the change in provider configuration in 2.0 and the potential implications.
We should probably lift the general Cluster/Service ID part to the configuration section after we rewrite it for 2.0</Description>
    <Title_Description>Add a note about the change in provider configuration in 2.0 Add a note about the change in provider configuration in 2.0 and the potential implications.
We should probably lift the general Cluster/Service ID part to the configuration section after we rewrite it for 2.0</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4347</IssueLabelID>
    <Title>Adding simple Azure Worker Role Sample app</Title>
    <Description>
    </Description>
    <Title_Description>Adding simple Azure Worker Role Sample app </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4346</IssueLabelID>
    <Title>More streaming documentation cleanup</Title>
    <Description>
    </Description>
    <Title_Description>More streaming documentation cleanup </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4345</IssueLabelID>
    <Title>Edit migration page for Azure Cloud Services and add it to the menu.</Title>
    <Description>
    </Description>
    <Title_Description>Edit migration page for Azure Cloud Services and add it to the menu. </Title_Description>
    <Label>documentation</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4341</IssueLabelID>
    <Title>Fix title of the ADO.NET configuration page</Title>
    <Description>
    </Description>
    <Title_Description>Fix title of the ADO.NET configuration page </Title_Description>
    <Label>documentation</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4337</IssueLabelID>
    <Title>Update of Orleans stream documentation.</Title>
    <Description>Still more to do but will do that in next PR.  Getting this out for review / merge while working on more involved changes.</Description>
    <Title_Description>Update of Orleans stream documentation. Still more to do but will do that in next PR.  Getting this out for review / merge while working on more involved changes.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4333</IssueLabelID>
    <Title>How Cluster calls each other?</Title>
    <Description>Hi. everybody
I learned from the tutorial how the client invokes silo's Grains.
But I didn't find a way for silo to call silo (cluster call cluster).
Orleans 2.x has very little documentation</Description>
    <Title_Description>How Cluster calls each other? Hi. everybody
I learned from the tutorial how the client invokes silo's Grains.
But I didn't find a way for silo to call silo (cluster call cluster).
Orleans 2.x has very little documentation</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4331</IssueLabelID>
    <Title>Old data in zookeeper don't get  removed</Title>
    <Description>I find out when my orleans application restarts there will be a new record in the deploy node in zookeeper but it seems that the old record never get removed.  Will that cause performance or other problem?</Description>
    <Title_Description>Old data in zookeeper don't get  removed I find out when my orleans application restarts there will be a new record in the deploy node in zookeeper but it seems that the old record never get removed.  Will that cause performance or other problem?</Title_Description>
    <Label>help wanted</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>28/03/2018 6:33:10 AM +00:00</CreatedAt>
    <ClosedAt>8/10/2018 9:31:07 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4328</IssueLabelID>
    <Title>Timeout set by client is only respected by top-level grain</Title>
    <Description>According to https://github.com/dotnet/orleans/issues/1693#issuecomment-212984821 the timeout set by the client should be respected and propagated down to grains invoked by the grain running on the silo. I have a (fairly) minimal project here that demonstrates it is not: https://github.com/pmsanford/orleans-timeout-propagation-demo

It appears that the request to the first grain completes even if it takes longer than the SiloMessagingOptions.ResponseTimeout. However any grain calls beyond the initial call only respect the SiloMessagingOptions.ResponseTimeout. Have I misinterpreted the comment on the linked issue or is this a bug?

**Should a timeout set on MessagingOptions (or ClientMessagingOptions (??)) on the client side propagate through all grain activations on the silo?**

Edited to add: This is on OSX with `dotnet --version 2.1.4` and `Orleans version 2.0.0-rc2`</Description>
    <Title_Description>Timeout set by client is only respected by top-level grain According to https://github.com/dotnet/orleans/issues/1693#issuecomment-212984821 the timeout set by the client should be respected and propagated down to grains invoked by the grain running on the silo. I have a (fairly) minimal project here that demonstrates it is not: https://github.com/pmsanford/orleans-timeout-propagation-demo

It appears that the request to the first grain completes even if it takes longer than the SiloMessagingOptions.ResponseTimeout. However any grain calls beyond the initial call only respect the SiloMessagingOptions.ResponseTimeout. Have I misinterpreted the comment on the linked issue or is this a bug?

**Should a timeout set on MessagingOptions (or ClientMessagingOptions (??)) on the client side propagate through all grain activations on the silo?**

Edited to add: This is on OSX with `dotnet --version 2.1.4` and `Orleans version 2.0.0-rc2`</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4326</IssueLabelID>
    <Title>Do not add "-dev" version suffix to Release build if suffix isn't set.</Title>
    <Description>Without this fix final builds of 2.0.0 are marked as "2.0.0-dev".</Description>
    <Title_Description>Do not add "-dev" version suffix to Release build if suffix isn't set. Without this fix final builds of 2.0.0 are marked as "2.0.0-dev".</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4325</IssueLabelID>
    <Title>Skip ShouldUseInjectedQueueBalancerAndBalanceCorrectly tests.</Title>
    <Description>Will be addressed with https://github.com/dotnet/orleans/issues/4317.</Description>
    <Title_Description>Skip ShouldUseInjectedQueueBalancerAndBalanceCorrectly tests. Will be addressed with https://github.com/dotnet/orleans/issues/4317.</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4324</IssueLabelID>
    <Title>Skipping LogConsistencyTestsTwoClusters tests.</Title>
    <Description>Until we resolve https://github.com/dotnet/orleans/issues/4293</Description>
    <Title_Description>Skipping LogConsistencyTestsTwoClusters tests. Until we resolve https://github.com/dotnet/orleans/issues/4293</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4323</IssueLabelID>
    <Title>Fixed bug in custom storage log consistency provider factory.</Title>
    <Description>- Was passing name to constructor when name was not one of the construction parameteres.</Description>
    <Title_Description>Fixed bug in custom storage log consistency provider factory. - Was passing name to constructor when name was not one of the construction parameteres.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4322</IssueLabelID>
    <Title>Intermittent failures of  SMS_AllSilosRestart_UnsubscribeConsumer test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4155&amp;resultId=101189
&gt;Error message
Orleans.Runtime.OrleansMessageRejectionException : No gateways available
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.Streaming.Reliability.StreamReliabilityTests.&lt;SMS_AllSilosRestart_UnsubscribeConsumer&gt;d__40.MoveNext() in D:\build\agent\_work\15\s\test\TesterAzureUtils\Streaming\StreamReliabilityTests.cs:line 626
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent failures of  SMS_AllSilosRestart_UnsubscribeConsumer test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4155&amp;resultId=101189
&gt;Error message
Orleans.Runtime.OrleansMessageRejectionException : No gateways available
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.Streaming.Reliability.StreamReliabilityTests.&lt;SMS_AllSilosRestart_UnsubscribeConsumer&gt;d__40.MoveNext() in D:\build\agent\_work\15\s\test\TesterAzureUtils\Streaming\StreamReliabilityTests.cs:line 626
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:42:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4321</IssueLabelID>
    <Title>Intermittent failures of Sched_Task_SubTaskExecutionSequencing test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4155&amp;resultId=100410
&gt;Error message
Assert.Equal() Failure\r\nExpected: 10\r\nActual: 8
Stack trace
at UnitTests.SchedulerTests.OrleansTaskSchedulerBasicTests.Sched_Task_SubTaskExecutionSequencing() in D:\build\agent\_work\15\s\test\NonSilo.Tests\SchedulerTests\OrleansTaskSchedulerBasicTests.cs:line 558</Description>
    <Title_Description>Intermittent failures of Sched_Task_SubTaskExecutionSequencing test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4155&amp;resultId=100410
&gt;Error message
Assert.Equal() Failure\r\nExpected: 10\r\nActual: 8
Stack trace
at UnitTests.SchedulerTests.OrleansTaskSchedulerBasicTests.Sched_Task_SubTaskExecutionSequencing() in D:\build\agent\_work\15\s\test\NonSilo.Tests\SchedulerTests\OrleansTaskSchedulerBasicTests.cs:line 558</Title_Description>
    <Label>test-issue</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4320</IssueLabelID>
    <Title>Intermittent failures of PersistentStreamingOverSingleGatewayTest test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4147&amp;resultId=100810
&gt;Error message
Assert.Equal() Failure\r\nExpected: 653\r\nActual: 654
Stack trace
at Tester.StreamingTests.SystemTargetRouteTests.&lt;&gt;c__DisplayClass5_0.&lt;PersistentStreamingOverSingleGatewayTest&gt;b__6(Boolean lastTry) in D:\build\agent2\_work\8\s\test\Tester\StreamingTests\SystemTargetRouteTests.cs:line 96
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent2\_work\8\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 89
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent2\_work\8\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 102
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.SystemTargetRouteTests.&lt;PersistentStreamingOverSingleGatewayTest&gt;d__5.MoveNext() in D:\build\agent2\_work\8\s\test\Tester\StreamingTests\SystemTargetRouteTests.cs:line 96
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent failures of PersistentStreamingOverSingleGatewayTest test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4147&amp;resultId=100810
&gt;Error message
Assert.Equal() Failure\r\nExpected: 653\r\nActual: 654
Stack trace
at Tester.StreamingTests.SystemTargetRouteTests.&lt;&gt;c__DisplayClass5_0.&lt;PersistentStreamingOverSingleGatewayTest&gt;b__6(Boolean lastTry) in D:\build\agent2\_work\8\s\test\Tester\StreamingTests\SystemTargetRouteTests.cs:line 96
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent2\_work\8\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 89
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent2\_work\8\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 102
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.SystemTargetRouteTests.&lt;PersistentStreamingOverSingleGatewayTest&gt;d__5.MoveNext() in D:\build\agent2\_work\8\s\test\Tester\StreamingTests\SystemTargetRouteTests.cs:line 96
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:39:04 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4319</IssueLabelID>
    <Title>intermittent failures of Rem_Azure_GT_1F1J_MultiGrain</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=101129
&gt;Error message
Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message Request S127.0.0.1:27480:259533019*cli/c5a628a4@ac0793a9-&gt;S127.0.0.1:27480:259533019*grn/60DF7002/9f44629c@07e6ffa6 #7449[ForwardCount=2]: for 2 times after Non-existent activation to invalid activation. Rejecting now. 
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.TimerTests.ReminderTests_Base.&lt;PerCopyGrainFailureTest&gt;d__25.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\TimerTests\ReminderTests_Base.cs:line 342
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.TimerTests.ReminderTests_AzureTable.&lt;Rem_Azure_GT_1F1J_MultiGrain&gt;d__16.MoveNext() in D:\build\agent\_work\18\s\test\TesterAzureUtils\Reminder\ReminderTests_AzureTable.cs:line 365
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>intermittent failures of Rem_Azure_GT_1F1J_MultiGrain https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=101129
&gt;Error message
Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message Request S127.0.0.1:27480:259533019*cli/c5a628a4@ac0793a9-&gt;S127.0.0.1:27480:259533019*grn/60DF7002/9f44629c@07e6ffa6 #7449[ForwardCount=2]: for 2 times after Non-existent activation to invalid activation. Rejecting now. 
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.TimerTests.ReminderTests_Base.&lt;PerCopyGrainFailureTest&gt;d__25.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\TimerTests\ReminderTests_Base.cs:line 342
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.AzureUtils.TimerTests.ReminderTests_AzureTable.&lt;Rem_Azure_GT_1F1J_MultiGrain&gt;d__16.MoveNext() in D:\build\agent\_work\18\s\test\TesterAzureUtils\Reminder\ReminderTests_AzureTable.cs:line 365
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:32:53 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4318</IssueLabelID>
    <Title>Intermittent failures of Rem_Grain_1J_MultiGrainMultiReminders test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4164&amp;resultId=101330
&gt;Error message
Orleans.Runtime.ReminderException : Could not unregister reminder &lt;IOrleansReminder: GrainRef=GrainReference:*grn/549BB267/40733213fcc201daf462fc6a472e3e9403000000549bb267-0xB3D221CC ReminderName=REMINDER_1 ETag=bd94968a-6ff0-4986-9088-53bac5792d6d&gt; from the reminder table due to tag mismatch. You can retry.
Stack trace
Server stack trace: 
at Orleans.Runtime.ReminderService.LocalReminderService.&lt;UnregisterReminder&gt;d__19.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 148
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansCodeGenReminderServiceMethodInvoker.&lt;Invoke&gt;d__0.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Core\obj\Release\netstandard2.0\Orleans.Core.orleans.g.cs:line 947
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 91
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__64.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\InsideRuntimeClient.cs:line 364
Exception rethrown at [0]: 
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.Grains.ReminderTestGrain2.&lt;StopReminder&gt;d__14.MoveNext() in D:\build\agent\_work\15\s\test\TestInternalGrains\ReminderTestGrain2.cs:line 129
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GrainInterfaces.OrleansCodeGenReminderTestGrain2MethodInvoker.&lt;Invoke&gt;d__0.MoveNext() in D:\build\agent\_work\15\s\test\TestGrainInterfaces\obj\Release\netstandard2.0\win10-x64\TestGrainInterfaces.orleans.g.cs:line 26485
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 91
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__64.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\InsideRuntimeClient.cs:line 364
Exception rethrown at [1]: 
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.TimerTests.ReminderTests_Base.&lt;ExecuteWithRetriesStop&gt;d__29.MoveNext() in D:\build\agent\_work\15\s\test\TesterInternal\TimerTests\ReminderTests_Base.cs:line 420
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()</Description>
    <Title_Description>Intermittent failures of Rem_Grain_1J_MultiGrainMultiReminders test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4164&amp;resultId=101330
&gt;Error message
Orleans.Runtime.ReminderException : Could not unregister reminder &lt;IOrleansReminder: GrainRef=GrainReference:*grn/549BB267/40733213fcc201daf462fc6a472e3e9403000000549bb267-0xB3D221CC ReminderName=REMINDER_1 ETag=bd94968a-6ff0-4986-9088-53bac5792d6d&gt; from the reminder table due to tag mismatch. You can retry.
Stack trace
Server stack trace: 
at Orleans.Runtime.ReminderService.LocalReminderService.&lt;UnregisterReminder&gt;d__19.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs:line 148
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansCodeGenReminderServiceMethodInvoker.&lt;Invoke&gt;d__0.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Core\obj\Release\netstandard2.0\Orleans.Core.orleans.g.cs:line 947
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 91
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__64.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\InsideRuntimeClient.cs:line 364
Exception rethrown at [0]: 
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.Grains.ReminderTestGrain2.&lt;StopReminder&gt;d__14.MoveNext() in D:\build\agent\_work\15\s\test\TestInternalGrains\ReminderTestGrain2.cs:line 129
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GrainInterfaces.OrleansCodeGenReminderTestGrain2MethodInvoker.&lt;Invoke&gt;d__0.MoveNext() in D:\build\agent\_work\15\s\test\TestGrainInterfaces\obj\Release\netstandard2.0\win10-x64\TestGrainInterfaces.orleans.g.cs:line 26485
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.GrainMethodInvoker.&lt;Invoke&gt;d__21.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\GrainMethodInvoker.cs:line 91
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.InsideRuntimeClient.&lt;Invoke&gt;d__64.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Runtime\Core\InsideRuntimeClient.cs:line 364
Exception rethrown at [1]: 
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;WithTimeout&gt;d__16.MoveNext() in D:\build\agent\_work\15\s\src\Orleans.Core\Async\TaskExtensions.cs:line 218
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.TimerTests.ReminderTests_Base.&lt;ExecuteWithRetriesStop&gt;d__29.MoveNext() in D:\build\agent\_work\15\s\test\TesterInternal\TimerTests\ReminderTests_Base.cs:line 420
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:31:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4317</IssueLabelID>
    <Title>Intermittent failures of PluggableQueueBalancerTest_ShouldUseInjectedQueueBalancerAndBalanceCorrectly test</Title>
    <Description>Likely related to #3993.

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=100678
&gt;Error message
Assert.Equal() Failure\r\nExpected: 1\r\nActual: 2
Stack trace
at Tester.StreamingTests.PluggableQueueBalancerTestBase.&lt;CheckLeases&gt;d__4.MoveNext() in D:\build\agent\_work\18\s\test\Tester\StreamingTests\PlugableQueueBalancerTests\PluggableQueueBalancerTestBase.cs:line 41
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 89
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 102
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.PluggableQueueBalancerTestBase.&lt;ShouldUseInjectedQueueBalancerAndBalanceCorrectly&gt;d__2.MoveNext() in D:\build\agent\_work\18\s\test\Tester\StreamingTests\PlugableQueueBalancerTests\PluggableQueueBalancerTestBase.cs:line 23
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent failures of PluggableQueueBalancerTest_ShouldUseInjectedQueueBalancerAndBalanceCorrectly test Likely related to #3993.

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=100678
&gt;Error message
Assert.Equal() Failure\r\nExpected: 1\r\nActual: 2
Stack trace
at Tester.StreamingTests.PluggableQueueBalancerTestBase.&lt;CheckLeases&gt;d__4.MoveNext() in D:\build\agent\_work\18\s\test\Tester\StreamingTests\PlugableQueueBalancerTests\PluggableQueueBalancerTestBase.cs:line 41
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;&gt;c__DisplayClass4_0.&lt;&lt;WaitUntilAsync&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 89
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.TestingHost.Utils.TestingUtils.&lt;WaitUntilAsync&gt;d__4.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.TestingHost\Utils\TestingUtils.cs:line 102
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tester.StreamingTests.PluggableQueueBalancerTestBase.&lt;ShouldUseInjectedQueueBalancerAndBalanceCorrectly&gt;d__2.MoveNext() in D:\build\agent\_work\18\s\test\Tester\StreamingTests\PlugableQueueBalancerTests\PluggableQueueBalancerTestBase.cs:line 23
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4316</IssueLabelID>
    <Title>CustomStorage test is failing consistently</Title>
    <Description>We should probably rename it to something less generic.

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=101473
&gt;Error message
System.InvalidOperationException : A suitable constructor for type 'Orleans.EventSourcing.CustomStorage.LogConsistencyProvider' could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor.
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;&gt;c__DisplayClass12_0.&lt;&lt;ThreeCheckers&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 111
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;ThreeCheckers&gt;d__12.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 141
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;DoBasicLogTestGrainTest&gt;d__11.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 100
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;CustomStorage&gt;d__8.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>CustomStorage test is failing consistently We should probably rename it to something less generic.

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4144&amp;resultId=101473
&gt;Error message
System.InvalidOperationException : A suitable constructor for type 'Orleans.EventSourcing.CustomStorage.LogConsistencyProvider' could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor.
Stack trace
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;&gt;c__DisplayClass12_0.&lt;&lt;ThreeCheckers&gt;b__0&gt;d.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 111
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;ThreeCheckers&gt;d__12.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 141
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;DoBasicLogTestGrainTest&gt;d__11.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 100
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.BasicLogTestGrainTests.&lt;CustomStorage&gt;d__8.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\BasicLogTestGrainTests.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:27:58 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4315</IssueLabelID>
    <Title>WIP: Azure Kubernetes Service sample</Title>
    <Description>I am working on a Azure Kubernetes sample with instructions on how to build and deploy into Kubernetes.

I could use feed back if this is what people what to see.

https://github.com/jms69/orleans/tree/akssample/Samples/2.0/Kubernetes</Description>
    <Title_Description>WIP: Azure Kubernetes Service sample I am working on a Azure Kubernetes sample with instructions on how to build and deploy into Kubernetes.

I could use feed back if this is what people what to see.

https://github.com/jms69/orleans/tree/akssample/Samples/2.0/Kubernetes</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4314</IssueLabelID>
    <Title>HelloWorld Sample Error for netcore 2.0</Title>
    <Description>I try to run the HelloWorld sample on my mac I use .netcore 2.0 it throws the exception below:
System.ArgumentException: Cannot find an implementation class for grain interface: HelloWorld.Interfaces.IHello. Make sure the grain assembly was correctly deployed and loaded in the silo.
   at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
   at Orleans.GrainFactory.GetGrain[TGrainInterface](Int64 primaryKey String grainClassNamePrefix)
   at OrleansClient.Program.&lt;DoClientWork&gt;d__3.MoveNext() in /Users/echo/Documents/Github/orleans/Samples/2.0/HelloWorld/src/OrleansClient/Program.cs:line 78
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at OrleansClient.Program.&lt;RunMainAsync&gt;d__1.MoveNext() in /Users/echo/Documents/Github/orleans/Samples/2.0/HelloWorld/src/OrleansClient/Program.cs:line 29
</Description>
    <Title_Description>HelloWorld Sample Error for netcore 2.0 I try to run the HelloWorld sample on my mac I use .netcore 2.0 it throws the exception below:
System.ArgumentException: Cannot find an implementation class for grain interface: HelloWorld.Interfaces.IHello. Make sure the grain assembly was correctly deployed and loaded in the silo.
   at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
   at Orleans.GrainFactory.GetGrain[TGrainInterface](Int64 primaryKey String grainClassNamePrefix)
   at OrleansClient.Program.&lt;DoClientWork&gt;d__3.MoveNext() in /Users/echo/Documents/Github/orleans/Samples/2.0/HelloWorld/src/OrleansClient/Program.cs:line 78
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at OrleansClient.Program.&lt;RunMainAsync&gt;d__1.MoveNext() in /Users/echo/Documents/Github/orleans/Samples/2.0/HelloWorld/src/OrleansClient/Program.cs:line 29
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4313</IssueLabelID>
    <Title>Redundant Dictionary allocation in RequestContext.Set ?</Title>
    <Description>There is a extra allocation of `Dictionary` with copying values from another `Dictionary` if it exists.
https://github.com/dotnet/orleans/blob/3f27bea31633e55dbf4cbdb96b1562021da2226b/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs#L84-L89

Looks like comments outdated and article by link too. Does it make sense since  `CallContextData` based on `AsyncLocal&lt;T&gt;` not `CallContext` anymore? I tried remove this allocation and all still works fine. Could you investigate this question?</Description>
    <Title_Description>Redundant Dictionary allocation in RequestContext.Set ? There is a extra allocation of `Dictionary` with copying values from another `Dictionary` if it exists.
https://github.com/dotnet/orleans/blob/3f27bea31633e55dbf4cbdb96b1562021da2226b/src/Orleans.Core.Abstractions/Runtime/RequestContext.cs#L84-L89

Looks like comments outdated and article by link too. Does it make sense since  `CallContextData` based on `AsyncLocal&lt;T&gt;` not `CallContext` anymore? I tried remove this allocation and all still works fine. Could you investigate this question?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4312</IssueLabelID>
    <Title>Silo requests failing with error The target silo is no longer active</Title>
    <Description>From last few days (from 23rd of March) in one of our environment with 6 Orleans instances we started seeing an error - Error message: **The target silo is no longer active: target was S100.115.122.69:11111:259510909 but this silo is S100.115.122.69:11111:259777677. The rejected message is Request S100.115.164.34:11111:259777673*grn/89AD686A/7415dd99@dcbdc496-&gt;S100.115.122.69:11111:259510909*grn/D850AA86/5b444c9d@d6c97486 #298658: global::CloudPlatform.Tenant.Grain.Interfaces.Device.Event.IEventGrain:ProcessEventAsync()." Argument1=" Server stack trace: at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)** 
The error is observed in all the instances of the cluster and all the communication to this one silo (S100.115.122.69) fails continuously. 
From the OrleansSiloInstances table I can see that S100.115.122.69:11111:259510909 is marked to be dead on 23rd (2018-03-23 15:52:08.479 GMT)
![image](https://user-images.githubusercontent.com/14808657/37955528-7a01a016-31c6-11e8-956d-4faf5506e653.png)

There were these following warnings from other silos soon after the faulty silo was marked as dead - 
**EventName="MessageEvent" Message="[2018-03-23 15:52:52.990 GMT 53	WARNING	100148	Dispatcher	100.115.116.30:11111]	No target activation S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5 for response message: Transient Rejection (info: Silo S100.115.116.30:11111:259511374 is rejecting message: Request S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5-&gt;S100.115.122.69:11111:259510909*grn/716E8E94/643cd8bd+CovStreamProvider_CovStreamNameSpace@165c009c #25883[ForwardCount=1]: global::Orleans.Streams.IPubSubRendezvousGrain:RegisterProducer(). Reason = Target S100.115.122.69:11111:259510909 silo is known to be dead) Response S100.115.122.69:11111:259510909*grn/716E8E94/643cd8bd+CovStreamProvider_CovStreamNameSpace@165c009c-&gt;S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5 #25883: global::Orleans.Streams.IPubSubRendezvousGrain:RegisterProducer()	" TraceSource="WaWorkerHost.exe"**

These warning from the **faulty silo:**
**EventName="MessageEvent" Message="[2018-03-23 15:52:52.236 GMT 54	WARNING	100602	MembershipOracle	100.115.122.69:11111]	Silo CloudPlatform.Tenant.Worker.OrleansHost_IN_0 restarted on same host RD0003FFA01D47 New silo address = S100.115.122.69:11111:259516351 Previous silo address = S100.115.122.69:11111:259510909	" TraceSource="WaWorkerHost.exe"**

**EventName="MessageEvent" Message="[2018-03-23 15:52:50.923 GMT 54	WARNING	100824	AzureBasedMembershipTable	100.115.122.69:11111]	Update failed due to contention on the table. Will retry. Entry SiloAddress=S100.115.122.69:11111:259516351 SiloName=CloudPlatform.Tenant.Worker.OrleansHost_IN_0 Status=Joining eTag W/"datetime'2018-03-23T15%3A52%3A33.0728507Z'" table version = &lt;6255 W/"datetime'2018-03-23T15%3A52%3A08.7128507Z'"&gt; " TraceSource="WaWorkerHost.exe"**

**EventName="MessageEvent" Message="[2018-03-23 15:52:08.369 GMT 115	WARNING	100325	Silo	100.115.122.69:11111]	Ignoring System.TimeoutException exception thrown from an action called by Silo.Stop.	Exc level 0: System.TimeoutException: Task.WaitWithThrow has timed out after 00:01:00. at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task TimeSpan timeout) at Orleans.Runtime.Utils.SafeExecute(Action action Logger logger Func`1 callerGetter)" TraceSource="WaWorkerHost.exe"**

We did a couple of re starts and deployments but nothing seemed to have fixed the issue. Even now other silos are trying to connect to the faulty silo using older epoch S100.115.122.69:11111:259510909 and getting No longer active error.
Could you please help us finding what is the cause of this and how can we fix this? </Description>
    <Title_Description>Silo requests failing with error The target silo is no longer active From last few days (from 23rd of March) in one of our environment with 6 Orleans instances we started seeing an error - Error message: **The target silo is no longer active: target was S100.115.122.69:11111:259510909 but this silo is S100.115.122.69:11111:259777677. The rejected message is Request S100.115.164.34:11111:259777673*grn/89AD686A/7415dd99@dcbdc496-&gt;S100.115.122.69:11111:259510909*grn/D850AA86/5b444c9d@d6c97486 #298658: global::CloudPlatform.Tenant.Grain.Interfaces.Device.Event.IEventGrain:ProcessEventAsync()." Argument1=" Server stack trace: at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task)** 
The error is observed in all the instances of the cluster and all the communication to this one silo (S100.115.122.69) fails continuously. 
From the OrleansSiloInstances table I can see that S100.115.122.69:11111:259510909 is marked to be dead on 23rd (2018-03-23 15:52:08.479 GMT)
![image](https://user-images.githubusercontent.com/14808657/37955528-7a01a016-31c6-11e8-956d-4faf5506e653.png)

There were these following warnings from other silos soon after the faulty silo was marked as dead - 
**EventName="MessageEvent" Message="[2018-03-23 15:52:52.990 GMT 53	WARNING	100148	Dispatcher	100.115.116.30:11111]	No target activation S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5 for response message: Transient Rejection (info: Silo S100.115.116.30:11111:259511374 is rejecting message: Request S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5-&gt;S100.115.122.69:11111:259510909*grn/716E8E94/643cd8bd+CovStreamProvider_CovStreamNameSpace@165c009c #25883[ForwardCount=1]: global::Orleans.Streams.IPubSubRendezvousGrain:RegisterProducer(). Reason = Target S100.115.122.69:11111:259510909 silo is known to be dead) Response S100.115.122.69:11111:259510909*grn/716E8E94/643cd8bd+CovStreamProvider_CovStreamNameSpace@165c009c-&gt;S100.115.138.17:11111:259511483*grn/D66845D2/643cd8bd@ad32d9b5 #25883: global::Orleans.Streams.IPubSubRendezvousGrain:RegisterProducer()	" TraceSource="WaWorkerHost.exe"**

These warning from the **faulty silo:**
**EventName="MessageEvent" Message="[2018-03-23 15:52:52.236 GMT 54	WARNING	100602	MembershipOracle	100.115.122.69:11111]	Silo CloudPlatform.Tenant.Worker.OrleansHost_IN_0 restarted on same host RD0003FFA01D47 New silo address = S100.115.122.69:11111:259516351 Previous silo address = S100.115.122.69:11111:259510909	" TraceSource="WaWorkerHost.exe"**

**EventName="MessageEvent" Message="[2018-03-23 15:52:50.923 GMT 54	WARNING	100824	AzureBasedMembershipTable	100.115.122.69:11111]	Update failed due to contention on the table. Will retry. Entry SiloAddress=S100.115.122.69:11111:259516351 SiloName=CloudPlatform.Tenant.Worker.OrleansHost_IN_0 Status=Joining eTag W/"datetime'2018-03-23T15%3A52%3A33.0728507Z'" table version = &lt;6255 W/"datetime'2018-03-23T15%3A52%3A08.7128507Z'"&gt; " TraceSource="WaWorkerHost.exe"**

**EventName="MessageEvent" Message="[2018-03-23 15:52:08.369 GMT 115	WARNING	100325	Silo	100.115.122.69:11111]	Ignoring System.TimeoutException exception thrown from an action called by Silo.Stop.	Exc level 0: System.TimeoutException: Task.WaitWithThrow has timed out after 00:01:00. at Orleans.OrleansTaskExtentions.WaitWithThrow(Task task TimeSpan timeout) at Orleans.Runtime.Utils.SafeExecute(Action action Logger logger Func`1 callerGetter)" TraceSource="WaWorkerHost.exe"**

We did a couple of re starts and deployments but nothing seemed to have fixed the issue. Even now other silos are trying to connect to the faulty silo using older epoch S100.115.122.69:11111:259510909 and getting No longer active error.
Could you please help us finding what is the cause of this and how can we fix this? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/03/2018 8:49:02 AM +00:00</CreatedAt>
    <ClosedAt>25/06/2018 10:32:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4311</IssueLabelID>
    <Title>[2.0 RC2]What's wrong with this?</Title>
    <Description>2018-03-27 04:30:08.626 +08:00 [fail] Runtime.Scheduler.WorkerPoolThread/2[101212]: Worker pool thread Runtime.Scheduler.WorkerPoolThread/2 (ManagedThreadId=26) has been busy for long time: Executing Task Id=158 Status=Running for 00:00:00.3903356 on WorkItem=System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Running Executing for 00:00:00.3903596. WorkItemGroup Details: System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Running. Currently QueuedWorkItems=25; Total EnQueued=4870; Total processed=4844; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-12:Queued=25; Detailed SchedulingContext=&lt;[LowPrioritySystemTarget: S127.0.0.1:11111:259745611*stg/0/00000000@S00000000] CurrentlyExecuting=Response S127.0.0.1:11111:259745611*grn/44515979/e01548b0@4cb04888-&gt;S127.0.0.1:11111:259745611*stg/0/00000000@S00000000 #9896: &gt;.</Description>
    <Title_Description>[2.0 RC2]What's wrong with this? 2018-03-27 04:30:08.626 +08:00 [fail] Runtime.Scheduler.WorkerPoolThread/2[101212]: Worker pool thread Runtime.Scheduler.WorkerPoolThread/2 (ManagedThreadId=26) has been busy for long time: Executing Task Id=158 Status=Running for 00:00:00.3903356 on WorkItem=System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Running Executing for 00:00:00.3903596. WorkItemGroup Details: System*WorkItemGroup:Name=*stg/0/00000000WorkGroupStatus=Running. Currently QueuedWorkItems=25; Total EnQueued=4870; Total processed=4844; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-12:Queued=25; Detailed SchedulingContext=&lt;[LowPrioritySystemTarget: S127.0.0.1:11111:259745611*stg/0/00000000@S00000000] CurrentlyExecuting=Response S127.0.0.1:11111:259745611*grn/44515979/e01548b0@4cb04888-&gt;S127.0.0.1:11111:259745611*stg/0/00000000@S00000000 #9896: &gt;.</Title_Description>
    <Label>question</Label>
    <Assignee>lfzm</Assignee>
    <CreatedAt>27/03/2018 1:31:12 AM +00:00</CreatedAt>
    <ClosedAt>11/04/2018 6:22:33 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4310</IssueLabelID>
    <Title>Tutorials for Orleans 2.0</Title>
    <Description>This is issue ticket is intended to start a discussion on how the tutorials for Orleans 2.0 (and beyond) should  be developed. As we come up with tangible items to take action on we can populate this post to track progress on these items.</Description>
    <Title_Description>Tutorials for Orleans 2.0 This is issue ticket is intended to start a discussion on how the tutorials for Orleans 2.0 (and beyond) should  be developed. As we come up with tangible items to take action on we can populate this post to track progress on these items.</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4308</IssueLabelID>
    <Title>Does this make sense for Orleans or SF and if so guidance please</Title>
    <Description>We’re working to take our  software to Azure cloud and looking at Orleans and Service Fabric (SF) as potential frameworks.  We need to:

1)	Populate our analysis engines with lots of data (e.g. 100MB to 2GB) per engine instance.
2)	Maintain that state and if an engine instance goes idle for say 20 minutes or more we’d like to unload it (i.e. and not pay for the engine instance resource).
3)	Each engine instance will support one to several end users with a specific data set.
4)	Each engine instance can be highly interactive generating lots of plot data near realtime.  We’re maintaining state as we don’t want to pay the price to populate engine instance for each engine interaction.
5)	An engine instance action can take a few seconds a few minutes to even tens of minutes.  We’ll want some feedback.
6)	Users may access an engine instance every few seconds (e.g. to steer the engine towards a result based on feedback) and will want live plot data.
7)	Each user will want to talk to a specific engine instance.
8)	As a user expresses interest in running a simulation (i.e. standing up an engine instance) ideally we want him to choose small/medium/large computing resource to run his engine instance (i.e. based on the problem he’s trying to solve he may want more or less computing/memory power).

We’re considering Orleans and SF but we’re having difficulty specifying architecture based on above requirements.  We’ve considered:

1)	Trying to think about an SF node or an Orleans silo as an ‘engine instance’ described above.
2)	Leveraging both Orleans and SF notion of fault tolerance through replication.
3)	Leveraging local (i.e. to node or silo) storage to store results and maintain state (i.e. for long periods or until idle for 20 minutes).

We’ve not understood how to:

1)	Limit a silo or a node to a single engine instance so that we can control resourcing of the engine instance.
2)	Keep a user’s engine instance data separate from another users engine instance data.  
3)	Direct a request from a user (e.g. through a web API) to a particular engine instance.

Does this make sense for Orleans does it make more sense for SF?  Any pointers on how to implement the above would be helpful.
</Description>
    <Title_Description>Does this make sense for Orleans or SF and if so guidance please We’re working to take our  software to Azure cloud and looking at Orleans and Service Fabric (SF) as potential frameworks.  We need to:

1)	Populate our analysis engines with lots of data (e.g. 100MB to 2GB) per engine instance.
2)	Maintain that state and if an engine instance goes idle for say 20 minutes or more we’d like to unload it (i.e. and not pay for the engine instance resource).
3)	Each engine instance will support one to several end users with a specific data set.
4)	Each engine instance can be highly interactive generating lots of plot data near realtime.  We’re maintaining state as we don’t want to pay the price to populate engine instance for each engine interaction.
5)	An engine instance action can take a few seconds a few minutes to even tens of minutes.  We’ll want some feedback.
6)	Users may access an engine instance every few seconds (e.g. to steer the engine towards a result based on feedback) and will want live plot data.
7)	Each user will want to talk to a specific engine instance.
8)	As a user expresses interest in running a simulation (i.e. standing up an engine instance) ideally we want him to choose small/medium/large computing resource to run his engine instance (i.e. based on the problem he’s trying to solve he may want more or less computing/memory power).

We’re considering Orleans and SF but we’re having difficulty specifying architecture based on above requirements.  We’ve considered:

1)	Trying to think about an SF node or an Orleans silo as an ‘engine instance’ described above.
2)	Leveraging both Orleans and SF notion of fault tolerance through replication.
3)	Leveraging local (i.e. to node or silo) storage to store results and maintain state (i.e. for long periods or until idle for 20 minutes).

We’ve not understood how to:

1)	Limit a silo or a node to a single engine instance so that we can control resourcing of the engine instance.
2)	Keep a user’s engine instance data separate from another users engine instance data.  
3)	Direct a request from a user (e.g. through a web API) to a particular engine instance.

Does this make sense for Orleans does it make more sense for SF?  Any pointers on how to implement the above would be helpful.
</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4306</IssueLabelID>
    <Title>Question: Is there a stream example?</Title>
    <Description>Hi 

I am working on my master thesis about the fault tolerance techniques in Actor Based Stream Processing Frameworks. I have read through the documentation about stream and before starting programming a code sample(even a hello world program) about stream can definitely helps me a lot. The only example I can find is the quick start example in the documentation. 

I am new to stream processing so I hope to get some help here. Is there any code sample about stream?  

Thanks a lot!
</Description>
    <Title_Description>Question: Is there a stream example? Hi 

I am working on my master thesis about the fault tolerance techniques in Actor Based Stream Processing Frameworks. I have read through the documentation about stream and before starting programming a code sample(even a hello world program) about stream can definitely helps me a lot. The only example I can find is the quick start example in the documentation. 

I am new to stream processing so I hope to get some help here. Is there any code sample about stream?  

Thanks a lot!
</Title_Description>
    <Label>documentation</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4305</IssueLabelID>
    <Title>ProtobufSerializer</Title>
    <Description>Hi
I called this method in the Client &amp; Silo
`.Configure&lt;SerializationProviderOptions&gt;(opt =&gt; opt.SerializationProviders.Add(typeof(ProtobufSerializer).GetTypeInfo()))`
To ensure the Protobuf Serialization is work.What do I need to do?
Do I need to manually call serialization before calling Grains?</Description>
    <Title_Description>ProtobufSerializer Hi
I called this method in the Client &amp; Silo
`.Configure&lt;SerializationProviderOptions&gt;(opt =&gt; opt.SerializationProviders.Add(typeof(ProtobufSerializer).GetTypeInfo()))`
To ensure the Protobuf Serialization is work.What do I need to do?
Do I need to manually call serialization before calling Grains?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4301</IssueLabelID>
    <Title>Add Dns name look up clustering for container frameworks</Title>
    <Description>Docker/Kubernetes can communicate with other containers using DNS name lookup.  When the silo containers are scaled and there are multiple instances we can use Dns.GetHostEntry to look up the multiple addresses and pass it to UseStaticClustering().

The problem is that this list is static so as I scale up and down or as containers shutdown and restart the client only has a static list of gateways.  We should do a continuous DNS resolution so the client will have the most recent list of IPs.
```
builder.UseDnsNameLookupClustering("mysilocontainer" 40000);
```
I had created a web UI Orleans client in a container and the silo in another container.  After scaling the silo container up and down and failing out some of the original containers the client could no longer connect with the silo because it has a stale IP list.</Description>
    <Title_Description>Add Dns name look up clustering for container frameworks Docker/Kubernetes can communicate with other containers using DNS name lookup.  When the silo containers are scaled and there are multiple instances we can use Dns.GetHostEntry to look up the multiple addresses and pass it to UseStaticClustering().

The problem is that this list is static so as I scale up and down or as containers shutdown and restart the client only has a static list of gateways.  We should do a continuous DNS resolution so the client will have the most recent list of IPs.
```
builder.UseDnsNameLookupClustering("mysilocontainer" 40000);
```
I had created a web UI Orleans client in a container and the silo in another container.  After scaling the silo container up and down and failing out some of the original containers the client could no longer connect with the silo because it has a stale IP list.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4299</IssueLabelID>
    <Title>Update NuGet Packages page for 2.0</Title>
    <Description>
    </Description>
    <Title_Description>Update NuGet Packages page for 2.0 </Title_Description>
    <Label>documentation</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4298</IssueLabelID>
    <Title>tutorial about of Grain Persistence</Title>
    <Description>Do you plan on creating tutorial about of Grain Persistence？</Description>
    <Title_Description>tutorial about of Grain Persistence Do you plan on creating tutorial about of Grain Persistence？</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>23/03/2018 11:02:40 PM +00:00</CreatedAt>
    <ClosedAt>28/03/2018 9:53:03 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4296</IssueLabelID>
    <Title>Update Prerequisites page and fix a copy-paste error in What's New</Title>
    <Description>
    </Description>
    <Title_Description>Update Prerequisites page and fix a copy-paste error in What's New </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>23/03/2018 4:57:22 PM +00:00</CreatedAt>
    <ClosedAt>23/03/2018 7:40:39 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4295</IssueLabelID>
    <Title>Build-time generation issue in Microsoft.Orleans.OrleansCodeGenerator.Build</Title>
    <Description>Hi guys

Found the following issue in the latest 2.0.0-rc-2 version.

**Download for the the reproduction:**
[OrleansIssue.Libs.zip](https://github.com/dotnet/orleans/files/1841533/OrleansIssue.Libs.zip)

One of my grain uses RabbitMq to receive messages.
The moment I reference the NuGet pacakge RabbitMQ.Client v5.0.1 (.NET 4.5.1) and used a type from the package in a grain the this error comes up:

`..OrleansIssue.Libs\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.2.0.0-rc2\build\..\tasks\net461\Orleans.CodeGeneration.Build.exe" "@obj\Debug\codegen\OrleansIssue.Libs.orleans.g.args.txt"" exited with code 3.`

And the build output:

```
1&gt;  Orleans-CodeGen - Generating file &lt;path&gt;source\repos\OrleansIssue.Libs\obj\Debug\OrleansIssue.Libs.orleans.g.cs
1&gt;  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
1&gt;        Exception loading types from assembly 'RabbitMQ.Client Version=5.0.0.0 Culture=neutral PublicKeyToken=89e7d7c5feba84ce': 
1&gt;        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1&gt;           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1&gt;           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1&gt;           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1&gt;        Exc level 1: System.IO.FileLoadException: Could not load file or assembly 'Microsoft.Diagnostics.Tracing.EventSource Version=1.1.28.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1&gt;        Exc level 2: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1&gt;        Exc level 1: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040).
1&gt;  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1&gt;     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1&gt;     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1&gt;     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1&gt;  -- Code Generation FAILED -- 
1&gt;  
```

After some digging I found a relation with `Microsoft.Diagnostics.Tracing.EventSource.Redist`. As soon as this package is **downgraded** from 2.0.0-&gt; 1.1.28 the issue is resolved.

Please note that there is no compilation error in the code  its only the grain code generation at build-time.

Code:

```
 public class MyGrain : Grain IMyGrain
    {
        // RabbitMq type from RabbitMQ.Client
        private ConnectionFactory _factory;

        public Task DoWork()
        {
            throw new NotImplementedException();
        }
    }
```

Involved packages:

Used RabbitMq package:
`&lt;package id="RabbitMQ.Client" version="5.0.1" targetFramework="net471" /&gt;`

Package that throws the error:
`package id="Microsoft.Orleans.OrleansCodeGenerator.Build" version="2.0.0-rc2" targetFramework="net471"`

Can someone find out what goes wrong here?</Description>
    <Title_Description>Build-time generation issue in Microsoft.Orleans.OrleansCodeGenerator.Build Hi guys

Found the following issue in the latest 2.0.0-rc-2 version.

**Download for the the reproduction:**
[OrleansIssue.Libs.zip](https://github.com/dotnet/orleans/files/1841533/OrleansIssue.Libs.zip)

One of my grain uses RabbitMq to receive messages.
The moment I reference the NuGet pacakge RabbitMQ.Client v5.0.1 (.NET 4.5.1) and used a type from the package in a grain the this error comes up:

`..OrleansIssue.Libs\packages\Microsoft.Orleans.OrleansCodeGenerator.Build.2.0.0-rc2\build\..\tasks\net461\Orleans.CodeGeneration.Build.exe" "@obj\Debug\codegen\OrleansIssue.Libs.orleans.g.args.txt"" exited with code 3.`

And the build output:

```
1&gt;  Orleans-CodeGen - Generating file &lt;path&gt;source\repos\OrleansIssue.Libs\obj\Debug\OrleansIssue.Libs.orleans.g.cs
1&gt;  warn: Orleans.CodeGenerator.RoslynCodeGenerator[101723]
1&gt;        Exception loading types from assembly 'RabbitMQ.Client Version=5.0.0.0 Culture=neutral PublicKeyToken=89e7d7c5feba84ce': 
1&gt;        Exc level 0: System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1&gt;           at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1&gt;           at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1&gt;           at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1&gt;        Exc level 1: System.IO.FileLoadException: Could not load file or assembly 'Microsoft.Diagnostics.Tracing.EventSource Version=1.1.28.0 Culture=neutral PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1&gt;        Exc level 2: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
1&gt;        Exc level 1: System.IO.FileLoadException: The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040).
1&gt;  System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types. Retrieve the LoaderExceptions property for more information.
1&gt;     at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
1&gt;     at System.Reflection.RuntimeAssembly.get_DefinedTypes()
1&gt;     at Orleans.Runtime.TypeUtils.GetDefinedTypes(Assembly assembly ILogger logger) in D:\build\agent\_work\9\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs:line 561
1&gt;  -- Code Generation FAILED -- 
1&gt;  
```

After some digging I found a relation with `Microsoft.Diagnostics.Tracing.EventSource.Redist`. As soon as this package is **downgraded** from 2.0.0-&gt; 1.1.28 the issue is resolved.

Please note that there is no compilation error in the code  its only the grain code generation at build-time.

Code:

```
 public class MyGrain : Grain IMyGrain
    {
        // RabbitMq type from RabbitMQ.Client
        private ConnectionFactory _factory;

        public Task DoWork()
        {
            throw new NotImplementedException();
        }
    }
```

Involved packages:

Used RabbitMq package:
`&lt;package id="RabbitMQ.Client" version="5.0.1" targetFramework="net471" /&gt;`

Package that throws the error:
`package id="Microsoft.Orleans.OrleansCodeGenerator.Build" version="2.0.0-rc2" targetFramework="net471"`

Can someone find out what goes wrong here?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4294</IssueLabelID>
    <Title>Added test to exersize queue rebalancing while actively streaming</Title>
    <Description>It's a continuation of #4272. GitHub is angry with me and is not letting me force push (this force is not with me) 
This test is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
</Description>
    <Title_Description>Added test to exersize queue rebalancing while actively streaming It's a continuation of #4272. GitHub is angry with me and is not letting me force push (this force is not with me) 
This test is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
</Title_Description>
    <Label>P3</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4293</IssueLabelID>
    <Title>LogConsistencyTestsFourClusters are not passing</Title>
    <Description>This has been hidden by the fact that they are not marked as functionals.</Description>
    <Title_Description>LogConsistencyTestsFourClusters are not passing This has been hidden by the fact that they are not marked as functionals.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4292</IssueLabelID>
    <Title>Ported log consistency providers from IProvider.</Title>
    <Description>- Should no longer require legacy systems to use.

This should address "Configuring LogConsistencyProvider still requires legacy config in 2.0-rc2" #4286 </Description>
    <Title_Description>Ported log consistency providers from IProvider. - Should no longer require legacy systems to use.

This should address "Configuring LogConsistencyProvider still requires legacy config in 2.0-rc2" #4286 </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4291</IssueLabelID>
    <Title>Error calling grain's</Title>
    <Description>0.
"Exception" : "Orleans.Storage.BadGrainStorageConfigException: No storage provider named \"Default\" found loading grain type Orleans.Runtime.Versions.VersionStoreGrain.
1.
Lifecycle start canceled due to errors at stage 1000
2.
Error calling grain's OnActivateAsync() method - Grain type = Orleans.Runtime.Versions.VersionStoreGrain Activation = [Activation: S127.0.0.1:8271:259483257*grn/13BAB4D8/00000000+fabric:/SecurityApp/StatelessCommandService@1cbfe087 #GrainType=Orleans.Runtime.Versions.VersionStoreGrain Placement=RandomPlacement State=Activating]
3.
Failed to InvokeActivate for [Activation: S127.0.0.1:8271:259483257*grn/13BAB4D8/00000000+fabric:/SecurityApp/StatelessCommandService@d6345997 #GrainType=Orleans.Runtime.Versions.VersionStoreGrain Placement=RandomPlacement State=Invalid].</Description>
    <Title_Description>Error calling grain's 0.
"Exception" : "Orleans.Storage.BadGrainStorageConfigException: No storage provider named \"Default\" found loading grain type Orleans.Runtime.Versions.VersionStoreGrain.
1.
Lifecycle start canceled due to errors at stage 1000
2.
Error calling grain's OnActivateAsync() method - Grain type = Orleans.Runtime.Versions.VersionStoreGrain Activation = [Activation: S127.0.0.1:8271:259483257*grn/13BAB4D8/00000000+fabric:/SecurityApp/StatelessCommandService@1cbfe087 #GrainType=Orleans.Runtime.Versions.VersionStoreGrain Placement=RandomPlacement State=Activating]
3.
Failed to InvokeActivate for [Activation: S127.0.0.1:8271:259483257*grn/13BAB4D8/00000000+fabric:/SecurityApp/StatelessCommandService@d6345997 #GrainType=Orleans.Runtime.Versions.VersionStoreGrain Placement=RandomPlacement State=Invalid].</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4290</IssueLabelID>
    <Title>Second pass at options overrides</Title>
    <Description>- Added registration functions that use named options and register the options for logging
- Updated named components that use cluster options to support the overrides.

Unclear what to do about unnamed components that use cluster options.  At this time they are not being overridden.  Maybe we can use the component name or abstraction name?  (IReminderTable? for instance).  What to do with unnamed components is for discussion and planning possible additional pass should not block this PR.</Description>
    <Title_Description>Second pass at options overrides - Added registration functions that use named options and register the options for logging
- Updated named components that use cluster options to support the overrides.

Unclear what to do about unnamed components that use cluster options.  At this time they are not being overridden.  Maybe we can use the component name or abstraction name?  (IReminderTable? for instance).  What to do with unnamed components is for discussion and planning possible additional pass should not block this PR.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4289</IssueLabelID>
    <Title>Remove inconsistent sub builder pattern in streaming</Title>
    <Description>Remove ISiloHostBuilder and IClientBuilder extensions methods which returns a stream sub builder instead of a ISiloHostbuilder or IClientBuilder. To keep consistency hence reduce confusion. </Description>
    <Title_Description>Remove inconsistent sub builder pattern in streaming Remove ISiloHostBuilder and IClientBuilder extensions methods which returns a stream sub builder instead of a ISiloHostbuilder or IClientBuilder. To keep consistency hence reduce confusion. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4288</IssueLabelID>
    <Title>Update FAQ</Title>
    <Description>
    </Description>
    <Title_Description>Update FAQ </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4287</IssueLabelID>
    <Title>Reminders: Improve error message when using reminders without a reminder table</Title>
    <Description>Alternative implementation of #4280

Fixes #4278</Description>
    <Title_Description>Reminders: Improve error message when using reminders without a reminder table Alternative implementation of #4280

Fixes #4278</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4286</IssueLabelID>
    <Title>Configuring LogConsistencyProvider still requires legacy config in 2.0-rc2</Title>
    <Description>To configure the EventSourcing I can only use legacy config.

Will this be added to 2.0 config by release?

```
var config = new ClusterConfiguration();
config.AddLogStorageBasedLogConsistencyProvider("StateStorage");  

builder.AddLegacyClusterConfigurationSupport(config);
```
</Description>
    <Title_Description>Configuring LogConsistencyProvider still requires legacy config in 2.0-rc2 To configure the EventSourcing I can only use legacy config.

Will this be added to 2.0 config by release?

```
var config = new ClusterConfiguration();
config.AddLogStorageBasedLogConsistencyProvider("StateStorage");  

builder.AddLegacyClusterConfigurationSupport(config);
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4285</IssueLabelID>
    <Title>Update What's New page</Title>
    <Description>
    </Description>
    <Title_Description>Update What's New page </Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4284</IssueLabelID>
    <Title>Remove 1.5 content from 2.0 Tutorials page</Title>
    <Description>This is to prevent confusion and to prepare a clean slate for 2.0 tutorials.</Description>
    <Title_Description>Remove 1.5 content from 2.0 Tutorials page This is to prevent confusion and to prepare a clean slate for 2.0 tutorials.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4283</IssueLabelID>
    <Title>WorkGroup X took elapsed time and Task pressure</Title>
    <Description>I've been investigating grain client timeouts and with that a large number of WorkGroup timeout warnings. After a fair amount of logging commenting and digging around I think I've distilled it down into being Task pressure on the scheduler. I'll try to describe out scenario summarize the investigatory steps and findings and then provide a simple example that results in the same warnings.

# Our Usage
We use Orleans as a means of importing normalizing processing and ultimately storing data from external data sources into a cloud based database. Additionally as new data and updates to old data come in we update external clients with the normalized and processed data.

Each document that comes in has a primary key to which we use to create an import grain. This import grain does some work to map external source IDs to normalized ones and then passes the normalized data to a "model" grain who's primary key is the mapped external primary key. These "model" grains use a custom storage provider that reads/writes to the cloud based database. This call also calls update on registered observers which end up flowing through to externally connected clients subscribed to document changes.

That's a pretty brief description of what we're trying to accomplish. I can dig into how we're doing it if necessary but I don't want to get side tracked on the approach yet.

# Investigations
- Eliminated possible blocking calls (Task.Run all the things)
- Added logging with timestamps around turns (start stop and around await calls)
- Added logging to the database to check query times

## Findings
- The timing logs ended up not really correlating well to any of the "WorkGroup X took elapsed time"
- The timing logs showed pretty random and sporadic long duration tasks (explained below)

### Sporadic long-running tasks
One of the best examples I encountered was when investigating some long execution database calls in a WriteStateAsync call to a storage provider. Generally the database call would take 100-150ms (keep in mind these are called via Task.Run). The database's logs were showing 10-40ms for the actual query. While attempting to determine the difference here I noticed that individual statements in the code would sometimes very dramatically in how long they "took" and the query itself was not always the thing that took 100-150ms. An example is:

1. Do some small amount of work
2. Do some other small amount of work
3. Build a 200-300 character string using $"" interpolation
4. Execute query

"Generally" step 4 would take 100-150ms; however _sometimes_ steps 1 or 2 or 3 would take 150ms and step 4 would take 10-40ms.

### Conclusions
So based on that I put together a simple grain call that generates a bunch of Tasks and I end up seeing the same "WorkGroup X took elapsed time" warnings.

### Is this normal and/or expected?
We do generate a number of tasks throughout many of our grains. Not an inordinately large number but it's probably 1-10 per document.

I would expect this type of behavior spinning up a large number of threads that would then end up having to compete for CPU core time. Thus I feel like this is probably normal given a large number of Tasks would end up competing for Thread time? What seems strange to me; however is that the warning message implies the WorkGroup was _started_ preempted and then completed.

# Simple Example
## Grain Client
The client just calls a grain's Echo method 100 times. Each iteration is a new grain.
```C#
while (!quit)
{
    var duration = new ExecutionTime();
    var grain = client.GetGrain&lt;IEchoGrain&gt;(Guid.NewGuid());
    for (var i = 0; i &lt; 100; i++)
    {
        var _ = grain.Echo("Some message here");
    }
    Console.WriteLine($"Duration: {duration}");
    await Task.Delay(1000);
}
```

## Grain
The grain creates 100 Task.Delay(500) tasks and then Task.WhenAll's them. Note: I've tried most variations of using Task.Run and not.

```C#
public class EchoGrain : Grain IEchoGrain
{
    public async Task&lt;string&gt; Echo(string message)
    {
        var tasks = new List&lt;Task&gt;();
        for (var i = 0; i &lt; 100; i++)
        {
            var task = Task.Run(() =&gt; Task.Delay(500));
            tasks.Add(task);
        }
        await Task.Run(() =&gt; Task.WhenAll(tasks));
        return message;
    }
}
```</Description>
    <Title_Description>WorkGroup X took elapsed time and Task pressure I've been investigating grain client timeouts and with that a large number of WorkGroup timeout warnings. After a fair amount of logging commenting and digging around I think I've distilled it down into being Task pressure on the scheduler. I'll try to describe out scenario summarize the investigatory steps and findings and then provide a simple example that results in the same warnings.

# Our Usage
We use Orleans as a means of importing normalizing processing and ultimately storing data from external data sources into a cloud based database. Additionally as new data and updates to old data come in we update external clients with the normalized and processed data.

Each document that comes in has a primary key to which we use to create an import grain. This import grain does some work to map external source IDs to normalized ones and then passes the normalized data to a "model" grain who's primary key is the mapped external primary key. These "model" grains use a custom storage provider that reads/writes to the cloud based database. This call also calls update on registered observers which end up flowing through to externally connected clients subscribed to document changes.

That's a pretty brief description of what we're trying to accomplish. I can dig into how we're doing it if necessary but I don't want to get side tracked on the approach yet.

# Investigations
- Eliminated possible blocking calls (Task.Run all the things)
- Added logging with timestamps around turns (start stop and around await calls)
- Added logging to the database to check query times

## Findings
- The timing logs ended up not really correlating well to any of the "WorkGroup X took elapsed time"
- The timing logs showed pretty random and sporadic long duration tasks (explained below)

### Sporadic long-running tasks
One of the best examples I encountered was when investigating some long execution database calls in a WriteStateAsync call to a storage provider. Generally the database call would take 100-150ms (keep in mind these are called via Task.Run). The database's logs were showing 10-40ms for the actual query. While attempting to determine the difference here I noticed that individual statements in the code would sometimes very dramatically in how long they "took" and the query itself was not always the thing that took 100-150ms. An example is:

1. Do some small amount of work
2. Do some other small amount of work
3. Build a 200-300 character string using $"" interpolation
4. Execute query

"Generally" step 4 would take 100-150ms; however _sometimes_ steps 1 or 2 or 3 would take 150ms and step 4 would take 10-40ms.

### Conclusions
So based on that I put together a simple grain call that generates a bunch of Tasks and I end up seeing the same "WorkGroup X took elapsed time" warnings.

### Is this normal and/or expected?
We do generate a number of tasks throughout many of our grains. Not an inordinately large number but it's probably 1-10 per document.

I would expect this type of behavior spinning up a large number of threads that would then end up having to compete for CPU core time. Thus I feel like this is probably normal given a large number of Tasks would end up competing for Thread time? What seems strange to me; however is that the warning message implies the WorkGroup was _started_ preempted and then completed.

# Simple Example
## Grain Client
The client just calls a grain's Echo method 100 times. Each iteration is a new grain.
```C#
while (!quit)
{
    var duration = new ExecutionTime();
    var grain = client.GetGrain&lt;IEchoGrain&gt;(Guid.NewGuid());
    for (var i = 0; i &lt; 100; i++)
    {
        var _ = grain.Echo("Some message here");
    }
    Console.WriteLine($"Duration: {duration}");
    await Task.Delay(1000);
}
```

## Grain
The grain creates 100 Task.Delay(500) tasks and then Task.WhenAll's them. Note: I've tried most variations of using Task.Run and not.

```C#
public class EchoGrain : Grain IEchoGrain
{
    public async Task&lt;string&gt; Echo(string message)
    {
        var tasks = new List&lt;Task&gt;();
        for (var i = 0; i &lt; 100; i++)
        {
            var task = Task.Run(() =&gt; Task.Delay(500));
            tasks.Add(task);
        }
        await Task.Run(() =&gt; Task.WhenAll(tasks));
        return message;
    }
}
```</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4281</IssueLabelID>
    <Title>Intermittent failure of GlobalSingleInstanceClusterTests.All_Small test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4113&amp;resultId=101389
&gt;Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False
Stack trace
at Tests.GeoClusterTests.GlobalSingleInstanceClusterTests.&lt;ConflictResolution&gt;d__14.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\GlobalSingleInstanceClusterTests.cs:line 412
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.GlobalSingleInstanceClusterTests.&lt;All_Small&gt;d__1.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\GlobalSingleInstanceClusterTests.cs:line 40
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent failure of GlobalSingleInstanceClusterTests.All_Small test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4113&amp;resultId=101389
&gt;Error message
Assert.True() Failure\r\nExpected: True\r\nActual: False
Stack trace
at Tests.GeoClusterTests.GlobalSingleInstanceClusterTests.&lt;ConflictResolution&gt;d__14.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\GlobalSingleInstanceClusterTests.cs:line 412
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.GlobalSingleInstanceClusterTests.&lt;All_Small&gt;d__1.MoveNext() in D:\build\agent\_work\13\s\test\TesterInternal\GeoClusterTests\GlobalSingleInstanceClusterTests.cs:line 40
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4278</IssueLabelID>
    <Title>Obscure error message when using Reminders without registering a reminders provider</Title>
    <Description>```C#
  public class Info : Grain IInfo IRemindable
    {
        public Task ReceiveReminder(string reminderName TickStatus status)
        {
            Console.WriteLine("Thanks for reminding me-- I almost forgot!");
            return Task.CompletedTask;
        }
        public async override Task OnActivateAsync()
        {
            Console.WriteLine("OnActivateAsync..");
            return;
        }
        public async Task&lt;string&gt; Get()
        {
             Console.WriteLine("get..");
            TimeSpan t1 = TimeSpan.FromMinutes(2);
            TimeSpan t2 = TimeSpan.FromMinutes(3);
            try
            {
                IGrainReminder reminder = await RegisterOrUpdateReminder("testtime" t1 t2);
            }
            catch (Exception ex)
            {
                throw ex;
            }
            //base.RegisterTimer(OnClientRefreshTimer null t1 - TimeSpan.FromSeconds(2) t1);

            return "info";
        }
    }
```
```
SystemTarget *stg/0/00000000 not active on this silo. Msg=Request S127.0.0.1:11112:259398066*grn/54700641/00000000@e5d40db1-&gt;S127.0.0.1:11112:259398066*stg/0/00000000@S00000000 #23: 
```
```C#
  client = StartClientWithRetries().Result;

            var info = client.GetGrain&lt;IInfo&gt;(0);
            var result = info.Get();
```
I want to implement ReceiveReminder at ten o'clock every day
</Description>
    <Title_Description>Obscure error message when using Reminders without registering a reminders provider ```C#
  public class Info : Grain IInfo IRemindable
    {
        public Task ReceiveReminder(string reminderName TickStatus status)
        {
            Console.WriteLine("Thanks for reminding me-- I almost forgot!");
            return Task.CompletedTask;
        }
        public async override Task OnActivateAsync()
        {
            Console.WriteLine("OnActivateAsync..");
            return;
        }
        public async Task&lt;string&gt; Get()
        {
             Console.WriteLine("get..");
            TimeSpan t1 = TimeSpan.FromMinutes(2);
            TimeSpan t2 = TimeSpan.FromMinutes(3);
            try
            {
                IGrainReminder reminder = await RegisterOrUpdateReminder("testtime" t1 t2);
            }
            catch (Exception ex)
            {
                throw ex;
            }
            //base.RegisterTimer(OnClientRefreshTimer null t1 - TimeSpan.FromSeconds(2) t1);

            return "info";
        }
    }
```
```
SystemTarget *stg/0/00000000 not active on this silo. Msg=Request S127.0.0.1:11112:259398066*grn/54700641/00000000@e5d40db1-&gt;S127.0.0.1:11112:259398066*stg/0/00000000@S00000000 #23: 
```
```C#
  client = StartClientWithRetries().Result;

            var info = client.GetGrain&lt;IInfo&gt;(0);
            var result = info.Get();
```
I want to implement ReceiveReminder at ten o'clock every day
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4277</IssueLabelID>
    <Title>Overridable options</Title>
    <Description>Another prototype like #4276 which allows override of options by registering names services to override an option.</Description>
    <Title_Description>Overridable options Another prototype like #4276 which allows override of options by registering names services to override an option.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4275</IssueLabelID>
    <Title>WIP - More aggressively cleanup system target stream producers.</Title>
    <Description>This is part of a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.

The concern was that inactive system target stream producers were not being cleaned up in the pubsub state leading to streams that could no longer be subscribed to or unsubscribed from.

There is an issue here though I am unconvinced it is the cause of the behaviors @ilyalukyanov is seeing.  This conclusion comes from the fact that in @ilyalukyanov's scenario silos were being killed so the system target stream producers on those silo by the existing logic should be cleaned up.  The system target stream producers that where rebalanced would have unregistered as part of the queue rebalancing.  Only if the unregister operation had failed would this bug manifest.  That would have shown up in the logs.

This PR is marked WIP because it's not yet obvious that this is the right fix.  It's not clear under what conditions the OrleansMessageRejectionException is returned.  The GetApproximateSiloStatus check implies that it was expected that there was a possibility for OrleansMessageRejectionException to be received when the producer was still valid and I've yet been unable to rule this out.  The cost of getting this wrong is that healthy producers could be removed thus no longer be notified of subscription changes on that stream.</Description>
    <Title_Description>WIP - More aggressively cleanup system target stream producers. This is part of a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.

The concern was that inactive system target stream producers were not being cleaned up in the pubsub state leading to streams that could no longer be subscribed to or unsubscribed from.

There is an issue here though I am unconvinced it is the cause of the behaviors @ilyalukyanov is seeing.  This conclusion comes from the fact that in @ilyalukyanov's scenario silos were being killed so the system target stream producers on those silo by the existing logic should be cleaned up.  The system target stream producers that where rebalanced would have unregistered as part of the queue rebalancing.  Only if the unregister operation had failed would this bug manifest.  That would have shown up in the logs.

This PR is marked WIP because it's not yet obvious that this is the right fix.  It's not clear under what conditions the OrleansMessageRejectionException is returned.  The GetApproximateSiloStatus check implies that it was expected that there was a possibility for OrleansMessageRejectionException to be received when the producer was still valid and I've yet been unable to rule this out.  The cost of getting this wrong is that healthy producers could be removed thus no longer be notified of subscription changes on that stream.</Title_Description>
    <Label>work-in-progress</Label>
    <Assignee>ilyalukyanov</Assignee>
    <CreatedAt>21/03/2018 9:30:52 PM +00:00</CreatedAt>
    <ClosedAt>28/02/2019 9:51:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4273</IssueLabelID>
    <Title>Add validation for pubsubstore when using persistent streams</Title>
    <Description>Persistent streams which has Explicit pubsub configured requires a grain storage with name `PubSubStore` configured with silo. But this is not obvious to users. So in this PR adding a validation for this if user forget to configure one. 

Fix for #4196 </Description>
    <Title_Description>Add validation for pubsubstore when using persistent streams Persistent streams which has Explicit pubsub configured requires a grain storage with name `PubSubStore` configured with silo. But this is not obvious to users. So in this PR adding a validation for this if user forget to configure one. 

Fix for #4196 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4272</IssueLabelID>
    <Title>Added test to exersize queue rebalancing while actively streaming</Title>
    <Description>This tests is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
It will not compile or pass tests until Lease based queue balancer fixes #4267 is merged.</Description>
    <Title_Description>Added test to exersize queue rebalancing while actively streaming This tests is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
It will not compile or pass tests until Lease based queue balancer fixes #4267 is merged.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4271</IssueLabelID>
    <Title>Clean up EH checkpointing</Title>
    <Description>- checkpoints new uses serviceid for partitioning
- table name has default</Description>
    <Title_Description>Clean up EH checkpointing - checkpoints new uses serviceid for partitioning
- table name has default</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4269</IssueLabelID>
    <Title>Fix race condition in ClientMessageCenter</Title>
    <Description>Fix for #3171 

We could add code to make request fail quicker (not waiting the default timeout) but it a very edge case so I don't think it is worth it.</Description>
    <Title_Description>Fix race condition in ClientMessageCenter Fix for #3171 

We could add code to make request fail quicker (not waiting the default timeout) but it a very edge case so I don't think it is worth it.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4268</IssueLabelID>
    <Title>How to determine message is delivered on OneWay mode ？</Title>
    <Description>Seems orleans send self a rejection response message while request message fail to send
but in OneWay mode  error message will not throw so i can't catch it

is there any way could ensure message will arrive in OneWay mode?</Description>
    <Title_Description>How to determine message is delivered on OneWay mode ？ Seems orleans send self a rejection response message while request message fail to send
but in OneWay mode  error message will not throw so i can't catch it

is there any way could ensure message will arrive in OneWay mode?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4267</IssueLabelID>
    <Title>Lease based queue balancer fixes</Title>
    <Description>- Timers were not on orleans thread so couldn't make grain calls.
- Aqure logic could be too greedy
- logging and spelling cleanup (can you believe -I- fixed spelling?)
- prevented possible devide by 0 issues.</Description>
    <Title_Description>Lease based queue balancer fixes - Timers were not on orleans thread so couldn't make grain calls.
- Aqure logic could be too greedy
- logging and spelling cleanup (can you believe -I- fixed spelling?)
- prevented possible devide by 0 issues.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4265</IssueLabelID>
    <Title>Intermittent failures of ThreeClusterBattery test</Title>
    <Description>https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4079&amp;resultId=101380
&gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:21300:259343047*gcl/C/562f28b3+C@ef6312b6-&gt;S127.0.0.1:21301:259343061*grn/21E58844/4fe3f9d0@ca8917b6 #865358[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now. 
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.ClientWrapper.GetRuntimeId(Int32 i) in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 179
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;Deact&gt;d__17.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 0
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;ThreeClusterBattery&gt;d__5.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
----- Inner Stack Trace -----
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4069&amp;resultId=101409
&gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:21300:259293372*gcl/C/697540ac+C@0aecc696-&gt;S127.0.0.1:21300:259293372*grn/21E58844/6f9bb666@aee927a3 #61674[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now. 
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.ClientWrapper.GetRuntimeId(Int32 i) in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 179
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;Deact&gt;d__17.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 0
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;ThreeClusterBattery&gt;d__5.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
----- Inner Stack Trace -----
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100</Description>
    <Title_Description>Intermittent failures of ThreeClusterBattery test https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4079&amp;resultId=101380
&gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:21300:259343047*gcl/C/562f28b3+C@ef6312b6-&gt;S127.0.0.1:21301:259343061*grn/21E58844/4fe3f9d0@ca8917b6 #865358[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now. 
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.ClientWrapper.GetRuntimeId(Int32 i) in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 179
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;Deact&gt;d__17.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 0
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;ThreeClusterBattery&gt;d__5.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
----- Inner Stack Trace -----
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100

https://orleans.visualstudio.com/Orleans/_TestManagement/Runs?_a=resultSummary&amp;runId=4069&amp;resultId=101409
&gt;Error message
System.AggregateException : One or more errors occurred.\r\n---- Orleans.Runtime.OrleansMessageRejectionException : Forwarding failed: tried to forward message NewPlacement Request S127.0.0.1:21300:259293372*gcl/C/697540ac+C@0aecc696-&gt;S127.0.0.1:21300:259293372*grn/21E58844/6f9bb666@aee927a3 #61674[ForwardCount=2]: for 2 times after Duplicate activation to invalid activation. Rejecting now. 
Stack trace
at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.ClientWrapper.GetRuntimeId(Int32 i) in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 179
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;Deact&gt;d__17.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 0
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Tests.GeoClusterTests.TestingClusterHost.&lt;RunWithTimeout&gt;d__6.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\TestingClusterHost.cs:line 72
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.GeoClusterTests.MultiClusterRegistrationTests.&lt;ThreeClusterBattery&gt;d__5.MoveNext() in D:\build\agent\_work\18\s\test\TesterInternal\GeoClusterTests\MultiClusterRegistrationTests.cs:line 70
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
----- Inner Stack Trace -----
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext() in D:\build\agent\_work\18\s\src\Orleans.Core\Async\TaskExtensions.cs:line 100</Title_Description>
    <Label>test-issue</Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4264</IssueLabelID>
    <Title>Remove duplicate references to AdoNet.targets</Title>
    <Description>This is a follow-up to #4243.

There are currently build warnings while building `Orleans.Persistence.AdoNet/Orleans.Persistence.AdoNet.csproj` and `Orleans.Reminders.AdoNet/Orleans.Reminders.AdoNet.csproj` complaining about duplicate references to `Microsoft.Orleans.Persistence.AdoNet.targets`. This change seems to make build happy and the content files still get copied to the project folder.

@veikkoeeva Could you double-check please.</Description>
    <Title_Description>Remove duplicate references to AdoNet.targets This is a follow-up to #4243.

There are currently build warnings while building `Orleans.Persistence.AdoNet/Orleans.Persistence.AdoNet.csproj` and `Orleans.Reminders.AdoNet/Orleans.Reminders.AdoNet.csproj` complaining about duplicate references to `Microsoft.Orleans.Persistence.AdoNet.targets`. This change seems to make build happy and the content files still get copied to the project folder.

@veikkoeeva Could you double-check please.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4263</IssueLabelID>
    <Title>Support for Method Invoke Attributes on Interface to apply to all methods</Title>
    <Description>I'm running into a case where I am adding an attribute (specifically `TransactionAttribute`) to all methods on a grain interface. It would be nice to instead add the attribute to the interface and have it apply to all methods.

It looks like this would involve changing `GrainReferenceGenerator.GenerateInvokeMethods()` to generate the invoke options for the interface and then merge with individual method options into the invocation expression.

I'm happy to work on a PR for this but I wanted to get some feedback before pursuing.</Description>
    <Title_Description>Support for Method Invoke Attributes on Interface to apply to all methods I'm running into a case where I am adding an attribute (specifically `TransactionAttribute`) to all methods on a grain interface. It would be nice to instead add the attribute to the interface and have it apply to all methods.

It looks like this would involve changing `GrainReferenceGenerator.GenerateInvokeMethods()` to generate the invoke options for the interface and then merge with individual method options into the invocation expression.

I'm happy to work on a PR for this but I wanted to get some feedback before pursuing.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4260</IssueLabelID>
    <Title>What is PubSubStore for? Running one night will produce more than 140000 data</Title>
    <Description>What is PubSubStore for? Running one night will produce more than 140000 data</Description>
    <Title_Description>What is PubSubStore for? Running one night will produce more than 140,000 data What is PubSubStore for? Running one night will produce more than 140000 data</Title_Description>
    <Label>question</Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4255</IssueLabelID>
    <Title>Remove [Obsolete] attributes from most legacy types</Title>
    <Description>Fixes #4252.

I only left ` [Obsolete]` on `StatisticsWriteLogStatisticsToTable` `StatisticsProviderName` and `StatisticsWriteLogStatisticsToTable` because the underlying functionality has been removed; and on `ClientConfiguration.DeploymentId` and `GlobalConfiguration.DeploymentId` to disambiguate `DeploymentId` vs. `ClusterId`.</Description>
    <Title_Description>Remove [Obsolete] attributes from most legacy types Fixes #4252.

I only left ` [Obsolete]` on `StatisticsWriteLogStatisticsToTable` `StatisticsProviderName` and `StatisticsWriteLogStatisticsToTable` because the underlying functionality has been removed; and on `ClientConfiguration.DeploymentId` and `GlobalConfiguration.DeploymentId` to disambiguate `DeploymentId` vs. `ClusterId`.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4253</IssueLabelID>
    <Title>Fix build break by fixing GeoClusterTests</Title>
    <Description>
    </Description>
    <Title_Description>Fix build break by fixing GeoClusterTests </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4251</IssueLabelID>
    <Title>Azure Table API with Orleans rc2</Title>
    <Description>Is it possible to use persist grain state in Azure Table API or any other Azure storage? I'm trying to configure it but I haven't found any useful example. Is it ready?

I'm referring to Orleans on .net core.</Description>
    <Title_Description>Azure Table API with Orleans rc2 Is it possible to use persist grain state in Azure Table API or any other Azure storage? I'm trying to configure it but I haven't found any useful example. Is it ready?

I'm referring to Orleans on .net core.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>19/03/2018 8:59:54 PM +00:00</CreatedAt>
    <ClosedAt>3/04/2018 12:25:49 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4250</IssueLabelID>
    <Title>Question: Orleans dependencies across all assemblies.</Title>
    <Description>Question about orleans dependencies across all assemblies.

Hello! 
Perhaps this question is not the first and a little bit naive but i could not find similar issue.

http://dotnet.github.io/orleans/Tutorials/My-First-Orleans-Application.html

In you tutorial for Orleans 2.0 solution has 3 assemblies:
```
SiloHost
GrainInterfaces
GrainCollection
```
And all assemblies depend on Orleans. I mean SiloHost needs orleans to start silo.
GrainInterfaces needs IGrainWithGuidKey. 
GrainCollection classes implement interfaces stored in GrainInterfaces.


What about decouple GrainInterfaces assembly and IGrainWithGuidKey and use extension method instead of IGrainWithGuidKey:

```
services.AddOrleans(opt =&gt; 
{
   opt.AddGrain&lt;IPlayerGrain PlayerGrain&gt;(o =&gt; o.SetKey&lt;int&gt;());

   //for example default key has Guid type
   ...
})
```
?

After this call IPlayerGrain does not need to implement IGrainWithGuidKey and GrainIneterfaces assembly will be clean.</Description>
    <Title_Description>Question: Orleans dependencies across all assemblies. Question about orleans dependencies across all assemblies.

Hello! 
Perhaps this question is not the first and a little bit naive but i could not find similar issue.

http://dotnet.github.io/orleans/Tutorials/My-First-Orleans-Application.html

In you tutorial for Orleans 2.0 solution has 3 assemblies:
```
SiloHost
GrainInterfaces
GrainCollection
```
And all assemblies depend on Orleans. I mean SiloHost needs orleans to start silo.
GrainInterfaces needs IGrainWithGuidKey. 
GrainCollection classes implement interfaces stored in GrainInterfaces.


What about decouple GrainInterfaces assembly and IGrainWithGuidKey and use extension method instead of IGrainWithGuidKey:

```
services.AddOrleans(opt =&gt; 
{
   opt.AddGrain&lt;IPlayerGrain PlayerGrain&gt;(o =&gt; o.SetKey&lt;int&gt;());

   //for example default key has Guid type
   ...
})
```
?

After this call IPlayerGrain does not need to implement IGrainWithGuidKey and GrainIneterfaces assembly will be clean.</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4248</IssueLabelID>
    <Title>Orleans 2.0-rc2 - enums with GeneratedCode attribute cannot be serialized by grain client</Title>
    <Description>First off I want to be very clear that I don't see this as an issue per se.  Just FYI in case others deem this worthwhile to deal with.

My grain interfaces project referenced a common business model project with classes generated from an xml schema codegen tool adding `[System.CodeDom.Compiler.GeneratedCodeAttribute("XmlSchemaClassGenerator" "1.0.0.0")]` to each class.  This was fine with Orleans 1.5 but not with 2.0.  In 2.0 *some* types from this package with this `GeneratedCode` attribute are not serializable - particualrly enums.

Again not a real issue as it's simple enough for me to remove this attribute.  We're considering separating our silo business models from the xml generated ones anyway so I'm good.  Just posting this in case others encounter this issue or if people feel it's worth resolving.</Description>
    <Title_Description>Orleans 2.0-rc2 - enums with GeneratedCode attribute cannot be serialized by grain client First off I want to be very clear that I don't see this as an issue per se.  Just FYI in case others deem this worthwhile to deal with.

My grain interfaces project referenced a common business model project with classes generated from an xml schema codegen tool adding `[System.CodeDom.Compiler.GeneratedCodeAttribute("XmlSchemaClassGenerator" "1.0.0.0")]` to each class.  This was fine with Orleans 1.5 but not with 2.0.  In 2.0 *some* types from this package with this `GeneratedCode` attribute are not serializable - particualrly enums.

Again not a real issue as it's simple enough for me to remove this attribute.  We're considering separating our silo business models from the xml generated ones anyway so I'm good.  Just posting this in case others encounter this issue or if people feel it's worth resolving.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4247</IssueLabelID>
    <Title>How to configure Default Collection Age Limit in Orleans 2.0</Title>
    <Description>Hello
I need to configure Default Collection Age in Orleans 2.0.
Could you please tell me how can I do this?
I found this documentation but it's not for Orleans 2.0
http://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html

I think it's related to #4244 </Description>
    <Title_Description>How to configure Default Collection Age Limit in Orleans 2.0 Hello
I need to configure Default Collection Age in Orleans 2.0.
Could you please tell me how can I do this?
I found this documentation but it's not for Orleans 2.0
http://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Activation-Garbage-Collection.html

I think it's related to #4244 </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>19/03/2018 2:51:52 PM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 8:23:00 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4244</IssueLabelID>
    <Title>Is there any sample for the 2.0 configuraton?</Title>
    <Description>There is no sample no document about common orleans 2.0 configuration usage. 
UseLocalhostClustering in http://dotnet.github.io/orleans/Documentation/2.0/Configuration2.0.html is not enough</Description>
    <Title_Description>Is there any sample for the 2.0 configuraton? There is no sample no document about common orleans 2.0 configuration usage. 
UseLocalhostClustering in http://dotnet.github.io/orleans/Documentation/2.0/Configuration2.0.html is not enough</Title_Description>
    <Label>documentation</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4237</IssueLabelID>
    <Title>How to represent a database table?</Title>
    <Description>Newbie question: Suppose I have a database table and would like to expose some basic methods like Add/Update/Delete through grains.
1) Should the grain be the table or the individual rows?
2) If the table is represented with grains as individual rows how do I create a master grain that can find the right grain to update?
Thanks
</Description>
    <Title_Description>How to represent a database table? Newbie question: Suppose I have a database table and would like to expose some basic methods like Add/Update/Delete through grains.
1) Should the grain be the table or the individual rows?
2) If the table is represented with grains as individual rows how do I create a master grain that can find the right grain to update?
Thanks
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>16/03/2018 8:01:40 AM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 9:30:53 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4236</IssueLabelID>
    <Title>Use Orleans and AspNetCore or The Battle for IServiceProvider</Title>
    <Description>I opened an issue for aspnet/hosting [#1349](https://github.com/aspnet/Hosting/issues/1349) regarding dependency injection. 
The [gist ](https://gist.github.com/eisendle/b1bc2259e5d753d7d460cc27a182191e)in this issue shows the problems which arise when AspNetCore is used together withOrleans in terms of ownership of the IServiceProvider.

I have read somewhere that there will be an generic HostBuilder implementation and Orleans will switch to this new nuget package for building the SiloHost. Is this the plan?

If so I´d like to challenge this decision because the HostBuilder enforces ownership of the IServiceProvider and when using two frameworks which use HostBuilder (like in my example AspNetCore and Orleans) there is no easy way to use only one IServiceProvider.

As a result it would be difficult to use AspNetCore and Orleans together.</Description>
    <Title_Description>Use Orleans and AspNetCore or The Battle for IServiceProvider I opened an issue for aspnet/hosting [#1349](https://github.com/aspnet/Hosting/issues/1349) regarding dependency injection. 
The [gist ](https://gist.github.com/eisendle/b1bc2259e5d753d7d460cc27a182191e)in this issue shows the problems which arise when AspNetCore is used together withOrleans in terms of ownership of the IServiceProvider.

I have read somewhere that there will be an generic HostBuilder implementation and Orleans will switch to this new nuget package for building the SiloHost. Is this the plan?

If so I´d like to challenge this decision because the HostBuilder enforces ownership of the IServiceProvider and when using two frameworks which use HostBuilder (like in my example AspNetCore and Orleans) there is no easy way to use only one IServiceProvider.

As a result it would be difficult to use AspNetCore and Orleans together.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4235</IssueLabelID>
    <Title>Make providers use Cluster ID and Service ID from ClusterOptions</Title>
    <Description>Make providers use Cluster ID and Service ID from ClusterOptions.
Also fix Azure Queue SQS and GCP pubsub providers to use Service ID instead of Cluster ID.</Description>
    <Title_Description>Make providers use Cluster ID and Service ID from ClusterOptions Make providers use Cluster ID and Service ID from ClusterOptions.
Also fix Azure Queue SQS and GCP pubsub providers to use Service ID instead of Cluster ID.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4233</IssueLabelID>
    <Title>Generic interface non-generic grain causes Exception from Method property in interceptor</Title>
    <Description>The following code demonstrates an issue which occurs in `IIncomingGrainCallFilter` implementations when accessing `IGrainCallContext.Method` from a non-generic grain which is called using a generic reference. For example calling `CaterpillarGrain` below using `IHungryGrain&lt;Apple&gt;` will reproduce this issue.

```C#
public interface IHungryGrain&lt;T&gt; : IGrainWithIntegerKey
{
  Task Eat(T food);
}

public interface ICaterpillarGrain : IHungryGrain&lt;Apple&gt; { }

public class CaterpillarGrain :
  Grain
  ICaterpillarGrain
  IHungryGrain&lt;Apple&gt;
  IIncomingGrainCallFilter
{
  Task IIncomingGrainCallFilter.Invoke(IIncomingGrainCallContext ctx)
  {
    // System.InvalidOperationException: Type CaterpillarGrain does not
    // implement interface with id -1378928681 (ADCF37D7)
    Console.WriteLine(ctx.Method);
    return ctx.Invoke();
  }

  Task Eat(Apple food) =&gt; Task.CompletedTask;
}

// Causes exception:
var generic = grainFactory.GetGrain&lt;IHungryGrain&lt;Apple&gt;&gt;(0);
await generic.Eat(new Apple("Jazz"));

// No exception:
var nonGeneric = grainFactory.GetGrain&lt;ICaterpillarGrain&gt;(0);
await nonGeneric.Eat(new Apple("Jazz"));
```

Workaround: Access the grain using a non-generic interface. In the above example this is `ICaterpillarGrain`

xref: #4178</Description>
    <Title_Description>Generic interface, non-generic grain causes Exception from Method property in interceptor The following code demonstrates an issue which occurs in `IIncomingGrainCallFilter` implementations when accessing `IGrainCallContext.Method` from a non-generic grain which is called using a generic reference. For example calling `CaterpillarGrain` below using `IHungryGrain&lt;Apple&gt;` will reproduce this issue.

```C#
public interface IHungryGrain&lt;T&gt; : IGrainWithIntegerKey
{
  Task Eat(T food);
}

public interface ICaterpillarGrain : IHungryGrain&lt;Apple&gt; { }

public class CaterpillarGrain :
  Grain
  ICaterpillarGrain
  IHungryGrain&lt;Apple&gt;
  IIncomingGrainCallFilter
{
  Task IIncomingGrainCallFilter.Invoke(IIncomingGrainCallContext ctx)
  {
    // System.InvalidOperationException: Type CaterpillarGrain does not
    // implement interface with id -1378928681 (ADCF37D7)
    Console.WriteLine(ctx.Method);
    return ctx.Invoke();
  }

  Task Eat(Apple food) =&gt; Task.CompletedTask;
}

// Causes exception:
var generic = grainFactory.GetGrain&lt;IHungryGrain&lt;Apple&gt;&gt;(0);
await generic.Eat(new Apple("Jazz"));

// No exception:
var nonGeneric = grainFactory.GetGrain&lt;ICaterpillarGrain&gt;(0);
await nonGeneric.Eat(new Apple("Jazz"));
```

Workaround: Access the grain using a non-generic interface. In the above example this is `ICaterpillarGrain`

xref: #4178</Title_Description>
    <Label>bug</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4232</IssueLabelID>
    <Title>New query functionality</Title>
    <Description>@wentaowu and I are planning to add more query functionality beyond what's in http://github.com/OrleansContrib/Orleans.Indexing . We'd welcome recommendations for high-priority additions e.g. ones you had to implement in your app due to a lack of built-in Orleans support. We have two questions. First what types of query expressions are most important? For example:
 
1.	Select grains in a grain class satisfying a {&lt; ≤&gt; ≥} predicate on a property. E.g. Employee.Salary &lt; 100K. This requires adding B-trees to Orleans.Indexing which currently supports only hash indexes. 
 
2.	Top-K query over a group of grains in a grain class. E.g. top-10 players in a game grouped by game type which is a property of the game grain-type.
 
3.	Aggregate queries i.e. count sum max min average over a collection. E.g. number of devices of each device type where device type is a property of the device grain-type.
 
4.	Path queries. E.g. a list of teams that have a member M with M.Languages containing "F#" where Team is a grain-type that has a collection-valued property called Members and Member is a grain type with a collection-valued property called Languages.
 
Second over which set of grains can a query be executed? For example:
 
5.	Queries over all initialized grains of one or more grain-types where grains are mapped to persistent storage.
 
6.	Same as (5) but one or more of the grain types is not persisted.
 
7.	Queries over active grains only.  
 
8.	Queries over streams with a window function. E.g. all devices that reported a failure in the last 5 minutes.
 
9.	Materialized views. For a given query maintain its result in the face of updates to the underlying grains. E.g. a count of the number of faulty devices of each device type (which is a grain class).



</Description>
    <Title_Description>New query functionality @wentaowu and I are planning to add more query functionality beyond what's in http://github.com/OrleansContrib/Orleans.Indexing . We'd welcome recommendations for high-priority additions e.g. ones you had to implement in your app due to a lack of built-in Orleans support. We have two questions. First what types of query expressions are most important? For example:
 
1.	Select grains in a grain class satisfying a {&lt; ≤&gt; ≥} predicate on a property. E.g. Employee.Salary &lt; 100K. This requires adding B-trees to Orleans.Indexing which currently supports only hash indexes. 
 
2.	Top-K query over a group of grains in a grain class. E.g. top-10 players in a game grouped by game type which is a property of the game grain-type.
 
3.	Aggregate queries i.e. count sum max min average over a collection. E.g. number of devices of each device type where device type is a property of the device grain-type.
 
4.	Path queries. E.g. a list of teams that have a member M with M.Languages containing "F#" where Team is a grain-type that has a collection-valued property called Members and Member is a grain type with a collection-valued property called Languages.
 
Second over which set of grains can a query be executed? For example:
 
5.	Queries over all initialized grains of one or more grain-types where grains are mapped to persistent storage.
 
6.	Same as (5) but one or more of the grain types is not persisted.
 
7.	Queries over active grains only.  
 
8.	Queries over streams with a window function. E.g. all devices that reported a failure in the last 5 minutes.
 
9.	Materialized views. For a given query maintain its result in the face of updates to the underlying grains. E.g. a count of the number of faulty devices of each device type (which is a grain class).



</Title_Description>
    <Label>enhancement</Label>
    <Assignee>philbe</Assignee>
    <CreatedAt>15/03/2018 6:27:26 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4230</IssueLabelID>
    <Title>Chirper Scale Subscriber (Follower)</Title>
    <Description>Is there a limit to the number of subscribers of a publisher? Example: users with 20 million followers each. pub-sub cache in Pulling Protocol resolves this? I've seen Benchmarks in [https://www.researchgate.net/publication/233416056_Orleans_Cloud_Computing_for_Everyone](url) but the example each user only has 27 followers each. I'm having a Fan-out-on-write feed project and would like to know if this is the correct way?
Thanks
</Description>
    <Title_Description>Chirper Scale Subscriber (Follower) Is there a limit to the number of subscribers of a publisher? Example: users with 20 million followers each. pub-sub cache in Pulling Protocol resolves this? I've seen Benchmarks in [https://www.researchgate.net/publication/233416056_Orleans_Cloud_Computing_for_Everyone](url) but the example each user only has 27 followers each. I'm having a Fan-out-on-write feed project and would like to know if this is the correct way?
Thanks
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/03/2018 2:20:03 PM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 9:30:33 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4229</IssueLabelID>
    <Title>Is IServiceCollection.AddScoped seemingly invalid in Orleans?</Title>
    <Description>
    </Description>
    <Title_Description>Is IServiceCollection.AddScoped seemingly invalid in Orleans? </Title_Description>
    <Label>question</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4228</IssueLabelID>
    <Title>Fix build errors with dotnet core sdk 2.1.101</Title>
    <Description>I got some build errors after updating Visual Studio and dotnet SDK.  These changes fixed the build errors.
</Description>
    <Title_Description>Fix build errors with dotnet core sdk 2.1.101 I got some build errors after updating Visual Studio and dotnet SDK.  These changes fixed the build errors.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4227</IssueLabelID>
    <Title>Orleans.Clustering.ZooKeeper When is it released?</Title>
    <Description>
    </Description>
    <Title_Description>Orleans.Clustering.ZooKeeper When is it released? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/03/2018 7:27:31 AM +00:00</CreatedAt>
    <ClosedAt>16/03/2018 1:32:37 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4226</IssueLabelID>
    <Title>ServiceFabric :  A cluster id has not been configured BUG</Title>
    <Description>what's error with me?
how to do it?

```
var listener = OrleansServiceListener.CreateStateless(
                (serviceContext builder) =&gt;
                {
                    // Optional: use Service Fabric for cluster membership.
                     builder.UseServiceFabricClustering(serviceContext);

                    var config = new ClusterConfiguration();

                    config.Globals.ReminderServiceType = ReminderServiceProviderType.Disabled;

                    // Service Fabric manages port allocations so update the configuration using those ports.
                    builder.Configure&lt;EndpointOptions&gt;(options =&gt; {
                        options.AdvertisedIPAddress = IPAddress.Loopback;
                        options.ConfigureFromServiceContext(serviceContext);
                    });

                    builder.AddIncomingGrainCallFilter&lt;ExceptionConversionFilter&gt;();

                    // Tell Orleans to use this configuration.
                    builder.UseConfiguration(config);

                    builder.ConfigureServices(ConfigureDelegate);

                    // Add your application assemblies.
                    builder.ConfigureApplicationParts(parts =&gt;
                    {
                        // Alternative: add all loadable assemblies in the current base path (see AppDomain.BaseDirectory).
                        parts.AddFromApplicationBaseDirectory().WithCodeGeneration();
                    });
                });
```</Description>
    <Title_Description>ServiceFabric :  A cluster id has not been configured, BUG what's error with me?
how to do it?

```
var listener = OrleansServiceListener.CreateStateless(
                (serviceContext builder) =&gt;
                {
                    // Optional: use Service Fabric for cluster membership.
                     builder.UseServiceFabricClustering(serviceContext);

                    var config = new ClusterConfiguration();

                    config.Globals.ReminderServiceType = ReminderServiceProviderType.Disabled;

                    // Service Fabric manages port allocations so update the configuration using those ports.
                    builder.Configure&lt;EndpointOptions&gt;(options =&gt; {
                        options.AdvertisedIPAddress = IPAddress.Loopback;
                        options.ConfigureFromServiceContext(serviceContext);
                    });

                    builder.AddIncomingGrainCallFilter&lt;ExceptionConversionFilter&gt;();

                    // Tell Orleans to use this configuration.
                    builder.UseConfiguration(config);

                    builder.ConfigureServices(ConfigureDelegate);

                    // Add your application assemblies.
                    builder.ConfigureApplicationParts(parts =&gt;
                    {
                        // Alternative: add all loadable assemblies in the current base path (see AppDomain.BaseDirectory).
                        parts.AddFromApplicationBaseDirectory().WithCodeGeneration();
                    });
                });
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4225</IssueLabelID>
    <Title>Adding Orleans.Client to ASP.Net Core WebApi project causes a stack overflow</Title>
    <Description>Repo:
1. In VS.Net 2017 create an ASP.Net Core WebApi project then run it in debug.
2. Add Microsoft.Orlenas.Client 2.0.0-rc2 package to the project and run it again in debug.

Result:
Stack overflow error.
</Description>
    <Title_Description>Adding Orleans.Client to ASP.Net Core WebApi project causes a stack overflow Repo:
1. In VS.Net 2017 create an ASP.Net Core WebApi project then run it in debug.
2. Add Microsoft.Orlenas.Client 2.0.0-rc2 package to the project and run it again in debug.

Result:
Stack overflow error.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4222</IssueLabelID>
    <Title>Intemittent failures of ValidateGeneratedStreamsTest</Title>
    <Description>
    </Description>
    <Title_Description>Intemittent failures of ValidateGeneratedStreamsTest </Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>14/03/2018 9:19:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4221</IssueLabelID>
    <Title>Intermittent failure of  StressHandlingMultipleDelayedRequests test</Title>
    <Description>
    </Description>
    <Title_Description>Intermittent failure of  StressHandlingMultipleDelayedRequests test </Title_Description>
    <Label>test-issue</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4220</IssueLabelID>
    <Title>Intermittent failures of ControllableAdapter* tests</Title>
    <Description>ControllableAdapterEchoTest
ControllableAdapterFactoryEchoTest</Description>
    <Title_Description>Intermittent failures of ControllableAdapter* tests ControllableAdapterEchoTest
ControllableAdapterFactoryEchoTest</Title_Description>
    <Label>test-issue</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4219</IssueLabelID>
    <Title>Fix for #4129</Title>
    <Description>
    </Description>
    <Title_Description>Fix for #4129 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4218</IssueLabelID>
    <Title>One minute minimum restriction on Reminder period</Title>
    <Description>It would be useful to be able to set the minimum Reminder period to less than one minute for a handful of critical grains that may not receive messages often and that we don't want to leave deactivated for up to a minute.

One example would be a grain that primarily runs a _timer_ to perform some critical work that should ideally always be performed at intervals below a minute.

If it was possible to set the reminder to less than one minute then the _timer_ might not even be necessary if the reminder period was sufficient.

I am guessing that the one minute restriction is performance related. If so in my opinion the decision should be left to the application designer...</Description>
    <Title_Description>One minute minimum restriction on Reminder period It would be useful to be able to set the minimum Reminder period to less than one minute for a handful of critical grains that may not receive messages often and that we don't want to leave deactivated for up to a minute.

One example would be a grain that primarily runs a _timer_ to perform some critical work that should ideally always be performed at intervals below a minute.

If it was possible to set the reminder to less than one minute then the _timer_ might not even be necessary if the reminder period was sufficient.

I am guessing that the one minute restriction is performance related. If so in my opinion the decision should be left to the application designer...</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>14/03/2018 7:59:49 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4217</IssueLabelID>
    <Title>Grains on SiloA deactivated because of SiloB shutting down</Title>
    <Description>Hi there.

I've found an issue where app grains on one silo are often being deactivated because another silo shut down. This seems like a serious reliability problem to me as any grain can essentially be deactivated anywhere in the cluster at any time even though their hosting silo is not affected.

Hoping this is not expected behaviour as any grain that uses timers and does not regularly receive messages could be deactivated in this way.

It's easy to reproduce (see steps at end) and I have been able to repro in v1.5.1 and v1.5.3 using memory and azure table storage (via emulator).

Here are the entries in the log that precede the deactivation:

    [2018-03-14 05:57:13.401 GMT    10      INFO    100524  Catalog 10.1.26.61:11111]       Catalog is deactivating 11 activations due to a failure of silo S10.1.26.61:11112:258702790/x177DA9FF since it is a primary directory partition to these grain ids.
    [2018-03-14 05:57:13.407 GMT    14      INFO    103004  VirtualBucketsRingProvider      10.1.26.61:11111]       Removed Server S10.1.26.61:11112:258702790/x177DA9FF. Current view: [S10.1.26.61:11111:258702592 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]
    [2018-03-14 05:57:13.419 GMT    10      INFO    100541  Catalog 10.1.26.61:11111]       DeactivateActivations: total 11 to shutdown out of them 11 promptly 0 later when become idle and 0 are already being destroyed or invalid.
    [2018-03-14 05:57:13.425 GMT    14      INFO    103005  VirtualBucketsRingProvider      10.1.26.61:11111]       -NotifyLocalRangeSubscribers about old &lt;MultiRange: Size=x863E5CFB %Ring=52.439%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True
    [2018-03-14 05:57:13.442 GMT    10      INFO    100503  Catalog 10.1.26.61:11111]       Starting DestroyActivations #0 of 11 activations
    [2018-03-14 05:57:13.447 GMT    14      INFO    100612  MembershipOracle        10.1.26.61:11111]   Will watch (actively ping) 0 silos: []
    [2018-03-14 05:57:13.447 GMT    13      INFO    102934  Orleans.Runtime.ReminderService.LocalReminderService    10.1.26.61:11111]    My range changed from &lt;MultiRange: Size=x863E5CFB %Ring=52.439%&gt; to &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased = True
    [2018-03-14 05:57:13.476 GMT     8      ERROR   -1      OrleansTest.PubSubGrain ]       !!!!!!!!!! PubSubGrain on silo S10.1.26.61:11111:258702592 being deactivated because of shutdown of another silo!

The last error above is being logged by me in OnDeactivateAsync() of the grain that should not be deactivated. It was created on the initial silo and requests delayed deactivation in OnActivateAsync().

I've attached a simple project that makes it easy to repro and debug by following these steps:
* Open OrleansTest.sln in VS 2017 build and update the debug executable to the OrleansHost.exe in the bin/Debug directory.
* Start the Azure Storage Emulator. Alternatively rename the included OrleansConfiguration_memorystorage.xml and OrleansConfiguration2_memorystorage.xml files to OrleansConfiguration.xml and OrleansConfiguration2.xml respectively.
* Start Debug session.
* Wait for first silo to start successfully and for one of the messages to be logged e.g. "Processing message 'some message' in grain ..."
* Open command line in bin/Debug directory.
*## Start the second silo by executing "OrleansHost.exe SecondSilo OrleansConfiguration2.xml".
* Wait for this second silo to start logging "Processing message 'some message' in grain ...". This indicates that a grain on the second silo is also now receiving messages.
* Press Ctrl+C to stop second silo.
* About 60% of the time the grain sending the messages (which started on the first silo) will be shut down because of the second silo being stopped. The other 40% of the time the grains on the second silo will be activated on the first silo and everything continues working as expected.
* If the incorrect deactivation does not occur just keep repeating from step *## above and it will happen.

Thanks.

[OrleansDeactivationRepro.zip](https://github.com/dotnet/orleans/files/1809832/OrleansDeactivationRepro.zip)
</Description>
    <Title_Description>Grains on SiloA deactivated because of SiloB shutting down Hi there.

I've found an issue where app grains on one silo are often being deactivated because another silo shut down. This seems like a serious reliability problem to me as any grain can essentially be deactivated anywhere in the cluster at any time even though their hosting silo is not affected.

Hoping this is not expected behaviour as any grain that uses timers and does not regularly receive messages could be deactivated in this way.

It's easy to reproduce (see steps at end) and I have been able to repro in v1.5.1 and v1.5.3 using memory and azure table storage (via emulator).

Here are the entries in the log that precede the deactivation:

    [2018-03-14 05:57:13.401 GMT    10      INFO    100524  Catalog 10.1.26.61:11111]       Catalog is deactivating 11 activations due to a failure of silo S10.1.26.61:11112:258702790/x177DA9FF since it is a primary directory partition to these grain ids.
    [2018-03-14 05:57:13.407 GMT    14      INFO    103004  VirtualBucketsRingProvider      10.1.26.61:11111]       Removed Server S10.1.26.61:11112:258702790/x177DA9FF. Current view: [S10.1.26.61:11111:258702592 -&gt; &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt;]
    [2018-03-14 05:57:13.419 GMT    10      INFO    100541  Catalog 10.1.26.61:11111]       DeactivateActivations: total 11 to shutdown out of them 11 promptly 0 later when become idle and 0 are already being destroyed or invalid.
    [2018-03-14 05:57:13.425 GMT    14      INFO    103005  VirtualBucketsRingProvider      10.1.26.61:11111]       -NotifyLocalRangeSubscribers about old &lt;MultiRange: Size=x863E5CFB %Ring=52.439%&gt; new &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased? True
    [2018-03-14 05:57:13.442 GMT    10      INFO    100503  Catalog 10.1.26.61:11111]       Starting DestroyActivations #0 of 11 activations
    [2018-03-14 05:57:13.447 GMT    14      INFO    100612  MembershipOracle        10.1.26.61:11111]   Will watch (actively ping) 0 silos: []
    [2018-03-14 05:57:13.447 GMT    13      INFO    102934  Orleans.Runtime.ReminderService.LocalReminderService    10.1.26.61:11111]    My range changed from &lt;MultiRange: Size=x863E5CFB %Ring=52.439%&gt; to &lt;MultiRange: Size=x100000000 %Ring=100.000%&gt; increased = True
    [2018-03-14 05:57:13.476 GMT     8      ERROR   -1      OrleansTest.PubSubGrain ]       !!!!!!!!!! PubSubGrain on silo S10.1.26.61:11111:258702592 being deactivated because of shutdown of another silo!

The last error above is being logged by me in OnDeactivateAsync() of the grain that should not be deactivated. It was created on the initial silo and requests delayed deactivation in OnActivateAsync().

I've attached a simple project that makes it easy to repro and debug by following these steps:
* Open OrleansTest.sln in VS 2017 build and update the debug executable to the OrleansHost.exe in the bin/Debug directory.
* Start the Azure Storage Emulator. Alternatively rename the included OrleansConfiguration_memorystorage.xml and OrleansConfiguration2_memorystorage.xml files to OrleansConfiguration.xml and OrleansConfiguration2.xml respectively.
* Start Debug session.
* Wait for first silo to start successfully and for one of the messages to be logged e.g. "Processing message 'some message' in grain ..."
* Open command line in bin/Debug directory.
*## Start the second silo by executing "OrleansHost.exe SecondSilo OrleansConfiguration2.xml".
* Wait for this second silo to start logging "Processing message 'some message' in grain ...". This indicates that a grain on the second silo is also now receiving messages.
* Press Ctrl+C to stop second silo.
* About 60% of the time the grain sending the messages (which started on the first silo) will be shut down because of the second silo being stopped. The other 40% of the time the grains on the second silo will be activated on the first silo and everything continues working as expected.
* If the incorrect deactivation does not occur just keep repeating from step *## above and it will happen.

Thanks.

[OrleansDeactivationRepro.zip](https://github.com/dotnet/orleans/files/1809832/OrleansDeactivationRepro.zip)
</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>14/03/2018 6:30:39 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4213</IssueLabelID>
    <Title>Intermittent failures of InterSiloClientCancellationTokenPassing test</Title>
    <Description>**Error message**
System.Exception : Could not make requested grains placement

**Stack trace**
&gt;at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;GetGrains&gt;d__16`1.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 194
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;ClientGrainGrainTokenPassing&gt;d__14.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 161
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;InterSiloClientCancellationTokenPassing&gt;d__12.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 147
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
    <Title_Description>Intermittent failures of InterSiloClientCancellationTokenPassing test **Error message**
System.Exception : Could not make requested grains placement

**Stack trace**
&gt;at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;GetGrains&gt;d__16`1.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 194
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;ClientGrainGrainTokenPassing&gt;d__14.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 161
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at UnitTests.CancellationTests.GrainCancellationTokenTests.&lt;InterSiloClientCancellationTokenPassing&gt;d__12.MoveNext() in D:\build\agent\_work\18\s\test\Tester\CancellationTests\GrainCancellationTokenTests.cs:line 147
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/03/2018 6:20:43 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4211</IssueLabelID>
    <Title>Fix validator ordering</Title>
    <Description>Fix #4203 

The issue is that `SiloClusteringValidator` get `IMembershipOracle` and `IMembershipTable` from DI and they require themselves a lot of other components in DI...

So if this validator is called before the validators from the options used in these membership constructors it will fail without a good error message.

I think we should move these "advanced" check in the silo startup to avoid any trouble in the future but for now it should fix the issue.</Description>
    <Title_Description>Fix validator ordering Fix #4203 

The issue is that `SiloClusteringValidator` get `IMembershipOracle` and `IMembershipTable` from DI and they require themselves a lot of other components in DI...

So if this validator is called before the validators from the options used in these membership constructors it will fail without a good error message.

I think we should move these "advanced" check in the silo startup to avoid any trouble in the future but for now it should fix the issue.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4210</IssueLabelID>
    <Title>ISiloHostBuilder.UseLocalhostClustering with primarySiloEndpoint set to null throw exception</Title>
    <Description>The doc says:
```
 /// &lt;param name="primarySiloEndpoint"&gt;
 /// The endpoint of the primary silo or &lt;see langword="null"/&gt; to use this silo as the primary.
 /// &lt;/param&gt;
```

But then the silo fails to start with:

&gt; Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 8000 ---&gt; Orleans.Runtime.OrleansConfigurationException: &gt; DevelopmentClusterMembershipOptions.PrimarySiloEndpoint must be set when using development clustering.
</Description>
    <Title_Description>ISiloHostBuilder.UseLocalhostClustering with primarySiloEndpoint set to null throw exception The doc says:
```
 /// &lt;param name="primarySiloEndpoint"&gt;
 /// The endpoint of the primary silo or &lt;see langword="null"/&gt; to use this silo as the primary.
 /// &lt;/param&gt;
```

But then the silo fails to start with:

&gt; Orleans.Runtime.OrleansLifecycleCanceledException: Lifecycle start canceled due to errors at stage 8000 ---&gt; Orleans.Runtime.OrleansConfigurationException: &gt; DevelopmentClusterMembershipOptions.PrimarySiloEndpoint must be set when using development clustering.
</Title_Description>
    <Label>bug</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4207</IssueLabelID>
    <Title>[2.0 RC2] Ado.Net reminders provider is broken in RC2</Title>
    <Description>After upgrade to RC2 I have exception when using Ado.Net reminders provider. I configure it as:

```
        .UseAdoNetReminderService(options =&gt;
         {
                 options.ConnectionString = ConnectionString;
                 options.Invariant = "System.Data.SqlClient";
          })
```

and on `_siloHost = builder.Build();` I got: 
```
Orleans.Runtime.OrleansConfigurationException
  HResult=0x80131500
  Message=Invalid AdoNetReminderTableOptions values for AdoNetReminderTable. Invariant is required.
  Source=Orleans.Reminders.AdoNet
  StackTrace:
   at Orleans.Configuration.AdoNetReminderTableOptionsValidator.ValidateConfiguration()
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
   at Orleans.Hosting.SiloHostBuilder.Build()
   at &lt;....&gt;.Orleans.Start() in &lt;....&gt;\Orelans.cs:line 53
   at &lt;....&gt;.Program.Service.Start() in &lt;....&gt;\Program.cs:line 28
   at &lt;....&gt;.Program.&lt;&gt;c.&lt;Main&gt;b__1_3(Service tc) in &lt;....&gt;\Program.cs:line 53
   at Topshelf.ServiceConfiguratorExtensions.&lt;&gt;c__DisplayClass2_0`1.&lt;WhenStarted&gt;b__0(T service HostControl control)
   at Topshelf.Builders.DelegateServiceBuilder`1.DelegateServiceHandle.Start(HostControl hostControl)
   at Topshelf.Hosts.ConsoleRunHost.Run()

```
</Description>
    <Title_Description>[2.0 RC2] Ado.Net reminders provider is broken in RC2 After upgrade to RC2 I have exception when using Ado.Net reminders provider. I configure it as:

```
        .UseAdoNetReminderService(options =&gt;
         {
                 options.ConnectionString = ConnectionString;
                 options.Invariant = "System.Data.SqlClient";
          })
```

and on `_siloHost = builder.Build();` I got: 
```
Orleans.Runtime.OrleansConfigurationException
  HResult=0x80131500
  Message=Invalid AdoNetReminderTableOptions values for AdoNetReminderTable. Invariant is required.
  Source=Orleans.Reminders.AdoNet
  StackTrace:
   at Orleans.Configuration.AdoNetReminderTableOptionsValidator.ValidateConfiguration()
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
   at Orleans.Hosting.SiloHostBuilder.Build()
   at &lt;....&gt;.Orleans.Start() in &lt;....&gt;\Orelans.cs:line 53
   at &lt;....&gt;.Program.Service.Start() in &lt;....&gt;\Program.cs:line 28
   at &lt;....&gt;.Program.&lt;&gt;c.&lt;Main&gt;b__1_3(Service tc) in &lt;....&gt;\Program.cs:line 53
   at Topshelf.ServiceConfiguratorExtensions.&lt;&gt;c__DisplayClass2_0`1.&lt;WhenStarted&gt;b__0(T service HostControl control)
   at Topshelf.Builders.DelegateServiceBuilder`1.DelegateServiceHandle.Start(HostControl hostControl)
   at Topshelf.Hosts.ConsoleRunHost.Run()

```
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4206</IssueLabelID>
    <Title>Orleans.OrleansCodeGenerator.Build Failed to execute</Title>
    <Description>![image](https://user-images.githubusercontent.com/28291464/37336461-67e10050-26ec-11e8-8746-aa2eb16bb703.png)
</Description>
    <Title_Description>Orleans.OrleansCodeGenerator.Build Failed to execute ![image](https://user-images.githubusercontent.com/28291464/37336461-67e10050-26ec-11e8-8746-aa2eb16bb703.png)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4205</IssueLabelID>
    <Title>[2.0 RC2 ]recommends IServiceCollection.AddIncomingGrainCallFilter to restore Public</Title>
    <Description>@ReubenBond 

2.0 RC2 `IServiceCollection.AddIncomingGrainCallFilter` is recommended to restore Public because  `IServiceCollection ` is required to intercept component configuration when developing components but 2.0RC2 cannot use `IServiceCollection ` when configuring `AddIncomingGrainCallFilter.`</Description>
    <Title_Description>[2.0 RC2 ]recommends IServiceCollection.AddIncomingGrainCallFilter to restore Public @ReubenBond 

2.0 RC2 `IServiceCollection.AddIncomingGrainCallFilter` is recommended to restore Public because  `IServiceCollection ` is required to intercept component configuration when developing components but 2.0RC2 cannot use `IServiceCollection ` when configuring `AddIncomingGrainCallFilter.`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4203</IssueLabelID>
    <Title>NullReferenceException if EndpointOptions.AdvertisedIPAddress is not specified</Title>
    <Description>The following test fails with a `NullReferenceException` when the `AdvertisedIPAddress` line is commented out.

```C#
[Fact]
public void SiloHostBuilder_MinimalConfigurationTest()
{
    var builder = new SiloHostBuilder()
        //.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
        .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = "test")
        .ConfigureServices(services =&gt; services.AddSingleton&lt;IMembershipTable NoOpMembershipTable&gt;());
    using (var silo = builder.Build())
    {
        Assert.NotNull(silo);
    }
}
```

```
Test Name:	NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest
Test FullName:	NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest
Test Source:	C:\dev\orleans4\test\NonSilo.Tests\SiloHostBuilderTests.cs : line 67
Test Outcome:	Failed
Test Duration:	0:00:07.035

Result StackTrace:	
at System.Net.IPEndPoint..ctor(IPAddress address Int32 port)
   at Orleans.Hosting.EndpointOptionsExtensions.GetPublicSiloEndpoint(EndpointOptions options) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\EndpointOptionsExtensions.cs:line 85
   at Orleans.Runtime.LocalSiloDetails.&lt;&gt;c__DisplayClass2_0.&lt;.ctor&gt;b__0() in C:\dev\orleans4\src\Orleans.Runtime\Silo\LocalSiloDetails.cs:line 24
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at Orleans.Runtime.LocalSiloDetails.get_SiloAddress() in C:\dev\orleans4\src\Orleans.Runtime\Silo\LocalSiloDetails.cs:line 38
   at Orleans.Runtime.GrainTypeManager..ctor(ILocalSiloDetails siloDetails IApplicationPartManager applicationPartManager PlacementStrategy defaultPlacementStrategy SerializationManager serializationManager MultiClusterRegistrationStrategyManager multiClusterRegistrationStrategyManager ILogger`1 logger IOptions`1 grainClassOptions) in C:\dev\orleans4\src\Orleans.Runtime\GrainTypeManager\GrainTypeManager.cs:line 51
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
   at Orleans.Hosting.DefaultSiloServices.&lt;&gt;c.&lt;AddDefaultServices&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\DefaultSiloServices.cs:line 98
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Core\Configuration\ServiceCollectionExtensions.cs:line 28
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Core\Configuration\ServiceCollectionExtensions.cs:line 28
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
   at Orleans.Runtime.Configuration.SiloClusteringValidator.ValidateConfiguration() in C:\dev\orleans4\src\Orleans.Runtime\Configuration\Validators\SiloClusteringValidator.cs:line 32
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 161
   at Orleans.Hosting.SiloHostBuilder.Build() in C:\dev\orleans4\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 51
   at NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest() in C:\dev\orleans4\test\NonSilo.Tests\SiloHostBuilderTests.cs:line 72
Result Message:	
System.ArgumentNullException : Value cannot be null.
Parameter name: address
```</Description>
    <Title_Description>NullReferenceException if EndpointOptions.AdvertisedIPAddress is not specified The following test fails with a `NullReferenceException` when the `AdvertisedIPAddress` line is commented out.

```C#
[Fact]
public void SiloHostBuilder_MinimalConfigurationTest()
{
    var builder = new SiloHostBuilder()
        //.Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
        .Configure&lt;ClusterOptions&gt;(options =&gt; options.ClusterId = "test")
        .ConfigureServices(services =&gt; services.AddSingleton&lt;IMembershipTable NoOpMembershipTable&gt;());
    using (var silo = builder.Build())
    {
        Assert.NotNull(silo);
    }
}
```

```
Test Name:	NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest
Test FullName:	NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest
Test Source:	C:\dev\orleans4\test\NonSilo.Tests\SiloHostBuilderTests.cs : line 67
Test Outcome:	Failed
Test Duration:	0:00:07.035

Result StackTrace:	
at System.Net.IPEndPoint..ctor(IPAddress address Int32 port)
   at Orleans.Hosting.EndpointOptionsExtensions.GetPublicSiloEndpoint(EndpointOptions options) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\EndpointOptionsExtensions.cs:line 85
   at Orleans.Runtime.LocalSiloDetails.&lt;&gt;c__DisplayClass2_0.&lt;.ctor&gt;b__0() in C:\dev\orleans4\src\Orleans.Runtime\Silo\LocalSiloDetails.cs:line 24
   at System.Lazy`1.CreateValue()
   at System.Lazy`1.LazyInitValue()
   at Orleans.Runtime.LocalSiloDetails.get_SiloAddress() in C:\dev\orleans4\src\Orleans.Runtime\Silo\LocalSiloDetails.cs:line 38
   at Orleans.Runtime.GrainTypeManager..ctor(ILocalSiloDetails siloDetails IApplicationPartManager applicationPartManager PlacementStrategy defaultPlacementStrategy SerializationManager serializationManager MultiClusterRegistrationStrategyManager multiClusterRegistrationStrategyManager ILogger`1 logger IOptions`1 grainClassOptions) in C:\dev\orleans4\src\Orleans.Runtime\GrainTypeManager\GrainTypeManager.cs:line 51
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
   at Orleans.Hosting.DefaultSiloServices.&lt;&gt;c.&lt;AddDefaultServices&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\DefaultSiloServices.cs:line 98
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Core\Configuration\ServiceCollectionExtensions.cs:line 28
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
   at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp) in C:\dev\orleans4\src\Orleans.Core\Configuration\ServiceCollectionExtensions.cs:line 28
   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProvider.&lt;&gt;c__DisplayClass22_0.&lt;RealizeService&gt;b__0(ServiceProvider provider)
   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
   at Orleans.Runtime.Configuration.SiloClusteringValidator.ValidateConfiguration() in C:\dev\orleans4\src\Orleans.Runtime\Configuration\Validators\SiloClusteringValidator.cs:line 32
   at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider) in C:\dev\orleans4\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 161
   at Orleans.Hosting.SiloHostBuilder.Build() in C:\dev\orleans4\src\Orleans.Runtime\Hosting\Generic\SiloHostBuilder.cs:line 51
   at NonSilo.Tests.SiloHostBuilderTests.SiloHostBuilder_MinimalConfigurationTest() in C:\dev\orleans4\test\NonSilo.Tests\SiloHostBuilderTests.cs:line 72
Result Message:	
System.ArgumentNullException : Value cannot be null.
Parameter name: address
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4202</IssueLabelID>
    <Title>How does Orleans unit test? Is there an instance or document?</Title>
    <Description>How does Orleans unit test? Is there an instance or document?</Description>
    <Title_Description>How does Orleans unit test? Is there an instance or document? How does Orleans unit test? Is there an instance or document?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/03/2018 2:30:09 AM +00:00</CreatedAt>
    <ClosedAt>14/03/2018 6:20:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4201</IssueLabelID>
    <Title>Bboyle1234 shutdowndocs</Title>
    <Description>
    </Description>
    <Title_Description>Bboyle1234 shutdowndocs </Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/03/2018 1:23:41 AM +00:00</CreatedAt>
    <ClosedAt>21/03/2018 11:38:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4200</IssueLabelID>
    <Title>Gateways route system target calls correctly - test</Title>
    <Description>Added test demonstrating that system target calls are not routed correctly from the client.  The test demonstrates this by showing persistent streams fail to work when Gateways are not defined on every silo.</Description>
    <Title_Description>Gateways route system target calls correctly - test Added test demonstrating that system target calls are not routed correctly from the client.  The test demonstrates this by showing persistent streams fail to work when Gateways are not defined on every silo.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4198</IssueLabelID>
    <Title>Streaming questions</Title>
    <Description>This is not an issue but questions. The answers could be useful for a streaming FAQ:

- For ImplicitStreamSubscriptions there is a great amount of housekeeping that the developer must do to subscribe to its own stream and unsubscribe resume and such. Can it be enhanced to a degree to get these done by the runtime and not by the developer? It is easy to miss and there is no sample code on how to do streaming (right).

- Streaming implementation does not fan out to all subscribers but calling and awaiting them one-by-one (if not fire and forget specified). For me fire and forget is a misleading name but documentation states what it does. Perhaps getting all the ```Task```s then doing a ```Task.WhenAll``` would be better. I did not see the possible reasoning behind this is there one?

- Am I right that the serialization of the ```OnNext``` payload happens for every subscriber and not just once? For multiple subscribers it could be a great overhead.</Description>
    <Title_Description>Streaming questions This is not an issue but questions. The answers could be useful for a streaming FAQ:

- For ImplicitStreamSubscriptions there is a great amount of housekeeping that the developer must do to subscribe to its own stream and unsubscribe resume and such. Can it be enhanced to a degree to get these done by the runtime and not by the developer? It is easy to miss and there is no sample code on how to do streaming (right).

- Streaming implementation does not fan out to all subscribers but calling and awaiting them one-by-one (if not fire and forget specified). For me fire and forget is a misleading name but documentation states what it does. Perhaps getting all the ```Task```s then doing a ```Task.WhenAll``` would be better. I did not see the possible reasoning behind this is there one?

- Am I right that the serialization of the ```OnNext``` payload happens for every subscriber and not just once? For multiple subscribers it could be a great overhead.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>12/03/2018 10:57:18 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4197</IssueLabelID>
    <Title>Grain could stuck until timeout when stream subscriber is not reachable (disconnected)</Title>
    <Description>Problem:
I'm facing a streaming issue. I configured a SimpleMessageStream with Memory storage for pubsub. I'm having a simple client who instantiates a Grain invoking a method on it and inside the method the Grain calls ```OnNext``` on the stream to notify the subscribers of a state change.

If the client does not call ```UnsubscribeAsync``` before exiting then on the next run any call to the same Grain would timeout since the Grain is still "executing" the previous ```OnNext``` call.

It seems that client disconnection is not wiping out all the related data for that client like subscription handles.

Solution:
a. When a client disconnects all related data like subscription handles should be removed "immediately".
b. Check out why an ```OnNext``` to a disconnected client making the client stuck why is there a wait for the timeout. Since client socket does not exists so that remote callback to the client should fail much faster.

The error I saw in the console:
```
Runtime.Scheduler.WorkerPoolThread/5[101212]
      Worker pool thread Runtime.Scheduler.WorkerPoolThread/5 (ManagedThreadId=31) has been busy for long time: Executing Task Id=1 Status=Running for 00:05:00.1723371 on WorkItem=System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Running Executing for 00:05:00.1729365. WorkItemGroup Details: System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=4; Total processed=3; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-1:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S127.0.0.1:11111:258443880*stg/20/00000014@S00000014] CurrentlyExecuting=null&gt;.
```
</Description>
    <Title_Description>Grain could stuck until timeout, when stream subscriber is not reachable (disconnected) Problem:
I'm facing a streaming issue. I configured a SimpleMessageStream with Memory storage for pubsub. I'm having a simple client who instantiates a Grain invoking a method on it and inside the method the Grain calls ```OnNext``` on the stream to notify the subscribers of a state change.

If the client does not call ```UnsubscribeAsync``` before exiting then on the next run any call to the same Grain would timeout since the Grain is still "executing" the previous ```OnNext``` call.

It seems that client disconnection is not wiping out all the related data for that client like subscription handles.

Solution:
a. When a client disconnects all related data like subscription handles should be removed "immediately".
b. Check out why an ```OnNext``` to a disconnected client making the client stuck why is there a wait for the timeout. Since client socket does not exists so that remote callback to the client should fail much faster.

The error I saw in the console:
```
Runtime.Scheduler.WorkerPoolThread/5[101212]
      Worker pool thread Runtime.Scheduler.WorkerPoolThread/5 (ManagedThreadId=31) has been busy for long time: Executing Task Id=1 Status=Running for 00:05:00.1723371 on WorkItem=System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Running Executing for 00:05:00.1729365. WorkItemGroup Details: System*WorkItemGroup:Name=*stg/20/00000014WorkGroupStatus=Running. Currently QueuedWorkItems=0; Total EnQueued=4; Total processed=3; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-1:Queued=0; Detailed SchedulingContext=&lt;[SystemTarget: S127.0.0.1:11111:258443880*stg/20/00000014@S00000014] CurrentlyExecuting=null&gt;.
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4196</IssueLabelID>
    <Title>Silo should validate if a PubSubStore is configured or not before starting</Title>
    <Description>Issue:
When you setup the streaming but not adding a storage with the baked in name of "PubSubStore" the Silo starts without errors and then later when it needs to access the store to persist a subscription it fails during runtime.

Solution:
Add additional validation if a "PubSubStore" is registered in DI or not. If not fail early with configuration exception.

Nice to have:
Make "PubSubStore" provider name configurable
</Description>
    <Title_Description>Silo should validate if a PubSubStore is configured or not before starting Issue:
When you setup the streaming but not adding a storage with the baked in name of "PubSubStore" the Silo starts without errors and then later when it needs to access the store to persist a subscription it fails during runtime.

Solution:
Add additional validation if a "PubSubStore" is registered in DI or not. If not fail early with configuration exception.

Nice to have:
Make "PubSubStore" provider name configurable
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4189</IssueLabelID>
    <Title>Removing a grain interface from the project fails the build</Title>
    <Description>How to reproduce:

1. Create a new project for grain interfaces
2. Reference `Microsoft.Orleans.OrleansCodeGenerator.Build` `2.0.0-rc1` and `Microsoft.Orleans.Runtime.Abstractions` `2.0.0-rc1`
3. Add two grain interfaces
4. Build the project so that the code will be generated
5. Remove one interface and rebuild the project
6. Build fails with the following output
```
1&gt;------ Rebuild All started: Project: DMCTS.GrainInterfaces Configuration: Debug Any CPU ------
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(1930519317): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(8719287204): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(2012720139): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;Done building project "DMCTS.GrainInterfaces.csproj" -- FAILED.
========== Rebuild All: 0 succeeded 1 failed 0 skipped ==========
```

Deleting `obj` directory helps.
</Description>
    <Title_Description>Removing a grain interface from the project fails the build How to reproduce:

1. Create a new project for grain interfaces
2. Reference `Microsoft.Orleans.OrleansCodeGenerator.Build` `2.0.0-rc1` and `Microsoft.Orleans.Runtime.Abstractions` `2.0.0-rc1`
3. Add two grain interfaces
4. Build the project so that the code will be generated
5. Remove one interface and rebuild the project
6. Build fails with the following output
```
1&gt;------ Rebuild All started: Project: DMCTS.GrainInterfaces Configuration: Debug Any CPU ------
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(1930519317): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(8719287204): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;obj\Debug\netcoreapp2.0\DMCTS.GrainInterfaces.orleans.g.cs(2012720139): error CS0234: The type or namespace name 'ITreeGrainV2' does not exist in the namespace 'DMCTS.GrainInterfaces' (are you missing an assembly reference?)
1&gt;Done building project "DMCTS.GrainInterfaces.csproj" -- FAILED.
========== Rebuild All: 0 succeeded 1 failed 0 skipped ==========
```

Deleting `obj` directory helps.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4188</IssueLabelID>
    <Title>System.TypeAccessException: Named type "..." is invalid: Type string "..." cannot be resolved.</Title>
    <Description>I believe I encounter a bug. It seems Orleans doesn't work well with generic type that is located in another project. Could be related to #4012 
I've prepared a minimal repro project for the case: https://github.com/alexandrnikitin/orleans-repro-4188

To reproduce:

```
cd \samples\GoogleHashcode2018
&gt;BuildAndRun.ps1
```
Observe Client console app output. The following exception appears:

```
System.AggregateException: One or more errors occurred. (Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.) ---&gt; System.TypeAccessException: Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReferenceRuntime.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at Rides.Client.Program.&lt;DoClientWork&gt;d__3.MoveNext() in C:\projects\my\DistributedMonteCarloTreeSearch.NET\samples\GoogleHashcode2018\Rides.Client\Program.cs:line 81
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Rides.Client.Program.&lt;RunMainAsync&gt;d__1.MoveNext() in C:\projects\my\DistributedMonteCarloTreeSearch.NET\samples\GoogleHashcode2018\Rides.Client\Program.cs:line 26
---&gt; (Inner Exception #0) System.TypeAccessException: Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReferenceRuntime.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()&lt;---
```</Description>
    <Title_Description>System.TypeAccessException: Named type "..." is invalid: Type string "..." cannot be resolved. I believe I encounter a bug. It seems Orleans doesn't work well with generic type that is located in another project. Could be related to #4012 
I've prepared a minimal repro project for the case: https://github.com/alexandrnikitin/orleans-repro-4188

To reproduce:

```
cd \samples\GoogleHashcode2018
&gt;BuildAndRun.ps1
```
Observe Client console app output. The following exception appears:

```
System.AggregateException: One or more errors occurred. (Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.) ---&gt; System.TypeAccessException: Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReferenceRuntime.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at Rides.Client.Program.&lt;DoClientWork&gt;d__3.MoveNext() in C:\projects\my\DistributedMonteCarloTreeSearch.NET\samples\GoogleHashcode2018\Rides.Client\Program.cs:line 81
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Rides.Client.Program.&lt;RunMainAsync&gt;d__1.MoveNext() in C:\projects\my\DistributedMonteCarloTreeSearch.NET\samples\GoogleHashcode2018\Rides.Client\Program.cs:line 26
---&gt; (Inner Exception #0) System.TypeAccessException: Named type "DMCTS.Grains.NodeView`1&lt;Rides.MakeRideAction&gt;" is invalid: Type string "Rides.MakeRideAction" cannot be resolved.
   at Orleans.Serialization.BinaryTokenStreamReaderExtensinons.ReadSpecifiedTypeHeader(IBinaryTokenStreamReader this SerializationManager serializationManager)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.BuiltInTypes.DeserializeOrleansResponse(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.Deserialize(Type t IBinaryTokenStreamReader stream)
   at Orleans.Runtime.Message.GetDeserializedBody(SerializationManager serializationManager)
   at Orleans.Runtime.GrainReferenceRuntime.ResponseCallback(Message message TaskCompletionSource`1 context)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()&lt;---
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4187</IssueLabelID>
    <Title>Search grains by value in state. Is it possible?</Title>
    <Description>I have a problem I need to find all grains with a certain value in their state.
For example a grain in a state has a variable IsOnline and I would like to get a list of all such grains.
Now I'm doing this with queries in the repository (I'm using CosmosDB) but maybe there is a better way?</Description>
    <Title_Description>Search grains by value in state. Is it possible? I have a problem I need to find all grains with a certain value in their state.
For example a grain in a state has a variable IsOnline and I would like to get a list of all such grains.
Now I'm doing this with queries in the repository (I'm using CosmosDB) but maybe there is a better way?</Title_Description>
    <Label>question</Label>
    <Assignee>philbe</Assignee>
    <CreatedAt>12/03/2018 10:19:31 AM +00:00</CreatedAt>
    <ClosedAt>13/03/2018 4:44:27 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4186</IssueLabelID>
    <Title>Problems using `Microsoft.Orleans.TestingHost` in a separate .NET Core console app</Title>
    <Description>I want to use the Test Cluster in a separate console app so I create one and reference the latest `2.0.0-rc1` `Microsoft.Orleans.TestingHost`.

```
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
    &lt;RuntimeFrameworkVersion&gt;2.0.5&lt;/RuntimeFrameworkVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Orleans.TestingHost" Version="2.0.0-rc1" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

```

```
using Orleans.TestingHost;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var host = new TestClusterBuilder(1).Build();
            host.Deploy();
        }
    }
}
```

Launching it throws the following exception:

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Extensions.Configuration.Abstractions Version=2.0.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'. The system cannot find the file specified.
```

I install the latest `2.1.0-preview1-final` `Microsoft.Extensions.Configuration.Binder` package (which is referenced by `Microsoft.Orleans.TestingHost`)
```
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="2.1.0-preview1-final" /&gt;
```

Then it throws this:

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
```

I install all direct latest dependencies of `Microsoft.Orleans.TestingHost`

```
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="2.1.0-preview1-final" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansProviders" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.TestingHost" Version="2.0.0-rc1" /&gt;
  &lt;/ItemGroup&gt;

```
It prints starting messages and throws `System.TypeLoadException`:

```
----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------
Starting a new silo in app domain Primary


Unhandled Exception: System.TypeLoadException: Could not load type 'System.AppDomainSetup' from assembly 'mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089'.
```

The same happens if I have references to Grain interfaces and Grains library projects from that console app. What am I doing wrong?</Description>
    <Title_Description>Problems using `Microsoft.Orleans.TestingHost` in a separate .NET Core console app I want to use the Test Cluster in a separate console app so I create one and reference the latest `2.0.0-rc1` `Microsoft.Orleans.TestingHost`.

```
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
    &lt;RuntimeFrameworkVersion&gt;2.0.5&lt;/RuntimeFrameworkVersion&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Orleans.TestingHost" Version="2.0.0-rc1" /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

```

```
using Orleans.TestingHost;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            var host = new TestClusterBuilder(1).Build();
            host.Deploy();
        }
    }
}
```

Launching it throws the following exception:

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'Microsoft.Extensions.Configuration.Abstractions Version=2.0.0.0 Culture=neutral PublicKeyToken=adb9793829ddae60'. The system cannot find the file specified.
```

I install the latest `2.1.0-preview1-final` `Microsoft.Extensions.Configuration.Binder` package (which is referenced by `Microsoft.Orleans.TestingHost`)
```
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="2.1.0-preview1-final" /&gt;
```

Then it throws this:

```
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'Orleans.Core Version=2.0.0.0 Culture=neutral PublicKeyToken=null'. The system cannot find the file specified.
```

I install all direct latest dependencies of `Microsoft.Orleans.TestingHost`

```
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="2.1.0-preview1-final" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Core" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansProviders" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.0-rc1" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.TestingHost" Version="2.0.0-rc1" /&gt;
  &lt;/ItemGroup&gt;

```
It prints starting messages and throws `System.TypeLoadException`:

```
----------------------------- STARTING NEW UNIT TEST SILO HOST: Orleans.TestingHost.TestCluster -------------------------------------
Starting a new silo in app domain Primary


Unhandled Exception: System.TypeLoadException: Could not load type 'System.AppDomainSetup' from assembly 'mscorlib Version=4.0.0.0 Culture=neutral PublicKeyToken=b77a5c561934e089'.
```

The same happens if I have references to Grain interfaces and Grains library projects from that console app. What am I doing wrong?</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4184</IssueLabelID>
    <Title>Correct way to add GrainCallFilter</Title>
    <Description>The extension methods `AddGrainCallFilter` are marked as obsolete but after https://github.com/dotnet/orleans/pull/4091 the methods they say to use instead have been made internal.

Should either remove obsolete designation put other methods back to public or create and link to a desired implementation.</Description>
    <Title_Description>Correct way to add GrainCallFilter The extension methods `AddGrainCallFilter` are marked as obsolete but after https://github.com/dotnet/orleans/pull/4091 the methods they say to use instead have been made internal.

Should either remove obsolete designation put other methods back to public or create and link to a desired implementation.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>9/03/2018 8:14:13 PM +00:00</CreatedAt>
    <ClosedAt>9/03/2018 10:11:46 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4180</IssueLabelID>
    <Title>Set GrainService.Status to Started in the base implementation of StartInBackground()</Title>
    <Description>Fixes #4128.
This should help prevent mistakes of not setting the status to started which leads to not receiving cluster repartitioning notifications.</Description>
    <Title_Description>Set GrainService.Status to Started in the base implementation of StartInBackground() Fixes #4128.
This should help prevent mistakes of not setting the status to started which leads to not receiving cluster repartitioning notifications.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4179</IssueLabelID>
    <Title>Pkg Check Always change.</Title>
    <Description>Reference Microsoft.Orleans.OrleansCodeGenerator.Build

Unable to incrementally upgrade

pkg Check Always change.

2018-03-09t08:35:21.7251126z Searching for application packages: C:VSTSAgentWork219aapplicationpackage
2018-03-09t08:35:21.8161145z Find application Package: C:VSTSAgentWork219aapplicationpackage
2018-03-09t08:35:21.8431113z version value: ". 20180309.9"
2018-03-09t08:35:22.0131140z Previous build Number: "20180309.8"
2018-03-09T08:35:22.6151082Z Downloading Project "Drop" ...
2018-03-09t08:35:33.8640326z Progress Update: 786426 bytes Received ...
2018-03-09t08:35:45.0289523z Progress Update: 1572858 bytes Received ...
2018-03-09t08:35:50.9359148z has completed the download Project "Drop".
2018-03-09t08:36:23.1906931z Progress Update: 2146297 bytes Received ...
2018-03-09t08:36:23.2056934z Previous build location: "C:VSTSAgentWorktmpdrop"
2018-03-09T08:36:23.2056934Z is searching for changes to the application type ' Jobapptype ' ...
2018-03-09t08:36:23.3666896z is searching for changes to the service "statelessdenormalizerservicepkg" ...
2018-03-09T08:36:23.4136911Z is searching for a change in package ' Code ' ...
2018-03-09T08:36:43.2015585Z is searching for package "Config" for changes ...
2018-03-09T08:36:43.5135588Z is searching for changes to the service "statelesscommandservicepkg" ...
2018-03-09t08:36:43.5205567z is searching for a change in package ' Code ' ...
# **2018-03-09t08:36:46.9865323z changed the file "Labor.job.commandhandler.dll".**
2018-03-09t08:37:03.1944208z updates the package "Statelesscommandservicepkgcode" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".
2018-03-09T08:37:03.2044209Z is searching for package "Config" for changes ...
2018-03-09T08:37:03.3584199Z has changed the service manifest.
2018-03-09t08:37:03.3594197z updates the service "statelesscommandservicepkg" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".
2018-03-09T08:37:03.3944184Z has changed the application manifest. 2018-03-09t08:37:03.3954176z updates the application type "Jobapptype" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".


</Description>
    <Title_Description>Pkg Check Always change. Reference Microsoft.Orleans.OrleansCodeGenerator.Build

Unable to incrementally upgrade

pkg Check Always change.

2018-03-09t08:35:21.7251126z Searching for application packages: C:VSTSAgentWork219aapplicationpackage
2018-03-09t08:35:21.8161145z Find application Package: C:VSTSAgentWork219aapplicationpackage
2018-03-09t08:35:21.8431113z version value: ". 20180309.9"
2018-03-09t08:35:22.0131140z Previous build Number: "20180309.8"
2018-03-09T08:35:22.6151082Z Downloading Project "Drop" ...
2018-03-09t08:35:33.8640326z Progress Update: 786426 bytes Received ...
2018-03-09t08:35:45.0289523z Progress Update: 1572858 bytes Received ...
2018-03-09t08:35:50.9359148z has completed the download Project "Drop".
2018-03-09t08:36:23.1906931z Progress Update: 2146297 bytes Received ...
2018-03-09t08:36:23.2056934z Previous build location: "C:VSTSAgentWorktmpdrop"
2018-03-09T08:36:23.2056934Z is searching for changes to the application type ' Jobapptype ' ...
2018-03-09t08:36:23.3666896z is searching for changes to the service "statelessdenormalizerservicepkg" ...
2018-03-09T08:36:23.4136911Z is searching for a change in package ' Code ' ...
2018-03-09T08:36:43.2015585Z is searching for package "Config" for changes ...
2018-03-09T08:36:43.5135588Z is searching for changes to the service "statelesscommandservicepkg" ...
2018-03-09t08:36:43.5205567z is searching for a change in package ' Code ' ...
# **2018-03-09t08:36:46.9865323z changed the file "Labor.job.commandhandler.dll".**
2018-03-09t08:37:03.1944208z updates the package "Statelesscommandservicepkgcode" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".
2018-03-09T08:37:03.2044209Z is searching for package "Config" for changes ...
2018-03-09T08:37:03.3584199Z has changed the service manifest.
2018-03-09t08:37:03.3594197z updates the service "statelesscommandservicepkg" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".
2018-03-09T08:37:03.3944184Z has changed the application manifest. 2018-03-09t08:37:03.3954176z updates the application type "Jobapptype" from version "1.0.0.20180309.8" to "1.0.0.20180309.9".


</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4178</IssueLabelID>
    <Title>Can I use Grain like this?</Title>
    <Description>![image](https://user-images.githubusercontent.com/28291464/37198769-5a20d380-23ba-11e8-88e9-557e8e4a09fd.png)
![image](https://user-images.githubusercontent.com/28291464/37198881-bb6d189c-23ba-11e8-86fe-5f0573c13d8d.png)

`  var ta = await ser.GetMessage1(name);`  error when executing：

![image](https://user-images.githubusercontent.com/28291464/37198458-4d0c3d34-23b9-11e8-9e97-9bb7fccdb9cf.png)


If you change  `ITest1Service&lt;TTest&gt;`  to  `ITest1Service`

Don't know if the above example is not allowed or have other problems?</Description>
    <Title_Description>Can I use Grain like this? ![image](https://user-images.githubusercontent.com/28291464/37198769-5a20d380-23ba-11e8-88e9-557e8e4a09fd.png)
![image](https://user-images.githubusercontent.com/28291464/37198881-bb6d189c-23ba-11e8-86fe-5f0573c13d8d.png)

`  var ta = await ser.GetMessage1(name);`  error when executing：

![image](https://user-images.githubusercontent.com/28291464/37198458-4d0c3d34-23b9-11e8-9e97-9bb7fccdb9cf.png)


If you change  `ITest1Service&lt;TTest&gt;`  to  `ITest1Service`

Don't know if the above example is not allowed or have other problems?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4174</IssueLabelID>
    <Title>When Silo shutdown Grain deactivation is happening too late in the lifecycle</Title>
    <Description>Silo will accept new activation in the `Active` state but will deactivate its grain activation only at stage `RuntimeServices` which is happening after the `ApplicationServices` state.

It will cause issue if the grain implementation rely on a component that is dependant on the `ApplicationServices` state (like storage providers...)</Description>
    <Title_Description>When Silo shutdown, Grain deactivation is happening too late in the lifecycle Silo will accept new activation in the `Active` state but will deactivate its grain activation only at stage `RuntimeServices` which is happening after the `ApplicationServices` state.

It will cause issue if the grain implementation rely on a component that is dependant on the `ApplicationServices` state (like storage providers...)</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4170</IssueLabelID>
    <Title>protobuf-net serializer</Title>
    <Description>Hey considering using [protobuf-net](https://github.com/mgravell/protobuf-net) since it's so easy to use as opposed to the code-generation approach (imo). Thought this might be a nice addition here.</Description>
    <Title_Description>protobuf-net serializer Hey considering using [protobuf-net](https://github.com/mgravell/protobuf-net) since it's so easy to use as opposed to the code-generation approach (imo). Thought this might be a nice addition here.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4169</IssueLabelID>
    <Title>Revert "Improved transparancy and timing of silo lifecycle. (#4116)"</Title>
    <Description>This reverts commit 3a7b5710a2b2f7bc250e15ccb48a47dd8dcb57ec. It broke some functional tests.</Description>
    <Title_Description>Revert "Improved transparancy and timing of silo lifecycle. (#4116)" This reverts commit 3a7b5710a2b2f7bc250e15ccb48a47dd8dcb57ec. It broke some functional tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4168</IssueLabelID>
    <Title>RequestContext not available in next operation</Title>
    <Description>We have a Grain that uses the RequestContext to pass along the user information. When we use the same Grain instance twice in our calling code the second call no longer has access to the RequestContext which seems normal since it (the second operation) is completed on another thread. However it would seem to me that the RequestContext should be migrated to the new thread or am I completely missing the point?
Should every Grain instance be used only once? Likely refetching the instance would resolve the issue (not tested will try this out later).

Client:
RequestContext.Set("User" User.Id);
var grain = ClusterClient.GetGrain&lt;OurGrain&gt;();
grain.Operation1();
grain.Operation2();

OurGrain:
Operation1():
RequestContext.Get("User") =&gt; Fine

Operation2():
RequestContext.Get("User") =&gt; null</Description>
    <Title_Description>RequestContext not available in next operation We have a Grain that uses the RequestContext to pass along the user information. When we use the same Grain instance twice in our calling code the second call no longer has access to the RequestContext which seems normal since it (the second operation) is completed on another thread. However it would seem to me that the RequestContext should be migrated to the new thread or am I completely missing the point?
Should every Grain instance be used only once? Likely refetching the instance would resolve the issue (not tested will try this out later).

Client:
RequestContext.Set("User" User.Id);
var grain = ClusterClient.GetGrain&lt;OurGrain&gt;();
grain.Operation1();
grain.Operation2();

OurGrain:
Operation1():
RequestContext.Get("User") =&gt; Fine

Operation2():
RequestContext.Get("User") =&gt; null</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>8/03/2018 11:06:29 AM +00:00</CreatedAt>
    <ClosedAt>12/03/2018 9:02:09 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4167</IssueLabelID>
    <Title>Will the 2.0RC version of the cluster how to configure?</Title>
    <Description>Will the 2.0RC version of the cluster how to configure?</Description>
    <Title_Description>Will the 2.0RC version of the cluster how to configure? Will the 2.0RC version of the cluster how to configure?</Title_Description>
    <Label>question</Label>
    <Assignee>lfzm</Assignee>
    <CreatedAt>8/03/2018 7:49:08 AM +00:00</CreatedAt>
    <ClosedAt>12/03/2018 1:25:09 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4163</IssueLabelID>
    <Title>Client is not initialized. Current client state is Created.</Title>
    <Description>ServiceFabric RunAsync Finish : 
protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            // Creat the client and connect to the cluster.
            GrainFactory.PayQuery = GrainFactory.CreateFromFabricClient("fabric:/PayApp/StatelessQueryService");

            await GrainFactory.PayQuery.ConnectAsync();

        }

</Description>
    <Title_Description>Client is not initialized. Current client state is Created. ServiceFabric RunAsync Finish : 
protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            // Creat the client and connect to the cluster.
            GrainFactory.PayQuery = GrainFactory.CreateFromFabricClient("fabric:/PayApp/StatelessQueryService");

            await GrainFactory.PayQuery.ConnectAsync();

        }

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4162</IssueLabelID>
    <Title>Fix legacy configuration</Title>
    <Description>Fix implicit overriding of cluster ID in legacy membership configuration.</Description>
    <Title_Description>Fix legacy configuration Fix implicit overriding of cluster ID in legacy membership configuration.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4159</IssueLabelID>
    <Title>Throw on Build if ClusterId is not set on silo/client</Title>
    <Description>
    </Description>
    <Title_Description>Throw on Build if ClusterId is not set on silo/client </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4158</IssueLabelID>
    <Title>Dns.GetHostAddressesAsync failure preventing Silo start</Title>
    <Description>I'm getting the following stack trace when attempting to start a silo. I believe the cause is the default value for `AdvertisedIPAddress` in `EndpointOptions`. I'm trying to run the silo (rc1)  in an AWS Fargate (managed container service) task. I can try to troubleshoot the underlying error more but I'm pretty sure I'll need to set the `AdvertisedIPAddress` manually anyways so having the default specified in a different manner (as suggested in https://github.com/dotnet/orleans/issues/4115) may make more sense.

```
Unhandled Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.AggregateException: One or more errors occurred. (No such device or address) ---&gt; System.Net.Internals.SocketExceptionFactory+ExtendedSocketException: No such device or address
at System.Net.Dns.InternalGetHostByName(String hostName Boolean includeIPv6)
at System.Net.Dns.ResolveCallback(Object context)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
at System.Net.Dns.EndGetHostAddresses(IAsyncResult asyncResult)
at System.Net.Dns.&lt;&gt;c.&lt;GetHostAddressesAsync&gt;b__25_1(IAsyncResult asyncResult)
at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Configuration.ConfigUtilities.&lt;ResolveIPAddress&gt;d__18.MoveNext()
--- End of inner exception stack trace ---
at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
at Orleans.Configuration.EndpointOptions..ctor()
--- End of inner exception stack trace ---
at System.RuntimeTypeHandle.CreateInstance(RuntimeType type Boolean publicOnly Boolean&amp; canBeCached RuntimeMethodHandleInternal&amp; ctor)
at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly Boolean skipCheckThis Boolean fillCache StackCrawlMark&amp; stackMark)
at System.Activator.CreateInstance[T]()
at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name)
at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)
at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication Boolean useDefaultConstructor)
at System.Lazy`1.CreateValue()
at Orleans.Runtime.LocalSiloDetails..ctor(IOptions`1 siloOptions IOptions`1 clusterOptions IOptions`1 siloEndpointOptions)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
at Orleans.Runtime.Configuration.SiloClusteringValidator.ValidateConfiguration()
at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
at Orleans.Hosting.SiloHostBuilder.Build()
```</Description>
    <Title_Description>Dns.GetHostAddressesAsync failure preventing Silo start I'm getting the following stack trace when attempting to start a silo. I believe the cause is the default value for `AdvertisedIPAddress` in `EndpointOptions`. I'm trying to run the silo (rc1)  in an AWS Fargate (managed container service) task. I can try to troubleshoot the underlying error more but I'm pretty sure I'll need to set the `AdvertisedIPAddress` manually anyways so having the default specified in a different manner (as suggested in https://github.com/dotnet/orleans/issues/4115) may make more sense.

```
Unhandled Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.AggregateException: One or more errors occurred. (No such device or address) ---&gt; System.Net.Internals.SocketExceptionFactory+ExtendedSocketException: No such device or address
at System.Net.Dns.InternalGetHostByName(String hostName Boolean includeIPv6)
at System.Net.Dns.ResolveCallback(Object context)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Net.Dns.HostResolutionEndHelper(IAsyncResult asyncResult)
at System.Net.Dns.EndGetHostAddresses(IAsyncResult asyncResult)
at System.Net.Dns.&lt;&gt;c.&lt;GetHostAddressesAsync&gt;b__25_1(IAsyncResult asyncResult)
at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar Func`2 endFunction Action`1 endAction Task`1 promise Boolean requiresSynchronization)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Orleans.Runtime.Configuration.ConfigUtilities.&lt;ResolveIPAddress&gt;d__18.MoveNext()
--- End of inner exception stack trace ---
at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
at Orleans.Configuration.EndpointOptions..ctor()
--- End of inner exception stack trace ---
at System.RuntimeTypeHandle.CreateInstance(RuntimeType type Boolean publicOnly Boolean&amp; canBeCached RuntimeMethodHandleInternal&amp; ctor)
at System.RuntimeType.CreateInstanceSlow(Boolean publicOnly Boolean skipCheckThis Boolean fillCache StackCrawlMark&amp; stackMark)
at System.Activator.CreateInstance[T]()
at Microsoft.Extensions.Options.OptionsFactory`1.Create(String name)
at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)
at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication Boolean useDefaultConstructor)
at System.Lazy`1.CreateValue()
at Orleans.Runtime.LocalSiloDetails..ctor(IOptions`1 siloOptions IOptions`1 clusterOptions IOptions`1 siloEndpointOptions)
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitConstructor(ConstructorCallSite constructorCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider Type serviceType)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService[T](IServiceProvider provider)
at Orleans.Configuration.ServiceCollectionExtensions.&lt;&gt;c__0`2.&lt;AddFromExisting&gt;b__0_1(IServiceProvider sp)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver.VisitScoped(ScopedCallSite scopedCallSite ServiceProvider provider)
at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)
at Orleans.Runtime.Configuration.SiloClusteringValidator.ValidateConfiguration()
at Orleans.Hosting.SiloHostBuilder.ValidateSystemConfiguration(IServiceProvider serviceProvider)
at Orleans.Hosting.SiloHostBuilder.Build()
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4157</IssueLabelID>
    <Title>Lifecycle participant - is it working correctly?</Title>
    <Description>This is a lifecycle participant intended to run `OnStart` before any grains are activate and `OnStop` after all grains are deactivated.

It seems to correctly run `OnStart` before any grains are activated but it seems to **incorrectly** run `OnStop` before the grains are deactivated.

```
    public interface ILocalSiloClusterClientProvider {
        IClusterClient Client { get; }
    }

    public class LocalSiloClusterClientProvider : ILifecycleParticipant&lt;ISiloLifecycle&gt; ILocalSiloClusterClientProvider {

        readonly Action&lt;ClientBuilder&gt; ConfigureClientBuilder;

        public IClusterClient Client { get; private set; }

        public LocalSiloClusterClientProvider(Action&lt;ClientBuilder&gt; configureClientBuilder) {
            ConfigureClientBuilder = configureClientBuilder;
        }

        public void Participate(ISiloLifecycle lifecycle) {
            lifecycle.Subscribe(ServiceLifecycleStage.ApplicationServices OnStart OnStop);
        }

        async Task OnStart(CancellationToken token) {
            var clientBuilder = new ClientBuilder();
            ConfigureClientBuilder?.Invoke(clientBuilder);
            Client = clientBuilder.Build();
            await Client.Connect();
        }

        async Task OnStop(CancellationToken token) {
            await Client.Close();
            Client.Dispose();
        }
    }

    public static class LocalSiloClusterClientProviderExtensions {
        public static ISiloHostBuilder AddLocalSiloClusterClientProvider(this ISiloHostBuilder builder Action&lt;ClientBuilder&gt; clientBuilder) {
            return builder.ConfigureServices(services =&gt; {
                services.AddSingleton&lt;ILocalSiloClusterClientProvider LocalSiloClusterClientProvider&gt;(serviceProvider =&gt; new LocalSiloClusterClientProvider(clientBuilder));
                services.Add(new ServiceDescriptor(typeof(ILifecycleParticipant&lt;ISiloLifecycle&gt;) sp =&gt; sp.GetRequiredService&lt;ILocalSiloClusterClientProvider&gt;() services.Last().Lifetime));
            });
        }
    }
```
The service is injected on the SiloBuilder with the following code: 

```
    .AddLocalSiloClusterClientProvider(clientBuilder =&gt; clientBuilder
            .ConfigureCluster(options =&gt; options.ClusterId = MyGrainConfiguration.ClusterId)
            .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IInstrumentGrain).Assembly).WithReferences())
            .UseStaticClustering(options =&gt; { options.Gateways.Add(new IPEndPoint(IPAddress.Loopback MyGrainConfiguration.GatewayPort).ToGatewayUri()); }))
```

Silo shutdown is initiated via `await Silo.StopAsync()` while running in a dot net core 2.0 console app after the user presses Ctrl+C.

Silo is also configured with `.Configure&lt;ProcessExitHandlingOptions&gt;(options =&gt; options.FastKillOnProcessExit = false)`


```
            Console.CancelKeyPress += (s a) =&gt; {
                a.Cancel = true;
                Task.Run(StopSilo);
            };

        static async Task StopSilo() {
            await silo.StopAsync();
            _siloStopped.Set(); // a manual reset event that allows 'Main' to finish up
        }
```</Description>
    <Title_Description>Lifecycle participant - is it working correctly? This is a lifecycle participant intended to run `OnStart` before any grains are activate and `OnStop` after all grains are deactivated.

It seems to correctly run `OnStart` before any grains are activated but it seems to **incorrectly** run `OnStop` before the grains are deactivated.

```
    public interface ILocalSiloClusterClientProvider {
        IClusterClient Client { get; }
    }

    public class LocalSiloClusterClientProvider : ILifecycleParticipant&lt;ISiloLifecycle&gt; ILocalSiloClusterClientProvider {

        readonly Action&lt;ClientBuilder&gt; ConfigureClientBuilder;

        public IClusterClient Client { get; private set; }

        public LocalSiloClusterClientProvider(Action&lt;ClientBuilder&gt; configureClientBuilder) {
            ConfigureClientBuilder = configureClientBuilder;
        }

        public void Participate(ISiloLifecycle lifecycle) {
            lifecycle.Subscribe(ServiceLifecycleStage.ApplicationServices OnStart OnStop);
        }

        async Task OnStart(CancellationToken token) {
            var clientBuilder = new ClientBuilder();
            ConfigureClientBuilder?.Invoke(clientBuilder);
            Client = clientBuilder.Build();
            await Client.Connect();
        }

        async Task OnStop(CancellationToken token) {
            await Client.Close();
            Client.Dispose();
        }
    }

    public static class LocalSiloClusterClientProviderExtensions {
        public static ISiloHostBuilder AddLocalSiloClusterClientProvider(this ISiloHostBuilder builder Action&lt;ClientBuilder&gt; clientBuilder) {
            return builder.ConfigureServices(services =&gt; {
                services.AddSingleton&lt;ILocalSiloClusterClientProvider LocalSiloClusterClientProvider&gt;(serviceProvider =&gt; new LocalSiloClusterClientProvider(clientBuilder));
                services.Add(new ServiceDescriptor(typeof(ILifecycleParticipant&lt;ISiloLifecycle&gt;) sp =&gt; sp.GetRequiredService&lt;ILocalSiloClusterClientProvider&gt;() services.Last().Lifetime));
            });
        }
    }
```
The service is injected on the SiloBuilder with the following code: 

```
    .AddLocalSiloClusterClientProvider(clientBuilder =&gt; clientBuilder
            .ConfigureCluster(options =&gt; options.ClusterId = MyGrainConfiguration.ClusterId)
            .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(IInstrumentGrain).Assembly).WithReferences())
            .UseStaticClustering(options =&gt; { options.Gateways.Add(new IPEndPoint(IPAddress.Loopback MyGrainConfiguration.GatewayPort).ToGatewayUri()); }))
```

Silo shutdown is initiated via `await Silo.StopAsync()` while running in a dot net core 2.0 console app after the user presses Ctrl+C.

Silo is also configured with `.Configure&lt;ProcessExitHandlingOptions&gt;(options =&gt; options.FastKillOnProcessExit = false)`


```
            Console.CancelKeyPress += (s a) =&gt; {
                a.Cancel = true;
                Task.Run(StopSilo);
            };

        static async Task StopSilo() {
            await silo.StopAsync();
            _siloStopped.Set(); // a manual reset event that allows 'Main' to finish up
        }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4155</IssueLabelID>
    <Title>Improve how grain services are registered</Title>
    <Description>Remove service ID as a configurable argument as 0 is currently hardcoded.
Add a silo builder extension method for registering grain services.
Update and extend tests to cover both the legacy way and the new way of handling of grain services.</Description>
    <Title_Description>Improve how grain services are registered Remove service ID as a configurable argument as 0 is currently hardcoded.
Add a silo builder extension method for registering grain services.
Update and extend tests to cover both the legacy way and the new way of handling of grain services.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4154</IssueLabelID>
    <Title>Some 2.0 samples are in 1.x directory</Title>
    <Description>I foudn this samples located in wrong directory:
https://github.com/dotnet/orleans/tree/master/Samples/1.x/FSharp.NetCore
https://github.com/dotnet/orleans/tree/master/Samples/1.x/Orleans-Docker
https://github.com/dotnet/orleans/tree/master/Samples/1.x/Docker-Simple</Description>
    <Title_Description>Some 2.0 samples are in 1.x directory I foudn this samples located in wrong directory:
https://github.com/dotnet/orleans/tree/master/Samples/1.x/FSharp.NetCore
https://github.com/dotnet/orleans/tree/master/Samples/1.x/Orleans-Docker
https://github.com/dotnet/orleans/tree/master/Samples/1.x/Docker-Simple</Title_Description>
    <Label>Hacktoberfest</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>7/03/2018 10:57:53 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4153</IssueLabelID>
    <Title>Documentation: Garbage collection in dotnet core app</Title>
    <Description>Consider including something like this in the article about garbage collection

A dotnet core app will give this warning at startup: 
```
warn: Orleans.Runtime.Silo[100405]
      Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
warn: Orleans.Runtime.Silo[100405]
      Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
```

Fix it by adding this to the `.csproj` file:
```
  &lt;!--- Configure garbage collection "just right" for orleans: http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html --&gt;
  &lt;PropertyGroup&gt;
    &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
    &lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt;
  &lt;/PropertyGroup&gt;
```

The warning will persist when running the app from the Visual Studio debugger but will disappear after a publish eg
```
dotnet publish myapp -o publish
dotnet publish/myapp.dll
```</Description>
    <Title_Description>Documentation: Garbage collection in dotnet core app Consider including something like this in the article about garbage collection

A dotnet core app will give this warning at startup: 
```
warn: Orleans.Runtime.Silo[100405]
      Note: Silo not running with ServerGC turned on - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt;
warn: Orleans.Runtime.Silo[100405]
      Note: ServerGC only kicks in on multi-core systems (settings enabling ServerGC have no effect on single-core machines).
```

Fix it by adding this to the `.csproj` file:
```
  &lt;!--- Configure garbage collection "just right" for orleans: http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html --&gt;
  &lt;PropertyGroup&gt;
    &lt;ServerGarbageCollection&gt;true&lt;/ServerGarbageCollection&gt;
    &lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt;
  &lt;/PropertyGroup&gt;
```

The warning will persist when running the app from the Visual Studio debugger but will disappear after a publish eg
```
dotnet publish myapp -o publish
dotnet publish/myapp.dll
```</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4151</IssueLabelID>
    <Title>Interesting shutdown behaviour</Title>
    <Description>Repo to reproduce observations
https://github.com/bboyle1234/OrleansSiloShutdownIssue

# OrleansSiloShutdownIssue

An interesting investigation of console app shutdown behaviour. Now that I've come this far with the experiment it looks like it may have nothing to do with Orleans itself. 

If the `Console.CancelKeyPressed` event handler returns before the `static void Main(string[] args)` method returns the console app hangs.

In this project the Orleans silo shutdown triggers `_siloShutdownEvent.Set()`. The two methods mentioned above are waiting on that event before they can return. If there are no `Thread.Sleep(100)` statements in the code it's a random race to the finish. When `Main` finishes first the program exits gracefully. When `Console.CancelKeyPress` finishes first the program hangs.

I've added a bool flag that you can change to determine the race winner so you can see both outcomes. 

Either way Orleans emits the following warning: 

```
warn: Orleans.Runtime.Catalog[100502]
      UnregisterManyAsync 1 failed.
System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;FinishDestroyActivations&gt;d__76.MoveNext()
warn: Orleans.Runtime.Catalog[100502]
      UnregisterManyAsync 2 failed.
System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
```
</Description>
    <Title_Description>Interesting shutdown behaviour Repo to reproduce observations
https://github.com/bboyle1234/OrleansSiloShutdownIssue

# OrleansSiloShutdownIssue

An interesting investigation of console app shutdown behaviour. Now that I've come this far with the experiment it looks like it may have nothing to do with Orleans itself. 

If the `Console.CancelKeyPressed` event handler returns before the `static void Main(string[] args)` method returns the console app hangs.

In this project the Orleans silo shutdown triggers `_siloShutdownEvent.Set()`. The two methods mentioned above are waiting on that event before they can return. If there are no `Thread.Sleep(100)` statements in the code it's a random race to the finish. When `Main` finishes first the program exits gracefully. When `Console.CancelKeyPress` finishes first the program hangs.

I've added a bool flag that you can change to determine the race winner so you can see both outcomes. 

Either way Orleans emits the following warning: 

```
warn: Orleans.Runtime.Catalog[100502]
      UnregisterManyAsync 1 failed.
System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Scheduler.AsyncClosureWorkItem.&lt;Execute&gt;d__8.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Runtime.Catalog.&lt;FinishDestroyActivations&gt;d__76.MoveNext()
warn: Orleans.Runtime.Catalog[100502]
      UnregisterManyAsync 2 failed.
System.InvalidOperationException: Grain directory is stopping
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.CheckIfShouldForward(GrainId grainId Int32 hopCount String operationDescription)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.UnregisterOrPutInForwardList(IEnumerable`1 addresses UnregistrationCause cause Int32 hopCount Dictionary`2&amp; forward List`1 tasks String context)
   at Orleans.Runtime.GrainDirectory.LocalGrainDirectory.&lt;UnregisterManyAsync&gt;d__107.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
```
</Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>7/03/2018 5:40:28 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4150</IssueLabelID>
    <Title>Silo hang while shutdown</Title>
    <Description>Since 2.0 beta shutdown isn't being properly handled. It never call grain services stream providers storage Shutdown()/Close() methods.

While trying to debug the issue several of those NRE happens and the silo hang:

```

'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Globalization.dll'. Cannot find or open the PDB file.
Exception thrown: 'System.NullReferenceException' in Orleans.Core.dll
Exception thrown: 'System.NullReferenceException' in System.Private.CoreLib.dll
Exception thrown: 'System.NullReferenceException' in System.Private.CoreLib.dll
'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Diagnostics.StackTrace.dll'. Cannot find or open the PDB file.
'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Reflection.Metadata.dll'. Cannot find or open the PDB file.
Exception thrown: 'System.Net.Sockets.SocketException' in System.Net.Sockets.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.Threading.Tasks.TaskCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
```

If I enable Orleans debug I can see it breaks on this exception:

![image](https://user-images.githubusercontent.com/4714040/37073886-50d12e06-21a8-11e8-8b33-86fd12c9bb80.png)

And this one:

![image](https://user-images.githubusercontent.com/4714040/37073897-62fbdf4a-21a8-11e8-9c38-07908e5ecbce.png)

After that the silo hangs in a state that it never shutdown but is not active either as new activations nor stream messages are being processed. Funny enough the dump of statistics and Activation Collection is printed on the console as if it were running.
</Description>
    <Title_Description>Silo hang while shutdown Since 2.0 beta shutdown isn't being properly handled. It never call grain services stream providers storage Shutdown()/Close() methods.

While trying to debug the issue several of those NRE happens and the silo hang:

```

'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Globalization.dll'. Cannot find or open the PDB file.
Exception thrown: 'System.NullReferenceException' in Orleans.Core.dll
Exception thrown: 'System.NullReferenceException' in System.Private.CoreLib.dll
Exception thrown: 'System.NullReferenceException' in System.Private.CoreLib.dll
'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Diagnostics.StackTrace.dll'. Cannot find or open the PDB file.
'dotnet.exe' (CoreCLR: clrhost): Loaded 'C:\Program Files\dotnet\shared\Microsoft.NETCore.App\2.0.5\System.Reflection.Metadata.dll'. Cannot find or open the PDB file.
Exception thrown: 'System.Net.Sockets.SocketException' in System.Net.Sockets.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.ArgumentNullException' in System.Private.CoreLib.dll
Exception thrown: 'System.Threading.Tasks.TaskCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.OperationCanceledException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
Exception thrown: 'System.OperationCanceledException' in System.Private.CoreLib.dll
Exception thrown: 'System.InvalidOperationException' in System.Collections.Concurrent.dll
```

If I enable Orleans debug I can see it breaks on this exception:

![image](https://user-images.githubusercontent.com/4714040/37073886-50d12e06-21a8-11e8-8b33-86fd12c9bb80.png)

And this one:

![image](https://user-images.githubusercontent.com/4714040/37073897-62fbdf4a-21a8-11e8-9c38-07908e5ecbce.png)

After that the silo hangs in a state that it never shutdown but is not active either as new activations nor stream messages are being processed. Funny enough the dump of statistics and Activation Collection is printed on the console as if it were running.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4149</IssueLabelID>
    <Title>Silos start running timer</Title>
    <Description>What to do when the silo starts running the timer，Not through the client call

 public class Test: Orleans.Grain
    {
        public void TestTime()
        {
            Console.WriteLine("get..");
            TimeSpan t1 = TimeSpan.FromSeconds(10);
            base.RegisterTimer(OnClientRefreshTimer null t1 - TimeSpan.FromSeconds(2) t1);
        }

        private async Task OnClientRefreshTimer(object data)
        {
            Console.WriteLine("write");
        }
    }</Description>
    <Title_Description>Silos start running timer What to do when the silo starts running the timer，Not through the client call

 public class Test: Orleans.Grain
    {
        public void TestTime()
        {
            Console.WriteLine("get..");
            TimeSpan t1 = TimeSpan.FromSeconds(10);
            base.RegisterTimer(OnClientRefreshTimer null t1 - TimeSpan.FromSeconds(2) t1);
        }

        private async Task OnClientRefreshTimer(object data)
        {
            Console.WriteLine("write");
        }
    }</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>7/03/2018 3:11:07 AM +00:00</CreatedAt>
    <ClosedAt>12/03/2018 3:13:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4145</IssueLabelID>
    <Title>Rename MembershipOptions to ClusteringOptions</Title>
    <Description>Rename `MembershipOptions` to `ClusteringOptions` and `DevelopmentMembershipOptions` to `DevelopmentClusteringOptions`.</Description>
    <Title_Description>Rename MembershipOptions to ClusteringOptions Rename `MembershipOptions` to `ClusteringOptions` and `DevelopmentMembershipOptions` to `DevelopmentClusteringOptions`.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4144</IssueLabelID>
    <Title>Silo Host Could not load file or assembly for 3rd party libraries used in Grain implementation project</Title>
    <Description>Silo Host Could not load file or assembly for 3rd party libraries used in Grain implementation project.
For ex. I'm using NuGet package -&gt; Microsoft.Store.PartnerCenter Version=1.7.0.0 in Grain implementation project (targets .net framework 4.7.1) and the SiloHost project (targets .netstandard2.0) has -&gt; Microsoft.Store.PartnerCenter.dll in bin folder(SiloHostProject\bin\Debug\netcoreapp2.0) but it throws an exception -&gt; Could not load file or assembly.</Description>
    <Title_Description>Silo Host Could not load file or assembly for 3rd party libraries used in Grain implementation project Silo Host Could not load file or assembly for 3rd party libraries used in Grain implementation project.
For ex. I'm using NuGet package -&gt; Microsoft.Store.PartnerCenter Version=1.7.0.0 in Grain implementation project (targets .net framework 4.7.1) and the SiloHost project (targets .netstandard2.0) has -&gt; Microsoft.Store.PartnerCenter.dll in bin folder(SiloHostProject\bin\Debug\netcoreapp2.0) but it throws an exception -&gt; Could not load file or assembly.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4137</IssueLabelID>
    <Title>Interceptor use problems？？？</Title>
    <Description>Use interceptors to do permission verification return insufficient rights message the client can not receive the message because the message can not be converted is there any solution?

![image](https://user-images.githubusercontent.com/28291464/37013715-7e9d3950-2136-11e8-8aab-38216d202968.png)
</Description>
    <Title_Description>Interceptor use problems？？？ Use interceptors to do permission verification return insufficient rights message the client can not receive the message because the message can not be converted is there any solution?

![image](https://user-images.githubusercontent.com/28291464/37013715-7e9d3950-2136-11e8-8aab-38216d202968.png)
</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4136</IssueLabelID>
    <Title>Normalize cluster config &amp; simplify binding IConfiguration to TOptions</Title>
    <Description>Fixes #4086.

Unsure if we should also add some sugar methods like `ConfigureClusterId(string)` and `ConfigureSiloName(string)`. `ClusterId` is much more important than `SiloName`.

We could also consider setting `ClusterId` to `"default"` if it's not otherwise set.</Description>
    <Title_Description>Normalize cluster config &amp; simplify binding IConfiguration to TOptions Fixes #4086.

Unsure if we should also add some sugar methods like `ConfigureClusterId(string)` and `ConfigureSiloName(string)`. `ClusterId` is much more important than `SiloName`.

We could also consider setting `ClusterId` to `"default"` if it's not otherwise set.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4130</IssueLabelID>
    <Title>In ActivationCountPlacementDirector place locally if the cache is not ready</Title>
    <Description>It's possible that when using `ActivationCountBasedPlacement` strategy the silo will try to choose a place for an activation before the cache used in the director is populated.

The proposed fix is just to place locally until the cache is ready.
</Description>
    <Title_Description>In ActivationCountPlacementDirector, place locally if the cache is not ready It's possible that when using `ActivationCountBasedPlacement` strategy the silo will try to choose a place for an activation before the cache used in the director is populated.

The proposed fix is just to place locally until the cache is ready.
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4129</IssueLabelID>
    <Title>Bug: PerfCounterEnvironmentStatistics never reports CpuUsage</Title>
    <Description>I think the registration is wrong because OnStart is never called. 

cpuCounterPF != null but cpuUsageTimer == null</Description>
    <Title_Description>Bug: PerfCounterEnvironmentStatistics never reports CpuUsage I think the registration is wrong because OnStart is never called. 

cpuCounterPF != null but cpuUsageTimer == null</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4128</IssueLabelID>
    <Title>How to let timers survive a (graceful) silo shutdown</Title>
    <Description>I have a Game grain which manages the logic for a turn-based game between two players. Inside this grain a timer is used to measure the time for each turn and forcefully end a player's turn if they fail to play in a timely manner.

If this grain gets deactivated (even gracefully) the timer will cease to exist. The creation of a new activation of this grain will depend on it receiving external calls which means it may not happen until one of the players makes a move which defeats the purpose of the timer. I can save the game's state and let it continue off from where the old silo was shut down but I currently have no way of bringing the timer back online.

One way is to constantly poll the grain from another grain. This fails because the other grain is also subject to the same limitations as the original (namely it may get deactivated with no way to restore its timers).

Another way is to have a second grain (let's call it pinger). One could have the game ask the pinger (on deactivation) to call it back after a second or so. This is likely to succeed most of the time but if the pinger happens to be on the same silo and get deactivated after the game it will still fail.

Yet another may be to have the game call itself. However I'm not entirely sure this is a stable solution as I don't know how the silos handle the case of a grain receiving a call while it's already deactivating but not yet fully deactivated. If the grain is removed from the global directory *before* the OnDeactivateAsync call this may succeed. I just thought of this while writing this question so I have yet to see if this actually works.

A reminder is not appropriate in this scenario because the minimum interval for a reminder is 60 seconds IIRC. An entire turn takes about half a minute.

Any other ideas on how to handle this (and other similar cases)?</Description>
    <Title_Description>How to let timers survive a (graceful) silo shutdown I have a Game grain which manages the logic for a turn-based game between two players. Inside this grain a timer is used to measure the time for each turn and forcefully end a player's turn if they fail to play in a timely manner.

If this grain gets deactivated (even gracefully) the timer will cease to exist. The creation of a new activation of this grain will depend on it receiving external calls which means it may not happen until one of the players makes a move which defeats the purpose of the timer. I can save the game's state and let it continue off from where the old silo was shut down but I currently have no way of bringing the timer back online.

One way is to constantly poll the grain from another grain. This fails because the other grain is also subject to the same limitations as the original (namely it may get deactivated with no way to restore its timers).

Another way is to have a second grain (let's call it pinger). One could have the game ask the pinger (on deactivation) to call it back after a second or so. This is likely to succeed most of the time but if the pinger happens to be on the same silo and get deactivated after the game it will still fail.

Yet another may be to have the game call itself. However I'm not entirely sure this is a stable solution as I don't know how the silos handle the case of a grain receiving a call while it's already deactivating but not yet fully deactivated. If the grain is removed from the global directory *before* the OnDeactivateAsync call this may succeed. I just thought of this while writing this question so I have yet to see if this actually works.

A reminder is not appropriate in this scenario because the minimum interval for a reminder is 60 seconds IIRC. An entire turn takes about half a minute.

Any other ideas on how to handle this (and other similar cases)?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>5/03/2018 9:53:38 AM +00:00</CreatedAt>
    <ClosedAt>9/03/2018 10:08:57 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4125</IssueLabelID>
    <Title>Docker Deployment Client Connection Failed</Title>
    <Description>I Follow the Sample:

https://github.com/dotnet/orleans/tree/master/Samples/2.0/docker-aspnet-core

Silo has been successful but the client connection failed

![image](https://user-images.githubusercontent.com/7261408/36946992-d457a3b2-2000-11e8-9fb9-99eabc37296d.png)


System.AggregateException
  HResult=0x80131500
  Message=One or more errors occurred. (The target silo became unavailable for message: Request *cli/193b298f@0e75cbb3-&gt;S172.22.0.3:30000:257871284*stg/17/00000011@S00000011 #2: . Target History is: &lt;S172.22.0.3:30000:257871284:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.)
  Source=System.Private.CoreLib
  StackTrace:
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Threading.Tasks.Task.Wait()
   at Client.Program.Main(String[] args) in D:\jinbiao\OrleansSamples\OrleansDocker\Client\Program.cs:line 34

内部异常 1:
SiloUnavailableException: The target silo became unavailable for message: Request *cli/193b298f@0e75cbb3-&gt;S172.22.0.3:30000:257871284*stg/17/00000011@S00000011 #2: . Target History is: &lt;S172.22.0.3:30000:257871284:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
</Description>
    <Title_Description>Docker Deployment Client Connection Failed I Follow the Sample:

https://github.com/dotnet/orleans/tree/master/Samples/2.0/docker-aspnet-core

Silo has been successful but the client connection failed

![image](https://user-images.githubusercontent.com/7261408/36946992-d457a3b2-2000-11e8-9fb9-99eabc37296d.png)


System.AggregateException
  HResult=0x80131500
  Message=One or more errors occurred. (The target silo became unavailable for message: Request *cli/193b298f@0e75cbb3-&gt;S172.22.0.3:30000:257871284*stg/17/00000011@S00000011 #2: . Target History is: &lt;S172.22.0.3:30000:257871284:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.)
  Source=System.Private.CoreLib
  StackTrace:
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task.Wait(Int32 millisecondsTimeout CancellationToken cancellationToken)
   at System.Threading.Tasks.Task.Wait()
   at Client.Program.Main(String[] args) in D:\jinbiao\OrleansSamples\OrleansDocker\Client\Program.cs:line 34

内部异常 1:
SiloUnavailableException: The target silo became unavailable for message: Request *cli/193b298f@0e75cbb3-&gt;S172.22.0.3:30000:257871284*stg/17/00000011@S00000011 #2: . Target History is: &lt;S172.22.0.3:30000:257871284:*stg/17/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.
</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4123</IssueLabelID>
    <Title>Change the type of the Gateways property in StaticGatewayListProviderOptions in rc1</Title>
    <Description>The type of Gateways in StaticGatewayListProviderOptions is IList&lt;Uri&gt;.
The absence of the AddRange method in IList makes adding multiple gateway endpoints in ClientBuilder unnecessarily cumbersome.

Changing it to a List resolves this issue.

</Description>
    <Title_Description>Change the type of the Gateways property in StaticGatewayListProviderOptions in rc1 The type of Gateways in StaticGatewayListProviderOptions is IList&lt;Uri&gt;.
The absence of the AddRange method in IList makes adding multiple gateway endpoints in ClientBuilder unnecessarily cumbersome.

Changing it to a List resolves this issue.

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4120</IssueLabelID>
    <Title>Register InMemoryRemindersTable</Title>
    <Description>There is no registration for this class. Therefore reminders do not work out of the box.</Description>
    <Title_Description>Register InMemoryRemindersTable There is no registration for this class. Therefore reminders do not work out of the box.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4119</IssueLabelID>
    <Title>Is Orleans a microservice framework?</Title>
    <Description>I'm new to `microservice architecture` and `orleans`  it took me a few days to learn both of them but still maybe some of the concepts are not very clear to me.
**Is Orleans a microservice framework?**
It seems to me that it is but i'm not sure may be it is part of `microservice architecture`.
could some one tell me and give some brief explanations?</Description>
    <Title_Description>Is Orleans a microservice framework? I'm new to `microservice architecture` and `orleans`  it took me a few days to learn both of them but still maybe some of the concepts are not very clear to me.
**Is Orleans a microservice framework?**
It seems to me that it is but i'm not sure may be it is part of `microservice architecture`.
could some one tell me and give some brief explanations?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>3/03/2018 4:47:10 PM +00:00</CreatedAt>
    <ClosedAt>21/06/2018 9:52:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4118</IssueLabelID>
    <Title>Code Review of Orlean.Providers.MongoDB</Title>
    <Description>Hi

We'd appreciate a code review of the rc1 branch ( https://github.com/OrleansContrib/Orleans.Providers.MongoDB/tree/rc1)
There is a test application as well as unit tests.

Packages can be found at https://www.nuget.org/packages/Orleans.Providers.MongoDB

@SebastianStehle has done a significant refactor of the providers(https://github.com/OrleansContrib/Orleans.Providers.MongoDB/issues/26).  

Would it be possible to add this to the Orleans Providers? It feels like MongoDb would be ideal for an opensource Linux enviroment.</Description>
    <Title_Description>Code Review of Orlean.Providers.MongoDB Hi

We'd appreciate a code review of the rc1 branch ( https://github.com/OrleansContrib/Orleans.Providers.MongoDB/tree/rc1)
There is a test application as well as unit tests.

Packages can be found at https://www.nuget.org/packages/Orleans.Providers.MongoDB

@SebastianStehle has done a significant refactor of the providers(https://github.com/OrleansContrib/Orleans.Providers.MongoDB/issues/26).  

Would it be possible to add this to the Orleans Providers? It feels like MongoDb would be ideal for an opensource Linux enviroment.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4116</IssueLabelID>
    <Title>Improved transparancy and timing of silo lifecycle.</Title>
    <Description>- Subscrivers are now named.
- Silo lifecycle now reports stages prior to start.

**_Example stage reporting:_**

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage -2147483648: Orleans.Runtime.SiloOptionsLogger	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 4000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 8000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 10000: Orleans.Runtime.Versions.GrainVersionStore Orleans.Storage.AzureTableGrainStorage-AzureStore Orleans.Storage.AzureTableGrainStorage-PubSubStore Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 20000: Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

**_Example timing information:_**

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 10000 which took 21 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 20000 which took 65 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 20000 which took 20 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 10000 which took 0 Milliseconds.

Stream provider started in two stages because it initializes in stage 10000 and starts reading events running in stage 20000.</Description>
    <Title_Description>Improved transparancy and timing of silo lifecycle. - Subscrivers are now named.
- Silo lifecycle now reports stages prior to start.

**_Example stage reporting:_**

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage -2147483648: Orleans.Runtime.SiloOptionsLogger	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 2000: Orleans.Runtime.InsideRuntimeClient Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 4000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 8000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 10000: Orleans.Runtime.Versions.GrainVersionStore Orleans.Storage.AzureTableGrainStorage-AzureStore Orleans.Storage.AzureTableGrainStorage-PubSubStore Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 20000: Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

**_Example timing information:_**

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 10000 which took 21 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 20000 which took 65 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 20000 which took 20 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 10000 which took 0 Milliseconds.

Stream provider started in two stages because it initializes in stage 10000 and starts reading events running in stage 20000.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4115</IssueLabelID>
    <Title>EndpointOptions enhancement concerns/suggestions</Title>
    <Description>This issue is more about "how to" and not an actual bug.

[```EndpointOptions```](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Hosting/EndpointOptions.cs) class:

- Options classes generally should be dumb. An options class intialization should not make operations like dns lookup. IOptions infrastructure has better vehicles for such things like an ```IConfigureOptions&lt;EndpointOptions&gt;``` implementation. That would be a much better place to provide default values if it was not provided by the developer in the ```Configure``` method since Setup runs after it. And the fact that ```Result``` is used on the async operation does not feel right.
- Since ```IPEndpoint``` class contains the Port itself too so it feels like a duplicated effort to include that separately especially that the given ```Port``` properties are use to construct the ```IPEndPoint``` instance but on a contrary there is no way to specify just an IP Address as string to be able to get composed with the individual ```Port``` property.

[```EndpointOptionsExtensions```](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Hosting/EndpointOptionsExtensions.cs) class:

- These methods are "demoting" the usage of ```IOptions``` by offering extension methods for individual properties it is not a common pattern with ```IOptions```.
- ```listenOnAllHostAddresses``` should be ```listenOnAnyHostAddress``` based on that later ```IPAddress.Any``` is used. Also this property should be part of the ```EndpointOptions``` class since it defines behavior

Kestrel is more complex in terms of "listening" capabilities but since devs are/will be more familiar with it perhaps it should be good to follow their already implemented patterns and as Orleans 2.x will go forward deeper Linux support SystemD and Linux Sockets support will come some day eventually and the options in Kestrel already having a place for it there.

My suggestion here is to rethink how the IP Address/Ports are exposed in ```EndpointOptions``` based on the above.

** EDIT **

One more thing to add is that Gateway is an "optional" Silo feature maybe we can have a Silo and Gateway endpoint option separately especially because of the new ```AdvertisedIPAddress``` property.</Description>
    <Title_Description>EndpointOptions enhancement concerns/suggestions This issue is more about "how to" and not an actual bug.

[```EndpointOptions```](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Hosting/EndpointOptions.cs) class:

- Options classes generally should be dumb. An options class intialization should not make operations like dns lookup. IOptions infrastructure has better vehicles for such things like an ```IConfigureOptions&lt;EndpointOptions&gt;``` implementation. That would be a much better place to provide default values if it was not provided by the developer in the ```Configure``` method since Setup runs after it. And the fact that ```Result``` is used on the async operation does not feel right.
- Since ```IPEndpoint``` class contains the Port itself too so it feels like a duplicated effort to include that separately especially that the given ```Port``` properties are use to construct the ```IPEndPoint``` instance but on a contrary there is no way to specify just an IP Address as string to be able to get composed with the individual ```Port``` property.

[```EndpointOptionsExtensions```](https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Hosting/EndpointOptionsExtensions.cs) class:

- These methods are "demoting" the usage of ```IOptions``` by offering extension methods for individual properties it is not a common pattern with ```IOptions```.
- ```listenOnAllHostAddresses``` should be ```listenOnAnyHostAddress``` based on that later ```IPAddress.Any``` is used. Also this property should be part of the ```EndpointOptions``` class since it defines behavior

Kestrel is more complex in terms of "listening" capabilities but since devs are/will be more familiar with it perhaps it should be good to follow their already implemented patterns and as Orleans 2.x will go forward deeper Linux support SystemD and Linux Sockets support will come some day eventually and the options in Kestrel already having a place for it there.

My suggestion here is to rethink how the IP Address/Ports are exposed in ```EndpointOptions``` based on the above.

** EDIT **

One more thing to add is that Gateway is an "optional" Silo feature maybe we can have a Silo and Gateway endpoint option separately especially because of the new ```AdvertisedIPAddress``` property.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4114</IssueLabelID>
    <Title>does orleans2.0 rc1 support client discovery?</Title>
    <Description>at client side the hello demo use `UseStaticClustering` to conntect to the silo 
but in real world silo may be dynamic， i means that the client doesn't know about the place of silo.
so how to support client discovery? just like below or anthor way
```xml
&lt;ClientConfiguration xmlns="urn:orleans"&gt;
  &lt;SystemStore SystemStoreType="SqlServer"
               DeploymentId="target deployment ID"
               DataConnectionString="SQL connection string"/&gt;
&lt;/ClientConfiguration&gt;
```</Description>
    <Title_Description>does orleans2.0 rc1 support client discovery? at client side the hello demo use `UseStaticClustering` to conntect to the silo 
but in real world silo may be dynamic， i means that the client doesn't know about the place of silo.
so how to support client discovery? just like below or anthor way
```xml
&lt;ClientConfiguration xmlns="urn:orleans"&gt;
  &lt;SystemStore SystemStoreType="SqlServer"
               DeploymentId="target deployment ID"
               DataConnectionString="SQL connection string"/&gt;
&lt;/ClientConfiguration&gt;
```</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>2/03/2018 3:56:28 PM +00:00</CreatedAt>
    <ClosedAt>3/03/2018 6:03:34 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4113</IssueLabelID>
    <Title>[Question] Silo shutdown and OnDeactivateAsync</Title>
    <Description>I've been digging through the docs and the issues but I didn't find an answer to the following question:

_When a silo is shut down what happens inside a grain's_ `OnDeactivateAsync` _method when another grain is referenced from there which in turn is getting (or has got) deactivated due to silo shutdown?_

And to make things more obvious imagine all silos have been shut down except for the last one; and now that last one is also shutting down i.e. there are no other silos online. Say you reference another grain in `OnDeactivateAsync` which already got deactivated - will an exception be thrown in this case? Or will that referenced grain become reactivated? If so how will the reactivated grain eventually get deactivated? Is the silo trying to drain the silo from grains by retrying a deactivation again and again (until a timeout)?</Description>
    <Title_Description>[Question] Silo shutdown and OnDeactivateAsync I've been digging through the docs and the issues but I didn't find an answer to the following question:

_When a silo is shut down what happens inside a grain's_ `OnDeactivateAsync` _method when another grain is referenced from there which in turn is getting (or has got) deactivated due to silo shutdown?_

And to make things more obvious imagine all silos have been shut down except for the last one; and now that last one is also shutting down i.e. there are no other silos online. Say you reference another grain in `OnDeactivateAsync` which already got deactivated - will an exception be thrown in this case? Or will that referenced grain become reactivated? If so how will the reactivated grain eventually get deactivated? Is the silo trying to drain the silo from grains by retrying a deactivation again and again (until a timeout)?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>2/03/2018 3:17:50 PM +00:00</CreatedAt>
    <ClosedAt>13/03/2018 9:59:22 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4112</IssueLabelID>
    <Title>SystemTarget not active on this silo</Title>
    <Description>In 2.0 rc1 grain services are not working as it was before it.

```
SystemTarget *stg/0/00000000 not active on this silo. Msg=Request S192.168.196.55:10001:257696242*grn/1DFC7212/00000000@28ac39b0-&gt;S192.168.196.55:10001:257696242*stg/0/00000000@S00000000 #74: 
```

Here is the repro case:

```
internal class MyServiceClient : GrainServiceClient&lt;IMyService&gt; IMyServiceClient
  {
    public MyServiceClient (IServiceProvider serviceProvider) : base(serviceProvider) { }

    public async Task DoSomething()
    {
      try
      {
        //Here is where it blow when called from a grain method
        await GrainService.DoSomething();
      }
      catch (Exception exc)
      {
        throw;
      }
    }
  }

internal class MyService : GrainService IMyService
  {

....

    private bool _isRunning;

    public MyService (IOptions&lt;MyOptions&gt; options
            IGrainFactory grainFactory IGrainIdentity id
            Silo silo ILoggerFactory loggerFactory) : base(id silo loggerFactory)
    {
      ...
      this._grainFactory = grainFactory;
      this._logger = loggerFactory.CreateLogger(nameof(MyService));
      ...
    }

    public Task DoSomething()
    {
      return Task.CompletedTask;
    }

    public override async Task Start()
    {
      this._isRunning = true;
      await base.Start();      
    }

    protected override async Task StartInBackground()
    {
      await Task.Factory.StartNew(async () =&gt;
      {
        while (this._isRunning)
        {
         // Do our background work here
      });
      this.Status = GrainServiceStatus.Started;
    }

    public override async Task Stop()
    {
      this._isRunning = false;
      this.Status = GrainServiceStatus.Stopped;
    }
  }
```

And this is how I'm registering the grain service:

```
.ConfigureServices(services =&gt;
        {
          services.Configure&lt;MyOptions&gt;(opt =&gt;
          {
            opt.GrainServices.Add(new KeyValuePair&lt;string short&gt;(/*typeof(MyService).AssemblyQualifiedName*/ "MyAssembly.MyNamespace.MyService MyAssembly" 1));
          });
          services.Configure&lt;MyOptions&gt;(config.GetSection(MyOptions.SECTION_NAME));
          services.AddSingleton&lt;IMyServiceClient MyServiceClient&gt;();
        });
```
Redacted the sample for simplicity.

What is wrong there?  I would appreciate anyone jump in as this is a blocker for me.</Description>
    <Title_Description>SystemTarget not active on this silo In 2.0 rc1 grain services are not working as it was before it.

```
SystemTarget *stg/0/00000000 not active on this silo. Msg=Request S192.168.196.55:10001:257696242*grn/1DFC7212/00000000@28ac39b0-&gt;S192.168.196.55:10001:257696242*stg/0/00000000@S00000000 #74: 
```

Here is the repro case:

```
internal class MyServiceClient : GrainServiceClient&lt;IMyService&gt; IMyServiceClient
  {
    public MyServiceClient (IServiceProvider serviceProvider) : base(serviceProvider) { }

    public async Task DoSomething()
    {
      try
      {
        //Here is where it blow when called from a grain method
        await GrainService.DoSomething();
      }
      catch (Exception exc)
      {
        throw;
      }
    }
  }

internal class MyService : GrainService IMyService
  {

....

    private bool _isRunning;

    public MyService (IOptions&lt;MyOptions&gt; options
            IGrainFactory grainFactory IGrainIdentity id
            Silo silo ILoggerFactory loggerFactory) : base(id silo loggerFactory)
    {
      ...
      this._grainFactory = grainFactory;
      this._logger = loggerFactory.CreateLogger(nameof(MyService));
      ...
    }

    public Task DoSomething()
    {
      return Task.CompletedTask;
    }

    public override async Task Start()
    {
      this._isRunning = true;
      await base.Start();      
    }

    protected override async Task StartInBackground()
    {
      await Task.Factory.StartNew(async () =&gt;
      {
        while (this._isRunning)
        {
         // Do our background work here
      });
      this.Status = GrainServiceStatus.Started;
    }

    public override async Task Stop()
    {
      this._isRunning = false;
      this.Status = GrainServiceStatus.Stopped;
    }
  }
```

And this is how I'm registering the grain service:

```
.ConfigureServices(services =&gt;
        {
          services.Configure&lt;MyOptions&gt;(opt =&gt;
          {
            opt.GrainServices.Add(new KeyValuePair&lt;string short&gt;(/*typeof(MyService).AssemblyQualifiedName*/ "MyAssembly.MyNamespace.MyService MyAssembly" 1));
          });
          services.Configure&lt;MyOptions&gt;(config.GetSection(MyOptions.SECTION_NAME));
          services.AddSingleton&lt;IMyServiceClient MyServiceClient&gt;();
        });
```
Redacted the sample for simplicity.

What is wrong there?  I would appreciate anyone jump in as this is a blocker for me.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4110</IssueLabelID>
    <Title>Warning in logs: Ignoring unhandled exception during PubSub.UnregisterProducer</Title>
    <Description>I'm running Orleans 1.5.3 and currently playing around with Orleans streams especially with the SMSProvider.

I wrote a grain called `AppSettingsGrain` which contains settings for the service which can be configured via a client.

In order to make the settings locally available in all silos I replicate the data by utilizing streams. As soon as the settings are changed in the `AppSettingsGrain` they are propagated to all _explicitly_ subscribed `AppSettingsObserverGrain` instances. The latter grains live in each silo and only one per silo (using the `PreferLocalPlacement` strategy).

This works fine. BTW: I'm using a `FileStorageProvider` for persisting the stream subscriptions.

Now there is a simple test case: I start the debugger only using one (primary) silo. Then I change the settings by calling the `AppSettingsGrain`; the changes correctly get propagated to the `AppSettingsObserverGrain`.

Then I stop the debugger and restart. Again I change the settings by calling the `AppSettingsGrain`. 

Now I see the following log message:

```
[2018-03-01 15:13:03 +01:00 WRN] [2018-03-01 14:13:03.108 GMT    10     WARNING 103405  InsideRuntimeClient     127.0.0.1:11111]     Extension not installed on grain Services.Infrastructure.Grains.Implementations.AppSettingsGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamProducer
ExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData for message IsAlwaysInterleave NewPlacement Request S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899-&gt;S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3 #61: global::Orleans.Streams.IStreamProducerExtension:AddSubscriber()
Exc level 0: Orleans.Runtime.GrainExtensionNotInstalledException: Extension not installed on grain Services.Infrastructure.Grains.Implementations.AppSettingsGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamProducerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData
[2018-03-01 15:13:03 +01:00 WRN] [2018-03-01 14:13:03.177 GMT    13     WARNING 103406  PubSubRendezvousGrain-S127.0.0.1:11111:257609562-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+SMSProvider_AppSettings-0xBAEA8216      ]       Producer PubSubPublisherState:StreamId=AppSettings-00000000-0000-0000-0000-000000000000-SMSProviderProducer=GrainReference:*grn/A64CC0FF/00000000. on stream AppSettings-00000000-0000-0000-0000-000000000000-SMSProvider is no longer active - permanently removing producer.
```

I think this warning has to be ignored and is caused by the pub-sub infrastructure which reads the persisted subscription data and realizes that the former producer grain is gone (due to the restart). Right?

Anyway the changes are correctly propagated to the `AppSettingsObserverGrain`.

Again everything works fine so far.

From now on I don't touch the debugger anymore. I simply let the debugger run over night.

The next day I see the following log messages:

```
[2018-03-01 17:14:49 +01:00 INF] &lt;T:[Services.Infrastructure.Grains.Implementations.AppSettingsObserverGrain]&gt; Local observer grain "baea66cccdbd441ea3f4fba2bded6bfb$923ad49009794fb9a5d5007190fbeea8" deactivated.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.048 GMT     7     WARNING 100157  CallbackData    127.0.0.1:11111]        Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;. About to break its promise.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.083 GMT    10     WARNING 103402  SimpleMessageStreamProducer`1   127.0.0.1:11111]        Ignoring unhandled exception during PubSub.UnregisterProducer
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer().
Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

As you can see after 2 hours the `AppSettingsObserverGrain` has correctly been deactivated by activation garbage collection.

But after further 30 minutes an exception occurs:

```
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.048 GMT     7     WARNING 100157  CallbackData    127.0.0.1:11111]        Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;. About to break its promise.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.083 GMT    10     WARNING 103402  SimpleMessageStreamProducer`1   127.0.0.1:11111]        Ignoring unhandled exception during PubSub.UnregisterProducer
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer().
Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

After analyzing the magic strings I made the following observation:

The warning which appears on silo startup contains the following magic strings (I think they are identifying grains and their placements):

```
NewPlacement Request S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899-&gt;S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3

Producer=GrainReference:*grn/A64CC0FF/00000000

PubSubRendezvousGrain-S127.0.0.1:11111:257609562-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+SMSProvider_AppSettings-0xBAEA8216

Producer PubSubPublisherState:StreamId=AppSettings-00000000-0000-0000-0000-000000000000-SMSProviderProducer=GrainReference:*grn/A64CC0FF/00000000.
```


Now have a look at the strings which are logged after 2.5 hours:

```
Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899

Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
```

As you can see some of the strings are matching.

So I blame the "orphaned" producer grain subscription which is loaded on silo startup for causing the exception.

Anyway - when I changed the settings of the `AppSettingsGrain` the next morning in order to find out whether the change notification is still working regardless of the exception everything worked okay. Can I safely ignore the exception?</Description>
    <Title_Description>Warning in logs: Ignoring unhandled exception during PubSub.UnregisterProducer I'm running Orleans 1.5.3 and currently playing around with Orleans streams especially with the SMSProvider.

I wrote a grain called `AppSettingsGrain` which contains settings for the service which can be configured via a client.

In order to make the settings locally available in all silos I replicate the data by utilizing streams. As soon as the settings are changed in the `AppSettingsGrain` they are propagated to all _explicitly_ subscribed `AppSettingsObserverGrain` instances. The latter grains live in each silo and only one per silo (using the `PreferLocalPlacement` strategy).

This works fine. BTW: I'm using a `FileStorageProvider` for persisting the stream subscriptions.

Now there is a simple test case: I start the debugger only using one (primary) silo. Then I change the settings by calling the `AppSettingsGrain`; the changes correctly get propagated to the `AppSettingsObserverGrain`.

Then I stop the debugger and restart. Again I change the settings by calling the `AppSettingsGrain`. 

Now I see the following log message:

```
[2018-03-01 15:13:03 +01:00 WRN] [2018-03-01 14:13:03.108 GMT    10     WARNING 103405  InsideRuntimeClient     127.0.0.1:11111]     Extension not installed on grain Services.Infrastructure.Grains.Implementations.AppSettingsGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamProducer
ExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData for message IsAlwaysInterleave NewPlacement Request S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899-&gt;S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3 #61: global::Orleans.Streams.IStreamProducerExtension:AddSubscriber()
Exc level 0: Orleans.Runtime.GrainExtensionNotInstalledException: Extension not installed on grain Services.Infrastructure.Grains.Implementations.AppSettingsGrain attempting to invoke type Orleans.Streams.OrleansCodeGenStreamProducerExtensionMethodInvoker from invokable Orleans.Runtime.ActivationData
[2018-03-01 15:13:03 +01:00 WRN] [2018-03-01 14:13:03.177 GMT    13     WARNING 103406  PubSubRendezvousGrain-S127.0.0.1:11111:257609562-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+SMSProvider_AppSettings-0xBAEA8216      ]       Producer PubSubPublisherState:StreamId=AppSettings-00000000-0000-0000-0000-000000000000-SMSProviderProducer=GrainReference:*grn/A64CC0FF/00000000. on stream AppSettings-00000000-0000-0000-0000-000000000000-SMSProvider is no longer active - permanently removing producer.
```

I think this warning has to be ignored and is caused by the pub-sub infrastructure which reads the persisted subscription data and realizes that the former producer grain is gone (due to the restart). Right?

Anyway the changes are correctly propagated to the `AppSettingsObserverGrain`.

Again everything works fine so far.

From now on I don't touch the debugger anymore. I simply let the debugger run over night.

The next day I see the following log messages:

```
[2018-03-01 17:14:49 +01:00 INF] &lt;T:[Services.Infrastructure.Grains.Implementations.AppSettingsObserverGrain]&gt; Local observer grain "baea66cccdbd441ea3f4fba2bded6bfb$923ad49009794fb9a5d5007190fbeea8" deactivated.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.048 GMT     7     WARNING 100157  CallbackData    127.0.0.1:11111]        Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;. About to break its promise.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.083 GMT    10     WARNING 103402  SimpleMessageStreamProducer`1   127.0.0.1:11111]        Ignoring unhandled exception during PubSub.UnregisterProducer
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer().
Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

As you can see after 2 hours the `AppSettingsObserverGrain` has correctly been deactivated by activation garbage collection.

But after further 30 minutes an exception occurs:

```
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.048 GMT     7     WARNING 100157  CallbackData    127.0.0.1:11111]        Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer(). Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;. About to break its promise.
[2018-03-01 17:44:50 +01:00 WRN] [2018-03-01 16:44:50.083 GMT    10     WARNING 103402  SimpleMessageStreamProducer`1   127.0.0.1:11111]        Ignoring unhandled exception during PubSub.UnregisterProducer
Exc level 0: System.TimeoutException: Response did not arrive on time in 00:30:00 for message: Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899 #8239: global::Orleans.Streams.IPubSubRendezvousGrain:UnregisterProducer().
Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Providers.Streams.SimpleMessageStream.SimpleMessageStreamProducer`1.&lt;Cleanup&gt;d__28.MoveNext()
```

After analyzing the magic strings I made the following observation:

The warning which appears on silo startup contains the following magic strings (I think they are identifying grains and their placements):

```
NewPlacement Request S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899-&gt;S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3

Producer=GrainReference:*grn/A64CC0FF/00000000

PubSubRendezvousGrain-S127.0.0.1:11111:257609562-*grn/716E8E94/0000000000000000000000000000000006000000716e8e94+SMSProvider_AppSettings-0xBAEA8216

Producer PubSubPublisherState:StreamId=AppSettings-00000000-0000-0000-0000-000000000000-SMSProviderProducer=GrainReference:*grn/A64CC0FF/00000000.
```


Now have a look at the strings which are logged after 2.5 hours:

```
Request S127.0.0.1:11111:257609562*grn/A64CC0FF/00000000@a9167ba3-&gt;S127.0.0.1:11111:257609562*grn/716E8E94/00000000+SMSProvider_AppSettings@2bb98899

Target History is: &lt;S127.0.0.1:11111:257609562:*grn/716E8E94/00000000+SMSProvider_AppSettings:@2bb98899&gt;.
```

As you can see some of the strings are matching.

So I blame the "orphaned" producer grain subscription which is loaded on silo startup for causing the exception.

Anyway - when I changed the settings of the `AppSettingsGrain` the next morning in order to find out whether the change notification is still working regardless of the exception everything worked okay. Can I safely ignore the exception?</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4109</IssueLabelID>
    <Title>2.0 rc1 ServiceFabric clustering is dependent on Legacy Configuration</Title>
    <Description>The service fabric clustering components are still dependent on the Legacy GlobalConfiguration object (and legacy nuget package).  

Is ServiceFabric clustering considered to be legacy as well? Since I saw some threads indicating to use another membership provider (like azure table) in SF.

</Description>
    <Title_Description>2.0 rc1 ServiceFabric clustering is dependent on Legacy Configuration The service fabric clustering components are still dependent on the Legacy GlobalConfiguration object (and legacy nuget package).  

Is ServiceFabric clustering considered to be legacy as well? Since I saw some threads indicating to use another membership provider (like azure table) in SF.

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4107</IssueLabelID>
    <Title>[question]Is there any guide for orleans upgrade?</Title>
    <Description>In the production environment applications which have many nodes will be upgraded node by node.

Test users may be migrated to the new released node. And then 10% user and then 30%... finally 100%.
New silos have been added to the cluster with no active grain until test users are manually migrated to the new silo.

New software is released in a controllable reversible way.  This is very important for large applications.

Is there any guide for upgrade orleans for example if the application has to be upgraded from orleans 1.5 to 2.0 without downtime  in the controllable reversible way?</Description>
    <Title_Description>[question]Is there any guide for orleans upgrade? In the production environment applications which have many nodes will be upgraded node by node.

Test users may be migrated to the new released node. And then 10% user and then 30%... finally 100%.
New silos have been added to the cluster with no active grain until test users are manually migrated to the new silo.

New software is released in a controllable reversible way.  This is very important for large applications.

Is there any guide for upgrade orleans for example if the application has to be upgraded from orleans 1.5 to 2.0 without downtime  in the controllable reversible way?</Title_Description>
    <Label>P2</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4099</IssueLabelID>
    <Title>Using AzureTableStorage for grain state in 2.0.0-rc1 results in exception</Title>
    <Description>I'm not sure if I've misconfigured the provider after upgrading or what but I'm getting the following exception:

```
2018-02-28 13:47:42.0305|ERROR|Orleans.Storage.AzureTableGrainStorage|Error from storage provider AzureTableGrainStorage.Atlas.Grains.OracleGrain during ReadState for grain Type=Atlas.Grains.OracleGrain Pk=*grn/A7373A0B/0000000000000000000000000000000003ffffffa7373a0b-0xFD37BD8E Id=GrainReference:*grn/A7373A0B/00000000 Error=
 
Exc level 0: System.ArgumentException: GrainState-Table property not initialized
   at Orleans.Storage.AzureTableGrainStorage.&lt;ReadStateAsync&gt;d__15.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Core.StateStorageBridge`1.&lt;ReadStateAsync&gt;d__11.MoveNext()
2018-02-28 13:47:42.0329|ERROR|Orleans.Runtime.GrainLifecycle|Lifecycle start canceled due to errors at stage 1000
2018-02-28 13:47:42.0329|ERROR|Orleans.Runtime.Catalog|Error calling grain's OnActivateAsync() method - Grain type = Atlas.Grains.OracleGrain Activation = [Activation: S127.0.0.1:11111:257550460*grn/A7373A0B/00000000@4bea0e8a #GrainType=Atlas.Grains.OracleGrain Placement=RandomPlacement State=Activating]
```

I'm using the following configuration:

```
services.AddAzureTableGrainStorage("AzureTableStore" options =&gt;
{
    options.UseJson = true;
    options.ConnectionString = "my connection string here";
    options.TableName = "my table name however i only added this in an attempt to fix the issue";
});
```
</Description>
    <Title_Description>Using AzureTableStorage for grain state in 2.0.0-rc1 results in exception I'm not sure if I've misconfigured the provider after upgrading or what but I'm getting the following exception:

```
2018-02-28 13:47:42.0305|ERROR|Orleans.Storage.AzureTableGrainStorage|Error from storage provider AzureTableGrainStorage.Atlas.Grains.OracleGrain during ReadState for grain Type=Atlas.Grains.OracleGrain Pk=*grn/A7373A0B/0000000000000000000000000000000003ffffffa7373a0b-0xFD37BD8E Id=GrainReference:*grn/A7373A0B/00000000 Error=
 
Exc level 0: System.ArgumentException: GrainState-Table property not initialized
   at Orleans.Storage.AzureTableGrainStorage.&lt;ReadStateAsync&gt;d__15.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.Core.StateStorageBridge`1.&lt;ReadStateAsync&gt;d__11.MoveNext()
2018-02-28 13:47:42.0329|ERROR|Orleans.Runtime.GrainLifecycle|Lifecycle start canceled due to errors at stage 1000
2018-02-28 13:47:42.0329|ERROR|Orleans.Runtime.Catalog|Error calling grain's OnActivateAsync() method - Grain type = Atlas.Grains.OracleGrain Activation = [Activation: S127.0.0.1:11111:257550460*grn/A7373A0B/00000000@4bea0e8a #GrainType=Atlas.Grains.OracleGrain Placement=RandomPlacement State=Activating]
```

I'm using the following configuration:

```
services.AddAzureTableGrainStorage("AzureTableStore" options =&gt;
{
    options.UseJson = true;
    options.ConnectionString = "my connection string here";
    options.TableName = "my table name however i only added this in an attempt to fix the issue";
});
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4098</IssueLabelID>
    <Title>Custom placement strategy usability improvements</Title>
    <Description>In 2.0.0-rc1 custom placement strategy registration isn't as obvious as it should be:
```C#
builder.ConfigureServices(services =&gt;
{
    services
      .AddSingletonNamedService&lt;PlacementStrategy VersionAwarePlacementStrategy&gt;(
        nameof(VersionAwarePlacementStrategy))
      .AddSingletonKeyedService&lt;Type IPlacementDirector VersionAwarePlacementDirector&gt;(
        typeof(VersionAwarePlacementStrategy));
});
```

The director registration should be obvious and discoverable. The strategy registration should not be needed.

cc @yzhao174</Description>
    <Title_Description>Custom placement strategy usability improvements In 2.0.0-rc1 custom placement strategy registration isn't as obvious as it should be:
```C#
builder.ConfigureServices(services =&gt;
{
    services
      .AddSingletonNamedService&lt;PlacementStrategy VersionAwarePlacementStrategy&gt;(
        nameof(VersionAwarePlacementStrategy))
      .AddSingletonKeyedService&lt;Type IPlacementDirector VersionAwarePlacementDirector&gt;(
        typeof(VersionAwarePlacementStrategy));
});
```

The director registration should be obvious and discoverable. The strategy registration should not be needed.

cc @yzhao174</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4097</IssueLabelID>
    <Title>Improve configuration validators for ADO.NET configuration</Title>
    <Description>* Consolidate naming of ADO.NET invariant option: now it's `Invariant` in all places instead of being `AdoInvariant` in clustering and `Invariant` everywhere else.
* Add configuration validators for clustering and reminders and improve grain storage validator to check that `Invariant` is set.
* Propagate invariant value from legacy configuration to reminder configuration.
* Add `invariant` parameter on reminder config extension method which takes a connection string.</Description>
    <Title_Description>Improve configuration validators for ADO.NET configuration * Consolidate naming of ADO.NET invariant option: now it's `Invariant` in all places instead of being `AdoInvariant` in clustering and `Invariant` everywhere else.
* Add configuration validators for clustering and reminders and improve grain storage validator to check that `Invariant` is set.
* Propagate invariant value from legacy configuration to reminder configuration.
* Add `invariant` parameter on reminder config extension method which takes a connection string.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4096</IssueLabelID>
    <Title>TypeMap are not dynamically refreshed on clients</Title>
    <Description>Related to #4028 with in-place upgrades.

The issue is that if you try to update both silo and client at the same time new clients are more likely to start before the new silos so they get an outdated `TypeMap` (clients get it when they connect to their first silo).

Right now the workaround is to create a new `ClusterClient` that will pick-up a new `TypeMap` when getting an exception saying `Cannot find an implementation class for grain `

Here are our options:

1. Keep the current behavior (no `TypeMap` refresh on clients). Developer will have to handle the case explicitely.
2. Refresh periodically the `TypeMap`:
a) With a timer on the client
b) Silo will send a push notification to the client telling him to update the `TypeMap`when needed (but since clients are connected to multiple silos but only one of them should send such notifications?)

</Description>
    <Title_Description>TypeMap are not dynamically refreshed on clients Related to #4028 with in-place upgrades.

The issue is that if you try to update both silo and client at the same time new clients are more likely to start before the new silos so they get an outdated `TypeMap` (clients get it when they connect to their first silo).

Right now the workaround is to create a new `ClusterClient` that will pick-up a new `TypeMap` when getting an exception saying `Cannot find an implementation class for grain `

Here are our options:

1. Keep the current behavior (no `TypeMap` refresh on clients). Developer will have to handle the case explicitely.
2. Refresh periodically the `TypeMap`:
a) With a timer on the client
b) Silo will send a push notification to the client telling him to update the `TypeMap`when needed (but since clients are connected to multiple silos but only one of them should send such notifications?)

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4095</IssueLabelID>
    <Title>Unclear dependency of Reminders to Membership on ADO.net providers</Title>
    <Description>If I have something like this:

```
builder
        .Configure(c =&gt; c.ClusterId = configRoot["ClusterId"])
        .ConfigureSiloName(serviceName)
        .UseAdoNetReminderService(opt =&gt;
        {
          opt.ConnectionString = configRoot["ClusterStorage"];
          // opt.Invariant = ADO_INVARIANT;
        })
        .ConfigureEndpoints(IPAddress.Parse(siloIp) port port + 1000 true)
        .UseAdoNetClustering(options =&gt;
        {
          options.ConnectionString = configRoot["ClusterStorage"];
          options.AdoInvariant = ADO_INVARIANT;
        })
...
```

The silo fail to start saying that the membership provider relational storage can't have a null value on `AdoInvariant`.

If I uncomment `// opt.Invariant = ADO_INVARIANT;` at the Reminders configuration (kudos to @rikbosch) the silo start just fine.

I understand that reminders as any other AdoNet provider requires the `Invariant` to not be null. What I doesn't understand is why the Membership provider blow up when the reminder is not properly configured.

To remediate that I think the AdoNet provider would love to receive a configuration validator like the other providers so it can fail fast by the time you call `builder.Build()`.</Description>
    <Title_Description>Unclear dependency of Reminders to Membership on ADO.net providers If I have something like this:

```
builder
        .Configure(c =&gt; c.ClusterId = configRoot["ClusterId"])
        .ConfigureSiloName(serviceName)
        .UseAdoNetReminderService(opt =&gt;
        {
          opt.ConnectionString = configRoot["ClusterStorage"];
          // opt.Invariant = ADO_INVARIANT;
        })
        .ConfigureEndpoints(IPAddress.Parse(siloIp) port port + 1000 true)
        .UseAdoNetClustering(options =&gt;
        {
          options.ConnectionString = configRoot["ClusterStorage"];
          options.AdoInvariant = ADO_INVARIANT;
        })
...
```

The silo fail to start saying that the membership provider relational storage can't have a null value on `AdoInvariant`.

If I uncomment `// opt.Invariant = ADO_INVARIANT;` at the Reminders configuration (kudos to @rikbosch) the silo start just fine.

I understand that reminders as any other AdoNet provider requires the `Invariant` to not be null. What I doesn't understand is why the Membership provider blow up when the reminder is not properly configured.

To remediate that I think the AdoNet provider would love to receive a configuration validator like the other providers so it can fail fast by the time you call `builder.Build()`.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4093</IssueLabelID>
    <Title>Move ConfigureEndpoints to Orleans.Hosting</Title>
    <Description>
    </Description>
    <Title_Description>Move ConfigureEndpoints to Orleans.Hosting </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4086</IssueLabelID>
    <Title>SiloBuilder extensions/options usability issues</Title>
    <Description>Let's track here all change that we should do in SiloBuilder extensions methods and options before release.

- [x] `UseDevelopmentClustering` is not very user friendly; user should be able to just call `siloBuilder.UseDevelopmentClustering()` not `siloBuilder.UseDevelopmentClustering(options =&gt; ....)`
- [x] `ConfigureEndpoints` extensions are in namespace `Orleans.Configuration` instead of `Orleans.Hosting`
- [ ] The method to configure the cluster on the client is called `ConfigureCluster` but is called `Configure` on the silo</Description>
    <Title_Description>SiloBuilder extensions/options usability issues Let's track here all change that we should do in SiloBuilder extensions methods and options before release.

- [x] `UseDevelopmentClustering` is not very user friendly; user should be able to just call `siloBuilder.UseDevelopmentClustering()` not `siloBuilder.UseDevelopmentClustering(options =&gt; ....)`
- [x] `ConfigureEndpoints` extensions are in namespace `Orleans.Configuration` instead of `Orleans.Hosting`
- [ ] The method to configure the cluster on the client is called `ConfigureCluster` but is called `Configure` on the silo</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4084</IssueLabelID>
    <Title>Failure loading MemoryStorageGrain</Title>
    <Description>On latest RC calling `.AddMemoryGrainStorageAsDefault()` fail to register the provider if we are adding any type to application parts manager (i.e. the auto-discovery is disable since I'm adding assemblies manually).

This method is supposed to add the `IMemoryStorageGrain` to the App parts internally.

Logs attached.

Thanks
[logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f (1).txt](https://github.com/dotnet/orleans/files/1764074/logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f.1.txt)
</Description>
    <Title_Description>Failure loading MemoryStorageGrain On latest RC calling `.AddMemoryGrainStorageAsDefault()` fail to register the provider if we are adding any type to application parts manager (i.e. the auto-discovery is disable since I'm adding assemblies manually).

This method is supposed to add the `IMemoryStorageGrain` to the App parts internally.

Logs attached.

Thanks
[logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f (1).txt](https://github.com/dotnet/orleans/files/1764074/logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f.1.txt)
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4082</IssueLabelID>
    <Title>Can I connect Orleans server with golang，nodejs...  another language ？</Title>
    <Description>please ：

Can I connect Orleans server with golang，nodejs...  another language ？</Description>
    <Title_Description>Can I connect Orleans server with golang，nodejs...  another language ？ please ：

Can I connect Orleans server with golang，nodejs...  another language ？</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>27/02/2018 7:35:39 AM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 9:11:38 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4080</IssueLabelID>
    <Title>Improve persistent stream provider configuration pattern </Title>
    <Description>Persistent stream providers are very complex it has many components which user can customize. Now the configuration of those components has scattered in three places one is through inheritance another one is through giant god  stream provider options which is intended to configure everything third one is through the component's own option. All three of them has pain points listed below. 

- Use inheritance  instead of DI to configure some core component such as `CheckpointerFactory` `QueueMapperFactory` `StreamFailureHandlerFactory` setters on `TAdapterFactory`. This make configuring harder since if user want to configure those they need to actually have a reasonable understanding of how Orleans streaming is wired up internally to know which class to inherit and when to set those factories. Although this is true before so one may argue it might be fine now. But the fact is after provider been integrated with lifecycle its configuration process has been changed entirely. For users who configured those factory through inheritance they cannot use our extension methods to configure their custom stream provider and the configuration their are familiar with is gone and they need to get used to a new one which is almost as bad as before. So I think we should kill this pain point because we provided a new configuration method it will suck if it is as bad as before. 

- The disadvantage of god stream provider options is its poor flexibility extensibility and complexity. I will skipped listing its cons here since I think there's a consensus on Why god configuration is bad. 

- Configure one component through its own option is the way to go forward. The problem with it right now is poor discoverability especially when the configuration is in three places. For example to configure a queue balancer now you need to first set the queue balancer type right in the stream provider options then you need to configure the specific type of queue balancer options through DI which there's no extra infrastructure to guide you on how to do that. 

I would argue some of those need to be improved in 2.0 scope because we create a fuss to provide a new way of configuration it will be bad if this new configuration method is as bad as before and user need to learn about this new bad way and adapt to it instead of happily adapt a better way. 

General direction is to uniform these three ways of configuration and develop one consistent and better way to configure stream providers which also has good discoverability extensibility and flexibility.  
</Description>
    <Title_Description>Improve persistent stream provider configuration pattern  Persistent stream providers are very complex it has many components which user can customize. Now the configuration of those components has scattered in three places one is through inheritance another one is through giant god  stream provider options which is intended to configure everything third one is through the component's own option. All three of them has pain points listed below. 

- Use inheritance  instead of DI to configure some core component such as `CheckpointerFactory` `QueueMapperFactory` `StreamFailureHandlerFactory` setters on `TAdapterFactory`. This make configuring harder since if user want to configure those they need to actually have a reasonable understanding of how Orleans streaming is wired up internally to know which class to inherit and when to set those factories. Although this is true before so one may argue it might be fine now. But the fact is after provider been integrated with lifecycle its configuration process has been changed entirely. For users who configured those factory through inheritance they cannot use our extension methods to configure their custom stream provider and the configuration their are familiar with is gone and they need to get used to a new one which is almost as bad as before. So I think we should kill this pain point because we provided a new configuration method it will suck if it is as bad as before. 

- The disadvantage of god stream provider options is its poor flexibility extensibility and complexity. I will skipped listing its cons here since I think there's a consensus on Why god configuration is bad. 

- Configure one component through its own option is the way to go forward. The problem with it right now is poor discoverability especially when the configuration is in three places. For example to configure a queue balancer now you need to first set the queue balancer type right in the stream provider options then you need to configure the specific type of queue balancer options through DI which there's no extra infrastructure to guide you on how to do that. 

I would argue some of those need to be improved in 2.0 scope because we create a fuss to provide a new way of configuration it will be bad if this new configuration method is as bad as before and user need to learn about this new bad way and adapt to it instead of happily adapt a better way. 

General direction is to uniform these three ways of configuration and develop one consistent and better way to configure stream providers which also has good discoverability extensibility and flexibility.  
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4077</IssueLabelID>
    <Title>Start GrainVersionStore later at runtime</Title>
    <Description>Related issue: #4075 </Description>
    <Title_Description>Start GrainVersionStore later at runtime Related issue: #4075 </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4075</IssueLabelID>
    <Title>IVersionStore should not be used before the silo is ready</Title>
    <Description>Right now it is used in `ServiceLifecycleStage.RuntimeGrainServices` and sometimes when the first silo starts you can get these errors in the logs:

&gt; [2018-02-23 01:23:05.417 GMT 45	Error	102202	Orleans.Storage.AzureTableGrainStorage]	!!!!!!!!!! Error from storage provider AzureTableGrainStorage.Orleans.Runtime.Versions.VersionStoreGrain during ReadState for grain Type=Orleans.Runtime.Versions.VersionStoreGrain Pk=*grn/13BAB4D8/000000000000000000000000000000000600000013bab4d8+loadtests636549168964888958-0xD87DF39E Id=GrainReference:*grn/13BAB4D8/00000000+loadtests636549168964888958 Error=

I think we should move its initialization in  `ServiceLifecycleStage.ApplicationServices`</Description>
    <Title_Description>IVersionStore should not be used before the silo is ready Right now it is used in `ServiceLifecycleStage.RuntimeGrainServices` and sometimes when the first silo starts you can get these errors in the logs:

&gt; [2018-02-23 01:23:05.417 GMT 45	Error	102202	Orleans.Storage.AzureTableGrainStorage]	!!!!!!!!!! Error from storage provider AzureTableGrainStorage.Orleans.Runtime.Versions.VersionStoreGrain during ReadState for grain Type=Orleans.Runtime.Versions.VersionStoreGrain Pk=*grn/13BAB4D8/000000000000000000000000000000000600000013bab4d8+loadtests636549168964888958-0xD87DF39E Id=GrainReference:*grn/13BAB4D8/00000000+loadtests636549168964888958 Error=

I think we should move its initialization in  `ServiceLifecycleStage.ApplicationServices`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4073</IssueLabelID>
    <Title>Fix test configuration bug in AzureQueue tests introduced in #4067</Title>
    <Description>Need a memory store provider named "MemoryStore" instead of the default one.</Description>
    <Title_Description>Fix test configuration bug in AzureQueue tests introduced in #4067 Need a memory store provider named "MemoryStore" instead of the default one.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4069</IssueLabelID>
    <Title>End-To-End Identity</Title>
    <Description>Hello

are there any plans to integrate "end-to-end (windows)identity" feature into Orleans?

By this I mean "running the grain method in the context of a windows-user" - something which you get for free for most other MS-Products (WCF / ASMX services etc).

This is mandatory for our use case and I have been struggling implementing this (I kinda have it working now using SSPI Api....but right now the solution is a little messy and implementing that in all places where it is needed will be a lot of work).

So - are there any plans on integrating this into Orleans?</Description>
    <Title_Description>End-To-End Identity Hello

are there any plans to integrate "end-to-end (windows)identity" feature into Orleans?

By this I mean "running the grain method in the context of a windows-user" - something which you get for free for most other MS-Products (WCF / ASMX services etc).

This is mandatory for our use case and I have been struggling implementing this (I kinda have it working now using SSPI Api....but right now the solution is a little messy and implementing that in all places where it is needed will be a lot of work).

So - are there any plans on integrating this into Orleans?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>22/02/2018 10:54:37 AM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 9:11:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4066</IssueLabelID>
    <Title>Port AWS libraries to use options/lifecycle.</Title>
    <Description>This updates the AWS libraries use options and lifecycle rather than the legacy provider model.
Work was done by @galvesribeiro I'm just shepherding it through the process.</Description>
    <Title_Description>Port AWS libraries to use options/lifecycle. This updates the AWS libraries use options and lifecycle rather than the legacy provider model.
Work was done by @galvesribeiro I'm just shepherding it through the process.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4065</IssueLabelID>
    <Title>Duplicate cluster ID on the client.</Title>
    <Description>ClusterId is defined in the SiloOptions which is available on the client (per my understanding) and in the ClusterClientOptions.  This ambiguity introduces a number of maintenance and configuration questions. 

Client and silo should each have only one source of cluster information if it's the same or different option is less important than each having only a single source.</Description>
    <Title_Description>Duplicate cluster ID on the client. ClusterId is defined in the SiloOptions which is available on the client (per my understanding) and in the ClusterClientOptions.  This ambiguity introduces a number of maintenance and configuration questions. 

Client and silo should each have only one source of cluster information if it's the same or different option is less important than each having only a single source.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4063</IssueLabelID>
    <Title>Silo lifecycle performance fix</Title>
    <Description>Attempt to address performance issues related to silo lifecycle.
- Silo lifecycle actions are not run in lifecycle context.</Description>
    <Title_Description>Silo lifecycle performance fix Attempt to address performance issues related to silo lifecycle.
- Silo lifecycle actions are not run in lifecycle context.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4061</IssueLabelID>
    <Title>Update Samples and docs to show necessity of using ObserverSubscriptionManager.IsSubscribed()</Title>
    <Description>Both the Orleans docs and several samples just call ObserverSubscriptionManager.Subscribe() without handling the OrleansException that is generated if the observer that is subbed/unsubbed is already subbed/unsubbed. That seems like an important failure state to handle especially since the current docs actually suggest re-subbing as a means of improving reliability of this feature.</Description>
    <Title_Description>Update Samples and docs to show necessity of using ObserverSubscriptionManager.IsSubscribed() Both the Orleans docs and several samples just call ObserverSubscriptionManager.Subscribe() without handling the OrleansException that is generated if the observer that is subbed/unsubbed is already subbed/unsubbed. That seems like an important failure state to handle especially since the current docs actually suggest re-subbing as a means of improving reliability of this feature.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>21/02/2018 4:52:34 PM +00:00</CreatedAt>
    <ClosedAt>20/04/2018 5:49:24 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4060</IssueLabelID>
    <Title>Client unable to talk to Gateways</Title>
    <Description>We have an established product that uses Orleans.  It has been stably running for some time now but today out the blue some clients struggled to talk to the Silos.  Can anyone help me figure out why?

**Setup:**
- 8 machines
- Each machine runs one Silo and one Client
- The Client takes messages off a MSMQ and forwards it to the Cluster
- Using SQL membership
- This is our development system so no hardware or windows firewalls are on

**Observed behaviour**
- Communication issues happened at the same time
- Some clients work normally
- Some clients fail to talk to the cluster (log below)
- When a client fails to send data no data can be sent from that client at all (we allow up to messages sent to Orleans simultaneously)
- Clients failed within 30-60 minutes of each other
- The clients that fail fail on a "known" error.  I.e. an Orleans exception is thrown the client retries to send its data forever.

**Log**

```[2018-02-21 08:57:18.343 GMT    60   INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:56:18   
[2018-02-21 08:57:28.783 GMT    17  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0246063   
[2018-02-21 08:57:28.783 GMT    17  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762596: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:57:28.986 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762597: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:57:29.205 GMT    49  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762599: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:57:29.205 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762600: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:57:29.315 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762601: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 08:58:18.353 GMT    59  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:57:18   
[2018-02-21 08:58:30.839 GMT     7  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0559244   
[2018-02-21 08:58:30.839 GMT     7  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762700: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:58:31.026 GMT    64  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762701: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:58:31.214 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762702: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:58:31.214 GMT    17  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762703: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:58:31.339 GMT     5  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762704: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 08:59:18.363 GMT    25  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:58:18   
[2018-02-21 08:59:32.850 GMT     8  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0109545   
[2018-02-21 08:59:32.850 GMT     8  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762803: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:59:33.053 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762804: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:59:33.241 GMT     5  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762806: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:59:33.241 GMT    11  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762805: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:59:33.350 GMT    49  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762807: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 09:00:18.374 GMT    25  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:59:18   
[2018-02-21 09:00:34.863 GMT    60  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0128829   
[2018-02-21 09:00:34.863 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762906: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 09:00:35.066 GMT     8  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762907: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 09:00:35.254 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762909: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 09:00:35.254 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762908: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 09:00:35.379 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762910: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
```</Description>
    <Title_Description>Client unable to talk to Gateways We have an established product that uses Orleans.  It has been stably running for some time now but today out the blue some clients struggled to talk to the Silos.  Can anyone help me figure out why?

**Setup:**
- 8 machines
- Each machine runs one Silo and one Client
- The Client takes messages off a MSMQ and forwards it to the Cluster
- Using SQL membership
- This is our development system so no hardware or windows firewalls are on

**Observed behaviour**
- Communication issues happened at the same time
- Some clients work normally
- Some clients fail to talk to the cluster (log below)
- When a client fails to send data no data can be sent from that client at all (we allow up to messages sent to Orleans simultaneously)
- Clients failed within 30-60 minutes of each other
- The clients that fail fail on a "known" error.  I.e. an Orleans exception is thrown the client retries to send its data forever.

**Log**

```[2018-02-21 08:57:18.343 GMT    60   INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:56:18   
[2018-02-21 08:57:28.783 GMT    17  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0246063   
[2018-02-21 08:57:28.783 GMT    17  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762596: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:57:28.986 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762597: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:57:29.205 GMT    49  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762599: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:57:29.205 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762600: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:57:29.315 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762601: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 08:58:18.353 GMT    59  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:57:18   
[2018-02-21 08:58:30.839 GMT     7  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0559244   
[2018-02-21 08:58:30.839 GMT     7  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762700: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:58:31.026 GMT    64  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762701: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:58:31.214 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762702: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:58:31.214 GMT    17  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762703: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:58:31.339 GMT     5  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762704: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 08:59:18.363 GMT    25  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:58:18   
[2018-02-21 08:59:32.850 GMT     8  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0109545   
[2018-02-21 08:59:32.850 GMT     8  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762803: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 08:59:33.053 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762804: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 08:59:33.241 GMT     5  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762806: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 08:59:33.241 GMT    11  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762805: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 08:59:33.350 GMT    49  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762807: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
[2018-02-21 09:00:18.374 GMT    25  INFO    101309  Messaging.GatewayManager    192.168.5.183:0]    Refreshed the live Gateway list. Found 8 gateways from Gateway listProvider: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Picked only known live out of them. Now has 8 live Gateways: [gwy.tcp://192.168.5.182:40001/256757971 gwy.tcp://192.168.5.183:40001/256757974 gwy.tcp://192.168.5.184:40001/256757977 gwy.tcp://192.168.5.185:40001/256757981 gwy.tcp://192.168.5.186:40001/256757984 gwy.tcp://192.168.5.187:40000/256757987 gwy.tcp://192.168.5.188:40000/256757990 gwy.tcp://192.168.5.189:40001/256757993]. Previous refresh time was = 21/02/2018 08:59:18   
[2018-02-21 09:00:34.863 GMT    60  INFO    600157  CallbackData    192.168.5.183:0]    Log code 100157 occurred 35 additional times in the previous 00:01:02.0128829   
[2018-02-21 09:00:34.863 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.187:40000:256757987*grn/242D8DD/00000000+352219001585801 #1762906: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.187:40000:256757987:*grn/242D8DD/00000000+352219001585801:&gt;. About to break its promise. 
[2018-02-21 09:00:35.066 GMT     8  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.186:40001:256757984*grn/242D8DD/00000000+DG461140 #1762907: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.186:40001:256757984:*grn/242D8DD/00000000+DG461140:&gt;. About to break its promise.   
[2018-02-21 09:00:35.254 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.188:40000:256757990*grn/242D8DD/00000000+357467030555080 #1762909: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.188:40000:256757990:*grn/242D8DD/00000000+357467030555080:&gt;. About to break its promise. 
[2018-02-21 09:00:35.254 GMT    60  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.184:40001:256757977*grn/242D8DD/00000000+359739071028328 #1762908: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.184:40001:256757977:*grn/242D8DD/00000000+359739071028328:&gt;. About to break its promise. 
[2018-02-21 09:00:35.379 GMT    59  WARNING 100157  CallbackData    192.168.5.183:0]    Response did not arrive on time in 00:00:30 for message: Request *cli/57264686@2423259f-&gt;S192.168.5.182:40001:256757971*grn/242D8DD/00000000+357467030555312 #1762910: global::Grains.Interfaces.IUnitGrain:ProcessPlot(). Target History is: &lt;S192.168.5.182:40001:256757971:*grn/242D8DD/00000000+357467030555312:&gt;. About to break its promise. 
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4056</IssueLabelID>
    <Title>DynamoDB transaction log</Title>
    <Description>Ported Azure transaction log to dynamodb.
Made a small api change to DynamoDBStorage in order to get continuation information from queries.</Description>
    <Title_Description>DynamoDB transaction log Ported Azure transaction log to dynamodb.
Made a small api change to DynamoDBStorage in order to get continuation information from queries.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4055</IssueLabelID>
    <Title>Fix various AzureStorage tests</Title>
    <Description>Only config/initialization issues in functional tests</Description>
    <Title_Description>Fix various AzureStorage tests Only config/initialization issues in functional tests</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4053</IssueLabelID>
    <Title>MemoryStorage - etag mismatch</Title>
    <Description>We have noticed we are getting a lot of etag mismatch issues and we couldn't figure out why as during dev they don't usually appear but in prod they do.

Today I had investigated a bit and finally I found out why its happening. This is how to do it:

- Use a MemoryStorage as persistence for a stateful grain
- Set `State = null`
- `WriteStateAsync`
- Deactivate grain

On next reactivation if you use `WriteStateAsync` it will throw an etag mismatch exception even if you explicitly call `ReadStateAsync` and then call `WriteStateAsync` it will still throw an exception the only way to recover it is to use `ClearStateAsync`

However if you call it when the grain is still activated it works correctly e.g.
```cs
State = new Hero {
    Name = "Rexxar"
};
await WriteStateAsync();
State = null;
await WriteStateAsync();
State = new Hero {
    Name = "Thrall"
};
await WriteStateAsync();
```

Not entirely sure if its a bug or a misuse i think its a bit of both but either or ideally it can be prevented because it can lead to some quite hard to track issues.</Description>
    <Title_Description>MemoryStorage - etag mismatch We have noticed we are getting a lot of etag mismatch issues and we couldn't figure out why as during dev they don't usually appear but in prod they do.

Today I had investigated a bit and finally I found out why its happening. This is how to do it:

- Use a MemoryStorage as persistence for a stateful grain
- Set `State = null`
- `WriteStateAsync`
- Deactivate grain

On next reactivation if you use `WriteStateAsync` it will throw an etag mismatch exception even if you explicitly call `ReadStateAsync` and then call `WriteStateAsync` it will still throw an exception the only way to recover it is to use `ClearStateAsync`

However if you call it when the grain is still activated it works correctly e.g.
```cs
State = new Hero {
    Name = "Rexxar"
};
await WriteStateAsync();
State = null;
await WriteStateAsync();
State = new Hero {
    Name = "Thrall"
};
await WriteStateAsync();
```

Not entirely sure if its a bug or a misuse i think its a bit of both but either or ideally it can be prevented because it can lead to some quite hard to track issues.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4052</IssueLabelID>
    <Title>Cannot find generated GrainReference class</Title>
    <Description>Hi，in my test environment a silo and a client are started.
There are two grains in the silo: GrainA and GrainB.

When I try to get a GrainB reference in the CLIENT it works fine.

But when I try to get a GrainB reference in the GrainA's OnActivateAsync  an exception is thrown out:
System.InvalidOperationException: 'Cannot find generated GrainReference class for interface 'MyInterfaces.IInterfaceOrleans''

Orleans version: 2.0.0 beta3 from nuget.org

Any suggestion for further diagnosing?</Description>
    <Title_Description>Cannot find generated GrainReference class Hi，in my test environment a silo and a client are started.
There are two grains in the silo: GrainA and GrainB.

When I try to get a GrainB reference in the CLIENT it works fine.

But when I try to get a GrainB reference in the GrainA's OnActivateAsync  an exception is thrown out:
System.InvalidOperationException: 'Cannot find generated GrainReference class for interface 'MyInterfaces.IInterfaceOrleans''

Orleans version: 2.0.0 beta3 from nuget.org

Any suggestion for further diagnosing?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>17/02/2018 3:38:00 PM +00:00</CreatedAt>
    <ClosedAt>2/04/2018 9:09:13 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4051</IssueLabelID>
    <Title>Removed more legacy dependencies.</Title>
    <Description>Removed from:
- Orleans.Cluster.AdoNet
- Orleans.Persistence.AdoNet
- Orleans.Clustering.DynomoDb
- Orleans.Persistence.AzureStorage
- Orleans.Clustering.Consul
- Orleans.Clustering.ZooKeeper</Description>
    <Title_Description>Removed more legacy dependencies. Removed from:
- Orleans.Cluster.AdoNet
- Orleans.Persistence.AdoNet
- Orleans.Clustering.DynomoDb
- Orleans.Persistence.AzureStorage
- Orleans.Clustering.Consul
- Orleans.Clustering.ZooKeeper</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4047</IssueLabelID>
    <Title>Execute lifecycle on OrleansTaskScheduler</Title>
    <Description>
    </Description>
    <Title_Description>Execute lifecycle on OrleansTaskScheduler </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4044</IssueLabelID>
    <Title>Added optional listenerAddress parameter to ConfigureEndpoints()</Title>
    <Description>@benjaminpetit please review.

Instead of using this code:

```
 .Configure&lt;EndpointOptions&gt;(o =&gt;
{
       o.AdvertisedIPAddress = Dns.GetHostAddresses(Dns.GetHostName()).First(s =&gt; s.AddressFamily == AddressFamily.InterNetwork);
       o.SiloPort = 22222;
       o.GatewayPort = 40000;
       o.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any 22222);
       o.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any 40000);
})
```

I'd like it simplified with this:

```
.ConfigureEndpoints(22222 40000 AddressFamily.InterNetwork IPAddress.Any)
```
</Description>
    <Title_Description>Added optional listenerAddress parameter to ConfigureEndpoints() @benjaminpetit please review.

Instead of using this code:

```
 .Configure&lt;EndpointOptions&gt;(o =&gt;
{
       o.AdvertisedIPAddress = Dns.GetHostAddresses(Dns.GetHostName()).First(s =&gt; s.AddressFamily == AddressFamily.InterNetwork);
       o.SiloPort = 22222;
       o.GatewayPort = 40000;
       o.SiloListeningEndpoint = new IPEndPoint(IPAddress.Any 22222);
       o.GatewayListeningEndpoint = new IPEndPoint(IPAddress.Any 40000);
})
```

I'd like it simplified with this:

```
.ConfigureEndpoints(22222 40000 AddressFamily.InterNetwork IPAddress.Any)
```
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4043</IssueLabelID>
    <Title>[Question] With FastKillOnCancel removed whats the guidance on handling CTRL-C fast shutdown.</Title>
    <Description>With FastKillOnCancel removed and AppDomain wired for fast kill what is guidance on handling CTRL-C fast kill?

This way:
```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    Environment.Exit(0);  
                };
```

This way:
```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    var cancellationSource = new CancellationTokenSource();
                    cancellationSource.Cancel();
                    this.silo.StopAsync(cancellationSource.Token);
                };
```

Or this way:

```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    var cancellationSource = new CancellationTokenSource();
                    cancellationSource.Cancel();
                    this.silo.StopAsync(cancellationSource.Token).GetAwaiter().GetResult();
                };
```


</Description>
    <Title_Description>[Question] With FastKillOnCancel removed whats the guidance on handling CTRL-C fast shutdown. With FastKillOnCancel removed and AppDomain wired for fast kill what is guidance on handling CTRL-C fast kill?

This way:
```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    Environment.Exit(0);  
                };
```

This way:
```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    var cancellationSource = new CancellationTokenSource();
                    cancellationSource.Cancel();
                    this.silo.StopAsync(cancellationSource.Token);
                };
```

Or this way:

```
                Console.CancelKeyPress += (sender eventArgs) =&gt;
                {
                    var cancellationSource = new CancellationTokenSource();
                    cancellationSource.Cancel();
                    this.silo.StopAsync(cancellationSource.Token).GetAwaiter().GetResult();
                };
```


</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/02/2018 7:40:27 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4042</IssueLabelID>
    <Title>Persistent stream provider to lifecycle</Title>
    <Description>Pushing this PR out to get eyes on it but it's not passing testing yet.  Still WIP.

Since persistent stream provider is the base for most of our steam providers we couldn't refactor these one at a time.

Following stream providers now use options and lifecycle.
* Azure Queue
* EventHub
* Sqs
* PubSub
* Memory
* Generator
* EventDataGenerator
* Various test providers

TBD:
Fix tests.
Move options to Orleans.Configuration namespace.
Replace DataConnectionStream with ConnectionString in options to conform to other options.
Possibly validators but would like to push that to separate PR given the size of this change.

NOTE:  Persistent stream providers and various adapters are complex and patterns can be improved now that we can inject dependencies but current patterns are best effort port.  Please note where further refactoring in the future is warranted.

Future Refactor:
* Data Adapters
* Inject checkpointing
* Inject generators (for generated streams)
* Inject failure handlers
* Possible adapter or provider builders
</Description>
    <Title_Description>Persistent stream provider to lifecycle Pushing this PR out to get eyes on it but it's not passing testing yet.  Still WIP.

Since persistent stream provider is the base for most of our steam providers we couldn't refactor these one at a time.

Following stream providers now use options and lifecycle.
* Azure Queue
* EventHub
* Sqs
* PubSub
* Memory
* Generator
* EventDataGenerator
* Various test providers

TBD:
Fix tests.
Move options to Orleans.Configuration namespace.
Replace DataConnectionStream with ConnectionString in options to conform to other options.
Possibly validators but would like to push that to separate PR given the size of this change.

NOTE:  Persistent stream providers and various adapters are complex and patterns can be improved now that we can inject dependencies but current patterns are best effort port.  Please note where further refactoring in the future is warranted.

Future Refactor:
* Data Adapters
* Inject checkpointing
* Inject generators (for generated streams)
* Inject failure handlers
* Possible adapter or provider builders
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4039</IssueLabelID>
    <Title>Using a generic method on a grain interface results in needed reference to Orleans.Core from interface project</Title>
    <Description>The generated code when a grain interface has a generic method results in a reference to GenericMethodInvoker which is in Orleans.Core. Following the sample projects the interface project only has references to Orleans.Core.Abstractions and code gen.

While it isn't hard to add the extra reference that may not be the desired fix. 

Looking into what GenericMethodInvoker depends on in core / what it is doing it doesn't really feel like it should be moved. Perhaps an IGenericMethodInvoker would make sense but I'm not sure where the implementation would get injected.</Description>
    <Title_Description>Using a generic method on a grain interface results in needed reference to Orleans.Core from interface project The generated code when a grain interface has a generic method results in a reference to GenericMethodInvoker which is in Orleans.Core. Following the sample projects the interface project only has references to Orleans.Core.Abstractions and code gen.

While it isn't hard to add the extra reference that may not be the desired fix. 

Looking into what GenericMethodInvoker depends on in core / what it is doing it doesn't really feel like it should be moved. Perhaps an IGenericMethodInvoker would make sense but I'm not sure where the implementation would get injected.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4038</IssueLabelID>
    <Title>Grain Bulk Creation</Title>
    <Description>Does anyone have an ideas on how to create grains in batch? We use DynamoDB to store JSON records which I'm hoping to deserialize into Grains. I've tried code in two ways:

1. Do a BatchGetItemAsync and then for each result create a grain and set the value
2. Do a GetItemAsync in the Grain OnActivateAsync() and set the value

Option 1 is much faster by doing the batch but it means I have code in a different grain to do the BatchGetItemsAsync and then set the Grain values. Option 2 leads to cleaner code but is significantly slower.

I would like to have my Grain know how to initialize itself but need to do it some way using Batch.</Description>
    <Title_Description>Grain Bulk Creation Does anyone have an ideas on how to create grains in batch? We use DynamoDB to store JSON records which I'm hoping to deserialize into Grains. I've tried code in two ways:

1. Do a BatchGetItemAsync and then for each result create a grain and set the value
2. Do a GetItemAsync in the Grain OnActivateAsync() and set the value

Option 1 is much faster by doing the batch but it means I have code in a different grain to do the BatchGetItemsAsync and then set the Grain values. Option 2 leads to cleaner code but is significantly slower.

I would like to have my Grain know how to initialize itself but need to do it some way using Batch.</Title_Description>
    <Label>question</Label>
    <Assignee>tinpl</Assignee>
    <CreatedAt>14/02/2018 12:48:47 PM +00:00</CreatedAt>
    <ClosedAt>26/02/2018 1:34:21 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4036</IssueLabelID>
    <Title>Remove FastKillOnCancel setting add ProcessExitHandlingOptions</Title>
    <Description>- Remove FastKillOnCancelKeyPress setting from SiloOptions and also legacy configuration per #3957 
- Add ProcessExitHandlingOptions to configure whether to fast kill on process exit. per #4016 </Description>
    <Title_Description>Remove FastKillOnCancel setting, add ProcessExitHandlingOptions - Remove FastKillOnCancelKeyPress setting from SiloOptions and also legacy configuration per #3957 
- Add ProcessExitHandlingOptions to configure whether to fast kill on process exit. per #4016 </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4034</IssueLabelID>
    <Title>PerformanceTuningOptions</Title>
    <Description>Merge ServicePointOptions and ThreadPoolOptions into one option `PerformanceTuningOptions` and keep it in core. Reasons as follows

They exists for configuring environment to be optimal for orleans cluster performance. Yes none of the target they configure is maintained by orleans but we think configure them to be at optimal  values is orleans’s responsibility because they are essential for orleans performance. If we don’t configure them the default settings for ThreadPool or ServicePointManager greatly affects performance especially ThreadPool settings. If we ask our user to configure them then we run risks of low discoverability of the need to configure them and mysterious performance drop after adopting 2.0. 

Default MinThreads for ThreadPool is small while Orleans needs hundreds of threads to have optimal performance. 
And also ServicePointOptions are not just for optimization when using AzureStorage. The settings there are for optimizing ServicePointManager to handle small requests to our understanding. See blog post https://blogs.msdn.microsoft.com/windowsazurestorage/2010/06/25/nagles-algorithm-is-not-friendly-towards-small-requests/ for more info. 

So based on above reasons. We merge those two options into one with default values. 
</Description>
    <Title_Description>PerformanceTuningOptions Merge ServicePointOptions and ThreadPoolOptions into one option `PerformanceTuningOptions` and keep it in core. Reasons as follows

They exists for configuring environment to be optimal for orleans cluster performance. Yes none of the target they configure is maintained by orleans but we think configure them to be at optimal  values is orleans’s responsibility because they are essential for orleans performance. If we don’t configure them the default settings for ThreadPool or ServicePointManager greatly affects performance especially ThreadPool settings. If we ask our user to configure them then we run risks of low discoverability of the need to configure them and mysterious performance drop after adopting 2.0. 

Default MinThreads for ThreadPool is small while Orleans needs hundreds of threads to have optimal performance. 
And also ServicePointOptions are not just for optimization when using AzureStorage. The settings there are for optimizing ServicePointManager to handle small requests to our understanding. See blog post https://blogs.msdn.microsoft.com/windowsazurestorage/2010/06/25/nagles-algorithm-is-not-friendly-towards-small-requests/ for more info. 

So based on above reasons. We merge those two options into one with default values. 
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4033</IssueLabelID>
    <Title>Endpointoptions default values</Title>
    <Description>* Add default values for `EndpointOptions`
* Add ip value check in the validator</Description>
    <Title_Description>Endpointoptions default values * Add default values for `EndpointOptions`
* Add ip value check in the validator</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4032</IssueLabelID>
    <Title>Add more logging to AzureTableGrainStorage init Add ConfiguratorValidator</Title>
    <Description>- Add more logging to AzureTableGrainStorage init to improve debugging experience
- Add Configuration validator to  `AzureTableGrainStorageOptions`
- rename `DataConnectionString` to be `ConnectionString`. To be consistent with the `ConnectionString` in AzureGatewaylistprovider and AzureMembershipProvier</Description>
    <Title_Description>Add more logging to AzureTableGrainStorage init, Add ConfiguratorValidator - Add more logging to AzureTableGrainStorage init to improve debugging experience
- Add Configuration validator to  `AzureTableGrainStorageOptions`
- rename `DataConnectionString` to be `ConnectionString`. To be consistent with the `ConnectionString` in AzureGatewaylistprovider and AzureMembershipProvier</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4031</IssueLabelID>
    <Title>Move Azure blob storage to options and lifecycle pattern</Title>
    <Description>Sorry for the single big commit but it was a bit hard to split.</Description>
    <Title_Description>Move Azure blob storage to options and lifecycle pattern Sorry for the single big commit but it was a bit hard to split.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4030</IssueLabelID>
    <Title>Move remaining *Options classes to Orleans.Configuration namespace</Title>
    <Description>
    </Description>
    <Title_Description>Move remaining *Options classes to Orleans.Configuration namespace </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4028</IssueLabelID>
    <Title>New grain Implementation is not loaded after its first upgrade</Title>
    <Description>We are running Orleans 2.0 on ServiceFabric cluster. When we try to add a new interface/implementation of a grain or change the name of existing interface/implementation it will fail with error message:

&gt; {"error":{"innererror":"System.ArgumentException: Cannot find an implementation class for grain interface: Fog.GrainInterfaces.IFogFailureManagementGrain. Make sure the grain assembly was correctly deployed and loaded in the silo.
  at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
  at Orleans.GrainFactory.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
  at Orleans.ClusterClient.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
  at Fog.GrainInterfaces.GrainFactoryExtension.GetFogFailureManagementGrainReference(IGrainFactory grainFactory Guid key) in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.GrainInterfaces\\GrainFactoryExtension.cs:line 37
  at Fog.Frontend.Controllers.BatchController.ThrowIfFailureOn(AzureRegion regionId String accountName String poolId String methodName) in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.Frontend\\Controllers\\BatchController.cs:line 49
  at Fog.Frontend.Controllers.BatchController.&lt;CreatePool&gt;d__6.MoveNext() in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.Frontend\\Controllers\\BatchController.cs:line 186\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Threading.Tasks.TaskHelpersExtensions.&lt;CastToObject&gt;d__3`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at Microsoft.Gaming.Common.WebApi.RootMessageHandler.&lt;SendAsync&gt;d__5.MoveNext() in C:\\BA\\185\\s\\src\\Common\\Common.WebApi\\RootMessageHandler.cs:line 52""code":null"message":null}}

3 scenarios:
1. If we deploy the new code cleanly from scratch everything is working
2. If we have old version in ServiceFabric and we make an upgrade with this new version then new grain is not loaded
3. If we have old version in ServiceFabric and we make an upgrade with this new version and upgrade again everything is working. New grain is loaded. This is just to make the same upgrade twice.</Description>
    <Title_Description>New grain Implementation is not loaded after its first upgrade We are running Orleans 2.0 on ServiceFabric cluster. When we try to add a new interface/implementation of a grain or change the name of existing interface/implementation it will fail with error message:

&gt; {"error":{"innererror":"System.ArgumentException: Cannot find an implementation class for grain interface: Fog.GrainInterfaces.IFogFailureManagementGrain. Make sure the grain assembly was correctly deployed and loaded in the silo.
  at Orleans.GrainFactory.GetGrainClassData(Type interfaceType String grainClassNamePrefix)
  at Orleans.GrainFactory.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
  at Orleans.ClusterClient.GetGrain[TGrainInterface](Guid primaryKey String grainClassNamePrefix)
  at Fog.GrainInterfaces.GrainFactoryExtension.GetFogFailureManagementGrainReference(IGrainFactory grainFactory Guid key) in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.GrainInterfaces\\GrainFactoryExtension.cs:line 37
  at Fog.Frontend.Controllers.BatchController.ThrowIfFailureOn(AzureRegion regionId String accountName String poolId String methodName) in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.Frontend\\Controllers\\BatchController.cs:line 49
  at Fog.Frontend.Controllers.BatchController.&lt;CreatePool&gt;d__6.MoveNext() in C:\\BA\\185\\s\\src\\ControlPlane\\Fog.Frontend\\Controllers\\BatchController.cs:line 186\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Threading.Tasks.TaskHelpersExtensions.&lt;CastToObject&gt;d__3`1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Controllers.ApiControllerActionInvoker.&lt;InvokeActionAsyncCore&gt;d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Controllers.ActionFilterResult.&lt;ExecuteAsync&gt;d__2.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Web.Http.Dispatcher.HttpControllerDispatcher.&lt;SendAsync&gt;d__1.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---
  at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
  at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
  at Microsoft.Gaming.Common.WebApi.RootMessageHandler.&lt;SendAsync&gt;d__5.MoveNext() in C:\\BA\\185\\s\\src\\Common\\Common.WebApi\\RootMessageHandler.cs:line 52""code":null"message":null}}

3 scenarios:
1. If we deploy the new code cleanly from scratch everything is working
2. If we have old version in ServiceFabric and we make an upgrade with this new version then new grain is not loaded
3. If we have old version in ServiceFabric and we make an upgrade with this new version and upgrade again everything is working. New grain is loaded. This is just to make the same upgrade twice.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4026</IssueLabelID>
    <Title>Add startup tasks to replace deprecated bootstrap providers</Title>
    <Description>Resolves #4014

Developers can register an implementation of `IStartupTask` and perform operations such as calling grains from within the `OnStarted()` method.

Added a new `SystemTarget` for the purpose of scheduling startup tasks. I didn't extend scheduling to all lifecycle participants because the scheduler itself is only started at a certain silo lifecycle stage and therefore wont pump tasks before then. If this is an issue maybe someone has an idea for how to solve it?

See the tests at the bottom for usage.</Description>
    <Title_Description>Add startup tasks to replace deprecated bootstrap providers Resolves #4014

Developers can register an implementation of `IStartupTask` and perform operations such as calling grains from within the `OnStarted()` method.

Added a new `SystemTarget` for the purpose of scheduling startup tasks. I didn't extend scheduling to all lifecycle participants because the scheduler itself is only started at a certain silo lifecycle stage and therefore wont pump tasks before then. If this is an issue maybe someone has an idea for how to solve it?

See the tests at the bottom for usage.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4024</IssueLabelID>
    <Title>Add a configuration validator and options formatter for EndpointOptions</Title>
    <Description>@benjaminpetit this might also need a default value for `AdvertisedIPAddress` but I'm not sure if the default should be `Any` `Localhost` or something else.

</Description>
    <Title_Description>Add a configuration validator and options formatter for EndpointOptions @benjaminpetit this might also need a default value for `AdvertisedIPAddress` but I'm not sure if the default should be `Any` `Localhost` or something else.

</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4021</IssueLabelID>
    <Title>[Question] Running beta 3 on azure worker role</Title>
    <Description>Hello! I'm trying the latest beta of 2.0.0 on a azure worker role but I can not even start the silo the error thrown is the next one 

OrleansMessageRejectionException: Silo S10.43.44.207:54629:256167661 is rejecting message: Request S10.43.44.207:0:256167661???/00000013@S00000013-&gt;S10.43.44.207:0:256167661???/dc13e0a2@Sdc13e0a2 #5: global::Orleans.Streams.IPersistentStreamPullingManager:Initialize(). Reason = Recent (00:00:00.7408936 ago at 2018-02-12 21:41:16.135 GMT) connection failure trying to reach target silo S10.43.44.207:0:256167661. Going to drop Request msg 5 without sending. CONNECTION_RETRY_DELAY = 00:00:01.

and the configuration I'm using the next config 
```
var config = AzureSilo.DefaultConfiguration();
config.AddAzureTableStorageProvider();
config.AddAzureQueueStreamProviderV2("StreamProvider");
config.AddMemoryStorageProvider("PubSubStore");
config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable;
```</Description>
    <Title_Description>[Question] Running beta 3 on azure worker role Hello! I'm trying the latest beta of 2.0.0 on a azure worker role but I can not even start the silo the error thrown is the next one 

OrleansMessageRejectionException: Silo S10.43.44.207:54629:256167661 is rejecting message: Request S10.43.44.207:0:256167661???/00000013@S00000013-&gt;S10.43.44.207:0:256167661???/dc13e0a2@Sdc13e0a2 #5: global::Orleans.Streams.IPersistentStreamPullingManager:Initialize(). Reason = Recent (00:00:00.7408936 ago at 2018-02-12 21:41:16.135 GMT) connection failure trying to reach target silo S10.43.44.207:0:256167661. Going to drop Request msg 5 without sending. CONNECTION_RETRY_DELAY = 00:00:01.

and the configuration I'm using the next config 
```
var config = AzureSilo.DefaultConfiguration();
config.AddAzureTableStorageProvider();
config.AddAzureQueueStreamProviderV2("StreamProvider");
config.AddMemoryStorageProvider("PubSubStore");
config.Globals.ReminderServiceType = GlobalConfiguration.ReminderServiceProviderType.AzureTable;
```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4020</IssueLabelID>
    <Title>Move Orleans.Core and Orleans.Runtime options to Orleans.Configuration namespace</Title>
    <Description>This is for #3956 - move `Orleans.Core` and `Orleans.Runtime` options from `Orleans.Hosting` to `Orleans.Configuration` namespace.</Description>
    <Title_Description>Move Orleans.Core and Orleans.Runtime options to Orleans.Configuration namespace This is for #3956 - move `Orleans.Core` and `Orleans.Runtime` options from `Orleans.Hosting` to `Orleans.Configuration` namespace.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4019</IssueLabelID>
    <Title>Rename ProxiedMessageCenter to ClientMessageCenter</Title>
    <Description>Rename `ProxiedMessageCenter` to `ClientMessageCenter`</Description>
    <Title_Description>Rename ProxiedMessageCenter to ClientMessageCenter Rename `ProxiedMessageCenter` to `ClientMessageCenter`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4018</IssueLabelID>
    <Title>More cleanup of types</Title>
    <Description>Move `SystemStatuc` enum to `Orleans.Runtime`.
Remove `MetricsTableWriteInterval` from `StatisticsOptions` and all downstream dependencies.
Move `TransactionsOptions` to Orleans.Runtime to use it for transactions' `DefaultMetricWritePeriod`.</Description>
    <Title_Description>More cleanup of types Move `SystemStatuc` enum to `Orleans.Runtime`.
Remove `MetricsTableWriteInterval` from `StatisticsOptions` and all downstream dependencies.
Move `TransactionsOptions` to Orleans.Runtime to use it for transactions' `DefaultMetricWritePeriod`.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4016</IssueLabelID>
    <Title>Add a config option to not intercept AppDomain.CurrentDomain.ProcessExit in Silo</Title>
    <Description>Dev that want to intercept `AppDomain.CurrentDomain.ProcessExit` to control silo shutdown currently cannot to it reliably since in `Silo` we always listen to this event and do a "FastKill".

We should add an option to disable this behavior but let it by default
</Description>
    <Title_Description>Add a config option to not intercept AppDomain.CurrentDomain.ProcessExit in Silo Dev that want to intercept `AppDomain.CurrentDomain.ProcessExit` to control silo shutdown currently cannot to it reliably since in `Silo` we always listen to this event and do a "FastKill".

We should add an option to disable this behavior but let it by default
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4015</IssueLabelID>
    <Title>Logger is not used currently in Orleans.Runtime.Dispatcher</Title>
    <Description>There is a bug in the usage of the logger in Orleans.Runtime.Dispatcher and possibly in other places.
For example the LoggerExtensions.Info method signature is:
`internal static void Info(this Logger logger ErrorCode errorCode string format params object[] args)`
But it is used as follows
`logger.Info(ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation String.Format("Intermediate NonExistentActivation for message {0}" message) ex);`
So the params are as follows:
ErrorCode errorCode =  ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation
string format = String.Format("Intermediate NonExistentActivation for message {0}" message)
params object[] args = ex

This means that we try to call string.Format on the result of this string format and the exception as args.
In most cases this is not a major problem as it just means that the exception is never logged.
It is a big issue if the grain key contains curly braces(maybe not the best idea but it's the current implementation) the call fails over System.FormatException.
This is the call stack:

`System.FormatException: Input string was not in a correct format.    at System.Text.StringBuilder.AppendFormat(IFormatProvider provider String format Object[] args)    at System.String.Format(IFormatProvider provider String format Object[] args)    at Orleans.Runtime.LoggerImpl.WriteLogMessage(Int32 errorCode Severity sev String format Object[] args Exception exception)    at Orleans.Runtime.LoggerExtensions.Info(Logger logger ErrorCode errorCode String format Object[] args)    at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)`




</Description>
    <Title_Description>Logger is not used currently in Orleans.Runtime.Dispatcher There is a bug in the usage of the logger in Orleans.Runtime.Dispatcher and possibly in other places.
For example the LoggerExtensions.Info method signature is:
`internal static void Info(this Logger logger ErrorCode errorCode string format params object[] args)`
But it is used as follows
`logger.Info(ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation String.Format("Intermediate NonExistentActivation for message {0}" message) ex);`
So the params are as follows:
ErrorCode errorCode =  ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation
string format = String.Format("Intermediate NonExistentActivation for message {0}" message)
params object[] args = ex

This means that we try to call string.Format on the result of this string format and the exception as args.
In most cases this is not a major problem as it just means that the exception is never logged.
It is a big issue if the grain key contains curly braces(maybe not the best idea but it's the current implementation) the call fails over System.FormatException.
This is the call stack:

`System.FormatException: Input string was not in a correct format.    at System.Text.StringBuilder.AppendFormat(IFormatProvider provider String format Object[] args)    at System.String.Format(IFormatProvider provider String format Object[] args)    at Orleans.Runtime.LoggerImpl.WriteLogMessage(Int32 errorCode Severity sev String format Object[] args Exception exception)    at Orleans.Runtime.LoggerExtensions.Info(Logger logger ErrorCode errorCode String format Object[] args)    at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)`




</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4014</IssueLabelID>
    <Title>[Question] - How to build bootstrap providers without legacy package?</Title>
    <Description>Hi

I try to figure out how to build a bootstrap provider without the legacy stuff in beta3.

My attempt:

    public sealed class EventConsumerBootstrap : ILifecycleParticipant&lt;ISiloLifecycle&gt;
    {
        private readonly IGrainFactory grainFactory;

        public EventConsumerBootstrap(IGrainFactory grainFactory)
        {
            this.grainFactory = grainFactory;
        }

        public void Participate(ISiloLifecycle lifecycle)
        {
            lifecycle.Subscribe(SiloLifecycleStage.SiloActive ct =&gt;
            {
                var grain = grainFactory.GetGrain&lt;IEventConsumerManagerGrain&gt;("Default");

                return grain.ActivateAsync();
            });
        }
    }

But the problem is that I have no access to the scheduler. The legacy package uses the OrleansScheduler which is internal. Therefore my call to the grain fails.</Description>
    <Title_Description>[Question] - How to build bootstrap providers without legacy package? Hi

I try to figure out how to build a bootstrap provider without the legacy stuff in beta3.

My attempt:

    public sealed class EventConsumerBootstrap : ILifecycleParticipant&lt;ISiloLifecycle&gt;
    {
        private readonly IGrainFactory grainFactory;

        public EventConsumerBootstrap(IGrainFactory grainFactory)
        {
            this.grainFactory = grainFactory;
        }

        public void Participate(ISiloLifecycle lifecycle)
        {
            lifecycle.Subscribe(SiloLifecycleStage.SiloActive ct =&gt;
            {
                var grain = grainFactory.GetGrain&lt;IEventConsumerManagerGrain&gt;("Default");

                return grain.ActivateAsync();
            });
        }
    }

But the problem is that I have no access to the scheduler. The legacy package uses the OrleansScheduler which is internal. Therefore my call to the grain fails.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4013</IssueLabelID>
    <Title>[Question] - Grain Placement</Title>
    <Description>I am attempting to model a cluster of Hyper-V servers where I want a Grain to represent a particular Hyper-V image but where that Hyper-V image can only exist in silo's where the HyperVisor actually has that image available!

For example the cluster consists of:

1. Silo A for HyperVisor machine A has Images "A" and "B"
2. Silo B for HyperVisor machine B has Images "A" "B" and "C"

When an orleans client requests the grain for Image "A" - I'd like this grain to be activated in either Silo 1 or 2. 

When an orleans client requests the grain for Image "C" - I'd like this grain to be activate in Silo B because thats the only silo where the image is available.

Is it possible for me to achieve something like this? Or is this kind of thing frowned upon? (If so any suggestions on how I would change the model would be welcome.

Thanks
</Description>
    <Title_Description>[Question] - Grain Placement I am attempting to model a cluster of Hyper-V servers where I want a Grain to represent a particular Hyper-V image but where that Hyper-V image can only exist in silo's where the HyperVisor actually has that image available!

For example the cluster consists of:

1. Silo A for HyperVisor machine A has Images "A" and "B"
2. Silo B for HyperVisor machine B has Images "A" "B" and "C"

When an orleans client requests the grain for Image "A" - I'd like this grain to be activated in either Silo 1 or 2. 

When an orleans client requests the grain for Image "C" - I'd like this grain to be activate in Silo B because thats the only silo where the image is available.

Is it possible for me to achieve something like this? Or is this kind of thing frowned upon? (If so any suggestions on how I would change the model would be welcome.

Thanks
</Title_Description>
    <Label>question</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4012</IssueLabelID>
    <Title>Not support generic type on Grain. </Title>
    <Description>Hi there is there any way to support generic type on an Grain? e.g.
```fsharp
    type GameGrain&lt;'GameState 'GameAction&gt; (engine: IGameEngine&lt;'GameState 'GameAction&gt;) = 
        inherit Grain ()

        interface IGame&lt;'GameState 'GameAction&gt; with
            member __.GetState () =
                engine.Zero () |&gt; Task.FromResult

            member __.Play prevState action = 
                engine.Reducer prevState action |&gt; Task.FromResult
```
** https://github.com/darting/orleans-fsharp/blob/master/src/Grains/Library.fs#L19-L27

If I try to get a grain uses:
```fsharp
let grain = client.GetGrain&lt;IGame&lt;Game1.GameState Game1.GameAction&gt;&gt; "darting"
```
** https://github.com/darting/orleans-fsharp/blob/master/src/Client/Program.fs#L21
Orleans will throw exception
```
Cannot instantiate generic class Grains.Say.GameGrain`2[[System.Int32 System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e][Games.Game1+GameAction Games Version=0.0.0.0 Culture=neutral PublicKeyToken=null]]
System.ArgumentException: An item with the same key has already been added. Key: Grains.Say.GameGrain`2
   at System.ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(Object key)
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key TValue value InsertionBehavior behavior)
   at Orleans.Runtime.GrainTypeManager.get_Item(String className)
```


here is my test repo
https://github.com/darting/orleans-fsharp/blob/master/src/Client/Program.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Grains/Library.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Host/Program.fs#L12

Thanks</Description>
    <Title_Description>Not support generic type on Grain.  Hi there is there any way to support generic type on an Grain? e.g.
```fsharp
    type GameGrain&lt;'GameState 'GameAction&gt; (engine: IGameEngine&lt;'GameState 'GameAction&gt;) = 
        inherit Grain ()

        interface IGame&lt;'GameState 'GameAction&gt; with
            member __.GetState () =
                engine.Zero () |&gt; Task.FromResult

            member __.Play prevState action = 
                engine.Reducer prevState action |&gt; Task.FromResult
```
** https://github.com/darting/orleans-fsharp/blob/master/src/Grains/Library.fs#L19-L27

If I try to get a grain uses:
```fsharp
let grain = client.GetGrain&lt;IGame&lt;Game1.GameState Game1.GameAction&gt;&gt; "darting"
```
** https://github.com/darting/orleans-fsharp/blob/master/src/Client/Program.fs#L21
Orleans will throw exception
```
Cannot instantiate generic class Grains.Say.GameGrain`2[[System.Int32 System.Private.CoreLib Version=4.0.0.0 Culture=neutral PublicKeyToken=7cec85d7bea7798e][Games.Game1+GameAction Games Version=0.0.0.0 Culture=neutral PublicKeyToken=null]]
System.ArgumentException: An item with the same key has already been added. Key: Grains.Say.GameGrain`2
   at System.ThrowHelper.ThrowAddingDuplicateWithKeyArgumentException(Object key)
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key TValue value InsertionBehavior behavior)
   at Orleans.Runtime.GrainTypeManager.get_Item(String className)
```


here is my test repo
https://github.com/darting/orleans-fsharp/blob/master/src/Client/Program.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Grains/Library.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Host/Program.fs#L12

Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4010</IssueLabelID>
    <Title>[Question] - SqlServerStorage provider issue</Title>
    <Description>I am trying to get sqlserver storage working and on startup I am getting this exception:

&gt; OrleansException: Provider of type Orleans.Storage.AdoNetStorageProvider name AdoNetStorage was not loaded.Please check that you deployed the assembly in which the provider class is defined to the execution folder.

I am referencing these packages:

```xml
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.CommandLine" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Logging.Console" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Clustering.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansSQLUtils" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AzureStorage" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Reminders.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="OrleansDashboard" Version="2.0.0-beta4" /&gt;
    &lt;PackageReference Include="System.Data.SqlClient" Version="4.4.2" /&gt;

```

Here is my method for configuration:

```
              var cluster = new ClusterConfiguration();          
            cluster.LoadFromFile("OrleansConfiguration.dev.xml");        
            return cluster;

```

and:

```xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;OrleansConfiguration xmlns="urn:orleans"&gt;
  &lt;Globals&gt;
    
     &lt;StorageProviders&gt;
      &lt;Provider Type="Orleans.Storage.AdoNetStorageProvider"
                Name="AdoNetStorage"
                AdoInvariant="System.Data.SqlClient"
                DataConnectionString="Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True"
                UseJsonFormat="true" /&gt;
    &lt;/StorageProviders&gt;
    
    &lt;SystemStore SystemStoreType ="SqlServer"
               DeploymentId="OrleansTest"
               DataConnectionString="Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True" AdoInvariant="System.Data.SqlClient" /&gt;
    
  &lt;/Globals&gt;
  &lt;Defaults&gt;
    &lt;Networking Address="localhost" Port="11111" /&gt;
    &lt;ProxyingGateway Address="localhost" Port="30000" /&gt;
  &lt;/Defaults&gt;
&lt;/OrleansConfiguration&gt;

```

Not sure what I am missing.. the `Microsoft.Orleans.Persistence.AdoNet` package contains the `Orleans.Storage.AdoNetStorageProvider` type and its in my bin directory. 

I have also tried adding the assembly as an application part like this but same error:

```
  partManger.AddApplicationPart(typeof(Orleans.Storage.AdoNetStorageProvider).Assembly);

```</Description>
    <Title_Description>[Question] - SqlServerStorage provider issue I am trying to get sqlserver storage working and on startup I am getting this exception:

&gt; OrleansException: Provider of type Orleans.Storage.AdoNetStorageProvider name AdoNetStorage was not loaded.Please check that you deployed the assembly in which the provider class is defined to the execution folder.

I am referencing these packages:

```xml
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.CommandLine" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Extensions.Logging.Console" Version="2.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Clustering.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansRuntime" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.OrleansSQLUtils" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Persistence.AzureStorage" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="Microsoft.Orleans.Reminders.AdoNet" Version="2.0.0-beta3" /&gt;
    &lt;PackageReference Include="OrleansDashboard" Version="2.0.0-beta4" /&gt;
    &lt;PackageReference Include="System.Data.SqlClient" Version="4.4.2" /&gt;

```

Here is my method for configuration:

```
              var cluster = new ClusterConfiguration();          
            cluster.LoadFromFile("OrleansConfiguration.dev.xml");        
            return cluster;

```

and:

```xml

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;OrleansConfiguration xmlns="urn:orleans"&gt;
  &lt;Globals&gt;
    
     &lt;StorageProviders&gt;
      &lt;Provider Type="Orleans.Storage.AdoNetStorageProvider"
                Name="AdoNetStorage"
                AdoInvariant="System.Data.SqlClient"
                DataConnectionString="Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True"
                UseJsonFormat="true" /&gt;
    &lt;/StorageProviders&gt;
    
    &lt;SystemStore SystemStoreType ="SqlServer"
               DeploymentId="OrleansTest"
               DataConnectionString="Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Orleans;Integrated Security=True;Pooling=False;Max Pool Size=200;Asynchronous Processing=True;MultipleActiveResultSets=True" AdoInvariant="System.Data.SqlClient" /&gt;
    
  &lt;/Globals&gt;
  &lt;Defaults&gt;
    &lt;Networking Address="localhost" Port="11111" /&gt;
    &lt;ProxyingGateway Address="localhost" Port="30000" /&gt;
  &lt;/Defaults&gt;
&lt;/OrleansConfiguration&gt;

```

Not sure what I am missing.. the `Microsoft.Orleans.Persistence.AdoNet` package contains the `Orleans.Storage.AdoNetStorageProvider` type and its in my bin directory. 

I have also tried adding the assembly as an application part like this but same error:

```
  partManger.AddApplicationPart(typeof(Orleans.Storage.AdoNetStorageProvider).Assembly);

```</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4008</IssueLabelID>
    <Title>Intermittent failures of ElasticityTest_AllSilosOverloaded test</Title>
    <Description>`ElasticityTest_AllSilosOverloaded` is failing intermittently by getting an `GatewayTooBusyException` when trying to execute
```csharp
await taintedGrainSecondary.LatchOverloaded();
```
I suspect this is happening due to a race when making a call to a grain in the second silo via the gateway in the first silo that is getting set to the overloaded state on the previous line.</Description>
    <Title_Description>Intermittent failures of ElasticityTest_AllSilosOverloaded test `ElasticityTest_AllSilosOverloaded` is failing intermittently by getting an `GatewayTooBusyException` when trying to execute
```csharp
await taintedGrainSecondary.LatchOverloaded();
```
I suspect this is happening due to a race when making a call to a grain in the second silo via the gateway in the first silo that is getting set to the overloaded state on the previous line.</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>11/02/2018 2:00:53 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4007</IssueLabelID>
    <Title>Update Docker-Deployment.md</Title>
    <Description>Including reference to OrleansContrib\Orleans.Clustering.Kubernetes</Description>
    <Title_Description>Update Docker-Deployment.md Including reference to OrleansContrib\Orleans.Clustering.Kubernetes</Title_Description>
    <Label>documentation</Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4003</IssueLabelID>
    <Title>Improved error logging of legacy systems</Title>
    <Description>
    </Description>
    <Title_Description>Improved error logging of legacy systems </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>4002</IssueLabelID>
    <Title>Upgrade Suggestions - How to Handle Persisted Grain States</Title>
    <Description>I have been trying to upgrade from v1.2.2 to v1.5.3 but I am having some issues. Our code persists instances of grains using [Orleans.StorageProviders.SimpleSQLServerStorage](https://github.com/OrleansContrib/Orleans.StorageProviders.SimpleSQLServerStorage) and after upgrading Orleans and SimpleSQLServerStorage the grains fail to deserialize:
`!!!!!!!!!! Error clearing: GrainType=Orleans.Runtime.Versions.VersionStoreGrain GrainId=GrainReference:*grn/13BAB4D8/00000000+OrleansTest ETag= in to DataSource=`

The grains were serialized as binary to a SQL Server DB before VersionStoreGrain was added so the deserialize always fails and I can't find an easy way to add a fallback serializer to the old 1.2.2 way. This could work for new/clean installs but existing installs of our current codebase would require deleting all of the stored grains before upgrading which requires too much manual work to document and re-create all the grain configurations during an upgrade.

I really like the recent work that was done to add versioning to the grains which addresses one of our main limitations of using v1.2.2.  Does anyone have any suggestions on how they have handled these types of situations?</Description>
    <Title_Description>Upgrade Suggestions - How to Handle Persisted Grain States I have been trying to upgrade from v1.2.2 to v1.5.3 but I am having some issues. Our code persists instances of grains using [Orleans.StorageProviders.SimpleSQLServerStorage](https://github.com/OrleansContrib/Orleans.StorageProviders.SimpleSQLServerStorage) and after upgrading Orleans and SimpleSQLServerStorage the grains fail to deserialize:
`!!!!!!!!!! Error clearing: GrainType=Orleans.Runtime.Versions.VersionStoreGrain GrainId=GrainReference:*grn/13BAB4D8/00000000+OrleansTest ETag= in to DataSource=`

The grains were serialized as binary to a SQL Server DB before VersionStoreGrain was added so the deserialize always fails and I can't find an easy way to add a fallback serializer to the old 1.2.2 way. This could work for new/clean installs but existing installs of our current codebase would require deleting all of the stored grains before upgrading which requires too much manual work to document and re-create all the grain configurations during an upgrade.

I really like the recent work that was done to add versioning to the grains which addresses one of our main limitations of using v1.2.2.  Does anyone have any suggestions on how they have handled these types of situations?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3998</IssueLabelID>
    <Title>Removed Core.Legacy dependency some azure extension pacakges</Title>
    <Description>Removed Orleans.Core.Legacy dependency from:
Orleans.Cluster.AzureStorage
Orleans.Reminders.AzureStorage
Orleans.Streaming.Eventhubs</Description>
    <Title_Description>Removed Core.Legacy dependency some azure extension pacakges Removed Orleans.Core.Legacy dependency from:
Orleans.Cluster.AzureStorage
Orleans.Reminders.AzureStorage
Orleans.Streaming.Eventhubs</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3996</IssueLabelID>
    <Title>Skip CallThatShouldHaveBeenDroppedNotExecutedTest for now</Title>
    <Description>#3995 is tracking failures of the test.</Description>
    <Title_Description>Skip CallThatShouldHaveBeenDroppedNotExecutedTest for now #3995 is tracking failures of the test.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3995</IssueLabelID>
    <Title>Intermittent failures of CallThatShouldHaveBeenDroppedNotExecutedTest</Title>
    <Description>&gt;Assert.Throws() Failure\r\nExpected: typeof(System.TimeoutException)\r\nActual: (No exception was thrown)

Need to investigate.</Description>
    <Title_Description>Intermittent failures of CallThatShouldHaveBeenDroppedNotExecutedTest &gt;Assert.Throws() Failure\r\nExpected: typeof(System.TimeoutException)\r\nActual: (No exception was thrown)

Need to investigate.</Title_Description>
    <Label>P3</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>8/02/2018 7:35:54 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3994</IssueLabelID>
    <Title>Skip faling tests until they are fixed</Title>
    <Description>Skip DelayedQueueRebalancingTests_* for now.
#3993 is tracking fixing of these tests.</Description>
    <Title_Description>Skip faling tests until they are fixed Skip DelayedQueueRebalancingTests_* for now.
#3993 is tracking fixing of these tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3993</IssueLabelID>
    <Title>Test failures in DelayedQueueRebalancingTests_*</Title>
    <Description>DelayedQueueRebalancingTests_2 seems to be failing consistently with errors like the following:
&gt;Assert.Equal() Failure\r\nExpected: 2\r\nActual: 4

&gt;Assert.Equal() Failure\r\nExpected: 2\r\nActual: 3

and sometimes
&gt;Orleans.Runtime.OrleansMessageRejectionException : Silo S127.0.0.1:28513:255762038 is rejecting message: Request S127.0.0.1:28513:255762038*stg/14/0000000e@S0000000e-&gt;S127.0.0.1:28514:255762039*stg/10/0000000a@S0000000a #110: . Reason = Recent (00:00:00.0468768 ago at 2018-02-08 05:00:52.321 GMT) connection failure trying to reach target silo S127.0.0.1:28514:255762039. Going to drop Request msg 110 without sending. CONNECTION_RETRY_DELAY = 00:00:01.

DelayedQueueRebalancingTests_1 is failing infrequently
&gt;Orleans.Runtime.OrleansMessageRejectionException : Silo S127.0.0.1:22815:255804984 is rejecting message: Request S127.0.0.1:22815:255804984*stg/10/0000000a@S0000000a-&gt;S127.0.0.1:22816:255804985*stg/10/0000000a@S0000000a #215: . Reason = Recent (00:00:00 ago at 2018-02-08 16:56:43.128 GMT) connection failure trying to reach target silo S127.0.0.1:22816:255804985. Going to drop Request msg 215 without sending. CONNECTION_RETRY_DELAY = 00:00:01.</Description>
    <Title_Description>Test failures in DelayedQueueRebalancingTests_* DelayedQueueRebalancingTests_2 seems to be failing consistently with errors like the following:
&gt;Assert.Equal() Failure\r\nExpected: 2\r\nActual: 4

&gt;Assert.Equal() Failure\r\nExpected: 2\r\nActual: 3

and sometimes
&gt;Orleans.Runtime.OrleansMessageRejectionException : Silo S127.0.0.1:28513:255762038 is rejecting message: Request S127.0.0.1:28513:255762038*stg/14/0000000e@S0000000e-&gt;S127.0.0.1:28514:255762039*stg/10/0000000a@S0000000a #110: . Reason = Recent (00:00:00.0468768 ago at 2018-02-08 05:00:52.321 GMT) connection failure trying to reach target silo S127.0.0.1:28514:255762039. Going to drop Request msg 110 without sending. CONNECTION_RETRY_DELAY = 00:00:01.

DelayedQueueRebalancingTests_1 is failing infrequently
&gt;Orleans.Runtime.OrleansMessageRejectionException : Silo S127.0.0.1:22815:255804984 is rejecting message: Request S127.0.0.1:22815:255804984*stg/10/0000000a@S0000000a-&gt;S127.0.0.1:22816:255804985*stg/10/0000000a@S0000000a #215: . Reason = Recent (00:00:00 ago at 2018-02-08 16:56:43.128 GMT) connection failure trying to reach target silo S127.0.0.1:22816:255804985. Going to drop Request msg 215 without sending. CONNECTION_RETRY_DELAY = 00:00:01.</Title_Description>
    <Label>test-issue</Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3992</IssueLabelID>
    <Title>Fix DelayedQueueRebalancingTests</Title>
    <Description>`DelayedQueueRebalancingTests` started to fail intermittently. we skipped the two tests for 2.0 rc. But need to fix it for 2.0 </Description>
    <Title_Description>Fix DelayedQueueRebalancingTests `DelayedQueueRebalancingTests` started to fail intermittently. we skipped the two tests for 2.0 rc. But need to fix it for 2.0 </Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3989</IssueLabelID>
    <Title>Proxy Gateway should honor address settings and allow localhost calls from client</Title>
    <Description>```
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any 40000);
```
This setting does not work because the Gateway endpoint will always be set to the IP address of the silo.
I sidecar scenarios we want to be able to call the gateway as localhost:40000 by setting the service to IPAddress.Any or IPAddress.Loopback.
This fix allows the Gateway address setting to be honored. If the IPAddress is set to None then we function same as today by copying Silo address to Gateway address.</Description>
    <Title_Description>Proxy Gateway should honor address settings and allow localhost calls from client ```
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any 40000);
```
This setting does not work because the Gateway endpoint will always be set to the IP address of the silo.
I sidecar scenarios we want to be able to call the gateway as localhost:40000 by setting the service to IPAddress.Any or IPAddress.Loopback.
This fix allows the Gateway address setting to be honored. If the IPAddress is set to None then we function same as today by copying Silo address to Gateway address.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3984</IssueLabelID>
    <Title>Gateway cannot be called using localhost when running in non-local silo mode.  Kubernetes pod scenerio</Title>
    <Description>This is the scenario that breaks:

- Orleans silo running in container listening on port 22222 and gateway 40000 with IP.Any using Azure table membership
- Web app in container listening to port 80 using Orleans client calling Gateway client endpoint 127.0.0.1 port 40000
- Both containers are in side one Kubernetes Statefulset pod with external port 80 exposed.
- Silo to silo communications works well.

It is expected that the web app can communicate with the Orleans silo at localhost:40000 inside the pod.  This is not the case.  It seems that the gateway will always listen on the same address as the silo address.

```
this.gatewayAddressLazy = new Lazy&lt;SiloAddress&gt;(() =&gt; endpointOptions.ProxyPort != 0 ? SiloAddress.New(new IPEndPoint(this.SiloAddress.Endpoint.Address endpointOptions.ProxyPort) 0) : null);
```
The config setting below where IP address is set to ANY is not being honored:
```
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any 40000);
```

This breaks any sidecar scenarios in containerized applications.
</Description>
    <Title_Description>Gateway cannot be called using localhost when running in non-local silo mode.  Kubernetes pod scenerio This is the scenario that breaks:

- Orleans silo running in container listening on port 22222 and gateway 40000 with IP.Any using Azure table membership
- Web app in container listening to port 80 using Orleans client calling Gateway client endpoint 127.0.0.1 port 40000
- Both containers are in side one Kubernetes Statefulset pod with external port 80 exposed.
- Silo to silo communications works well.

It is expected that the web app can communicate with the Orleans silo at localhost:40000 inside the pod.  This is not the case.  It seems that the gateway will always listen on the same address as the silo address.

```
this.gatewayAddressLazy = new Lazy&lt;SiloAddress&gt;(() =&gt; endpointOptions.ProxyPort != 0 ? SiloAddress.New(new IPEndPoint(this.SiloAddress.Endpoint.Address endpointOptions.ProxyPort) 0) : null);
```
The config setting below where IP address is set to ANY is not being honored:
```
config.Defaults.ProxyGatewayEndpoint = new IPEndPoint(IPAddress.Any 40000);
```

This breaks any sidecar scenarios in containerized applications.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3983</IssueLabelID>
    <Title>[Proposal] IClusterClient.Connect retry could simplify user code</Title>
    <Description>As a newcomer to Orleans I was surprised to learn that `Connect` does not Just Work especially considering I was in my first already messy HelloWorld attempt. I expected to have something like the following after [reading the docs](http://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html) :

```csharp
static async Task JustConnect()
{
    var config = ClientConfiguration.LocalhostSilo();
    var builder = new ClientBuilder()
        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICorn).Assembly)
            .WithReferences())
        .ConfigureLogging(logging =&gt; logging.AddConsole())
        .UseConfiguration(config);
    ClusterClient = builder.Build();
    await ClusterClient.Connect();
}
```

Because my silo application takes a few seconds to start up the first few Connect calls are mostly guaranteed to fail. The first thing I attempted to do about it was to wrap the call to `Connect` in a `do {} while (true);` which provided me with an `InvalidOperationException` and a message of "A prior connection attempt failed. This instance must be disposed." Okay I can build a new one! So I then moved my call to `.Build()` within my loop. That's a paddlin' too. "Build may only be called once per ClientBuilder instance." Okay fine I guess. So I move my builder into the loop too and get:

```csharp
static async Task KeepTryingToConnect()
{
    var config = ClientConfiguration.LocalhostSilo();

    do
    {
        try
        {
            var builder = new ClientBuilder()
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICorn).Assembly)
                    .WithReferences())
                .ConfigureLogging(logging =&gt; logging.AddConsole())
                .UseConfiguration(config);
            ClusterClient = builder.Build();
            await ClusterClient.Connect();
            break;
        }
        catch (SiloUnavailableException)
        {
            ClusterClient?.Dispose();
        }
    }
    while (true);
}
```

If some kind of retry could be built into `Connect` I think it could improve the new user experience a bit. I'm sure established projects and users also use a very similar pattern so maybe it can help others too.

</Description>
    <Title_Description>[Proposal] IClusterClient.Connect retry could simplify user code As a newcomer to Orleans I was surprised to learn that `Connect` does not Just Work especially considering I was in my first already messy HelloWorld attempt. I expected to have something like the following after [reading the docs](http://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html) :

```csharp
static async Task JustConnect()
{
    var config = ClientConfiguration.LocalhostSilo();
    var builder = new ClientBuilder()
        .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICorn).Assembly)
            .WithReferences())
        .ConfigureLogging(logging =&gt; logging.AddConsole())
        .UseConfiguration(config);
    ClusterClient = builder.Build();
    await ClusterClient.Connect();
}
```

Because my silo application takes a few seconds to start up the first few Connect calls are mostly guaranteed to fail. The first thing I attempted to do about it was to wrap the call to `Connect` in a `do {} while (true);` which provided me with an `InvalidOperationException` and a message of "A prior connection attempt failed. This instance must be disposed." Okay I can build a new one! So I then moved my call to `.Build()` within my loop. That's a paddlin' too. "Build may only be called once per ClientBuilder instance." Okay fine I guess. So I move my builder into the loop too and get:

```csharp
static async Task KeepTryingToConnect()
{
    var config = ClientConfiguration.LocalhostSilo();

    do
    {
        try
        {
            var builder = new ClientBuilder()
                .ConfigureApplicationParts(parts =&gt; parts.AddApplicationPart(typeof(ICorn).Assembly)
                    .WithReferences())
                .ConfigureLogging(logging =&gt; logging.AddConsole())
                .UseConfiguration(config);
            ClusterClient = builder.Build();
            await ClusterClient.Connect();
            break;
        }
        catch (SiloUnavailableException)
        {
            ClusterClient?.Dispose();
        }
    }
    while (true);
}
```

If some kind of retry could be built into `Connect` I think it could improve the new user experience a bit. I'm sure established projects and users also use a very similar pattern so maybe it can help others too.

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3981</IssueLabelID>
    <Title>Options formating improvements.</Title>
    <Description>Removed catalog as it was deemed unnecessary.
Order logging by formatter name.  Helps with grouping of related options when using default formatters.
Allow user override of formatters before or after defaults.
Fixed issues with named options not reporting correctly.
Updated tests to verify by confirming expected log output.

</Description>
    <Title_Description>Options formating improvements. Removed catalog as it was deemed unnecessary.
Order logging by formatter name.  Helps with grouping of related options when using default formatters.
Allow user override of formatters before or after defaults.
Fixed issues with named options not reporting correctly.
Updated tests to verify by confirming expected log output.

</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3980</IssueLabelID>
    <Title>Add networking mask options in EndpointOptions</Title>
    <Description>Related issue: #3203 

Right now using the legacy configuration in the case of a "multi-homed" server to force the selection of a specific IP address for the membership/gateway table users have to use `GlobalConfiguration.SubNet`.  This solution is not suitable if the networks available on the server are not using network sliced in 8/16/24.

With this implementation in `EndpointOptions` the user can use a real network address with a real network mask.
</Description>
    <Title_Description>Add networking mask options in EndpointOptions Related issue: #3203 

Right now using the legacy configuration in the case of a "multi-homed" server to force the selection of a specific IP address for the membership/gateway table users have to use `GlobalConfiguration.SubNet`.  This solution is not suitable if the networks available on the server are not using network sliced in 8/16/24.

With this implementation in `EndpointOptions` the user can use a real network address with a real network mask.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3979</IssueLabelID>
    <Title>When is version 2.0 expected to be used in a production environment? We are now new system development intended to be applied if the time is too long we can only choose other</Title>
    <Description>When is version 2.0 expected to be used in a production environment? We are now new system development intended to be applied if the time is too long we can only choose other</Description>
    <Title_Description>When is version 2.0 expected to be used in a production environment? We are now new system development, intended to be applied, if the time is too long, we can only choose other When is version 2.0 expected to be used in a production environment? We are now new system development intended to be applied if the time is too long we can only choose other</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>7/02/2018 2:08:14 AM +00:00</CreatedAt>
    <ClosedAt>1/03/2018 11:08:38 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3978</IssueLabelID>
    <Title>Fix intermittent failures in custom placement tests</Title>
    <Description>Make sorting of silos in the custom placement tests match the order used in the placement director.</Description>
    <Title_Description>Fix intermittent failures in custom placement tests Make sorting of silos in the custom placement tests match the order used in the placement director.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3977</IssueLabelID>
    <Title>Move load shedding settings to LoadSheddingOptions</Title>
    <Description>This is a preparation step for #3948 and a useful cleanup step in general.</Description>
    <Title_Description>Move load shedding settings to LoadSheddingOptions This is a preparation step for #3948 and a useful cleanup step in general.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3976</IssueLabelID>
    <Title>Refactor statistic and metric system</Title>
    <Description>Currently orleans metric and statistic system has some problems which  made it confusing to use and error prone 
- [ ]  use assembly loading to configure default `IMetricsDataPublisher` and `IStatisticsPublisher` which is error prone and also against the new way of configuring providers 
- [ ] use questionable way to determine to use default metric publisher and statistic publisher or not. See `CanUseAzureTable` in `ClientStatisticsManager` as an example. 
- [x] has multiple interfaces such as `IStatisticsPublisher` `IMetricDataPublisher` whose difference isn't clear. For example Which metrics belongs to statistics and which belongs to metrics? 
- [ ] overlap with telemetry. So basically now we have three system reporting metrics in orleans and their responsibility and infrastructure overlap with each other. This made metrics harder to maintain and harder to use. 

Considering refactor it. </Description>
    <Title_Description>Refactor statistic and metric system Currently orleans metric and statistic system has some problems which  made it confusing to use and error prone 
- [ ]  use assembly loading to configure default `IMetricsDataPublisher` and `IStatisticsPublisher` which is error prone and also against the new way of configuring providers 
- [ ] use questionable way to determine to use default metric publisher and statistic publisher or not. See `CanUseAzureTable` in `ClientStatisticsManager` as an example. 
- [x] has multiple interfaces such as `IStatisticsPublisher` `IMetricDataPublisher` whose difference isn't clear. For example Which metrics belongs to statistics and which belongs to metrics? 
- [ ] overlap with telemetry. So basically now we have three system reporting metrics in orleans and their responsibility and infrastructure overlap with each other. This made metrics harder to maintain and harder to use. 

Considering refactor it. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3975</IssueLabelID>
    <Title>Lifecycle for ClusterClient</Title>
    <Description>A lifecycle was added to the client to support component initialization made necessary when the provider model was removed.  This lifecycle is minimal and is weakly integrated with client initialization/shutdown.

We need to drive client initialization/shutdown from the lifecycle and declare well defined stages as we do for the silo.</Description>
    <Title_Description>Lifecycle for ClusterClient A lifecycle was added to the client to support component initialization made necessary when the provider model was removed.  This lifecycle is minimal and is weakly integrated with client initialization/shutdown.

We need to drive client initialization/shutdown from the lifecycle and declare well defined stages as we do for the silo.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3974</IssueLabelID>
    <Title>Fixes for Multi-Cluster Support</Title>
    <Description>It's been a while since we added multi-cluster support. Running all the tests I found some bugs:

- when running with at least three clusters and activating a grain concurrently messages could get forwarded excessively causing activation to fail (due to the forward count limit). I fixed this by forwarding only to destinations that are known to be the owner.
- Message.cs contained a bug that made the IsReturnedFromRemoteCluster flag not work correctly. This could also cause excessive forwarding and failure to remove stale directory cache entries.
- in two places NullReferenceExceptions were thrown when multi-clusters had no gateways reporting. I put in the proper handling of these situations.
- some tests were failing because the gsi-directory-maintenance was happening too late. To fix this I changed the periodic maintenance loop so it  runs the maintenance immediately after each multi-cluster-configuration change.

I also fixed some tracing issues and added more tests to the Functional category so we can cover these types of errors in regression.
</Description>
    <Title_Description>Fixes for Multi-Cluster Support It's been a while since we added multi-cluster support. Running all the tests I found some bugs:

- when running with at least three clusters and activating a grain concurrently messages could get forwarded excessively causing activation to fail (due to the forward count limit). I fixed this by forwarding only to destinations that are known to be the owner.
- Message.cs contained a bug that made the IsReturnedFromRemoteCluster flag not work correctly. This could also cause excessive forwarding and failure to remove stale directory cache entries.
- in two places NullReferenceExceptions were thrown when multi-clusters had no gateways reporting. I put in the proper handling of these situations.
- some tests were failing because the gsi-directory-maintenance was happening too late. To fix this I changed the periodic maintenance loop so it  runs the maintenance immediately after each multi-cluster-configuration change.

I also fixed some tracing issues and added more tests to the Functional category so we can cover these types of errors in regression.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3971</IssueLabelID>
    <Title>Contributing guide - getting started</Title>
    <Description>I and my team are willing to try and contribute to Orleans source however currently there's no guide on how to start and for a big project like this we don't know where to start.

Can you create a very simple guide on how to get started in order to contribute e.g. clone build run (ideally in our project so we can test better + debuggable)

Something along these lines is what im thinking:

In order to contribute to the project follow these simple steps:

- Clone orleans repo - `git clone https://github.com/dotnet/orleans.git`
- Restore/Build project - `dotnet build .\Orleans.sln`
- Reference Orleans csproj instead the nugets e.g. `Orleans.Core.csproj` in your app (example)
- ...
- Run tests via `Test.cmd`

If you are able to help us where to start we are willing to contribute thanks!</Description>
    <Title_Description>Contributing guide - getting started I and my team are willing to try and contribute to Orleans source however currently there's no guide on how to start and for a big project like this we don't know where to start.

Can you create a very simple guide on how to get started in order to contribute e.g. clone build run (ideally in our project so we can test better + debuggable)

Something along these lines is what im thinking:

In order to contribute to the project follow these simple steps:

- Clone orleans repo - `git clone https://github.com/dotnet/orleans.git`
- Restore/Build project - `dotnet build .\Orleans.sln`
- Reference Orleans csproj instead the nugets e.g. `Orleans.Core.csproj` in your app (example)
- ...
- Run tests via `Test.cmd`

If you are able to help us where to start we are willing to contribute thanks!</Title_Description>
    <Label>P3</Label>
    <Assignee>JillHeaden</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3969</IssueLabelID>
    <Title>Using system given free ports in tests to remove transient test failures in CI</Title>
    <Description>Anedoctally I experienced multiple errors in opening sockets in CI server which appeared to be due to some socket being already reserved. 

As a first measure I suggest adding a functionality to ask the system to give a free port from the ephemeral range and use that. The code could be like:

```
/// &lt;summary&gt;
/// Finds a free port from an ephemeral range.
/// &lt;/summary&gt;
/// &lt;returns&gt;The found free port.&lt;/returns&gt;
public static int GetFreePortFromEphemeralRange()
{
    var listener = new TcpListener(IPAddress.Loopback 0);
    listener.Start();
    int port = ((IPEndPoint)listener.LocalEndpoint).Port;
    listener.Stop();

    return port;
}
```

When this change is implemented it needs to be ensured all places are modified and the current code does not assume _well known_ ports. Assuming all places are changed to use system given free ports failing tests should reveal places that assume _well known_ ports.

One option to refactor the tests could be to implement a cache or a DI-like container to (lazily) generate and hold parameters that are then injected in all test class constructors. This could would allow sharing assets where feasible and perhaps make the testing infrastructure more uniform (and more approachable). There are some examples on how to do this at https://github.com/xunit/xunit/issues/687.
</Description>
    <Title_Description>Using system given free ports in tests to remove transient test failures in CI Anedoctally I experienced multiple errors in opening sockets in CI server which appeared to be due to some socket being already reserved. 

As a first measure I suggest adding a functionality to ask the system to give a free port from the ephemeral range and use that. The code could be like:

```
/// &lt;summary&gt;
/// Finds a free port from an ephemeral range.
/// &lt;/summary&gt;
/// &lt;returns&gt;The found free port.&lt;/returns&gt;
public static int GetFreePortFromEphemeralRange()
{
    var listener = new TcpListener(IPAddress.Loopback 0);
    listener.Start();
    int port = ((IPEndPoint)listener.LocalEndpoint).Port;
    listener.Stop();

    return port;
}
```

When this change is implemented it needs to be ensured all places are modified and the current code does not assume _well known_ ports. Assuming all places are changed to use system given free ports failing tests should reveal places that assume _well known_ ports.

One option to refactor the tests could be to implement a cache or a DI-like container to (lazily) generate and hold parameters that are then injected in all test class constructors. This could would allow sharing assets where feasible and perhaps make the testing infrastructure more uniform (and more approachable). There are some examples on how to do this at https://github.com/xunit/xunit/issues/687.
</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3968</IssueLabelID>
    <Title>silo.StopAsync()  indefinite wait</Title>
    <Description>  private static async Task StopSilo()
        {
            Console.WriteLine("Start Silo stop");

            await silo.StopAsync();
            
            Console.WriteLine("Silo stopped");

        }</Description>
    <Title_Description>silo.StopAsync()  indefinite wait   private static async Task StopSilo()
        {
            Console.WriteLine("Start Silo stop");

            await silo.StopAsync();
            
            Console.WriteLine("Silo stopped");

        }</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3967</IssueLabelID>
    <Title>Suggest RequestContext add an IServiceProvider property so easy to control</Title>
    <Description>Suggest RequestContext add an IServiceProvider property so easy to control</Description>
    <Title_Description>Suggest RequestContext add an IServiceProvider property, so easy to control Suggest RequestContext add an IServiceProvider property so easy to control</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3964</IssueLabelID>
    <Title>Sort list of silos in HashBasedPlacementDirector</Title>
    <Description>Sort list of available compatible silos before picking a target one based on the grain ID hash.
Fixes non-deterministic behavior of HashBasedPlacementDirector and related tests.</Description>
    <Title_Description>Sort list of silos in HashBasedPlacementDirector Sort list of available compatible silos before picking a target one based on the grain ID hash.
Fixes non-deterministic behavior of HashBasedPlacementDirector and related tests.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3960</IssueLabelID>
    <Title>Allow OrleansJsonSerializer to be used as an external serialization provider</Title>
    <Description>Fixes #3853

Problem: `SerializationManager` attempts to create all configured serialization providers in its constructor but `OrleansJsonSerializer` has a constructor dependency on `SerializationManager`. This causes a DI cycle and subsequently a `StackOverflowException`.

This PR fixes that issue.

* Removes `SerializationManager` property from `IRuntimeClient` (I'm really happy about this)
* Modifies the constructors of `InsideRuntimeClient` `OutsideRuntimeClient` and `OrleansJsonSerializer` to no longer take `SerializationManager`</Description>
    <Title_Description>Allow OrleansJsonSerializer to be used as an external serialization provider Fixes #3853

Problem: `SerializationManager` attempts to create all configured serialization providers in its constructor but `OrleansJsonSerializer` has a constructor dependency on `SerializationManager`. This causes a DI cycle and subsequently a `StackOverflowException`.

This PR fixes that issue.

* Removes `SerializationManager` property from `IRuntimeClient` (I'm really happy about this)
* Modifies the constructors of `InsideRuntimeClient` `OutsideRuntimeClient` and `OrleansJsonSerializer` to no longer take `SerializationManager`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3959</IssueLabelID>
    <Title>Reference Microsoft.Orleans.OrleansCodeGenerator.Build problem？</Title>
    <Description>Reference Microsoft.Orleans.OrleansCodeGenerator.Build it seems invalid it is not completed 2.0 or I configure here?
![image](https://user-images.githubusercontent.com/28291464/35715634-bcf3d8f8-080e-11e8-846c-496511b5c92d.png)

![image](https://user-images.githubusercontent.com/28291464/35715660-dad566fc-080e-11e8-9ea6-707b255a9ccc.png)
</Description>
    <Title_Description>Reference Microsoft.Orleans.OrleansCodeGenerator.Build problem？ Reference Microsoft.Orleans.OrleansCodeGenerator.Build it seems invalid it is not completed 2.0 or I configure here?
![image](https://user-images.githubusercontent.com/28291464/35715634-bcf3d8f8-080e-11e8-846c-496511b5c92d.png)

![image](https://user-images.githubusercontent.com/28291464/35715660-dad566fc-080e-11e8-9ea6-707b255a9ccc.png)
</Title_Description>
    <Label>question</Label>
    <Assignee>lfzm</Assignee>
    <CreatedAt>2/02/2018 3:48:39 AM +00:00</CreatedAt>
    <ClosedAt>2/02/2018 6:04:46 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3957</IssueLabelID>
    <Title>Configuration Work - unwanted or improperly organized settings</Title>
    <Description>While moving from monolithic Cluster and Client configurations to options settings surfaced which should probably not be part of Orleans core or may not be categorized correctly.

Below is a list of some such settings and I encourage others to contribute to this list if the current options seem ill conceived or unnecessary.

AdoNetOptions - should not be in Orleans core.
ServicePointOptions - should not be in Orleans core.
Load shedding settings - Probably should not be part of statistics. (EDIT: moved to its own options)
FastKillOnCancelKeyPress - probably should not be in Orleans core.

Figure out what to do about these.

[Edit]
Thread pool options - don't think thread pool settup should be part of orleans core.
</Description>
    <Title_Description>Configuration Work - unwanted or improperly organized settings While moving from monolithic Cluster and Client configurations to options settings surfaced which should probably not be part of Orleans core or may not be categorized correctly.

Below is a list of some such settings and I encourage others to contribute to this list if the current options seem ill conceived or unnecessary.

AdoNetOptions - should not be in Orleans core.
ServicePointOptions - should not be in Orleans core.
Load shedding settings - Probably should not be part of statistics. (EDIT: moved to its own options)
FastKillOnCancelKeyPress - probably should not be in Orleans core.

Figure out what to do about these.

[Edit]
Thread pool options - don't think thread pool settup should be part of orleans core.
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3956</IssueLabelID>
    <Title>Configuration Work - Option home and namespace</Title>
    <Description>Currently all options derived from legacy cluster and client configurations live in Orleans.Core and are under the namespace Orleans.Host.

The namespace was selected for discoverability.
The location was selected to avoid dependency issues since Orleans Core is where the original configurations lived.

It's not clear if this pattern is what we want to maintain in the long run.

Revisit where options should live what should be in core runtime and what options should be with their components.</Description>
    <Title_Description>Configuration Work - Option home and namespace Currently all options derived from legacy cluster and client configurations live in Orleans.Core and are under the namespace Orleans.Host.

The namespace was selected for discoverability.
The location was selected to avoid dependency issues since Orleans Core is where the original configurations lived.

It's not clear if this pattern is what we want to maintain in the long run.

Revisit where options should live what should be in core runtime and what options should be with their components.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3955</IssueLabelID>
    <Title>Configuration Work - Formatters</Title>
    <Description>Add options formatters for all the new options. (many already have formatters)</Description>
    <Title_Description>Configuration Work - Formatters Add options formatters for all the new options. (many already have formatters)</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3954</IssueLabelID>
    <Title>Configuration Works - StorageOptions</Title>
    <Description>The original cluster and client configurations used a shared account key for general storage and reminder storage.  This pattern has been carried over in the StorageOptions.  This is a questionable pattern as there is no reason to assume authentication/authorization for various storage systems can be generalized in such a way nor is it possible to provide reasonable defaults or security for such information.

Identify storage needs (by component) for framework work out abstractions and configuration.  Leave extension configurations to the extensions.</Description>
    <Title_Description>Configuration Works - StorageOptions The original cluster and client configurations used a shared account key for general storage and reminder storage.  This pattern has been carried over in the StorageOptions.  This is a questionable pattern as there is no reason to assume authentication/authorization for various storage systems can be generalized in such a way nor is it possible to provide reasonable defaults or security for such information.

Identify storage needs (by component) for framework work out abstractions and configuration.  Leave extension configurations to the extensions.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3953</IssueLabelID>
    <Title>Configuration Work - assembly loaded types</Title>
    <Description>Many patterns carried over from the legacy configuration use strings or enums to identify component implementations.  These settings trigger assembly loads of pre defined assemblies and creation of types assumed to be in those assemblies.  This pattern is error prone and poorly maintainable.

In new systems this is done by requiring component implementations to be registered in the container by name and configured values are used by named service resolution but no consensus has been built around this pattern.

We need to design a better pattern and replace the legacy pattern.  </Description>
    <Title_Description>Configuration Work - assembly loaded types Many patterns carried over from the legacy configuration use strings or enums to identify component implementations.  These settings trigger assembly loads of pre defined assemblies and creation of types assumed to be in those assemblies.  This pattern is error prone and poorly maintainable.

In new systems this is done by requiring component implementations to be registered in the container by name and configured values are used by named service resolution but no consensus has been built around this pattern.

We need to design a better pattern and replace the legacy pattern.  </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3952</IssueLabelID>
    <Title>Configuration Work - Extension libraries</Title>
    <Description>We need to remove references to legacy configuration classes (and references to legacy packages) from extension libraries and their test assemblies.  This work can (should) be subdivided into per extension library change sets.</Description>
    <Title_Description>Configuration Work - Extension libraries We need to remove references to legacy configuration classes (and references to legacy packages) from extension libraries and their test assemblies.  This work can (should) be subdivided into per extension library change sets.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3951</IssueLabelID>
    <Title>Configuration Work - TestingHost</Title>
    <Description>Remove use of legacy configuration from Orleans.TestingHost introducing a Orleans.TestingHost.Legacy if necessary.</Description>
    <Title_Description>Configuration Work - TestingHost Remove use of legacy configuration from Orleans.TestingHost introducing a Orleans.TestingHost.Legacy if necessary.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3950</IssueLabelID>
    <Title>Configuration Work - XML docs</Title>
    <Description>While moving from monolithic Cluster and Client configurations to options settings without xml comments were copied without comment leaving it unclear what these settings are for.

We need to go through all of the new options and ensure that the options themselves as well as all of it's properties have xml comments.</Description>
    <Title_Description>Configuration Work - XML docs While moving from monolithic Cluster and Client configurations to options settings without xml comments were copied without comment leaving it unclear what these settings are for.

We need to go through all of the new options and ensure that the options themselves as well as all of it's properties have xml comments.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3949</IssueLabelID>
    <Title>Configuration Work - Defaults</Title>
    <Description>While moving from monolithic Cluster and Client configurations to options we've duplicated defaults. Many of the options introduced duplicated the defaults in the options rather than having the options have the authoritative default and referencing these defaults from the legacy configurations.

We need to go through all of the added options and ensure the defaults in the options are correct and authoritative.</Description>
    <Title_Description>Configuration Work - Defaults While moving from monolithic Cluster and Client configurations to options we've duplicated defaults. Many of the options introduced duplicated the defaults in the options rather than having the options have the authoritative default and referencing these defaults from the legacy configurations.

We need to go through all of the added options and ensure the defaults in the options are correct and authoritative.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3948</IssueLabelID>
    <Title>Move Silo-specific options from Orleans.Core to Orleans.Runtime</Title>
    <Description>There no need for silo-specific options to pollute `Orleans.Core`.

While it is somewhat ugly to duplicate some default values in the legacy config classes I think that's an acceptable price to pay for cleanness of the forward looking APIs. The legacy classes are ... legacy anyway and their defaults are unlikely to change anyway.

Moved the following options classes to Orleans.Runtime:

* SiloMessagingOptions
* SiloStatisticsOptions
* ConsistentRingOptions
* GrainCollectionOptions
* GrainDirectoryOptions
* GrainPlacementOptions
* GrainServiceOptions
* ReminderOptions
* SchedulingOptions

Also moved OrleansConfiguration.xsd to Orleans.Core.Legacy.</Description>
    <Title_Description>Move Silo-specific options from Orleans.Core to Orleans.Runtime There no need for silo-specific options to pollute `Orleans.Core`.

While it is somewhat ugly to duplicate some default values in the legacy config classes I think that's an acceptable price to pay for cleanness of the forward looking APIs. The legacy classes are ... legacy anyway and their defaults are unlikely to change anyway.

Moved the following options classes to Orleans.Runtime:

* SiloMessagingOptions
* SiloStatisticsOptions
* ConsistentRingOptions
* GrainCollectionOptions
* GrainDirectoryOptions
* GrainPlacementOptions
* GrainServiceOptions
* ReminderOptions
* SchedulingOptions

Also moved OrleansConfiguration.xsd to Orleans.Core.Legacy.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3947</IssueLabelID>
    <Title>More options formatting and related cleanup</Title>
    <Description>Added formatters for grain directory options grain placement options schedualling options thread pool options type managment options versioning options and silo options.
Fixed formatting of messaging options.
Fixed some options defaults.</Description>
    <Title_Description>More options formatting, and related cleanup Added formatters for grain directory options grain placement options schedualling options thread pool options type managment options versioning options and silo options.
Fixed formatting of messaging options.
Fixed some options defaults.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3945</IssueLabelID>
    <Title>Ping Benchmark fixes</Title>
    <Description>
    </Description>
    <Title_Description>Ping Benchmark fixes </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3944</IssueLabelID>
    <Title>2.0 version can be configured to optimize it?</Title>
    <Description>![image](https://user-images.githubusercontent.com/28291464/35657078-94d68246-0735-11e8-9cfa-25a06ec968af.png)
</Description>
    <Title_Description>2.0 version can be configured to optimize it? ![image](https://user-images.githubusercontent.com/28291464/35657078-94d68246-0735-11e8-9cfa-25a06ec968af.png)
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>1/02/2018 1:52:43 AM +00:00</CreatedAt>
    <ClosedAt>2/02/2018 4:09:40 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3943</IssueLabelID>
    <Title>Fix tests. Remove ServiceId and ClusterId getter turn on file logging</Title>
    <Description>- fix some tests
- remove `ServiceId` and `ClusterId` getter from `TestCluster` since they are misleading. They only reflect values you set using `TestClusterOptions` may not reflect values if you configure cluster using legacy `ClusterConfiguration`. 
- turn on file logger for TestCluster by default
</Description>
    <Title_Description>Fix tests. Remove ServiceId and ClusterId getter, turn on file logging - fix some tests
- remove `ServiceId` and `ClusterId` getter from `TestCluster` since they are misleading. They only reflect values you set using `TestClusterOptions` may not reflect values if you configure cluster using legacy `ClusterConfiguration`. 
- turn on file logger for TestCluster by default
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3935</IssueLabelID>
    <Title>Fix FastKillOnCancelKeyPress not stopping the process.</Title>
    <Description>When FastKillOnCancelKeyPress=true State is set to Closing but Stop process never starts.</Description>
    <Title_Description>Fix FastKillOnCancelKeyPress not stopping the process. When FastKillOnCancelKeyPress=true State is set to Closing but Stop process never starts.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3933</IssueLabelID>
    <Title>FastKillOnCancelKeyPress waits forever</Title>
    <Description>When FastKillOnCancelKeyPress=true SystemStatus is set to stopping but nothing signals the LifeCycle to stop.

The Stop() method then wait for the SystemStatus to Terminate but it never does.

Working on a local fix.</Description>
    <Title_Description>FastKillOnCancelKeyPress waits forever When FastKillOnCancelKeyPress=true SystemStatus is set to stopping but nothing signals the LifeCycle to stop.

The Stop() method then wait for the SystemStatus to Terminate but it never does.

Working on a local fix.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3930</IssueLabelID>
    <Title>Consult a cluster configuration problem.</Title>
    <Description>Whether the Orleans can be assembled into a cluster between different systems.
Example:
A system (user system) : obtain user information function and configure gateway address: 123.135.13.13:4545.
B system (message system) : send message function configure gateway address and A system. Is it feasible?
If the client can call 123.135.13.13:4545 gateway address it can obtain the user of A system and send information to system B.
Because I didn't succeed in the experiment.</Description>
    <Title_Description>Consult a cluster configuration problem. Whether the Orleans can be assembled into a cluster between different systems.
Example:
A system (user system) : obtain user information function and configure gateway address: 123.135.13.13:4545.
B system (message system) : send message function configure gateway address and A system. Is it feasible?
If the client can call 123.135.13.13:4545 gateway address it can obtain the user of A system and send information to system B.
Because I didn't succeed in the experiment.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>30/01/2018 3:17:12 AM +00:00</CreatedAt>
    <ClosedAt>2/02/2018 6:05:18 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3929</IssueLabelID>
    <Title>TestMultiClusterConf_3_3 fails intermittently</Title>
    <Description>TestMultiClusterConf_3_3 has been failing intermittently for some time now. I submitted #3928 to skip it for now. This issue is to remember to investigate it.

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs#_a=resultSummary&amp;runId=3414&amp;resultId=101084
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2110021101\r\nActual: 2110021102\r\n ↑ (pos 10)

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs?_a=resultSummary&amp;runId=3397&amp;resultId=101169
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2110021101\r\nActual: 2110021102\r\n ↑ (pos 10)

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs#_a=resultSummary&amp;runId=3341&amp;resultId=101222
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2120021201\r\nActual: 2120021202\r\n ↑ (pos 10)</Description>
    <Title_Description>TestMultiClusterConf_3_3 fails intermittently TestMultiClusterConf_3_3 has been failing intermittently for some time now. I submitted #3928 to skip it for now. This issue is to remember to investigate it.

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs#_a=resultSummary&amp;runId=3414&amp;resultId=101084
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2110021101\r\nActual: 2110021102\r\n ↑ (pos 10)

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs?_a=resultSummary&amp;runId=3397&amp;resultId=101169
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2110021101\r\nActual: 2110021102\r\n ↑ (pos 10)

https://orleans.visualstudio.com/Orleans/Orleans%20Team/_TestManagement/Runs#_a=resultSummary&amp;runId=3341&amp;resultId=101222
&gt;Assert.Equal() Failure\r\n ↓ (pos 10)\r\nExpected: 2120021201\r\nActual: 2120021202\r\n ↑ (pos 10)</Title_Description>
    <Label>
    </Label>
    <Assignee>sebastianburckhardt</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3928</IssueLabelID>
    <Title>Skip TestMultiClusterConf_3_3</Title>
    <Description>Skip TestMultiClusterConf_3_3 because it fails intermittently and needs to be investigated.</Description>
    <Title_Description>Skip TestMultiClusterConf_3_3 Skip TestMultiClusterConf_3_3 because it fails intermittently and needs to be investigated.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3927</IssueLabelID>
    <Title>Replaced AzureTableStorage storage provider with AzureTableGrainStorage.</Title>
    <Description>Moved the first provider  to the new extension pattern.

Split storage calls and initialization from IStorageProvider so usage patterns are independent of initialization.

IGrainStorage is the new grain storage abstraction.

IStorageProvider is supported for legacy storage providers and inherits from IGrainStorage and IProvider.

All grain storage logic now talks to IGrainStorage.

AzureTableStorage was replaced with AzureTableGrainStorage which no longer uses the provider pattern but instead uses DI and the silo lifecycle directly and is configured using options.
</Description>
    <Title_Description>Replaced AzureTableStorage storage provider with AzureTableGrainStorage. Moved the first provider  to the new extension pattern.

Split storage calls and initialization from IStorageProvider so usage patterns are independent of initialization.

IGrainStorage is the new grain storage abstraction.

IStorageProvider is supported for legacy storage providers and inherits from IGrainStorage and IProvider.

All grain storage logic now talks to IGrainStorage.

AzureTableStorage was replaced with AzureTableGrainStorage which no longer uses the provider pattern but instead uses DI and the silo lifecycle directly and is configured using options.
</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3926</IssueLabelID>
    <Title>Remove Newtonsoft.JSON Dependency from core abstractions</Title>
    <Description>Per https://github.com/dotnet/orleans/issues/3913</Description>
    <Title_Description>Remove Newtonsoft.JSON Dependency from core abstractions Per https://github.com/dotnet/orleans/issues/3913</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3925</IssueLabelID>
    <Title>Error starting orleans beta 3 silo in .net core stateless service fabric</Title>
    <Description>I have a trivial set of .net core 2.0 orleans beta 3 interfaces/implementations . A local host silo works fine. When I use the .net core preview azure service fabric tools to create a stateless silo I get an unhandled exception error when starting.

https://gist.github.com/jamiemitchellconsultants/fa498a292f7342ee4f61d6b126848010</Description>
    <Title_Description>Error starting orleans beta 3 silo in .net core stateless service fabric I have a trivial set of .net core 2.0 orleans beta 3 interfaces/implementations . A local host silo works fine. When I use the .net core preview azure service fabric tools to create a stateless silo I get an unhandled exception error when starting.

https://gist.github.com/jamiemitchellconsultants/fa498a292f7342ee4f61d6b126848010</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3924</IssueLabelID>
    <Title>I would like to ask each request to call Grain can be viewed in EventSourcing?</Title>
    <Description>
    </Description>
    <Title_Description>I would like to ask, each request to call Grain can be viewed in EventSourcing? </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>29/01/2018 9:59:57 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2018 2:27:43 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3922</IssueLabelID>
    <Title>When released 2.0 stable version?</Title>
    <Description>When released 2.0 stable version?</Description>
    <Title_Description>When released 2.0 stable version? When released 2.0 stable version?</Title_Description>
    <Label>question</Label>
    <Assignee>lfzm</Assignee>
    <CreatedAt>29/01/2018 3:22:53 AM +00:00</CreatedAt>
    <ClosedAt>29/01/2018 9:57:57 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3920</IssueLabelID>
    <Title>Sending an impl instead of the interface as parameter can fail silently</Title>
    <Description>I have a `IUNetMessageProcessor` interface and an implementation type named `UNetMessageProcessor`  I have a method in another grain which takes as argument `IUNetMessageProcessor` and was sending myself to it from a UNetMessageProcessor grain by using `AsReference&lt;IUNetMesageProcessor&gt;(this)` but by mistake i instead wrote `AsReference&lt;UNetMessageProcessor&gt;(this)` 

What happened was that I was getting InvalidOperationException in Orleans.dl-l&gt;mscorlib.dll which was being swallowed and i only was getting a log message. 

This can be improved in two ways. More important is to throw it and let it crash (maybe if it doesn't break backward compatibility) and another is writing a Roslyn analyzer which checks you are only passing interfaces if there is no elegant way of preventing it altogether 

Today I got reminded of the type errors which we sometimes got in Erlang and actually felt great about Orleans after 3 hours of debugging</Description>
    <Title_Description>Sending an impl instead of the interface as parameter can fail silently I have a `IUNetMessageProcessor` interface and an implementation type named `UNetMessageProcessor`  I have a method in another grain which takes as argument `IUNetMessageProcessor` and was sending myself to it from a UNetMessageProcessor grain by using `AsReference&lt;IUNetMesageProcessor&gt;(this)` but by mistake i instead wrote `AsReference&lt;UNetMessageProcessor&gt;(this)` 

What happened was that I was getting InvalidOperationException in Orleans.dl-l&gt;mscorlib.dll which was being swallowed and i only was getting a log message. 

This can be improved in two ways. More important is to throw it and let it crash (maybe if it doesn't break backward compatibility) and another is writing a Roslyn analyzer which checks you are only passing interfaces if there is no elegant way of preventing it altogether 

Today I got reminded of the type errors which we sometimes got in Erlang and actually felt great about Orleans after 3 hours of debugging</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3919</IssueLabelID>
    <Title>Connection failed after restart client/silo in docker-deployment</Title>
    <Description>Error log:
&gt; Unhandled Exception: System.AggregateException: One or more errors occurred. (The target silo became unavailable for message: Request *cli/b1d88196@02695dbc-&gt;S10.0.2.6:10400:0???/00000011@S00000011 #2: global::Orleans.Runtime.IClusterTypeManager:GetClusterTypeCodeMap(). Target History is: &lt;S10.0.2.6:10400:0:???/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.) ---&gt; Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/b1d88196@02695dbc-&gt;S10.0.2.6:10400:0???/00000011@S00000011 #2: global::Orleans.Runtime.IClusterTypeManager:GetClusterTypeCodeMap(). Target History is: &lt;S10.0.2.6:10400:0:???/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.

It happens sometimes when:
1. start silo then start client
2. silos are running and then restart clients.
and if those errors occurred **clients cannot connect to silos unless i restart silos.**

And:
If clients are running then restart silos
clients will mark silo dead and will not connect silo again
it's a faulty error because in [docker-deployment](https://github.com/dotnet/orleans/blob/master/Samples/Docker-Simple/Client/Program.cs) there's only one gateway endpoint. </Description>
    <Title_Description>Connection failed after restart client/silo in docker-deployment Error log:
&gt; Unhandled Exception: System.AggregateException: One or more errors occurred. (The target silo became unavailable for message: Request *cli/b1d88196@02695dbc-&gt;S10.0.2.6:10400:0???/00000011@S00000011 #2: global::Orleans.Runtime.IClusterTypeManager:GetClusterTypeCodeMap(). Target History is: &lt;S10.0.2.6:10400:0:???/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.) ---&gt; Orleans.Runtime.SiloUnavailableException: The target silo became unavailable for message: Request *cli/b1d88196@02695dbc-&gt;S10.0.2.6:10400:0???/00000011@S00000011 #2: global::Orleans.Runtime.IClusterTypeManager:GetClusterTypeCodeMap(). Target History is: &lt;S10.0.2.6:10400:0:???/00000011:@S00000011&gt;. See https://aka.ms/orleans-troubleshooting for troubleshooting help.

It happens sometimes when:
1. start silo then start client
2. silos are running and then restart clients.
and if those errors occurred **clients cannot connect to silos unless i restart silos.**

And:
If clients are running then restart silos
clients will mark silo dead and will not connect silo again
it's a faulty error because in [docker-deployment](https://github.com/dotnet/orleans/blob/master/Samples/Docker-Simple/Client/Program.cs) there's only one gateway endpoint. </Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3916</IssueLabelID>
    <Title>Fix logger exceptions</Title>
    <Description>PR fixing the issue https://github.com/dotnet/orleans/issues/3909
Removed  some logging code seems to be left from testing
Test for big 1-dimensional array of primitive type serialization showing off the issue
</Description>
    <Title_Description>Fix logger exceptions PR fixing the issue https://github.com/dotnet/orleans/issues/3909
Removed  some logging code seems to be left from testing
Test for big 1-dimensional array of primitive type serialization showing off the issue
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3915</IssueLabelID>
    <Title>ADO.NET configuration methods naming (Sql -&gt; AdoNet?)</Title>
    <Description>It appears the new Orleans ADO.NET related configuration methods use the term `Sql` (e.g. `.UseSqlMembership`) whereas `AdoNet` is used where support for older public interface hasn't been issue. Then the older pieces use `SqlServer`.

A more consistent experience would be picking one and considering how to best promote it. Since the library builds on ADO.NET and Nuget packages use that the most natural neutral choice could be `AdoNet`. It's perhaps worth entertaining an idea if in the 2.0.0 release timeframe the `SqlServer` ones such as `GlobalConfiguration.LivenessProviderType.SqlServer` could have an alias such as `GlobalConfiguration.LivenessProviderType.AdoNet`.</Description>
    <Title_Description>ADO.NET configuration methods naming (Sql -&gt; AdoNet?) It appears the new Orleans ADO.NET related configuration methods use the term `Sql` (e.g. `.UseSqlMembership`) whereas `AdoNet` is used where support for older public interface hasn't been issue. Then the older pieces use `SqlServer`.

A more consistent experience would be picking one and considering how to best promote it. Since the library builds on ADO.NET and Nuget packages use that the most natural neutral choice could be `AdoNet`. It's perhaps worth entertaining an idea if in the 2.0.0 release timeframe the `SqlServer` ones such as `GlobalConfiguration.LivenessProviderType.SqlServer` could have an alias such as `GlobalConfiguration.LivenessProviderType.AdoNet`.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3913</IssueLabelID>
    <Title>Remove Orleans.Core.Abstractions Newtonsoft.Json Dependency</Title>
    <Description>Would it be possible to remove the Newtonsoft.Json dependency from Orleans.Core.Abstractions?
It appears to only be used here: https://github.com/dotnet/orleans/blob/f98bd17fa980160c348ff75a4e819d39ff740eb1/src/Orleans.Core.Abstractions/IDs/UniqueIdentifier.cs#L10

I am sharing some classes that use Orleans attributes with a Unity project. I am able to add the dependency in Unity but it causes an error message on startup. It doesn't actually break anything so this isn't a high priority but it would be nice to clean it up.</Description>
    <Title_Description>Remove Orleans.Core.Abstractions Newtonsoft.Json Dependency Would it be possible to remove the Newtonsoft.Json dependency from Orleans.Core.Abstractions?
It appears to only be used here: https://github.com/dotnet/orleans/blob/f98bd17fa980160c348ff75a4e819d39ff740eb1/src/Orleans.Core.Abstractions/IDs/UniqueIdentifier.cs#L10

I am sharing some classes that use Orleans attributes with a Unity project. I am able to add the dependency in Unity but it causes an error message on startup. It doesn't actually break anything so this isn't a high priority but it would be nice to clean it up.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3912</IssueLabelID>
    <Title>Update activation GC page</Title>
    <Description>Updated activation GC page to document and emphasize programmatic configuration and hopefully for better clarity.</Description>
    <Title_Description>Update activation GC page Updated activation GC page to document and emphasize programmatic configuration and hopefully for better clarity.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3911</IssueLabelID>
    <Title>Odd virtual methods in Grain class</Title>
    <Description>Why following methods are virtual:
- RegisterTimer
- RegisterOrUpdateReminder
- UnregisterReminder
- GetReminder
- GetReminders
- GetStreamProvider
- DeactivateOnIdle
- DelayDeactivation
- GetLogger
- Participate

Those are considered to be called by consumers not by Orleans (like `OnActivateAsync()`) so overriding them make little or no sense. In fact all these methods do nothing but merely delegate to `IGrainRuntime`. IMHO it might be better to seal them to not confuse developers.

If this was done for unit-testing (mocking) purposes this now seems unnecessary as all mocking could be done against IGrainRuntime.XXX. </Description>
    <Title_Description>Odd virtual methods in Grain class Why following methods are virtual:
- RegisterTimer
- RegisterOrUpdateReminder
- UnregisterReminder
- GetReminder
- GetReminders
- GetStreamProvider
- DeactivateOnIdle
- DelayDeactivation
- GetLogger
- Participate

Those are considered to be called by consumers not by Orleans (like `OnActivateAsync()`) so overriding them make little or no sense. In fact all these methods do nothing but merely delegate to `IGrainRuntime`. IMHO it might be better to seal them to not confuse developers.

If this was done for unit-testing (mocking) purposes this now seems unnecessary as all mocking could be done against IGrainRuntime.XXX. </Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3910</IssueLabelID>
    <Title>[Proposal] New codegen hint</Title>
    <Description>The functional way (style) for doing communication is via messages which in C# are usually implemented by classes. Currently Orleans codegen can only generate serializers for class if it's marked with `Serializable` attribute which means that each and every message class need to be marked with it. That creates a lot of unnecessary noise and make definitions more verbose.

It would be great to have new hint for codegen (ie done via config) to generate serializers for all types which could be assigned from specified type. For example Orleankka provides 2 base interfaces `Message` and `Result` (for requests and responses respectively) which are used for strongly typed actors (`ActorMessage&lt;TActor&gt;`` ActorMessage&lt;TActor TResult&gt;`). Having this ability will save 1 line of code per each message definition and will make them more compact. </Description>
    <Title_Description>[Proposal] New codegen hint The functional way (style) for doing communication is via messages which in C# are usually implemented by classes. Currently Orleans codegen can only generate serializers for class if it's marked with `Serializable` attribute which means that each and every message class need to be marked with it. That creates a lot of unnecessary noise and make definitions more verbose.

It would be great to have new hint for codegen (ie done via config) to generate serializers for all types which could be assigned from specified type. For example Orleankka provides 2 base interfaces `Message` and `Result` (for requests and responses respectively) which are used for strongly typed actors (`ActorMessage&lt;TActor&gt;`` ActorMessage&lt;TActor TResult&gt;`). Having this ability will save 1 line of code per each message definition and will make them more compact. </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3909</IssueLabelID>
    <Title>Microsoft.Extensions.Logging issue</Title>
    <Description>Seems that from v2 release of Microsoft.Extensions.Logging the way of providing messages templates to logger.Log* functions became more suitable for structured/semantic logging.
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x#log-message-template
However Orleans still uses the 'string.Format' style of generating messages. In comparison to M.E.L proposed way of naming variables it just hides the possibility to implement custom log providers to have more intuitive/straightforward extraction of key/value pairs of important variables.
Moreover in case of line https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Serialization/SerializationManager.cs#L747   the old code leads to a bug. Calling this ( case of serializing non-immutable 1dim arrays of primitive types ) throws a `
System.AggregateException: 'An error occurred while writing to logger(s). (Index (zero based) must be greater than or equal to zero and less than the size of the argument list.)'
InnerException	{System.FormatException: Index (zero based) must be greater than or equal to zero and less than the size of the argument list.
at System.Text.StringBuilder.AppendFormatHelper(IFormatProvider provider String format ParamsArray args)
at System.String.FormatHelper(IFormatProvider provider String format ParamsArray args)
at System.String.Format(IFormatProvider provider String format Object[] args)
at NLog.Extensions.Logging.NLogLogger.Log[TState](LogLevel logLevel EventId eventId TState state Exception exception Func 3 formatter)
   at Microsoft.Extensions.Logging.Logger.Log[TState](LogLevel logLevel EventId eventId TState state Exception exception Func 3 formatter)}	System.Exception {System.FormatException}`

do not mind the NLog here had this exceptiong on office pc using regular M.E.L.Console
</Description>
    <Title_Description>Microsoft.Extensions.Logging issue Seems that from v2 release of Microsoft.Extensions.Logging the way of providing messages templates to logger.Log* functions became more suitable for structured/semantic logging.
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x#log-message-template
However Orleans still uses the 'string.Format' style of generating messages. In comparison to M.E.L proposed way of naming variables it just hides the possibility to implement custom log providers to have more intuitive/straightforward extraction of key/value pairs of important variables.
Moreover in case of line https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Serialization/SerializationManager.cs#L747   the old code leads to a bug. Calling this ( case of serializing non-immutable 1dim arrays of primitive types ) throws a `
System.AggregateException: 'An error occurred while writing to logger(s). (Index (zero based) must be greater than or equal to zero and less than the size of the argument list.)'
InnerException	{System.FormatException: Index (zero based) must be greater than or equal to zero and less than the size of the argument list.
at System.Text.StringBuilder.AppendFormatHelper(IFormatProvider provider String format ParamsArray args)
at System.String.FormatHelper(IFormatProvider provider String format ParamsArray args)
at System.String.Format(IFormatProvider provider String format Object[] args)
at NLog.Extensions.Logging.NLogLogger.Log[TState](LogLevel logLevel EventId eventId TState state Exception exception Func 3 formatter)
   at Microsoft.Extensions.Logging.Logger.Log[TState](LogLevel logLevel EventId eventId TState state Exception exception Func 3 formatter)}	System.Exception {System.FormatException}`

do not mind the NLog here had this exceptiong on office pc using regular M.E.L.Console
</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3906</IssueLabelID>
    <Title>【2.0.0-beta3】When the invalid Silo exists in Consul other SiloHost will be reported to be wrong in startup</Title>
    <Description>![tim 20180125183508](https://user-images.githubusercontent.com/8308243/35383995-e7ee81cc-01fe-11e8-8576-31ccf13c277a.png)
![tim 20180125183416](https://user-images.githubusercontent.com/8308243/35383999-ea87006c-01fe-11e8-9c01-2db504e1fee5.png)
</Description>
    <Title_Description>【2.0.0-beta3】When the invalid Silo exists in Consul, other SiloHost will be reported to be wrong in startup ![tim 20180125183508](https://user-images.githubusercontent.com/8308243/35383995-e7ee81cc-01fe-11e8-8576-31ccf13c277a.png)
![tim 20180125183416](https://user-images.githubusercontent.com/8308243/35383999-ea87006c-01fe-11e8-9c01-2db504e1fee5.png)
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>25/01/2018 10:38:39 AM +00:00</CreatedAt>
    <ClosedAt>5/02/2018 7:04:51 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3905</IssueLabelID>
    <Title>Does orleans support permission verification or is there any way to achieve?</Title>
    <Description>Does orleans support permission verification or is there any way to achieve?</Description>
    <Title_Description>Does orleans support permission verification, or is there any way to achieve? Does orleans support permission verification or is there any way to achieve?</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>25/01/2018 10:07:55 AM +00:00</CreatedAt>
    <ClosedAt>30/01/2018 3:09:42 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3903</IssueLabelID>
    <Title>how to use IClusterClient </Title>
    <Description>1.Create a static IClusterClient all use it. ex: static IClusterClient clusterClient = clusterClient.Connect().Wait();

2.or each client's method build a instance (IClusterClient clusterClient=IClientBuilder.Build() cost 0.5second)
then clusterClient.Connect()-&gt; todo-&gt;clusterClient.Dispose()  
next time IClusterClient clusterClient=IClientBuilder.Build()  clusterClient.Connect()-&gt; todo-&gt;clusterClient.Dispose()

Which one? or other?</Description>
    <Title_Description>how to use IClusterClient  1.Create a static IClusterClient all use it. ex: static IClusterClient clusterClient = clusterClient.Connect().Wait();

2.or each client's method build a instance (IClusterClient clusterClient=IClientBuilder.Build() cost 0.5second)
then clusterClient.Connect()-&gt; todo-&gt;clusterClient.Dispose()  
next time IClusterClient clusterClient=IClientBuilder.Build()  clusterClient.Connect()-&gt; todo-&gt;clusterClient.Dispose()

Which one? or other?</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>25/01/2018 2:41:41 AM +00:00</CreatedAt>
    <ClosedAt>25/01/2018 6:23:59 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3901</IssueLabelID>
    <Title>Move ClusterConfiguration to legacy</Title>
    <Description>Moved Cluster configuration to Orleans.Core.Legacy.
All references to it and related configuration classes have been removed from core Orleans packages.
Added a number of options to account for configuration data that had not been moved to options.
External packages and test libraries still rely on ClusterConfiguration and now depend on Orleans.Core.Legacy.  This can be cleaned up in future passes.</Description>
    <Title_Description>Move ClusterConfiguration to legacy Moved Cluster configuration to Orleans.Core.Legacy.
All references to it and related configuration classes have been removed from core Orleans packages.
Added a number of options to account for configuration data that had not been moved to options.
External packages and test libraries still rely on ClusterConfiguration and now depend on Orleans.Core.Legacy.  This can be cleaned up in future passes.</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3900</IssueLabelID>
    <Title>Add IOptionFormatter and IOptionResolver interfaces</Title>
    <Description>- Add IOptionFormatter and IOptionResolver interfaces
- Add extension methods to provide better usability to configure option and option formatter together 
- Added option formatter for some options as a starting point

Didn't end up adding interface `IOptionsLogger` for two reasons
- not many people will be interested in writing their own IOptionsLogger we should be wary to add an public interface which no user expressed need for
-  the interface is mostly just a marker interface as a marker interface it doesn't really bring any constraints or guidance on how user should be using it. 

So I end up just created two internal class `SiloOptionsLogger` and `ClientOptionsLogger` which share the same base class `OptionsLogger`. SiloOptionsLogger subscribed to silo lifecycle and ClientOptionsLogger subscribed to client lifecycle 

</Description>
    <Title_Description>Add IOptionFormatter and IOptionResolver interfaces - Add IOptionFormatter and IOptionResolver interfaces
- Add extension methods to provide better usability to configure option and option formatter together 
- Added option formatter for some options as a starting point

Didn't end up adding interface `IOptionsLogger` for two reasons
- not many people will be interested in writing their own IOptionsLogger we should be wary to add an public interface which no user expressed need for
-  the interface is mostly just a marker interface as a marker interface it doesn't really bring any constraints or guidance on how user should be using it. 

So I end up just created two internal class `SiloOptionsLogger` and `ClientOptionsLogger` which share the same base class `OptionsLogger`. SiloOptionsLogger subscribed to silo lifecycle and ClientOptionsLogger subscribed to client lifecycle 

</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3897</IssueLabelID>
    <Title>Add TelemetryOptions to configure Telemetry consumers</Title>
    <Description>I tested locally but unfortunately I don't have unit tests for this since it is a Windows specific features...

We should be able to add some testing in the future I think.</Description>
    <Title_Description>Add TelemetryOptions to configure Telemetry consumers I tested locally but unfortunately I don't have unit tests for this since it is a Windows specific features...

We should be able to add some testing in the future I think.</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3889</IssueLabelID>
    <Title>[Question] Azure network configuration for Orleans in Service Fabric</Title>
    <Description>I try run Orleans in Serivce Fabric. I have error "Invalid port specified" on client.
My client is web application defined in App Service
Silos run on Service Fabric. 
How I should to define the azure network for orleans client and server? Thanks
```
[UriFormatException: Invalid URI: Invalid port specified.]
   System.Uri.CreateThis(String uri Boolean dontEscape UriKind uriKind) +262
   Orleans.Runtime.Utils.ToGatewayUri(SiloAddress address) +182
   Orleans.Clustering.AdoNet.Storage.&lt;&gt;c__DisplayClass3_0`1.&lt;ReadAsync&gt;b__0(IDataRecord record Int32 i CancellationToken cancellationToken) +30
   Orleans.Clustering.AdoNet.Storage.&lt;SelectAsync&gt;d__13`1.MoveNext() +215
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.&lt;ExecuteReaderAsync&gt;d__14`1.MoveNext() +949
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.&lt;ExecuteAsync&gt;d__15`1.MoveNext() +1209
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.RelationalStorage.ReadAsync(String query Action`1 parameterProvider Func`4 selector CancellationToken cancellationToken CommandBehavior commandBehavior) +266
   Orleans.Clustering.AdoNet.Storage.RelationalStorageExtensions.ReadAsync(IRelationalStorage storage String query Func`2 selector Action`1 parameterProvider) +233
   Orleans.Clustering.AdoNet.Storage.&lt;ReadAsync&gt;d__7`2.MoveNext() +236
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Runtime.Membership.&lt;GetGateways&gt;d__12.MoveNext() +475
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Messaging.GatewayManager..ctor(ClientConfiguration cfg IGatewayListProvider gatewayListProvider ILoggerFactory loggerFactory) +254
   Orleans.Messaging.ProxiedMessageCenter..ctor(ClientConfiguration config IPAddress localAddress Int32 gen GrainId clientId IGatewayListProvider gatewayListProvider SerializationManager serializationManager IRuntimeClient runtimeClient MessageFactory messageFactory IClusterConnectionStatusListener connectionStatusListener ExecutorService executorService ILoggerFactory loggerFactory IOptions`1 networkingOptions) +370
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   Microsoft.Extensions.Internal.ConstructorMatcher.CreateInstance(IServiceProvider provider) +464
   Microsoft.Extensions.Internal.ActivatorUtilities.CreateInstance(IServiceProvider provider Object[] parameters) +61
   Orleans.&lt;StartInternal&gt;d__67.MoveNext() +438
```</Description>
    <Title_Description>[Question] Azure network configuration for Orleans in Service Fabric I try run Orleans in Serivce Fabric. I have error "Invalid port specified" on client.
My client is web application defined in App Service
Silos run on Service Fabric. 
How I should to define the azure network for orleans client and server? Thanks
```
[UriFormatException: Invalid URI: Invalid port specified.]
   System.Uri.CreateThis(String uri Boolean dontEscape UriKind uriKind) +262
   Orleans.Runtime.Utils.ToGatewayUri(SiloAddress address) +182
   Orleans.Clustering.AdoNet.Storage.&lt;&gt;c__DisplayClass3_0`1.&lt;ReadAsync&gt;b__0(IDataRecord record Int32 i CancellationToken cancellationToken) +30
   Orleans.Clustering.AdoNet.Storage.&lt;SelectAsync&gt;d__13`1.MoveNext() +215
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.&lt;ExecuteReaderAsync&gt;d__14`1.MoveNext() +949
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.&lt;ExecuteAsync&gt;d__15`1.MoveNext() +1209
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Clustering.AdoNet.Storage.RelationalStorage.ReadAsync(String query Action`1 parameterProvider Func`4 selector CancellationToken cancellationToken CommandBehavior commandBehavior) +266
   Orleans.Clustering.AdoNet.Storage.RelationalStorageExtensions.ReadAsync(IRelationalStorage storage String query Func`2 selector Action`1 parameterProvider) +233
   Orleans.Clustering.AdoNet.Storage.&lt;ReadAsync&gt;d__7`2.MoveNext() +236
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Runtime.Membership.&lt;GetGateways&gt;d__12.MoveNext() +475
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) +60
   Orleans.Messaging.GatewayManager..ctor(ClientConfiguration cfg IGatewayListProvider gatewayListProvider ILoggerFactory loggerFactory) +254
   Orleans.Messaging.ProxiedMessageCenter..ctor(ClientConfiguration config IPAddress localAddress Int32 gen GrainId clientId IGatewayListProvider gatewayListProvider SerializationManager serializationManager IRuntimeClient runtimeClient MessageFactory messageFactory IClusterConnectionStatusListener connectionStatusListener ExecutorService executorService ILoggerFactory loggerFactory IOptions`1 networkingOptions) +370
   System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() +31
   Microsoft.Extensions.Internal.ConstructorMatcher.CreateInstance(IServiceProvider provider) +464
   Microsoft.Extensions.Internal.ActivatorUtilities.CreateInstance(IServiceProvider provider Object[] parameters) +61
   Orleans.&lt;StartInternal&gt;d__67.MoveNext() +438
```</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3888</IssueLabelID>
    <Title>Silo to Silo Communication</Title>
    <Description>Hi we got a few questions regarding **silo to silo communication**. We have created an implementation using streams (SMS provider) and the communication works but we are facing a couple of issues with handling of subscriptions.

There are 2 different silos in this example: Silo A - the producer of the streaming events and Silo B - subscribes to these streams.
Below is a code sample for Silo B which demonstrates the usage with `EventManagerGrain` and `EventGrain`. Here we receive an exception:

&gt; System.AggregateException: One or more errors occurred. ---&gt; System.InvalidOperationException: Trying to send a message Request S127.0.0.1:22222:254231219-&gt; # 594:  on a silo not from within grain and not from within system target (RuntimeContext is not set to SchedulingContext) RuntimeContext.Current=null TaskScheduler.Current=System.Threading.Tasks.ThreadPoolTaskScheduler

`EventManagerGrain`
```C#
[ImplicitStreamSubscription("EventActivated")]
...

public async Task Init() 
{
  var streamProvider = _clusterClient.GetStreamProvider("SMSProvider");
  _activationStream = streamProvider.GetStream&lt;int&gt;(Guid.Empty "EventActivated");

  await _activationStream.SubscribeAsync(async (eventId token) =&gt;
  {
    // GrainFactory throws an exception here (see above)
    await GrainFactory.GetGrain&lt;IEventGrain&gt;(eventId).SubscribeStreams();
  });
}
```

`EventGrain`
```C#
[ImplicitStreamSubscription("ActionAdded")]
[ImplicitStreamSubscription("ActionRemoved")]
...

public async Task SubscribeStreams()
{
  var provider = _clusterClient.GetStreamProvider("SMSProvider");
  _actionAddedStream = provider.GetStream&lt;ActionAdded&gt;(this.GetPrimaryKey() "ActionAdded");
  _actionRemovedStream = provider.GetStream&lt;ActionRemoved&gt;(this.GetPrimaryKey() "ActionRemoved");

  await _actionAddedStream.SubscribeAsync((actionAdded token) =&gt; Handle(actionAdded)));
  await _actionRemovedStream.SubscribeAsync((actionRemoved token) =&gt; Handle(actionRemoved));
}
```
___

Another solution that has been considered is a central `DistributorService` that connects to all the silo clusters and receives messages (using a pub/sub framework) and distribute them to their corresponding silo using `ClusterClient`.
![Other solution](https://www.lucidchart.com/publicSegments/view/62f6062b-83a9-438f-83f8-925be3880d62/image.png)

We couldn't find any documentation describing approaches for silo-to-silo communication. Issue #1670 suggest communication over HTTP but will this be a viable solution? Some guidelines for best practices on this would be much appreciated. </Description>
    <Title_Description>Silo to Silo Communication Hi we got a few questions regarding **silo to silo communication**. We have created an implementation using streams (SMS provider) and the communication works but we are facing a couple of issues with handling of subscriptions.

There are 2 different silos in this example: Silo A - the producer of the streaming events and Silo B - subscribes to these streams.
Below is a code sample for Silo B which demonstrates the usage with `EventManagerGrain` and `EventGrain`. Here we receive an exception:

&gt; System.AggregateException: One or more errors occurred. ---&gt; System.InvalidOperationException: Trying to send a message Request S127.0.0.1:22222:254231219-&gt; # 594:  on a silo not from within grain and not from within system target (RuntimeContext is not set to SchedulingContext) RuntimeContext.Current=null TaskScheduler.Current=System.Threading.Tasks.ThreadPoolTaskScheduler

`EventManagerGrain`
```C#
[ImplicitStreamSubscription("EventActivated")]
...

public async Task Init() 
{
  var streamProvider = _clusterClient.GetStreamProvider("SMSProvider");
  _activationStream = streamProvider.GetStream&lt;int&gt;(Guid.Empty "EventActivated");

  await _activationStream.SubscribeAsync(async (eventId token) =&gt;
  {
    // GrainFactory throws an exception here (see above)
    await GrainFactory.GetGrain&lt;IEventGrain&gt;(eventId).SubscribeStreams();
  });
}
```

`EventGrain`
```C#
[ImplicitStreamSubscription("ActionAdded")]
[ImplicitStreamSubscription("ActionRemoved")]
...

public async Task SubscribeStreams()
{
  var provider = _clusterClient.GetStreamProvider("SMSProvider");
  _actionAddedStream = provider.GetStream&lt;ActionAdded&gt;(this.GetPrimaryKey() "ActionAdded");
  _actionRemovedStream = provider.GetStream&lt;ActionRemoved&gt;(this.GetPrimaryKey() "ActionRemoved");

  await _actionAddedStream.SubscribeAsync((actionAdded token) =&gt; Handle(actionAdded)));
  await _actionRemovedStream.SubscribeAsync((actionRemoved token) =&gt; Handle(actionRemoved));
}
```
___

Another solution that has been considered is a central `DistributorService` that connects to all the silo clusters and receives messages (using a pub/sub framework) and distribute them to their corresponding silo using `ClusterClient`.
![Other solution](https://www.lucidchart.com/publicSegments/view/62f6062b-83a9-438f-83f8-925be3880d62/image.png)

We couldn't find any documentation describing approaches for silo-to-silo communication. Issue #1670 suggest communication over HTTP but will this be a viable solution? Some guidelines for best practices on this would be much appreciated. </Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>22/01/2018 10:10:49 AM +00:00</CreatedAt>
    <ClosedAt>29/01/2018 4:00:50 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3887</IssueLabelID>
    <Title>Replaced life cycle stage enums with constants</Title>
    <Description>Lifecycle stage enums gave the impression that the stages were limited to only the defined enumes which was not the intention of the design.  They also necessitated the development and maintenance of extensions to support each enum.</Description>
    <Title_Description>Replaced life cycle stage enums with constants Lifecycle stage enums gave the impression that the stages were limited to only the defined enumes which was not the intention of the design.  They also necessitated the development and maintenance of extensions to support each enum.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3885</IssueLabelID>
    <Title>2.0.0-ci.20180118.3 build breaks transactional state storage</Title>
    <Description>After updating to 2.0.0-ci.20180118.3  I now get `System.InvalidOperationException: No default ITransactionalStateStorageFactory nor IStorageProvider was found while attempting to create transactional state storage.`

Switching back to 2.0.0-ci.20180116.5 makes the error go away. I suspect it is related to this commit: https://github.com/dotnet/orleans/commit/9bd486bb7368a83a37b7565e2d267aed959e4df7</Description>
    <Title_Description>2.0.0-ci.20180118.3 build breaks transactional state storage After updating to 2.0.0-ci.20180118.3  I now get `System.InvalidOperationException: No default ITransactionalStateStorageFactory nor IStorageProvider was found while attempting to create transactional state storage.`

Switching back to 2.0.0-ci.20180116.5 makes the error go away. I suspect it is related to this commit: https://github.com/dotnet/orleans/commit/9bd486bb7368a83a37b7565e2d267aed959e4df7</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3884</IssueLabelID>
    <Title> Updating Interceptors.md to include graincalls made from interceptors</Title>
    <Description>Adding grain calls from interceptors as a useful use case.</Description>
    <Title_Description> Updating Interceptors.md to include graincalls made from interceptors Adding grain calls from interceptors as a useful use case.</Title_Description>
    <Label>documentation</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3883</IssueLabelID>
    <Title>SerializationException under high load</Title>
    <Description>This issue tracks a non-root-caused issue whereby a SerializationException is thrown in the Message deserialization path usually during header deserialization when the system is under high load.

I don't know how to reproduce the issue.

**Example 1**

`Unexpected token '185' introducing type specifier`

**Example 2**

```
   Exception trying to process 43634 bytes from endpoint xx.xx.xxx.xx:58094  
Exc level 0: System.Runtime.Serialization.SerializationException: Attempt to read past the end of the input stream: CurrentPosition=20 n=1851879244 totalLength=523283
   at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n Int32&amp; offset Boolean&amp; safeToUse)
   at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n Int32&amp; offset)
   at Orleans.Serialization.BinaryTokenStreamReader.ReadString()
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context)
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e)
```

**Example 3**

```
!!!!!!!!!! Exception deserializing message body Exc level 0: System.ArgumentException: Extended key field is not null in non-extended UniqueIdentifier.
at Orleans.Runtime.UniqueKey.ValidateKeyExt(String keyExt UInt64 typeCodeData)
at Orleans.Runtime.UniqueKey.NewKey(UInt64 n0 UInt64 n1 UInt64 typeCodeData String keyExt)
at Orleans.Serialization.BinaryTokenStreamReader.ReadUniqueKey()
at Orleans.Serialization.BinaryTokenStreamReader.TryReadSimpleType(Object&amp; result SerializationTokenType&amp; token)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at AppEngine.Interfaces.States.OrleansCodeGenCti_Reg_Models_Models_ChildControlInformationSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Grains\obj\Release\AppEngine.Grains.orleans.g.cs:line 1064
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.BuiltInTypes.DeserializeList[T](Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) 
at AppEngine.Interfaces.States.OrleansCodeGenCti_Reg_Models_Models_FormSectionInformationSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Grains\obj\Release\AppEngine.Grains.orleans.g.cs:line 993
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) 
at AppEngine.Interfaces.OrleansCodeGenAppEngine.Interfaces_GrainMessages_ProcessModelMessageSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Interfaces\obj\Release\AppEngine.Interfaces.orleans.g.cs:line 4921
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.BuiltInTypes.DeserializeInvokeMethodRequest(Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.Deserialize(Type t BinaryTokenStreamReader stream)
at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
```

cc @sujesharukil who experienced this error [here](https://gitter.im/dotnet/orleans?at=5a544256290a1f456166ce91) [+here](https://gitter.im/dotnet/orleans?at=5a54341a0505ad8b45cf7192) [+here](https://gitter.im/dotnet/orleans?at=5a5430ef290a1f4561667f71)

Try reproducing with very large messages (&gt; 500KB) and high concurrency (concurrent messages)</Description>
    <Title_Description>SerializationException under high load This issue tracks a non-root-caused issue whereby a SerializationException is thrown in the Message deserialization path usually during header deserialization when the system is under high load.

I don't know how to reproduce the issue.

**Example 1**

`Unexpected token '185' introducing type specifier`

**Example 2**

```
   Exception trying to process 43634 bytes from endpoint xx.xx.xxx.xx:58094  
Exc level 0: System.Runtime.Serialization.SerializationException: Attempt to read past the end of the input stream: CurrentPosition=20 n=1851879244 totalLength=523283
   at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n Int32&amp; offset Boolean&amp; safeToUse)
   at Orleans.Serialization.BinaryTokenStreamReader.CheckLength(Int32 n Int32&amp; offset)
   at Orleans.Serialization.BinaryTokenStreamReader.ReadString()
   at Orleans.Runtime.Message.HeadersContainer.Deserializer(Type expected IDeserializationContext context)
   at Orleans.Serialization.SerializationManager.DeserializeMessageHeaders(IDeserializationContext context)
   at Orleans.Runtime.IncomingMessageBuffer.TryDecodeMessage(Message&amp; msg)
   at Orleans.Runtime.Messaging.IncomingMessageAcceptor.ReceiveCallbackContext.ProcessReceived(SocketAsyncEventArgs e)
```

**Example 3**

```
!!!!!!!!!! Exception deserializing message body Exc level 0: System.ArgumentException: Extended key field is not null in non-extended UniqueIdentifier.
at Orleans.Runtime.UniqueKey.ValidateKeyExt(String keyExt UInt64 typeCodeData)
at Orleans.Runtime.UniqueKey.NewKey(UInt64 n0 UInt64 n1 UInt64 typeCodeData String keyExt)
at Orleans.Serialization.BinaryTokenStreamReader.ReadUniqueKey()
at Orleans.Serialization.BinaryTokenStreamReader.TryReadSimpleType(Object&amp; result SerializationTokenType&amp; token)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at AppEngine.Interfaces.States.OrleansCodeGenCti_Reg_Models_Models_ChildControlInformationSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Grains\obj\Release\AppEngine.Grains.orleans.g.cs:line 1064
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.BuiltInTypes.DeserializeList[T](Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) 
at AppEngine.Interfaces.States.OrleansCodeGenCti_Reg_Models_Models_FormSectionInformationSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Grains\obj\Release\AppEngine.Grains.orleans.g.cs:line 993
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context) 
at AppEngine.Interfaces.OrleansCodeGenAppEngine.Interfaces_GrainMessages_ProcessModelMessageSerializer.Deserializer(Type expected IDeserializationContext context) in U:\Apps\App\src\AppEngine.Interfaces\obj\Release\AppEngine.Interfaces.orleans.g.cs:line 4921
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.BuiltInTypes.DeserializeInvokeMethodRequest(Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected IDeserializationContext context)
at Orleans.Serialization.SerializationManager.Deserialize(Type t BinaryTokenStreamReader stream)
at Orleans.Runtime.Message.DeserializeBody(SerializationManager serializationManager List`1 bytes)
```

cc @sujesharukil who experienced this error [here](https://gitter.im/dotnet/orleans?at=5a544256290a1f456166ce91) [+here](https://gitter.im/dotnet/orleans?at=5a54341a0505ad8b45cf7192) [+here](https://gitter.im/dotnet/orleans?at=5a5430ef290a1f4561667f71)

Try reproducing with very large messages (&gt; 500KB) and high concurrency (concurrent messages)</Title_Description>
    <Label>bug</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3882</IssueLabelID>
    <Title>[Question] - IExternalSerializer issue</Title>
    <Description>Just seeking some advice on how to get to the bottom of this problem.
I can see my custom serialiser is serialising my object on the client side and deserialising it on the server side.
I can see my grain is then activated on the server side.
However after activation my grain method on the server side is not actually invoked. The client instead reports an exception. I can't find anywhere to intercept this exception which I assume is happening on the server side but I am not sure. The stack trace isn't particularly hepful:

```
&gt; Result StackTrace:	
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Csla.Orleans.OrleansDataPortalProxy.&lt;Update&gt;d__8.MoveNext() in C:\Users\Darrell\Source\Repos\Csla.Orleans\src\Csla.Orleans\OrleansDataPortalProxy.cs:line 74
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal`1.&lt;DoUpdateAsync&gt;d__36.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal`1.&lt;UpdateAsync&gt;d__46.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal.&lt;UpdateAsync&gt;d__34`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Csla.Orleans.Tests.ConfigureTests.&lt;Can_Create&gt;d__4.MoveNext() in C:\Users\Darrell\Source\Repos\Csla.Orleans\Csla.Orleans.Tests\ConfigureTests.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Result Message:	System.NullReferenceException : Object reference not set to an instance of an object.
```

My serialiser only deserialises types that implement a particular interface `IMobileObject`. I have noticed other types like `InvokeRequest` which are orleans types that my serialiser returns `false` for when orlenas asks it if it can serialise them. Because of this my serialiser only takes responsibility for serialising the types that I am interested in - I am assuming that this is ok because the fallback serialisation methods will handle those other types?

I guess I am just wondering how I go about diagnosing why the grain method isn;t being invoked - how can I get some more detailed information? Starting with whether the server is reporting the exception (as I suspect as it happens after grain activation) or whether it purely happening on the client side.

</Description>
    <Title_Description>[Question] - IExternalSerializer issue Just seeking some advice on how to get to the bottom of this problem.
I can see my custom serialiser is serialising my object on the client side and deserialising it on the server side.
I can see my grain is then activated on the server side.
However after activation my grain method on the server side is not actually invoked. The client instead reports an exception. I can't find anywhere to intercept this exception which I assume is happening on the server side but I am not sure. The stack trace isn't particularly hepful:

```
&gt; Result StackTrace:	
at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Orleans.OrleansTaskExtentions.&lt;&lt;ToTypedTask&gt;g__ConvertAsync4_0&gt;d`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Csla.Orleans.OrleansDataPortalProxy.&lt;Update&gt;d__8.MoveNext() in C:\Users\Darrell\Source\Repos\Csla.Orleans\src\Csla.Orleans\OrleansDataPortalProxy.cs:line 74
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal`1.&lt;DoUpdateAsync&gt;d__36.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal`1.&lt;UpdateAsync&gt;d__46.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.DataPortal.&lt;UpdateAsync&gt;d__34`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Csla.BusinessBase`1.&lt;SaveAsync&gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Csla.Orleans.Tests.ConfigureTests.&lt;Can_Create&gt;d__4.MoveNext() in C:\Users\Darrell\Source\Repos\Csla.Orleans\Csla.Orleans.Tests\ConfigureTests.cs:line 83
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
Result Message:	System.NullReferenceException : Object reference not set to an instance of an object.
```

My serialiser only deserialises types that implement a particular interface `IMobileObject`. I have noticed other types like `InvokeRequest` which are orleans types that my serialiser returns `false` for when orlenas asks it if it can serialise them. Because of this my serialiser only takes responsibility for serialising the types that I am interested in - I am assuming that this is ok because the fallback serialisation methods will handle those other types?

I guess I am just wondering how I go about diagnosing why the grain method isn;t being invoked - how can I get some more detailed information? Starting with whether the server is reporting the exception (as I suspect as it happens after grain activation) or whether it purely happening on the client side.

</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3881</IssueLabelID>
    <Title>GrainClient OutOfMemoryException</Title>
    <Description>This is my Grain Client initialise code.  If it fails to connect to a gateway for long enough it runs out of memory.  Can someone help me identify why?

```
    public Action ConnectionToClusterLost { get; set; }

       public async Task&lt;IClusterClient&gt; InitialiseClient(ClientConfiguration config)
        {
            config.AddSimpleMessageStreamProvider("SMSProvider");
            config.ClientName = System.Diagnostics.Process.GetCurrentProcess().ProcessName;

            config.TraceToConsole = this.TraceToConsole;

            var descriptionString = config.GatewayProvider == ClientConfiguration.GatewayProviderType.SqlServer
                            ? config.DataConnectionString
                            : "Local";

            Console.WriteLine($"Starting Client -&gt; {descriptionString}");
            await this.myClientService.OnClientDebugMessage($"Starting Client -&gt; {descriptionString}");

            IClusterClient clusterClient = null;

            while (clusterClient == null)
            {
                try
                {
                    clusterClient = new ClientBuilder()
                       .AddClusterConnectionLostHandler((o e) =&gt;
                        {
                            ConnectionToClusterLost?.Invoke();
                        })
                       .UseConfiguration(config)
                       .Build();

                    await this.myClientService.OnClientDebugMessage($"Connecting");
                    await clusterClient.Connect();
                }
                catch (SiloUnavailableException ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Silo unavailable. {ex.Message}");

                    this.LastException = ex;
                }
                catch (OrleansException ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Orleans exception. {ex.Message}");
                    this.LastException = ex;
                }
                catch (Exception ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Unknown exception. {ex.Message}");
                    this.LastException = ex;
                }
                finally
                {
                    await this.myClientService.OnClientDebugMessage($"Waiting 1 second before trying again");
                    await Task.Delay(TimeSpan.FromSeconds(1));

                    if (clusterClient != null &amp;&amp; !clusterClient.IsInitialized)
                    {
                        clusterClient.Dispose();
                        clusterClient = null;
                    }
                }
            }

            await this.myClientService.OnClientDebugMessage($"Client Started!");
            Console.WriteLine("Client Started!");

            return clusterClient;
        }
```</Description>
    <Title_Description>GrainClient OutOfMemoryException This is my Grain Client initialise code.  If it fails to connect to a gateway for long enough it runs out of memory.  Can someone help me identify why?

```
    public Action ConnectionToClusterLost { get; set; }

       public async Task&lt;IClusterClient&gt; InitialiseClient(ClientConfiguration config)
        {
            config.AddSimpleMessageStreamProvider("SMSProvider");
            config.ClientName = System.Diagnostics.Process.GetCurrentProcess().ProcessName;

            config.TraceToConsole = this.TraceToConsole;

            var descriptionString = config.GatewayProvider == ClientConfiguration.GatewayProviderType.SqlServer
                            ? config.DataConnectionString
                            : "Local";

            Console.WriteLine($"Starting Client -&gt; {descriptionString}");
            await this.myClientService.OnClientDebugMessage($"Starting Client -&gt; {descriptionString}");

            IClusterClient clusterClient = null;

            while (clusterClient == null)
            {
                try
                {
                    clusterClient = new ClientBuilder()
                       .AddClusterConnectionLostHandler((o e) =&gt;
                        {
                            ConnectionToClusterLost?.Invoke();
                        })
                       .UseConfiguration(config)
                       .Build();

                    await this.myClientService.OnClientDebugMessage($"Connecting");
                    await clusterClient.Connect();
                }
                catch (SiloUnavailableException ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Silo unavailable. {ex.Message}");

                    this.LastException = ex;
                }
                catch (OrleansException ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Orleans exception. {ex.Message}");
                    this.LastException = ex;
                }
                catch (Exception ex)
                {
                    await this.myClientService.OnClientConnectionError(ex $"Unknown exception. {ex.Message}");
                    this.LastException = ex;
                }
                finally
                {
                    await this.myClientService.OnClientDebugMessage($"Waiting 1 second before trying again");
                    await Task.Delay(TimeSpan.FromSeconds(1));

                    if (clusterClient != null &amp;&amp; !clusterClient.IsInitialized)
                    {
                        clusterClient.Dispose();
                        clusterClient = null;
                    }
                }
            }

            await this.myClientService.OnClientDebugMessage($"Client Started!");
            Console.WriteLine("Client Started!");

            return clusterClient;
        }
```</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3880</IssueLabelID>
    <Title>Build Time Code Generation on MacOS Failing 2.0.0-beta3</Title>
    <Description>When attempting to build a 2.0.0 project on MacOS Sierra we get the attached Msbuild error: https://i.imgur.com/ikpdTq1.png

The text if the image won't load is as follows:

The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded for the assembly '.../Orleans.CodeGeneration.Build.dll'. Could not resolve type with token 0100001e (from typeref class/assembly System.MarshalByRefObject System.Runtime Version=4.2.0.0 Culture=neutral....

It looks like that goes on to cause a ReflectionTypeLoadException in MSBuild.

</Description>
    <Title_Description>Build Time Code Generation on MacOS Failing 2.0.0-beta3 When attempting to build a 2.0.0 project on MacOS Sierra we get the attached Msbuild error: https://i.imgur.com/ikpdTq1.png

The text if the image won't load is as follows:

The "Orleans.CodeGeneration.GetDotNetHost" task could not be loaded for the assembly '.../Orleans.CodeGeneration.Build.dll'. Could not resolve type with token 0100001e (from typeref class/assembly System.MarshalByRefObject System.Runtime Version=4.2.0.0 Culture=neutral....

It looks like that goes on to cause a ReflectionTypeLoadException in MSBuild.

</Title_Description>
    <Label>P2</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3879</IssueLabelID>
    <Title>Blocked when trying to create QueueClient</Title>
    <Description>Hi Guys

    Recently we are facing a timeout: "Response did not arrive on time in 00:01:00 for message"
 
    Here is the detailed of error:
   EventName="MessageEvent" Message="[2018-01-17 07:43:15.900 GMT    15	ERROR  	101212	Runtime.Scheduler.WorkerPoolThread/0	10.96.138.81:11111]	!!!!!!!!!! Worker pool thread Runtime.Scheduler.WorkerPoolThread/0 (ManagedThreadId=16) has been busy for long time: Executing Task Id=1 Status=Running for 00:09:26.4995991 on WorkItem=WorkItemGroup:Name=[Activation: xxxx Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:09:26.4995991. WorkItemGroup Details: WorkItemGroup:Name=[Activation: Placement=RandomPlacement]WorkGroupStatus=Running. Currently QueuedWorkItems=2; Total EnQueued=7; Total processed=4; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-13:Queued=2; Detailed SchedulingContext=&lt;[Activation:xxxx  Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=1 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:09:39.5444282 CollectionAgeLimit=02:00:00]&gt;.	" TraceSource="WaWorkerHost.exe"

     after add tracing we found that it's blocked at line of:
     QueueClient.CreateFromConnectionString(connectionString queueName)

     The strange is that it's only blocked when running in a cloud service while no block found if running locally. 

Here are the detailed info of the environment: 
Orleans: 1.2.3
WindowsAzure.ServiceBus: 3.2.2
&lt;package id="WindowsAzure.ServiceBus" version="3.2.2" targetFramework="net452" /&gt;

is there any graceful way to resolve it?

Many Thanks</Description>
    <Title_Description>Blocked when trying to create QueueClient Hi Guys

    Recently we are facing a timeout: "Response did not arrive on time in 00:01:00 for message"
 
    Here is the detailed of error:
   EventName="MessageEvent" Message="[2018-01-17 07:43:15.900 GMT    15	ERROR  	101212	Runtime.Scheduler.WorkerPoolThread/0	10.96.138.81:11111]	!!!!!!!!!! Worker pool thread Runtime.Scheduler.WorkerPoolThread/0 (ManagedThreadId=16) has been busy for long time: Executing Task Id=1 Status=Running for 00:09:26.4995991 on WorkItem=WorkItemGroup:Name=[Activation: xxxx Placement=RandomPlacement]WorkGroupStatus=Running Executing for 00:09:26.4995991. WorkItemGroup Details: WorkItemGroup:Name=[Activation: Placement=RandomPlacement]WorkGroupStatus=Running. Currently QueuedWorkItems=2; Total EnQueued=7; Total processed=4; Quantum expirations=0; TaskRunner=ActivationTaskScheduler-13:Queued=2; Detailed SchedulingContext=&lt;[Activation:xxxx  Placement=RandomPlacement State=Valid NonReentrancyQueueSize=0 EnqueuedOnDispatcher=1 InFlightCount=0 NumRunning=0 IdlenessTimeSpan=00:09:39.5444282 CollectionAgeLimit=02:00:00]&gt;.	" TraceSource="WaWorkerHost.exe"

     after add tracing we found that it's blocked at line of:
     QueueClient.CreateFromConnectionString(connectionString queueName)

     The strange is that it's only blocked when running in a cloud service while no block found if running locally. 

Here are the detailed info of the environment: 
Orleans: 1.2.3
WindowsAzure.ServiceBus: 3.2.2
&lt;package id="WindowsAzure.ServiceBus" version="3.2.2" targetFramework="net452" /&gt;

is there any graceful way to resolve it?

Many Thanks</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3877</IssueLabelID>
    <Title>[Question] What is the suggested pattern to use and query multiple unique keys in a single Grain?</Title>
    <Description>Lets say I have a simple Grain for an user account that stores data like this:

For every user:
- UserID
- Name
- Email

Now lets say I want to be able to do all of this:

1. Get Name from UserID
2. Get UserID from Name
3. Get Name and/or ID from Email Addr

Now what is the best approach here to store the data in a scalable way (not a single grain for all users) gaurantee each Fields uniqueness and also be able to query them using Orleans?

I assume it's not possible with Orleans by itself unless I make multiple mapping Grains that are shitty to maintain and require data duplications but what would be the suggested way to implement this functionalty?
</Description>
    <Title_Description>[Question] What is the suggested pattern to use and query multiple unique keys in a single Grain? Lets say I have a simple Grain for an user account that stores data like this:

For every user:
- UserID
- Name
- Email

Now lets say I want to be able to do all of this:

1. Get Name from UserID
2. Get UserID from Name
3. Get Name and/or ID from Email Addr

Now what is the best approach here to store the data in a scalable way (not a single grain for all users) gaurantee each Fields uniqueness and also be able to query them using Orleans?

I assume it's not possible with Orleans by itself unless I make multiple mapping Grains that are shitty to maintain and require data duplications but what would be the suggested way to implement this functionalty?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>17/01/2018 5:41:52 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2018 5:04:12 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3876</IssueLabelID>
    <Title>Deserialiser issue: Message: System.TypeAccessException </Title>
    <Description>I am using latest beta packages running on netcoreapp2.0 targeting netstandard2.0

I am having an issue implementing an `IExternalSerializer`.

I am seeing:

&gt; Message: System.TypeAccessException : Named type "Csla.Orleans.Tests.BusinessObjects.Root" is invalid: Type string "Csla.Orleans.Tests.BusinessObjects.Root" cannot be resolved.

Repro is here: ~https://github.com/dotnet/orleans/issues/1536~ https://github.com/dazinator/Csla.Orleans

1. Set `Csla.Orleans.TestLocalHost` project as the Startup project and run the solution.
2. CD into the `Csla.Orleans.Tests` directory and run `dotnet test` to run the xunit tests in the console - this will create a client and call the server passing an object which is serialized with the custom serialiser.

Alternatively to debug the client:

1. CD into `Csla.Orleans.TestLocalHost` and run `dotnet run`
2. Build the `Csla.Orleans.Tests` projects and then right click on the test named "Csla.Orleans.ConfigurerTests.Can_Create` in test explorer window and click "Debug Selected Test"


On the client side I can step through my custom serialiser and it seems to be serialising the object fine.

On the server side I can't see deserialising happening.

I then get the above error :-(

Any pointers greatly appreciated!</Description>
    <Title_Description>Deserialiser issue: Message: System.TypeAccessException  I am using latest beta packages running on netcoreapp2.0 targeting netstandard2.0

I am having an issue implementing an `IExternalSerializer`.

I am seeing:

&gt; Message: System.TypeAccessException : Named type "Csla.Orleans.Tests.BusinessObjects.Root" is invalid: Type string "Csla.Orleans.Tests.BusinessObjects.Root" cannot be resolved.

Repro is here: ~https://github.com/dotnet/orleans/issues/1536~ https://github.com/dazinator/Csla.Orleans

1. Set `Csla.Orleans.TestLocalHost` project as the Startup project and run the solution.
2. CD into the `Csla.Orleans.Tests` directory and run `dotnet test` to run the xunit tests in the console - this will create a client and call the server passing an object which is serialized with the custom serialiser.

Alternatively to debug the client:

1. CD into `Csla.Orleans.TestLocalHost` and run `dotnet run`
2. Build the `Csla.Orleans.Tests` projects and then right click on the test named "Csla.Orleans.ConfigurerTests.Can_Create` in test explorer window and click "Debug Selected Test"


On the client side I can step through my custom serialiser and it seems to be serialising the object fine.

On the server side I can't see deserialising happening.

I then get the above error :-(

Any pointers greatly appreciated!</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3874</IssueLabelID>
    <Title>Custom serializer and Stream</Title>
    <Description>I am attempting to write a custom serialiser based on CSLA's serialiser here:

https://github.com/MarimerLLC/csla/blob/0041bc665942aa7e3a4a546adde6e5f8ad715aab/Source/Csla.Shared/Serialization/Mobile/MobileFormatter.cs

Most serialiser implementations support deserializing from a `System.IO.Stream` and Serializing to a given `System.IO.Stream`.

However Orleans `IDeserializationContext` requires deserializing from a `IBinaryTokenStreamReader` which does not derive from stream as well as Serializing to a `IBinaryTokenStreamWriter` which again doesn't derive from stream.

I read some further comment here that suggests that third party serializer authors change their implementation:
https://github.com/dotnet/orleans/blob/master/src/Orleans.Serialization.Protobuf/ProtobufSerializer.cs#L81

If I want to plug in a third party serialiser that deals purely at the stream level - what is the recommended path for me to do that?

Is there some reason why `IBinaryTokenStreamWriter / Reader` can't derive from Stream or some StreamAdaptor can be written for them so that Orleans can gain easier pluggability?

At the moment I am deserializing by reading the data into a seperate memory stream like this:

```csharp
        public object Deserialize(Type expectedType IDeserializationContext context)
        {
            var size = context.StreamReader.ReadInt();        

            using (var memoryStream = new MemoryStream(size))
            {
                memoryStream.Write(context.StreamReader.ReadBytes(size) 0 size);               
                var deserialised = _cslaSerializarionFormatter.Deserialize(memoryStream);
                return deserialised;
            }     
        }
```

I am assuming this will essentially make a copy of the data? I am worried about performance of that.

Many Thanks</Description>
    <Title_Description>Custom serializer and Stream I am attempting to write a custom serialiser based on CSLA's serialiser here:

https://github.com/MarimerLLC/csla/blob/0041bc665942aa7e3a4a546adde6e5f8ad715aab/Source/Csla.Shared/Serialization/Mobile/MobileFormatter.cs

Most serialiser implementations support deserializing from a `System.IO.Stream` and Serializing to a given `System.IO.Stream`.

However Orleans `IDeserializationContext` requires deserializing from a `IBinaryTokenStreamReader` which does not derive from stream as well as Serializing to a `IBinaryTokenStreamWriter` which again doesn't derive from stream.

I read some further comment here that suggests that third party serializer authors change their implementation:
https://github.com/dotnet/orleans/blob/master/src/Orleans.Serialization.Protobuf/ProtobufSerializer.cs#L81

If I want to plug in a third party serialiser that deals purely at the stream level - what is the recommended path for me to do that?

Is there some reason why `IBinaryTokenStreamWriter / Reader` can't derive from Stream or some StreamAdaptor can be written for them so that Orleans can gain easier pluggability?

At the moment I am deserializing by reading the data into a seperate memory stream like this:

```csharp
        public object Deserialize(Type expectedType IDeserializationContext context)
        {
            var size = context.StreamReader.ReadInt();        

            using (var memoryStream = new MemoryStream(size))
            {
                memoryStream.Write(context.StreamReader.ReadBytes(size) 0 size);               
                var deserialised = _cslaSerializarionFormatter.Deserialize(memoryStream);
                return deserialised;
            }     
        }
```

I am assuming this will essentially make a copy of the data? I am worried about performance of that.

Many Thanks</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3866</IssueLabelID>
    <Title>Documentation clarification</Title>
    <Description>[The DI page](https://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Dependency-Injection.html) says this

&gt; However Orleans supports every container dependent injection mechanisms one of the most commonly used method is constructor injection.

I think what was intended was something like this

&gt; Orleans supports every container-dependent injection mechanism but one of the most commonly used methods is constructor injection shown here.

If I'm correct I think the sentence should be replaced as it is neither grammatical nor clear</Description>
    <Title_Description>Documentation clarification [The DI page](https://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Dependency-Injection.html) says this

&gt; However Orleans supports every container dependent injection mechanisms one of the most commonly used method is constructor injection.

I think what was intended was something like this

&gt; Orleans supports every container-dependent injection mechanism but one of the most commonly used methods is constructor injection shown here.

If I'm correct I think the sentence should be replaced as it is neither grammatical nor clear</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/01/2018 7:57:35 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3865</IssueLabelID>
    <Title>Improve and fix ADO.NET configuration documentation</Title>
    <Description>The ADO.NET documentation should be both fixed and improved.

- There is a problem described at https://github.com/dotnet/orleans/issues/3862.
- The documentation should also be clear that one ought to consider schemas and filegroups in a production application.

Cross-referenging https://github.com/dotnet/orleans/issues/3864.</Description>
    <Title_Description>Improve and fix ADO.NET configuration documentation The ADO.NET documentation should be both fixed and improved.

- There is a problem described at https://github.com/dotnet/orleans/issues/3862.
- The documentation should also be clear that one ought to consider schemas and filegroups in a production application.

Cross-referenging https://github.com/dotnet/orleans/issues/3864.</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>15/01/2018 5:40:36 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3863</IssueLabelID>
    <Title>DeploymentLoadPublisher implications of reducing inteval</Title>
    <Description>```
This class collects runtime statistics for all silos in the current deployment for use by placement.
```
https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs#L14

What is this statistics used for? Is it e.g. used internally to distribute load in the cluster or is it statistics for monitoring or both?

The reason for me asking is that it by default seem to tick every second so out of curiosity I want to know what the implications are if this internval decreased.

```
2018-01-14 20:51:18 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:18 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:18 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:18 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
2018-01-14 20:51:19 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:19 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:19 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:19 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
2018-01-14 20:51:20 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:20 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:20 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:20 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
```

Would be great with a documented API in the code so that one could understand in the IDE what a setting affects.</Description>
    <Title_Description>DeploymentLoadPublisher implications of reducing inteval ```
This class collects runtime statistics for all silos in the current deployment for use by placement.
```
https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Placement/DeploymentLoadPublisher.cs#L14

What is this statistics used for? Is it e.g. used internally to distribute load in the cluster or is it statistics for monitoring or both?

The reason for me asking is that it by default seem to tick every second so out of curiosity I want to know what the implications are if this internval decreased.

```
2018-01-14 20:51:18 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:18 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:18 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:18 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
2018-01-14 20:51:19 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:19 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:19 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:19 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
2018-01-14 20:51:20 [Debug] Orleans.Runtime.DeploymentLoadPublisher PublishStatistics.
2018-01-14 20:51:20 [Debug] Orleans.Runtime.SafeTimer Creating timer "Orleans.Runtime.sync.SafeTimerBase" with dueTime=00:30:00 period=-00:00:00.0010000
2018-01-14 20:51:20 [Debug] Orleans.Runtime.DeploymentLoadPublisher UpdateRuntimeStatistics from "S127.0.0.1:22222:253655457"
2018-01-14 20:51:20 [Debug] Orleans.Runtime.SafeTimer Disposing timer "Orleans.Runtime.sync.SafeTimerBase"
```

Would be great with a documented API in the code so that one could understand in the IDE what a setting affects.</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>14/01/2018 8:10:40 PM +00:00</CreatedAt>
    <ClosedAt>17/01/2018 5:10:52 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3859</IssueLabelID>
    <Title>Grain.InvokeException being reported as a Warning?</Title>
    <Description>why is Grain.InvokeException being reported as a Warning?

When tracking down a problem especially a problem with a stream message we get a Warning in the logs when an exception occurs.

Exception during Grain method call of message: Request S172.18.124.51:11111:253489437*cli/b116d8b2@db94af81-&gt;S172.18.124.53:11111:253489427*grn/3159BD7A/00000000+STRING_IDENT@069db998 #24: global::Rb.ReactivePrototype.PhoneGrainInterfaces.IPhoneGrain:PhoneGrainInviteReceived()


https://github.com/dotnet/orleans/blob/b0d7edfdb148614b1210cf37e0c0d555dc68b6c7/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L382

```
catch (Exception exc1)
                {
                    if (invokeExceptionLogger.IsEnabled(LogLevel.Debug) || message.Direction == Message.Directions.OneWay)
                    {
                        invokeExceptionLogger.Warn(ErrorCode.GrainInvokeException
                            "Exception during Grain method call of message: " + message exc1);
                    }
```

obviously we dont want to re-throw the exception but it would be nice to have it reported as an Error.   Was this intention?
</Description>
    <Title_Description>Grain.InvokeException being reported as a Warning? why is Grain.InvokeException being reported as a Warning?

When tracking down a problem especially a problem with a stream message we get a Warning in the logs when an exception occurs.

Exception during Grain method call of message: Request S172.18.124.51:11111:253489437*cli/b116d8b2@db94af81-&gt;S172.18.124.53:11111:253489427*grn/3159BD7A/00000000+STRING_IDENT@069db998 #24: global::Rb.ReactivePrototype.PhoneGrainInterfaces.IPhoneGrain:PhoneGrainInviteReceived()


https://github.com/dotnet/orleans/blob/b0d7edfdb148614b1210cf37e0c0d555dc68b6c7/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L382

```
catch (Exception exc1)
                {
                    if (invokeExceptionLogger.IsEnabled(LogLevel.Debug) || message.Direction == Message.Directions.OneWay)
                    {
                        invokeExceptionLogger.Warn(ErrorCode.GrainInvokeException
                            "Exception during Grain method call of message: " + message exc1);
                    }
```

obviously we dont want to re-throw the exception but it would be nice to have it reported as an Error.   Was this intention?
</Title_Description>
    <Label>question</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>13/01/2018 1:32:36 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2018 1:34:15 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3858</IssueLabelID>
    <Title>Move some streaming related helpers in abstractions</Title>
    <Description>While they are not really abstractions they are used by Grain project and it would be a pity to add a dependency on Core just for this helper functions...</Description>
    <Title_Description>Move some streaming related helpers in abstractions While they are not really abstractions they are used by Grain project and it would be a pity to add a dependency on Core just for this helper functions...</Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3853</IssueLabelID>
    <Title>Add OrleansJsonSerializer to external serializers causes circular references</Title>
    <Description>OrleansJsonSerializer's constructor:
`public OrleansJsonSerializer(SerializationManager serializationManager IGrainFactory grainFactory)`

RegisterSerializationProviders:
`var serializer = ActivatorUtilities.CreateInstance(serviceProvider typeInfo.AsType()) as IExternalSerializer;`</Description>
    <Title_Description>Add OrleansJsonSerializer to external serializers causes circular references OrleansJsonSerializer's constructor:
`public OrleansJsonSerializer(SerializationManager serializationManager IGrainFactory grainFactory)`

RegisterSerializationProviders:
`var serializer = ActivatorUtilities.CreateInstance(serviceProvider typeInfo.AsType()) as IExternalSerializer;`</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3852</IssueLabelID>
    <Title>Display grain type name in GrainId.ToString()</Title>
    <Description>Right now when a `GrainId` is logged its id and its `TypeCode` are logged. It could be useful to log the grain implementation name used instead.</Description>
    <Title_Description>Display grain type name in GrainId.ToString() Right now when a `GrainId` is logged its id and its `TypeCode` are logged. It could be useful to log the grain implementation name used instead.</Title_Description>
    <Label>enhancement</Label>
    <Assignee>benjaminpetit</Assignee>
    <CreatedAt>10/01/2018 11:58:08 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3851</IssueLabelID>
    <Title>Add StreamSubscriptionHandleFactory to subscribe onbehalf feature</Title>
    <Description>subscribe on behalf feature has a bug in it which makes it unusable. The cause of the bug is in streaming infra stream type is not parsed correctly to `IStreamSubscriptionObserver.OnSubscribe`. This PR introduces `IStreamSubscriptionHandleFactory` which requires user to give that type information as a way to fix that bug. 

There were other solutions discussed for this bug  but they all require more engineer hours. Based on the team's current capacity this seems to be the best way ATM to fix it. </Description>
    <Title_Description>Add StreamSubscriptionHandleFactory to subscribe onbehalf feature subscribe on behalf feature has a bug in it which makes it unusable. The cause of the bug is in streaming infra stream type is not parsed correctly to `IStreamSubscriptionObserver.OnSubscribe`. This PR introduces `IStreamSubscriptionHandleFactory` which requires user to give that type information as a way to fix that bug. 

There were other solutions discussed for this bug  but they all require more engineer hours. Based on the team's current capacity this seems to be the best way ATM to fix it. </Title_Description>
    <Label>
    </Label>
    <Assignee>jason-bragg</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3850</IssueLabelID>
    <Title>Process Response messages before Request messages</Title>
    <Description>Currently response messages and request messages are both treated equally by `ActivationData`.

For improving call latency on hot grains it might be beneficial to process response messages with higher priority than request messages.</Description>
    <Title_Description>Process Response messages before Request messages Currently response messages and request messages are both treated equally by `ActivationData`.

For improving call latency on hot grains it might be beneficial to process response messages with higher priority than request messages.</Title_Description>
    <Label>performance</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>10/01/2018 11:44:55 PM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3849</IssueLabelID>
    <Title>Display GrainId/type of SystemGrain and SystemTarget in GrainId.ToStringImpl</Title>
    <Description>Related to #3844 </Description>
    <Title_Description>Display GrainId/type of SystemGrain and SystemTarget in GrainId.ToStringImpl Related to #3844 </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3848</IssueLabelID>
    <Title>[Question] Streams limitations lots of subscribe/unsubscribes</Title>
    <Description>I'm trying to use orleans streams to manage channel subscriptions in a websocket server. What happens is when sockets are connected the server will ask a grain to give back a stream Id. The socket server (orleans client) then creates a subscription to that stream. Now these are a lot of subscriptions/unsubscriptions and when the numbers grow I start to receive lots of exceptions on the client side when adding a message to the stream. SerializationExceptions to be exact.

Now my question is does the runtime sends a message from the silo for each subscription on the client side or one message will be sent to the client and then the client forwards it to all local subscribers?
And on the broader sense is using streams in this way a good choice for this scenario?

_I'm using SMS provider with fire and forget and a memory storage provider for pubsubstore._

Things I've already tried to find the cause:
- Made stream messages Immutable. This was actually the way it was from the beginning this leads to NullReferenceExceptions which made me think maybe the message is disposed (well not technically speaking).
- Added ILBasedSerializer for fallback serializer. No help to get the actual exception message.</Description>
    <Title_Description>[Question] Streams limitations, lots of subscribe/unsubscribes I'm trying to use orleans streams to manage channel subscriptions in a websocket server. What happens is when sockets are connected the server will ask a grain to give back a stream Id. The socket server (orleans client) then creates a subscription to that stream. Now these are a lot of subscriptions/unsubscriptions and when the numbers grow I start to receive lots of exceptions on the client side when adding a message to the stream. SerializationExceptions to be exact.

Now my question is does the runtime sends a message from the silo for each subscription on the client side or one message will be sent to the client and then the client forwards it to all local subscribers?
And on the broader sense is using streams in this way a good choice for this scenario?

_I'm using SMS provider with fire and forget and a memory storage provider for pubsubstore._

Things I've already tried to find the cause:
- Made stream messages Immutable. This was actually the way it was from the beginning this leads to NullReferenceExceptions which made me think maybe the message is disposed (well not technically speaking).
- Added ILBasedSerializer for fallback serializer. No help to get the actual exception message.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3847</IssueLabelID>
    <Title>Dependency Injection in ASP.NET Core</Title>
    <Description>Hi there .. for orleans 2.0 what I should register to IServiceCollection? ClientBuilder? what will be its lifetimes? Transient or Scoped or Singleton? Thanks for help.</Description>
    <Title_Description>Dependency Injection in ASP.NET Core Hi there .. for orleans 2.0 what I should register to IServiceCollection? ClientBuilder? what will be its lifetimes? Transient or Scoped or Singleton? Thanks for help.</Title_Description>
    <Label>question</Label>
    <Assignee>ReubenBond</Assignee>
    <CreatedAt>10/01/2018 11:04:51 AM +00:00</CreatedAt>
    <ClosedAt>11/01/2018 2:31:08 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3846</IssueLabelID>
    <Title>A fsharp sample for .net core based on orleans 2.0</Title>
    <Description>This PRs is reated to issue #3845. It is a fsharp sample for .net core. Thanks to @ReubenBond for his help.</Description>
    <Title_Description>A fsharp sample for .net core, based on orleans 2.0 This PRs is reated to issue #3845. It is a fsharp sample for .net core. Thanks to @ReubenBond for his help.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3845</IssueLabelID>
    <Title>New samples for fsharp based on version 2</Title>
    <Description>Hi there

can we have a new sample for fsharp which based on version 2? thanks :)
  </Description>
    <Title_Description>New samples for fsharp based on version 2 Hi there

can we have a new sample for fsharp which based on version 2? thanks :)
  </Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3844</IssueLabelID>
    <Title>Resolve code omitted by ABSTRACTIONS_TODO</Title>
    <Description>https://github.com/dotnet/orleans/blob/a132a5acaf74ceb233fdf08ba497f384ce1c95ff/src/Orleans.Core.Abstractions/IDs/GrainId.cs#L219

https://github.com/dotnet/orleans/blob/a132a5acaf74ceb233fdf08ba497f384ce1c95ff/src/Orleans.Core.Abstractions/IDs/GrainId.cs#L253

SystemTargets are showing up in logs with with `???` in place of their type like `Orleans.Streams.???/ea97e894.Router]	Created PersistentStreamPullingAgent ???/459873b2bfab8e5b6bbeab2bea97e89401000000000000ff-0x6AE30F88`</Description>
    <Title_Description>Resolve code omitted by ABSTRACTIONS_TODO https://github.com/dotnet/orleans/blob/a132a5acaf74ceb233fdf08ba497f384ce1c95ff/src/Orleans.Core.Abstractions/IDs/GrainId.cs#L219

https://github.com/dotnet/orleans/blob/a132a5acaf74ceb233fdf08ba497f384ce1c95ff/src/Orleans.Core.Abstractions/IDs/GrainId.cs#L253

SystemTargets are showing up in logs with with `???` in place of their type like `Orleans.Streams.???/ea97e894.Router]	Created PersistentStreamPullingAgent ???/459873b2bfab8e5b6bbeab2bea97e89401000000000000ff-0x6AE30F88`</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3841</IssueLabelID>
    <Title>How to create a reader-writer grain with parallel reads</Title>
    <Description>I'm facing an issue similar to what is discussed (but not resolved) in #1468. Basically I need a reader-writer grain(s?) to hold some values so other parts of the system can reference them frequently and in parallel.

What I'm after is storing some system-wide config values which are accessed frequently and subject to change but only *extremely* rarely (once a month or so at most). The system should be reconfigurable without downtime. What I'm currently considering is to store the data in some database. Then it will be read at silo startup and there will be a special callback to read the data again after it changes externally. I don't want to read the data from the database every time I need it because:

1. It'll create unnecessary processing overhead inside the silo as some of the data must be processed and filtered out.
2. It'll increase load on the database which I cannot guarantee will be as good at handling high load as the silo environment.
3. The data is verified by the silo environment before it is updated. Reading directly from the database means there will be no middle layer to hold the last known valid data while the operator updates and fixes the new data.

I can easily create a reader-writer locked in-memory data store but Orleans' single-threaded execution policy doesn't allow parallel access to the grain that holds the data. I can think of the following ways to bypass this:

1. Have multiple copies of the data inside multiple grains. This is obviously not optimal.
2. Use static fields to store the data and make the grain a stateless worker. This means every silo has its own copy of the data (which also helps with reducing network load) but there is no means of asking every *silo* to update its copy of the data (that I know of at least).

Suggestions?
  </Description>
    <Title_Description>How to create a reader-writer grain with parallel reads I'm facing an issue similar to what is discussed (but not resolved) in #1468. Basically I need a reader-writer grain(s?) to hold some values so other parts of the system can reference them frequently and in parallel.

What I'm after is storing some system-wide config values which are accessed frequently and subject to change but only *extremely* rarely (once a month or so at most). The system should be reconfigurable without downtime. What I'm currently considering is to store the data in some database. Then it will be read at silo startup and there will be a special callback to read the data again after it changes externally. I don't want to read the data from the database every time I need it because:

1. It'll create unnecessary processing overhead inside the silo as some of the data must be processed and filtered out.
2. It'll increase load on the database which I cannot guarantee will be as good at handling high load as the silo environment.
3. The data is verified by the silo environment before it is updated. Reading directly from the database means there will be no middle layer to hold the last known valid data while the operator updates and fixes the new data.

I can easily create a reader-writer locked in-memory data store but Orleans' single-threaded execution policy doesn't allow parallel access to the grain that holds the data. I can think of the following ways to bypass this:

1. Have multiple copies of the data inside multiple grains. This is obviously not optimal.
2. Use static fields to store the data and make the grain a stateless worker. This means every silo has its own copy of the data (which also helps with reducing network load) but there is no means of asking every *silo* to update its copy of the data (that I know of at least).

Suggestions?
  </Title_Description>
    <Label>question</Label>
    <Assignee>rikbosch</Assignee>
    <CreatedAt>8/01/2018 6:35:55 AM +00:00</CreatedAt>
    <ClosedAt>31/01/2018 1:32:56 AM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3840</IssueLabelID>
    <Title>ClientInvokeCallback for grain to grain call in Orleans 1.5.3</Title>
    <Description>I am migrating project from Orleans 1.4.2 to 1.5.3 and faced with issue set ClientInvokeCallback inside Silo. We are using ClientInvokeCallback/IGrainCallFilter(IProviderRuntime.SetInvokeInterceptor in 1.4.2) for propagate log correlation id between http frontend -&gt; grain and grain to grain call but looks like in Orleans v1.5.3 it is not possible anymore set ClientInvokeCallback inside Silo as GrainClient uses directly OutsideRuntimeClient class (and guard which checks client initialization was added). What is proper way to add ClientInvokeCallback for grain to grain call inside Silo? or something other should be used for the same purpose?</Description>
    <Title_Description>ClientInvokeCallback for grain to grain call in Orleans 1.5.3 I am migrating project from Orleans 1.4.2 to 1.5.3 and faced with issue set ClientInvokeCallback inside Silo. We are using ClientInvokeCallback/IGrainCallFilter(IProviderRuntime.SetInvokeInterceptor in 1.4.2) for propagate log correlation id between http frontend -&gt; grain and grain to grain call but looks like in Orleans v1.5.3 it is not possible anymore set ClientInvokeCallback inside Silo as GrainClient uses directly OutsideRuntimeClient class (and guard which checks client initialization was added). What is proper way to add ClientInvokeCallback for grain to grain call inside Silo? or something other should be used for the same purpose?</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3839</IssueLabelID>
    <Title>Docs: missing lifetime info about client</Title>
    <Description>Regarding: http://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html

It would be nice with a couple of notes of recommended lifetime scope of clients for different environments e.g. web.

Also would be nice with information about what happens if the socket goes down after some requests? Will it auto-reconnect?</Description>
    <Title_Description>Docs: missing lifetime info about client Regarding: http://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Developing-a-Client.html

It would be nice with a couple of notes of recommended lifetime scope of clients for different environments e.g. web.

Also would be nice with information about what happens if the socket goes down after some requests? Will it auto-reconnect?</Title_Description>
    <Label>documentation</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>7/01/2018 10:53:05 AM +00:00</CreatedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3838</IssueLabelID>
    <Title>Use e.g. extension methods on config to make it more obvious</Title>
    <Description>Was trying to find good info about configuration e.g. on how to turn trace logging and statistics off. Found this: http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html

Which says: 

```
//TraceFilePattern = "false" // Set it to false or none to disable file tracing effectively it sets config.Defaults.TraceFileName = null;
```

That is not really obvious. Could be simplified with a simple extension method or something:

```
config.DisableFileTracing();
```

When it comes to statistics I'm not sure if it's enough to do `StatisticsWriteLogStatisticsToTable = false` or if you have to assign `TimeSpan.FromMilliseconds(-1)` (weird that `TimeSpan.Zero` isn't accepted) to some of the intervals. Could also be something like:

```
config.DisableStatistics();
```</Description>
    <Title_Description>Use e.g. extension methods on config to make it more obvious Was trying to find good info about configuration e.g. on how to turn trace logging and statistics off. Found this: http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Client-Configuration.html

Which says: 

```
//TraceFilePattern = "false" // Set it to false or none to disable file tracing effectively it sets config.Defaults.TraceFileName = null;
```

That is not really obvious. Could be simplified with a simple extension method or something:

```
config.DisableFileTracing();
```

When it comes to statistics I'm not sure if it's enough to do `StatisticsWriteLogStatisticsToTable = false` or if you have to assign `TimeSpan.FromMilliseconds(-1)` (weird that `TimeSpan.Zero` isn't accepted) to some of the intervals. Could also be something like:

```
config.DisableStatistics();
```</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3837</IssueLabelID>
    <Title>Docs and logs inconsistent</Title>
    <Description>Docs (http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html) says GC should be configured:

```
&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;gcServer enabled="true"/&gt;
    &lt;gcConcurrent enabled="true"/&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;

```

But when doing so logs seem to recommend `gcConcurrent.enabled=false`.

```
Note: Silo not running with ServerGC turned on or with GCLatencyMode.Batch enabled - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt; and &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcConcurrent enabled="false"/&gt;
```

How should it be?</Description>
    <Title_Description>Docs and logs, inconsistent Docs (http://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Configuring-.NET-Garbage-Collection.html) says GC should be configured:

```
&lt;configuration&gt;
  &lt;runtime&gt;
    &lt;gcServer enabled="true"/&gt;
    &lt;gcConcurrent enabled="true"/&gt;
  &lt;/runtime&gt;
&lt;/configuration&gt;

```

But when doing so logs seem to recommend `gcConcurrent.enabled=false`.

```
Note: Silo not running with ServerGC turned on or with GCLatencyMode.Batch enabled - recommend checking app config : &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcServer enabled="true"&gt; and &lt;configuration&gt;-&lt;runtime&gt;-&lt;gcConcurrent enabled="false"/&gt;
```

How should it be?</Title_Description>
    <Label>
    </Label>
    <Assignee>sergeybykov</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3835</IssueLabelID>
    <Title>ClientConfiguration.LoadFromFile sync over async</Title>
    <Description>Works like a charm when executing in a context where restoring on captured context isn't a problem (e.g. Console) but when switching to e.g. ASP.Net environment where bootstraping happens in a non async flow one might think that the exposed `ClientConfiguration.LoadFromFile()` is safe (due to being sync). This seems to be wrong.

https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ConfigUtilities.cs#L349
https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ClusterConfiguration.cs#L440

None of the lines has `ConfigureAwait(false)` so when https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ClientConfiguration.cs#L222 happens the blocking call seem to cause a dead-lock at least it hangs for me.

Either expose `LoadFromFile` as pure `async` and let the consumer decide or perhaps start using `ConfigureAwait(false)`? Guess the first option is hard has that would be breaking and exposing `LoadFromFileAsync` is hard is not an option since that seem to violate the naming convention with other async methods.</Description>
    <Title_Description>ClientConfiguration.LoadFromFile, sync over async Works like a charm when executing in a context where restoring on captured context isn't a problem (e.g. Console) but when switching to e.g. ASP.Net environment where bootstraping happens in a non async flow one might think that the exposed `ClientConfiguration.LoadFromFile()` is safe (due to being sync). This seems to be wrong.

https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ConfigUtilities.cs#L349
https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ClusterConfiguration.cs#L440

None of the lines has `ConfigureAwait(false)` so when https://github.com/dotnet/orleans/blob/master/src/Orleans.Core/Configuration/ClientConfiguration.cs#L222 happens the blocking call seem to cause a dead-lock at least it hangs for me.

Either expose `LoadFromFile` as pure `async` and let the consumer decide or perhaps start using `ConfigureAwait(false)`? Guess the first option is hard has that would be breaking and exposing `LoadFromFileAsync` is hard is not an option since that seem to violate the naming convention with other async methods.</Title_Description>
    <Label>
    </Label>
    <Assignee>xiazen</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3833</IssueLabelID>
    <Title>Remove dependency on Orleans.Runtime from most extension projects</Title>
    <Description>This address #198 although a bit indirectly.

With this change most extensions don't need to reference `Orleans.Runtime` anymore. That is particularly important for `.Clustering` and `.Streaming` extensions that are used on the client side. Only .Hosting extensions now reference `Orleans.Runtime` which makes perfect sense for them to do.

Being a meta-package now `AzureUtils` will still bring `Orleans.Runtime` as a dependency because `AzureUtils` includes `Orleans.Hosting.AzureCloudServices`. But by referencing instead individual packages such as `Orleans.Clustering.AzureStorage` `Orleans.Streaming.AzureStorage` and `Orleans.Streaming.EventHubs` one can now avoid bringing `Orleans.Runtime` to the client.

`OrleansAWSUtils` and `OrleansSQLUtils` don't bring `Orleans.Runtime` anymore because they don't have hosting packages. Neither do `Orleans.Clustering.Consul` and `Orleans.Clustering.ZooKeeper`.

`Orleans.Runtime.Abstractions` is probably not the best name for this assembly/package but I couldn't come up with a better one.</Description>
    <Title_Description>Remove dependency on Orleans.Runtime from most extension projects This address #198 although a bit indirectly.

With this change most extensions don't need to reference `Orleans.Runtime` anymore. That is particularly important for `.Clustering` and `.Streaming` extensions that are used on the client side. Only .Hosting extensions now reference `Orleans.Runtime` which makes perfect sense for them to do.

Being a meta-package now `AzureUtils` will still bring `Orleans.Runtime` as a dependency because `AzureUtils` includes `Orleans.Hosting.AzureCloudServices`. But by referencing instead individual packages such as `Orleans.Clustering.AzureStorage` `Orleans.Streaming.AzureStorage` and `Orleans.Streaming.EventHubs` one can now avoid bringing `Orleans.Runtime` to the client.

`OrleansAWSUtils` and `OrleansSQLUtils` don't bring `Orleans.Runtime` anymore because they don't have hosting packages. Neither do `Orleans.Clustering.Consul` and `Orleans.Clustering.ZooKeeper`.

`Orleans.Runtime.Abstractions` is probably not the best name for this assembly/package but I couldn't come up with a better one.</Title_Description>
    <Label>
    </Label>
    <Assignee>ReubenBond</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3832</IssueLabelID>
    <Title>ToGatewayUri will cause exception when using IPv6</Title>
    <Description>Orleans.Core\Utils\Utils.cs 
Method 
        **public static Uri ToGatewayUri(this System.Net.IPEndPoint ep)**
and         
        **public static Uri ToGatewayUri(this SiloAddress address)**
will generate UriFormatException exception when Address is the IPv6 format.

I think UriBuilder should fix the problem.
Code below:

        public static Uri ToGatewayUri(this System.Net.IPEndPoint ep)
        {
            var builder = new UriBuilder("gwy.tcp" ep.Address.ToString() ep.Port);
            return builder.Uri;
        }

        /// &lt;summary&gt;
        /// Represent a silo address in the gateway URI format.
        /// &lt;/summary&gt;
        /// &lt;param name="address"&gt;The input silo address&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Uri ToGatewayUri(this SiloAddress address)
        {
            var builder = new UriBuilder("gwy.tcp" address.Endpoint.Address.ToString() address.Endpoint.Port address.Generation.ToString());
            return builder.Uri;
        }</Description>
    <Title_Description>ToGatewayUri will cause exception when using IPv6 Orleans.Core\Utils\Utils.cs 
Method 
        **public static Uri ToGatewayUri(this System.Net.IPEndPoint ep)**
and         
        **public static Uri ToGatewayUri(this SiloAddress address)**
will generate UriFormatException exception when Address is the IPv6 format.

I think UriBuilder should fix the problem.
Code below:

        public static Uri ToGatewayUri(this System.Net.IPEndPoint ep)
        {
            var builder = new UriBuilder("gwy.tcp" ep.Address.ToString() ep.Port);
            return builder.Uri;
        }

        /// &lt;summary&gt;
        /// Represent a silo address in the gateway URI format.
        /// &lt;/summary&gt;
        /// &lt;param name="address"&gt;The input silo address&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static Uri ToGatewayUri(this SiloAddress address)
        {
            var builder = new UriBuilder("gwy.tcp" address.Endpoint.Address.ToString() address.Endpoint.Port address.Generation.ToString());
            return builder.Uri;
        }</Title_Description>
    <Label>bug</Label>
    <Assignee>sergeybykov</Assignee>
    <CreatedAt>5/01/2018 9:03:34 PM +00:00</CreatedAt>
    <ClosedAt>30/01/2018 9:36:22 PM +00:00</ClosedAt>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3831</IssueLabelID>
    <Title>Remove unnecessary dependencies on Orleans.Runtime from extension projects</Title>
    <Description>With this change only .Clustering .Reminders and .Hosting extensions will have a dependency on Orleans.Runtime. Removing those requires a bigger change.</Description>
    <Title_Description>Remove unnecessary dependencies on Orleans.Runtime from extension projects With this change only .Clustering .Reminders and .Hosting extensions will have a dependency on Orleans.Runtime. Removing those requires a bigger change.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
  <IssueDetail>
    <IssueLabelID>3830</IssueLabelID>
    <Title>Calling grain method using GrainClient hangs after running for some time</Title>
    <Description>I am using ASP.NET and I have a controller method uses `GrainClient` within   If I run ASP.NET then instantly call this controller the call to the grain works correctly.  

At some point in the future this stops working I havent tracked down exactly how long it takes but certainly if I leave it running over night it fails in the morning.

If I step through the code I get a grain reference of  `{GrainReference:*grn/A97D1470/00000000}`. 

If I turn on all exceptions the call to the grain throws this exception

&gt; System.Net.Sockets.SocketException: 'An existing connection was forcibly closed by the remote host'

The NativeErrorCode is `10054`

Oddly enough this exception doesnt seem to bubble up through ASP.NET and make the call fail.</Description>
    <Title_Description>Calling grain method using GrainClient hangs after running for some time I am using ASP.NET and I have a controller method uses `GrainClient` within   If I run ASP.NET then instantly call this controller the call to the grain works correctly.  

At some point in the future this stops working I havent tracked down exactly how long it takes but certainly if I leave it running over night it fails in the morning.

If I step through the code I get a grain reference of  `{GrainReference:*grn/A97D1470/00000000}`. 

If I turn on all exceptions the call to the grain throws this exception

&gt; System.Net.Sockets.SocketException: 'An existing connection was forcibly closed by the remote host'

The NativeErrorCode is `10054`

Oddly enough this exception doesnt seem to bubble up through ASP.NET and make the call fail.</Title_Description>
    <Label>
    </Label>
    <Assignee>benjaminpetit</Assignee>
  </IssueDetail>
</IssueDetails>