<PullRequests>
  <PullRequest>
    <IssueID>6960</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>vjgarciag96</FixedByID>
    <Title>2 Fix Observable flat Map with max Concurrency hangs </Title>
    <Description>Just a backport to of the fix for the scalar queue max concurrency issue already fixed for in The code for the fix has been added and also the test for it.In addition, as was also done for, the corresponding test for Flowable Flat Map has been added. Resolves</Description>
    <CreatedDate>14/04/2020</CreatedDate>
    <ClosedDate>15/04/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>2.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6960</PullRequestID>
        <IssueID>6946</IssueID>
        <Title>Fix Observable flatMap with max Concurrency hangs</Title>
        <Description>Queued up scalar values were not counted as completed, thus the subsequent sources where not subscribed to to fill up the allowed concurrency level Fixes</Description>
        <CreatedDate>04/04/2020</CreatedDate>
        <ClosedDate>04/04/2020</ClosedDate>
        <Labels>
          <Label>3</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6960</PullRequestID>
        <IssueID>6946</IssueID>
        <Title>Fix Observable flat Map with max Concurrency hangs</Title>
        <Description>Queued up scalar values were not counted as completed, thus the subsequent sources where not subscribed to to fill up the allowed concurrency level.Fixes </Description>
        <CreatedDate>04/04/2020</CreatedDate>
        <ClosedDate>04/04/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6960</PullRequestID>
        <IssueID>6947</IssueID>
        <Title>open for grabs backport</Title>
        <Description>Fix for the scalar queue max concurrency issue already fixed for in</Description>
        <CreatedDate>04/04/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>2.x</Label>
          <Label>Bug</Label>
          <Label>PR welcome</Label>
          <Label>good first issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6946</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>Fix Observable flat Map with max Concurrency hangs</Title>
    <Description>Queued up scalar values were not counted as completed thus the subsequent sources where not subscribed to to fill up the allowed concurrency level Fixes</Description>
    <CreatedDate>04/04/2020</CreatedDate>
    <ClosedDate>04/04/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6946</PullRequestID>
        <IssueID>6945</IssueID>
        <Title>Deadlock</Title>
        <Code>
		 if (integer % 5 != 0) {
                    return Observable
                            .just(integer);
                }

                return Observable
                        .just(-integer)
                        .observeOn(Schedulers.io());
        </Code>
        <Description>RXJava I randomly got into a weird situation where my code entered a deadlock and I dont know why. I simplified the code and got to the below part which will enter a deadlock and never return.
This seems like a bug, but maybe I'm missing something. The code</Description>
        <CreatedDate>04/04/2020</CreatedDate>
        <ClosedDate>04/04/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6944</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>tomislavhofman</FixedByID>
    <Title>Updateimageurlstonontransparentversion.</Title>
    <Description>Updated image urls to use non-transparent ones as per Resolves</Description>
    <CreatedDate>02/04/2020</CreatedDate>
    <ClosedDate>02/04/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Documentation</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6944</PullRequestID>
        <IssueID>6883</IssueID>
        <Title>Marbles should have a proper background</Title>
        <Description>The transparent ones look terrible with dark themed IDEs or non light background image Only looks fine in Eclipse Write a program that goes through the images in  images rx operators checks if the image has transparency draw it onto a white background then save it as originalName v3 png because some of those are linked all around Find the filename in the source code and replace them.</Description>
        <CreatedDate>27/01/2020</CreatedDate>
        <ClosedDate>02/04/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Cleanup</Label>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6944</PullRequestID>
        <IssueID>6883</IssueID>
        <Title>Marbles should have a proper background</Title>
        <Description>The transparent ones look terrible with dark themed IDEs or non light background image Only looks fine in Eclipse image Write a program that goes through the images in images rx operators checks if the image has transparency, draw it onto a white background then save it as original Name v3 png because some of those are linked all around Find the filename in the source code and replace them.</Description>
        <CreatedDate>27/01/2020</CreatedDate>
        <ClosedDate>02/04/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Cleanup</Label>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6935</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>dependabot-preview[bot]</FixedByID>
    <Title>Bumpmockitocorefrom3.2.4to3.3.3</Title>
    <Description>Bumps mockito core Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself. You can also trigger a rebase manually by commenting dependabot rebase. You can trigger Dependabot actions by commenting on this PR rebase will rebase this PR  recreate  will recreate this PR, overwriting any edits that have been made to it  merge  will merge this PR after your CI passes on it  squash and merge  will squash and merge this PR after your CI passes on it cancel merge  will cancel a previously requested merge and block automerging  reopen  will reopen this PR if it is closed  close  will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually  ignore this major version  will close this PR and stop Dependabot creating any more for this major version  unless you reopen the PR or upgrade to it yourself  ignore this minor version  will close this PR and stop Dependabot creating any more for this minor version  unless you reopen the PR or upgrade to it yourself  ignore this dependency  will close this PR and stop Dependabot creating any more for this dependency  unless you reopen the PR or upgrade to it yourself  use these labels  will set the current labels as the default for future PRs for this repo and language use these reviewers  will set the current reviewers as the default for future PRs for this repo and language  use these assignees  will set the current assignees as the default for future PRs for this repo and language use this milestone  will set the current milestone as the default for future PRs for this repo and language  badge me  will comment on this PR with code to add a "Dependabot enabled" badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run and or open at any time  Automerge options never patch minor and dev runtime dependencies) Out of range updates receive only lockfile updates if desired Security updates receive only security updates if desired
</Description>
    <CreatedDate>16/03/2020</CreatedDate>
    <ClosedDate>16/03/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>dependencies</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1881</IssueID>
        <Title>Scan/Reduce Overloads &amp; Type Erasure</Title>
        <Code> 
		public class ScanVsReduceExample {
			public static void main(String[] args) {
				list.add(i);
				return list;
				System.out.println("... vs ...");
			}
		}
       </Code>
        <Description>I think the recent additions to scan reduce may cause issues Rename one of them Add an extra argument so arity solves it. I actually think the most correct thing to do is remove  since an initial value is most often intended for mutable state in scan reduce.  headin the box as this is a last minute API fix we need prior to Monday for</Description>
        <CreatedDate>15/11/2014</CreatedDate>
        <ClosedDate>15/11/2014</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1881</IssueID>
        <Title>Scan/Reduce Overloads Type Erasure</Title>
        <Code> 
		public class ScanVsReduceExample {

			public static void main(String... args) {
				Observable.range(0, 10).reduce(() -&gt; new ArrayList&lt;Integer&gt;(), (list, i) -&gt; {
					list.add(i);
					return list;
				}).forEach(System.out::println);

				System.out.println("... vs ...");

				Observable.range(0, 10).scan(() -&gt; new ArrayList&lt;Integer&gt;(), (list, i) -&gt; {
					list.add(i);
					return list;
				}).forEach(System.out::println);
			}
		}
       </Code>
        <Description>I think the recent additions to scan reduce may cause issues Rename one of them Add an extra argument so arity solves it. actually think the most correct thing to do is remove scan R Func2 R super T R since an initial value is most often intended for mutable state in scan reduce 		cc head in the box as this is a last minute API fix we need prior to Monday for</Description>
        <CreatedDate>15/11/2014</CreatedDate>
        <ClosedDate>15/11/2014</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1858</IssueID>
        <Title>Zip all overloads</Title>
        <Description>zip java lang Iterable extends Observable ws FuncN extends R zip Function Returns an Observable that emits the results of a function of your choosing function of your choosing combiner function</Description>         <CreatedDate>10/11/2014</CreatedDate>
        <ClosedDate>11/11/2014</ClosedDate>
        <Labels>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1858</IssueID>
        <Title>Zip all overloads</Title>
        <Description>zip java lang Iterable extends Observable ws FuncN extends R zip Function Returns an Observable that emits the results of a function of your choosing function of your choosing combiner function</Description>
        <CreatedDate>10/11/2014</CreatedDate>
        <ClosedDate>11/11/2014</ClosedDate>
        <Labels>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1868</IssueID>
        <Title>Improve Lifecycle Docs</Title>
        <Description>Based on a Twitter conversation we may need to improve docs around lifecycle: </Description>
        <CreatedDate>12/11/2014</CreatedDate>
        <ClosedDate>31/03/2018</ClosedDate>
        <Labels>
          <Label>1.x</Label>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1867</IssueID>
        <Title>usage of 2 buffers with both a timespan and a count</Title>
        <Description>The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.The observed rate will be as slow as 1 item per whatever is the second buffer timespan.Please see the following Gist for the JUnit code demonstrating the issue.</Description>
        <CreatedDate>12/11/2014</CreatedDate>
        <ClosedDate>19/11/2014</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1867</IssueID>
        <Title>usage of 2 buffers with both a timespan and a count</Title>
        <Description>The usage of 2 RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber.The observed rate will be as slow as 1 item per whatever is the second buffer timespan.Please see the following Gist for the JUnit code demonstrating the issue.</Description>
        <CreatedDate>12/11/2014</CreatedDate>
        <ClosedDate>19/11/2014</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1881</IssueID>
        <Title>Scan Reduce Overloads Type Erasure</Title>
        <Code> 
		public class ScanVsReduceExample {

			public static void main(String... args) {
				Observable.range(0, 10).reduce(() -&gt; new ArrayList&lt;Integer&gt;(), (list, i) -&gt; {
					list.add(i);
					return list;
				}).forEach(System.out::println);

				System.out.println("... vs ...");

				Observable.range(0, 10).scan(() -&gt; new ArrayList&lt;Integer&gt;(), (list, i) -&gt; {
					list.add(i);
					return list;
				}).forEach(System.out::println);
			}
		}
		</Code>
        <Description>I think the recent additions to scan reduce may cause issues Rename one of them Add an extra argument so arity solves it.I actually think the most correct thing to do is remove scan R, Func R super T R since an initial value is most often intended for mutable state in scan reduce head in the box as this is a last minute API fix we need prior to Monday for</Description>
        <CreatedDate>15/11/2014</CreatedDate>
        <ClosedDate>15/11/2014</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6935</PullRequestID>
        <IssueID>1858</IssueID>
        <Title>Zip all overloads</Title>
        <Description>zip java lang Iterable extends Observable ws, FuncN extends R zip Function Returns an Observable that emits the results of a function of your choosing function of your choosing combiner function</Description>
        <CreatedDate>10/11/2014</CreatedDate>
        <ClosedDate>11/11/2014</ClosedDate>
        <Labels>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6934</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>VovaStelmashchuk</FixedByID>
    <Title>Add see annotation for range operators</Title>
    <Description> Added see annotation for range operators reorder annotation to common code style.</Description>
    <CreatedDate>14/03/2020</CreatedDate>
    <ClosedDate>19/03/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Documentation</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6934</PullRequestID>
        <IssueID>4535</IssueID>
        <Title>Javadoc mistakes to look for</Title>
        <Description>From this comment parameter names change in the code but the javadocs still refer to the old names
		potential exceptions change in the code and the javadocs arent updated to match missing back pressure scheduler since annotations and outdated information in each of these
		changing things from consonant to vowel sound starting doing a search and replace and not replacing a with an or vice versa to match.  Also, sometimes changing singulars to plurals or vice-versa by search-and-replace, which causes its own set of grammatical headaches.- if you see any documentation that uses the passive voice, you can almost always make it clearer and less prone to misinterpretation by rewriting it in the active voice- URLs for marble diagrams are copy-and-pasted, the name of the operator is changed, but the width/height values in the img tag are not, so that the right image appears but in the wrong dimensions (there were a couple of these in the javadocs last I looked)</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6921</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>3.xFixreplaynotresettingwhentheconnectionisdisposed</Title>
    <Description>Disposing a replay based connectable should reset the operator to its fresh state. This was supposed to happen but the relevant code changes were not enabled. The PR fixes this for both Flowable and Observable 	based implementations. The publish based connectables work as intended. Fixes</Description>
    <CreatedDate>28/02/2020</CreatedDate>
    <ClosedDate>29/02/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6921</PullRequestID>
        <IssueID>6920</IssueID>
        <Title>Observable replay a bug or a feature</Title>
        <Description>Version Hello In the Connectable Observable java docs this following is written Disposing the connection will reset the code Connectable Flowable to its fresh state and there is no need to call code reset in this case. So I think If I dispose the connection then I dont need to call reset it should be in its initial state. However the following test fails. But if you uncomment the reset call then it passes Could you please clarify whether it is a bug or expected behaviour. Thanks!</Description>
        <CreatedDate>28/02/2020</CreatedDate>
        <ClosedDate>29/02/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6917</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title> Fix Flowable switch Map not canceling properly during on Next cancel races</Title>
    <Description>There was an unnecessary active lazy Set null which prevented cancellation of the inner source under some circumstances. More specifically when one thread issued a cancel the cancelled flag was set then another thread in drain would loop around, see the cancelled flag and clear the reference. 	Back in the cancelling thread, the dispose Inner would only see null and do nothing. Observable switch Map did not have this mistake. Both received unit tests to verify the correct behavior. will be fixed in a separate PR.    Resolves</Description>
    <CreatedDate>27/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6917</PullRequestID>
        <IssueID>6914</IssueID>
        <Title>Flowable Switch map sometimes doesnt unsubscribe from inner stream</Title>
        <Description>RxJava version Sometimes when the inner flowable emits item, the unsubscription from the outer chain after receiving the first item doesn't trigger the unsubscription from the inner Flowable. The completion of the outer chain also doesnt trigger the finally of the inner Flowable. This doesnt happen if I replace Flowable with Observable. Sorry for the pretty dumb example code, but not sure how to illustrate the problem better. So the expected result would be that Outer finally and Inner finally both printed times. What happens is that Inner finally is sometimes not printed, and the subscription to the inner flowable remains hanging, even though the outer chain has completed. On my machine this test produces around Inner finally results instead of It varies from run to run.</Description>
        <CreatedDate>27/02/2020</CreatedDate>
        <ClosedDate>27/02/2020</ClosedDate>
        <Labels>
          <Label>2.x</Label>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6903</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>vjgarciag96</FixedByID>
    <Title>Add Error handling section to Observable blocking First Java Docs</Title>
    <Description>Add missing Java Docs section Resolves</Description>
    <CreatedDate>09/02/2020</CreatedDate>
    <ClosedDate>09/02/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Documentation</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6903</PullRequestID>
        <IssueID>6900</IssueID>
        <Title>Add error handling section to Observable blocking First</Title>
        <Description>It looks like the only blocking method missing an error handling section. The other variants blocking Last blocking Single in Observable do have it as well as in Flowable Just copy the relevant dt dd section over.</Description>
        <CreatedDate>07/02/2020</CreatedDate>
        <ClosedDate>09/02/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Documentation</Label>
          <Label>PR welcome</Label>
          <Label>good first issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6899</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>Add concat Eager Delay Error across</Title>
    <Description>Flowable Observable Maybe and Single now have a concat Eager Delay Error delegating to the appropriate concat Map Eager Delay Error operator. In addition Maybe and Single received an overload concat Eager Iterable int to expose the max Concurrency option already present in the rest of the types. Note that Completable concat Eager Delay Error is essentially the same as merge Delay Error because there are no items to keep emitting in order. Resolves The Flowable and Observable variant of concat Eager also received fresh marble diagrams. Related </Description>
    <CreatedDate>30/01/2020</CreatedDate>
    <ClosedDate>30/01/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Cleanup</PullRequestLabel>
      <PullRequestLabel>Documentation</PullRequestLabel>
      <PullRequestLabel>Enhancement</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6899</PullRequestID>
        <IssueID>6880</IssueID>
        <Title>Add concat Eager Delay Error across</Title>
        <Description>concat Eager is available but its delay error variant is missing.</Description>
        <CreatedDate>26/01/2020</CreatedDate>
        <ClosedDate>30/01/2020</ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Enhancement</Label>
          <Label>PR welcome</Label>
          <Label>good first issue</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6899</PullRequestID>
        <IssueID>5813</IssueID>
        <Title>Flowable missing or incorrect marbles tracking issue</Title>
        <Description> amb indicate cancellation and request propagation ambArray indicate cancellation and request propagation combineLatest missing diagram combineLatestDelayError missing diagram concatArrayDelayError operator name indicate error delayed concatArrayEager missing diagram concatArrayEagerDelayError missing diagram concatDelayError missing diagram concatEager missing diagram concatEagerDelayError missing diagram create missing diagram error Callable indicate callback that creates the Throwable error Throwable indicate parameter fromArray operator name indicate items inside the bo fromCallable indicate item is the result of the callback inside the bo fromFuture operator name fromIterable operator name indicate items inside the bo fromPublisher missing diagram generate missing diagram intervalRange missing diagram just indicate item inside the bo as many as there are sources so .. mergeArray operator name mergeArrayDelayError operator name mergeDelayError indicate inner sources are generated sequenceEqual indicate cancellation after the mismatch has been found switchOnNe tDelayError operator name indicate error delay using indicate actual Flowable and items zipArray operator name zipIterable operator name all should return Single ambWith indicate cancellation and request propagation e ists should return Single as missing diagram operator removed blockingFirst missing diagram blockingForEach operator name blockingIterable operator name indicate iterator call to hasNe t and ne t blockingLast operator name blockingLatest missing diagram blockingMostRecent operator name blockingNe t operator name blocking Single operator name to Future rework diagram to indicate Future blocking Subscribe missing diagram buffer Callable indicate custom collection buffer open close parameter name in the bo collect indicate initial container supplier should return Single collectInto indicate initial container should return Single operator name compose missing diagram concatMap prefetch indicate prefetch effects through requests concat Map Delay Error missing diagram concat Map Eager missing diagram concat Map Eager Delay Error missing diagram concat Map Iterable missing diagram concatWith operator name contains should return Single count operator name default If Empty indicate non empty case delay Subscription Publisher missing diagram dematerialize indicate dematerializing a terminal notification cancels the source doFinally missing diagram do After Net missing diagram do On Cancel operator name unsubscribe cancel in te t do On Complete indicate events pass through do On Each indicate events pass through do OnError indicate events pass through doOnNe t indicate events pass through doOnRequest missing diagram doOnTerminate indicate events pass through show both error and complete case elementAt should return Maybe indicate if source is shorter than inde elementAtOrDefault should return Single indicate if source has that element elementAtOrError should return Single indicate error case firstElement image aspect off add case separator dashed vertical line first image aspect off firstOrError combine two sections vertical separator empty source arrow flatMap delayError indicate error delay case flatMap ma Concurrency missing diagram flatMap Function Function Callable int missing diagram flatMap Function BiFunction boolean int missing diagram flatMap Function BiFunction int missing diagram flatMapCompletable missing diagram flatMapIterable image aspect looks off flatMapMaybe missing diagram flatMapSingle missing diagram forEach missing diagram forEachWhile missing diagram hide missing diagram isEmpty should return Single lastElement operator name should return Maybe last T should return Single operator name lastOrError combine sections into one add vertical case separator limit missing diagram mergeWith operator name indicate the second source as parameter on Error Resume Net Function indicate error function on Error Return indicate error function on Error Return Item operator name on Terminate Detach missing diagram publish Function rework diagram rebatch Requests missing diagram reduce seed indicate star as parameter reduce With Callable indicate star as a supplied value operator name repeat indicate resubscription repeatUntil indicate boolean supplier replay remove publish bo replay Function rework diagram retry indicate infinte resubscription retry Bi Predicate indicate function decision on retry retry long indicate retry count effect retry long Predicate indicate predicate effects retry Predicate indicate predicate effects retry Until missing diagram scan R indicate initialValue as parameter scan Callable indicate initialValue is the result of a call share indicate the source gets cancelled single Element operator name should return Maybe single operator name should return Single single Or Error combine cases into one bo add vertical case separators skip Until indicate until cancels the main source sorted missing diagram startWith Iterable indicate iterable parameter indicate subscription startWith Publisher indicate subscription after the start element s startWith T one start value indicate subscription after the start element start With Array operator name indicate subscription after the start element s switch Map Delay Error operator name indicate error is delayed take Until Predicate indicate source is cancelled take Until Publisher indicate source is cancelled take While indicate source is cancelled to missing diagram toList should return Single to List Callable should return Single indicate custom collection to Map should return Single to Multi map should return Single to Observable missing diagram to Sorted List should return Single unsubscribe On missing diagram with Latest From s s missing diagrams with Latest From Publisher missing diagram with Latest From Iterable missing diagram</Description>
        <CreatedDate>17/01/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>3.x</Label>
          <Label>Documentation</Label>
          <Label>PR welcome</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6897</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>3.xAddremainingMaybemarbles50</Title>
    <Description>Resolves </Description>
    <CreatedDate>29/01/2020</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Cleanup</PullRequestLabel>
      <PullRequestLabel>Documentation</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6897</PullRequestID>
        <IssueID>5806</IssueID>
        <Title>Maybe incorrect or missing marbles tracking issue</Title>
        <Description> amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long Time Unit operator name in the box indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per Maybe source merge Delay Error Publisher one marble per Maybe source merge Delay Error Maybe Maybe one marble per Maybe source sequence Equal result should be Single timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram doOnTerminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flatMap Function Function Callable one marble per Maybe result should be Maybe flatMap Function BiFunction one marble per Maybe result should be Maybe flatMapObservable should be mapped into an Observable flatMapPublisher indicate backpressure flatMapSingle indicate empty maybe results in error flatMapSingleElement operator name indicate empty maybe flatMapCompletable indicate empty maybe hide missing diagram ignoreElement operator name one marble per Maybe result should be Maybe isEmpty result should be Single mergeWith operator name one marble per Maybe indicate backpressure ofType one marble per Maybe onErrorComplete missing diagram onErrorResumeNext one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome on Exception Resume Next operator takes a Maybe source directlyË‡ operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate backpressure retry one marble per Maybe result should be Maybe indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe timeout one marble per Maybe output should be Maybe timeout Maybe Source missing diagram timeout Maybe Source Maybe Source missing diagram timeout Publisher missing diagram timeout Publisher Maybe Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribeOn missing diagram zip With one marble per Maybe output should be Maybe</Description>
        <CreatedDate>10/01/2018</CreatedDate>
        <ClosedDate>29/01/2020</ClosedDate>
        <Labels>
          <Label>2.x</Label>
          <Label>3.x</Label>
          <Label>Documentation</Label>
          <Label>PR welcome</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6895</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>3.xFixgroupBynotrequestingmoreifagroupiscancelledwitems</Title>
    <Description>If a group is cancelled with unconsumed item in its buffer the operator stopped requesting more thus hanging other groups. In the operator was some what strenghtened for this case except one case when the cancellation happens outside the drain loop. The fix is to invoke drain from cancel for it to have the cleanup and replenishment happen. Fixes</Description>
    <CreatedDate>29/01/2020</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>3.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6895</PullRequestID>
        <IssueID>6889</IssueID>
        <Title>Unexpected behaviour of Group By operator wrt request handling</Title>
        <Code>
        List&lt;TestSubscriber&gt; listOfSubscribers = new ArrayList&lt;&gt;();
        TestSubscriber&lt;Integer&gt; subscriber = TestSubscriber.create(0);
        listOfSubscribers.add(subscriber);
        groupedFlowable.subscribe(subscriber);
        List&lt;TestSubscriber&gt; listOfSubscribers = new ArrayList&lt;&gt;();
        TestSubscriber&lt;Integer&gt; subscriber = TestSubscriber.create(0);
        listOfSubscribers.add(subscriber);
        groupedFlowable.subscribe(subscriber);		
        </Code>
        <Description>The groupBy operator does not work as expected wrt. request handling. If a subscriber of one of the GroupedFlowables is cancelled the buffer space occupied by this Grouped Flowable is not released. The code below illustrates this behavior Code Whats your opinion on this? Could this be a bug or does it work as designed Thank you</Description>
        <CreatedDate>28/01/2020</CreatedDate>
        <ClosedDate>29/01/2020</ClosedDate>
        <Labels>
          <Label>2.x</Label>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6894</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>Fix group By not requesting more if a group is cancelled with buffered items</Title>
    <Description>If a group is cancelled with unconsumed item in its buffer, the operator stopped requesting more thus hanging other groups. The fix is to count how many items are still in the buffer upon cancellation, and issue a request for them for the parent.Fixes</Description>
    <CreatedDate>29/01/2020</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <PullRequestLabels>
      <PullRequestLabel>2.x</PullRequestLabel>
      <PullRequestLabel>Bug</PullRequestLabel>
    </PullRequestLabels>
    <Issues>
      <Issue>
        <RepoID>RxJava</RepoID>
        <PullRequestID>6894</PullRequestID>
        <IssueID>6889</IssueID>
        <Title>Unexpected behaviour of Group By operator wrt. request handling</Title>
        <Code>
        List&lt;TestSubscriber&gt; listOfSubscribers = new ArrayList&lt;&gt;();
        TestSubscriber&lt;Integer&gt; subscriber = TestSubscriber.create(0);
        listOfSubscribers.add(subscriber);
        groupedFlowable.subscribe(subscriber);        
		</Code>
        <Description>The group By operator does not work as expected wrt. request handling. If a subscriber of one of the Grouped Flowables is cancelled, the buffer space occupied by this Grouped Flowable is not released. Whats your opinion on this Could this be a bug or does it work as designed Thank you</Description>
        <CreatedDate>28/01/2020</CreatedDate>
        <ClosedDate>29/01/2020</ClosedDate>
        <Labels>
          <Label>2.x</Label>
          <Label>3.x</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6893</IssueID>
    <RepoID>RxJava</RepoID>
    <FixedByID>akarnokd</FixedByID>
    <Title>Reenable XFlat Map Test maybe Single addmissing Singleo perators</Title>
    <Description>Reenable the X Flat MapTest maybeSingle and make sure all flatMap variants behave the same when the flow is cancelled disposed while the mapper function is executing, thus the returned inner source doesn't get subscribed to at all. Resolves While adding the extra tests I noticed two flatMap variant is missing from Single A combiner of the original and inner success item flatMap Function T, Single U , BiFunction T, U, R A notification type mapper flatMap Function T, Single R , Function Throwable, Single R image image Lastly, the same combiner variant for Maybe received a marble diagram too image Related  </Description>
  <CreatedDate>29/01/2020</CreatedDate>
  <ClosedDate>29/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Documentation</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
   <PullRequestLabel>Test</PullRequestLabel>
   <PullRequestLabel>Test-Failures</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6893</PullRequestID>
    <IssueID>6892</IssueID>
    <Title>Reenable X Flat Map Test maybe Single</Title>
    <Description>There is a small behavior difference between Flowable flat Map and Maybe flat Map Single that made the test fail.Namely, the effect of disposing before the function returns the inner source.</Description>
    <CreatedDate>28/01/2020</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Test-Failures</Label>
    </Labels>
   </Issue>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6893</PullRequestID>
    <IssueID>5806</IssueID>
    <Title>Maybe incorrect or missing marbles tracking issue </Title>
    <Description>amb missing diagram ambArray missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long TimeUnit operator name in the box indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per Maybe source merge Delay Error Publisher one marble per Maybe source merge Delay Error Maybe Maybe one marble per Maybe source sequenceEqual result should be Single . timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function BiFunction one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome on Exception Resume Next operator takes a Maybe source directly operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate backpressure retry one marble per Maybe result should be Maybe indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe time out one marble per Maybe output should be Maybe time out Maybe Source missing diagram time out Maybe Source Maybe Source missing diagram timeout Publisher missing diagram timeout Publisher MaybeSource missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per Maybe output should be Maybe</Description>
    <CreatedDate>10/01/2018</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <Labels>
     <Label>2.x</Label>
     <Label>3.x</Label>
     <Label>Documentation</Label>
     <Label>PR welcome</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6891</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>slisaasquatch</FixedByID>
  <Title>Swap Maybe flat Map Singleand Maybe flat Map Single Element</Title>
  <Description>Resolve Dropped the old Maybe flat Map Single and replaced it with Maybe flat Map Single Element</Description>
  <CreatedDate>28/01/2020</CreatedDate>
  <ClosedDate>28/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Removal</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6891</PullRequestID>
    <IssueID>6878</IssueID>
    <Title>Swap Maybe flat Map Single and Maybe flat Map Single Element</Title>
    <Description>Currently flat Map Single returns Single and signals No Such Element Exception if the source Maybe is empty. flat Map Single Element remains Maybe Id consider renaming flat Map Single to flat Map Single Or Error and flat Map Single Element to flat Map Single as I think a default Maybe Maybe transformer should better match the other such transformers.     Alternatively drop flat Map Single and rename flat Map Single Element to flat Map Single so that the original behavior could be achieved via flat Map Single to Single </Description>    
	<CreatedDate>26/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Discussion</Label>
     <Label>Removal</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6890</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>3.xFixmarbledimensionsaddprogramthatchecksthem</Title>
  <Description>Resolves Also added  diagrams missing and fixed diagram wrongly exported image</Description>
  <CreatedDate>28/01/2020</CreatedDate>
  <ClosedDate>28/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Cleanup</PullRequestLabel>
   <PullRequestLabel>Documentation</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6890</PullRequestID>
    <IssueID>6872</IssueID>
    <Title>Create a tool that scans the java sources and checks marble dimensions</Title>
    <Description>Create a manually runnable tool in internal util that walks through the java sources of the base classes parses out the img width height src downloads the referenced image and verifies that height is set properly More specifically round image width image height and prints a fake stacktrace element to the particular line and the right amount It is recommended the download is somewhat rate limited 1 per ms because the sheer number of images The same reason applies why this isn't an unit test to be Use Test Helper find Source to locate the source java </Description>
    <CreatedDate>25/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Documentation</Label>
     <Label>PR welcome</Label>
     <Label>Test</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6888</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Use more appropriate operators when delegating to Flowable ops</Title>
  <Description>Many Single and Maybe operators delegate to Flowable operators This PR makes sure they use the most appropriate ones since there are Single and Maybe specific operators on Flowable for some time now Some concatenating non delayed Single operators now use the Flowable concat Map Single Delay Error Functions identity false because an array or Iterable of Single s cant just throw anytime like a Publisher Single T s Publisher could hence a delay error until boundary mode works the same but without the extra coordination of the more general Publisher variant Resolves Completable didnt have any delegation required changing </Description>
  <CreatedDate>28/01/2020</CreatedDate>
  <ClosedDate>28/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Cleanup</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6888</PullRequestID>
    <IssueID>6865</IssueID>
    <Title>Check Maybe Single Completable operators delegating to Flowable ops</Title>
    <Code>
  public static &lt;T&gt; Flowable&lt;T&gt; merge @NonNull Publisher&lt;@NonNull ? extends MaybeSource&lt;? extends T&gt;&gt; sources, int maxConcurrency {
    Objects.requireNonNull sources, "sources is null" ;
    ObjectHelper.verifyPositive maxConcurrency, "maxConcurrency" ;
    return RxJavaPlugins.onAssembly new FlowableFlatMapPublisher sources, MaybeToPublisher.instance , false, maxConcurrency, 1 ;
  }
</Code>
    <Description>Some operators in Maybe Single and Completable are delegating to Flowable operators that may not be the best fit. For example But since Flowable Flat Map Maybe takes a Flowable T not a Publisher T a new simple class should be created Flowable Flat Map Maybe Publisher that takes a Publisher T but reuses the internals of FlowableFlatMapMaybe .</Description>
 <CreatedDate>24/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6887</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>add safe Subscribe to Maybe Single Completable</Title>
  <Description>Add the final missing method safe Subscribe to Maybe Single Completable Resolves</Description>
  <CreatedDate>28/01/2020</CreatedDate>
  <ClosedDate>28/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6887</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description>Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable startWith MaybeSource SingleSource Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6886</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add Completable on Error Return Item</Title>
  <Description>The operators were already available else where. Related In addition the Maybe variants have received updated marbles as well Related </Description>
  <CreatedDate>28/01/2020</CreatedDate>
  <ClosedDate>28/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6886</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue</Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source  
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6886</PullRequestID>
    <IssueID>5806</IssueID>
    <Title>Maybe incorrect or missing marbles tracking issue </Title>
    <Description> amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long TimeUnit operator name in the box indicate Future is the parameter indicate timeout fromRunnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per Maybe source merge Delay Error Publisher one marble per Maybe source merge Delay Error Maybe Maybe one marble per Maybe source sequence Equal result should be Single timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function BiFunction one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome on Exception Resume Next operator takes a Maybe source directlyË‡ operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate backpressure retry one marble per Maybe result should be Maybe indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe time out one marble per Maybe output should be Maybe time out Maybe Source missing diagram timeout Maybe Source Maybe Source missing diagram time out Publisher missing diagram time out Publisher Maybe Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per Maybe output should be Maybe</Description>
    <CreatedDate>10/01/2018</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <Labels>
     <Label>2.x</Label>
     <Label>3.x</Label>
     <Label>Documentation</Label>
     <Label>PR welcome</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6885</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add missing start With overloads</Title>
  <Description>Add missing start With overloads source Flowable present Observable Maybe Single Completable Related</Description>
  <CreatedDate>27/01/2020</CreatedDate>
  <ClosedDate>27/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6885</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Lifecycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6884</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>3.xAddCompletable.sequenceEqual</Title>
  <Description>The operator was available in all other classes.Related</Description>
  <CreatedDate>27/01/2020</CreatedDate>
  <ClosedDate>27/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6884</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source  
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6882</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add Single merge Array merge Array Delay Error</Title>
  <Description>Single was missing the merge Array and merge Array Delay Error operators already present in the other classes Related
</Description>
  <CreatedDate>27/01/2020</CreatedDate>
  <ClosedDate>27/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6882</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Lifecycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6881</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add various concatX Delay Error operators</Title>
  <Description>Add the following concat kind of operators Maybe concat Array Eager Delay Error Maybe concat Delay Error Publisher int  Single concat Array Delay Error Single concat Array Eager DelayError Single concat Delay Error  Completable concat Array Delay Error Completable concat Delay Error  In addition, the Maybe concat Delay Error Publisher marble has been fixed 
</Description>
  <CreatedDate>26/01/2020</CreatedDate>
  <ClosedDate>27/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Cleanup</PullRequestLabel>
   <PullRequestLabel>Documentation</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6881</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat DelayError Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch OnNext Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6879</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>3.xAddconcatMapXoperatorsaliases</Title>
  <Description>Add the following operator aliases Maybe concat Map Completable Maybe concat Map Single Single concat Map Completable Single concat Map Single concat Map Maybe Related In addition some missing or wrong May be marbles have been fixed 
</Description>
  <CreatedDate>26/01/2020</CreatedDate>
  <ClosedDate>26/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Documentation</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6879</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
 <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe timeInterval Maybe timestamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat DelayError Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single ofType Single on Error Complete Single retry Until Single safe Subscribe Single sequenceEqual rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6877</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>3.xAdddoOnLifecycletoMaybeSingleCompletable</Title>
  <Description>Add the do On Life cycle operator to the remaining classes Related </Description>
  <CreatedDate>26/01/2020</CreatedDate>
  <ClosedDate>26/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue> 
    <RepoID>RxJava</RepoID>
    <PullRequestID>6877</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequenceEqual Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable toFuture Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe timestamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source  
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6876</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add Single of Type</Title>
  <Description>Add of Type to Single already available to the other non empty base types Related In addition diagrams for Maybe filter  and  Maybe of Type  have been updated Related  </Description>
  <CreatedDate>26/01/2020</CreatedDate>
  <ClosedDate>26/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Documentation</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6876</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description>Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Lifecycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe timestamp Maybe toFuture Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable fromAction Observable fromCompletable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6876</PullRequestID>
    <IssueID>5806</IssueID>
    <Title>May be incorrect or missing marbles tracking issue </Title>
    <Description> amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long TimeUnit operator name in the box indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge DelayError Iterable one marble per Maybe source merge DelayError Publisher one marble per Maybe source merge Delay Error Maybe Maybe one marble per Maybe source sequence Equal result should be Single . timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe ... one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function BiFunction one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome on Exception ResumeNext operator takes a Maybe source directlyË‡ operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate backpressure retry one marble per Maybe result should be Maybe indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe timeout one marble per Maybe output should be Maybe timeout Maybe Source missing diagram timeout Maybe Source Maybe Source missing diagram timeout Publisher missing diagram timeout Publisher Maybe Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per May be output should be Maybe</Description>
    <CreatedDate>10/01/2018</CreatedDate>
    <ClosedDate>29/01/2020</ClosedDate>
    <Labels>
     <Label>2.x</Label>
     <Label>3.x</Label>
     <Label>Documentation</Label>
     <Label>PR welcome</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6875</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add May be Completable to Future</Title>
  <Description>Add to Future to Maybe and Completable Related </Description>
  <CreatedDate>26/01/2020</CreatedDate>
  <ClosedDate>26/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6875</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Net Completable switch On Net Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Lifecycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe timeInterval Maybe timestamp Maybe to Future Maybe switch On Net Maybe switch On Net Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat MapCompletable Single concat MapMaybe Single do On Lifecycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single timeInterval Single timestamp Single switch On Net Single switch On Net Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6874</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add time Interval timestamp to MS</Title>
  <Description>Add time Interval and timestamp operators overloads each to May be and Single Related</Description>
  <CreatedDate>25/01/2020</CreatedDate>
  <ClosedDate>26/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6874</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe star tWith Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge ArrayDelayError Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single startWith Single timeInterval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6873</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>3.xAddmanyfromXoperatorsmarbles</Title>
  <Description>Add a cross section of from operators present
 </Description>
  <CreatedDate>25/01/2020</CreatedDate>
  <ClosedDate>25/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6873</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue </Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch OnN ext Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe timeInterval Maybe timestamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6871</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add Maybe dematerialize</Title>
  <Description>Add the dematerialize operator to Maybe to be in sync with the other classes Related </Description>
  <CreatedDate>25/01/2020</CreatedDate>
  <ClosedDate>25/01/2020</ClosedDate>
  <PullRequestLabels>
   <PullRequestLabel>3.x</PullRequestLabel>
   <PullRequestLabel>Enhancement</PullRequestLabel>
  </PullRequestLabels>
  <Issues>
   <Issue>
    <RepoID>RxJava</RepoID>
    <PullRequestID>6871</PullRequestID>
    <IssueID>6852</IssueID>
    <Title>Missing operators tracking issue</Title>
    <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concatArrayEagerDelayError Single concatDelayError Single concatMap Single concatMapCompletable Single concatMapMaybe Single doOnLifecycle Single fromMaybe Single mergeArray Single mergeArrayDelayError Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single timeInterval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source </Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>28/01/2020</ClosedDate>
    <Labels>
     <Label>3.x</Label>
     <Label>Cleanup</Label>
     <Label>Enhancement</Label>
     <Label>PR welcome</Label>
     <Label>good first issue</Label>
    </Labels>
   </Issue>
  </Issues>
 </PullRequest>
 <PullRequest>
  <IssueID>6870</IssueID>
  <RepoID>RxJava</RepoID>
  <FixedByID>akarnokd</FixedByID>
  <Title>Add May be Single Completable switch On Nexts witch On Next Delay Error</Title>
  <Description>Add the missing switch On Next and switch On Next Delay Error operators which are essentially delegated to the respective Flowable switch MapX operators with identity mapping. </Description>
 <CreatedDate>25/01/2020</CreatedDate>
 <ClosedDate>25/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3.x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6870</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue</Title>
 <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blockingS ubscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Lifecycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
  <Label>3.x</Label> 
  <Label>Cleanup</Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6869</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Single Comple table retry Until marbles</Title>
 <Description>retry Until was missing from Single and Completable Added marble for Maybe as well Related </Description>
 <CreatedDate>25/01/2020</CreatedDate>
 <ClosedDate>25/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3.x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6869</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue </Title>
 <Description>Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe timestamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat MapCompletable Single concat MapMaybe Single do On Lifecycle Single from Maybe Single merge Array Single merge Array Delay Error Single ofType Single onError Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timestamp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source 
</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
  <Label>3.x</Label>
  <Label>Cleanup</Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6869</PullRequestID>
 <IssueID>5806</IssueID>
 <Title>Maybe incorrect or missing marbles tracking issue </Title>
 <Description>amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long TimeUnit operator name in the box indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per Maybe source merge Delay Error Publisher one marble per Maybe source merge Delay Error May be May be one marble per Maybe source sequence Equal result should be Single . timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zipArray one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate May be target indicate empty source concat With one marble per May be source result should be Maybe operator name indicate other is a parameter contains one marble per May be source result should be Single empty case count one marble per may be operator name result should be Single empty case default If Empty non empty case result should be May be delay time one marble per Maybe source result should be May be delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function Bi Function one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per May be result should be May be indicate call back on Error Return Item operator name one marble per Maybe result should be May be indicate normal outcome on Exception Resume Next operator takes a Maybe source directly operator removed on Terminate Detach missing diagram repeat one marble per source indicate back pressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per May be indicate back pressure retry one marble per May be result should be May be indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per May be output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe timeout one marble per Maybe output should be Maybe timeout Maybe Source missing diagram timeout Maybe Source Maybe Source missing diagram timeout Publisher missing diagram timeout Publisher Maybe Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per Maybe output should be Maybe</Description>
 <CreatedDate>10/01/2018</CreatedDate>
 <ClosedDate>29/01/2020</ClosedDate>
 <Labels>
  <Label>2.x</Label>
  <Label>3.x</Label>
  <Label>Documentation</Label>
  <Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6868</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Completable on Error Resume With</Title>
 <Description>This PR adds the missing Completable on Error Resume With present in the rest of the base classes.
Also marbles for Maybe on Error Resume Next and Maybe on Error Resume With have been updated. Related </Description>
 <CreatedDate>24/01/2020</CreatedDate>
 <ClosedDate>24/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3.x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6868</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue </Title>
 <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Next Completable switch On Next Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe timeInterval Maybe timestamp Maybe to Future Maybe switch On Next Maybe switch On Next Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single timest amp Single switch On Next Single switch On Next Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With Maybe Source Single Source Completable Source Observable from Action Observable from Completable Observable from Maybe Observable from Runnable Observable from Single Observable on Error Complete Observable start With Maybe Source Single Source Completable Source  </Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
  <Label>3.x</Label>
  <Label>Cleanup</Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6868</PullRequestID>
 <IssueID>5806</IssueID>
 <Title>May be incorrect or missing marbles tracking issue </Title>
 <Description> amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fix overlap misalignment inside the operator box concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the box indicate Future is the parameter from Future Future long TimeUnit operator name in the box indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per May be source merge Delay Error Publisher one marble per May be source merge Delay Error May be May be one marble per May be source sequence Equal result should be Single timer result should be May be using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per May be source result should be May be zip May be May be one marble per Maybe source result should be May be zip Array one marble per May be source result should be May be amb With one marble per May be source result should be May be as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do OnError missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function BiFunction one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map SingleElement operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome on Exception ResumeNext operator takes a Maybe source directly operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate back pressure retry one marble per Maybe result should be May be indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per Maybe output should be Maybe timeout one marble per Maybe output should be Maybe timeout Maybe Source missing diagram timeout Maybe Source Maybe Source missing diagram timeout Publisher missing diagram timeout Publisher Maybe Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per May be output should be May be</Description>
 <CreatedDate>10/01/2018</CreatedDate>
 <ClosedDate>29/01/2020</ClosedDate>
 <Labels>
  <Label>2.x</Label>
  <Label>3.x</Label>
  <Label>Documentation</Label>
  <Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6867</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add on Error Complete to Flowable Observable and Single</Title>
 <Description>Add the on Error Complete and on Error Complete Predicate operators to the remaining base classes. Also created the missing marble for May be on Error Complete Related 
</Description>
 <CreatedDate>24/01/2020</CreatedDate>
 <ClosedDate>24/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3.x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6867</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue</Title>
 <Description>
Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With May be Source Single Source Completable switch On Net Completable switch On Net Delay Error Completable to Future May be blocking Subscribe May be concat Array Eager Delay Error May be concat Map Completable May be concat Map Single May be dematerialize May be from Observable May be do On Life cycle May be from Publisher May be safe Subscribe May be start With May be time Interval May be timestamp May be to Future May be switch On Net May be switch On Net Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from May be Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Net Single switch On Net Delay Error Flowable from Action Flowable from Completable Flowable from May be Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With May be Source Single Source Completable Source Observable from Action Observable from Completable Observable from May be Observable from Runnable Observable from Single Observable on Error Complete Observable start With May be Source Single Source Completable Source </Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
  <Label>3. </Label>
  <Label>Cleanup</Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6867</PullRequestID>
 <IssueID>5806</IssueID>
 <Title> Maybe incorrect or missing marbles tracking issue </Title>
 <Description>amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fi overlap/misalignment inside the operator bo concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the bo indicate Future is the parameter from Future Future long TimeUnit operator name in the bo indicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per May be source merge Delay Error Iterable one marble per May be source merge Delay Error Publisher one marble per May be source merge Delay Error May be May be one marble per May be source sequence Equal result should be Single . timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe as missing diagram operator removed blocking Get missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concat Map indicate Maybe target indicate empty source concat With one marble per Maybe source result should be May be operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty non empty case result should be May be delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be May be do After Success missing diagram do After Terminate operator name one marble per May be result should be May be do Finally missing diagram do On Dispose missing diagram do On Complete one marble per May be result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per May be result should be May be filter one marble per May be result should be May be flat Map Function Function Callable one marble per May be result should be May be flat Map Function BiFunction one marble per May be result should be May be flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per May be result should be May be is Empty result should be Single merge With operator name one marble per May be indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Net one marble per May be result should be May be on Error Resume With one marble per May be result should be May be on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per May be result should be May be indicate normal outcome on Exception Resume Net operator takes a May be source directly operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per May be indicate backpressure retry one marble per May be result should be May be indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per May be output should be May be switch If Empty improve diagrams indicate argument type take Until one marble per May be output should be Maybe timeout one marble per May be output should be Maybe timeout May be Source missing diagram timeout May be Source May be Source missing diagram timeout Publisher missing diagram timeout Publisher May be Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per May be output should be May be</Description>
 <CreatedDate>10/01/2018</CreatedDate>
 <ClosedDate>29/01/2020</ClosedDate>
 <Labels>
  <Label>2. </Label>
  <Label>3. </Label>
  <Label>Documentation</Label>
  <Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6864</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>pestrada</FixedByID>
 <Title>Adding delay Error to Maybedelay</Title>
 <Description>Resolves 6863 </Description>
 <CreatedDate>24/01/2020</CreatedDate>
 <ClosedDate>24/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6864</PullRequestID>
 <IssueID>6863</IssueID>
 <Title>Maybe delay has no delay Error option unlike Single </Title>
 <Description>It defaults to always delay an error.</Description>
 <CreatedDate>23/01/2020</CreatedDate>
 <ClosedDate>24/01/2020</ClosedDate>
 <Labels>
  <Label>3. </Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6862</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add May be Single Completable blocking Subscribe</Title>
 <Description>Add the missing blocking Subscribe methods to Maybe Single and Completable for symmetry with Flowable and Observable. Usually wed like to avoid blocking but now that Project Loom preview transparently turns latch based awaiting into suspension inside Virtual Threads, they will act as free interop operators for e iting the reactive world into the continuation world. Related Marbles Maybe Single Completable
 </Description>
 <CreatedDate>23/01/2020</CreatedDate>
 <ClosedDate>24/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3.x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6862</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue </Title>
 <Description> Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completabledo On Life cycle Completableon Error Resume With Completableon Error Return Completableon Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With May be Source SingleSource Completable switch On Net Completable switch On Net Delay Error Completable to Future May be blocking Subscribe May be concat Array Eager Delay Error May be concat Map Completable May be concat Map Single May be dematerialize May be from Observable May be do On Life cycle May be from Publisher May be safe Subscribe May be start With May be timeInterval May be timestamp May be to Future May be witch on Net May be switch On Net Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map Maybe Single do On Life cycle Single from Maybe Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Net Single switch On Net Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With May be Source Single Source Completable Source Observable from Action Observable from Completable Observable from May be Observable from Runnable Observable from Single Observableon Error Complete Observable start With May be Source Single Source Completable Source
</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
  <Label>3. </Label>
  <Label>Cleanup</Label>
  <Label>Enhancement</Label>
  <Label>PR welcome</Label>
  <Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6860</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add last missing throws tag to JavaDocs</Title>
 <Description>Added the last missing throws tag to methods and one missing Non Null annotation.I included a small program that will list Java Docs without throws for future use. Resolves</Description>
 <CreatedDate>22/01/2020</CreatedDate>
 <ClosedDate>22/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6860</PullRequestID>
 <IssueID>6829</IssueID>
 <Title>Ensure delegating operator over loads list all relevant throws too in their Java docs</Title>
 <Description>The current Param Validation Naming can only check eplicit argument validation ie the method body lists require Non Null or verify Positive but not overloads delegating to those methods thus lacking the eplicit argument validation themselves. I dont think this can be automated therefore each base reactive class source should be manually examined and expanded with the missing throws declaration Flowable Observable Maybe Single Completable Parallel Flowable There is currently an Observable cleanup PR in the works please wait for it before doing this issue. Edit Perhaps checking if the typical method parameter names such as buffer SizeprefetchcapacityHintsourcemapperpredicateetc appear in throws declaration.</Description>
 <CreatedDate>09/01/2020</CreatedDate>
 <ClosedDate>22/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6857</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Wiki Improve Operator Matri with links and notes</Title>
 <Description>Update the Operator Matri Generator to add anchors and links to notes about why operators are not present in one or another class. Some operators are missing and will be added as part of Resolves</Description>
 <CreatedDate>22/01/2020</CreatedDate>
 <ClosedDate>22/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6857</PullRequestID>
 <IssueID>6852</IssueID>
 <Title>Missing operators tracking issue</Title>
 <Description>
 Operators present in some but not other classes when they make sense there too Completable concat Array Delay Error Completable blocking Subscribe Completable do On Life cycle Completable on Error Resume With Completable on Error Return Completable on Error Return Item Completable retry Until Completable safe Subscribe Completable sequence Equal Completable start With Maybe Source Single Source Completable switch On Net Completable switch On Net Delay Error Completable to Future Maybe blocking Subscribe Maybe concat Array Eager Delay Error Maybe concat Map Completable Maybe concat Map Single Maybe dematerialize Maybe from Observable Maybe do On Life cycle Maybe from Publisher Maybe safe Subscribe Maybe start With Maybe time Interval Maybe time stamp Maybe to Future Maybe switch On Net Maybe switch On Net Delay Error Single blocking Subscribe Single concat Array Delay Error Single concat Array Eager Delay Error Single concat Delay Error Single concat Map Single concat Map Completable Single concat Map May be Single do On Life cycle Single from May be Single merge Array Single merge Array Delay Error Single of Type Single on Error Complete Single retry Until Single safe Subscribe Single sequence Equal rename equals Single start With Single time Interval Single time stamp Single switch On Net Single switch On Net Delay Error Flowable from Action Flowable from Completable Flowable from Maybe Flowable from Observable Flowable from Runnable Flowable from Single Flowable on Error Complete Flowable start With May be Source Single Source Completable Source Observable from Action Observable from Completable Observable from May be Observable from Runnable Observable from Single Observable on Error Complete Observable startWith May be Source Single Source Completable Source 
</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>28/01/2020</ClosedDate>
 <Labels>
<Label>3.x</Label>
<Label>Cleanup</Label>
<Label>Enhancement</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6857</PullRequestID>
 <IssueID>6855</IssueID>
 <Title>3 Wiki Enhance Operator Matrigeneration with anchors and e planations</Title>
 <Description>Ive turned the column headers to images rotated 90 degrees so the table doesnt overflow the wiki layout. The Generator java should be updated accordingly plus Add HTML anchors to the rows so they can be navigated to via method Name Add up note sup to absent entries and a list of notes below the table e plaining why. For this the reason mapping has to be added to the generator.</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>22/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6856</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>slisaasquatch</FixedByID>
 <Title>Rename Single equals to Single sequence Equal</Title>
 <Description>Renamed Single equals to Single sequence Equal and renamed argument names for consistent naming Resolves</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>21/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6856</PullRequestID>
 <IssueID>6854</IssueID>
 <Title>Rename Single equals to Single sequence Equal</Title>
 <Description>For consistent naming.</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>21/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6853</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3. Fi methodargumentnamingacrosstypes</Title>
 <Description>Make method argument naming consistent between the base reactive classes adjust some of the naming for all.In addition the null check was missing from blocking Most Recent Resolves The utility program has to be run manually to list the inconsistencies. The remaining inconsistency is due to merge because its argument is sources for Flowable Observable but source for Single Maybe nested.</Description>
 <CreatedDate>21/01/2020</CreatedDate>
 <ClosedDate>21/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6853</PullRequestID>
 <IssueID>6832</IssueID>
 <Title>Validate argument naming consistency between base class methods</Title>
 <Code>
 void int paramName() {
 // deliberately empty
 }
 </Code>
 <Description>Operator argument naming should match between base classes on the same operators. For example Observable buffer boundary vs. Flowable buffer boundary Indicator. Source level comparison would be too complicated so reflection can be used for this provided the class saves the argument names. Javac has this option that must be enabled in the IDE and in build.gradle There are some common operator names across all base classes these should match as well.</Description>
 <CreatedDate>10/01/2020</CreatedDate>
 <ClosedDate>21/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6847</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Simplify return sentences in Flowable JavaDocs</Title>
 <Description>Simplify the wording of return in JavaDocs Resolves</Description>
 <CreatedDate>15/01/2020</CreatedDate>
 <ClosedDate>16/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6847</PullRequestID>
 <IssueID>6834</IssueID>
 <Title>Replace the verbose return entires with simpler ones</Title>
 <Description>Many operators documentation repeats more or less its first sentence as part of return. This adds unnecessary verbosity opportunity for them to become desynced and is e tra effort to maintain. Instead they should be as simple as return the new code Type instance Flowable Observable Maybe Single Completable ParallelFlowable return the new </Description>
 <CreatedDate>10/01/2020</CreatedDate>
 <ClosedDate>16/01/2020</ClosedDate>
 <Labels>
<Label>3.x</Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6846</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>slisaasquatch</FixedByID>
 <Title>DeletedunnecessaryNPEtests</Title>
 <Description>Resolves I have kept tests that arbitrarily throw NPEs like this one and tests with Iterable s that return null Iterator s like this one</Description>
 <CreatedDate>14/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6844</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Remove Maybe on Exception Resume Next</Title>
 <Description>It was always very peculiar to let only checked e ceptions resumed Resolves</Description>
 <CreatedDate>14/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6844</PullRequestID>
 <IssueID>6842</IssueID>
 <Title>Remove the remaining on Exception Resume Next operators </Title>
 <Description>Apparently Maybe on Exception Resume Net was not removed back then.</Description>
 <CreatedDate>14/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Cleanup</Label>
<Label>Removal</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6843</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3. Improvewordingofoperators</Title>
 <Description> Reword sentences with modifies and instructs Reword the source to the current Reword a couple of other operator sentences Related Resolves</Description>
 <CreatedDate>14/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6843</PullRequestID>
 <IssueID>6819</IssueID>
 <Title>Change the source Publisher in Flowable java docs to the current Flowable</Title>
 <Description>In instance methods of Flowablethe source should be referred to as the current code Flowable Currently it is the source link Publisher due to previous copypaste and search replace mistakes Similarly the resulting code Publisher should be the resulting code Flowable . Watch out for line breaks in the javadocs when searching for these as patterns the a source upstream resulting code link Publisher this code link Publisher new code Publisher </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <Labels>
<Label>3. </Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6843</PullRequestID>
 <IssueID>6821</IssueID>
 <Title>Reword javadocs saying the operator modifies the current source</Title>
 <Description>Reactive sources are immutable so there is no modification only wrapping and composition The wording modifies is an old remnant Also reword instructs type of docs.</Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <Labels>
<Label>3.x</Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6840</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3. Addnullabilityannotationstotypearguments</Title>
 <Description>Annotate type argument use with Non Null Resolves</Description>
 <CreatedDate>13/01/2020</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3. </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6840</PullRequestID>
 <IssueID>6766</IssueID>
 <Title>Add missing NonNull annotations to the standard methods</Title>
 <Description>Including the return type parameters and type argument usages on lambdas Flowable Observable Maybe Single Completable ParallelFlowable Please do them in separate PRs </Description>
 <CreatedDate>17/12/2019</CreatedDate>
 <ClosedDate>14/01/2020</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6839</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3 enablejavacparametersavinginclassfiles</Title>
 <Description>Related 6832</Description>
 <CreatedDate>13/01/2020</CreatedDate>
 <ClosedDate>13/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Build</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6839</PullRequestID>
 <IssueID>6832</IssueID>
 <Title>Validate argument naming consistency between base class methods </Title>
 <Code>
 void method int paramName {
 // deliberately empty
 }
 </Code>
 <Description>Operator argument naming should match between base classes on the same operators For e ample Observable buffer boundary vs Flowable buffer boundary Indicator Source level comparison would be too complicated so reflection can be used for this provided the class saves the argument names Javac has this option that must be enabled in the IDE and in build gradle There are some common operator names across all base classes these should match as well </Description>
 <CreatedDate>10/01/2020</CreatedDate>
 <ClosedDate>21/01/2020</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6838</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Rename to combine Latest Array Delay Error</Title>
 <Description>The operator missed a rename with to match the combine Latest Array variant Resolves</Description>
 <CreatedDate>13/01/2020</CreatedDate>
 <ClosedDate>13/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6838</PullRequestID>
 <IssueID>6820</IssueID>
 <Title>Rename combine Latest Delay Error array to combine Latest Array Delay Error</Title>
 <Description>Looks like the Array naming was not entirely consistent across operators </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>13/01/2020</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6837</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Remove apoint less Observable concat Map Iterable overload</Title>
 <Description>Remove the concat Map Iterable Function int overload as there is no buffering involved with the operator Resolves 6828 </Description>
 <CreatedDate>13/01/2020</CreatedDate>
 <ClosedDate>13/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6837</PullRequestID>
 <IssueID>6828</IssueID>
 <Title>Inline Observable concat Map Iterable and flat Map Iterable</Title>
 <Description>They can be implemented more efficiently than relying on concat Map or flat Map similarly to how Flowable implements them In addition the buffer Size overloads make no sense as the operation is completely synchronous and nothing is to be buffered In comparison Flowable concatMapIterable has to buffer the upstream items because the downstream may not be ready to consume the iterable </Description>
 <CreatedDate>09/01/2020</CreatedDate>
 <ClosedDate>13/01/2020</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
<Label>Performance</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6827</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Flowable flat Map not canceling the inner sources on outer error</Title>
 <Description>The outer onError did not cancel the inner sources The Observable variant works correctly but both received an unit test to verify the behavior Fixes 6825 </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>09/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2.x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6827</PullRequestID>
 <IssueID>6825</IssueID>
 <Title>2 Une pected Flowable flatMap behavior while handling an upstream error</Title>
 <Description>Hi Ive discovered an une pected behavior of the Flowable flatMap operator leading to a possible subscription leak Localized my problem in the following scenario RxJava version Given a simple Rchain of flowable flatMap value flowable flowable emits a value so that flatMap subscribes to flowable flowable emits an error Expected result flatMap disposes flowable upon handling the upstream error Actual result flowable remains subscribed after the entire Rchain terminates because of the error Replacing the flatMap operator with concatMap fi es the problem such a replacement is valid in my case However I decided to raise this issue because such behavior of flat Map looks quite odd to me Could somebody from RxJava team confirm whether my e pectation is valid and the observed behavior is a defect? I ve reproduced this issue in a code snippet I m e pecting this code to produce flowable cancelled output But got flowable error instead plus error gets thrown as Undeliverable Exception because it occurs after the entire chain is terminated </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>09/01/2020</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6826</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Flowable flat Map not canceling the inner sources on outer error</Title>
 <Description>The outer on Error did not cancel the inner sources The Observable variant works correctly but both received an unit test to verify the behavior will be fixed in a separate PR Related  </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>08/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6826</PullRequestID>
 <IssueID>6825</IssueID>
 <Title>Unexpected Flowable flatMap  behavior while handling an upstream error</Title>
 <Description>Hi Ive discovered an une pected behavior of the Flowable flatMap operator leading to a possible subscription leak Localized my problem in the following scenario RxJava version Given a simple Rchain of flowable flatMap value flowable flowable emits a value so that flatMap subscribes to flowable flowable emits an error Expected result flatMap disposes flowable upon handling the upstream error Actual result flowable remains subscribed after the entire Rchain terminates because of the error Replacing the flatMap operator with concatMap fixes the problem such a replacement is valid in my case However I decided to raise this issue because such behavior of flatMap looks quite odd to me Could somebody from RxJava team confirm whether my e pectation is valid and the observed behavior is a defect Ive reproduced this issue in a code snippet Im expecting this code to produce flowable cancelled output But got flowable error instead plus error gets thrown as UndeliverableE ception because it occurs after the entire chain is terminated </Description>
 <CreatedDate>08/01/2020</CreatedDate>
 <ClosedDate>09/01/2020</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6817</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>slisaasquatch</FixedByID>
 <Title>Deleted Functions natural Order</Title>
 <Description>Removes a duplication of the natural order comparator Resolves</Description>
 <CreatedDate>07/01/2020</CreatedDate>
 <ClosedDate>07/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6817</PullRequestID>
 <IssueID>6816</IssueID>
 <Title>3 simple cleanup Remove the duplicate Comparator in Functions</Title>
 <Description>In io reactive RxJava3 internal functions Functions this and this look like the e act same thing Is it worth it to delete one of them</Description>
 <CreatedDate>07/01/2020</CreatedDate>
 <ClosedDate>07/01/2020</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6814</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3 RemovefromFuture Scheduleroverloads</Title>
 <Description>Those overloads were only applying subscribe On with no other benefits Resolves</Description>
 <CreatedDate>07/01/2020</CreatedDate>
 <ClosedDate>07/01/2020</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6814</PullRequestID>
 <IssueID>6811</IssueID>
 <Title>Remove from Future scheduler overloads</Title>
 <Description>They basically simply just apply subscribe On </Description>
 <CreatedDate>06/01/2020</CreatedDate>
 <ClosedDate>07/01/2020</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
<Label>Removal</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6684</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix window time possible interrupts while terminating</Title>
 <Description>Fithe case in window time variants where the timer thread is busy with window emission and the upstream terminates on some other thread the window emission is interrupted The drain loop will take care of disposing the timer and the main downstream can simply be terminated Related Fixes</Description>
 <CreatedDate>24/10/2019</CreatedDate>
 <ClosedDate>29/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6684</PullRequestID>
 <IssueID>6674</IssueID>
 <Title>3 Fiwindow time possible interrupts while terminating</Title>
 <Description>Fithe case in window time variants where the timer thread is busy with window emission and the upstream terminates on some other thread the window emission is interrupted So instead of disposing the timer worker right after the upstream termination a DISPOSE message is queued up Thus any ongoing drain loop from the timer thread can cleanup gracefully After some additional considerations there is no need for DISPOSE The drain loop will take care of disposing the timer and the main downstream can simply be terminated The fix will be in a separate PR shortly Fixes  </Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6684</PullRequestID>
 <IssueID>6672</IssueID>
 <Title>Question Why a running computation thread got interrupted while window is finished</Title>
 <Description>Why an active computation thread got interrupted while window is finished Is it a bug</Description>
 <CreatedDate>16/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6681</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>thiyagu7</FixedByID>
 <Title>Backport marble diagrams for Single from</Title>
 <Description>This PR is to backport the marble images of Single class from  The method on Error Resume With does not e list in and hence I have left that out Closes </Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>18/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6681</PullRequestID>
 <IssueID>6679</IssueID>
 <Title>Backport marble fixes to Single</Title>
 <Description>The main task is to locate the relevant methods and then copypaste the img entry The diff in should help In case of renamed operator slet me know and Ill post images for them </Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>18/10/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6677</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix concurrent clear calls when fused chains are canceled</Title>
 <Description>Backport of When a fuseable source backed by an Spsc Linked Array Queue is cancelled and cleared concurrently i e one thread clears while the other cancels the chainthe clear method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state This PR fixes two kinds of mistakes leading to this scenario Calling clear from cancel dispose when the output is fused Calling clear from a fused drain loop when cancellation is detected When fused similar to pollcalling clear is the responsibility of the consumer and the producer side is not allowed to call them The bug affected the following operators Flowable On Back pressure Buffer Flowable Group By Unicast Processor Unicast Subject Fixes</Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6677</PullRequestID>
 <IssueID>6676</IssueID>
 <Title>Fix concurrent clear calls when fused chains are canceled</Title>
 <Description>When a fuseable source backed by an SpscLinkedArrayQueue is cancelled and cleared concurrently i e one thread clears while the other cancels the chainthe clear method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state This PR fixes two kinds of mistakes leading to this scenario Calling clear from cancel dispose when the output is fused Calling clear from a fused drain loop when cancellation is detected When fused similar to pollcalling clear is the responsibility of the consumer and the producer side is not allowed to call them The bug affected the following operators Flowable On Back pressure Buffer Flowable Group By Unicast Processor Unicast Subject Fixes  </Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6677</PullRequestID>
 <IssueID>6673</IssueID>
 <Title>NPE in Spsc Linked Array Queue clear due to concurrent invocation</Title>
 <stacktrace>
 Fatal Exception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue poll + 138 SpscLinkedArrayQueue java 138 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableConditionalSubscriber cancel + 157 BasicFuseableConditionalSubscriber java 157 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators flowable FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber tryOnNe t + 101 FlowableDistinctUntilChanged java 101 
 at io reactive internal operators flowable FlowableMap$MapConditionalSubscriber tryOnNe t + 128 FlowableMap java 128 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnConditionalSubscriber runAsync + 649 FlowableObserveOn java 649 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 


We just upgraded our project from 1 and did not see these errors in testing but are seeing them in production We're working to figure out the e act cause and will provide more information as we have it 

Here are some additional stack traces in case you notice any pattern 

Fatal E ception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll + 155 SpscLinkedArrayQueue java 155 
 at io reactive internal queue SpscLinkedArrayQueue poll + 145 SpscLinkedArrayQueue java 145 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableConditionalSubscriber cancel + 157 BasicFuseableConditionalSubscriber java 157 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber cancel + 168 FlowableConcatMapMaybe java 168 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber drain + 284 FlowableConcatMapMaybe java 284 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber onNe t + 137 FlowableConcatMapMaybe java 137 
 at io reactive internal operators flowable FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber tryOnNe t + 101 FlowableDistinctUntilChanged java 101 
 at io reactive internal operators flowable FlowableMap$MapConditionalSubscriber tryOnNe t + 128 FlowableMap java 128 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnConditionalSubscriber runAsync + 649 FlowableObserveOn java 649 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 


Fatal E ception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll + 155 SpscLinkedArrayQueue java 155 
 at io reactive internal queue SpscLinkedArrayQueue poll + 145 SpscLinkedArrayQueue java 145 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber clear + 264 FlowableOnBackpressureBuffer java 264 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber clear + 236 FlowableObserveOn java 236 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber checkTerminated + 188 FlowableObserveOn java 188 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnSubscriber runAsync + 399 FlowableObserveOn java 399 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 
 at io reactive internal schedulers ScheduledRunnable run + 66 ScheduledRunnable java 66 
 at io reactive internal schedulers ScheduledRunnable call + 57 ScheduledRunnable java 57 


Fatal E ception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue poll + 138 SpscLinkedArrayQueue java 138 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableSkipWhile$SkipWhileSubscriber cancel + 93 FlowableSkipWhile java 93 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber tryOnNe t + 74 FlowableFilter java 74 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber onNe t + 52 FlowableFilter java 52 
 at io reactive internal operators flowable FlowableSkipWhile$SkipWhileSubscriber onNe t + 56 FlowableSkipWhile java 56 
 at io reactive internal operators flowable FlowableMap$MapSubscriber onNe t + 68 FlowableMap java 68 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnSubscriber runAsync + 407 FlowableObserveOn java 407 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 


 </stacktrace>
 <Code>
toObservable&lt;Any&gt;  
 </Code>
 <Description>Reported in
 </Description>
 <CreatedDate>16/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6676</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix concurrent clear calls when fused chains are canceled</Title>
 <Description>When a fuseable source backed by an Spsc Linked Array Queue is cancelled and cleared concurrently i e one thread clears while the other cancels the chainthe clear method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state This PR fixes two kinds of mistakes leading to this scenario Calling clear from cancel dispose when the output is fused Calling clear from a fused drain loop when cancellation is detected When fused similar to pollcalling clear is the responsibility of the consumer and the producer side is not allowed to call them The bug affected the following operators Flowable On Back pressure Buffer Flowable Group By Unicast Processor Unicast Subject Fixes</Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6676</PullRequestID>
 <IssueID>6673</IssueID>
 <Title>NPE in SpscLinkedArrayQueue clear due to concurrent invocation</Title>
 <Code>
 toObservable&lt;Any&gt; 
 </Code>
 <stacktrace>
 Fatal Exception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue poll + 138 SpscLinkedArrayQueue java 138 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableConditionalSubscriber cancel + 157 BasicFuseableConditionalSubscriber java 157 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators flowable FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber tryOnNe t + 101 FlowableDistinctUntilChanged java 101 
 at io reactive internal operators flowable FlowableMap$MapConditionalSubscriber tryOnNe t + 128 FlowableMap java 128 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnConditionalSubscriber runAsync + 649 FlowableObserveOn java 649 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 

Fatal Exception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll + 155 SpscLinkedArrayQueue java 155 
 at io reactive internal queue SpscLinkedArrayQueue poll + 145 SpscLinkedArrayQueue java 145 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableConditionalSubscriber cancel + 157 BasicFuseableConditionalSubscriber java 157 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber cancel + 168 FlowableConcatMapMaybe java 168 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber drain + 284 FlowableConcatMapMaybe java 284 
 at io reactive internal operators mi ed FlowableConcatMapMaybe$ConcatMapMaybeSubscriber onNe t + 137 FlowableConcatMapMaybe java 137 
 at io reactive internal operators flowable FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber tryOnNe t + 101 FlowableDistinctUntilChanged java 101 
 at io reactive internal operators flowable FlowableMap$MapConditionalSubscriber tryOnNe t + 128 FlowableMap java 128 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnConditionalSubscriber runAsync + 649 FlowableObserveOn java 649 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 

Fatal Exception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll + 155 SpscLinkedArrayQueue java 155 
 at io reactive internal queue SpscLinkedArrayQueue poll + 145 SpscLinkedArrayQueue java 145 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber clear + 264 FlowableOnBackpressureBuffer java 264 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber clear + 236 FlowableObserveOn java 236 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber checkTerminated + 188 FlowableObserveOn java 188 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnSubscriber runAsync + 399 FlowableObserveOn java 399 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 
 at io reactive internal schedulers ScheduledRunnable run + 66 ScheduledRunnable java 66 
 at io reactive internal schedulers ScheduledRunnable call + 57 ScheduledRunnable java 57 

Fatal Exception java lang NullPointerE ception Attempt to invoke virtual method 'java lang Object java util concurrent atomic AtomicReferenceArray get int ' on a null object reference
 at io reactive internal queue SpscLinkedArrayQueue lvElement + 251 SpscLinkedArrayQueue java 251 
 at io reactive internal queue SpscLinkedArrayQueue poll + 138 SpscLinkedArrayQueue java 138 
 at io reactive internal queue SpscLinkedArrayQueue clear + 186 SpscLinkedArrayQueue java 186 
 at io reactive internal operators flowable FlowableOnBackpressureBuffer$BackpressureBufferSubscriber cancel + 154 FlowableOnBackpressureBuffer java 154 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber cancel + 154 FlowableObserveOn java 154 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableSkipWhile$SkipWhileSubscriber cancel + 93 FlowableSkipWhile java 93 
 at io reactive internal subscribers BasicFuseableSubscriber cancel + 158 BasicFuseableSubscriber java 158 
 at io reactive internal operators flowable FlowableElementAtSingle$ElementAtSubscriber onNe t + 85 FlowableElementAtSingle java 85 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber tryOnNe t + 74 FlowableFilter java 74 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber onNe t + 52 FlowableFilter java 52 
 at io reactive internal operators flowable FlowableSkipWhile$SkipWhileSubscriber onNe t + 56 FlowableSkipWhile java 56 
 at io reactive internal operators flowable FlowableMap$MapSubscriber onNe t + 68 FlowableMap java 68 
 at io reactive internal operators flowable FlowableObserveOn$ObserveOnSubscriber runAsync + 407 FlowableObserveOn java 407 
 at io reactive internal operators flowable FlowableObserveOn$BaseObserveOnSubscriber run + 176 FlowableObserveOn java 176 
 </stacktrace>
 <Description>Reported in We just upgraded our project from and did not see these errors in testing but are seeing them in production Were working to figure out the e act cause and will provide more information as we have it 
 </Description>
 <CreatedDate>16/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6674</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix window time possible interrupts while terminating</Title>
 <Description>Fithe case in window time variants where the timer thread is busy with window emission and the upstream terminates on some other thread the window emission is interrupted So instead of disposing the timer worker right after the upstream termination a DISPOSE message is queued up Thus any ongoing drain loop from the timer thread can cleanup gracefully After some additional considerations there is no need for DISPOSE The drain loop will take care of disposing the timer and the main downstream can simply be terminated The will be in a separate PR shortly Fixes </Description>
 <CreatedDate>17/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6674</PullRequestID>
 <IssueID>6672</IssueID>
 <Title>Question Why a running computation thread got interrupted while window is finished</Title>
 <Description>Why an active computation thread got interrupted while window is finished?
 
Is it a bug?</Description>
 <CreatedDate>16/10/2019</CreatedDate>
 <ClosedDate>17/10/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>3 </Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6668</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add missing marble diagams to Single</Title>
 <Description>Add hopefully all remaining missing marble diagrams to Single Resolves 
</Description>
 <CreatedDate>10/10/2019</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6668</PullRequestID>
 <IssueID>5788</IssueID>
 <Title>Single incorrect or missing images tracking issue </Title>
 <Description>amb missing diagram ambArray missing diagram concat arg missing diagram concat add rd and 4th source indicate backpressure concat Array missing diagram concat Array Eager missing diagram concat Eager missing diagram create missing diagram defer missing diagram error Callable missing diagram error Throwable indicate error in the box from Callable missing diagram from Publisher missing diagram from Observable missing diagram merge missing diagram merge indicate main element is a Single Source merge add and source indicate backpressure merge Delay Error Iterable Publisher missing diagrams wrong diagrams never missing diagram timer missing diagram equals missing diagram unsafe Create missing diagram using missing diagram wrap missing diagram amb With missing diagram as missing diagram hide missing diagram compose missing diagram cache missing diagram cast missing diagram delay missing diagram delay Subscription missing diagram dematerialize missing diagram do After Success missing diagram do After Terminate indicate error case do Finally missing diagram do On Subscibe missing diagram do On Success missing diagram do On Event missing diagram do On Error missing diagram do On Dispose missing diagram filter one source item indicate both true and false outcomes flat Map Publisher operator name blockingGet missing diagram lift missing diagram contains missing diagram merge With indicate backpressure on Error Return indicate item is the result of a function call with the original error on Error Return Item use the previous onErrorReturn diagram change name in bo on Error Resume Next diagram should have one item and no complete marker on Error Resume With operator name on Terminate Detach missing diagram repeat missing diagram repeat When missing diagram repeat Until missing diagram retry missing diagram retry When missing diagram subscribe missing diagram subscribe With missing diagram? take Until fiitem count in main and other sources indicate all other signal types time out missing diagram to missing diagram to Completable diagram is stretched to Flowable operator name in boindicate backpressure to Future indicate Future remove the blocking te t to Maybe operator name in boindicate both outcomes with proper signal types unsubscribe On missing diagram test missing diagram </Description>
 <code>SingleSource&lt;SingleSource&lt;T&gt;&gt; </code>
 <CreatedDate>05/01/2018</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6664</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix group By groupe mission in somecases</Title>
 <Description>This PR fixes two issues when the Observable groupBy operator would abandon a newly created group before the group only item was emitted causing data loss when the groupBy value selector failed for a new group thus the new group would never be emitted and report the failure It should fithe first test failure of but may not be the cause for the second </Description>
 <CreatedDate>04/10/2019</CreatedDate>
 <ClosedDate>05/10/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6664</PullRequestID>
 <IssueID>6663</IssueID>
 <Title>Observable group By test failures</Title>
 <Code>
  </Code>
 <stacktrace>
 io reactive RxJava3 internal operators observable ObservableGroupByTest &gt; firstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes FAILED
 java lang AssertionError e pected &lt;6&gt; but was &lt;5&gt;
 at org junit Assert fail Assert java 88 
 at org junit Assert failNotEquals Assert java 834 
 at org junit Assert assertEquals Assert java 645 
 at org junit Assert assertEquals Assert java 631 
 at io reactive RxJava3 internal operators observable ObservableGroupByTest firstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes ObservableGroupByTest java 765 
 </stacktrace>
 <Description>Two tests fail randomly on CI This is probably failing because some nonatomicity bug in determining a group has been abandoned I cant make these tests fail on my machine at all so the Group By logic has to be rechecked The Flowable variants have not failed yet </Description>
 <CreatedDate>04/10/2019</CreatedDate>
 <ClosedDate>20/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6657</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix size time bound window not creating windows properly</Title>
 <Description>There was a logic error in the size+time bound window operator for when to close a window if timers are not restarted when the sizebound is hit Due to this bug two tests were not receiving and thus accounting for empty windows that are happening when the sizebound is hit followed by the periodic timebound hit Fixes</Description>
 <CreatedDate>30/09/2019</CreatedDate>
 <ClosedDate>30/09/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6657</PullRequestID>
 <IssueID>6651</IssueID>
 <Title>Observable window long java util concurrent TimeUnit long if reached  window max count the timespan not work</Title>
 <Description>io reactive Observable window long java util concurrent Time Unit long There is nothing after seconds it make a confuse As the chart it says that the timeSpan still works after winowma size reached 
</Description>
 <CreatedDate>12/09/2019</CreatedDate>
 <ClosedDate>30/09/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6653</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix take Last time last events time window calculation</Title>
 <Description>The logic inside the Observable takeLast time was not using a fixed timestamp to compare against but one that could change between calls resulting in items wrongly skipped from the accumulated buffer The PR makes this timestamp limit fixed outside the drain loop The Flowable variant did not have the issue but both received the unit test verifying the correct behavior Fixes</Description>
 <CreatedDate>12/09/2019</CreatedDate>
 <ClosedDate>13/09/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6653</PullRequestID>
 <IssueID>6647</IssueID>
 <Title>confused of method takeLast long Time Unit </Title>
 <Description>Im a little confused about takeLast long Time Unit When executing the following code each time the output order is supposed to be N digits in the last time window but in fact the output results are inconsistent with the ideal state Code Result 
</Description>
 <CreatedDate>11/09/2019</CreatedDate>
 <ClosedDate>12/09/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6652</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix size time bound window not creating windows properly</Title>
 <Description>There was a logic error in the size time bound window operator for when to close a window if timers are not restarted when the sizebound is hit Due to this bug two tests were not receiving and thus accounting for empty windows that are happening when the sizebound is hit followed by the periodic timebound hit will be fixed in a separate PR Fixes</Description>
 <CreatedDate>12/09/2019</CreatedDate>
 <ClosedDate>17/09/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6652</PullRequestID>
 <IssueID>6651</IssueID>
 <Title>Observable window long java util concurrent TimeUnit long if reached window max count the timespan not work</Title>
 <Description>io reactive Observable window long java util concurrent Time Unit long There is nothing after seconds it make a confuse As the chart it says that the timeSpan still works after winowma size reached 
</Description>
 <CreatedDate>12/09/2019</CreatedDate>
 <ClosedDate>30/09/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6650</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>constrain ups tream requests from take remove limit operator</Title>
 <Description>As per discussion in 6569 this PR constrains upstream requests from the take operator and removes the limit operator Ive also added a couple of unit tests for coverage of elementAt that I didnt include in </Description>
 <CreatedDate>12/09/2019</CreatedDate>
 <ClosedDate>13/09/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6650</PullRequestID>
 <IssueID>6569</IssueID>
 <Title>unbounded requests from first take and others</Title>
 <Description>In we talked about some surprising request patterns from operators like firsttake and others where despite only one or a limited number of items being needed Long MAX  VALUE was requested of upstream and then cancelled after the desired number arrived   I believe this was a microoptimization performance boost that improved the Scrabble benchmarks Any change to the pattern was rejected based on it being a breaking API change In essence I d like us not to be opinionated about the effect on the upstream of overrequesting particularly over a network boundary By overrequesting we are fundamentally losing information that can be useful to optimizing upstream processing An e ample that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort O nlogn whereas requesting only one can be implemented upstream with a mascan O n This of course assumes one and only request to create the stream so is not a runofthemill streaming case I d also suggest we are not opinionated about the ability of upstream to respond to cancellation upstream may be performing cpu intensive actions in third party libraries that arent cancellable I think the effect on the benchmarks of reverting to naturally bounded requests where obvious firsttakeetc will be very small Can we revisit this one for </Description>
 <CreatedDate>12/07/2019</CreatedDate>
 <ClosedDate>13/09/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6650</PullRequestID>
 <IssueID>6620</IssueID>
 <Title>element At first constrain upstream requests </Title>
 <Description>As discussed in this PR constrains upstream requests for the elementAt and first overloads Other operators will be covered in other PRs </Description>
 <CreatedDate>16/08/2019</CreatedDate>
 <ClosedDate>16/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6648</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix take Lasttime last events time window calculation </Title>
 <Description>The logic inside the Observable takeLast time was not using a fixed timestamp to compare against but one that could change between calls resulting in items wrongly skipped from the accumulated buffer The PR makes this timestamp limit fi ed outside the drain loop The Flowable variant did not have the issue but both received the unit test verifying the correct behavior The same fix for will be posted separately Fixes</Description>
 <CreatedDate>11/09/2019</CreatedDate>
 <ClosedDate>12/09/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6648</PullRequestID>
 <IssueID>6647</IssueID>
 <Title>confused of method takeLast longTimeUnit </Title>
 <Description>Im a little confused about takeLast long Time Unit When executing the following code each time the output order is supposed to be N digits in the last time window but in fact the output results are inconsistent with the ideal state  Code Result image 
</Description>
 <CreatedDate>11/09/2019</CreatedDate>
 <ClosedDate>12/09/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6642</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix group By not canceling up stream due to group abandonment</Title>
 <Description>This PR fi es the issue when a group is not subscribed to the upstream may never cancel due to seemingly open groups The fiis a trade off with group abandonment and possible e cessive group recreation so that elements are not lost in case the groups do get subscribed to a bit later Therefore the groups should be subscribed to immediately and synchronously 
Consequently the following setups will result in constant group recreations Resolves</Description>
 <CreatedDate>29/08/2019</CreatedDate>
 <ClosedDate>29/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6642</PullRequestID>
 <IssueID>6596</IssueID>
 <Title>group By may never cancel the upstream if the group is dropped</Title>
 <Description> Summary The design decision to allow a delayed subscribe to a group emitted by groupBy i e subscribeOn creates a window where if the consumer ignores the group groupBy may never cancel its source Problem In order to support taking a limited number of groups i e source groupBy take the groupBy operator cant cancel its source just because the downstream cancelled the flow of groups on it Instead a reference counting scheme is used so that when all groups have been cancelled the upstream will then be cancelled i e source groupBy take flatMap take The documentation states that [one should not ignore a group Note A Grouped Flowable will cache the items it is to emit until such time as it is subscribed to For this reason in order to avoid memory leaks you should not simply ignore those Grouped Publisher s that do not concern you Instead you can signal to them that they may discard their buffers by applying an operator like ignoreElements to them however some operators may ignore their inputsince they dont see a group but an object only thus the group is not consumed and the source is never cancelled Unfortunately flatMap is one of such operators which when cancelled it will ignore incoming values and thus groups Add some asynchronous cancellation race and the problem manifests sooner or later source groupBy take flatMap takeUnit cancel Signal In the original R NET implementation groups are reference counted and if the consumer doesn't subscribe to it immediately the group is discarded right then However they don't cache items and thus a delayed subscription results in dataloss RxJava was set to avoid Proposition I propose a change to the groupBy logic to solve this cancellation problem as well as not lose data The solution requires multiple considerations First we need to detect if there was a subscribe call when a fresh group was emitted If not the group is discarded after the single value and a completion signal is emitted to the group This way the groupBy is not held back by a potentially unconsumed group and if the group is eventually consumed the value is not lost The drawback is that this scheme may lead to group recreation over and over even if the group is actually subscribed to in a delayed fashion Note however that since a group is practically a hot subject using subscribeOn has generally no practical benefit and consumers should apply observeOn to shift the emission to the desired thread anyway Second there is an inherent race possible between an async subscriber and deciding if the group has been subscribed to just in time Therefore an atomic state transition has to be implemented to declare a group live or dead on arrival In addition the completion of the dead group and a possible cancellation by its consumer should not trigger multiple cancellations/group removal especially the removal of a newer group with the same key Third when a Grouped Flowable is declared dead on arrival then consumed later the consumption if the cached item should not trigger a request from the main source like with any alive group consumption In contrast declaring a group dead should ask for replenishment from the main source as now we can't know if the group will ever be consumed </Description>
 <CreatedDate>29/07/2019</CreatedDate>
 <ClosedDate>29/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6639</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Clean up add Throwable and null value error messages</Title>
 <Description>This PR renames the internal add Throwable to try Add Throwable and introduces the try Add Throwable Or Report to perform the common reporting to the global error handler Usage places have been reevaluated and fixed if necessary In addition null exceptions have been made more uniform Resolves</Description>
 <CreatedDate>28/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6639</PullRequestID>
 <IssueID>6611</IssueID>
 <Title>3 Revise AtomicThrowable addThrowable usage</Title>
 <Code>
if errors addThrowable e{
 // do something with the error case
} else {
 RxJavaPlugins onError e;
}
 </Code>
 <Description>Currently many if not all usage of add Throwable is as follows The plugin error call could be inlined into the method call and renamed to try Add Throwable to ensure all usage places are updated correctly </Description>
 <CreatedDate>05/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6638</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3 Rename zip Iterable remove zip adjust concat Map argorder</Title>
 <Description>Rename zip Iterable to zip Remove zip Observable Source Observable Source and zip Publisher Publisher Change the order of the till The End argument in concat Map Delay Error and concat Map Eager Delay Error to be consistent with other operators taking a boolean parameter before prefetch max Concurrency Related</Description>
 <CreatedDate>28/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6638</PullRequestID>
 <IssueID>6610</IssueID>
 <Title>Change the parameter order of concat Map Single Maybe Completable Delay Error</Title>
 <Description>The regular concat Map Delay Error uses parameter order of mapper prefetch till The End but the S M C variants have mapper till The End prefetch The parameter ordering should match the original concat Map Delay Error</Description>
 <CreatedDate>05/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6637</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Avoid using System get Properties due to security restrictions</Title>
 <Description>Change the code in the SchedulerPoolFactory to use System getProperty directly Also fix property names to as now both and could run together Fixes</Description>
 <CreatedDate>28/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6637</PullRequestID>
 <IssueID>6636</IssueID>
 <Title>System properties access restriction </Title>
 <Description>Im getting access denied java PropertyPermission readwrite error when using the IO Scheduler Its coming from In my system I cant allow for read write access to all System properties Can this be changed to use System getProperty PURGE ENABLED KEY or the like as I can allow for access to specific keys </Description>
 <CreatedDate>27/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>3 </Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6635</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>vanniktech</FixedByID>
 <Title>Remove var arg overloads for combine Latest in Observable Flowable</Title>
 <Description>Started removing the vararg function from</Description>
 <CreatedDate>27/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6635</PullRequestID>
 <IssueID>6634</IssueID>
 <Title>improve combine Latest method names</Title>
 <Code>
public static &lt;T R&gt; Observable&lt;R&gt; combineLatest Iterable&lt;? e tends ObservableSource&lt;? e tends T&gt;&gt; sources Function&lt;? super Object[] ? e tends R&gt; combiner {}
public static &lt;T R&gt; Observable&lt;R&gt; combineLatest Function&lt;? super Object[] ? e tends R&gt; combiner int bufferSize ObservableSource&lt;? e tends T&gt; sources {}
 </Code>
 <Description>Calling combineLatest from Kotlin is a bit awkward The function has a lot of different parameters including Iterable Array as well as call sites for passing multiple Observables Is it possible to prefithese so we have some kind of combine Latest From Iterable which takes the Is it really required Callers could just use the array overload  combine Latest Delay Error is equivalent and could get the method name improvements as well Other methods such as concat merge could benefit from this change too </Description>
 <CreatedDate>27/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6629</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix ref Count not resetting when cross canceled</Title>
 <Description>This PR fixes the issue with ref Count not resetting the connection when the termination triggers cross cancellation over it Fixes The fiis more involved than because how uses two publish implementation internally due to bug fix The old classic implementation does not fail but the newer implementation fails If the fiis applied unconditionally the old classic implementation fails an older unit test verifying an error allows reconnection Therefore the PR checks and applies the new code path only if refCount isn't talking to the classic publish implementation 
As a reminder for has a redesigned Connectable with a much more clearer reset semantics and thus the restructuring of the termination handling had no trouble passing the aforementioned error allows reconnect unit test </Description>
 <CreatedDate>21/08/2019</CreatedDate>
 <ClosedDate>22/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6608</IssueID>
 <Title>ReplaySubject and buffer with debounce not emitting values after first subscription</Title>
 <Description>The issue described below started with version and continues with It works with through I have a test where a set a Replay Subject like so When I run the above test it fails on the second test subscription on RxJava or java lang Assertion Error Value counts differ expected but was latch values errors completions Expected Actual latch values errors completions </Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6609</IssueID>
 <Title>Fix ref Count not resetting when termination triggers crosscancel</Title>
 <Description>This PR fixes both ref Count implementation to properly reset the source when the source terminates multiple consumers In the original when the source terminated multiple sources the first termination handler cleared the connection but since the subscriberCount wasn't zero the source was not reset If this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object Unfortunately one can't just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers It has to wait for the source to terminate all consumers or have the consumers cancel all This affects and will be backported in a separate PR Fixes</Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6505</IssueID>
 <Title>Fix publish ref Count hang due to race</Title>
 <Description>This PR adds a work around implementation to the publish implementations Observable Publish and Flowable Publish so that when used with ref Count a connection disconnection race wont leave consumers hanging in certain situations This was necessary to avoid the behavior change with the classic implementations used without refCount In the alternate implementation when the connectable terminates the terminal event is signaled to late consumers until the operator is reset via the Reset table Connectable The ref Count operator detects the classic implementations through the ObservablePublishClassic and FlowablePublishClassic internal interfaces and replaces them via the new implementations The introduction of these interfaces were necessary to support 3rd party hooks that would intercept the classic connectable implementations via an arbitrary class which refCount wouldn't recognize or replace Fixes</Description> <CreatedDate>16/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6608</IssueID>
 <Title>Replay Subject and buffer with debounce not emitting values after first subscription</Title>
 <Description>The issue described below started with version and continues with It works with through I have a test where a set a Replay Subject like so When I run the above test it fails on the second test subscription on RxJava or java lang Assertion Error Value counts differ expected but was latch values errors completions Expected Actual latch values errors completions </Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6608</IssueID>
 <Title>Replay Subject and buffer with debounce not emitting values after first subscription</Title>
 <Description>The issue described below started with version and continues with It works with through I have a test where a set a Replay Subject like so When I run the above test it fails on the second test subscription on RxJava or java lang Assertion Error Value counts differ expected but was latch values errors completions Expected Actual latch values errors completions 
</Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6629</PullRequestID>
 <IssueID>6609</IssueID>
 <Title>3 FirefCount not resetting when termination triggers crosscancel</Title>
 <Description>This PR fixes both refCount implementation to properly reset the source when the source terminates multiple consumers In the original when the source terminated multiple sources the first termination handler cleared the connection but since the subscriberCount wasnt zero the source was not reset If this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object Unfortunately one can t just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers It has to wait for the source to terminate all consumers or have the consumers cancel all This affects and will be backported in a separate PR Fixes</Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6627</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix blocking Iterable hang when force disposed</Title>
 <Description>When the iterator was cast to Disposable and disposed the subsequent hasNe t would block indefinitely That interface is not intended to be part of the public API and Iterator in general does not support any form of official cancellation unlike Stream This PR makes sure that if that dispose is called it unblocks the iterator Resolves </Description>
 <CreatedDate>21/08/2019</CreatedDate>
 <ClosedDate>21/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6627</PullRequestID>
 <IssueID>6625</IssueID>
 <Title>2 Calling hasNe t on a disposed blocking iterator hangs forever</Title>
 <Description>Calling hasNe t on a a blocking iterator never returns if the iterator has been disposed Tested on To reproduce</Description>
 <CreatedDate>21/08/2019</CreatedDate>
 <ClosedDate>21/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6626</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix blocking Iterable not unblocking when force disposed</Title>
 <Description>When the iterator was cast to Disposable and disposed the subsequent has Net would block indefinitely That interface is not intended to be part of the public API and Iterator in general does not support any form of official cancellation unlike Stream This PR makes sure that if that dispose is called it unblocks the iterator A separate PR will be posted for Related</Description>
 <CreatedDate>21/08/2019</CreatedDate>
 <ClosedDate>21/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6626</PullRequestID>
 <IssueID>6625</IssueID>
 <Title>Calling has Next on a disposed blocking iterator hangs forever</Title>
 <Description>Calling has Next on a blocking iterator never returns if the iterator has been disposed Tested on To reproduce 
</Description>
 <CreatedDate>21/08/2019</CreatedDate>
 <ClosedDate>21/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6620</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>element At first constrain upstream requests</Title>
 <Description>As discussed in this PR constrains upstream requests for the element At and first overloads Other operators will be covered in other PRs</Description>
 <CreatedDate>16/08/2019</CreatedDate>
 <ClosedDate>16/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6620</PullRequestID>
 <IssueID>6569</IssueID>
 <Title>unbounded requests from first take and others</Title>
 <Description>In we talked about some surprising request patterns from operators like firsttake and others where despite only one or a limited number of items being needed Long MA _VALUE was requested of upstream and then cancelled after the desired number arrived I believe this was a microoptimization performance boost that improved the Scrabble benchmarks Any change to the pattern was rejected based on it being a breaking API change In essence Id like us not to be opinionated about the effect on the upstream of overrequesting particularly over a network boundary By overrequesting we are fundamentally losing information that can be useful to optimizing upstream processing An e ample that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort O nlogn whereas requesting only one can be implemented upstream with a mascan O n This of course assumes one and only request to create the stream so is not a runofthemill streaming case I d also suggest we are not opinionated about the ability of upstream to respond to cancellation upstream may be performing cpu intensive actions in thirdparty libraries that aren t cancellable I think the effect on the benchmarks of reverting to naturally bounded requests where obvious firsttakeetc will be very small Can we revisit this one for </Description>
 <CreatedDate>12/07/2019</CreatedDate>
 <ClosedDate>13/09/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6618</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix switch Map incorrect sync fusion error management</Title>
 <Description>This PR fixes the incorrect request call inside switch Map when working with syncfused sources Fixes</Description>
 <CreatedDate>14/08/2019</CreatedDate>
 <ClosedDate>14/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6618</PullRequestID>
 <IssueID>6615</IssueID>
 <Title>Flowable from Iterable does not work as e pected when used in switch Map</Title>
 <Code>
 System out println "value1 " + value ;
 System out println "complete";
 </Code>
 <Description>This issue was reproduces on RxJava and RC I have this piece of code This one prints value value And then nothing no complete no error nothing </Description>
 <CreatedDate>14/08/2019</CreatedDate>
 <ClosedDate>14/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6616</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix switch Map incorrect sync fusion error management</Title>
 <Description>This PR fixes the incorrect request call inside switch Map when working with syncfused sources Fixes</Description>
 <CreatedDate>14/08/2019</CreatedDate>
 <ClosedDate>14/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6616</PullRequestID>
 <IssueID>6615</IssueID>
 <Title>Flowable from Iterable does not work as expected when used in switch Map</Title>
 <Code>
 System out println "value1 " + value ;
 System out println "complete";
 </Code>
 <Description>This issue was reproduces on RxJava RC I have this piece of code This one prints value value And then nothing no complete no error nothing </Description>
 <CreatedDate>14/08/2019</CreatedDate>
 <ClosedDate>14/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6612</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix many operators swallowing undeliverable exceptions</Title>
 <Description>Fimany operators to emit the collected exception in case of a cancel dispose call to the plugin error handler i e becoming undeliverable excptions In addition the terminal event error delivery has been unified in many other operators so that the terminalindicator exception is never leaked There will be a separate PR about cleaning up the addThrowable usage cases Fixes</Description>
 <CreatedDate>05/08/2019</CreatedDate>
 <ClosedDate>05/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6612</PullRequestID>
 <IssueID>6611</IssueID>
 <Title>Revise Atomic Throwable add Throwable usage</Title>
 <Code>
if errors addThrowable e{
 // do something with the error case
} else {
 RxJavaPlugins onError e;
}
 </Code>
 <Description>Currently many if not all usage of add Throwable is as follows The plugin error call could be inlined into the method call and renamed to try Add Throwable to ensure all usage places are updated correctly 
</Description>
 <CreatedDate>05/08/2019</CreatedDate>
 <ClosedDate>28/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6612</PullRequestID>
 <IssueID>6587</IssueID>
 <Title>Inner errors within concat Map Single vanish if disposed</Title>
 <Code>
public class Test {
	public static void main String[] args {
//		Observable just 01 		// UndeliverableE ceptionFirst concatMapSingleblock throws interrupting second one
		Observable just 2 0 		// Just "MyError" output e ception in first block appears to vanish
				 concatMapSingle workItem2 &gt; {
					return Single just workItem2 subscribeOn Schedulers computation map workItem &gt; {
						try {
							Thread sleep 1000 ;
							if workItem == 1 
								throw new E ception "Something in first block failed" ;
							Thread sleep 1000 ;
						} catch InterruptedE ception e {
							System out println "InterruptedE ception in block 1" ;
							throw e;
						}
						return workItem;
					} ;
				} concatMapSingle workItem2 &gt; {
					return Single just workItem2 subscribeOn Schedulers computation map workItem &gt; {
						try {
							Thread sleep 1000 ;
							if workItem == 2 {
								throw new E ception "Something in second block failed" ;
							}
							Thread sleep 1000 ;
						} catch InterruptedE ception e {
							System out println "InterruptedE ception in block 2" ;
							throw e;
						}
						return workItem;
					} ;
				} blockingSubscribe item &gt; System out println "Item finished " + itemerr &gt; {
					System out println "MyError " + err toString ;
					err printStackTrace ;
				} ;
	}
}
 </Code>
 <Description>Not sure if this intentional or a bug The following code has processing stages If the first one throws an exception the second one gets interrupted and throws an Undeliverable Exception In the opposite case if the nd block throws an exception the st one gets interrupted but its InterruptedE ception is completely ignored not delivered to any error handler nor thrown as Undeliverable Exception This is caused by some kind of race condition within Concat Map Single Main Observer When the nd block throws on the Concat Map Single Main Observer instance belonging to the 1st block dispose is called before inner Error Because at this point errors is empty add Throwable succeeds but the drain loop is never called because dispose has set the Atomic Integer to Therefore the exception in error is never retrieved and forwarded This can be fixed if it needs fixing anyways by having inner Error dispose and the drain loop check for cancelled and forward e ceptions to Rx Java Plugins on Error if appropriate I will make a PR </Description>
 <CreatedDate>23/07/2019</CreatedDate>
 <ClosedDate>05/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6609</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix ref Count not resetting when termination triggers crosscancel</Title>
 <Description>This PR fixes both ref Count implementation to properly reset the source when the source terminates multiple consumers In the original when the source terminated multiple sources the first termination handler cleared the connection but since the subscriber Count wasnt zero the source was not reset If this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object Unfortunately one can't just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers It has to wait for the source to terminate all consumers or have the consumers cancel all This affects and will be backported in a separate PR Fixes</Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6609</PullRequestID>
 <IssueID>6608</IssueID>
 <Title>Replay Subject and buffer with debounce not emitting values after first subscription</Title>
 <Description>The issue described below started with version and continues with It works with through I have a test where a set a Replay Subject like so When I run the above test it fails on the second test subscription on RxJava or java lang Assertion Error Value counts differ expected but was latch values errors completions Expected Actual latch values errors completions </Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6607</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>3 Haveinternal operator observableunittestse tendsRxJavaTest6</Title>
 <Description>This commit updates the unit tests for internal operator observable Related</Description>
 <CreatedDate>02/08/2019</CreatedDate>
 <ClosedDate>03/08/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6607</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests extend a base test class</Title>
 <Code>
public abstract class RxJavaTest {
 protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;
   public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a global timeout and a perclass log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This base class ignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via [Gradle's test runner] </Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6604</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Have unit tests extends RxJava Test</Title>
 <Description>This commit updates the unit tests of the following operators internal operators maybe internal operator mixed internal operator single Related</Description>
 <CreatedDate>30/07/2019</CreatedDate>
 <ClosedDate>31/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6604</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests e tend a base test class</Title>
 <Code>
public abstract class RxJavaTest {
 protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;

 public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a global timeout and a per class log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This base class ignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via [Gradle's test runner] </Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6602</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix truncation bugs in replay and Replay Subject Processor</Title>
 <Description>This PR fixes several truncation bugs with the time and size bound replay operators and their hot class versions Unexpected removal of the last item just added due to becoming outofdate at the lowest time resolution creating a hole in the linked chain and hanging the consumer Related failure Incorrect size accounting upon removing old entries leading to more items dropped than expected Related</Description>
 <CreatedDate>30/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6602</PullRequestID>
 <IssueID>6582</IssueID>
 <Title>Fix truncation bugs in replay and Replay Subject Processor</Title>
 <Description>This PR fixes several truncation bugs with the time and size bound replay operators and their hot class versions Unexpected removal of the last item just added due to becoming outofdate at the lowest time resolution creating a hole in the linked chain and hanging the consumer Related failure Incorrect size accounting upon removing old entries leading to more items dropped than expected Side note The operators and classes would benefit from a rewrite to improve on allocation and indirection I wanted first to get the bugfi es and related tests done to have a known good baseline </Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>22/07/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6601</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Observable Blocking Subscribe compares with wrong object</Title>
 <Description>It should compare the TERMINATED instance with the value received from the blocking queue Fixes Related</Description>
 <CreatedDate>30/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6601</PullRequestID>
 <IssueID>6576</IssueID>
 <Title>ObservableBlockingSubscribe compares BlockingObserver TERMINATED with wrong object</Title>
 <Description>The Observable Blocking Subscribe observe function appears to compare the o variable i e the Observable Source which shouldnt ever change with Blocking Observer TERMINATED This will probably never be true The intention was likely to use instead of oin  Since this appears to be some what redundant with bs is Disposed this probably does not cause any issues </Description>
 <CreatedDate>17/07/2019</CreatedDate>
 <ClosedDate>19/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6601</PullRequestID>
 <IssueID>6577</IssueID>
 <Title>Fiissue Observable Blocking Subscribe compares Blocking Observer TERMINATED with wrong object</Title>
 <Description>Fix compare with instead of</Description>
 <CreatedDate>17/07/2019</CreatedDate>
 <ClosedDate>19/07/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6600</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>Roman Wuattier</FixedByID>
 <Title>Have internal operator flowable unit tests extends RxJava Test4</Title>
 <Description>This commit updates the unit tests for internal operator flowable Related 
</Description>
 <CreatedDate>30/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6600</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests extend a base test class</Title>
 <Code>public abstract class RxJavaTest {
 protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;
 public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a global timeout and a perclass log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This baseclassignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via  Gradle s test runner  </Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6599</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix merge With not canceling other when the main fails</Title>
 <Description>Fithe same bug in merge With cancelling the main source when the main source errors instead of the other source Fixes Related</Description>
 <CreatedDate>30/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6599</PullRequestID>
 <IssueID>6597</IssueID>
 <Title>using Observable merge With Completable Source up stream occurs an error but the Comletable Source wont be disposed</Title>
 <Code> 
 public void subscribe ObservableEmitter&lt;Object&gt; emitter throws E ception {
 Schedulers io scheduleDirect 
&gt; emitter tryOnError new Throwable "occurs error" 
1 TimeUnit SECONDS ;
 }
 
public void subscribe ObservableEmitter&lt;Object&gt; emitter throws E ception {
Schedulers io scheduleDirect &gt; emitter tryOnError new Throwable "occurs error"1 TimeUnit SECONDS ;
} 
 </Code>
 <Description>using Observable merge With Completable Source up stream occurs an error but the Comletable Source wont be disposed The dispose will be invokedã€‚In case of firstit will produce a memory leak Is that a bug</Description>
 <CreatedDate>29/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6599</PullRequestID>
 <IssueID>6598</IssueID>
 <Title>Fix merge With not cancelling the other source if the main errors</Title>
 <Description>The merge With implementations on Error called by the main source cancelled the main source instead of cancelling the other source This mistake affects all overloads of the operator Fixes</Description>
 <CreatedDate>29/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6598</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix merge With not cancelling theo ther source if the main errors</Title>
 <Description>The merge With implementations on Error called by the main source cancelled the main source instead of cancelling the other source This mistake affects all overloads of the operator Fixes</Description>
 <CreatedDate>29/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x<PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6598</PullRequestID>
 <IssueID>6597</IssueID>
 <Title>using Observable merge With Completable Source up stream occurs an error but the Comletable Source wont be disposed</Title>
 <Code>
 public void subscribe ObservableEmitter&lt;Object&gt; emitter throws E ception {
 Schedulers io scheduleDirect 
&gt; emitter tryOnError new Throwable "occurs error" 
1 TimeUnit SECONDS ;
 }
 
public void subscribe ObservableEmitter&lt;Object&gt; emitter throws E ception {
Schedulers io scheduleDirect &gt; emitter tryOnError new Throwable "occurs error"1 TimeUnit SECONDS ;
}
 </Code>
 <Description>using Observable merge With Completable Source up stream occurs an error but the Comletable Source wont be disposed The dispose will be invoked In case of firstit will produce a memory leak Is that a bug</Description>
 <CreatedDate>29/07/2019</CreatedDate>
 <ClosedDate>30/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6595</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Haveunittestse tendsRxJavaTest3</Title>
 <Description>This commit updates the unit tests of the following operators single subjects subscribers And for internal operators internal disposable internal fuctions internal observers internal queue interanl schedulers internal subscribers internal subscriptions internal operator completable Related </Description>
 <CreatedDate>28/07/2019</CreatedDate>
 <ClosedDate>29/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6595</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests e tend a base test class</Title>
 <Code>
public abstract class RxJavaTest {
 protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;
 public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a global timeout and a perclass log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This baseclassignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via Gradle test runner </Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6594</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Have unit tests extends RxJavaTest2</Title>
 <Description>This commit updates the unit tests of the following operators flowable maybe observable disposable observer parallel processors schedulers and RxJava plugin Related</Description>
 <CreatedDate>27/07/2019</CreatedDate>
 <ClosedDate>28/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6594</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests e tend a base test class</Title>
 <Code>
public abstract class RxJavaTest {
  protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;
 public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a global timeout and a per class log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This base class ignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via Gradle test runner</Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6589</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Createabasetestclassandhaveallunittestse tendit</Title>
 <Description>This commit creates the RxJavaTest class defining a default timeout to minutes An ignored test announce itself for each running class e tending it preventing Travis CI from killing the build Have Completable tests extend from RxJavaTest Have Disposable tests extend from RxJavaTest Have Exception tests extend from RxJavaTest Related</Description>
 <CreatedDate>24/07/2019</CreatedDate>
 <ClosedDate>26/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6589</PullRequestID>
 <IssueID>6583</IssueID>
 <Title>Have all unit tests extend a base test class</Title>
 <Code>
public abstract class RxJavaTest {
 protected Timeout globalTimeout = new Timeout 5 TimeUnit MINUTES ;
 public final void announce {
 }
}
 </Code>
 <Description>By adding a common base class we can enable a "global" timeout and a perclass log output that prevents Travis CI to stop the build and also not flood the log with all methods This way we no longer have to rely on the random ignores scattered along the codebase This baseclassignore may seem unnecessarily complicated but unfortunately I was unable to create a working setting via Gradle test runner</Description>
 <CreatedDate>22/07/2019</CreatedDate>
 <ClosedDate>04/08/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6577</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>Erlkoenig90</FixedByID>
 <Title>Fix issue Observable Blocking Subscribe compares Blocking Observer TERMINATED with wrong object</Title>
 <Description>Fix compare with instead of</Description>
 <CreatedDate>17/07/2019</CreatedDate>
 <ClosedDate>19/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6577</PullRequestID>
 <IssueID>6576</IssueID>
 <Title>Observable Blocking Subscribe compares Blocking Observer TERMINATED with wrong object</Title>
 <Description>The Observable Blocking Subscribe observe function appears to compare the o variable i e the ObservableSourcewhich shouldn't ever change with Blocking Observer TERMINATED This will probably never be true The intention was likely to use v instead of oin Since this appears to be somewhat redundant with bs is Disposed this probably does not cause any issues </Description>
 <CreatedDate>17/07/2019</CreatedDate>
 <ClosedDate>19/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6566</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix wording in Single javadocs</Title>
 <Description>Some wording fixes in Single includes</Description>
 <CreatedDate>11/07/2019</CreatedDate>
 <ClosedDate>12/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6566</PullRequestID>
 <IssueID>6565</IssueID>
 <Title>Fix JavaDocs of Single do On Terminate refer to on Complete notification</Title>
 <Description>As mentioned in JavaDocs of this class that Single does not have on Complete notification This newly introduced method refer to that notification which looks to me it should be onSuccess instead </Description>
 <CreatedDate>11/07/2019</CreatedDate>
 <ClosedDate>15/07/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6564</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>remove buffer window with supplieron Exception ResumeNext</Title>
 <Description>This PR removes kinds of operators that had no noticeable use bases or use cases on their own in the past years buffer Supplier Supplier window Supplier int on Exception Resume Next source Resolves Resolves
 </Description>
 <CreatedDate>08/07/2019</CreatedDate>
 <ClosedDate>11/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6564</PullRequestID>
 <IssueID>6554</IssueID>
 <Title>Remove on Exception Resume Next</Title>
 <Code>
 </Code>
 <Description>Java Docs source on Error Resume Next error error instanceof Exception fallback Obserable error error I dont remember ever needing asked for or recommended this operator? The difference from on Error Resume Next is that anything that's not e tending E ception can pass through I believe it was added to support some internal Net fli operation It can be emulated via on Error Resume Next 
 </Description>
 <CreatedDate>03/07/2019</CreatedDate>
 <ClosedDate>11/07/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6564</PullRequestID>
 <IssueID>6555</IssueID>
 <Title>Remove exact buffer window with Supplier source</Title>
 <Code></Code>
 <Description>source buffer Observable defer supplier take repeat  There e ist special overloads of the exact boundary buffer window operators that takes a supplier of a source Example JavaDocs This supplier is called over and over once the previous boundary signaled an item or completed Im not sure if this type of boundary was in use at all It can be emulated with the plain sourced versiong 
</Description>
 <CreatedDate>03/07/2019</CreatedDate>
 <ClosedDate>11/07/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6560</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>hluhovskyi</FixedByID>
 <Title>Fix NPE when debouncing empty source</Title>
 <Description>Background Related issue Cherry pick of for version Debounce with selector on the empty Observable leads to NPE It happens because of DebounceObserver debouncer field is set up only when on Net is called When on Net isnt called at all like when debouncing Observable emptywe get a null reference from debouncer and call emit on null which actually leads to NPE Change Wrap emit call with null check both in Observable Debounce and Flowable Debounce Test plan To check Observable gradlew test tests io reactive internal operators observable ObservableDebounceTest debounceOnEmpty To check Flowable gradlew test tests io reactive internal operators flowable Flowable Debounce Test debounce On Empty </Description>
 <CreatedDate>04/07/2019</CreatedDate>
 <ClosedDate>04/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6560</PullRequestID>
 <IssueID>6558</IssueID>
 <Title>NPE when debouncing empty source</Title>
 <Description>Hey there Ive faced with an issue when debouncing empty source it leads NPE Here is simple test which demonstrates a problem Issue also touches Flowable in the same way RxJava version is however it is also reproducible for latest I am going to create PR with a fisoon for both of versions let s keep this ticket to track a state of the issue 
</Description>
 <CreatedDate>04/07/2019</CreatedDate>
 <ClosedDate>05/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6560</PullRequestID>
 <IssueID>6559</IssueID>
 <Title>3 FiNPE when debouncing empty source</Title>
 <Description>Background Related issue Debounce with selector on the empty Observable leads to NPE It happens because of Debounce Observer debouncer field is set up only when on Net is called When on Net isnt called at all like when debouncing Observable empty we get a null reference from debouncer and call emit on null which actually leads to NPE Change Wrap emit call with null check both in ObservableDebounce and FlowableDebounce Test plan To check Observable 
 </Description>
 <CreatedDate>04/07/2019</CreatedDate>
 <ClosedDate>05/07/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6559</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>hluhovskyi</FixedByID>
 <Title>Fix NPE when debouncing empty source</Title>
 <Description>Background Related issue Debounce with selector on the empty Observable leads to NPE It happens because of Debounce Observer debouncer field is set up only when on Net is called When on Net isnt called at all like when debouncing Observable emptywe get a null reference from debouncer and call emit on null which actually leads to NPE Change Wrap emit call with null check both in Observable Debounce and Flowable Debounce Test plan To check Observable gradlew test tests io reactive internal operators observable Observable Debounce Test debounce On Empty To check Flowable gradlew test tests "io reactive internal operators flowable Flowable Debounce Test debounce On Empty  </Description>
 <CreatedDate>04/07/2019</CreatedDate>
 <ClosedDate>05/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6559</PullRequestID>
 <IssueID>6558</IssueID>
 <Title>NPE when debouncing empty source</Title>
 <Description>Hey there Ive faced with an issue when debouncing empty source it leads NPE Here is simple test which demonstrates a problem Issue also touches Flowable in the same way RxJava version is however it is also reproducible for latest I am going to create PR with a fisoon for both of versions let s keep this ticket to track a state of the issue </Description>
 <CreatedDate>04/07/2019</CreatedDate>
 <ClosedDate>05/07/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6556</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>luiscortes</FixedByID>
 <Title>rename on error resume net methods to disambiguate when calling from</Title>
 <Description>Resolves Renamed on Error Resume Net Source to on Error Resume With Source for Observable May be Single and Flowable Renamed some unit tests and their classes to reflect the method name change Changed parameter type of Single on Error Resume With from Single to Single Source Updated JavaDocs for all renamed methods Removed redundant casts for unit tests  Deleted duplicate unit test that arose from no longer needing to cast arguments </Description>
 <CreatedDate>03/07/2019</CreatedDate>
 <ClosedDate>04/07/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6556</PullRequestID>
 <IssueID>6551</IssueID>
 <Title>Disambiguous some method call sites when calling from Kotlin </Title>
 <Description>I vaguely remember that we already had a discussion about this but I dont know which conclusion was drawn Observable on Error Resume Next is ambiguous when calling from Kotlin  img width alt Screen shot at src Since is a thing do we want to rename these methods Similar to what we did with startWith even though there was no type inference problem </Description>
 <CreatedDate>30/06/2019</CreatedDate>
 <ClosedDate>04/07/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6544</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>luiscortes</FixedByID>
 <Title>Fixing version tagon Schedulers from Executor boolean</Title>
 <Description>Resolves Updating the version tag on Schedulers from Executor boolean since it was promoted </Description>
 <CreatedDate>26/06/2019</CreatedDate>
 <ClosedDate>26/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6544</PullRequestID>
 <IssueID>6543</IssueID>
 <Title>Fix Schedulers from Executor boolean version tag</Title>
 <Description>It should say since as it has been promoted </Description>
 <CreatedDate>26/06/2019</CreatedDate>
 <ClosedDate>28/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6538</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add concat Map with Scheduler guaranteeing where the mapper runs</Title>
 <Description>This PR adds an overload to concat Map and concat Map Delay Error in both Flowable and Observable which makes sure the mapper function is always e ecuted on a dedicated scheduler By default concatMap may e ecute the mapper function on various threads the subscribing thread the upstream thread generating the items to be mapped or the thread where the generated inner source terminates These overloads remove this kind of uncertainty The implementation is a copy of the original concat Map instead of an e tension so that optimizations for the nonscheduled variants still work without extra overhead Overloads to the concatMap Single Maybe Completable and concatMap Single Maybe Completable DelayError may be added in a separate PR later Resolves</Description>
 <CreatedDate>24/06/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6538</PullRequestID>
 <IssueID>6447</IssueID>
 <Title>observe On concat Map may not invoke the mapper function on the desired thread</Title>
 <Code>Flowable range observe On Schedulers computation concat Map v Flowable just Thread current Thread to String blocking Subscribe System out println </Code>
 <Description>There are two effects in play here fusion and trampolining Fusion will take the observe On queue and just pull on it when the subscription happens Trampolining will use the last interacting thread the subscription thread or the termination thread to pull on the internal queue dedicated or fused and when there is an item it will run the mapper on that thread This will likely print computation main main main main Work arounds Use hide between observeOn and concat Map to break fusion Use subscribeOn after concatMap to move the trampoline off the main thread Use defer subscribe On in the mapper function to calculate the actual Flowable on a desired thread not the mapper thread Appeared on StackOverflow </Description>
 <CreatedDate>28/03/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Investigating</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6535</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Java Docs clarify create emitter sare per consumer</Title>
 <Description>This PR adds this documentation part to the various create JavaDocs adapted Whenever an Observer subscribes to the returned Observable the provided Observable On Subscribe callback is invoked with a fresh instance of an ObservableEmitter that will interact only with that specific Observer If this Observer disposes the flow making ObservableEmitter isDisposed return true other observers subscribed to the same returned Observable are not affected Resolves</Description>
 <CreatedDate>21/06/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6535</PullRequestID>
 <IssueID>6390</IssueID>
 <Title>Observable Emitter Flowable Emitte RxJavadoc Improvement</Title>
 <Description>The javadoc for Observable Emtter states The emitter allows the registration of a single resource in the form of a Disposable or Cancellable via set Disposable Disposable or set Cancellable Cancellable respectively The emitter implementations will dispose cancel this instance when the downstream cancels the flow or after the event generator logic calls Emitter onError ThrowableEmitter onComplete or when tryOnError Throwable succeeds Similarly the javadoc for Flowable Emitter states The emitter allows the registration of a single resource in the form of a Disposable or Cancellable via setDisposable Disposable or setCancellable Cancellable respectively The emitter implementations will dispose cancel this instance when the downstream cancels the flow or after the event generator logic calls Emitter onError ThrowableEmitter onComplete or when tryOnError Throwable succeeds when the downstream cancels the flow is ambiguous for a noobie like me It isn't clear that a subscriber calling dispose will cancel the flow It would be very helpful if the relationship between the Emitter and the downstream subscriber was more e plicit </Description>
 <CreatedDate>29/01/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6534</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Make using resource disposal order consistent with eagermode</Title>
 <Description>Make the resource disposal order in all using implementations are consistent with the eagerness of the operator eager dispose resource then dispose the upstream noneager dispose the upstream then dispose the resource Fixes</Description>
 <CreatedDate>21/06/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6534</PullRequestID>
 <IssueID>6347</IssueID>
 <Title>Observable using disposes resource before upstream</Title>
 <Description>Ive expected that Observable using flow is create resource creates resource using observable subscribe finish cancel resourceusing observable dispose resource But for me actual is sometimes create resource creates resource using observable subscribe dispose resource finish cancel resource using observable As I understand using eager makes second flow consistent but i need first behavior which is not observed on dispose callresource is disposed first always then observable What is correct way to make Observable which is not eager even on dispose
</Description>
 <CreatedDate>19/12/2018</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Enhancement</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6533</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3 RemoveChanges md</Title>
 <Description>An unnecessary duplication of the releases tab Changing the file triggers an unecessary build that has to be canceled on Travis CI so that the actual release runs without interference Resolves</Description>
 <CreatedDate>21/06/2019</CreatedDate>
 <ClosedDate>21/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6533</PullRequestID>
 <IssueID>5646</IssueID>
 <Title>drop CHANGES md</Title>
 <Description>It has become somewhat of an inconvenience to update CHANGES md before pasting in the release text into the GitHubs own release page causing a full build before the release build just for that single file I don't remember e actly why CHANGES md was introduced but my assumption is that searching inside it via is simpler than searching within the Releases tab Options Keep it Drop it Use a dedicated wiki page instead 
</Description>
 <CreatedDate>05/10/2017</CreatedDate>
 <ClosedDate>21/06/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6532</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add eager truncation to bounded replay to avoid item retention</Title>
 <Description>This PR adds the eagerTruncate option to the replay operator so that the head node will lose the item reference it holds upon truncation The bounded buffers in replay implement a linked list that when truncated moves the head reference forward along the links atomically This allows late consumers to pick up the head and follow the links between them to get items replayed However the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would null out the value the consumer reaching the same node would see null as well and fail To avoid this type of retention the head node has to be refreshed with a new node still pointing to the ne t node in the chain but without any value The reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full which would reduce performance in cases where the e cess retention is not a problem Overloads to both the direct and functionvariants of both Flowable replay and Observable replay have been added To avoid too many overloads only one e tra overload has been added e tending the signature of the longest parameterized method per each bounds mode size time time+size Their unit test files have been cloned so that both the noneager original behavior and the eager behavior is tested separately Fixes</Description>
 <CreatedDate>21/06/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6532</PullRequestID>
 <IssueID>6475</IssueID>
 <Title>Bounded Replay Buffer temporarily leaks memory</Title>
 <Description>When using Observable replay Nthe Bounded Replay Buffer keeps up to N items in its buffer When using replay for example it keeps a reference to the most recent item but also the previous stale item Take for e ample this trivial snippet of code that provides an available Android View as a stream The replay call suggests a single value is cached but the implementation keeps a strong reference to the previous item as well Since this happens as a hidden side effect and rather counter intuitively it is easy to accidentally leak memoryeven when the client code seems to be careful about it Especially with Android Views referencing Activity conte ts this is problematic proposed a fifor this at the cost of an e tra Node allocation which turned out to be unwanted The proposed alternative there refers to RxJava Extensions cache Last but this only emits the very last item not intermediates </Description>
 <CreatedDate>07/05/2019</CreatedDate>
 <ClosedDate>24/06/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6530</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>disambiguate start With to start With Item start With Iterable</Title>
 <Description>start With and startWith Iterable was causing some trouble with startWith Publisher This PR will rename the former two The diagrams will be updated in a separate PR Resolves</Description>
 <CreatedDate>21/06/2019</CreatedDate>
 <ClosedDate>21/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6530</PullRequestID>
 <IssueID>6122</IssueID>
 <Title>Disambiguate start With Iterable</Title>
 <Description>We were using postfixes to avoid inference problems around operator methods such as from Iterable vs from Array but there is at least one operator currently start With that may exhibit type ambiguity A dedicated postfixed name should resolve the issue such as  start With start With Iterable Iterable start With Item start With Iterable remove start With start With Item T start With Iterable Iterable remove start With As a preparation we can deprecate start With within in case option or is chosen </Description>
 <CreatedDate>01/08/2018</CreatedDate>
 <ClosedDate>21/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6528</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>maksimm</FixedByID>
 <Title>Renametestmethodsandenablethecheck</Title>
 <Description>Fi6518 </Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6528</PullRequestID>
 <IssueID>6518</IssueID>
 <Title>remove test from test method names create a validator </Title>
 <Description>A lot of test methods were named like testin the era and we didnt want to change those for Now is the time to get rid of the redundant naming from all test methods In addition a validator should be added that checks all test Java files and reports if it finds the pattern void in any file See  this validator  for an example of finding and checking source code files </Description>
 <CreatedDate>19/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6526</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Remove methods from test consumer smake internal versions</Title>
 <Description>Remove methods from the standard test consumers based on feedback in comment Some test support has been moved into the io reactive testsupport package in the form of Test Observer and Test Subscriber Resolves</Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6526</PullRequestID>
 <IssueID>6153</IssueID>
 <Title>review features of the test consumers</Title>
 <Description>Review available assertions Remove redundant assertions Resolve ambiguities about the assertions Rething naming of assertions 
</Description>
 <CreatedDate>10/08/2018</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6525</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>maksimm</FixedByID>
 <Title>remove test from test method names create avalidator</Title>
 <Description>Fix Create validator Automatically rename methods test to analog to Fix License Headers Rename methods</Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Test</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6525</PullRequestID>
 <IssueID>6518</IssueID>
 <Title>remove test from testmethod names create a validator </Title>
 <Description>A lot of test methods were named like testin the era and we didnt want to change those for Now is the time to get rid of the redundant naming from all test methods In addition a validator should be added that checks all test Java files and reports if it finds the pattern void in any file See this validator for an e ample of finding and checking source code files </Description>
 <CreatedDate>19/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6523</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>3 Fi concatMapDelayErrornotcontinuingonfusedinnersourcecrash</Title>
 <Description>The Supplier fused path didnt consider the errordelay settings and cut the sequence short Fixes </Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6523</PullRequestID>
 <IssueID>6520</IssueID>
 <Title>Issus about Flowable concatMapDelayError</Title>
 <Code>
if integer &gt;= 100 {
 throw new NullPointerE ception "test null e p" ;
}
if integer &gt;= 100 {
 throw new NullPointerE ception "test null e p" ;
}
 </Code>
 <Description>RxJava version I feel doubt about Flowable concat Map Delay Error when I use Flowable from Callable The following code 
 </Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6522</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix concat Map Delay Error not continuing on fused inner source crash</Title>
 <Description>The Callable fused path didnt consider the errordelay settings and cut the sequence short Fixes</Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6522</PullRequestID>
 <IssueID>6520</IssueID>
 <Title>Issus about Flowable concatMapDelayError</Title>
 <Code>
if integer &gt;= 100 {
 throw new NullPointerE ception "test null e p" ;
}
return integer;
  </Code>
 <Description>RxJava version I feel doubt about Flowable concat Map Delay Error when I use Flowable from Callable The following code 
 </Description>
 <CreatedDate>20/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6519</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Connect able Flowable Connetable Observabe redesign</Title>
 <Description>This PR changes the connectable API to have a specific reset method to reset a terminated connectable source as part of the official API In when publish terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call connect again see 6501 However replay did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed items In this two corner cases have been fi ed by the introduction of reset Both publish and replay now remain in their terminated state until reset is called If the connection is disposed it will automatically reset their state just like before The state transitions are as follows This does resolve the race condition with publish refCount described in In addition there are some changes to Flowable publish behavior It no longer keeps consuming the upstream if there are no subscribers This implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation I have no strong preference on this property and in comparison Observable publish drops items because there is no backpressure buffer in its implementation Upstream errors are not reported to the RxJavaPlugins onError handler when if there are no subscribers but have to be observed via a subscriber Because terminal events are available until reset now we can't know really if there is going to be a subscriber or not However it might be possible to detect the noconsumer case upon an error and still report it when reset or dispose is called Resolves Resolves </Description>
 <CreatedDate>19/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6519</PullRequestID>
 <IssueID>6501</IssueID>
 <Title>publish refCount race may leave observers hanging</Title>
 <Code>
for (int i = 0; i &lt; 10_000; i++) {
 Observable&lt;Integer&gt; observable = Observable just 1 publish refCount ;
}
 </Code>
 <Description>This test eventually times out because one of the sources will not complete or trigger a reconnection Originally reported as a comment</Description>
 <CreatedDate>13/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6519</PullRequestID>
 <IssueID>6501</IssueID>
 <Title>publish ref Count race may leave observers hanging</Title>
 <Code>
for (int i = 0; i &lt; 10_000; i++) {
 Observable&lt;Integer&gt; observable = Observable just 1 publish refCount ;
}
</Code>
 <Description>This test eventually times out because one of the sources will not complete or trigger a reconnection Originally reported as a comment</Description>
 <CreatedDate>13/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6519</PullRequestID>
 <IssueID>5628</IssueID>
 <Title>Connectable Observable redesign</Title>
 <Description> Problem The CompletableObservable and Completable Flowable implementors publish and replay in RxJava and are inconsistent in their terminal behavior When publish terminates its CompletableObservable will appear as fresh to the new subscribers This has the drawback that such subscribers may hang as connect may be never called again In contrast replay will stay terminated along with any cached items and new subscribers can still get those events The drawback here is that a new connect will clear the internal storage and start the consumption of the main source while not giving any chance to subscribers to prepare and receive that stream of events from the start if the replay is bounded Dealing with this inconsistency currently requires refCount to trigger a reset on an unofficial channel casting the Completable Observer into Disposable if possible and disposing it when the count reaches zero again Suggested solution I suggest changing the API to include an explicit reset method and changing the logic to have states fresh connect running on Complete on Error terminated reset fresh and possibly terminated connect running In the fresh state consumers can pile up and be ready to receive events An atomic state change to running will begin streaming events until a terminal event is reached at which point the state atomically changes to terminated Consumers subscribing in this state will always receive the terminal event and in case of replaythe cached items as well A call to reset will clear the internal storage of the Connectable Observable and start out as fresh again allowing new consumers to gather around and get all fresh events from the beginning It is possible to support the call to connect in the terminated state to skip the fresh state Preventing this transition however may be more involved as connect should communicate this to be illegal transition someway as well as the need for a soft way for checking if connect is to succeed or not Note that calling connect on a running ConnectableObservable is a noop in and </Description>
 <CreatedDate>29/09/2017</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6519</PullRequestID>
 <IssueID>5899</IssueID>
 <Title>Flowable publish should not drop items if there are no consumers</Title>
 <Description>Unlike Observable publishthe Flowable publish has an internal queue and fetches data from upstream based on consumption For historical reasons the implementation drops items when there are no consumers which can lead to unnecessary dataloss when switching between consumers on an item boundary 
I propose changing the operator into not drop items when there are no consumers Thebehavior can be achieved via an additional unbounded consumer which stays subscribed until the operator completes </Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6516</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>remove get Values from some subjects processors</Title>
 <Description>The get Value and get Values methods were a remnant from a time where Subject and Flowable Processor was unifying all state peeking methods for every kind of subject processor These have been marked as Deprecated inand are now removed from They can be trivially replaced with get Value if necessary for example Related </Description>
<code>
Object value = subject getValue ;
if value == null {
 return new Object[1];
}
return new Object[] { value };
 </code>
 <CreatedDate>19/06/2019</CreatedDate>
 <ClosedDate>19/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Removal</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6516</PullRequestID>
 <IssueID>5622</IssueID>
 <Title>3 Breaking API changes</Title>
 <Description>This issue collects the API changes proposed for unused operators and overloads mistakes in signatures etcRemove Flowable subscribe args with Consumer super Subscription Remove Observable subscribe args with Consumer super Disposable Change Completable blocking Get signature Change Maybe default If Empty to return Single Change to to use dedicated non generic functional type which then can be implemented by a single class for multiple base types Remove Behavior Subject get Values Remove Behavior Processor get Values Change Single to Completable to Single ignore Element to be consistent with the other types Remove Async Subject get Values Remove Async Processor get Values
</Description>
 <CreatedDate>26/09/2017</CreatedDate>
 <ClosedDate>19/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6514</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Merge asin to to</Title>
 <Description>In the to operator used the generic Function to allow assemblytime conversion of flows into arbitrary types The drawback of this approach was that each base reactive type had the same Function interface in their method signature thus it was impossible to implement multiple converters for different reactive types within the same class To work around this issue the as operator andConverter interfaces have been introduced in 2 which interfaces are distinct and can be implemented on the same class Changing the signature of to in 2 was not possible due to the pledged binary compatibility of the library From the as methods have been removed and the to methods now each work with their respective Converer interfaces Flowable to Function Flowable is now Flowable to Flowable Converter Observable to Function Observable is now Observable to Observable Converter Maybe to FunctionFlowableT R is now Maybe to Maybe Converter Single to Function Flowable is now Maybe to Single Converter Completable to Function Completable R is now Completable to Completable Converter Parallel Flowable to Function Parallel Flowable is now ParallelFlowable to Parallel Flowable Converter If one was using these methods with a lambda e pression only a recompilation is needed before source to flowableflowable blocking First after source to flowableflowable blockingFirst If one was implementing a Function interface typically anonymouslythe interface type type arguments and the throws clause have to be adjusted Resolves</Description>
<code>
public Integer apply Flowable&lt;Integer&gt; t throws E ception {
 return t blockingFirst ;
 }
 
 public Integer apply Flowable&lt;Integer&gt; t {
 return t blockingFirst ;
 }
</code>
 <CreatedDate>19/06/2019</CreatedDate>
 <ClosedDate>19/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6514</PullRequestID>
 <IssueID>5654</IssueID>
 <Title>Proposal Observable Converter interface and friends</Title>
 <Description>For the compose operators ObservableTransformer was introduced to allow for classes to implement multiple transformer interfaces for composite implementations Id like to propose doing the same for the to operator by introducing Observable Converter and corresponding ones for others This would allow for composite converters as well If youre open to this I can contribute a PR</Description>
 <CreatedDate>09/10/2017</CreatedDate>
 <ClosedDate>19/06/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6505</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix publish ref Count hang due to race</Title>
 <Description>This PR adds a workaround implementation to the publish implementations Observable Publish and Flowable Publish so that when used with ref Count a connection disconnection race won't leave consumers hanging in certain situations This was necessary to avoid the behavior change with the classic implementations used without refCount In the alternate implementation when the connectable terminates the terminal event is signaled to late consumers until the operator is reset via the Reset table Connectable The refCount operator detects the classic implementations through the Observable Publish Classic and Flowable Publish Classic internal interfaces and replaces them via the new implementations The introduction of these interfaces were necessary to support 3rd party hooks that would intercept the classic connectable implementations via an arbitrary class which refCount wouldn't recognize or replace Fixes</Description>
 <CreatedDate>16/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6505</PullRequestID>
 <IssueID>6501</IssueID>
 <Title>publish refCount race may leave observers hanging</Title>
 <Code>
for (int i = 0; i &lt; 10_000; i++) {
 Observable&lt;Integer&gt; observable = Observable just 1 publish refCount ;
}
 </Code>
 <Description>This test eventually times out because one of the sources will not complete or trigger a reconnection Originally reported as a comment</Description>
 <CreatedDate>13/06/2019</CreatedDate>
 <ClosedDate>20/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6498</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Merge in changes from since the initial branching</Title>
 <Description>Version Bug fixes Fizip not stopping the subscription upon eager error Documentation changes  Fixed wrong type referenced in Maybe and Single JavaDocs Update the Javadoc of the retry operator Other Remove dependency of Schedulers from ObservableRefCountChange error message in ObservableFromArrayRemove redundant methods from sample ObservableRemove unused import from Flowable java Remove unused else from the Observable Version March Maven Bug fixes Add missing undeliverable error handling logic for Completable fromRunnable  fromAction operators  Documentation changes Improve the docs of Composite Disposable Improve subjects and processors package docImprove Creating Observables wiki doc Other Make error messages of parameter checks consistent </Description>
 <CreatedDate>06/06/2019</CreatedDate>
 <ClosedDate>13/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>3 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6488</IssueID>
 <Title>Fizip not stopping the subscription upon eager error</Title>
 <Description>The Observable zip did not stop subscribing to the ne t sources if the previous one failed with an onError Flowable zip works as intended Fixes</Description>
 <CreatedDate>26/05/2019</CreatedDate>
 <ClosedDate>27/05/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6453</IssueID>
 <Title>Fi ed typos for comments</Title>
 <Description>I was looking at the docs and found that some details does not match the given code For example It says new Completable instance when in fact it returns a Maybe </Description>
 <CreatedDate>04/04/2019</CreatedDate>
 <ClosedDate>04/04/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6458</IssueID>
 <Title>Update the Javadoc of the retry operator</Title>
 <Description>Specify that the times function parameter describes the number of times to resubscribe if the current Observable fails Solves
</Description>
 <CreatedDate>10/04/2019</CreatedDate>
 <ClosedDate>12/04/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6452</IssueID>
 <Title>Remove dependency of Schedulers from Observable Ref Count</Title>
 <Description>Resolves In the constructor of Observable Ref Count that takes Connectable Observable source as the argument we set timeout to L In that specific use case of ObservableRefCountscheduler is never needed Its only referenced in cancel method but if timeout is  it wont be triggered at all because there is early return This commit removes the need to depend on Schedulers trampoline and instead passes null to be scheduler when the ref count is not time based Similarly applies the same change to Flowable Ref Count The reasons for this change are the following In projects that dont depend on Schedulers class if there is no reference to Schedulersthe whole Schedulers can be stripped out of the library after optimizations e g proguard With constructor that references Schedulersthe optimizer cant properly strip it out In our quick test of our Android app we were able to reduce the RxJava library size dependency from KB to KB after optimization but before compression by simply avoiding access to Schedulers in Observable Ref Count 
 In terms of modularity Observable Ref Count is just an operator so it by itself should probably not have dependency on what available pool of schedulers Schedulers there are It should just know that there is some Scheduler that could be passed to ObservableRefCount when ObservableRefCount needs it </Description>
 <CreatedDate>03/04/2019</CreatedDate>
 <ClosedDate>04/04/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6461</IssueID>
 <Title>Change error message in ObservableFromArray</Title>
 <Description>Changed the error message when an element at position i is null to what was suggested in 6460 
</Description>
 <CreatedDate>13/04/2019</CreatedDate>
 <ClosedDate>13/04/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6469</IssueID>
 <Title>Remove redundant methods from Sample Observable </Title>
 <Description>Resolves 6468</Description>
 <CreatedDate>26/04/2019</CreatedDate>
 <ClosedDate>26/04/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6470</IssueID>
 <Title>remove unused import in Flowable java</Title>
 <Description>remove unused import in Flowable java</Description>
 <CreatedDate>28/04/2019</CreatedDate>
 <ClosedDate>28/04/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6485</IssueID>
 <Title>remove unused else from the Observable</Title>
 <Description>Remove unused else from the Observable class 
</Description>
 <CreatedDate>23/05/2019</CreatedDate>
 <ClosedDate>23/05/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6442</IssueID>
 <Title>Undeliverable error handling logic for Completable operators</Title>
 <Description>Completable from Action and Completable from Runnable operators were missing RxJava Plugins calls to handle Undeliverable errors This behaviour is fixed in this PR Also added missing error handling java doc for Completable fromRunnable </Description>
 <CreatedDate>25/03/2019</CreatedDate>
 <ClosedDate>26/03/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6432</IssueID>
 <Title>2 composite disposable docs</Title>
 <Description>On Composite Disposable add and addAll methods if the param is null currently the NPE error message produced by Object Helper is d is null which is not very helpful This is a small refactor for making the message a bit more helpful Resolves 6430 </Description>
 <CreatedDate>15/03/2019</CreatedDate>
 <ClosedDate>15/03/2019</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6434</IssueID>
 <Title>Improve subjects and processors package doc</Title>
 <Description> Fix typo in the subjects doc Expand the processors doc</Description>
 <CreatedDate>18/03/2019</CreatedDate>
 <ClosedDate>18/03/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6436</IssueID>
 <Title>refactor improves CreatingObservables wiki doc</Title>
 <Description>This PR improves the documentation for creating observables suggestions from lorenzpahl also included Closes  
</Description>
 <CreatedDate>19/03/2019</CreatedDate>
 <ClosedDate>21/03/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6498</PullRequestID>
 <IssueID>6433</IssueID>
 <Title>Make error messages of parameter checks consistent</Title>
 <Description>This PR updates error messages of parameter checks Most of the changes are due to the renaming of a parameter without changing the error message used when the parameter check fails </Description>
 <CreatedDate>16/03/2019</CreatedDate>
 <ClosedDate>21/03/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6497</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>khkong</FixedByID>
 <Title>Update Alphabetical List of Observable Operators md</Title>
 <Description> Invalid link edited </Description>
 <CreatedDate>04/06/2019</CreatedDate>
 <ClosedDate>04/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6497</PullRequestID>
 <IssueID>6132</IssueID>
 <Title>Update wiki to reflect tracking issue </Title>
 <Description>This is the overview of the suggested planned changes to the Wiki Text in bold are for e tra considerations optionsAdditional Reading mdreview links add newer links to blogs and topicsAlphabetical List of Observable Operators mdremove nonstandard deleted otherwise projecte ternal operators add newer operators link to the categorized other md files and sections in the wikiAlphabetical List of rd party operators md create page and list operators that used to be in RxJava andor interesting enough but available in rd party libraries such as RxJavae trasAsync Operatorsreview the operator set point to RxJavaE tensions project add fancy descriptions like in Back pressureupdate wording remove unavailable operators fiimage links make sure e amples are in JavaBack pressure mdmaybe review should be okay as it has been recently addedBlocking Observable Operators mdupdate to blocking methods add fancy descriptions like ine isting operators only fiimage linkCombining Observables mde pand operator list concateager with Latest From missing?fancy likelink to RxJavaE tensions or e plain join patterns hereConditional and Boolean Operators mdreview operators linke plain e tensions ops fancy likeConnectable Observable Operators mdadd newer operators have e amples in Java fiimage linksCreating Observables mdadd generateError Handling Operators mdreview set fancy likeError Handling mdreview only e isting e ceptions include the error handling e planations from the Whats different pageFiltering Observables mdreview remove none istent operators fancy likeGetting Started mdfiversions and maven group ids remove troubleshooting section add getting started from Readme md?Home mdRxJava project is no longer polyglot link to the other R YYY projects instead review sales pitch reviewe pand libraries and check for true v version support mention the v interop for the older libsHow To Use RxJava mdturn nonJava e amples into Java use only Java e amples fiimage links review the create sectionHow to Contribute mdneeds e tensive rewrite and detailingImplementing Your Own Operators mdneeds e tensive rewrite somewhat redundant with Writing Operators mdImplementing custom operators draft mdv only unlist it and add bannercontentMathematical and AggregateOperators mdreview operator list link to RxJavaE tensions fancy likeconcat is not an aggregatorObservable Utility Operators mdreview set add new operators fancy likeObservable mdpretty barebone perhaps list all reactive types and their support interfaces with some descriptionsParallelflows mdlist parallel operators sequential Delay Error fancy likeno longer e perimentalbetaPhantomOperators mddumping ground for oldnever relaized operators remove or add warning about historicalmuseum content?Plugins mdrewrite for RxJava Plugins and related componentsProblem Solving Examplesin RxJava mdFibonacci is not a relevant problem not sure what problem examples could be listed here instead how to wrapbridge to existing technologies How to get REST data into a listviewReactive Streams mdremove v related details wording Java Flow has been shippedScheduler mdneeds e tensive e pansion also add system properties perhaps mention e otic schedulers in RxJavaE tensions perhaps show how to write a schedulerString Observables mdthe RxJavaE tensions only has a few string operators link to them? fancy like Subject md needs e tensive e pansion show the various subject types their specific methods e amplesThe RxJava Android Module mdmaybe just link to R Android and remove the restTransforming Observables mdreview and add new operators fancy likeWhats different in md fineWritingoperatorsformde pand fusion topics e ample operatorsFooter mdfineSidebar mdnot sure if this is actually displayed as there is the Sidebar md md too Sync the twoSidebar md mdreorganize a bit list categories under "all operators"remove v references move v pages up
</Description>
 <CreatedDate>03/08/2018</CreatedDate>
 <ClosedDate>
 </ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6496</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>khkong</FixedByID>
 <Title>UpdateAdditionalReading md</Title>
 <Description> First line was edited What is Reactive Programming was wrong link so deleted </Description>
 <CreatedDate>04/06/2019</CreatedDate>
 <ClosedDate>04/06/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6496</PullRequestID>
 <IssueID>6132</IssueID>
 <Title>Update wiki to reflect 3 tracking issue </Title>
 <Description>This is the overview of the suggested planned changes to the Wiki Text in bold are for e tra considerations options Additional Reading mdreview links add newer links to blogs and topicsAlphabetical List of ObservableOperators mdremove nonstandard deletedotherwise projecte ternal operators add newer operators link to the categorized other md files and sections in the wikiAlphabetical List of rd party operators md create page and list operators that used to be in RxJava andor interesting enough but available in rd party libraries such as RxJavae trasAsyncOperators review the operator set point to RxJavaE tensions project add fancy descriptions like in Backpressure update wording remove unavailable operators fiimage links make sure e amples are in JavaBackpressure mdmaybe review should be okay as it has been recently addedBlocking Observable Operators mdupdate to blockingmethods add fancy descriptions like inexisting operators only fiimage linkCombining Observables mde pand operator list concateager with Latest From missingfancy like link to RxJavaE tensions or e plain join patterns hereConditional and Boolean Operators mdreview operators linke plain e tensions ops fancy likeConnectable Observable Operators mdadd newer operators have e amples in Java fiimage linksCreating Observables mdadd generateError HandlingOperators mdreview set fancy likeError Handling mdreview only e isting e ceptions include the error handling e planations from the What's different pageFiltering Observables mdreview remove none istent operators fancy likeGetting Started mdfiversions and maven group ids remove troubleshooting section add getting started from Readme mdHome mdRxJava project is no longer polyglot link to the other R YYY projects instead review "sales pitch" reviewe pand libraries and check for true v version support mention the v interop for the older libsHowToUseRxJava mdturn nonJava e amples into Java use only Java e amples fiimage links review the create sectionHowtoContribute mdneeds e tensive rewrite and detailingImplementing Your Own Operators mdneeds e tensive rewrite somewhat redundant with WritingOperators mdImplementing customoperators draft mdv only unlist it and add bannercontentMathematical and Aggregate Operators mdreview operator list link to RxJavaE tensions fancy likeconcat is not an aggregatorObservable Utility Operators mdreview set add new operators fancy likeObservable mdpretty barebone perhaps list all reactive types and their support interfaces with some descriptionsParallel flows mdlist parallel operators sequentialDelayErrorfancy likeno longer experimental betaPhantom Operators mddumping ground for oldnever relaized operators remove or add warning about historical museum contentPlugins mdrewrite for RxJava Plugins and related componentsProblem Solving Examplesin RxJava mdFibonacci is not a relevant problem not sure what problem e amples could be listed here instead how to wrap bridge to existingtechnologies How to get REST data into a listviewReactive Streams mdremove v related details wording Java Flow has been shippedScheduler mdneeds e tensive e pansion also add system properties perhaps mention e otic schedulers in RxJavaE tensions perhaps show how to write a schedulerString Observables mdthe RxJavaE tensions only has a few string operators link to them fancy like Subject md needs e tensive e pansion show the various subject types their specific methods e amplesThe RxJava Android Module mdmaybe just link to R Android and remove the restTransformingObservables mdreview and add new operators fancy likeWhats differentinmdfineWriting operatorsformde pand fusion topics e ample operatorsFooter mdfineSidebar mdnot sure if this is actually displayed as there is the Sidebar md md too Sync the twoSidebar md mdreorganize a bit list categories under "all operators"remove v references move v pages up
</Description>
 <CreatedDate>03/08/2018</CreatedDate>
 <ClosedDate>
 </ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Discussion</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6488</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 Fi zipnotstoppingthesubscriptionuponeagererror</Title>
 <Description>The Observable zip did not stop subscribing to the next sources if the previous one failed with an on Error Flowable zip works as intended Fixes</Description>
 <CreatedDate>26/05/2019</CreatedDate>
 <ClosedDate>27/05/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6488</PullRequestID>
 <IssueID>6487</IssueID>
 <Title>Multiple errors in ziped observables with flatMap</Title>
 <Description>While reading Error handling on wiki I realized that in a zip operator with a multiple network calls its possible to receive a crash with an Undeliverable Exception I tried to reproduce this behavior RxJava version Reproduce code Is this behavior correct Why there is no Undeliverable Exception in the second test Thanks</Description>
 <CreatedDate>26/05/2019</CreatedDate>
 <ClosedDate>27/05/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6483</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>LxSMNSYC</FixedByID>
 <Title>Correction for Maybe count doc typo</Title>
 <Description>Resolves</Description>
 <CreatedDate>20/05/2019</CreatedDate>
 <ClosedDate>20/05/2019</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6483</PullRequestID>
 <IssueID>6481</IssueID>
 <Title>Maybe count doc typo</Title>
 <Description>Screenshot from Says here that it returns a Maybe when in fact it returns a Single </Description>
 <CreatedDate>20/05/2019</CreatedDate>
 <ClosedDate>20/05/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6480</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>cvgaviao</FixedByID>
 <Title>Update README md</Title>
 <Description>fix issue</Description>
 <CreatedDate>18/05/2019</CreatedDate>
 <ClosedDate>18/05/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6480</PullRequestID>
 <IssueID>6479</IssueID>
 <Title>Example in readme gives me compilation error</Title>
 <Description>I m trying the examples provided in the readme file and in specifically this one I got a compilation error in the map method Cannot return a void result </Description>
 <CreatedDate>18/05/2019</CreatedDate>
 <ClosedDate>05/06/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6469</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>LxSMNSYC</FixedByID>
 <Title>Remove redundant methods from Sample Observable</Title>
 <Description>Resolves</Description>
 <CreatedDate>26/04/2019</CreatedDate>
 <ClosedDate>26/04/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>6461</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>IRuizM</FixedByID>
 <Title>Change error message in Observable From Array</Title>
 <Description>Changed the error message when an element at position i is null to what was suggested in 6460 
</Description>
 <CreatedDate>13/04/2019</CreatedDate>
 <ClosedDate>13/04/2019</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6461</PullRequestID>
 <IssueID>6460</IssueID>
 <Title>fromArray to report Element at inde$i is null</Title>
 <Description>Currently Observable fromArray says The ith element is nullwhich is a bit misleading as i is the element inde Update the error message to The element at index is null The Flowable version should be updated if necessary Note that the null checks appear multiple places </Description>
 <CreatedDate>13/04/2019</CreatedDate>
 <ClosedDate>13/04/2019</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
<Label>good first issue</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6076</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>UMFsimke</FixedByID>
 <Title>Add marble diagrams to the Single delay method</Title>
 <Description>Here are marbles for delay operator in Please let me know if I need to change anything on the diagram itself If not please send me URL when you upload image within the project so I can change URL for the marble in the PR </Description>
 <CreatedDate>08/07/2018</CreatedDate>
 <ClosedDate>10/07/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6076</PullRequestID>
 <IssueID>5788</IssueID>
 <Title>Single incorrect or missing images tracking issue </Title>
 <Description>amb missing diagram amb Array missing diagram concat arg missing diagram concat add rd and th source indicate backpressure concat Array missing diagram concat Array Eager missing diagram concat Eager missing diagram create missing diagram defer missing diagram error Callable missing diagram error Throwable indicate error in the bo from Callable missing diagram from Publisher missing diagram from Observable missing diagram merge missing diagram merge Single Source Single Source indicate main element is a SingleSource merge s s add rd and th source indicate backpressure merge Delay Error Iterable Publisher missing diagrams SSS wrong diagrams never missing diagram timer missing diagram equals missing diagram unsafe Create missing diagram using missing diagram wrap missing diagram ambWith missing diagram as missing diagram hide missing diagram compose missing diagram cache missing diagram cast missing diagram delay missing diagram delay Subscription missing diagram dematerialize missing diagram do After Success missing diagram do After Terminate indicate error case do Finally missing diagram do On Subscibe missing diagram do On Success missing diagram do On Event missing diagram do On Error missing diagram do On Dispose missing diagram filter one source item indicate both true and false outcomes flat Map Publisher operator name blocking Get missing diagram lift missing diagram contains missing diagram merge With indicate backpressure on Error Return indicate item is the result of a function call with the original error on Error Return Item use the previous on Error Return diagram change name in box on Error Resume Next diagram should have one item and no complete marker on Error Resume With operator name on Terminate Detach missing diagram repeat missing diagram repeat When missing diagram repeat Until missing diagram retry missing diagram retry When missing diagram subscribe missing diagram subscribe With missing diagram takeUntil fiitem count in main and other sources indicate all other signal types timeout missing diagram to missing diagram to Completable diagram is stretched to Flowable operator name in boindicate backpressure to Future indicate Future remove the blocking text to Maybe operator name in boindicate both outcomes with proper signal types unsubscribe On missing diagram test missing diagram </Description>
 <CreatedDate>05/01/2018</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6075</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>UMFsimke</FixedByID>
 <Title>Add marble diagram to the Single filter method</Title>
 <Description>Hopefully this should tick off the filter operator in Please let me know if I need to change anything on the diagram itself If not please send me URL when you upload image within the project so I can change URL for the marble in the PR Although I had a doubt and wanted to double check Operator filter returns Maybe which essentially will call onSuccess or onComplete By running jUnit tests I could observe that this is a behavior but if I use Test Observer then both assert Value and assert Complete are invoked when there are elements that satisfy filter condition </Description>
 <CreatedDate>08/07/2018</CreatedDate>
 <ClosedDate>08/07/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6075</PullRequestID>
 <IssueID>5788</IssueID>
 <Title>Single incorrect or missing images tracking issue </Title>
 <Description>amb missing diagram ambArray missing diagram concat arg missing diagram concat s1 s4 add 3rd and 4th source indicate backpressure concatArray missing diagram concatArrayEager missing diagram concatEager missing diagram create missing diagram defer missing diagram error Callable missing diagram error Throwable indicate error in the bo from Callable missing diagram from Publisher missing diagram from Observable missing diagram merge missing diagram merge Single Source Single Source indicate main element is a Single Source merge add source indicate backpressure merge Delay Error Iterable Publisher missing diagrams wrong diagrams never missing diagram timer missing diagram equals missing diagram unsafeCreate missing diagram using missing diagram wrap missing diagram ambWith missing diagram as missing diagram hide missing diagram compose missing diagram cache missing diagram cast missing diagram delay missing diagram delaySubscription missing diagram dematerialize missing diagram do After Success missing diagram do After Terminate indicate error case do Finally missing diagram do On Subscibe missing diagram do On Success missing diagram do On Event missing diagram do On Error missing diagram do On Dispose missing diagram filter one source item indicate both true and false outcomes flat Map Publisher operator name blocking Get missing diagram lift missing diagram contains missing diagram merge With indicate backpressure on Error Return indicate item is the result of a function call with the original error on Error Return Item use the previous on Error Return diagram change name in bo on Error Resume Next diagram should have one item and no complete marker on Error Resume With operator name on Terminate Detach missing diagram repeat missing diagram repeat When missing diagram repeat Until missing diagram retry missing diagram retry When missing diagram subscribe missing diagram subscribe With missing diagram? take Until fiitem count in main and other sources indicate all other signal types timeout missing diagram to missing diagram to Completable diagram is stretched to Flowable operator name in boindicate backpressure to Future indicate Future remove the blocking te t to Maybe operator name in boindicate both outcomes with proper signal types unsubscribe On missing diagram test missing diagram </Description>
 <CreatedDate>05/01/2018</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6074</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>UMFsimke</FixedByID>
 <Title>AddmarblediagramtotheSingle nevermethod</Title>
 <Description>First of all Im extremely grateful to open my first PR for RxJava I hope that Ill be able to tick more of the marbles from but for now this should tick off the never operator Please let me know if I need to change anything on the diagram itself If not please send me URL when you upload image within the project so I can change URL for the marble in the PR </Description>  <CreatedDate>07/07/2018</CreatedDate>
 <ClosedDate>08/07/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6074</PullRequestID>
 <IssueID>5788</IssueID>
 <Title>Single incorrect or missing images tracking issue </Title>
 <Description>amb missing diagram ambArray missing diagram concat arg missing diagram concat source indicate backpressure concat Array missing diagram concat ArrayEager missing diagram concat Eager missing diagram create missing diagram defer missing diagram error Callable missing diagram error Throwable indicate error in the box fromCallable missing diagram fromPublisher missing diagram fromObservable missing diagram merge missing diagram merge Single Source Single Source T indicate main element is a Single Source merge add and source indicate backpressure mergeDelayError Iterable Publisher missing diagrams wrong diagrams never missing diagram timer missing diagram equals missing diagram unsafe Create missing diagram using missing diagram wrap missing diagram ambWith missing diagram as missing diagram hide missing diagram compose missing diagram cache missing diagram cast missing diagram delay missing diagram delaySubscription missing diagram dematerialize missing diagram do After Success missing diagram do After Terminate indicate error case do Finally missing diagram do On Subscibe missing diagram do On Success missing diagram do On Event missing diagram do On Error missing diagram do On Dispose missing diagram filter one source item indicate both true and false outcomes flat Map Publisher operator name blockin gGet missing diagram lift missing diagram contains missing diagram merge With indicate backpressure on Error Return indicate item is the result of a function call with the original error on Error Return Item use the previous onErrorReturn diagram change name in bo on Error Resume Next diagram should have one item and no complete marker on Error Resume With operator name on Terminate Detach missing diagram repeat missing diagram repeat When missing diagram repeat Until missing diagram retry missing diagram retry When missing diagram subscribe missing diagram subscribe With missing diagram? take Until fiitem count in main and other sources indicate all other signal types timeout missing diagram to missing diagram to Completable diagram is stretched to Flowable operator name in boindicate backpressure to Future indicate Future remove the blocking text to Maybe operator name in boindicate both outcomes with proper signal types unsubscribe On missing diagram test missing diagram </Description>
 <CreatedDate>05/01/2018</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <Labels>
<Label>3 </Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6060</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 Fi concatMapSingleMaybenullemissionondisposerace</Title>
 <Description>This PR fixes a bug in all specialized concat Map implementation that allows null to be emitted when the success signal of the inner source races with the dispose signal of the sequence Likely fixes </Description>
 <CreatedDate>22/06/2018</CreatedDate>
 <ClosedDate>22/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6060</PullRequestID>
 <IssueID>6059</IssueID>
 <Title>map method called with null observable concatMapMaybe map</Title>
 <Code> </Code>
 <Description>I have something like This is null sometimes our tests reproduce it consistently in one case Didnt happen onI cant give more information for now just to let you know there is a problem If you cant figure it out soon Ill try to create some reproduction </Description>
 <CreatedDate>22/06/2018</CreatedDate>
 <ClosedDate>22/06/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6053</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add May be marble diagrams</Title>
 <Description>Resolved the following diagrams of amb missing diagramambArray missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayed marble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Eager Iterable missing diagram concat Eager Publisher missing diagram
</Description>
 <CreatedDate>21/06/2018</CreatedDate>
 <ClosedDate>21/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6053</PullRequestID>
 <IssueID>5806</IssueID>
 <Title>Maybe incorrect or missing marbles tracking issue </Title>
 <Description>amb missing diagram amb Array missing diagram concat Iterable missing diagram concat Publisher missing diagram concat Publisher int missing diagram concat Array missing diagram concat Array Delay Error indicate error delayedmarble per source concat Array Eager missing diagram concat Delay Error Iterable missing diagram concat Delay Error Publisher missing diagram concat Delay Error Publisher int fioverlap misalignment inside the operator bo concat Eager Iterable missing diagram concat Eager Publisher missing diagram create missing diagram defer missing diagram error Callable indicate callable returns the error from Action missing diagram from Completable missing diagram from Single missing diagram from Callable missing diagram from Future Future operator name in the boindicate Future is the parameter from Future Future long TimeUnit operator name in the boindicate Future is the parameter indicate timeout from Runnable missing diagram merge Iterable missing diagram merge Publisher missing diagram merge Publisher int missing diagram merge Array missing diagram merge Array Delay Error one marble per Maybe source merge Delay Error Iterable one marble per Maybe source merge Delay Error Publisher one marble per Maybe source merge Delay Error Maybe Maybe one marble per Maybe source sequenceEqual result should be Single timer result should be Maybe using rework to indicate the created Maybe wrap missing marble zip Iterable one marble per Maybe source result should be Maybe zip Maybe Maybe one marble per Maybe source result should be Maybe zip Array one marble per Maybe source result should be Maybe amb With one marble per Maybe source result should be Maybe  as missing diagram operator removed blockingGet missing diagram cache one marble per Maybe source result should be Maybe cast missing diagram compose missing diagram concatMap indicate Maybe target indicate empty source concatWith one marble per Maybe source result should be Maybe operator name indicate other is a parameter contains one marble per Maybe source result should be Single empty case count one marble per maybe operator name result should be Single empty case default If Empty nonempty case result should be Maybe delay time one marble per Maybe source result should be Maybe delay Publisher one marble per Maybe one signal by the Publisher empty publisher case delay Subscription Publisher missing diagram delay Subscription time one marble per Maybe source result should be Maybe do After Success missing diagram do After Terminate operator name one marble per Maybe result should be Maybe do Finally missing diagram do On Dispose missing diagram do On Complete one marble per Maybe result should be Maybe do On Error missing diagram do On Event missing diagram do On Subscribe missing diagram do On Success missing diagram do On Terminate one marble per Maybe result should be Maybe filter one marble per Maybe result should be Maybe flat Map Function Function Callable one marble per Maybe result should be Maybe flat Map Function BiFunction one marble per Maybe result should be Maybe flat Map Observable should be mapped into an Observable flat Map Publisher indicate backpressure flat Map Single indicate empty maybe results in error flat Map Single Element operator name indicate empty maybe flat Map Completable indicate empty maybe hide missing diagram ignore Element operator name one marble per Maybe result should be Maybe is Empty result should be Single merge With operator name one marble per Maybe indicate backpressure of Type one marble per Maybe on Error Complete missing diagram on Error Resume Next one marble per Maybe result should be Maybe on Error Resume With one marble per Maybe result should be Maybe on Error Return one marble per Maybe result should be Maybe indicate callback on Error Return Item operator name one marble per Maybe result should be Maybe indicate normal outcome  on Exception Resume Next operator takes a Maybe source directlyË‡ operator removed on Terminate Detach missing diagram repeat one marble per source indicate backpressure indicate repeat conditions repeat Until operator name repeat condition indicate backpressure repeat When one marble per Maybe indicate backpressure retry one marble per Maybe result should be Maybe indicate repeat conditions retry int Predicate missing diagram retry Predicate missing diagram retry Until missing diagram retry When one marble per Maybe output should be Maybe switch If Empty improve diagrams indicate argument type take Until one marble per May be output should be Maybe timeout one marble per May be output should be Maybe timeout May be Source missing diagram timeout May be Source May be Source missing diagram timeout Publisher missing diagram timeout Publisher May be Source missing diagram to missing diagram to Flowable missing diagram to Observable missing diagram to Single missing diagram unsubscribe On missing diagram zip With one marble per May be output should be Maybe</Description>
 <CreatedDate>10/01/2018</CreatedDate>
 <ClosedDate>29/01/2020</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6052</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>sircelsius</FixedByID>
 <Title>5980madesubscribeActualprotected</Title>
 <Description> Proposal Changed subscribeActual from public to protectedas described in How I tested Ran tests locally please let me know if I missed part of the contributing guidelines Fixes</Description>
 <CreatedDate>20/06/2018</CreatedDate>
 <ClosedDate>21/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6052</PullRequestID>
 <IssueID>5980</IssueID>
 <Title>subscribe Actual accidental public</Title>
 <Description>Looks like the following protected void subscribe Actual implementations have unintentionally become public Publish Subject Publish Processor There is no reason to call subscribe Actual from outside of RxJava however making these protected counts as a breaking change However it should be e tremely unlikey somebody was actually using these methods directy The question is do we take the risk and fithe visibility inor it has to wait for Note that many operators are also having this method as public but those are not really accessible from the outside </Description>
 <CreatedDate>29/04/2018</CreatedDate>
 <ClosedDate>21/06/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>3x</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6049</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>romanzes</FixedByID>
 <Title>Makeite plicitthatthrottleWithTimoutisanaliasofdebounce</Title>
 <Description>The documentation implies that these two methods are somewhat different Fixing that confusion as discussed in Made the descriptions of these methods the sameMentioned that it is an alias in the first paragraphs of throttle With Timeout javadoc commentsRemoved the links to thirdparty websites</Description>
 <CreatedDate>17/06/2018</CreatedDate>
 <ClosedDate>18/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6049</PullRequestID>
 <IssueID>6043</IssueID>
 <Title>Observable throttle With Timeout is confusing</Title>
 <Code>
public final Observable&lt;T&gt; throttleWithTimeout long timeout TimeUnit unit {
 return debounce timeout unit ;
}
 </Code>
 <Description>The documentation for Observable throttle With Timeout implies that its different from debounce and invites to read about the differences Of these links the first one isnt available anymore and the last two are about JS Looking at the methods implementation it becomes clear that in RxJava its not different from debounce in any way Do we really need both methods If yes could the documentation say explicitly that they are synonyms? Could these links to thirdparty websites be removed</Description>
 <CreatedDate>14/06/2018</CreatedDate>
 <ClosedDate>18/06/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6036</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>HansChua</FixedByID>
 <Title>2 Fix disposed Lambda Observeron Error to route to global error handler</Title>
 <Description>Fix the behaviour of LambdaObserver when disposed to route to the global error handler Fixes</Description>
 <CreatedDate>09/06/2018</CreatedDate>
 <ClosedDate>09/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6036</PullRequestID>
 <IssueID>6025</IssueID>
 <Title>error handlinge ception swallowed after explicit dispose</Title>
 <Description>Library verision The following code will silently swallow thrown e ception without signalling to R Plugins The same applies to BehaviourSubject Processor but not SingleSubject or Observable just range etc Though sections about error handling are almost equal in PublishSubject and SingleSubject The reason seems to be located in Lambda Observer which doesnt signal on Error if is disposed already Is it e pected behaviour</Description>
 <CreatedDate>28/05/2018</CreatedDate>
 <ClosedDate>09/06/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6029</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 UpgradetoGradle4 3 1addTakeUntilPerf</Title>
 <Description>The JMH pluginhas some shortcomings that prevent the execution of unit tests on Window sand on some very restricted Linu es Versionhas been fi ed in this regard but it also requires Gradle Unfortunately there are no newer versions to the JMH plugin so this is likely as far as we can go with versions Ive also added a new benchmark to measure the overhead in take Until Here are the results Windows Java u JMH Benchmark Mode CntScore Error Units Take Until Perf flowable thrptopss Take Until Perf flowable items thrptopss Take Until Perf observable thrptopss Take Until Perf observable items thrptopss The observable here uses an older algorithms structure and is generally relaying half the items under the same time amonut than the flowable version PRcan then be evaluated with this benchmark <Description>
 <CreatedDate>30/05/2018</CreatedDate>
 <ClosedDate>30/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Build</PullRequestLabel>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6029</PullRequestID>
 <IssueID>6028</IssueID>
 <Title>Improve Observable take Until</Title>
 <Description>This PR upgrades the Observable take Until to a newer algorithm the Flowable version is uptodate Some unit test remnants from the v1 era were upgraded too as the new algorithm no longer disposes the source or other if they terminate on their own the Reactive Streams specification doesnt allow that anyway </Description>
 <CreatedDate>29/05/2018</CreatedDate>
 <ClosedDate>30/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6026</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Fix Flowable blockingS ubscribe is unbounded and can lead to</Title>
 <Description>Create and bound new blocking Subscribe overloads to bufferSizeCreate new overloads with bufferSizeCreate a bounded ConsumerCreate a Bounded Subsciber Close </Description>
 <CreatedDate>29/05/2018</CreatedDate>
 <ClosedDate>14/06/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6026</PullRequestID>
 <IssueID>5988</IssueID>
 <Title>2 Flowable blockingSubscribe lambdas is unbounded and can lead to OOME</Title>
 <Description>I cant remember why but Flowable blockingSubscribe Consumer uses unbounded requests which can lead to Out Of Memory Error in both synchronous and asynchronous scenarios The problem was raised in this Stack Overflow question and apart from the obvious solutions having such unbounded operator over an asynchronous boundary can be a problem regardless Possible resolutions Behavior change bound it to buffer Size in andor Introduce overload s with prefetch but leave the e isting ones unbounded Alternatively this could be deferred untilwithout worrying of the behavior change <Description><CreatedDate>30/04/2018</CreatedDate>
 <ClosedDate>14/06/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>PR welcome</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6024</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Dedicated Single Maybe flat Map Publisher Observable and Then Observable Publisher implementations</Title>
 <Description>This PR implements the following operators directly instead of conversions between base types Single flat Map Observable Maybe flat Map Observable Maybe flat Map Publisher Completable and Then Observable Completable and Then Publisher The Single flat Map Publisher was reimplemented in already </Description>
 <CreatedDate>27/05/2018</CreatedDate>
 <ClosedDate>27/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6024</PullRequestID>
 <IssueID>6021</IssueID>
 <Title>Single flat Map Publisher full implementation</Title>
 <Description>See discussion in Resolves</Description>
 <CreatedDate>26/05/2018</CreatedDate>
 <ClosedDate>27/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
<Label>Performance</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6021</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>2 Single flat Map Publisher full implementation</Title>
 <Description>See discussion in Resolves</Description>
 <CreatedDate>26/05/2018</CreatedDate>
 <ClosedDate>27/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6021</PullRequestID>
 <IssueID>6015</IssueID>
 <Title>Single flat Map Publisher full implementation</Title>
 <Description>I noticed Single flat Map Publisher is implemented as to Flowable flat Map Publisher which subjects the one flowable to batched requests Id like to have requests go straight through to the one flowable Can I contribute this operator? The operator at the moment is at without fusion I can add more tests fusion transitive as per do On Each and follow the projectss naming and visibility conventions </Description>
 <CreatedDate>23/05/2018</CreatedDate>
 <ClosedDate>27/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>PR welcome</Label>
<Label>Performance</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6021</PullRequestID>
 <IssueID>6015</IssueID>
 <Title>Single flat Map Publisher full implementation</Title>
 <Description>I noticed Single flat Map Publisher is implemented as to Flowable flat Map Publisher which subjects the one flowable to batched requests Id like to have requests go straight through to the one flowable Can I contribute this operator? The operator at the moment is at without fusion I can add more tests fusion transitive as per doOnEach and follow the projectss naming and visibility conventions </Description>
 <CreatedDate>23/05/2018</CreatedDate>
 <ClosedDate>27/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>PR welcome</Label>
<Label>Performance</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6019</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Single take Until Maybe take Until dispose behavior</Title>
 <Description>Fithe dispose behavior of the Single take Until and Maybe take Until operators Tests were also added to the other take Until variants for Completable it is delegated to amb Fixes</Description>
 <CreatedDate>25/05/2018</CreatedDate>
 <ClosedDate>25/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6019</PullRequestID>
 <IssueID>6018</IssueID>
 <Title>Single take Until does not dispose subscription to other upon disposal</Title>
 <Description>Using Single take Until does not dispose the subscription it makes to other when the main subscription is disposed RxJava Version Sample
 </Description>
 <CreatedDate>24/05/2018</CreatedDate>
 <ClosedDate>25/05/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6014</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix prevent null checks on primitives</Title>
 <Description>This PR removes the accidental null checks on primitives in two Observable methods and adds a trap method to Object Helper to both highlight and fail the tests in case the null checks are still attempted The method is marked as deprecated so it will also show up in Eclipses problems window Replaces Resolves </Description>
 <CreatedDate>23/05/2018</CreatedDate>
 <ClosedDate>23/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6014</PullRequestID>
 <IssueID>6012</IssueID>
 <Title>Stops Integer bo ing via null checks in Observable concatEager</Title>
 <Description>Replaces with verifyPositive as in other similar methods This seems to be a trivial change and makes this more consistent with other areas of the code Let me know if it needs its own issue or any specific tests Given the methods only accept primitive ints and passing a null Integer would throw a runtime e ception Im not sure theres anything needed outside of the already present testing </Description>
 <CreatedDate>22/05/2018</CreatedDate>
 <ClosedDate>23/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6005</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Java doc space cleanup</Title>
 <Description>This PR adds a gradle task to replace the excessive whitespaces generated into the Javadocs between method arguments and after method argument annotations This task should run before the javadoc gets packaged up for maven and before it gets pushed back to the ghpagesThis was created as a repo branch so that the snapshot pushback is triggered see the comparison links below Resolves Comparison Multiple parameters before combine Latest combine Latest io reactive functions Functionorg reactive streams Publisher Multiple parameters after combineLatest snapshot combine Latest io reactive functions Function org reactive streams Publisher Newline after parameter annotation before as as io reactive Flowable Converter Newline after parameter annotation after as snapshot asio reactive Flowable Converter </Description>
 <CreatedDate>09/05/2018</CreatedDate>
 <ClosedDate>09/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6005</PullRequestID>
 <IssueID>6004</IssueID>
 <Title>Odd Java Doc formatting</Title>
 <Code> </Code>
 <Description>Since we switched to Java 8 compilation the generated JavaDocs often lists method arguments misaligned for example image Looks like the whole section is put into &lt;pre&gt; so those e tra spaces break the layout I wonder if it would be possible to avoid those </Description>
 <CreatedDate>09/05/2018</CreatedDate>
 <ClosedDate>09/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>6002</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Multicast Processor</Title>
 <Description>This PR adds the Multicast Processor from the e tensions project tensions multicast processor to be a standard processor option This type of processor fills the gap of having a backpressure coordinating processor type as Publish Processor doesnt coordinate backpressure on its own and Flowable publish often cant be used because the upstream may not yet ex ist when the dowstream consumers are setup Multicast Processor Resolves </Description>
<code>MulticastProcessor&lt;Integer&gt; mp2;</code>
 <CreatedDate>09/05/2018</CreatedDate>
 <ClosedDate>17/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>6002</PullRequestID>
 <IssueID>5999</IssueID>
 <Title>Add a processor with backpressure</Title>
 <Description>Im working on a RxJava 2 integration with Apache Camel and Ive found difficult to find a processor supporting backpressure All processors in e cept Serialized Processor that has a special purpose do the following call during onSubscribe So if we put any of those processor between a publisher and a subscriber theres no way to slow down the publisher in case the subscriber is slow We need a processor because our API e pect that publishers and subscribers connect to the library in independent moments First the publisher then the subscriber s or the opposite both scenarios are allowed So weve used with other implementations a backpressureaware "connector" in the middle the connector is subscribed to the publisher when the publisher is available and the subscriber subscribe to the connector when the subscriber is available When both are connected the flow starts I dont know if there there is a way to create such a backpressureaware connector in RxJava but doesnt seem so </Description>  <CreatedDate>07/05/2018</CreatedDate>
 <ClosedDate>17/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5991</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix switch Maptoindicateboundaryfusion</Title>
 <Description>Fix Flowable switch Map and Observable switchMap to request for boundary fusion in order to prevent a thread confined but otherwise fusion capable subsequence from running on the unintended thread Fixes</Description>
 <CreatedDate>02/05/2018</CreatedDate>
 <ClosedDate>04/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5991</PullRequestID>
 <IssueID>5990</IssueID>
 <Title>Drain applies mappers without scheduling </Title>
 <Description>Here is the test case Ive created This hits the assertion error as Switch Map Observer poll s the inner query inside its drain method running the poll method on Map Observer which ends up running on the thread the switchmap was subscribed to on i think I dont think the interop part is necessary to reproduce this bug but was the consistent way I was able to get the drain method to poll the inner query as fromCallable emits a completion after the relay has emitted but before the mapper has received the event </Description>
 <CreatedDate>02/05/2018</CreatedDate>
 <ClosedDate>04/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5986</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add ref Count with count disconnect timeout</Title>
 <Description>This PR e poses the additional refCount operation modes from Connect only when the specified number of Subscriber sObserver s have subscribed Disconnect when the given amount of time elapsed since the very last Subscriber Observer cancelled disposed  The combination of both In addition the original ref Count received e tra JavaDocs details </Description>
 <CreatedDate>30/04/2018</CreatedDate>
 <ClosedDate>09/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5986</PullRequestID>
 <IssueID>5975</IssueID>
 <Title>Fix ref Count connect subscribe cancel deadlock</Title>
 <Description>This PR fi es a deadlock issue with the refCount operator when a subscription leads to a blocking execution while the lock is being held preventing other subscription or cancellation from executing on other threads The bug was discovered as the cause of a reported hang on the Google groups The code has been developed in the e tensions project where the operator has more features The overloads supporting these features can be added in a separate enhancement PR </Description>
 <CreatedDate>28/04/2018</CreatedDate>
 <ClosedDate>29/04/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5979</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add throttle Latest operator</Title>
 <Description>This PR adds the throttle Latest operator to Observable and Flowable also known as conflate it is a combination of throttle First and sample where by frequent items are sampled but the first item outside the sampling window will be emitted immediately throttle Latest throttle Latest Resolves Replaces </Description>
 <CreatedDate>29/04/2018</CreatedDate>
 <ClosedDate>17/05/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5979</PullRequestID>
 <IssueID>4856</IssueID>
 <Title>Conflate Operator</Title>
 <Description>RxJava should have conflate operator I see we have sample debounce etc but actually they are not equivalent to conflate Conflate operator should behave as Sample if updates are faster than the given interval But if updates stops and new update comes after a long period it should push immediately Instead of waiting for sampling period 
</Description>
 <CreatedDate>16/11/2016</CreatedDate>
 <ClosedDate>17/05/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5979</PullRequestID>
 <IssueID>4856</IssueID>
 <Title>Conflate Operator</Title>
 <Description>RxJava should have conflate operator I see we have sample debounce etc but actually they are not equivalent to conflate Conflate operator should behave as Sample if updates are faster than the given interval But if updates stops and new update comes after a long period it should push immediately Instead of waiting for sampling period 
</Description>
 <CreatedDate>16/11/2016</CreatedDate>
 <ClosedDate>17/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5979</PullRequestID>
 <IssueID>5968</IssueID>
 <Title>Adding Flowable throttle And Sample Conflate operator</Title>
 <Description>This pull request is to add Flowable throttleAndSample operator as discussed in</Description>
 <CreatedDate>22/04/2018</CreatedDate>
 <ClosedDate>09/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
<Label>FeatureRequest</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5972</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Observable concat Map Single dropping up stream items</Title>
 <Description>The internal queue of Observable concat Map Single was incorrectly the bounded one from its Flowable counterpart causing it to drop upstream items if the current Single was delayed The right queue for Observable s is the SpscLinkedArrayQueue Added unit tests to both concatMapSingle and concatMapMaybe to verify the correct behavior Fixes </Description>
 <CreatedDate>24/04/2018</CreatedDate>
 <ClosedDate>24/04/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5972</PullRequestID>
 <IssueID>5971</IssueID>
 <Title>concatMapSingle ignores some onNe t events</Title>
 <Code>
public void test {
 TestScheduler testScheduler = new TestScheduler ;

 final Single&lt;List&lt;Integer&gt;&gt; first;
 final Single&lt;List&lt;Integer&gt;&gt; second;
 final Single&lt;List&lt;Integer&gt;&gt; third ;
 final Single&lt;List&lt;Integer&gt;&gt; fourth ;
 TestObserver&lt;List&lt;Integer&gt;&gt; testObserver;
}
 </Code>
 <Description>Version used I have a collection of interfaces They all define a method fetching a collection of items Single List Integer fetch Items Some of them perform local computations others a network call When concatening using concatMapSinglesome of the singles are not subscribed at all Here is a test I do think should pass A network call is faked here using a timer If the timer is replaced with Single just instead the test is passing It is my first issue on this repo feel free to edit my PR if I am not respecting the contribution guidelines </Description>
 <CreatedDate>23/04/2018</CreatedDate>
 <ClosedDate>24/04/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5948</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>RomanWuattier</FixedByID>
 <Title>Fix Observable java doc</Title>
 <Description> Replace do On Cancel by doOnDispose in Observable javadoc Thank you for contributing to RxJava Before pressing the Create Pull Request button please consider the following points  Please give a description about what and why you are contributing even if its trivial Replace do On Cancel by doOnDispose in Observable javadoc Please include the issue list number s or other PR numbers in the description if you are contributing in response to those  Please include a reasonable set of unit tests if you contribute new code or change an e isting one If you contribute an operator if applicable please make sure you have tests for working with an emptyjustrange of values as well as an error source with and/or without backpressure and see if unsubscription cancellation propagates correctly Javadoc only</Description>
 <CreatedDate>03/04/2018</CreatedDate>
 <ClosedDate>03/04/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5948</PullRequestID>
 <IssueID>5944</IssueID>
 <Title>Canceling an Observable in RxJava 2 </Title>
 <Description>Observable from Futures javadoc says Unlike cancelling the Observable wont cancel the future If necessary one can use composition to achieve the cancellation effect future Observable Source doOnCancel future cancel true Flowable has this method and it works as e pected like this But Observable seems to lack doOnCancel method doesnt it Tested RxJavas version is</Description>
 <CreatedDate>01/04/2018</CreatedDate>
 <ClosedDate>15/04/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5947</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>fix group By cancellation with evicting map factory</Title>
 <Description>Fixes When the outer stream is cancelled there may be evicted groups present in the queue to be completed Ive added code to complete the evicted groups in the cancel method as suggested by akarnokd To protect against a race condition where the EvictionAction is called just after the evicted groups are completed in cancel Ive added a cancelled check to EvictionAction However I am concerned about a race that Ill place in the comments on the code below </Description>
 <CreatedDate>03/04/2018</CreatedDate>
 <ClosedDate>29/05/2018</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5947</PullRequestID>
 <IssueID>5933</IssueID>
 <Title>group By with evicting mapseeing inconsistent behavior when eviction occurs</Title>
 <Code>
 private static class TestTicker e tends Ticker {
 long tick = 0;
 public long read {
return tick;
 }
 }
 </Code>
 <Description>I am using version Im seeing what I believe to be a bug in the group By operator when configured to use an evicting map Here is a test that demonstrates what Im seeing As you can see from this when a group eviction occurs and the root subscription is canceled the cancel dose not propagate beyond the groupBy it does when there is no eviction I think the reason for this is that after the eviction processing line  of FlowableGroupBy the groupCount is  when I believe it should be  This leads the groupBy to conclude that there are  active groups when the cancel occurs when in fact there is only one This doesnt happen when there is no eviction you can see this by commenting out the line that updates "tick" </Description>
 <CreatedDate>24/03/2018</CreatedDate>
 <ClosedDate>29/05/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5935</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix take to route late errors to RxJavaHooks</Title>
 <Description>If there is a late e ception after take has unsubscribed from the upstream this e ception was ignored by the operator This fimakes sure such late e ceptions are routed to the RxJavaHooks onError handler just like does Fixes</Description>
 <CreatedDate>26/03/2018</CreatedDate>
 <ClosedDate>26/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5935</PullRequestID>
 <IssueID>5934</IssueID>
 <Title>Operator Take seem to swallow Exceptions</Title>
 <Code>
 System out println "going to throw";
 throw new NullPointerException "bla";
 </Code>
 <Description>We have a Observable that is transformed into a Single Some unrelated changes caused a E ception in the onSuccess Action of the Subscriber This e ception seems to get lost It neither gets propagated to the onError Action nor to the RxJavaHooks setOnError Action Sample that reproduces the problem This is what I found out while debugging Exception is caught here st is in this case the Operator Take it is already completed So the Throwable is just ignored Could be related the same as</Description>
 <CreatedDate>26/03/2018</CreatedDate>
 <ClosedDate>31/03/2018</ClosedDate>
 <Labels>
<Label>1 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5928</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix concat Map Single concat Map May be dispose cleanup crash</Title>
 <Description>This PR fi es the accidental logical mistake in the cancel dispose logic of the new concat Map Single and concat Map Maybe operators of both Flowable and Observable where the internal queue cleanup should happen in a serialized fashion only which is the state when the work in progress counter changes from to ensured by a check Fixes</Description>
 <CreatedDate>23/03/2018</CreatedDate>
 <ClosedDate>23/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5928</PullRequestID>
 <IssueID>5927</IssueID>
 <Title>NPE in Spsc Linked Array Queue Element</Title>
 <Code>
 </Code>
<stacktrace>
java lang NullPointerE ception
 at io reactive internal queue SpscLinkedArrayQueue lvElement SpscLinkedArrayQueue java 249 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll SpscLinkedArrayQueue java 154 
 at io reactive internal queue SpscLinkedArrayQueue poll SpscLinkedArrayQueue java 144 
 at io reactive internal queue SpscLinkedArrayQueue clear SpscLinkedArrayQueue java 184 
 at io reactive internal operators mi ed ObservableConcatMapMaybe$ConcatMapMaybeMainObserver dispose ObservableConcatMapMaybe java 152 
 at io reactive internal observers BasicFuseableObserver dispose BasicFuseableObserver java 152 
 at io reactive internal observers BasicFuseableObserver dispose BasicFuseableObserver java 152 
 at io reactive internal operators observable ObservableTake$TakeObserver dispose ObservableTake java 90 
 at io reactive internal disposables DisposableHelper dispose DisposableHelper java 125 
 at io reactive internal observers LambdaObserver dispose LambdaObserver java 100 
 at java util HashMap$Values forEach HashMap java 981 

java lang NullPointerE ception
 at io reactive internal queue SpscLinkedArrayQueue lvElement SpscLinkedArrayQueue java 249 
 at io reactive internal queue SpscLinkedArrayQueue newBufferPoll SpscLinkedArrayQueue java 154 
 at io reactive internal queue SpscLinkedArrayQueue poll SpscLinkedArrayQueue java 144 
 at io reactive internal queue SpscLinkedArrayQueue clear SpscLinkedArrayQueue java 184 
 at io reactive internal operators mi ed ObservableConcatMapMaybe$ConcatMapMaybeMainObserver drain ObservableConcatMapMaybe java 200 
 at io reactive internal operators mi ed ObservableConcatMapMaybe$ConcatMapMaybeMainObserver innerSuccess ObservableConcatMapMaybe java 165 
 at io reactive internal operators mi ed ObservableConcatMapMaybe$ConcatMapMaybeMainObserver$ConcatMapMaybeObserver onSuccess ObservableConcatMapMaybe java 290 
 at io reactive internal operators single SingleFlatMapMaybe$FlatMapMaybeObserver onSuccess SingleFlatMapMaybe java 117 
 at io reactive internal operators maybe MaybeJust subscribeActual MaybeJust java 36 
 at io reactive Maybe subscribe Maybe java 4065 
</stacktrace>
 <Description>Ive seen already a couple of those after upgrading Unfortunately I cannot give you any reproduction as I have zero idea where it might come from but here are a couple of stacktraces This didnt happen on or any of the previous versions Please tell me if I can help more </Description>
 <CreatedDate>23/03/2018</CreatedDate>
 <ClosedDate>23/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5924</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 UpdateSingle flatMapPublishermarble</Title>
 <Description>Renamed the operator in the bo For flat Map Publisher flat Map Publisher</Description>
 <CreatedDate>21/03/2018</CreatedDate>
 <ClosedDate>21/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5924</PullRequestID>
 <IssueID>5788</IssueID>
 <Title>Single incorrect or missing images tracking issue </Title>
 <Description>amb missing diagram ambArray missing diagram concat arg missing diagram concat add rd and th source indicate back pressure concat Array missing diagram concat Array Eager missing diagram concat Eager missing diagram create missing diagram defer missing diagram error Callable missing diagram error Throwable indicate error in the bo from Callable missing diagram from Publisher missing diagram from Observable missing diagram merge missing diagram merge Single Source Single Source indicate main element is a Single Source merge source indicate backpressure merge Delay Error Iterable Publisher missing diagrams wrong diagrams never missing diagram timer missing diagram equals missing diagram unsafeCreate missing diagram using missing diagram wrap missing diagram ambWith missing diagram as missing diagram hide missing diagram compose missing diagram cache missing diagram cast missing diagram delay missing diagram delay Subscription missing diagram dematerialize missing diagram do After Success missing diagram do After Terminate indicate error case do Finally missing diagram do On Subscibe missing diagram do On Success missing diagram do On Event missing diagram do On Error missing diagram do On Dispose missing diagram filter one source item indicate both true and false outcomes flat Map Publisher operator name blocking Get missing diagram lift missing diagram contains missing diagram merge With indicate backpressure on Error Return indicate item is the result of a function call with the original error on Error Return Item use the previous onErrorReturn diagram change name in bo on Error ResumeNe t diagram should have one item and no complete marker on Error Resume With operator name on Terminate Detach missing diagram repeat missing diagram repeat When missing diagram repeat Until missing diagram retry missing diagram retry When missing diagram subscribe missing diagram subscribe With missing diagram? take Until fiitem count in main and other sources indicate all other signal types timeout missing diagram to missing diagram to Completable diagram is stretched to Flowable operator name in boindicate backpressure to Future indicate Future remove the blocking text to Maybe operator name in boindicate both outcomes with proper signal types unsubscribeOn missing diagram test missing diagram
</Description>
 <CreatedDate>05/01/2018</CreatedDate>
 <ClosedDate>11/10/2019</ClosedDate>
 <Labels>
<Label>3x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5923</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Java Doc warnings of buffer Publisher Callable</Title>
 <Description>Text is not allowed between dl and its child tags Fixes 5916 </Description>
 <CreatedDate>19/03/2018</CreatedDate>
 <ClosedDate>19/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5923</PullRequestID>
 <IssueID>5916</IssueID>
 <Title>2 Javadoc syntaerror</Title>
 <Code> </Code>
 <Description> </Description>
 <CreatedDate>15/03/2018</CreatedDate>
 <ClosedDate>19/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5918</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Improve the scalar source performance of Observable concats witch Map</Title>
 <Description>This PR adds scalar source optimizations to Observable operatorsconcat Map Completableconcat Map Singleconcat Map Maybeswitch Map Completableswitch Map Singleswitch Map MaybeBenchmark K Windows Java u The baseline is taken fromThe target is to be faster than using the plain concatMap or switchMap with a toObservable conversion The apparent shortcomings of longer concatMapMaybe and concatMapSingle will be addressed in a subsequent PR </Description>
 <CreatedDate>15/03/2018</CreatedDate>
 <ClosedDate>15/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5918</PullRequestID>
 <IssueID>5914</IssueID>
 <Title>Benchmark Map operators</Title>
 <Description>This PR adds JMH benchmarks to measure operators mapping onto other types such as flat Map Completable concat Map Single etc In addition two new benchmarks were added to measure the flat Map Iterable performance in additional situations Baseline results i K WindowsJava u JMH Compare GUI workspace filemapz_ws ml The first diagram compares the dedicated plain same inner type as the outer type and conversionbased flows image The switch Map based Observable operators look like they could use some optimizations Overall count is not optimized with the dedicated versions From the Observable s perspective image Looks like the concat Map operators could use some optimizations The flat Map Iterable measures are as follows image The Flowable version seem to be considerably slower probably not explainable due to backpressure overhead </Description>
 <CreatedDate>14/03/2018</CreatedDate>
 <ClosedDate>14/03/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Performance</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5917</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>fix and deprecate evicting group By and add new overload</Title>
 <Description>See There is a problem with the existing Observable group By overload with an evicting map factory where depending on the eviction behaviour of the supplied map factory groups may not be completed and may leak memory The problem e tends to the method signature in that the eviction action should report the evicted GroupedObservable not the corresponding key This PR fixes the existing method at the e pense of doubling up the internal map groups into groupsCopy so that we can always successfully lookup the evicted group from the groupsCopy map Evictions from groups are mirrored in groupsCopy after the lookupdeprecates the problematic overload indicating that it uses more memory than the preferred new overload adds a new method groupBy that has the corrected signature and offers bufferSize and delayError parameters for a bit more fle ibility and to differentiate the erased signature from the deprecated methodadds tests that were ported from the tests</Description>
 <CreatedDate>15/03/2018</CreatedDate>
 <ClosedDate>19/03/2018</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5917</PullRequestID>
 <IssueID>5868</IssueID>
 <Title>group By with evicting map factory fix</Title>
 <Code>
 &lt;K R&gt; Observable&lt;GroupedObservable&lt;K R&gt;&gt; groupBy 
 Func1&lt;? super T ? e tends K&gt; keySelector
 Func1&lt;? super T ? e tends R&gt; elementSelector 
 Func1&lt;Action1&lt;K&gt; Map&lt;K Object&gt;&gt; evictingMapFactory 

 &lt;K R&gt; Observable&lt;GroupedObservable&lt;K R&gt;&gt; groupBy 
 Func1&lt;? super T ? e tends K&gt; keySelector
 Func1&lt;? super T ? e tends R&gt; elementSelector 
 Func1&lt;Action1&lt;Object&gt; Map&lt;K Object&gt;&gt; evictingMapFactory 
 </Code>
 <Description>Im preparing a PR to fix bug with the operator group By where an evicting map factory is specified The problem with the operator e tends as far as the method signature This is what it is now and the javadoc will be changed to indicate that the value from the map should be passed to the Action1 and not the key This is a breaking change How do we want this to happen Ive got a few optionsreplace the method breaking change move toreplace the method breaking change move to that will be confusingdeprecate the existing method and add group Bydeprecate the existing method and throw a Dont Call Me Exception and add group Byremove the e isting method and add group By Any ideas preferences Im ready to go with the PR but just need to decide the change in the API </Description>
 <CreatedDate>27/02/2018</CreatedDate>
 <ClosedDate>19/03/2018</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5906</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>vanniktech</FixedByID>
 <Title> Add public constructor for Test Scheduler that takes the time</Title>
 <Description> adds a time constructor to Test Scheduler should I make it e perimental or will it just be stable Fixes </Description>
 <CreatedDate>09/03/2018</CreatedDate>
 <ClosedDate>09/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5906</PullRequestID>
 <IssueID>5901</IssueID>
 <Title>Pulib constructor for TestScheduler that already takes the time</Title>
 <Description>Id like to have the ability to have an instantiated Test Scheduler which already has a time Internally itd just delegate to advance Time To and the constructor would also take the same parameters as that method What are your thoughts</Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>09/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>PR welcome</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5904</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Flowable single Or Error to Flowable not signalling No Such ElementException</Title>
 <Description>When a singleOrError is followed by toFlowablethe assembly process switches the Flowable Single operator into a Flowable Flowable operator implementing the single Or Error behavior saving the backandforth type conversion The backing implementation was shared with singleElement and as such did not properly handle the orError case for an empty source The PR fi es the lack of NoSuchElementE ception in this case 
Fixes The Observable variant doesnt have such optimization but the test has been converted to make sure Observable is verified for this aspect in case the optimization is implemented with it in the future </Description>
 <CreatedDate>08/03/2018</CreatedDate>
 <ClosedDate>09/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5904</PullRequestID>
 <IssueID>5903</IssueID>
 <Title>Flowable single Or Error does not signal an e ception if followed by flat Map Publisher</Title>
 <Description>The following code demonstrates the e pected behavior of Flowable single Or Error as I understand it This is with RxJava and Reactive Streams</Description>
 <CreatedDate>08/03/2018</CreatedDate>
 <ClosedDate>09/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5898</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix retention in theother replay components</Title>
 <Description>This is a followup PR to in order to avoid item retention in the head node For the Replay Processor the cleanup can be triggered with cleanup Buffer For the replay operators such trigger is not possible However the terminal events will perform the cleanup internally at least </Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5898</PullRequestID>
 <IssueID>5892</IssueID>
 <Title>Fith extra retention problem in Replay Subject</Title>
 <Description>In the bounded buffers of Replay Subject the head reference may retain one extra item when the trimming happens Nulling out this reference is not possible at this point because old consumers may be still walking through the underlying linked list of nodes However replacing a head with the same ne t pointer which is always not null if value is not null but no value will eventually let the value get GCd This cleanup doesnt happen on every onNe t because it doubles the node allocation and thus the overhead This PR modifies the code so that terminal events do perform this head swapping and introduces the Replay Subject cleanup Buffer method to allow the user to perform the head swapping while the Replay Subject is not yet terminated and the cleanup is needed If this type of change is accepted the ReplayProcessor can also be refitted For the replay operators the terminal cleanup can be implemented but the on demand cleanup cant as there is no API surface for its internal buffer available </Description>
 <CreatedDate>06/03/2018</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5897</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>clarify dematerialize and terminal items signals</Title>
 <Description>Specify in both Flowable and Observable that a terminal notification item or a regular terminal signal ends the flow Fixes</Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5897</PullRequestID>
 <IssueID>5261</IssueID>
 <Title>dematerialize and completion</Title>
 <Description>I do not e pect Flowable just Notification create On Next dematerialize to complete but it does Do you think this is a bug too? If so I can submit a PR 
</Description>
 <CreatedDate>03/04/2017</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>PR welcome</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5895</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>adamsp</FixedByID>
 <Title>Fix buffer documentation to correctly describe on Error behaviour</Title>
 <Description>Fixes I just copied the sentence from the fixed docs in  and updated to use Observable Source Publisher naming</Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5895</PullRequestID>
 <IssueID>5894</IssueID>
 <Title>buffer documentation incorrect for on Error behaviour</Title>
 <Description>The documentation for most buffer operators reads as follows When the source Observable Source completes or encounters an error the resulting Observable Source emits the current buffer and propagates the notification from the source ObservableSource This is incorrect none of the buffer operators emit their buffer before propagating an error Note that this documentation was fixed in in this is effectively a duplicate of issue</Description>
 <CreatedDate>07/03/2018</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5888</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix Flowable window Publisher Callable upstreamhandling</Title>
 <Description>This PR fixes the upstream handling in Flowable window Publisher and Flowable window Callable Publisher operators to make sure if both the main output and the inner windows have been cancelled the upstream is also cancelled Related In addition the Jacoco code coverage has been updated to mainly due to the automatic filtering of difficult to impossible code paths</Description>
 <CreatedDate>04/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5888</PullRequestID>
 <IssueID>5887</IssueID>
 <Title>Fix window Observable Callable upstream handling</Title>
 <Description>This PR fixes the upstream handling in Observable window Observable Source and Observable window Callable Observable Source operators to make sure if both the main output and the inner windows have been disposed the upstream is also disposed Fixes Remark There are a couple of w null checks showing up as partially covered In theory with the right interleaving w can become null but unfortunately the usual Test Helper race testing is unlikely to trigger that case There would be a higher chance with  threads one disposing one completing the main and one completing the inner window but the current CI is effectively   cores/threads that tend to not produce a thorough interleaving </Description>
 <CreatedDate>04/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5888</PullRequestID>
 <IssueID>5881</IssueID>
 <Title>Incorrect upstream management in window Observable and window Callable </Title>
 <Description>While working on coverage improvements Ive noticed Flowable window Publisher and Flowable window Callable Publisher plus their Observable counterpart manage the upstream incorrectly as they dont cancel it when both the main output and the current window have been cancelled </Description>
 <CreatedDate>03/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5887</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix window Observable Callable upstream handling</Title>
 <Description>This PR fixes the upstream handling in Observable window ObservableSource and Observable window Callable Observable Source operators to make sure if both the main output and the inner windows have been disposed the upstream is also disposed Fixes Remark There are a couple of w null checks showing up as partially covered In theory with the right interleaving w can become nullbut unfortunately the usual TestHelper race testing is unlikely to trigger that case There would be a higher chance with 3 threads one disposing one completing the main and one completing the inner window but the current CI is effectively 1 52 cores/threads that tend to not produce a thorough interleaving </Description>
 <CreatedDate>04/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5887</PullRequestID>
 <IssueID>5881</IssueID>
 <Title>Incorrect upstream management in window Observable and window Callable </Title>
 <Description>While working on coverage improvements Ive noticed Flowable window Publisher and Flowable window Callable Publisher plus their Observable counterpart manage the upstream incorrectly as they dont cancel it when both the main output and the current window have been cancelled </Description>
 <CreatedDate>03/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5886</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Upgrade the algorithm of Observable timeout time selector operators</Title>
 <Description>This PR improves the algorithms of the Observable timeout time and Observable timeout selector operators to match their Flowable counterparts implemented in In addition coverage of the Flowable counterparts have been improved by synchronizing the unit tests Note that they were the last users of Observer Full Arbiter and Full Arbiter Observer which are now removed Closes </Description>
 <CreatedDate>04/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5886</PullRequestID>
 <IssueID>5661</IssueID>
 <Title>improve Flowable timeout</Title>
 <Description>This PR improves the internal overhead of the Flowable timeout operator its timed and selector based versions to use the adapted indexed atomic state transition approach In addition there was a race condition and potential event loss in Test Scheduler peek could return null if the task was removed from the queue via disposing it between the isEmpty check and peek itself  In addition if the task was disposed between the peek and removethe remove could remove the new head of the queue which is no longer what peek saw and results in tasks being dropped </Description>
 <CreatedDate>11/10/2017</CreatedDate>
 <ClosedDate>13/10/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5886</PullRequestID>
 <IssueID>5882</IssueID>
 <Title>Update the algorithm Observable timeout time timeout selector </Title>
 <Description>Update the Observable timeout time and the Observable timeout selectors operators to the more modern atomic index tracking algorithm and get rid of Observer Full Arbiter and Full Arbiter Observer Their Flowable counterparts have been updated in</Description>
 <CreatedDate>03/03/2018</CreatedDate>
 <ClosedDate>04/03/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5875</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Observable switch Map and concat Map operators</Title>
 <Description>This PR ports the various switch Map and concat Map operators from and to Observable concat Map Completable replaced by the common implementation concat Map Completable Delay Errorconcat Map May beconcat Map May be Delay Errorconcat Map Singleconcat Map Single Delay Errorswitch Map Completableswitch Map Completable Delay Errorswitch Map May beswitch Map May be Delay Errorswitch Map Single dedicated implementationswitch Map Single Delay Error dedicated implementation This PR concludes the requested set of operators in Marbles will be updated/adjusted in a separate PR </Description>
 <CreatedDate>02/03/2018</CreatedDate>
 <ClosedDate>03/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5875</PullRequestID>
 <IssueID>5870</IssueID>
 <Title>Add Flowable switch Map Completable Delay Error operator</Title>
 <Description>This PR adds the Flowable switch Map Completable and Flowable switch Map Completable Delay Error operators as requested by The associated new marbles are switch Map Completable switch Map Complet able Delay Error </Description>
 <CreatedDate>28/02/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5875</PullRequestID>
 <IssueID>5871</IssueID>
 <Title>Add Flowable concat Map Completable Delay Error operator</Title>
 <Description>This PR adds the Flowable concat Map Completable and Flowable concat Map Completable Delay Error operators as requested by The marbles will be updated in a separate PR </Description>
 <CreatedDate>28/02/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5875</PullRequestID>
 <IssueID>5872</IssueID>
 <Title>Add Flowable concat Map Maybe Single Delay Erroroperators</Title>
 <Description>This PR adds operators that allow concatenating a mapped sequence of May be s or Single s with or without delaying their errors concat Map May be overload with prefetch concat Map May be Delay Error overloads with error mode and prefetch concat Map Single overload with prefetch concat Map Single Delay Error overloads with error mode and prefetch They are in the same PR as the Single variants implementation is practically the Maybe implementation minus the on Complete case Their marbles will be updated in a separate PR Originally requested in</Description>
 <CreatedDate>01/03/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5875</PullRequestID>
 <IssueID>5873</IssueID>
 <Title>Add Flowable switch Map May be Single Delay Error operators</Title>
 <Description>This PR adds Flowable operators that allow switching between a mapped sequence of Maybe s or Single s with or without delaying their errorsswitch Map Maybeswitch Map May be Delay Errorswitch Map Singleswitch Map Single Delay Error They are in the same PR as the Single variants implementation is practically the Maybe implementation minus the onComplete case Their marbles will be updated in a separate PR Originally requested in </Description>
 <CreatedDate>01/03/2018</CreatedDate>
 <ClosedDate>02/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5875</PullRequestID>
 <IssueID>4853</IssueID>
 <Title>switch Map Single and switch Map Completable</Title>
 <Description>Hey the addition of flat Map Singl flat Map Cos witch le made the usage of Single and Completable way nicer in RxJava Do you consider adding switch Map Single  switch Map Completable to RxJava as well Cheers</Description>
 <CreatedDate>15/11/2016</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5873</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Flowable switch Map May be Single Delay Error operators</Title>
 <Description>This PR adds Flowable operators that allow switching between a mapped sequence of Maybe s or Single s with or without delaying their errors switch Map Maybe switch Map Maybe Delay Errorswitch Map Singleswitch Map Single Delay Error They are in the same PR as the Single variants implementation is practically the Maybe implementation minus the onComplete case Their marbles will be updated in a separate PR Originally requested in </Description>
 <CreatedDate>01/03/2018</CreatedDate>
 <ClosedDate>02/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5873</PullRequestID>
 <IssueID>4853</IssueID>
 <Title>switch Map Single and switch Map Completable</Title>
 <Description>Hey the addition of flat Map Single flat Map Completable made the usage of Single and Completable way nicer in RxJava Do you consider adding switch Map Single switch Map Completable to RxJava 2 as well Cheers</Description>
 <CreatedDate>15/11/2016</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5872</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Flowable concat Map Maybe Single Delay Error operators</Title>
 <Description>This PR adds operators that allow concatenating a mapped sequence of Maybe s or Single s with or without delaying their errors concat Map May be overload with prefetchconcat Map May be Delay Error over loads with error mode and prefetchconcat Map Singleoverload with prefetchconcat Map Single Delay Error over loads with error mode and prefetch They are in the same PR as the Single variants implementation is practically the May be implementation minus the on Complete case Their marbles will be updated in a separate PR Originally requested in</Description>
 <CreatedDate>01/03/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5872</PullRequestID>
 <IssueID>4853</IssueID>
 <Title>switch Map Single and switch Map Completable</Title>
 <Description>Hey the addition of flat Map Single flat Map Completable made the usage of Single and Completable way nicer in RxJava Do you consider adding switch Map Single switch Map Completable to RxJava 2 as well Cheers<Description>
 <CreatedDate>15/11/2016</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5871</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Flowable concat Map Completable Delay Error operator</Title>
 <Description>This PR adds the Flowable concat Map Completable and Flowable concat Map Completable Delay Error operators as requested by The marbles will be updated in a separate PR </Description>
 <CreatedDate>28/02/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5871</PullRequestID>
 <IssueID>4853</IssueID>
 <Title>switch Map Single and switch Map Completable</Title>
 <Description>Hey the addition of flatMapSingleflatMapCompletable made the usage of Single and Completable way nicer in RxJava Do you consider adding switchMapSingleswitchMapCompletable to RxJava as well Cheers<Description>
 <CreatedDate>15/11/2016</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5870</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Add Flowable switch Map Completable Delay Error operator</Title>
 <Description>This PR adds the Flowable switch Map Completable and Flowable switch Map Completable Delay Error operators as requested by The associated new marbles are switch Map Completable switch Map Completable Delay Error </Description>
 <CreatedDate>28/02/2018</CreatedDate>
 <ClosedDate>01/03/2018</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5870</PullRequestID>
 <IssueID>4853</IssueID>
 <Title>switc hMapSingle and switchMapCompletable</Title>
 <Description>Hey the addition of flat Map Single flat Map Completable made the usage of Single and Completable way nicer in RxJava Do you consider adding switch Map Single switch Map Completable to RxJavaas well Cheers</Description>
 <CreatedDate>15/11/2016</CreatedDate>
 <ClosedDate>07/03/2018</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5449</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>ansman</FixedByID>
 <Title>Remove the Non Null annotation from Function</Title>
 <Description>As per per the discussion in</Description>
 <CreatedDate>27/06/2017</CreatedDate>
 <ClosedDate>28/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5449</PullRequestID>
 <IssueID>5447</IssueID>
 <Title>Remove NonNull annotation in Consumer method parameter</Title>
 <Description>This fixes</Description>
 <CreatedDate>27/06/2017</CreatedDate>
 <ClosedDate>27/06/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5447</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>ansman</FixedByID>
 <Title>Remove Non Null annotation in Consumer method parameter</Title>
 <Description>This fixes</Description>
 <CreatedDate>27/06/2017</CreatedDate>
 <ClosedDate>27/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5447</PullRequestID>
 <IssueID>5442</IssueID>
 <Title>onsumer contract is violated when using do On Event</Title>
 <Code></Code>
 <Description>The following code showcases the problem 
 </Description>
 <CreatedDate>26/06/2017</CreatedDate>
 <ClosedDate>27/06/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Kotlin</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5440</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>concat to report is Disposed consistently with termination</Title>
 <Description>This PR makes sure the Disposable of a concat operator reports true when the sequence terminates Reported in</Description>
 <CreatedDate>26/06/2017</CreatedDate>
 <ClosedDate>27/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Shortcoming</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5440</PullRequestID>
 <IssueID>5439</IssueID>
 <Title>Observable concat Observable Observable subscribed with an Observer has Disposable is Disposed false after completion</Title>
 <Description>Thanks for using RxJava but before you post an issue please consider the following points Please include the library version number including the minor and patch version in the issue text In addition if youd include the major version in the title such as that would be great If you think you found a bug please include a code sample that reproduces the problem Dumping a stacktrace is usually not enough for us </Description>
 <CreatedDate>25/06/2017</CreatedDate>
 <ClosedDate>05/07/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Shortcoming</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5427</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix buffer time ma Size duplicating buffers on time size race</Title>
 <Description>The PR fixes both the time ma Size bound buffer operators of Flowable and Observable The logic didnt properly mutually e clude the timer action and the on Net action resulting in probabilistic emission of the same buffer twice Reported in </Description>
 <CreatedDate>19/06/2017</CreatedDate>
 <ClosedDate>20/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5427</PullRequestID>
 <IssueID>5426</IssueID>
 <Title>buffer timespan unit count emits duplicated items</Title>
 <Code>
public class BufferTest {

 public void testBuffer {
 Observable range 0 10 
 map n &gt; {
 Thread sleep 100 ;
 return n;
}

 }
}

 </Code>
 <Description>The following code is expected to print something like but try to run it several times and you can see that sometimes it prints out where one of the bunches is duplicated </Description>  <CreatedDate>19/06/2017</CreatedDate>
 <ClosedDate>20/06/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5419</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 fi periodicschedulingwithnegativeperiodcausingIAE</Title>
 <Description>This PR adds unit tests to verify the Scheduler schedule Periodically Direct and Scheduler Worker schedule Periodically works with nonpositive period as required by the Javadoc The computation and single schedulers were not working properly and the underlying Scheduled ExecutorService crashed with IllegalArgumentE ception thus these are now fixed with custom handler for the period cases Related </Description>
 <CreatedDate>16/06/2017</CreatedDate>
 <ClosedDate>17/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5419</PullRequestID>
 <IssueID>5416</IssueID>
 <Title>schedule Periodically with nonpositive period</Title>
 <Description>Currently the Scheduler and Worker API allows for non positive periods on periodically scheduling but the underlying Scheduled Executor Service dont The javadoc doesnt specify any restrictions on period unlike initialDelay or delay where a nonpositive value is considered to be an execute without delay In theory the default periodic logic could handle the case by executing such periodic tasks without any delay but Im not certain the behavior is actually desired Related StackOverflow question So the two options I see are as follows throw IAE with nonpositive periods with the related operators and require the Scheduler Worker API to do the same allowperiod and introduce workarounds inside the Scheduler Worker implementations I prefer option as nobody seem to have encountered this specific issue before that would have rendered the code inoperable anyway due to a crash similar to the SO case </Description>
 <CreatedDate>14/06/2017</CreatedDate>
 <ClosedDate>19/06/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5413</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>Sroka</FixedByID>
 <Title>Add empty source clauses to javadocs of combine Latest operators</Title>
 <Description>accepting unspecified number of sources This commit resolves</Description>
 <CreatedDate>14/06/2017</CreatedDate>
 <ClosedDate>28/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5413</PullRequestID>
 <IssueID>5412</IssueID>
 <Title>combine Latest Iterable Publisher Function not emitting on empty iterable </Title>
 <Description>I am using RxJava and operator io reactive Flowable combine Latest java lang Iterable extends org reactive streams Publishe extends io reactive functions Function supe RxJava lang Object extends R but Ive seen this behavior in as well Overload of combine Latests and combine Latests Delay Error that takes Iterable of Publishers is not emitting any items and combiner function passed to it is not called when iterable is empty For this operator I would e pect it to scale linearly that is If I pass Iterable of size as a first argument I e pect an Array of sizeto be passed to combiner function </Description>
 <CreatedDate>14/06/2017</CreatedDate>
 <ClosedDate>28/06/2017</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5407</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>devisnik</FixedByID>
 <Title>Default Subscriber java doc sample fix</Title>
 <Description>The example in the javadoc of DefaultSubscriber is not compiling Default Subscriber is not a Disposable This PR updates the javadoc to provide a compiling example Fiis similar to for DefaultObserver </Description>
 <CreatedDate>11/06/2017</CreatedDate>
 <ClosedDate>11/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5407</PullRequestID>
 <IssueID>5405</IssueID>
 <Title>Default Observe RxJavadoc example fix</Title>
 <Description>The example in the javadoc of Default Observer is not compiling DefaultObserver is not a Disposable This PR updates the javadoc to provide a compiling example </Description>
 <CreatedDate>09/06/2017</CreatedDate>
 <ClosedDate>09/06/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5395</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>Coffee 2 Code NL</FixedByID>
 <Title>Update README md</Title>
 <Description>Added Gitter im chat for support As discussed in</Description>
 <CreatedDate>05/06/2017</CreatedDate>
 <ClosedDate>05/06/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Information</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5395</PullRequestID>
 <IssueID>5394</IssueID>
 <Title>Add Gitter im to README md under Communication</Title>
 <Description>Could you add to the Communication area in the Readme There are some people there but I think adding it to the readme might spark some activity </Description>
 <CreatedDate>05/06/2017</CreatedDate>
 <ClosedDate>05/06/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Information</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5318</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>apply API promotions for</Title>
 <Description>This PR applies the API promotions of Note that Single unsubscribe On remainded experimental and Observable from Emitter was removed Where the experimental version was available it was moved up as History experimental similar to how versioning/promotions happen Suggested review strategy verify Experimental and Beta annotations are removed from the method and from Javadoc verify since is present</Description>
 <CreatedDate>27/04/2017</CreatedDate>
 <ClosedDate>27/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1x</PullRequestLabel>
 <PullRequestLabel>API promotion</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5318</PullRequestID>
 <IssueID>5201</IssueID>
 <Title>API promotions</Title>
 <Description>Planned release date for May stPromote Experimental to stable exceptions Assembly Stack Trace Exceptionfunctions Cancellable internal observers Assertable Subscriber Observableinternal operators Flat Map Completableinternal operators Flat MapSingleinternal schedulers SchedulerWheninternal util Backpressure Drain Manageinternal util Blocking Utils the class and its single methodCompletable from EmitterCompletable testCompletable EmitterCompletable SubscribeEmitterSchedule whenSingle EmitterSingle from EmitterSingle merge ObservableSingle overloadsSingle merge Delay Error Observable Single overloadsSingle cacheSingle toSingle do On EachSingle do On SuccessSingle testobservers Assertable Subscribeobservers Async Completable Subscribeobservers Safe Completable Subscribeobservers Test Subscribe get Completionsobservers Test Subscribe await Value Countobservers Test Subscribe assert Values And Clearschedulers Schedulers resetplugins RxJava Completable Execution Hookplugins RxJava Hooksplugins RxJava Plugins resetplugins RxJava Plugins get Completable Execution Hookplugins RxJava Plugins register Completable ExecutionHookplugins RxJava Schedulers Hook create Computation Schedule overloadsplugins RxJava Schedulers Hook create Io Schedule overloadsplugins RxJava Schedulers Hook create New Thread Schedule overloadssubjects Unicast SubjectObservable create Action Emitter T Emitter Back pressure StrategyObservable unsafe CreateObservable toObservable zip Observable FuncNObservable flat Ma pCompletableoverloadsObservable flat Map SingleoverloadsObservable group By Func Func Func ActionK MapK ObjectObservable on Terminate DetachObservable rebatch RequestsObservable subscribe On Schedule booleanObservable sortedObservable sorted FuncObservable with Latest FromoverloadsObservable test overloadsPromote Beta to stableobservable Blocking Observable subscribe overloadsexceptions Composite Exception Throwableexceptions exceptions throw Or Report overloadsBack pressure OverflowSingle on Error Resume Next overloadsSingle to CompletableSingle do On ErrorSingle do On SubscribeSingle delay overloadsSingle defeSingle do On UnsubscribeSingle do After TerminateSingle flat Map CompletableSingle liftSingle to BlockingSingle using overloadsSingle delay Subscription Observableplugins RxJava Error Handle handle On Next Value Renderingplugins RxJava Error Handler endsingles Blocking SingleObservable to CompletableObservable concat Delay Error overloadsObservable merge Delay ErrorObservable switch On Next Delay ErrorObservable using Func Func Action booleanObservable concat Map Delay ErrorObservable delay Subscription ObservableObservable distinct Until Changed FuncObservable concat Eage overloadsObservable concat Map Eage overloadsObservable on Back pressure Buffelong Action Back pressure Overflow StrategyObservable switch Map Delay ErrorObservable to Sorted List intObservable to Sorted List Func intobservables Sync On Subscribe create Single State overloadsobservables Sync On Subscribe create Stateful overloadsobservables Sync On Subscribe create Stateless overloadsCompletablePromote Experimental to Betaobservable Async On Subscribe of its factory methodsObservable create Async On SubscribeLeave as is Single unsubscribe On since Remove Experimental Observable from Emitter</Description>
 <CreatedDate>20/03/2017</CreatedDate>
 <ClosedDate>27/04/2017</ClosedDate>
 <Labels>
<Label>1 </Label>
<Label>API promotion</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5307</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Apply promotions for</Title>
 <Description>This PR applies the promotions listed in Suggested review strategy Check if the Experimental annotation has been removed or turned into Beta  Check if the History matches the original value of the updated since</Description>
 <CreatedDate>21/04/2017</CreatedDate>
 <ClosedDate>21/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>API promotion</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5307</PullRequestID>
 <IssueID>5243</IssueID>
 <Title>API promotions</Title>
 <Description>Planned release date April  Experimental to Standard  Check Return Value since  Scheduler when since  Completable Subject since  Maybe Subject since  Single Subject since  Test Subscriber request More since  Completable  cache since  do Finally since  hide since  Flowable  do After Next since  do Finally since  sample with emit Last option since  Maybe  do After Success since  do Finally since  flat Map Single Element since  Observable  do After Next since  do Finally since  sample with emitLast option since  Single  do After Success since  do After Terminate since  do Finally since  Base Test Consumer  assert Never since over loads  assert No Timeout since  assert Time out since  await Count since overloads  clear Timeout since  is Time out since  Test Wait Strategy since  with Tag since  Rx Java Plugins  create Computation Scheduler since  create Io Scheduler since  create New Thread Scheduler since  create Single Scheduler since  get On Before Blocking since  isFailOnBlocking Scheduler since onBeforeBlocking since  set Fail On Blocking Scheduler since  set On Before Blocking since  Beta to Standard There are no components marked with Beta in the version additions  Experimental to Beta  Flowable Subscriber since  Flowable parallel since overloads  Flowable subscribe Flowable Subscriber since  On Error Not Implemented Exception since  Protocol Violation Exception since  Undeliverable Exception since  Parallel Flowable since  RxJava Plugins get On Parallel Assembly since  RxJava Plugins on Assembly Parallel Flowable since  RxJava Plugins set On Parallel Assembly since  Leave as is Observable switch Map Single since Experimental  Observable switch Map Single Delay Error since Experimental  Parallel Failure Handling since Experimental  Parallel Flowable doOnNext Consumer Parallel Failure Handling since Experimental  Parallel Flowable map Consumer Parallel Failure Handling since Experimental  Parallel Flowable filter Consumer Parallel Failure Handling sinceExperimental  Parallel Transformer since Experimental  Behavior Processor offer since Experimental  Publish Processor offer since Experimental  Unicast Processor create boolean since Experimental overloads of failfast mode  Unicast Subject create boolean since Experimental overloads of failfast mode  Single unsubscribe On Scheduler since Experimental  Remove  Flowable strict since deprecated in </Description>
 <CreatedDate>29/03/2017</CreatedDate>
 <ClosedDate>25/04/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>API promotion</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5302</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 addSingle unsubscribeOn</Title>
 <Description>This PR adds the Single unsubscribeOn operator 

Related 5300 </Description>
 <CreatedDate>20/04/2017</CreatedDate>
 <ClosedDate>20/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5302</PullRequestID>
 <IssueID>5300</IssueID>
 <Title>Single unsubscribe On missing</Title>
 <Description>Also in order to match naming convertions that operator should be named dispose On</Description>
 <CreatedDate>20/04/2017</CreatedDate>
 <ClosedDate>21/04/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5296</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>Mauin</FixedByID>
 <Title>ImprovedoOnDisposeJavaDoc</Title>
 <Description>Sorry for the earlier PR This addresses the JavaDoc issues discussed in Removes the Note in Observable doOnDispose which claims its action would be called on terminal events  Slightly adjusts the JavaDocs of the Maybe Single Completable variants Adds throws note to some Observable Single Maybe doOnDispose as it was present in the Completable variant </Description>
 <CreatedDate>19/04/2017</CreatedDate>
 <ClosedDate>19/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5296</PullRequestID>
 <IssueID>5283</IssueID>
 <Title>Subscription not disposed after onComplete with RxJava 2 </Title>
 <Description>Hello I am not sure this is an issue I would rather say this is a question I have noticed a different behavior between RxJava and RxJava When an observable is completed with RxJava subscriptions get unsubscribed Is it a wanted Behavior If so is this behavior documented somewhere Thanks a lot for your help </Description>
 <CreatedDate>13/04/2017</CreatedDate>
 <ClosedDate>14/04/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5277</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Single subscribe Bi Consumer consistent is Disposed</Title>
 <Description>Fixes the Single subscribe BiConsumer to report is Disposed when terminating Reported in</Description>
 <CreatedDate>10/04/2017</CreatedDate>
 <ClosedDate>10/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5277</PullRequestID>
 <IssueID>5276</IssueID>
 <Title>Singles Disposable is not disposing </Title>
 <Description>I noticed that </Description>
 <CreatedDate>10/04/2017</CreatedDate>
 <ClosedDate>10/04/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5258</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>mtiidla</FixedByID>
 <Title>Use Intell JID Efriendly assertion failure message</Title>
 <Description>The assert Item failure message pattern in Test Subscriber does not match any of the regepatterns defined by IntelliJ to show Click to see difference link before By changing the expected to be to expectedthe pattern is recognised by IntelliJ and the helpful link is presented after The original idea from was to use the expected but waspattern used in JUnit but it is not picked up on its own by IntelliJ The Assertion Error must e tend from JUnits Comparison Failure to get it recognised This however requires dependency on JUnit junit So in the end the fiis just a very simple change in the message </Description>
 <CreatedDate>02/04/2017</CreatedDate>
 <ClosedDate>02/04/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5258</PullRequestID>
 <IssueID>5249</IssueID>
 <Title>Use IDE friendly assertion failed statements</Title>
 <Description>Currently the assertItem prints by the following statements focus on expected to be However it does not match any of the IntelliJ assertion regepatterns thus making it very difficult to visually compare e pected and actual values We forked assertItem using one of the following patterns from this and could immediately see the Click to see difference link in the IDE </Description>
 <CreatedDate>31/03/2017</CreatedDate>
 <ClosedDate>02/04/2017</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>PR welcome</Label>
<Label>Test</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5247</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix Flowable to List on Next cancelrace</Title>
 <Description>This PR fixes the Null Pointer Exception that can happen because cancel nulls out the value and onNext simply dereferences that value in Flowable To List Reported in</Description>
 <CreatedDate>31/03/2017</CreatedDate>
 <ClosedDate>31/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5247</PullRequestID>
 <IssueID>5246</IssueID>
 <Title>Null Pointer Exception in Flowable To List To List Subscriber on Next</Title>
 <Code>
 </Code>
 <stacktrace>
 Fatal E ception java lang NullPointerE ception Attempt to invoke interface method boolean java util Collection add java lang Objecton a null object reference
 at io reactive internal operators flowable FlowableToList$ToListSubscriber onNext FlowableToList java 71 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber tryOnNext FlowableFilter java 73 
 at io reactive internal operators flowable FlowableFilter$FilterSubscriber onNext FlowableFilter java 51 
 at io reactive internal operators flowable FlowableConcatMap$ConcatMapImmediate innerNext FlowableConcatMap java 215 
 at io reactive internal operators flowable FlowableConcatMap$ConcatMapInner onNext FlowableConcatMap java 592 
 at io reactive internal operators flowable FlowableFromIterable$IteratorSubscription fastPath FlowableFromIterable java 181 
 at io reactive internal operators flowable FlowableFromIterable$BaseRangeSubscription request FlowableFromIterable java 123 
 at io reactive internal subscriptions SubscriptionArbiter setSubscription SubscriptionArbiter java 96 
 at io reactive internal operators flowable FlowableConcatMap$ConcatMapInner onSubscribe FlowableConcatMap java 585 
 at io reactive internal operators flowable FlowableFromIterable subscribe FlowableFromIterable java 69 
 at io reactive internal operators flowable FlowableFromIterable subscribeActual FlowableFromIterable java 47 
 at io reactive Flowable subscribe Flowable java 12901 
 at io reactive internal operators flowable FlowableConcatMap$ConcatMapImmediate drain FlowableConcatMap java 343 
 at io reactive internal operators flowable FlowableConcatMap$BaseConcatMapSubscriber onNext FlowableConcatMap java 158 
 at io reactive internal operators flowable FlowableSubscribeOn$SubscribeOnSubscriber onNext FlowableSubscribeOn java 97 
 at io reactive internal subscriptions DeferredScalarSubscription complete DeferredScalarSubscription java 133 
 at io reactive internal operators flowable FlowableFromCallable subscribeActual FlowableFromCallable java 44 
 at io reactive Flowable subscribe Flowable java 12901 
 at io reactive internal operators flowable FlowableSubscribeOn$SubscribeOnSubscriber run FlowableSubscribeOn java 82 
 at io reactive internal schedulers ScheduledRunnable run ScheduledRunnable java 59 
 at io reactive internal schedulers ScheduledRunnable call ScheduledRunnable java 51 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 272 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1133 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 607 
 at java lang Thread run Thread java 761 
 </stacktrace>
 <Description>Notices few of this crashes is there any way to find from where they are coming
 </Description>
 <CreatedDate>31/03/2017</CreatedDate>
 <ClosedDate>31/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5226</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>mostroverkhov</FixedByID>
 <Title>Unicast Processor fail fast support</Title>
 <Description>This PR adds support for fail fast behavior to UnicastProcessor with methods UnicastP rocessor T create boolean delay Error Uni cast Processor T create int capacity Hint Runnable on Terminated boolean delay Error Relates to</Description>
 <CreatedDate>24/03/2017</CreatedDate>
 <ClosedDate>24/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5226</PullRequestID>
 <IssueID>5165</IssueID>
 <Title>Uni cast Subject does not replay on Next calls made prior to subscription if on Error is also called prior to subscription</Title>
 <Code>
 UnicastSubject&lt;String&gt; s = UnicastSubject create ;
 </Code>
 <Description>Im using RxJava Consider this code This outputs java lang Exception uh oh However the same code using RxJavaversion of Uni cast Subject outputs java lang Exception uh oh Which is the behavior I expected from
</Description>
 <CreatedDate>08/03/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>2x</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5226</PullRequestID>
 <IssueID>5217</IssueID>
 <Title>Uni cast Subject fail fast support</Title>
 <Description>This PR adds support for failfast behavior to UnicastSubject with methods UnicastSubjectT&gt; create boolean delayErrorUnicastSubjectT&gt; create int capacityHint Runnable onTerminated boolean delayError Relates to 5165
</Description>
 <CreatedDate>23/03/2017</CreatedDate>
 <ClosedDate>23/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5225</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>1 fi Completable onErrorResumeNextunsubscribenotpropagated</Title>
 <Description>The Completable onErrorResumeNext did not properly propagate the downstream unsubscribe call to upstream 

Reported in 5224 </Description>
 <CreatedDate>24/03/2017</CreatedDate>
 <ClosedDate>24/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5225</PullRequestID>
 <IssueID>5224</IssueID>
 <Title>1 2 9 Completable not unsubscribe with onErrorResumeNext</Title>
 <Code>java
 Completable com1 = Completable
 fromAction &gt; {
 try {
 Thread sleep 3000 ;
 } catch InterruptedE ception e {
 e printStackTrace ;
 }
 Log d TAG "c1" ;
} 
 doOnSubscribe s1 &gt; Log d TAG "com1 subscribe" 
 doOnUnsubscribe &gt; Log d TAG "com1 unsubscribe" ;

 Completable com2 = Completable
 fromAction &gt; {
 try {
 Thread sleep 6000 ;
 } catch InterruptedE ception e {
 e printStackTrace ;
 }
 Log d TAG "c2" ;
} 
 doOnSubscribe s2 &gt; Log d TAG "com2 subscribe" 
 doOnUnsubscribe &gt; Log d TAG "com2 unsubscribe" ;

 Subscription subscription =
Completable merge 
 com1
 com2
 
 subscribeOn Schedulers from E ecutors newSingleThreadE ecutor 
 onErrorResumeNext throwable &gt;
Completable
 fromAction &gt; Log d TAG "error happened" 

 doOnSubscribe s &gt; Log d TAG "subscribe" 
 doOnUnsubscribe &gt; Log d TAG "unsubscribe" 
 subscribe 
 &gt; Log d TAG "onComplete " 
throwable &gt; Log d TAG "onError " + throwable 
;

 Completable
 fromAction &gt; {
 subscription unsubscribe ;
 Log d TAG"whole subscription unsubscribe" ;
} 
 delay 2 TimeUnit SECONDS 
 subscribe ;

Result 

D subscribe
D com1 subscribe
D whole subscription unsubscribe
D c1
D com2 subscribe
D c2
D onComplete 


Case without operator onErrorResumeNext 

D subscribe
D com1 subscribe
D unsubscribe
D com1 unsubscribe
D whole subscription unsubscribe
D c1
 </Code>
 <Description>I have completable that contains merge or andThen 
Then I add onErrorResumeNext into sequence In this case If we unsubscribe the whole subscription when com1 is not completed yet then com2 wont be unsubscribed 

Code sample 
 </Description>
 <CreatedDate>24/03/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>1 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5223</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 improvethedocumentationofSchedulersutilityclass </Title>
 <Description>This PR improves the javadoc of the io reactive schedulers Schedulers utility class plus adds a missing SchedulerSupport constant for the single scheduler 

Let me know if something needs further e planation or some new case needs e planation 

Related 5145 </Description>
 <CreatedDate>24/03/2017</CreatedDate>
 <ClosedDate>24/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5223</PullRequestID>
 <IssueID>5145</IssueID>
 <Title>improve io reactive schedulers Schedulers documentation</Title>
 <Description> Better explain each scheduler type Repeat system parameters for each scheduler typeRemove mentions of Scheduler Lifecycle Explain how from handles Executor Executor Service and Scheduled Executor ServiceExplain getting back to the current thread requires a blocking schedulerMention the Scheduler Support annotations </Description>
 <CreatedDate>27/02/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5217</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>mostroverkhov</FixedByID>
 <Title>UnicastSubjectfailfastsupport</Title>
 <Description>This PR adds support for failfast behavior to UnicastSubject with methods UnicastSubjectT; create boolean delayErrorUnicastSubject&lt;T; create int capacityHint Runnable onTerminated boolean delayError Relates to 5165
</Description>
 <CreatedDate>23/03/2017</CreatedDate>
 <ClosedDate>23/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5217</PullRequestID>
 <IssueID>5165</IssueID>
 <Title>Uni cast Subject does not replay onNext calls made prior to subscription if on Error is also called prior to subscription </Title>
 <Code>
 UnicastSubject&lt;String&gt; s = UnicastSubject create ;
 </Code>
 <Description>I m using RxJava Consider this code Which is the behavior I expected from 
</Description>
 <CreatedDate>08/03/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>2x</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5213</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix window with time size emission problems</Title>
 <Description>The window operator overload with time and size bound didnt work correctly when some windows were terminated by the timeout and others by the size This PR fixes the case when the operator restarts the time windows when the size bound is reached leaking of the worker the item counter not reset to zero when the time bound is reached periodic window bound stopped working after the first window Related again </Description>
 <CreatedDate>22/03/2017</CreatedDate>
 <ClosedDate>22/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5213</PullRequestID>
 <IssueID>5104</IssueID>
 <Title>window timespan unit count always emit empty observable if not reach macount</Title>
 <Code>java
PublishSubject&lt;String&gt; vehicleToFetch = PublishSubject create;
</Code>
 <Description>This code will print nothing all the time I am using RxJava 
</Description>
 <CreatedDate>17/02/2017</CreatedDate>
 <ClosedDate>18/02/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5210</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>better documentation on the abstract consumer classes</Title>
 <Description>This PR improves the documentation of the abstract consumer classes such as Disposable Subscriber Resource Subscriber and their counterparts for the other base reactive types It contains a lot of copypaste so please read through all of the text in case the te t was not properly adapted to the abstract class at hand Related </Description>
 <CreatedDate>21/03/2017</CreatedDate>
 <ClosedDate>21/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5210</PullRequestID>
 <IssueID>5148</IssueID>
 <Title>improve documentation of the default consumer types</Title>
 <Description>Describe their singleuse nature Explicitly mention on Start Explicitly mention dispose or cancel Maybe add code examples Disposable Subscriber Disposable Completable Observer Disposable Maybe Observer Disposable Single Observer Disposable Observer Resource Subscriber also remove mention of Async Observer Resource Completable Observer Resource Maybe Observer Resource Single Observer Resource Observer </Description>
 <CreatedDate>28/02/2017</CreatedDate>
 <ClosedDate>21/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5208</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix images of first Element flatten As flat Map Iterable</Title>
 <Description>This PR links in the new images from for previously misleading marble diagrams of the operators </Description>
 <CreatedDate>21/03/2017</CreatedDate>
 <ClosedDate>21/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5208</PullRequestID>
 <IssueID>5130</IssueID>
 <Title>incorrect images</Title>
 <Description>This is a container for identifying and tracking fixes to outdated or incorrent marble diagrams Single flatten As Flowable refers to flat Map Iterable no reordering of colors Single flatten As Observable refers to flat Map Iterable no reordering of colors Flowable flat Map Iterable no reordering of colors Observable flat Map Iterable no reordering of colors Flowable first Element indicate cancellation after the first element shift marbles so the end element doesnt imply the completion like in single Or Error Observable first Element indicate cancellation after the first element shift marbles so the end element doesnt imply the completion like in single Or Error </Description>
 <CreatedDate>22/02/2017</CreatedDate>
 <ClosedDate>27/04/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5207</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>2 preventtaskstoselfinterruptonthestandardschedulers</Title>
 <Description>Task wrappers of the various schedulers and modes direct worker were able to get cancelled via interruption from the same thread they were running Related</Description>
 <CreatedDate>20/03/2017</CreatedDate>
 <ClosedDate>22/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5207</PullRequestID>
 <IssueID>5203</IssueID>
 <Title>Is delay Subscription interrupts the thread immediately as expected</Title>
 <Code>
 TestObserver&lt;Boolean&gt; observer = TestObserver create ;
 </Code>
 <Description>I ran the below test code with RxJava and got a failure which succeeded with RxJava If I put subscribeOn before delaySubscriptionit does not fail I am not sure if it is as e pected so want to know if it is the e pected behaviour Here is some background of my issue I am using RxJava with Retrofit and it seems Retrofit precisely speaking Okio which is being used in Ok Http throws an error when the thread is interrupted while it tries to read the HTTP response I am trying to delay the HTTP call to achieve something like debounce with delaySubscription operator and encountered this issue I have a workaround so just want to know if it is the e pected behaviour Thank you for your support in advance </Description>
 <CreatedDate>20/03/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5202</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>add resilient versions of parallel map filter do On Next</Title>
 <Description>This PR adds new overloads to Parallel Flowable operators map filter and do On Next to enable per item error handling in case the main function fails with some exception Flowable range  parallel  map v v ParallelFailureHandling SKIP  sequential  test  assertResult  The new Parallel Failure Handling has some default enumeration values to handle the common cases In addition the Bi Function overload allows bounded retries and or conditional handling of failures Related</Description>
 <CreatedDate>20/03/2017</CreatedDate>
 <ClosedDate>23/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5202</PullRequestID>
 <IssueID>5128</IssueID>
 <Title>resilience in the parallel operators</Title>
 <Code>
 map Function&lt;T R&gt; Function&lt;Throwable FailureHandling&gt; 
 filter Predicate&lt;T&gt; Function&lt;Throwable FailureHandling&gt; 
 doOnNext Action&lt;T&gt; Function&lt;Throwable FailureHandling&gt; 
 </Code>
 <Description>When the architecture of the parallel subsystem was designed the goal was to provide means for efficient parallel computations over recovering from failures in any or most of the parallel rails in it This resulted fail fast implementation and little to no means beyond flat Map to prevent the death of the whole parallel computation due to a single failing component Adding the usual on Error ResumeNext or retry doesnt work because the core driver parallel cant support resubscription on its individual rails and even if a failure behind a runOn almost certainly would drop any unprocessed elements in its queue The given toolset Parallel Flowable already gives the opportunity to include resilience at the cost of overhead flatMap and or concatMap As with the traditional flows the inner Flowable s to these can have all sorts of operators not available on parallel itself and are confined to the particular rail thus retry on Error Resume Next can be applied on a per item basis  On the other hand parallel map doOnNext among others dont offer any ignore resume option out of boand unless the developer applies trycatch to prevent crashing the rail To enable finer gained control in this situation I propose the following overloads enum Failure Handling stop error skip retry They should cover the the cases where the Function hosts a blocking call if there was a need for timed backoff the concatMap approach is still available Thoughts </Description>
 <CreatedDate>22/02/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5199</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>increase time out on parallel completable tests</Title>
 <Description>This PR increases the timeout on Completable Test test methods and on Parallel Flowable Test parallel is And Prefetch Async Related</Description>
 <CreatedDate>20/03/2017</CreatedDate>
 <ClosedDate>20/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>TestFailures</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5199</PullRequestID>
 <IssueID>5154</IssueID>
 <Title>Parallel Flowable Test &gt; parallelismAndPrefetchAsync FAILED</Title>
 <Code>
io reactive parallel ParallelFlowableTest &gt; parallelismAndPrefetchAsync FAILED
 java lang AssertionError Value counts differ; E pected 1048576 Actual 619054 latch = 1 values = 619054 errors = 0 completions = 0 
 at io reactive observers BaseTestConsumer fail BaseTestConsumer java 146 
 at io reactive observers BaseTestConsumer assertValueCount BaseTestConsumer java 443 
 at io reactive parallel ParallelFlowableTest parallelismAndPrefetchAsync ParallelFlowableTest java 741 
 </Code>
 <Description> 
 Could be due to timeout on an overworked container instance Also the Base Test Consumer may be e tended to print the cancellation status which awaitDone sets make await Done add an onError requires synchronising the errors list or a separate timeout flag that gets also printed </Description>
 <CreatedDate>03/03/2017</CreatedDate>
 <ClosedDate>20/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5199</PullRequestID>
 <IssueID>5179</IssueID>
 <Title>io reactive completable Completable Test do On Error No Error FAILED</Title>
 <Description>io reactive completable Completable Test do On Error No Error FAILED</Description>
 <CreatedDate>12/03/2017</CreatedDate>
 <ClosedDate>20/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5195</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>mostroverkhov</FixedByID>
 <Title>Uni cast Subject fail fast and delay error behavior</Title>
 <Description>This PR adds support for delayerror behavior to UnicastSubject with methods Unicast Subject create boolean delay Error Uni cast Subject create int capacity Hint Action on Terminated boolean delay Error Behavior of e isting factory methods was not changed and is failfast Relates to 
</Description>
 <CreatedDate>18/03/2017</CreatedDate>
 <ClosedDate>18/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1 </PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5195</PullRequestID>
 <IssueID>5165</IssueID>
 <Title>Uni cast Subject does not replay onNext calls made prior to sub scription if onError is also called prior to subscription </Title>
 <Code>java
 UnicastSubject&lt;String&gt; s = UnicastSubject create;
 </Code>
 <Description>Im using RxJava Consider this code This outputs java lang Exception uh oh However the same code using RxJava version of Uni cast Subject outputs java lang Exception uh oh Which is the behavior I expected from 
</Description>
 <CreatedDate>08/03/2017</CreatedDate>
 <ClosedDate>27/03/2017</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>2x</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5189</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>nmorioka</FixedByID>
 <Title>fix concat Map Eager should accept for prefetch</Title>
 <Description>Fixes a bug that Flowable concat Map Eager mapper ma Concurrency prefetch and Observable concat Map Eager mapper ma Concurrency prefetch operators will not accept negative numbers Reported in </Description>
 <CreatedDate>15/03/2017</CreatedDate>
 <ClosedDate>15/03/2017</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5189</PullRequestID>
 <IssueID>5185</IssueID>
 <Title>concat Map Eager should accept for prefetch</Title>
 <Code></Code>
 <Description>The documentation for concat Map Eager states but it will fail if the collection is empty Either the documentation should be updated to reflect that 0 is not a valid value or it should accept and perhaps set it to a default value internally </Description>
 <CreatedDate>14/03/2017</CreatedDate>
 <ClosedDate>16/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5183</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>test to disallow anonymous inner classes</Title>
 <Description>This PR adds an unit test that scans the compiled class files for anonymous inner classes naming i e dollar sign followed by a number Since all the main test and perf classes end up in the same place the test has exceptions for file names containing Perf or Test The PR also fixes a few Check style warnings from and fixes a couple classes from tests that dont have the word Test in their name and thus were detected </Description>
 <CreatedDate>14/03/2017</CreatedDate>
 <ClosedDate>14/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5183</PullRequestID>
 <IssueID>5177</IssueID>
 <Title>Removes all anonymous inner classes</Title>
 <Description>This is a what left to complete this one Removes all AICs  Issue
</Description>
 <CreatedDate>12/03/2017</CreatedDate>
 <ClosedDate>12/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5182</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix replay ref Count leaking items between connections</Title>
 <Description>This PR updates Observable replay and Flowable replay for to not leak items between reconnections when run with refCount The replay operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data Only a new connect clears this data which may or may not happen Since refCount ensures that there wont be any late commers to an already completed connection because it also drops its current subscribers on termination or when reaching zero the replay can be reset to an empty state Related </Description>
 <CreatedDate>13/03/2017</CreatedDate>
 <ClosedDate>14/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5182</PullRequestID>
 <IssueID>5172</IssueID>
 <Title>replay ref Count keeps latest value in memory even after everyone unsubscribes</Title>
 <Code>
 Subscription subscription1 = testObservable subscribe;
 Subscription subscription2 = testObservable subscribe;
 subscription1 unsubscribe;
 subscription2 unsubscribe;
 </Code>
 <Description>Code sample Problem if I m storing in field any Observable that contains replay refCount then this field will store hard reference to that latest value stored in replay buffer even if there are no subscriptions to that replay This value takes memory and it is not good but maybe its asdesign Also I think that this bug is actual for any replayof any observables chain that have such operator Why am I sad usually I use such construction to not calculate or get from disc some shared singleinstance object so if there are at least one subscriber so that object is calculating on subscribe and other subscribers wont call calculation on subscribe but take already calculated value Reference to Very Big Object from Main Activity this root object from test Observable Observable field of MainA ctivity object stores Observable with replay from on Subscribe On Subscribe Ref Count field of test Observable stores ref Count from source Operator Replay field of On Subscribe Ref Count stores Connectable Observable of replay from current Atomic Reference reference to current subscriber it is only changing to notnull in connect of Operator Replay from value Operator Replay Replay Subscriber value of Atomic Reference from buffer Operator Replay Size Bound Replay Buffer linked list of replay values with limit after everyone unsubscribe it has size inde from value Operator Replay Node head node of linked list its own node value not from Atomic Reference field is null from value Operator Replay Node Next element of linked list from headit stores Very Big Object from value Very Big Object latest value of replay before everyone unsubscribe</Description>
 <CreatedDate>10/03/2017</CreatedDate>
 <ClosedDate>15/03/2017</ClosedDate>
 <Labels>
<Label>1x</Label>
<Label>2x</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5182</PullRequestID>
 <IssueID>5181</IssueID>
 <Title>replay ref Count avoid leaking items between connections</Title>
 <Description>This PR updates replay to not leak items between reconnections when run with refCount The replay operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data Only a new connect clears this data which may or may not happen Since refCount ensures that there wont be any latecommers to an already completed connection because it also drops its current subscribers on termination or when reaching zerothe replay can be reset to an empty state Reported in   
</Description>
 <CreatedDate>13/03/2017</CreatedDate>
 <ClosedDate>15/03/2017</ClosedDate>
 <Labels>
<Label>1 </Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5181</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>replay ref Count avoid leaking items between connections</Title>
 <Description>This PR updates replay to not leak items between reconnections when run with refCount The replay operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data Only a new connect clears this data which may or may not happen Since refCount ensures that there wont be any latecommers to an already completed connection because it also drops its current subscribers on termination or when reaching zerothe replay can be reset to an empty state Reported in  
</Description>
 <CreatedDate>13/03/2017</CreatedDate>
 <ClosedDate>15/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>1 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5181</PullRequestID>
 <IssueID>5172</IssueID>
 <Title>replay ref Count keeps latest value in memory even after everyone unsubscribes</Title>
 <Code>
 testObservable = Observable fromCallable new Callable&lt;Object&gt; 
 Subscription subscription1 = testObservable subscribe ;
 Subscription subscription2 = testObservable subscribe ;
 subscription1 unsubscribe ;
 subscription2 unsubscribe ;
 </Code>
 <Description>Code sample Problem if Im storing in field any Observable that contains replay refCount then this field will store hard reference to that latest valuestored in replay buffer even if there are no subscriptions to that replay This value takes memory and it is not good but maybe its asdesign Also I think that this bug is actual for any replayof any observables chain that have such operator Why am I sad usually I use such construction to not calculate or get from disc some shared single instance object so if there are at least one subscriber so that object is calculating on subscribe and other subscribers wont call calculation on subscribe but take already calculated value  reference to Very Big Object from Main Activity this root object  from test Observable Observable field of Main Activity object stores Observable with replay  from on Subscribe OnSubscribeRefCountfield of test Observable stores refCount  from source Operator Replay field of On Subscribe Ref Count stores Connectable Observable of replay  rom current AtomicReferencereference to current subscriber it is only changing to notnull in connect of Operator Replay  rom value Operator Replay Replay Subscriber value of Atomic Reference  rom buffer Operator Replay Size Bound Replay Buffer linked list of replay values with limit after everyone unsubscribe it has size inde  rom value Operator Replay Nodehead node of linked listits own node value not from Atomic Reference field is null  rom value Operator Replay NodeNext element of linked list from headit stores Very Big Object  rom value Very Big Object latest value of replay before everyone unsubscribe</Description>
 <CreatedDate>10/03/2017</CreatedDate>
 <ClosedDate>15/03/2017</ClosedDate>
 <Labels>
<Label>1 </Label>
<Label>2 </Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5177</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>SleimanJneidi</FixedByID>
 <Title>Removes all anonymous inner classes</Title>
 <Description>This is a what left to complete this one Rremoves all AICs issue</Description>
 <CreatedDate>12/03/2017</CreatedDate>
 <ClosedDate>12/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5177</PullRequestID>
 <IssueID>5150</IssueID>
 <Title>eliminate all anyonymous inner classes</Title>
 <Description>Currently mostly the base reactive classes have been cleared of anonymous inner classes Still many stacktraces contain SomeClass$ $ that makes it difficult to figure out what that e act component was without having an IDE open I dont know if IDEs allow searching for anonymous inner classes and or highlight them like warnings thus the a reasonable way would be to scan the build directory for files containing the $ pattern In addition if there is an agreement a new style validation unit test could be added that does the same scanning at unit test time ignoring SomeClassTest s and warning failing the build if any of such files was found PR welcome</Description>
 <CreatedDate>03/03/2017</CreatedDate>
 <ClosedDate>20/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5176</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix private field access few generics problems</Title>
 <Description>This PR fixes some private field accessor problems introduced by as well as a couple of generics warnings 

Note that in IntelliJ there is a J ME inspection for private access checks between parent and inner classes </Description>
 <CreatedDate>11/03/2017</CreatedDate>
 <ClosedDate>11/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5176</PullRequestID>
 <IssueID>5174</IssueID>
 <Title>WIP removes anonymous inner classes</Title>
 <Description>This is a WIP Since the changes are big an incremental review and PR was recommended by akarnokd Removes them from flowable observable operators Issue </Description>
 <CreatedDate>11/03/2017</CreatedDate>
 <ClosedDate>11/03/2017</ClosedDate>
 <Labels>
<Label>2 </Label>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5174</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>SleimanJneidi</FixedByID>
 <Title>WIP removes anonymous inner classes </Title>
 <Description>This is a WIP Since the changes are big an incremental review and PR was recommended by akarnokd Removes them from flowable observable operators Issue </Description>
 <CreatedDate>11/03/2017</CreatedDate>
 <ClosedDate>11/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2x</PullRequestLabel>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5174</PullRequestID>
 <IssueID>5150</IssueID>
 <Title>eliminate all anyonymous inner classes</Title>
 <Description>Currently mostly the base reactive classes have been cleared of anonymous inner classes Still many stacktraces contain SomeClass that makes it difficult to figure out what that exact component was without having an IDE open I dont know if IDEs allow searching for anonymous inner classes and or highlight them like warnings thus the a reasonable way would be to scan the build directory for files containing the pattern In addition if there is an agreement a new style validation unit test could be added that does the same scanning at unit test time ignoring Some Class Test s and warning failing the build if any of such files was found PR welcome </Description>
 <CreatedDate>03/03/2017</CreatedDate>
 <ClosedDate>20/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Cleanup</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>5163</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Single subscribe to report is Disposed true on success error</Title>
 <Description>The Consumer Single Observer didnt report is Disposed consistently with its state Reported in</Description>
 <CreatedDate>08/03/2017</CreatedDate>
 <ClosedDate>08/03/2017</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>2 </PullRequestLabel>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>5163</PullRequestID>
 <IssueID>5160</IssueID>
 <Title>Disposable returned from Single subscribe is not disposed after terminal event</Title>
 <Code>
public void testDisposable throws E ception {

	Disposable disposable;

	disposable = Single just 1 subscribe 
		Next &gt; System out println "Single Success" 
		error &gt; System out println "Single Error" 
	 ;

	System out println "Single Disposed " + disposable isDisposed ;

	disposable = Observable just 1 subscribe 
		Next &gt; System out println "Observable Next" 
		error &gt; System out println "Observable Error" 
		 &gt; System out println "Observable Complete" 
	 ;

	System out println "Observable Disposed " + disposable isDisposed ;
}
 </Code>
 <Description>When using Single subscribe on Success on Error the returned Disposable is not disposed after terminal event However for Observable Flowable Maybe and Completablethe results are all disposed Here is the test code RxJava</Description>
 <CreatedDate>08/03/2017</CreatedDate>
 <ClosedDate>08/03/2017</ClosedDate>
 <Labels>
<Label>2x</Label>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3977</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Use the correct Throwable to set the cause for Composite Exception</Title>
 <Description>The cause of is we use a wrong Throwable its cause has been set to set the cause and init Cause will throw an e ception Hence the cause chain is not created correctly In this PR it searches the root cause which doesnt have a cause and use it to call init Cause </Description>
 <CreatedDate>01/06/2016</CreatedDate>
 <ClosedDate>01/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3977</PullRequestID>
 <IssueID>3679</IssueID>
 <Title>Actual exception is being hidden by On Error Failed Exception</Title>
 <Code>
public void onCompleted {
		throw new IllegalThreadStateException; 
		}
 </Code>
 <stacktrace>
 Process com e ample mydemoapp PID 14118
java lang IllegalStateE ception Fatal E ception thrown on Scheduler Worker thread 
 at r internal schedulers ScheduledAction run ScheduledAction java 62 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 
 at java lang Thread run Thread java 818 
 Caused by r exceptions OnErrorFailedE ception Error occurred when trying to propagate error to Observer onError
 at r observers SafeSubscriber _onError SafeSubscriber java 194 
 at r observers SafeSubscriber onError SafeSubscriber java 120 
 at r internal operators OnSubscribeRedo$4$1 onError OnSubscribeRedo java 331 
 at r internal operators OperatorMerge$MergeSubscriber reportError OperatorMerge java 240 
 at r internal operators OperatorMerge$MergeSubscriber checkTerminate OperatorMerge java 776 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 537 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 526 
 at r internal operators OperatorMerge$InnerSubscriber onError OperatorMerge java 810 
 at r internal operators OperatorDoOnEach$1 onError OperatorDoOnEach java 71 
 at r exceptions exceptions throwOrReport exceptions java 187 
 at r internal operators OperatorDoOnEach$1 onNext OperatorDoOnEach java 82 
 at r internal operators OperatorDelay$1$3 call OperatorDelay java 88 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 Â 
 at java util concurrent FutureTask run FutureTask java 237 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 Â 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 Â 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 Â 
 at java lang Thread run Thread java 818 Â 
 Caused by r exceptions CompositeE ception 2 exceptions occurred 
 at r observers SafeSubscriber _onError SafeSubscriber java 194 Â 
 at r observers SafeSubscriber onError SafeSubscriber java 120 Â 
 at r internal operators OnSubscribeRedo$4$1 onError OnSubscribeRedo java 331 Â 
 at r internal operators OperatorMerge$MergeSubscriber reportError OperatorMerge java 240 Â 
 at r internal operators OperatorMerge$MergeSubscriber checkTerminate OperatorMerge java 776 Â 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 537 Â 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 526 Â 
 at r internal operators OperatorMerge$InnerSubscriber onError OperatorMerge java 810 Â 
 at r internal operators OperatorDoOnEach$1 onError OperatorDoOnEach java 71 Â 
 at r exceptions exceptions throwOrReport exceptions java 187 Â 
 at r internal operators OperatorDoOnEach$1 onNext OperatorDoOnEach java 82 Â 
 at r internal operators OperatorDelay$1$3 call OperatorDelay java 88 Â 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 Â 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 Â 
 at java util concurrent FutureTask run FutureTask java 237 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 Â 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 Â 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 Â 
 at java lang Thread run Thread java 818 Â 
 Caused by r exceptions CompositeE ception$CompositeE ceptionCausalChain Chain of Causes for CompositeE ception In Order Received =&gt;
 at android util Log getStackTraceString Log java 504 
 at com android internal os RuntimeInit Clog_e RuntimeInit java 59 
 at com android internal os RuntimeInit access$200 RuntimeInit java 43 
 at com android internal os RuntimeInit$UncaughtHandler uncaughtE ception RuntimeInit java 91 
 at java lang ThreadGroup uncaughtE ception ThreadGroup java 693 
 at java lang ThreadGroup uncaughtE ception ThreadGroup java 690 
 at r internal schedulers ScheduledAction run ScheduledAction java 66 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 Â 
 at java util concurrent FutureTask run FutureTask java 237 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 Â 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 Â 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 Â 
 at java lang Thread run Thread java 818 Â 
 Caused by java lang UnsupportedOperationE ception retry e ception
 at com e ample mydemoapp MainActivity$3$1$1 call MainActivity java 74 
 at com e ample mydemoapp MainActivity$3$1$1 call MainActivity java 72 
 at r Observable$11 onNext Observable java 4445 
 at r internal operators OperatorDoOnEach$1 onNext OperatorDoOnEach java 80 
 at r internal operators OperatorDelay$1$3 call OperatorDelay java 88 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 Â 
 at java util concurrent FutureTask run FutureTask java 237 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 Â 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 Â 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 Â 
 at java lang Thread run Thread java 818 Â 
 Caused by r exceptions OnErrorThrowable$OnNextValue OnError while emitting onNext value 3
 at r exceptions exceptions throwOrReport exceptions java 187 
 at r internal operators OperatorDoOnEach$1 onNext OperatorDoOnEach java 82 
 at r internal operators OperatorDelay$1$3 call OperatorDelay java 88 Â 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 Â 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 Â 
 at java util concurrent FutureTask run FutureTask java 237 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 Â 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 Â 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 Â 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 Â 
 at java lang Thread run Thread java 818 Â 

 </stacktrace>
 <Description>Using RxJava 1 10 and similar issue on 1 0 15I stumbled upon a mysterious stack trace that made no sense in my app after a lot of debugging I found that RxJava will report the wrong e ception in some scenarios For e ample if you run this sample code </Description>
 <CreatedDate>08/02/2016</CreatedDate>
 <ClosedDate>02/06/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3974</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>1 addterminalclarificationtoswitchMapoperators</Title>
 <Description>See 3576 
</Description>
 <CreatedDate>31/05/2016</CreatedDate>
 <ClosedDate>01/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3974</PullRequestID>
 <IssueID>3576</IssueID>
 <Title>Clarify behaviour in JavaDoc of switchOnNext with respect to completions</Title>
 <Description>The JavaDoc of switchOnNext doesnt currently say anything about how the resulting Observable will complete The marble diagram implies but not totally clearly that if an inner Observable completes after an outer onNextthat completion is swallowed and if an inner Observable completes after the outer Observable completes that the resulting Observable also completes However theres no info about what happens in an inner Observable completes _before_ an outer onNext Does the resulting Observable complete at that point or not?Ive read the tests and it seems the answer is that the resulting Observable will complete e actly when the following happen in this order 1 the outer Observable completes implying that the current inner Observable will never be switched to any other ;2 the current inner Observable completes And that the resulting Observable wont complete under any other circumstances Firstly is my understanding correct and secondly can the JavaDoc be improved?</Description>
 <CreatedDate>16/12/2015</CreatedDate>
 <ClosedDate>01/06/2016</ClosedDate>
 <Labels>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3971</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>request rebatch operator</Title>
 <Description>This is a followup on but with a separate operator on Observable 
</Description>
 <CreatedDate>31/05/2016</CreatedDate>
 <ClosedDate>01/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3971</PullRequestID>
 <IssueID>3964</IssueID>
 <Title>observe On immediate scheduler to be a request rebatcher</Title>
 <Code> public Observable&lt;Integer&gt; echo RpcStreamConte t&lt;?&gt; ctObservable&lt;Integer&gt; in {
 return in observeOn Schedulers immediate16 ;
}
 </Code>
 <Description>This PR removes the immediate scheduler optimization from observe On and treats it as a common scheduler Since observe On has a stable request pattern this turns it into a rebatching operator No matter what the downstream requests the upstream will requests of the specified size with as low water mark i e replenishment after Since immediate is synchronous this will run the drain loop non reentrant on the caller thread I found this mode of operation very handy in my Reactive RPC prototype and a simple streaming echo RPC call it prevents going unbounded and bloating the message sender threads </Description>
 <CreatedDate>25/05/2016</CreatedDate>
 <ClosedDate>31/05/2016</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3966</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>add multi other with Latest From operators</Title>
 <Description>Add with Latest From operator version that can take to N other sources and combi Nex them with the main source Related 
</Description>
 <CreatedDate>26/05/2016</CreatedDate>
 <ClosedDate>16/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3966</PullRequestID>
 <IssueID>3779</IssueID>
 <Title>with Latest From interface inconsistent with combine Latest</Title>
 <Description>Why with Latest From has only calling signature while combine Latest has plenty of convenient overload for combining multiple observables Should it be the same or this is by design</Description>
 <CreatedDate>18/03/2016</CreatedDate>
 <ClosedDate>17/06/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3958</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>just construction to call the on Create Execution hook</Title>
 <Description>This PR adds the call to Rx Java Observable Execution Hook onCreate to the just Scalar Synchronous Observable construction Related </Description>
 <CreatedDate>21/05/2016</CreatedDate>
 <ClosedDate>23/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3958</PullRequestID>
 <IssueID>2656</IssueID>
 <Title>just T RxJava Observable Execution Hook not called</Title>
 <Description>When using Observable just T the RxJava Observable Execution Hook is not call This is not like other just T that call r Observable from Iterable tends</Description>
 <CreatedDate>13/02/2015</CreatedDate>
 <ClosedDate>23/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3948</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>vanniktech</FixedByID>
 <Title>Add Completable and Then Completable deprecate end With</Title>
 <Description>See </Description>
 <CreatedDate>18/05/2016</CreatedDate>
 <ClosedDate>23/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3948</PullRequestID>
 <IssueID>3947</IssueID>
 <Title>Request Completable and Then Completable </Title>
 <Description>To match Completable andThen Observable Next and Completable and Then Single Next it would be nice if there were an operator like this Completable and Then Completable Next Unless there is some other way to achieve the same functionality right now </Description>
 <CreatedDate>18/05/2016</CreatedDate>
 <ClosedDate>23/05/2016</ClosedDate>
 <Labels>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3942</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>add Completable safe Subscribe option RxJava Plugin shook support</Title>
 <Description>Add option to safely subscribe a Completable Subscriber regular Subscriber and handle onfailures See also Naming and whether or not the safe wrapping should be the default is open to discussion 
</Description>
 <CreatedDate>14/05/2016</CreatedDate>
 <ClosedDate>01/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3942</PullRequestID>
 <IssueID>3938</IssueID>
 <Title>Add missing error handler call in Completable</Title>
 <CreatedDate>13/05/2016</CreatedDate>
 <ClosedDate>14/05/2016</ClosedDate>
 <Labels>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3941</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix Single flat Map not composing subscription through</Title>
 <Description>See</Description>
 <CreatedDate>14/05/2016</CreatedDate>
 <ClosedDate>17/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3941</PullRequestID>
 <IssueID>3940</IssueID>
 <Title>to Single leaks subscriber if followed by flat map </Title>
 <Description>Not sure this is a correct test let me know if I can provide any extra information </Description>
 <CreatedDate>13/05/2016</CreatedDate>
 <ClosedDate>17/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3928</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Update RxJava Javadoc to</Title>
 <Description>Closes </Description>
 <CreatedDate>11/05/2016</CreatedDate>
 <ClosedDate>11/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3928</PullRequestID>
 <IssueID>3925</IssueID>
 <Title>JavaDoc needs update after last release</Title>
 <Description>For example Observable create Async On Subscribe does not exist </Description>
 <CreatedDate>10/05/2016</CreatedDate>
 <ClosedDate>11/05/2016</ClosedDate>
 <Labels>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3924</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix R Ring Buffer pool depending on the computation scheduler</Title>
 <Description>This PR fixed the Object Pool dependency on the Schedulers computation which can be replaced via plugin hooks causing une pected and long sleeps i e when computation is replaced by immediate See Id also consider removing the R RingBuffer entirely </Description>
 <CreatedDate>09/05/2016</CreatedDate>
 <ClosedDate>10/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3924</PullRequestID>
 <IssueID>3923</IssueID>
 <Title>Should R RingBuffers validator really be on the computation scheduler?</Title>
 <Description>I just helped debug an issue where some Android robolectric tests timed out after upgrading from to due to As it turned out they were replacing the computation scheduler with immediate via RxJava Plugins The new commit caused R Ring Buffer SIZE to load the R Ring Buffer class in any call to observeOn which in turn created its Object Pools which in turn ran their start which sets up a periodic scheduling on the computation thread This caused the tests to hang indefinitely because of the repeated SleepingActions triggered by the validation tasks So since R RingBuffer can be loaded in various places by Rinternally that seems to make it a lot more difficult to reliably replace the computation scheduler particularly with immediate I recommended against the immediate override in this case but using a test scheduler wasnt really helping in this scenario either although I am unfamiliar with that codebase and didnt have time to dive too deep into why Short term fifor this particular case was to call observeOn with a size constant to sidestep the R RingBuffer load in these tests until we can clean up the underlying scheduler plugin overrides However Im wondering if maybe internal scheduling things like this should have their own scheduler? Maybe an internal computation scheduler that could be an additional override in the schedulers hook That would allow them to run unhindered in most cases despite computation being overridden but in e treme cases they could be overridden as well </Description>
 <CreatedDate>09/05/2016</CreatedDate>
 <ClosedDate>10/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3922</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix using resource cleanup when factory throws or being non eager</Title>
 <Description>The operator using didnt call the resource cleanup code if the observable Factory call code crashed In addition a noneager using didnt call the resource cleanup if one subscribed with unsafe Subscribe or the subscription to the generated Observable crashed Related  
</Description>
 <CreatedDate>09/05/2016</CreatedDate>
 <ClosedDate>10/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3922</PullRequestID>
 <IssueID>3921</IssueID>
 <Title>Possible resource leak in OnSubscribeUsing</Title>
 <Description>Hi I am considering using of RxJava to represent REST API responses so was looking into the sources to understand how stuff works In the On Subscribe Using operator there is something that looks like a logic error to me that may lead to leaking resources I am reporting theoretical issue I have not tried actually making it happen Also I have almost zero knowledge on how RxJava works so can be really missing something Sorry about that in advance So in the call method allocates resource the first thing and then creates Observable attaches dispose handler etc In the end it calls unsafeSubscribe handling for the potential e ception But what if e ception happens earlier? ImagiNexthe resource was allocated successfully but observableFactory call resource throws for e ample There seems to be nothing to dispose the resource in that case Again I have no deep understanding of RxJava but it looks to me that resource disposal should be happening in the top level try/finally block if resource was allocated but doOnTerminate has not been installed yet or failed to install I would probably just remove the inner try/catch and did all the handling at the top level possibly setting some boolean to indicate that stuff actually started so no cleanup needed Cheers</Description>
 <CreatedDate>09/05/2016</CreatedDate>
 <ClosedDate>10/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3918</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Replay Subject now supports backpressure</Title>
 <Description>In addition the behavior of timelimited mode has been changed Late subscribers will now skip stale data Related issue 
</Description>
 <CreatedDate>08/05/2016</CreatedDate>
 <ClosedDate>15/06/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3918</PullRequestID>
 <IssueID>3917</IssueID>
 <Title>replay bufferSize time TimeUnit not workingtruncate should be called with replay</Title>
 <Description>The buffer only gets truncated when a new item is added So any subscribers will always receive that last emission even if its older than the timelimit Here subscriber C is subbing after 30 secs so youd e pect the buffer to have truncated the last value since the timelimit is 5 secs This is the output &gt; Subscribing A&gt; Connecting&gt; subscriber A ========== 0&gt; subscriber A ========== 1&gt; subscriber A ========== 2&gt; subscriber A ========== 3&gt; subscriber A ========== 4&gt; Subscribing B&gt; subscriber B ========== 4&gt; subscriber A ========== 5&gt; subscriber B ========== 5&gt; subscriber A ========== 6&gt; subscriber B ========== 6&gt; subscriber A ========== 7&gt; subscriber B ========== 7&gt; subscriber A ========== 8&gt; subscriber B ========== 8&gt; subscriber A ========== 9&gt; subscriber B ========== 9&gt; Subscribing C&gt; subscriber C ========== 9</Description>
 <CreatedDate>06/05/2016</CreatedDate>
 <ClosedDate>22/06/2016</ClosedDate>
 <Labels>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3909</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Single retry When javadoc clarifications</Title>
 <Description>See</Description>
 <CreatedDate>05/05/2016</CreatedDate>
 <ClosedDate>05/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3909</PullRequestID>
 <IssueID>3774</IssueID>
 <Title>Single retry When allows Observable complete and throws</Title>
 <Code> 
public void testSingleErrorWithRetry throws E ception {
 TestSubscriber testSubscriber = new TestSubscriber ;
}
public void onCompleted {
if emittedTooMany {
 // Dont need to do anything here since we already sent an error downstream
} else {
 if itemEmitted {
 child onSuccess emission ;
 } else {
 child onError new NoSuchElementE ception "Observable emitted no items" ;
 }
}
}
 </Code>
 <stacktrace>
  at r observers TestSubscriber assertError TestSubscriber java 464 
 at com e ample E ampleTest testSingleErrorWithRetry E ampleTest java 77 
 at sun reflect NativeMethodAccessorImpl invoke0 Native Method 
 17 more
Caused by java util NoSuchElementE ception Observable emitted no items
 at r internal operators OnSubscribeSingle$1 onCompleted OnSubscribeSingle java 59 
 at r internal operators OnSubscribeRedo$4$1 onCompleted OnSubscribeRedo java 326 
 at r Observable$EmptyHolder$1 call Observable java 1123 
 at r Observable$EmptyHolder$1 call Observable java 1120 
 at r Observable unsafeSubscribe Observable java 8314 
 at r internal operators OnSubscribeRedo$4 call OnSubscribeRedo java 323 
 at r schedulers TrampolineScheduler$InnerCurrentThreadScheduler enqueue TrampolineScheduler java 80 
 at r schedulers TrampolineScheduler$InnerCurrentThreadScheduler schedule TrampolineScheduler java 59 
 at r internal operators OnSubscribeRedo call OnSubscribeRedo java 320 
 at r internal operators OnSubscribeRedo call OnSubscribeRedo java 55 
 at r Observable unsafeSubscribe Observable java 8314 
 at r internal operators OnSubscribeSingle call OnSubscribeSingle java 83 
 at r internal operators OnSubscribeSingle call OnSubscribeSingle java 29 
 at r Single$1 call Single java 93 
 at r Single$1 call Single java 73 
 at r Single subscribe Single java 1665 
 at com e ample E ampleTest testSingleErrorWithRetry E ampleTest java 67 
 22 more
 </stacktrace>
 <Description> The behavior should be changed The real child subscription before the Observable Single conversion is a Single Subscriber which doesnt have the method onCompleted Better on Error is called instead with the latest emitted error instead of the current NoSuchElementE ception The docs should be updated to If that Observable calls on Complete or onError then retry will call onError on the child subscription </Description>
 <CreatedDate>16/03/2016</CreatedDate>
 <ClosedDate>13/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>Documentation</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3907</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Do On Unsubscribe java doc clarifications</Title>
 <Description>See </Description>
 <CreatedDate>05/05/2016</CreatedDate>
 <ClosedDate>05/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3907</PullRequestID>
 <IssueID>3877</IssueID>
 <Title>do On Unsubscribe behaviour does not align with documentation</Title>
 <Code>
public class UnsubscribeTest {
 public void onUnsubscribeAfterRefCount {
 AtomicInteger count = new AtomicInteger ;
 TestSubscriber&lt;String&gt; testSubscriber1 = TestSubscriber create ;
 Subscription subscription1 = publishSubject subscribe testSubscriber1 ;
 TestSubscriber&lt;String&gt; testSubscriber2 = TestSubscriber create ;
 Subscription subscription2 = publishSubject subscribe testSubscriber2 ;
 }
}
 </Code>
 <stacktrace>
 Nonfatal Exception java lang IllegalStateE ception more items arrived than were requested
 at r internal producers ProducerArbiter produced ProducerArbiter java 98 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber innerCompleted OnSubscribeConcatMap java 206 
 at r internal operators OnSubscribeConcatMap$ConcatMapInnerSubscriber onCompleted OnSubscribeConcatMap java 345 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSingle$ParentSubscriber onCompleted OperatorSingle java 129 
 at r internal operators OperatorTakeLastOne$ParentSubscriber onCompleted OperatorTakeLastOne java 107 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 635 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 547 
 at r internal operators OperatorMerge$MergeSubscriber onCompleted OperatorMerge java 268 
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 47 
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 32 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable unsafeSubscribe Observable java 8741 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber drain OnSubscribeConcatMap java 286 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber innerCompleted OnSubscribeConcatMap java 209 
 at r internal operators OnSubscribeConcatMap$ConcatMapInnerSubscriber onCompleted OnSubscribeConcatMap java 345 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSingle$ParentSubscriber onCompleted OperatorSingle java 125 
 at r internal operators OperatorTakeLastOne$ParentSubscriber emit OperatorTakeLastOne java 159 
 at r internal operators OperatorTakeLastOne$ParentSubscriber onCompleted OperatorTakeLastOne java 125 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 635 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 547 
 at r internal operators OperatorMerge$InnerSubscriber onCompleted OperatorMerge java 836 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSubscribeOn$1$1 onCompleted OperatorSubscribeOn java 68 
 at r internal operators OnSubscribeToObservableFuture$ToObservableFuture call OnSubscribeToObservableFuture java 76 
 at r internal operators OnSubscribeToObservableFuture$ToObservableFuture call OnSubscribeToObservableFuture java 43 
 at r Observable unsafeSubscribe Observable java 8741 
 at r internal operators OperatorSubscribeOn$1 call OperatorSubscribeOn java 94 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 
 at java lang Thread run Thread java 818 

 </stracktrace>
 <Description>Hi According to the documentation here when my source observable is reference counted I should only be notified of the final subscribers unsubscription however unless I am misunderstanding the term _source_or misusing it it appears to be called on every subscribers unsubscription Below is a simple test which demonstrates what I mean on Unsubscribe After Ref Count will fail while on Unsubscribe Before Ref Count will pass </Description>
 <CreatedDate>22/04/2016</CreatedDate>
 <ClosedDate>31/05/2016</ClosedDate>
 <Labels>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3905</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix single Or Default back pressure if source is empty</Title>
 <Description>Issue is a gold mine for missing backpressure problems This PR fixes the case when single Or Default encounters an empty source and has to emit some default value Fixed via setting the SingleProducer on the child on termination 
</Description>
 <CreatedDate>02/05/2016</CreatedDate>
 <ClosedDate>02/05/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3905</PullRequestID>
 <IssueID>3892</IssueID>
 <Title>java lang Illegal State Exception more items arrived than were requested</Title>
 <Code>
 </Code>
 <Description>Were seeing this e ception for a small percent of our users We havent been able to reproduce this ourselves so providing a sample might not be feasible Any idea what could be causing this based on the stacktrace alone? </Description>
 <CreatedDate>28/04/2016</CreatedDate>
 <ClosedDate>02/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3895</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>cast should unsubscribe on crash eagerly</Title>
 <Description>Similar issue as in</Description>
 <CreatedDate>28/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3895</PullRequestID>
 <IssueID>3890</IssueID>
 <Title>map and filter should unsubscribe on crash eagerly</Title>
 <Description>In current master when the function in map or filter crashes the error is propagated but the upstream is not immediately unsubscribed but e pected to happen eventually due to some other operator or SafeSubscriber The fiand also the restructuring of the unsubscription chain makes sure the crash also unsubscribes immediately unless a fatal one Related StackOverflow question </Description>
 <CreatedDate>28/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3893</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>enable back pressure with from Future</Title>
 <Description>The from Future operator was not refitted for backpressure Reported in </Description>
 <CreatedDate>28/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3893</PullRequestID>
 <IssueID>3892</IssueID>
 <Title>java lang IllegalStateException more items arrived than were requested</Title>
 <Code> 
 </Code>
 <stacktrace>
 Nonfatal Exception java lang IllegalStateException more items arrived than were requested
 at r internal producers ProducerArbiter produced ProducerArbiter java 98 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber innerCompleted OnSubscribeConcatMap java 206 
 at r internal operators OnSubscribeConcatMap$ConcatMapInnerSubscriber onCompleted OnSubscribeConcatMap java 345 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSingle$ParentSubscriber onCompleted OperatorSingle java 129 
 at r internal operators OperatorTakeLastOne$ParentSubscriber onCompleted OperatorTakeLastOne java 107 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 635 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 547 
 at r internal operators OperatorMerge$MergeSubscriber onCompleted OperatorMerge java 268 
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 47 
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 32 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable$2 call Observable java 233 
 at r Observable$2 call Observable java 225 
 at r Observable unsafeSubscribe Observable java 8741 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber drain OnSubscribeConcatMap java 286 
 at r internal operators OnSubscribeConcatMap$ConcatMapSubscriber innerCompleted OnSubscribeConcatMap java 209 
 at r internal operators OnSubscribeConcatMap$ConcatMapInnerSubscriber onCompleted OnSubscribeConcatMap java 345 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSingle$ParentSubscriber onCompleted OperatorSingle java 125 
 at r internal operators OperatorTakeLastOne$ParentSubscriber emit OperatorTakeLastOne java 159 
 at r internal operators OperatorTakeLastOne$ParentSubscriber onCompleted OperatorTakeLastOne java 125 
 at r internal operators OperatorMerge$MergeSubscriber emitLoop OperatorMerge java 635 
 at r internal operators OperatorMerge$MergeSubscriber emit OperatorMerge java 547 
 at r internal operators OperatorMerge$InnerSubscriber onCompleted OperatorMerge java 836 
 at r internal operators OperatorMap$1 onCompleted OperatorMap java 43 
 at r internal operators OperatorSubscribeOn$1$1 onCompleted OperatorSubscribeOn java 68 
 at r internal operators OnSubscribeToObservableFuture$ToObservableFuture call OnSubscribeToObservableFuture java 76 
 at r internal operators OnSubscribeToObservableFuture$ToObservableFuture call OnSubscribeToObservableFuture java 43 
 at r Observable unsafeSubscribe Observable java 8741 
 at r internal operators OperatorSubscribeOn$1 call OperatorSubscribeOn java 94 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 
 at java lang Thread run Thread java 818 
 </stracktrace>
 <Description>Were seeing this exception for a small percent of our users We havent been able to reproduce this ourselves so providing a sample might not be feasible Any idea what could be causing this based on the stack trace alone</Description>
 <CreatedDate>28/04/2016</CreatedDate>
 <ClosedDate>02/05/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3886</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>dlew</FixedByID>
 <Title>throw If Fatal now throws On Completed Failed Exception</Title>
 <Description>Otherwise if theres an error in onCompleted the exception is swallowed and unreported Fixes</Description>
 <CreatedDate>27/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3886</PullRequestID>
 <IssueID>3885</IssueID>
 <Title>on Completed swallows all exceptions</Title>
 <Code> </Code>
 <Description>I was fairly surprised by the behavior of this stream What I expected to see was the thread crashing due to the exception instead absolutely nothing happens because onCompleted swallows the exception entirely </Description>
 <CreatedDate>27/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3883</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix multiple chained Single do After Terminate not calling actions</Title>
 <Description>Resolves The bug is caused by the impedance mismatch between Observable s Subscriber and Single s Single Subscriber The original code called onNext which immediately signalled an onSuccess but also caused an unsubscription preventing a delivery of on Completed in the inner Single The fix keeps on Success on Error rails intact throughout the chain </Description>
 <CreatedDate>27/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3883</PullRequestID>
 <IssueID>3881</IssueID>
 <Title>Single not calling doAfterTerminate when used in flatMap</Title>
 <Code>
 </Code>
 <Description>Ive noticed that when I return a Single from a flat Map and that Single calls do After Terminate Action the Action call method is never called This behaviour is not consistent with what happens when you do the same thing with an Observable I am using When I run I see the following printed to the console  observable Do After Terminate observable Flat Map Do After Terminate</Description>
 <CreatedDate>26/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3879</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>JakeWharton</FixedByID>
 <Title>Expose scheduler factories which accept thread factories</Title>
 <Description>This allows hooks to create schedulers whose threads have different priorities Closes </Description>
 <CreatedDate>22/04/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3879</PullRequestID>
 <IssueID>3724</IssueID>
 <Title>APIs for easily changing the thread priority of default schedulers via hook </Title>
 <Description>On Android the main thread is a sacred holy land at which we must all worship As such this means other threads ideally shouldnt be favorably scheduled in priority with it For network and filesystem operations this usually means using low priority threads One solution is to just use low priority threads on our own schedulers but this doesnt affect code using the standard io and computation schedulers Unfortunately theres a whole bunch of ceremony around how various schedulers are initialized which includes a mi ed bag of public vs nonpublic types and APIs which makes replacing them in a scheduler hook difficult I think the most easy way to accomplish this is the following ~~ R ThreadFactory constructor overload which takes a thread priority to use ~~ Not needed Factory methods on Schedulers for creating instances of iocomputationand newThread e cept using a supplied ThreadFactory Schedulers createIoScheduler ThreadFactory Schedulers createComputationScheduler ThreadFactory Schedulers createNewThreadScheduler ThreadFactory Nice to have Schedulers using these factory methods to create the default implementations This involves moving the thread factories from the individual types "up" to Shedulers </Description>
 <CreatedDate>21/02/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3871</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>JakeWharton</FixedByID>
 <Title>Deprecateremainingpublicschedulertypes </Title>
 <Description>A continuation of some work done in 3856 of removing uninstantiable types from the public API via deprecation 
</Description>
 <CreatedDate>20/04/2016</CreatedDate>
 <ClosedDate>21/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3871</PullRequestID>
 <IssueID>3856</IssueID>
 <Title>Provide factories for creating the default scheduler instances </Title>
 <Description>Unlike other hooks the RxJava Schedulers Hook has no access to the real Scheduler instances in order to do wrapping delegation With these factory methods a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulers For Android this wrapping delegation usecase is important for UI testing We have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre empty This is easy to do currently but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under test These three methods are referenced in and I think providing the defaults is useful as well as eventually adding overloads which take ThreadFactory instances for each </Description>
 <CreatedDate>13/04/2016</CreatedDate>
 <ClosedDate>18/04/2016</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3868</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fix anunsubscribe race in Event Loop Worker</Title>
 <Description>There is an unsubscribe race condition similar to in Cached Thread Scheduler Event Loop Worker and Event Loops Scheduler Event Loop Worker Image the following Execution order  Execution Order thread thread   submit task A  submit task B  unsubscribe Worker  unsubscribe task A  task A wont run as its unsubscribed  run task B  unsubscribe task B So task B will run but its previous task A will be skipped This PR adds a check before running an action and moves worker Under Concurrent Unsubscribe Should Not Allow Later Tasks To Run Due To Unsubscription Race to Abstract Scheduler Concurrency Tests to test all concurrent schedulers 
</Description>
 <CreatedDate>20/04/2016</CreatedDate>
 <ClosedDate>20/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3868</PullRequestID>
 <IssueID>3842</IssueID>
 <Title>improve Executor Scheduler worker unsubscription</Title>
 <Description>I noticed that when a worker built from Schedulers from E ecutors new Fixed Thread is unsubscribed the use of a CompositeSubscription to track task subscriptions means that the tasks may be unsubscribed in any old order CompositeSubscription holds its subscriptions in a HashSet This means that if the worker is given task A and task B then the race can prevent A from running but allow B to run Ive included a unit test in this PR that demos it Fails every time on my machine on the first loop This PR is really for discussion about the problem and possible fi es I have included a possible fiwhich is to track overall subscription using a volatile boolean and check that boolean before running any task If this was considered the way to go some further simplification would take place in the operator might not need to check individual task subscriptions I havent checked other schedulers for this sort of problem yet </Description>
 <CreatedDate>07/04/2016</CreatedDate>
 <ClosedDate>08/04/2016</ClosedDate>
 <Labels>
<Label>Cleanup</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3867</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>1 improveE ecutorSchedulerworkerunsubscriptionsomemore</Title>
 <Description>As per discussion in there was an outstanding possibility that unsubscription of a Worker would not cancel all tasks waiting in the queue This PR addresses that possibility I attempted to provoke the condition in a unit test but didnt manage it Nethertheless I think this change completes the protection desired in I do have mixed feelings about the possible double calling of queue clear once in the run method and once in the unsubscribe method Any preferences </Description>
 <CreatedDate>19/04/2016</CreatedDate>
 <ClosedDate>20/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Cleanup</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3867</PullRequestID>
 <IssueID>3842</IssueID>
 <Title>improve Executor Scheduler worker unsubscription</Title>
 <Description>I noticed that when a worker built from Schedulers from Executors new Fixed Thread is unsubscribed the use of a Composite Subscription to track task subscriptions means that the tasks may be unsubscribed in any old order Composite Subscription holds its subscriptions in a HashSet This means that if the worker is given task A and task B then the race can prevent A from running but allow B to run Ive included a unit test in this PR that demos it Fails every time on my machine on the first loop This PR is really for discussion about the problem and possible fi es I have included a possible fiwhich is to track overall subscription using a volatile boolean and check that boolean before running any task If this was considered the way to go some further simplification would take place in the operator might not need to check individual task subscriptions I havent checked other schedulers for this sort of problem yet </Description>
 <CreatedDate>07/04/2016</CreatedDate>
 <ClosedDate>08/04/2016</ClosedDate>
 <Labels>
<Label>Cleanup</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3867</PullRequestID>
 <IssueID>3842</IssueID>
 <Title>improve ExecutorScheduler worker unsubscription</Title>
 <Description>I noticed that when a worker built from Schedulers from E ecutors new Fixed Thread  is unsubscribed the use of a Composite Subscription to track task subscriptions means that the tasks may be unsubscribed  in any old order Composite Subscription holds its subscriptions in a HashSet This means  that if the worker is given task A and task B then the race can prevent A from running but allow B to run Ive included a unit test in this PR that demos it Fails every time on my machine on the first loop This PR is really for discussion about the problem and possible fi es I have included a possible fiwhich is to track overall subscription using a volatile boolean and check that boolean before running any task If this was considered the way to go some further simplification would take place in the operator might not need to check individual task subscriptions I havent checked other schedulers for this sort of problem yet </Description>
 <CreatedDate>07/04/2016</CreatedDate>
 <ClosedDate>08/04/2016</ClosedDate>
 <Labels>
<Label>Cleanup</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3866</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>1 AddSingle toCompletable</Title>
 <Description>Closes 3865 
</Description>
 <CreatedDate>18/04/2016</CreatedDate>
 <ClosedDate>19/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3866</PullRequestID>
 <IssueID>3865</IssueID>
 <Title>flatMap from Single to Completable</Title>
 <Code>
public Completable call Data data {
return saveData data ;
}};
 </Code>
 <Description>Is there an easy way of doing a flatMap from a Single to a Completable Currently I need to do something like this </Description>
 <CreatedDate>18/04/2016</CreatedDate>
 <ClosedDate>19/04/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3856</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>JakeWharton</FixedByID>
 <Title>Provide factories for creating the default scheduler instances </Title>
 <Description>Unlike other hooks the RxJava Schedulers Hook has no access to the real Scheduler instances in order to do wrapping delegation With these factory methods a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulers For Android this wrapping/delegation usecase is important for UI testing We have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre empty This is easy to do currently but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under test These three methods are referenced in and I think providing the defaults is useful as well as eventually adding overloads which take ThreadFactory instances for each </Description>
 <CreatedDate>13/04/2016</CreatedDate>
 <ClosedDate>18/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3856</PullRequestID>
 <IssueID>3724</IssueID>
 <Title>APIs for easily changing the thread priority of default schedulers via hook </Title>
 <Description>On Android the main thread is a sacred holy land at which we must all worship As such this means other threads ideally shouldnt be favorably scheduled in priority with it For network and filesystem operations this usually means using low priority threads One solution is to just use low priority threads on our own schedulers but this doesnt affect code using the standard io and computation schedulers Unfortunately theres a whole bunch of ceremony around how various schedulers are initialized which includes a mi ed bag of public vs nonpublic types and APIs which makes replacing them in a scheduler hook difficult I think the most easy way to accomplish this is the following ~~ R ThreadFactory constructor overload which takes a thread priority to use ~~ Not needed Factory methods on Schedulers for creating instances of iocomputationand newThread e cept using a supplied ThreadFactory Schedulers createIoScheduler ThreadFactory Schedulers createComputationScheduler ThreadFactory Schedulers createNewThreadScheduler ThreadFactory Nice to have Schedulers using these factory methods to create the default implementations This involves moving the thread factories from the individual types "up" to Shedulers </Description>
 <CreatedDate>21/02/2016</CreatedDate>
 <ClosedDate>29/04/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3845</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix delay Subscription Observable unsubscription before triggered</Title>
 <Description>The serial subscription in the delay Subscription Observable operator was not chained properly and thus an unsubscription before any events by the other didnt prevent the subscription to the main source Reported in </Description>
 <CreatedDate>08/04/2016</CreatedDate>
 <ClosedDate>08/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3845</PullRequestID>
 <IssueID>3844</IssueID>
 <Title>delay Subscription Observable breaks upstream unsubscription</Title>
 <Code> 
 public void testWithSubjects {
 PublishSubject&lt;Integer&gt; delayUntil = PublishSubject create ;
 PublishSubject&lt;Integer&gt; interrupt = PublishSubject create ;
 final AtomicBoolean subscribed = new AtomicBoolean false ;
 }
 </Code>
 <Description>This test case is failing tested with I stumbled upon this using Completable and Then which delegates to delay Subscription </Description>
 <CreatedDate>08/04/2016</CreatedDate>
 <ClosedDate>09/04/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3829</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>Add system property for disabling usage of Unsafe API</Title>
 <Description>Part of related to
</Description>
 <CreatedDate>04/04/2016</CreatedDate>
 <ClosedDate>04/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3829</PullRequestID>
 <IssueID>3459</IssueID>
 <Title>No Such Field Exception unsubscribed</Title>
 <Code>
 </Code>
 <stacktrace>
 java lang NoSuchFieldE ception unsubscribed
java lang Class getDeclaredField Class java 929 
java util concurrent atomic AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl &lt;init&gt; AtomicIntegerFieldUpdater java 251 
java util concurrent atomic AtomicIntegerFieldUpdater newUpdater AtomicIntegerFieldUpdater java 49 
r subscriptions BooleanSubscription &lt;clinit&gt; SourceFile 32 
r subscriptions Subscriptions create SourceFile 75 
r subjects SubjectSubscriptionManager addUnsubscriber SourceFile 68 
r subjects SubjectSubscriptionManager call SourceFile 58 
r subjects SubjectSubscriptionManager call SourceFile 35 
r Observable subscribe SourceFile 7803 
r Observable subscribe SourceFile 7531 
 </stacktrace>
 <Description>No Such Field Exception unsubscribed</Description>
 <CreatedDate>19/10/2015</CreatedDate>
 <ClosedDate>09/02/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3829</PullRequestID>
 <IssueID>3815</IssueID>
 <Title>1 Provide public constant instead of Unsafe Access is Unsafe Available </Title>
 <Description>Motivation save some nanoseconds on JVM and a little bit more on Android new construction will also be easier for JIT </Description>
 <CreatedDate>31/03/2016</CreatedDate>
 <ClosedDate>18/04/2016</ClosedDate>
 <Labels>
<Label>Cleanup</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3823</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Do After Terminate handle if action throws</Title>
 <Description>Fixes the bug reported in  
</Description>
 <CreatedDate>02/04/2016</CreatedDate>
 <ClosedDate>04/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3823</PullRequestID>
 <IssueID>3435</IssueID>
 <Title>Operator Finally calls action twice if action throws exception Exception thrown by action is swallowed</Title>
 <Description>While I was implementing Ive found two problems with OperatorFinally Ill call Operator Finally action as finally Action for better readability    If finallyAction is null Null Pointer Exception will be swallowed by Safe Subscriber this can be solved via action  null check in the Operator Finally Ill make PR If finallyAction throws exception  lift calls on Error and Operator Finally invokes finally Action again this may brake userdefined logic And second exception is swallowed by the Safe Subscriber see problem I vote for solving both of these problems before </Description>
 <CreatedDate>10/10/2015</CreatedDate>
 <ClosedDate>14/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3822</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>1 makedefensivecopyofthepropertiesinRxJavaPlugins</Title>
 <Description>Possible solution to 3749 
</Description>
 <CreatedDate>02/04/2016</CreatedDate>
 <ClosedDate>04/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3822</PullRequestID>
 <IssueID>3749</IssueID>
 <Title>Concurrent Modification Exception in RxJava Plugins get Plugin Implementation Via Property</Title>
 <stacktrace>
try {
        computeUnreadUnSyncedConversationCount ;
 } catch Exception e {
        Tmber e e "Error while computing Unread Unsynced Conversation Count" ;
  }
 </stacktrace>
 <Code> 
Caused by java util ConcurrentModificationE ception
 at java util Hashtable$HashIterator NextEntry Hashtable java 727 
 at java util Hashtable$EntryIterator Next Hashtable java 778 
 at java util Hashtable$EntryIterator Next Hashtable java 776 
 at r plugins RxJavaPlugins getPluginImplementationViaProperty RxJavaPlugins java 177 
 at r plugins RxJavaPlugins getSchedulersHook RxJavaPlugins java 232 
 at r schedulers Schedulers Schedulers java 
 at r schedulers Schedulers Schedulers java 
 </Code>
 <Description>I am using RxJava on Android and getting the following error Full detail here</Description>
 <CreatedDate>11/03/2016</CreatedDate>
 <ClosedDate>14/04/2016</ClosedDate>
 <Labels>
<Label>PR welcome</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3818</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>1 fromCallableExperimentalBeta</Title>
 <Description>Part of 3816
</Description>
 <CreatedDate>31/03/2016</CreatedDate>
 <ClosedDate>07/04/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>API promotion</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3818</PullRequestID>
 <IssueID>3816</IssueID>
 <Title>Make defer wait until request before calling Func</Title>
 <Code> 
AtomicBoolean b = new AtomicBoolean ;
TestSubscriber s = new TestSubscriber;
 </Code>
 <Description>Currently the defer operator calls its supplied Func0 immediately upon subscription as documented Because this operator is usually used to delay work of some kind this can prematurely trigger that work before the downstream consumer actually requests a nonzero amount A failing test to illustrate In this test the "work" aka b get ran before the downstream consumer actually wanted a value produced If you think of b get as say an HTTP request or something based on time etc the problem becomes more clear I havent looked but I would guess that defer s behavior was implemented prior to the backpressure concept being introduced Ill leave it up to the library maintainers to determiNexthe risk of changing the behavior but I want to again note oNexthing which started this conversation from comments in 3780 there currently doesnt e ist an easy sane stable API for deferring work that is backpressure aware as described above So if its determined to be too risky to alter deferfasttracking fromCallable to stable and things like SyncOnSubscribe would be useful This is of great concern to library developers not so much application developers where only stable APIs can safely be used </Description>
 <CreatedDate>31/03/2016</CreatedDate>
 <ClosedDate>31/03/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3809</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix merge flat Map crashing on an inner scalar of null</Title>
 <Description>This crash happens on contention where a scalar null value has to go through the scalar queue which doesnt support nulls and requires Notification Lite transformations The drain side had the proper get Value in place already Reported in </Description>
 <CreatedDate>29/03/2016</CreatedDate>
 <ClosedDate>29/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3809</PullRequestID>
 <IssueID>3808</IssueID>
 <Title>Null Pointer Exception caused by null elements in merge queue</Title>
 <Code> 
 Override public void onError Throwable e {
 e printStackTrace ;
 }

 Override public void onStart {
 request 1 ;
 }

 Override public void onCompleted { }
 } ;
 </Code>
 <stacktrace>
 java lang NullPointerE ception
 at r internal util atomic SpscUnboundedAtomicArrayQueue offer SpscUnboundedAtomicArrayQueue java 71 
 at r internal operators OperatorMerge$MergeSubscriber queueScalar OperatorMerge java 465 
 at r internal operators OperatorMerge$MergeSubscriber tryEmit OperatorMerge java 437 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 228 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 142 
 at r internal operators OperatorMap$1 onNext OperatorMap java 54 
 at r internal operators OnSubscribeRange$RangeProducer fastpath OnSubscribeRange java 126 
 at r internal operators OnSubscribeRange$RangeProducer request OnSubscribeRange java 63 
 at r Subscriber setProducer Subscriber java 211 
 at r Subscriber setProducer Subscriber java 205 
 at r internal operators OnSubscribeRange call OnSubscribeRange java 38 
 at r internal operators OnSubscribeRange call OnSubscribeRange java 26 
 at r Observable$2 call Observable java 162 
 at r Observable$2 call Observable java 154 
 at r Observable$2 call Observable java 162 
 at r Observable$2 call Observable java 154 
 at r Observable subscribe Observable java 8191 
 at r Observable subscribe Observable java 8158 
 at net danlew e periments Tester main Tester java 39 
 at sun reflect NativeMethodAccessorImpl invoke0 Native Method 
 at sun reflect NativeMethodAccessorImpl invoke NativeMethodAccessorImpl java 62 
 at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43 
 at java lang reflect Method invoke Method java 497 
 at com intellij rt Execution application AppMain main AppMain java 144 
Caused by r exceptions OnErrorThrowable$OnNextValue OnError while emitting onNext value 1
 at r exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 109 
 at r exceptions exceptions throwOrReport exceptions java 187 
 at r internal operators OperatorMap$1 onNext OperatorMap java 56 
 18 more

 </stacktrace>
 <Description>Take a look at this admittedly somewhat wonky sample stream Im running into in more complecode where the requests is different than the items pushed and seeing the same problem </Description>
 <CreatedDate>29/03/2016</CreatedDate>
 <ClosedDate>02/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3790</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>Expose Single lift</Title>
 <Description>Closes </Description>
 <CreatedDate>23/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>API promotion</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3790</PullRequestID>
 <IssueID>3161</IssueID>
 <Title>lift final Operator extends R super T has private access in Single</Title>
 <Description>I was expecting Single lift to be part of the public API like Observable lift Is there a reason for this restriction Single compose is public too and links to lift in the docs I guess the private access is just a bug My workaround </Description>
 <CreatedDate>15/08/2015</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <Labels>
<Label>PR welcome</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3789</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>Prevent Single zip of zero Singles</Title>
 <Description>Closes</Description>
 <CreatedDate>23/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3789</PullRequestID>
 <IssueID>3784</IssueID>
 <Title>Single zip on empty collection never terminate</Title>
 <Code> 
Observable zip new ArrayList&lt;Observable&lt;Integer&gt;&gt;i &gt; 
 </Code>
 <Description> </Description>
 <CreatedDate>20/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3787</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix Group By delaying group completion till all groups were emitted</Title>
 <Description>In groupBy was fixed to properly honor backpressure on the outer Observable The change included a drain loop that emitted onCompleted to the groups only when all Grouped Observable s were drained from the main queue This delayed the groups completion unnecessarily causing the concat operator to hang in some source consumer cases such as This PR fixes the behavior by signalling onCompleted to the groups the moment the main completes Note however that concatenating groups is eventually proNexto hangs due to the groups not completing until the source completes thus concat cant switch to the Next source One should use flatMap or concatMapEager instead </Description>
 <CreatedDate>21/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3787</PullRequestID>
 <IssueID>3775</IssueID>
 <Title>concat cant display all the groupedBy observers on version</Title>
 <Code> 
 SimpleDateFormat sdf = new SimpleDateFormat "MM/yyyy" ;
 String groupedStr = sdf format new Date appInfo getLastUpdateTime ;
 </Code>
 <Description>Here are the code Im using to test I got this result which apparently is not correct I only got three results device but it should be like this as shown on the RxJava essential code image This problem never occurs on Version</Description>
 <CreatedDate>17/03/2016</CreatedDate>
 <ClosedDate>02/04/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3777</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>srvaroa</FixedByID>
 <Title>observe On allow configurable buffer size</Title>
 <Description>The observe On operator is backed by a small queue of slots that may overflow quickly on slow producers This could only be avoided by adding a backpressure operator before the observeOn not only inconvenient but also taking a perf hit as it forces hops between two queues This patch allows modifying the default queue size on the observeOn operator Fixes Signed off by Galo Navarro anglorvaroagmail com
</Description>
 <CreatedDate>17/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3777</PullRequestID>
 <IssueID>3751</IssueID>
 <Title>Confusion when using Backpressure operators</Title>
 <Description>HeyWe have a use case in which a consumer might not be able to process items fast enough than what is emitted from a source observable I understood that in this case a backpressure with either onBackPressureBuffer or onBackPressureDrop might be useful In case of overflow / drop we would like to store items to a local storage and try processing them later when the consumer in this case is again able to handle the input rate Our consumer is actually a remote REST call which might timeout or not be available in which case we retry Anyways I tried alternative ways to address the problem but I cant find a suitable way to solve it To illustrate my testings here is some code In testOnBackPressureDrop I would assume that after the emitter has queued some items it would start dropping them However it seems that the backpressure operation subscription gets a receive size of 128 items 128 items in memory in this case is far too much for us and we would like to control the size of the request items In testOnBackPressureBuffer I would assume that the emitter would overflow after emitting more than two items into the buffer However in neither of the cases I dont e perience an oveflow or dropped items Also I realized that when using onBackPressureBuffer it seems that in overflow the observable emits onError To me that wouldnt be an option since I want the emitter to continue and I want to deal with the problem myself Could you please instruct me that what we are missing here or are we trying to do something that is not yet even possible e g is the API missing an operator like onBackPressureBufferAndDrop int capacity Action1 onDrop ?I wrote my tests based on the documentation in </Description>
 <CreatedDate>13/03/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3766</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>artemzinnatullin</FixedByID>
 <Title>Add Single onError Resume Next Func</Title>
 <Description>Closes closes closes whoa issues at a time 
</Description>
 <CreatedDate>14/03/2016</CreatedDate>
 <ClosedDate>15/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3766</PullRequestID>
 <IssueID>3440</IssueID>
 <Title>Single on Error Resume Next</Title>
 <Code>
 </Code>
 <Description>Observable has a on Error ResumeNext to continue with a new Observable if onError is called Id like something similar for Single so Single already has on Error Return it makes sense to have on Error Resume Next as well </Description>
 <CreatedDate>13/10/2015</CreatedDate>
 <ClosedDate>15/03/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3766</PullRequestID>
 <IssueID>3731</IssueID>
 <Title>Request Single on Error Resume Next Func super Throwable Single extends resume Function </Title>
 <Description>To match Observable s </Description>
 <CreatedDate>24/02/2016</CreatedDate>
 <ClosedDate>15/03/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3766</PullRequestID>
 <IssueID>3472</IssueID>
 <Title>Flatmap Single into Observable and ignore errors</Title>
 <Code> 
 </Code>
 <Description>I have UI observable which should work as long as my UI lives When my UI emits I create a network request which could be an Observable or a Single A Single fits best for a network call Single on Error Resume Next is btw only available in 2 Converting my Single to an Observable seems wrong because the network request is a Single </Description>
 <CreatedDate>27/10/2015</CreatedDate>
 <ClosedDate>15/03/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3759</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>concat Map full rewrite delay Error performance</Title>
 <Description>This is a full rewrite of the concat concat Map operator with the following properties using On Subscribe to save on the allocation of lift concat Delay Error and concat Map Delay Error to delay errors to the very end new trampolining logic that also subscribes to the Next source even if requested is zero using concat Map or concat Map Delay Error on a scalar source now bypasses the operator completely and uses Scalar Synchronous Observable scalar Flat Map as well the operator now detects just and empty sources and by passes subscribing accordingly added exceptions Utils to work with composite exceptions and terminal state useful for other similar delaying operators later on concat is now implemented as concat Map which saves on the allocation of an entire map operator Operator Window With Size Test test Back pressure Outer In exact had to be ignored because window doesnt honor backpressure properly and it is fixed in once it has been resolved the test can be reenabled Added varargs constructor to CompositeE ception for convenience avoids creating a list when the number of initial exceptions are known upfront Performance comparison to baseline Windows Java u image </Description>
 <CreatedDate>14/03/2016</CreatedDate>
 <ClosedDate>15/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3759</PullRequestID>
 <IssueID>3678</IssueID>
 <Title>fix counted buffer and window backpressure</Title>
 <Description>This PR fixes the backpressure behavior of the counted buffer and window operators and consists of several changes The main issue lies when count skip in the operators yielding overlapping buffers windows For buffer  when the upstream completed the logic emitted all remaining partial buffers even if there was no request for new buffers which can result in Missing Backpressure Exception  somewhere The proper handling of the final buffers required a new backpressure management algorithm which is now part of the Backpressure  Utils class and consists of two new methods post Complete Done called from on Complete to take over the emission of queued values and post Complete Request  which manages requests before and after the completed state For windowthe new window opened was emitted regardless of requests which was common due to request amplification i e  requesting n windows results in requesting count skip elements at first then skipn later which opens ceil count skip windows upfront To avoid the overflow the individual  windows have to go through the usual queue drain logic as well Ive also updated the Javadoc to reflect the back pressure behavior along with parameter validation In addition  the window case didnt manage cancellation properly When the outer observable is unsubscribed the inner subscribers may be still going and thus cancelling the upstream would stop hang  the inner windows Instead the open window count is tracked also counting the outer as 1 window and when all get unsubscribed i e count reaches zerothe upstream is unsubscribed  To accomplish this the UnicastSubject had to be retrofitted with a new optional callback Action which gets called at most once whenever either on Error or on Completed is called  or when the single Subscriber unsubscribes A secondary issue was with the Test Subscriber s initial request; some upstream operators could get  triggered with Long MAX VALUE despite the initial request amount was set This PR changes it to be set at construction time instead of in onStart </Description>
 <CreatedDate>08/02/2016</CreatedDate>
 <ClosedDate>18/03/2016</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3756</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>clarify join group Join no ordering guarantees</Title>
 <Description>Original issue 
</Description>
 <CreatedDate>14/03/2016</CreatedDate>
 <ClosedDate>14/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3756</PullRequestID>
 <IssueID>3616</IssueID>
 <Title>Join operator incorrect sequence</Title>
 <Description>I found a weird bug where join operator is emitting incorrect sequence in some Android devices Here is the block of code that I am using I suspect the cause is because its using Hash Map to store left and right emitted values Causing incorrect order in the values since Hash Map cannot guarantee the order of the entries It should uses Linked Hash Map to maintain the order of the entries Any thoughts Or did I miss something here Thanks</Description>
 <CreatedDate>14/01/2016</CreatedDate>
 <ClosedDate>14/03/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3754</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>measure flat Map concat Mapper for mance when used as filter</Title>
 <Description>This PR adds a class to measure the overhead of using empty when the flat Map concat Map emulates filter This will establish the comparison baseline for flatMap concatMap optimization as requested in` The baseline numbers https gist github com image https cloud github user content com assets Comparing flatMap against concat Map image https cloud github user content com assets Here mask indicates the andmask that makes emitting empty less frequent always every other every fourth every eighth This also means that range Empty starts emitting more and more values with higher mask value hence the different throughput values </Description>
 <CreatedDate>13/03/2016</CreatedDate>
 <ClosedDate>13/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Performance</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3754</PullRequestID>
 <IssueID>1653</IssueID>
 <Title>Optimisations with Observable empty </Title>
 <Description>I notice that calling observable concat Observable empty invokes backpressure Id find it useful if when I used Observable empty that optimisations came into play such as ensuring that observable concat Observable empty simply returned observable To achieve this Id make a private constant EMPTY = from new ArrayList in Observable so that calling Observable empty always returned this object cast into the appropriate generic type Then Id use a simple object reference equality test to determine if an optimisation could be made Do you think this proposal has legs? If so Ill knock up a PR I would seek to optimise more than just the concat operatorit would include merge and possibly others which I can think about if the time comes </Description>
 <CreatedDate>01/09/2014</CreatedDate>
 <ClosedDate>05/05/2016</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3753</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>fix Serialized Observer Test test Notification Delay</Title>
 <Description>This PR fixes the Serialized ObserverTest test NotificationDelay test to use reentrancy to verify the buffer in Serialized Observer is properly drained For now it loops times to see if the CI brings up the issue again Takes  ms on my machine but Ill probably reduce it to times  The previous version was a bit convoluted with all those countdowns that didnt properly lock out the other thread Reported in issue  </Description>
 <CreatedDate>13/03/2016</CreatedDate>
 <ClosedDate>14/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Test</PullRequestLabel>
 <PullRequestLabel>TestFailures</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3753</PullRequestID>
 <IssueID>1389</IssueID>
 <Title>Serialized Observer Test test Nofication Delay not deterministic</Title>
 <Description>This test is failing of the time on my old laptop and if I bump up n to on a modern desktop it fails all the time My laptop runs ubuntu  virtual processors java runtime and failed out of tests with  My desktop runs ubuntu eon virtual processors java runtime and fails every time after gets between and The line failing is line assert Same </Description>
 <CreatedDate>26/06/2014</CreatedDate>
 <ClosedDate>14/03/2016</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3752</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Single using</Title>
 <Description>This PR adds the factory method using overload to Single as requested in For convenience Ive also added Single subscribe Observer 
</Description>
 <CreatedDate>13/03/2016</CreatedDate>
 <ClosedDate>14/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3752</PullRequestID>
 <IssueID>3732</IssueID>
 <Title>Request Single using</Title>
 <Description>To match Observable using </Description>
 <CreatedDate>24/02/2016</CreatedDate>
 <ClosedDate>23/03/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3741</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>aaronweihe</FixedByID>
 <Title>Add do On Subscribe for Single</Title>
 <Description>Ref I didnt write much unit tests for do On Subscribe because it internally uses Operator Do On Subscribe which is well covered </Description>
 <CreatedDate>02/03/2016</CreatedDate>
 <ClosedDate>03/03/2016</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>3733</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>loganj</FixedByID>
 <Title>Avoid swallowing errors in Completable</Title>
 <Description>Instead deliver them up to the threads uncaught exception handler Fixes reactive RxJava
</Description>
 <CreatedDate>24/02/2016</CreatedDate>
 <ClosedDate>02/03/2016</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3733</PullRequestID>
 <IssueID>3726</IssueID>
 <Title>Completable subscribe swallows errors by default</Title>
 <Code>
 public void onError Throwable e {
ERROR_HANDLER handleError e ;
 }

 public final void onError Throwable e {
throw new OnErrorNotImplementedE ception e ;
 }
 </Code>
 <Description>The default behavior of Completable subscribe for errors is different from that of Observable or Single Errors in Completable are just passed to RxJava ErrorHandler which does nothing by default While Observable and Single cause runtime On Error Not Implemented Exception which is expected Completable java
 </Description>
 <CreatedDate>23/02/2016</CreatedDate>
 <ClosedDate>02/03/2016</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3342</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>KevinTCoughlin</FixedByID>
 <Title>Remove redundant on Start implementation in Operator Group By</Title>
 <Description>Addresses Removes a redundant on Start implementation in Operator GroupBy 
</Description>
 <CreatedDate>12/09/2015</CreatedDate>
 <ClosedDate>07/10/2015</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3342</PullRequestID>
 <IssueID>3067</IssueID>
 <Title>Operator Group By redundant on Start implementation</Title>
 <Description>These lines are redundant Im concerned that there is some intent behind placing these lines here that is not honoured akarnokd looks like you put these lines here what do you think The same goes for Operator Do On Unbsubscribe </Description>
 <CreatedDate>07/07/2015</CreatedDate>
 <ClosedDate>09/11/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3286</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>hyleung</FixedByID>
 <Title>Implements Blocking Single</Title>
 <Description>Adds Blocking Single issue the blocking version of Single Blocking Single has the following methods from Single factory method for creating a Blocking Single from a Single value returns the value emitted from the Single to Futurere turns a java util concurrent Future Couldnt actually think of any other useful operations to perform on Blocking Single in comparison to Blocking Observable theres not much to this class at the moment </Description>
 <CreatedDate>02/09/2015</CreatedDate>
 <ClosedDate>11/11/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Discussion</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3286</PullRequestID>
 <IssueID>3252</IssueID>
 <Title>Add Single toBlocking?</Title>
 <Description>Now that we have Single would it make sense to add a to Blocking method on the Single that would return the blocking version of the Single similar to Observable to Blocking Given that Single either returns a single item or fails Id imagine it would be pretty minimal I took a stab at it here just a get to return the value and to Future at the moment couldnt think of anything else that would be useful on a blocking Single </Description>
 <CreatedDate>30/08/2015</CreatedDate>
 <ClosedDate>12/11/2015</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>3256</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixed debounce behavior added throttle First throttle Last alias</Title>
 <Description>Ive implemented the wrong debounce logic in 
</Description>
 <CreatedDate>31/08/2015</CreatedDate>
 <ClosedDate>31/08/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>3256</PullRequestID>
 <IssueID>3254</IssueID>
 <Title>Operator debounce time select or throttle With Timeout alias </Title>
 <Description> Taking a break from window operators </Description>
 <CreatedDate>31/08/2015</CreatedDate>
 <ClosedDate>31/08/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2985</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>improve Operator Serialize Test test Multi Threaded With NPE in Middle</Title>
 <Description>to address have made it much more improbable that the error emission is the last thread to complete by only failing the test if the error emission is the last for repeats I chose to keep the runtime low average 
</Description>
 <CreatedDate>27/05/2015</CreatedDate>
 <ClosedDate>27/05/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>TestFailures</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2985</PullRequestID>
 <IssueID>2870</IssueID>
 <Title>Nondeterministic test OperatorSerializeTest testMultiThreadedWithNPEinMiddle</Title>
 <Code>
java lang AssertionError
 at org junit Assert fail Assert java 92 
 at org junit Assert assertTrue Assert java 43 
 at org junit Assert assertTrue Assert java 54 
 at r internal operators OperatorSerializeTest testMultiThreadedWithNPEinMiddle OperatorSerializeTest java 134 
 </Code>
 <Description>Took loops of gradlew clean test to show itself </Description>
 <CreatedDate>10/04/2015</CreatedDate>
 <ClosedDate>28/08/2015</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2983</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixed multiple calls toon Start </Title>
 <Description>Started investigating multiple calls to on Start based on and found a bunch but since on Start can be overridden I might have missed cases In addition Ive found a single place where a producer is set twice on a subscriber but again many other places may exist 
</Description>
 <CreatedDate>26/05/2015</CreatedDate>
 <ClosedDate>17/06/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2983</PullRequestID>
 <IssueID>2979</IssueID>
 <Title>Subscriber on Start is called twice on nested unsafe Subscription</Title>
 <Code>
public void testOnStartCalledOnceViaNestedUnsafeSubscribe {
 final AtomicInteger c = new AtomicInteger ;
 Observable defer new Func0&lt;Observable&lt;Integer&gt;&gt; {
 Override public Observable&lt;Integer&gt; call {
return Observable just 1 2 3 4 take 2 ;
 }
 } unsafeSubscribe new Subscriber&lt;Integer&gt; {
 Override public void onStart {
c incrementAndGet ;
request 1 ;
 }

 Override public void onCompleted { }

 Override public void onError Throwable e { }

 Override public void onNext Integer t {
request 1 ;
 }
 } ;

}
 </Code>
 <Description>This test shows the on Start called twice problem It is a clone of Subscriber Test test On Start Called Once Via Unsafe Subscribe but adding the defer operator which calls  unsafe Subscribe resulting in a nested call to unsafe Subscribe the one from the test and the second one from On Subscribe Defer  Two proposed solutions first one looks ugly second one adds more code to Subscriber Add a parameter to subscription calls to transfer the onStart called state  Modify Subscriber so subscribe unsafe Subscribe calls Subscriber start which delegates to the actual onStart protecting for duplicate calls </Description>
 <CreatedDate>22/05/2015</CreatedDate>
 <ClosedDate>07/07/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2972</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixed window time to work properly with unsubscription added</Title>
 <Description>backpressure support to window size skip See </Description>
 <CreatedDate>20/05/2015</CreatedDate>
 <ClosedDate>17/06/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2972</PullRequestID>
 <IssueID>1880</IssueID>
 <Title>JVM Doesnt Exit On This Window Example</Title>
 <Code> 
public static Observable&lt;Integer&gt; hotStream {
	return Observable create Subscriber&lt;? super Integer&gt; s &gt; {
	int i = 0;
	
		try {
		 // sleep for a random amount of time
		 // NOTE Only using Thread sleep here as an artificial demo 
		 Thread sleep long Math random100 ;
		} catch Exception {
		 // do nothing
		}
	
}
 </Code>
 <Description>Something about this doesnt let the JVM exit</Description>
 <CreatedDate>14/11/2014</CreatedDate>
 <ClosedDate>13/08/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2970</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>DeprecatedonBackpressureBlock</Title>
 <Description>See 2799 for reasons to deprecate 
</Description>
 <CreatedDate>20/05/2015</CreatedDate>
 <ClosedDate>17/06/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Documentation</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2970</PullRequestID>
 <IssueID>2799</IssueID>
 <Title>on Back pressure Block causes hangs</Title>
 <Description>Given this piece of code If we switch order of subscribe observe On observe On before subscribe Onit will work as e pected Also it will throw Missing  Backpressure Exception without on Backpressure as expected </Description>
 <CreatedDate>04/03/2015</CreatedDate>
 <ClosedDate>28/08/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2969</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Operator cache now supports backpressure</Title>
 <Description>Ive removed the controversial features and made the backing Cached Observable internal Related issue </Description>
 <CreatedDate>20/05/2015</CreatedDate>
 <ClosedDate>17/06/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2969</PullRequestID>
 <IssueID>1483</IssueID>
 <Title>Backpressure cache</Title>
 <Description>The cache operator should support downstream backpressure It should request Long MAx VALUE up but be capable of correctly responding to downstream similar to from Iterable This will mean we either have to stop using Replay Subject or be able to handle it with Replay Subject in the mi The idea here is that once data is cached it should behave as an  Iterable Therefore the cache really should behave like on Back pressure Buffer </Description>
 <CreatedDate>23/07/2014</CreatedDate>
 <ClosedDate>13/08/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2934</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix termination race condition in Operator Publish dispatch</Title>
 <Description>Fixes the cause of </Description>
 <CreatedDate>06/05/2015</CreatedDate>
 <ClosedDate>06/05/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2934</PullRequestID>
 <IssueID>2933</IssueID>
 <Title>Non deterministic test OperatorPublishTest test Observe On</Title>
 <Code>
 </Code>
 <stracktrace>
 r internal operators OperatorPublishTest &gt; testObserveOn FAILED
 java lang AssertionError e pected &lt;1000&gt; but was &lt;994&gt;
 at org junit Assert fail Assert java 93 
 at org junit Assert failNotEquals Assert java 647 
 at org junit Assert assertEquals Assert java 128 
 at org junit Assert assertEquals Assert java 472 
 at org junit Assert assertEquals Assert java 456 
 at r internal operators OperatorPublishTest testObserveOn OperatorPublishTest java 
 </stacktrace>
 <Description>Occurred in Travis build </Description>
 <CreatedDate>06/05/2015</CreatedDate>
 <ClosedDate>06/05/2015</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2912</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix the performance degradation due to different schedule Execution and</Title>
 <Description>Subscription List add and thread unparking This PR partially reverts some changes from earlier scheduler optimizations and fi es a case where if multiple concurrent schedule calls happen the order in the SubscriptionList might be different from the actual Execution order which degrades performance on task termination due to remove being On This might be the source of degradation in as well Ill post the Computation Scheduler Perf results later </Description>
 <CreatedDate>23/04/2015</CreatedDate>
 <ClosedDate>30/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2912</PullRequestID>
 <IssueID>2857</IssueID>
 <Title>Performance issues after upgrading from</Title>
 <Code>
 </Code>
 <stacktrace>
 Stack Trace Sample Count Percentage % 
java util concurrent locks LockSupport unpark Thread 1113 76 233
 java util concurrent locks AbstractQueuedSynchronizer unparkSuccessor AbstractQueuedSynchronizer$Node 1113 76 233
 java util concurrent locks AbstractQueuedSynchronizer release int 1113 76 233
java util concurrent locks ReentrantLock unlock 1113 76 233
r internal util SubscriptionList remove Subscription 1113 76 233
r internal schedulers ScheduledAction$Remover2 unsubscribe 1113 76 233
 r internal util SubscriptionList unsubscribeFromAll Collection 1113 76 233
 r internal util SubscriptionList unsubscribe 1113 76 233
 r internal schedulers ScheduledAction unsubscribe 1113 76 233
r internal schedulers ScheduledAction run 1113 76 233
java util concurrent E ecutors$RunnableAdapter call 1113 76 233
 java util concurrent FutureTask run 1113 76 233
 java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor$ScheduledFutureTask 1113 76 233
 java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run 1113 76 233
java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor$Worker 1113 76 233
java util concurrent ThreadPoolE ecutor$Worker run 1113 76 233
java lang Thread run 1113 76 233
 </stacktrace>
 <Description>Hello We are seeing high levels of lock contention after our upgrade to RxJava  Apologize for not having a unit test to reproduce this we have a fairly complesystem and we are having trouble figuring out which areas to dig deeper to find a reproducible case This is a paste from a JMC view As far as we know nothing should be getting unsubscribed in our application We would appreciate if anyone can shed some light on what kind of behavior would trigger the stack below </Description>
 <CreatedDate>06/04/2015</CreatedDate>
 <ClosedDate>11/05/2015</ClosedDate>
 <Labels>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2909</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix the drainer to check if the queue is empty before quitting </Title>
 <Description>Reported in The bug is on line If the drainer is delayed after a poll returning null and the emitter producing terminating before the get Count the  queue is non empty but the drainer quits and hence the value difference It comes up almost always if you put a sleep before </Description>
 <CreatedDate>23/04/2015</CreatedDate>
 <ClosedDate>23/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>TestFailures</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2909</PullRequestID>
 <IssueID>2908</IssueID>
 <Title>Nondeterministic test R RingBufferWithoutUnsafeTest testConcurrency</Title>
 <Code>
r internal util R RingBufferWithoutUnsafeTest &gt; testConcurrency FAILED
 java lang AssertionError e pected &lt;6920&gt; but was &lt;6808&gt;
 at org junit Assert fail Assert java 93 
 at org junit Assert failNotEquals Assert java 647 
 at org junit Assert assertEquals Assert java 128 
 at org junit Assert assertEquals Assert java 472 
 at org junit Assert assertEquals Assert java 456 
 at r internal util R RingBufferWithoutUnsafeTest testConcurrency R RingBufferWithoutUnsafeTest java 139 
 </Code>
 <Description>Concurrency failure on R RingBuffer doesnt look good Hopefully a problem with the test only </Description>
 <CreatedDate>23/04/2015</CreatedDate>
 <ClosedDate>23/04/2015</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2899</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>Observable fromemptytoemitonCompleteevenwhen0requested</Title>
 <Description>As per discussion in Observable from iterable is preferred to emit on Completed when iterable is empty even when nothing has been requested This PR adds a check on iterator has Next before the Producer is assigned and emits onCompleted immediately if has Next returns false Includes unit test that failed on e isting code base 
</Description>
 <CreatedDate>21/04/2015</CreatedDate>
 <ClosedDate>21/04/2015</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2899</PullRequestID>
 <IssueID>2884</IssueID>
 <Title>Back pressure and on Complete from an empty observable</Title>
 <Description>What is the preferred behaviour for an observable that supports backpressure but emits nothing when it has been subscribed to with an initial request of Should it report completion as soon as it knows it is empty or wait for a positive request  I notice that reactivestreamsjvm says&gt; A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription request long n call This allows us to go either way when developing an Operator for instance but perhaps RxJava wants to proffer a preferred or mandated direction for its internal operators  benjchristensen FYI viktorklang </Description>
 <CreatedDate>17/04/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2898</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>Observable rangeaddunittestforeagercompletiononempty</Title>
 <Description>As per discussion in 2884 it turns out that range does emit onComplete even when zero is requested because Observable range does not use OperatorRange when the count is zero but rather returns an Observable empty This PR adds a unit test confirming this fact 
</Description>
 <CreatedDate>20/04/2015</CreatedDate>
 <ClosedDate>21/04/2015</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2898</PullRequestID>
 <IssueID>2884</IssueID>
 <Title>Back pressure and on Complete from an empty observable</Title>
 <Description>What is the preferred behaviour for an observable that supports back pressure but emits nothing when it has been subscribed to with an initial request of Should it report completion as soon as it knows it is empty or wait for a positive request I notice that reactivestreamsjvm says&gt; A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription request long n call This allows us to go either way when developing an Operator for instance but perhaps RxJava wants to proffer a preferred or mandated direction for its internal operators benjchristensen FYI viktorklang </Description>
 <CreatedDate>17/04/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2897</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>alexwen</FixedByID>
 <Title>Fix for overlapping windows </Title>
 <Description>Source was emitting multiple times while holding queue Fixes 
</Description>
 <CreatedDate>20/04/2015</CreatedDate>
 <ClosedDate>21/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>2894</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Concat fixed reen trancy proble min complete Inner</Title>
 <Description>Fixes issue 
</Description>
 <CreatedDate>20/04/2015</CreatedDate>
 <ClosedDate>21/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2894</PullRequestID>
 <IssueID>2890</IssueID>
 <Title>Stack overflow with a combination of Buffer Till Subscriber subscribe On and concatMap</Title>
 <Code> Subject&lt;Integer&gt; subject = BufferUntilSubscriber create ;</Code>
 <Description>The following test code eventually fails with a StackOverFlowE ception provided a sufficient large value of n </Description>
 <CreatedDate>18/04/2015</CreatedDate>
 <ClosedDate>21/04/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2883</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Proposal standardized Subject state peeking methods</Title>
 <Description>This PR modifies the Subject class to host the union of the state peeking methods of the various Subject implementations and fixes the inconsistent behavior of Replay Subject get Values The changes enable the Serialized Subject to relay such state peeking method calls into the wrapped subject and allows future Subject wrappers to do the same </Description>
 <CreatedDate>16/04/2015</CreatedDate>
 <ClosedDate>29/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2883</PullRequestID>
 <IssueID>2458</IssueID>
 <Title>Lifting into a Subject</Title>
 <Description>Mildly interesting idea to see if there would be any interest</Description>
 <CreatedDate>15/01/2015</CreatedDate>
 <ClosedDate>19/06/2016</ClosedDate>
 <Labels>
<Label>FeatureRequest</Label>
<Label>PR welcome</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2875</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix NPEinrequestFromChildmethod </Title>
 <Description>Fi es NPE reported in 2874 
</Description>
 <CreatedDate>14/04/2015</CreatedDate>
 <ClosedDate>14/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2875</PullRequestID>
 <IssueID>2874</IssueID>
 <Title>concat Map observe On throws a NullPointer Exception sometimes</Title>
 <Code>
 for (int i = 0; i &lt; 10000000; i++) {
   subject onNext i ;
 }
 </Code>
 <stracktrace>
 Exception in thread "serviceE ecutor1" java lang NullPointerE ception
 at r internal operators OperatorConcat$ConcatSubscriber requestFromChild OperatorConcat java 129 
 at r internal operators OperatorConcat$ConcatSubscriber access$100 OperatorConcat java 78 
 at r internal operators OperatorConcat$ConcatProducer request OperatorConcat java 73 
 at r Subscriber request Subscriber java 141 
 at r internal operators OperatorObserveOn$ObserveOnSubscriber pollQueue OperatorObserveOn java 207 
 at r internal operators OperatorObserveOn$ObserveOnSubscriber access$000 OperatorObserveOn java 65 
 at r internal operators OperatorObserveOn$ObserveOnSubscriber$2 call OperatorObserveOn java 155 
 at r schedulers E ecutorScheduler$E ecutorAction run E ecutorScheduler java 173 
 at r schedulers E ecutorScheduler$E ecutorSchedulerWorker run E ecutorScheduler java 99 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1145 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 615 
 at java lang Thread run Thread java 745 
 </stracktrace>
 <Description>It is difficult to produce this one It occurs in our production service which has a code almost like this </Description>
 <CreatedDate>14/04/2015</CreatedDate>
 <ClosedDate>14/04/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2854</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixes wrong request accounting in Abstract On Subscribe</Title>
 <Description>Fixes</Description>
 <CreatedDate>03/04/2015</CreatedDate>
 <ClosedDate>07/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2854</PullRequestID>
 <IssueID>2853</IssueID>
 <Title>Abstract On Subscribe throws exception when on Next contains a request for more </Title>
 <stracktrace>
 java lang IllegalStateE ception This is not reentrant nor threadsafe
 at r observables AbstractOnSubscribe$SubscriptionState use AbstractOnSubscribe java 590 
 at r observables AbstractOnSubscribe$SubscriptionProducer doNext AbstractOnSubscribe java 360 
 at r observables AbstractOnSubscribe$SubscriptionProducer request AbstractOnSubscribe java 345 
 at r Subscriber request Subscriber java 145 
 at r observables AbstractOnSubscribeTest$20 onNext AbstractOnSubscribeTest java 541 
 at r observables AbstractOnSubscribeTest$20 onNext AbstractOnSubscribeTest java 1 
 at r observers SafeSubscriber onNext SafeSubscriber java 130 
 at r observables AbstractOnSubscribe$SubscriptionState accept AbstractOnSubscribe java 533 
 at r observables AbstractOnSubscribe$SubscriptionProducer doNext AbstractOnSubscribe java 367 
 at r observables AbstractOnSubscribe$SubscriptionProducer request AbstractOnSubscribe java 337 
 at r Subscriber setProducer Subscriber java 175 
 at r Subscriber setProducer Subscriber java 171 
 at r observables AbstractOnSubscribe call AbstractOnSubscribe java 191 
 at r observables AbstractOnSubscribe call AbstractOnSubscribe java 1 
 at r Observable subscribe Observable java 7585 
 at r observables AbstractOnSubscribeTest testCanRequestInOnNext AbstractOnSubscribeTest java 527 

 </stracktrace>
 <Code>
public void onError Throwable e {
exception set e ;
}

Override
public void onNext Integer t {
request 1 ;
}
 </Code>
 <Description> Abstract On Subscribe improperly throws an exception when the on Next method in a subscriber makes a call to request all calls synchronous The error thrown is this </Description>
 <CreatedDate>03/04/2015</CreatedDate>
 <ClosedDate>07/04/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2852</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Change retry When to eagerly ignore an errord sources subsequent events</Title>
 <Description>Fixes both issue and this Stack Overflow
</Description>
 <CreatedDate>02/04/2015</CreatedDate>
 <ClosedDate>02/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2852</PullRequestID>
 <IssueID>2826</IssueID>
 <Title>Why retry method with predicate only retries 2 times</Title>
 <Description>Hi can somebody explain me why following piece of code printing only two times message Retrying And not times as specified in predicate BTW if uncomment do On Error line in this sample  got times message Retrying Any ideas whats going on here </Description>
 <CreatedDate>15/03/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2851</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Add request Long MAX VALUE in on Start to fix the back pressure issue of debounce</Title>
 <Description>Fixed The issue is because Operator Debounce With Time will swallow values but not request more items Just add request Long MAX VALUE since it doesnt support back pressure 
</Description>
 <CreatedDate>01/04/2015</CreatedDate>
 <ClosedDate>02/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2851</PullRequestID>
 <IssueID>2850</IssueID>
 <Title>Using merge with throttle With Timeout leads to Missing Backpressure Exception</Title>
 <Code>
 </Code>
 <stracktrace>
 r exceptions MissingBackpressureE ception
 at r internal util R RingBuffer onNext R RingBuffer java 349 
 at r internal operators OperatorMerge$InnerSubscriber enqueue OperatorMerge java 721 
 at r internal operators OperatorMerge$InnerSubscriber emit OperatorMerge java 698 
 at r internal operators OperatorMerge$InnerSubscriber onNext OperatorMerge java 586 
 at r subjects SubjectSubscriptionManager$SubjectObserver onNext SubjectSubscriptionManager java 224 
 at r subjects PublishSubject onNext PublishSubject java 114 
 at org mpierce RxJava merge E perimentMain lambda$main$0 E perimentMain java 25 
 at org mpierce RxJava merge E perimentMain$$Lambda$1/1685538367 call Unknown Source 
 at r Scheduler$Worker$1 call Scheduler java 120 
 at r internal schedulers ScheduledAction run ScheduledAction java 55 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 511 
 at java util concurrent FutureTask run FutureTask java 266 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 180 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 293 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1142 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 617 
 at java lang Thread run Thread java 745 
 </stracktrace>
 <Description>Repro In text heres what Im doing I have two observables Observable neverand another that emits every  ms I merge those two and throttle With Timeout the result with a long timeout In a few seconds Ill get this Instead I would expect that the combo of merge throttle should simply result in throttle working as expected never emitting in this case </Description>
 <CreatedDate>31/03/2015</CreatedDate>
 <ClosedDate>02/04/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2845</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix for repeat wrong target of request</Title>
 <Description>Fixes 
</Description>
 <CreatedDate>24/03/2015</CreatedDate>
 <ClosedDate>25/03/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2845</PullRequestID>
 <IssueID>2844</IssueID>
 <Title>Concat Map combined with Delay causes a hang</Title>
 <Code> 
 public static void main final String arg throws Exception {
 System out println;
 }
 </Code>
 <Description>The following code Then it prints then and then hangs and doesnt do anything afterward I have no idea whats going on but I dont think that the end piece of code should hang if the first one doesnt I tested with and didnt find any similar looking issue with a quick look </Description>
 <CreatedDate>24/03/2015</CreatedDate>
 <ClosedDate>25/03/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2814</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Operator Publish full rewrite</Title>
 <Description>Complete rewrite of publish and fixed bugs of 
</Description>
 <CreatedDate>10/03/2015</CreatedDate>
 <ClosedDate>30/04/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2814</PullRequestID>
 <IssueID>2810</IssueID>
 <Title>Operator Publish bugs</Title>
 <Code> 
public void testShareReconnect {
 Observable&lt;Integer&gt; source = Observable share ;
 TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt; 
}
 </Code>
 <Description> Reconnect issue The following test fails because in Operator Publish the state get Origin still holds the subscriber of a previous connection Note that blindly evicting values from ss while completing in drainQueues is wrong too because if there is a concurrent subscription in the works its tracking recod in state ss and subscribers may get deleted as well instead of letting it wait for the Next connect davidmoten please look at these issues while you Operator Publish for </Description>
 <CreatedDate>06/03/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2814</PullRequestID>
 <IssueID>2803</IssueID>
 <Title>Operator Publish connect connection should not return null</Title>
 <Description>This is outstanding work from I can have a go at it Next week if noone in a rush </Description>
 <CreatedDate>05/03/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2804</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Observe On through put enhancements</Title>
 <Description>Squashed commits Further optimizations to observe On Using Spsc Array Queue directly in observe On instead of Ring Buffer to avoid the synchronization block Split tracking structure to serial Subscription List and timed Composite Subscription in Event Loops Scheduler which improves  the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying Linked List Benchmark Window Java warmup iteration Since it conflicts with anyway this is PR is to let others verify the optimizations actually work on other  because on my Windows sometimes get significant variance in the throughput during iterations Increased iteration time may be required as well 
</Description>
 <CreatedDate>05/03/2015</CreatedDate>
 <ClosedDate>06/03/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2804</PullRequestID>
 <IssueID>2773</IssueID>
 <Title>ObserveOn performance improvements</Title>
 <Description>Further optimizations to observeOn Using SpscArrayQueue directly in observeOn instead of RingBuffer to avoid the synchronization block Split tracking structure to serial SubscriptionList and timed CompositeSubscription in EventLoopsScheduler which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying LinkedList Benchmark i7 920 Window 764 Java 1 8u31 5 1s warmup 5 5s iteration NotesAt size = 1the throughput varies in a +/ 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there At size = 10 000 my system reached either the cache capacity or the OS schedulers time resolution so there no improvement there on At size = 100 000 and size = 1 000 000 the throughput doubles if I introduce some e tra delay i e via sleep 1 or some e tra work The benchmark generates a lot of garbage due to bo ing switching to a constant emitter increases the throughput subscribeOn 1 000 000 from 91 to 136 Since it conflicts with 2772 anyway this is PR is to let others verify the optimizations actually work on other OSes because on my Windows I sometimes get significant variance in the throughput during iterations Increased iteration time may be required as well </Description>
 <CreatedDate>25/02/2015</CreatedDate>
 <ClosedDate>05/03/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2804</PullRequestID>
 <IssueID>2772</IssueID>
 <Title>Helper methods to schedule tasks non interruptibly on an</Title>
 <Description>Executor Service Replaces By default io and new Thread schedules interruptible tasks computation schedules non interruptible tasks </Description>
 <CreatedDate>25/02/2015</CreatedDate>
 <ClosedDate>06/05/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2788</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fix the bug that publish will cache items when no subscriber</Title>
 <Description>Fixed
</Description>
 <CreatedDate>02/03/2015</CreatedDate>
 <ClosedDate>04/03/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2788</PullRequestID>
 <IssueID>2596</IssueID>
 <Title>Unexpected behavior of publish and connect </Title>
 <Description>I have e perienced some unexpected behaviors of publish and connect in my project Hopefully its not my misunderstanding since Im a newbie to I will use an Observer that simply print on Next on Error onCompleted I expected that after pub connectsource will start emitting and when pub is subscribed after 2 5 sec onNext 0 and onNext 1 will be missed by this subscriber However I got them all together at 2 5 sec and from 3rd second I got the following onNext 2 and so on This looks like a replay behavior to me </Description> <CreatedDate>04/02/2015</CreatedDate>
 <ClosedDate>20/05/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2779</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>Operator Multicast connect connection should not return null</Title>
 <Description>See discussion in Changes include fix for just for Operator Multi cast will do Operator Publish in another PR once have sorted this one out made fields private that had default visibility renamed On Subscribe Multicast Test to Operator Multicast Test addressed a possible race condition that could provoke an IAE when Observable subscribe sub is called with sub null unsubscription occurs between and on old code 
</Description>
 <CreatedDate>28/02/2015</CreatedDate>
 <ClosedDate>02/03/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2779</PullRequestID>
 <IssueID>2774</IssueID>
 <Title>Connectable Observable connect returns a null subscription if already connected</Title>
 <Description>Any posterior connect calls to an already connected Connectable Observable return nullbut I believe the  expected behaviour would be for it to return the subscription created for the first connection</Description>
 <CreatedDate>25/02/2015</CreatedDate>
 <ClosedDate>05/03/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2779</PullRequestID>
 <IssueID>2774</IssueID>
 <Title>ConnectableObservable connect returns a null subscription if already connected</Title>
 <Description>Any posterior connect calls to an already connected Connectable Observable return nullbut I believe the expected behaviour would be for it to return the subscription created for the first connection</Description>
 <CreatedDate>25/02/2015</CreatedDate>
 <ClosedDate>05/03/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2767</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Optimized scalar observe On subscribe On</Title>
 <Description>Redone Note that since the tests create a lot of garbage some perf numbers have quite some error margin some appear to be faster with this PR while others appear to be slower even if they are not affected by the changes 
</Description>
 <CreatedDate>23/02/2015</CreatedDate>
 <ClosedDate>24/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2767</PullRequestID>
 <IssueID>2603</IssueID>
 <Title>Optimized observe subscribeOn</Title>
 <Description>Doing observe On subscribe On on these is essentially the same operation Benchmark results Java Windows Unfortunately the benchmark results were quite hectic even with more warmup and iteration Id say the changes give for the size case but running the same code twice observe On subscribe On gives inconsistent values I suspect the main cause is the GC </Description>
 <CreatedDate>04/02/2015</CreatedDate>
 <ClosedDate>23/02/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2762</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Optimized is Unsubscribed check</Title>
 <Description>Extracted is Unsubscribed optimization from 
</Description>
 <CreatedDate>20/02/2015</CreatedDate>
 <ClosedDate>21/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2762</PullRequestID>
 <IssueID>2603</IssueID>
 <Title>Optimized observe On subscribe On</Title>
 <Description>Doing observe On subscribe On on these is essentially the same operation Benchmark results Java u Windows Unfortunately the benchmark results were quite hectic even with more warmup and iteration Id say the changes give for the size case but running the same code twice observe On subscribe On gives inconsistent values I suspect the main cause is the GC </Description>
 <CreatedDate>04/02/2015</CreatedDate>
 <ClosedDate>23/02/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2760</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>OperatorWithLatestFrom</Title>
 <Description>Named after R JS for issue 405
</Description>
 <CreatedDate>19/02/2015</CreatedDate>
 <ClosedDate>21/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2760</PullRequestID>
 <IssueID>405</IssueID>
 <Title>combine With Most Recent</Title>
 <Description>Im looking for an operation which does the following Whenever Observable emits an item combi Next his item with the most recent item of Observable Illustration I cant find a nice way of doing this Can anyone help me Or do we need to add a new operation to Observable</Description>
 <CreatedDate>23/09/2013</CreatedDate>
 <ClosedDate>23/02/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2759</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>davidmoten</FixedByID>
 <Title>Observable using should use unsafe Subscribe andenableeagerdisposal</Title>
 <Description>See where it was discovered that Observable using used subscribe instead of unsafe Subscribe which provoked a race condition leading to an Illegal Argument Exception from the merge operator This PR uses unsafe Subscribe and adds an overload for using to optionally dispose of resources eagerly just before completion or error The use case for this is a synchronous observable where a downstream operation wants to reuse a resource but because the observable is synchronous the resource cannot get disposed till the downstream completes Unit tests included </Description>
 <CreatedDate>19/02/2015</CreatedDate>
 <ClosedDate>21/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2759</PullRequestID>
 <IssueID>2604</IssueID>
 <Title>Operator Merge Ring Buffer throws Illegal State Exception again</Title>
 <Code>
 </Code>
 <stracktrace>
 java lang IllegalStateE ception This instance has been unsubscribed and the queue is no longer usable 
 at r internal util R RingBuffer onNext R RingBuffer java 346 
 at r internal operators OperatorMerge$InnerSubscriber enqueue OperatorMerge java 721 
 at r internal operators OperatorMerge$InnerSubscriber emit OperatorMerge java 698 
 at r internal operators OperatorMerge$InnerSubscriber onNext OperatorMerge java 586 
 at r internal operators OperatorSubscribeOn$1$1$1 onNext OperatorSubscribeOn java 76 
 at r internal operators OperatorMerge$MergeSubscriber handleScalarSynchronousObservableWithRequestLimits OperatorMerge java 280 
 at r internal operators OperatorMerge$MergeSubscriber handleScalarSynchronousObservable OperatorMerge java 243 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 176 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 120 
 at r internal operators OperatorMap$1 onNext OperatorMap java 55 
 at r internal operators OperatorMerge$MergeSubscriber handleScalarSynchronousObservableWithRequestLimits OperatorMerge java 280 
 at r internal operators OperatorMerge$MergeSubscriber handleScalarSynchronousObservable OperatorMerge java 243 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 176 
 at r internal operators OperatorMerge$MergeSubscriber onNext OperatorMerge java 120 
 at r internal operators OperatorMap$1 onNext OperatorMap java 55 
 at r internal operators NotificationLite accept NotificationLite java 150 
 at r internal operators OperatorMerge$MergeSubscriber drainScalarValueQueue OperatorMerge java 396 
 at r internal operators OperatorMerge$MergeSubscriber drainQueuesIfNeeded OperatorMerge java 343 
 at r internal operators OperatorMerge$MergeSubscriber access$500 OperatorMerge java 120 
 at r internal operators OperatorMerge$MergeProducer request OperatorMerge java 549 
 at r Subscriber request Subscriber java 130 
 at r internal operators OperatorMerge$MergeSubscriber drainQueuesIfNeeded OperatorMerge java 350 
 at r internal operators OperatorMerge$MergeSubscriber access$500 OperatorMerge java 120 
 at r internal operators OperatorMerge$MergeProducer request OperatorMerge java 549 
 at r Subscriber request Subscriber java 130 
 at r internal operators OperatorMerge$MergeSubscriber drainQueuesIfNeeded OperatorMerge java 350 
 at r internal operators OperatorMerge$MergeSubscriber access$500 OperatorMerge java 120 
 at r internal operators OperatorMerge$MergeProducer request OperatorMerge java 549 
 at r internal operators OperatorSubscribeOn$1$1$1$1$1 call OperatorSubscribeOn java 94 
 at r internal schedulers ScheduledAction run ScheduledAction java 47 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 511 
 at java util concurrent FutureTask run FutureTask java 266 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 180 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 293 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1142 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 617 
 at java lang Thread run Thread java 745 
Caused by r exceptions OnErrorThrowable$OnNextValue OnError while emitting onNext value au gov amsa ais Timestamped class
 at r exceptions OnErrorThrowable addValueAsLastCause OnErrorThrowable java 98 
 at r internal operators OperatorMap$1 onNext OperatorMap java 58 
 27 more
 </stracktrace>
 <Description>With Im getting an Illegal State Exception from Operator Merge This is repeatable for me but involves a big input data set being processed in chunks using flat Map on Subscribe so I cant give you a quick test case yet Hopefully just this description is enough otherwise Ill try and distill a test I think it is happening close to completion </Description>
 <CreatedDate>05/02/2015</CreatedDate>
 <ClosedDate>11/03/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>Discussion</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2655</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Switch On Next fix up stream produce replacing the ops own producer</Title>
 <Description>Fix for issue By calling the super child in Switch Subscribers constructor the upstreams merge producer overwrote the producer placed by the Switch On Next operator thus any downstream request went into the upstream an not into the currently active observable 
</Description>
 <CreatedDate>13/02/2015</CreatedDate>
 <ClosedDate>16/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2655</PullRequestID>
 <IssueID>2654</IssueID>
 <Title>sharing a switch Map which produces its result via merge will stop producing after events</Title>
 <Description>The first example uses switchMap and fails with the exception below after events whereas the second e ample uses flat Map and does not fail The third  example shows that switch Map does not fail if the nested observable is not a product of of the merge operator However the other variable is the share on the main  Observable Without this Example works I have called this case Example So you might wonder if it has anything to do with switch Map at all may be just sharing a merged observable will also fail Example 5however this case works fine So were left with  sharing a switch Map which produces its result via merge will stop producing after events But why using RxJava scalar exceptions Missing Back pressure Exception null at internal util RingBuffer 
 <CreatedDate>13/02/2015</CreatedDate>
 <ClosedDate>22/02/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2648</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>TakeWhiledontunsubscribedownstream </Title>
 <Description>Fi es 2647 issue with TakeWhile 
</Description>
 <CreatedDate>11/02/2015</CreatedDate>
 <ClosedDate>11/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2648</PullRequestID>
 <IssueID>2647</IssueID>
 <Title>flat Map doesnt propagate on Complete with unsubscribe of child</Title>
 <Code>
 public static void main String args {
 }
 </Code>
 <Description>The following code hangs forever as it doesnt emit a terminal event </Description>
 <CreatedDate>10/02/2015</CreatedDate>
 <ClosedDate>11/02/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2632</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>simonbasle</FixedByID>
 <Title>Implement hook to renders pecific types in On Next Value</Title>
 <Description>as discussed in allow implementations of RxJava Error Handler to define a rendering behavior for safe and known types to be rendered in the stacktrace of On Next Value 
</Description>
 <CreatedDate>06/02/2015</CreatedDate>
 <ClosedDate>17/03/2015</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2632</PullRequestID>
 <IssueID>2468</IssueID>
 <Title>Proposed improvement on On Next Value stacktrace rendition</Title>
 <Description>Hi I was looking at a stacktrace with On Next Value in it and saw that the last emitted item causing the E ception was indeed logged in the stacktrace as just a classNameas per 1401 see also the rendering code But in some conte ts like for the Couchbase SDK or some other framework using RI think it is acceptable to say that we can identify more types that it makes sense to stringify We can check that these types have a sufficiently performant safe and slim toString implementation to be fully rendered by OnNextValue Offering a mean to let RxJava know about such types would allow the String rendering to be activated in a crosscutting manner without reworking every single stream produced by the framework library to induce additional logging behavior I see two broad ways of achieving such a thingvia an _interface_ in RxJavaeither a marker interface implementing classes would then be rendered by calling their toStringor a functional interface implementing classes would have to define some sort of short performant and safe toStringtoShortString ? to be used by OnNextValue for renderingachieve the same via a RxJava Plugin providing a hook to decide or not if a value should be fully rendered additional method on RxJava Error Handler What do you think about this idea If we can agree on a way of doing this I be happy to contribute it</Description>
 <CreatedDate>20/01/2015</CreatedDate>
 <ClosedDate>28/08/2015</ClosedDate>
 <Labels>
<Label>Discussion</Label>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2630</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Cast back Observer to Subscriber if passed to subscribe Observer</Title>
 <Description>Rebased</Description>
 <CreatedDate>06/02/2015</CreatedDate>
 <ClosedDate>06/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Bug</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2630</PullRequestID>
 <IssueID>2600</IssueID>
 <Title>Make sure we keep a Subscriber subscription when passed as Observer</Title>
 <Description>Fixes</Description>
 <CreatedDate>04/02/2015</CreatedDate>
 <ClosedDate>06/02/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2627</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Flat Map over loads with ma imum concurrency parameter</Title>
 <Description>For issue There is no point in adding ma Concurrent to flat Map Iterable because each iterable is subscribed to sequentially and run to completion 
</Description>
 <CreatedDate>06/02/2015</CreatedDate>
 <ClosedDate>11/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2627</PullRequestID>
 <IssueID>2626</IssueID>
 <Title>Add flat Map variant with ma Concurrent</Title>
 <Description>To allow use of merge Observables ma Concurrent via flatMap we should consider adding a flatMap Func int ma Concurrent overload </Description>
 <CreatedDate>06/02/2015</CreatedDate>
 <ClosedDate>11/03/2015</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2622</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>ChangedObservable emptyintoastatelessconstantobservable </Title>
 <Description>Empty was always stateless so creating a new instance all the time especially through a from Iterable is wasteful Besides onCompleted events dont have to be backpressured Should enable identity based optimizations discussed in   </Description>
 <CreatedDate>05/02/2015</CreatedDate>
 <ClosedDate>06/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>2622</PullRequestID>
 <IssueID>1653</IssueID>
 <Title>Optimisations with Observable empty </Title>
 <Description>I notice that calling observable concat Observable empty invokes backpressure Id find it useful if when I used Observable empty that optimisations came into play such as ensuring that observable concat Observable empty simply returned observable To achieve this Id make a private constant EMPTY from new ArrayList in Observable so that calling Observable empty always returned this object cast into the appropriate generic type Then Id use a simple object reference equality test to determine if an optimisation could be made Do you think this proposal has legs? If so Ill knock up a PR I would seek to optimise more than just the concat operatorit would include merge and possibly others which I can think about if the time comes </Description>
 <CreatedDate>01/09/2014</CreatedDate>
 <ClosedDate>05/05/2016</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>2238</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Fix the bug that cache doesnt unsubscribe the source Observable when th </Title>
 <Description> source is terminated Fix
</Description>
 <CreatedDate>24/12/2014</CreatedDate>
 <ClosedDate>21/01/2015</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>2237</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Make Publish Operator Release Ring Buffer</Title>
 <Description>It was retaining the Ring Buffer reference between subscribes which meant it was never released to the object pool As per discussion in there are other issues in the OperatorPublish implementation but those will be fi ed later This PR is just for fixing the issue related to use of Ring Buffer 
</Description>
 <CreatedDate>24/12/2014</CreatedDate>
 <ClosedDate>24/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>2091</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>alexwen</FixedByID>
 <Title>Added Operator switch If Empty</Title>
 <Description>Like default If Empty but subscribes to and emits the items in an Observable if the source is empty Fixes 
</Description>
 <CreatedDate>19/12/2014</CreatedDate>
 <ClosedDate>03/02/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>1973</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixed test issuing non serialized messages to the subject </Title>
 <Description>Should resolve the test failure of When the main part of the test succeded an on Completed was sent out from the main thread which was not serialized in respect to the on Next issued from the worker thread therefore two replay was attempted sometimes At first the caught Up was seen false the replay was entered but the Next instruction cleared the indecausing the Illegal State Exception </Description>
 <CreatedDate>15/12/2014</CreatedDate>
 <ClosedDate>16/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1973</PullRequestID>
 <IssueID>1972</IssueID>
 <Title>Non deterministic test failure Replay Subject Concurrency Test test Replay Subject Emission Subscription Race</Title>
 <Description>This test randomly failed on my local machi Next his was just recently added cc akarnokd </Description>
 <CreatedDate>15/12/2014</CreatedDate>
 <ClosedDate>26/01/2015</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1965</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fix the issue that Sample doesnt call unsubscribe</Title>
 <Description>Fix
</Description>
 <CreatedDate>12/12/2014</CreatedDate>
 <ClosedDate>15/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>1957</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fix request issue in Scan</Title>
 <Description>didnt all cases</Description>
 <CreatedDate>12/12/2014</CreatedDate>
 <ClosedDate>13/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1957</PullRequestID>
 <IssueID>1904</IssueID>
 <Title>Fithe bug that Scan may request when n is</Title>
 <Description> Scan may request when n is and request makes the source Observable do nothing The unit test demonstrates this bug </Description>
 <CreatedDate>29/11/2014</CreatedDate>
 <ClosedDate>29/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1950</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Add Subscriptions unsubscribed to fix the is Unsubscribed issue</Title>
 <Description>As per</Description>
 <CreatedDate>11/12/2014</CreatedDate>
 <ClosedDate>13/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>1946</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Abstract On Subscribe to help build Observables one on Next at a time</Title>
 <Description>Repost of</Description>
 <CreatedDate>09/12/2014</CreatedDate>
 <ClosedDate>09/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1946</PullRequestID>
 <IssueID>1931</IssueID>
 <Title>Abstract On Subscribe to help implement back pressure respecting</Title>
 <Description>observables Proposed implementation for See tests for use cases </Description>
 <CreatedDate>05/12/2014</CreatedDate>
 <ClosedDate>09/12/2014</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1938</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Any All should not unsubscribed own stream</Title>
 <Description>Should fiissue When in doubt see take 
</Description>
 <CreatedDate>08/12/2014</CreatedDate>
 <ClosedDate>13/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>1922</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Set remove On Cancel Policy on the thread pool if supported</Title>
 <Description>This should solve the task retention problem of unused timeout tasks mentioned in I know Java Scheduled Thread Pool Executor has the set Remove On Cancel Policy and I remember seeing it in Android although I cant tell from which API version In Java this cant be solved without rewriting the entire scheduler or using a back ported executor </Description>
 <CreatedDate>02/12/2014</CreatedDate>
 <ClosedDate>09/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1922</PullRequestID>
 <IssueID>1919</IssueID>
 <Title> Updated timeout operator leaking ScheduledFutureTasks on Scheduler</Title>
 <Description>Hi folks update see below looks like its the timeout operator Im raising a ticket earlier than later because I suspect we have a leak somewhere in the Scheduler logic It could by in my code too but from the characteristics it looks more like something rinternal Ive been able to generate some OOM scenarios where GC takes all the time to clean things up and its not able to which pointed me to a leak A heap dump showed the leak suspect is the ScheduledFutureTask as part of the computation scheduler screen shot 20141202 at 10 40 28 You can see a full GC kicking in without actually making old gen smaller screen shot 20141202 at 10 42 50 The code path uses both observeOn once to move it onto a scheduler and also blocks single at the very end So Ill start looking in those places But maybe akarnokd or benjchristensen you have an idea where I can start debugging?</Description>
 <CreatedDate>02/12/2014</CreatedDate>
 <ClosedDate>11/03/2015</ClosedDate>
 <Labels>
<Label>Bug</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1918</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Revert Experimental on Back pressure Buffer With Capacity</Title>
 <Description>Reverts Reactive RxJava This breaks unit tests all over for some reason I completely missed it before merging as the unit tests related to on Back pressure Buffer themselves pass Its elsewhere that things break From what I can tell it is because on Back pressure Buffer is used in unit tests and those fail often with timeouts or what appears to be infinite loops since my CPU pegs itself </Description>
 <CreatedDate>02/12/2014</CreatedDate>
 <ClosedDate>02/12/2014</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>1901</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fixed redo group By backpressure management</Title>
 <Description>Issue</Description>
 <CreatedDate>25/11/2014</CreatedDate>
 <ClosedDate>29/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1901</PullRequestID>
 <IssueID>1900</IssueID>
 <Title>retry hangs when it is followed by a group by with items</Title>
 <Description>For an operator chain like o retry group By if the source Observable has items the JVM seems to hang Repeated unsubscribe calls seem to be sent by retry upwards</Description>
 <CreatedDate>25/11/2014</CreatedDate>
 <ClosedDate>29/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1886</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Buffer with time and merge fix</Title>
 <Description>Bug reportIm not sure if the wrong guard in merge contributed to this bug or not 
</Description>
 <CreatedDate>17/11/2014</CreatedDate>
 <ClosedDate>17/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1886</PullRequestID>
 <IssueID>1867</IssueID>
 <Title>usage of 2 buffers with both a timespan and a count</Title>
 <Description>The usage of RxJava buffers with both a timespan and a count will eventually make the events be emitted at a very slow rate to the subscriber The observed rate will be as slow as 1 item per whatever is the second buffer timespan Please see the following Gist for the JUnit code demonstrating the issue </Description>
 <CreatedDate>12/11/2014</CreatedDate>
 <ClosedDate>19/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1884</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Fix Scan Reduce Collect Factory Ambiguity</Title>
 <Description>This puts the seed factory on collect and removes it from scan and reduce due to ambiguity See The collect API was already very close so this fixes it to use a seed factory so the signature is now I remove the factory overloads for scan and reduce due to the issue in related to generics type erasure and lambdas causing ambiguity and compilation failures We may want to add at least a scan impl in the future with a seed factory but it will need a different name if we do such as scanTo I dont want to do that now for so well need to revisit that for with more time to think about it </Description>
<code>
public final &lt;R&gt; Observable&lt;R&gt; 
</code>
 <CreatedDate>15/11/2014</CreatedDate>
 <ClosedDate>15/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1884</PullRequestID>
 <IssueID>1881</IssueID>
 <Title>Scan Reduce Overloads Type Erasure</Title>
 <Code> 
 public static void main String args {}
 </Code>
 <Description>I think the recent additions to scan reduce may cause issues Rename one of them Add an extra argument so  solves it I actually think the most correct thing to do is remove scan since an initial value is most often intended for mutable state in scan reduce cc head in the  this is a last minute API fiwe need prior to Monday for</Description>
 <CreatedDate>15/11/2014</CreatedDate>
 <ClosedDate>15/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1866</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Fix memory leaking bounded Replay Subject due to retaining the node index</Title>
 <Description>indefinitely once the Subscriber caught up For issue 
</Description>
 <CreatedDate>12/11/2014</CreatedDate>
 <ClosedDate>15/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1866</PullRequestID>
 <IssueID>1865</IssueID>
 <Title>Replay Subject memory leak</Title>
 <Code> 
public static void main String args {
 ReplaySubject&lt;Integer&gt; subject ReplaySubject createWithSize 10 ;
 subject subscribe &gt; {} ;
 int ii 0;
 while true {
     subject onNext ii ;
     ii++;
  }
 }
 </Code>
 <Description>This little baby will grind to a halt do due never letting go of the events </Description>
 <CreatedDate>12/11/2014</CreatedDate>
 <ClosedDate>15/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1840</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>romanmazur</FixedByID>
 <Title>Unsubscribe when thread is interrupted</Title>
 <Description>Originated from discussion I was considering to make it optin but it would drastically increase number of methods in public API What do you think </Description>
 <CreatedDate>10/11/2014</CreatedDate>
 <ClosedDate>21/01/2015</ClosedDate>
 <PullRequestLabels>
 <PullRequestLabel>Enhancement</PullRequestLabel>
 </PullRequestLabels>
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1840</PullRequestID>
 <IssueID>1804</IssueID>
 <Title> Interrupted while waiting for subscription to complete in rc </Title>
 <stracktrace>
 FATAL E CEPTION R CachedThreadScheduler4
Process com mycompany myapp development PID 4413
java lang IllegalStateE ception E ception thrown on Scheduler Worker thread Add onError handling 
 at r internal schedulers ScheduledAction run ScheduledAction java 50 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 
 at java lang Thread run Thread java 818 
Caused by r exceptions OnErrorNotImplementedE ception Interrupted while waiting for subscription to complete 
 at r Observable$30 onError Observable java 7252 
 at r observers SafeSubscriber _onError SafeSubscriber java 127 
 at r observers SafeSubscriber onError SafeSubscriber java 96 
 at r internal operators OperatorMap$1 onError OperatorMap java 48 
 at r internal operators OperatorMap$1 onNext OperatorMap java 56 
 at r internal operators NotificationLite accept NotificationLite java 150 
 at r subjects SubjectSubscriptionManager$SubjectObserver emitNext SubjectSubscriptionManager java 254 
 at r subjects BehaviorSubject onNext BehaviorSubject java 166 
 at r Observable$34 onNext Observable java 7437 
 at r observers SafeSubscriber onNext SafeSubscriber java 104 
 at r internal operators OperatorMerge$InnerSubscriber emit OperatorMerge java 610 
 at r internal operators OperatorMerge$InnerSubscriber onNext OperatorMerge java 536 
 at r internal operators OperatorSingle$1 onCompleted OperatorSingle java 75 
 at r internal operators OperatorTake$1 onNext OperatorTake java 72 
 at r internal operators OperatorSubscribeOn$1$1$1 onNext OperatorSubscribeOn java 76 
 at com mycompany servercall ServerCall$1$1 call ServerCall java 56 
 at com mycompany servercall ServerCall$1$1 call ServerCall java 47 
 at r Observable unsafeSubscribe Observable java 7464 
 at r internal operators OperatorSubscribeOn$1$1 call OperatorSubscribeOn java 62 
 at r internal schedulers ScheduledAction run ScheduledAction java 45 
 7 more 
Caused by java lang RuntimeE ception Interrupted while waiting for subscription to complete 
 at r observables BlockingObservable blockForSingle BlockingObservable java 474 
 at r observables BlockingObservable single BlockingObservable java 348 
 at com mycompany myapp data CachedThing buildCachedThing CachedThing java 66 
 at com mycompany myapp data CachedThing &lt;init&gt; CachedThing java 28 
 at com mycompany myapp data FilterFunc call FilterFunc java 189 
 at com mycompany myapp data FilterFunc call FilterFunc java 175 
 at com mycompany myapp data CachedThing merge CachedThing java 60 
 at com mycompany myapp data ResponseCache update ResponseCache java 80 
 at com mycompany myapp data TransformFunc call TransformFunc java 105 
 at com mycompany myapp data TransformFunc call TransformFunc java 99 
 at com mycompany servercall CallState$3 map CallState java 79 
 at com mycompany servercall CallState$9 call CallState java 195 
 at com mycompany servercall CallState$9 call CallState java 193 
 at r internal operators OperatorMap$1 onNext OperatorMap java 54 
 22 more
Caused by java lang InterruptedE ception
 at java util concurrent locks AbstractQueuedSynchronizer acquireSharedInterruptibly AbstractQueuedSynchronizer java 1279 
 at java util concurrent CountDownLatch await CountDownLatch java 202 
 at r observables BlockingObservable blockForSingle BlockingObservable java 471 
 35 more
Caused by r exceptions OnErrorThrowable$OnNextValue OnError while emitting onNext value class 
 at r internal operators OperatorMap$1 onNext OperatorMap java 56 
 22 more
 </stracktrace>
 <Code>
 </Code>
 <Description>Doesnt happen on rc I can repro of the time Happens on both KitKat and Lollipop so I dont think its specific to any particular Android version I tried writing a testcase to repro but couldnt get it to fail Im guessing theres something broken between the android runtime and RxJavas thread management but I couldnt get any further than that </Description>
 <CreatedDate>28/10/2014</CreatedDate>
 <ClosedDate>08/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1832</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Fix Take Early Unsubscription Causing Interrupts</Title>
 <Description>Fixes This is one approach to fixing that still works with the unit tests that take had been changed for originally Still not sure if we should change the default behavior though to not interrupt a thread </Description>
 <CreatedDate>07/11/2014</CreatedDate>
 <ClosedDate>08/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1832</PullRequestID>
 <IssueID>1804</IssueID>
 <Title>Interrupted while waiting for subscription to complete in</Title>
 <Code>
List&lt;SubThing&gt; 
 </Code>
 <stracktrace>
 FATAL E CEPTION R CachedThreadScheduler4
Process com mycompany myapp development PID 4413
java lang IllegalStateE ception E ception thrown on Scheduler Worker thread Add onError handling 
 at r internal schedulers ScheduledAction run ScheduledAction java 50 
 at java util concurrent E ecutors$RunnableAdapter call E ecutors java 422 
 at java util concurrent FutureTask run FutureTask java 237 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask access$201 ScheduledThreadPoolE ecutor java 152 
 at java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask run ScheduledThreadPoolE ecutor java 265 
 at java util concurrent ThreadPoolE ecutor runWorker ThreadPoolE ecutor java 1112 
 at java util concurrent ThreadPoolE ecutor$Worker run ThreadPoolE ecutor java 587 
 at java lang Thread run Thread java 818 
Caused by r exceptions OnErrorNotImplementedE ception Interrupted while waiting for subscription to complete 
 at r Observable$30 onError Observable java 7252 
 at r observers SafeSubscriber _onError SafeSubscriber java 127 
 at r observers SafeSubscriber onError SafeSubscriber java 96 
 at r internal operators OperatorMap$1 onError OperatorMap java 48 
 at r internal operators OperatorMap$1 onNext OperatorMap java 56 
 at r internal operators NotificationLite accept NotificationLite java 150 
 at r subjects SubjectSubscriptionManager$SubjectObserver emitNext SubjectSubscriptionManager java 254 
 at r subjects BehaviorSubject onNext BehaviorSubject java 166 
 at r Observable$34 onNext Observable java 7437 
 at r observers SafeSubscriber onNext SafeSubscriber java 104 
 at r internal operators OperatorMerge$InnerSubscriber emit OperatorMerge java 610 
 at r internal operators OperatorMerge$InnerSubscriber onNext OperatorMerge java 536 
 at r internal operators OperatorSingle$1 onCompleted OperatorSingle java 75 
 at r internal operators OperatorTake$1 onNext OperatorTake java 72 
 at r internal operators OperatorSubscribeOn$1$1$1 onNext OperatorSubscribeOn java 76 
 at com mycompany servercall ServerCall$1$1 call ServerCall java 56 
 at com mycompany servercall ServerCall$1$1 call ServerCall java 47 
 at r Observable unsafeSubscribe Observable java 7464 
 at r internal operators OperatorSubscribeOn$1$1 call OperatorSubscribeOn java 62 
 at r internal schedulers ScheduledAction run ScheduledAction java 45 
 7 more 
Caused by java lang RuntimeE ception Interrupted while waiting for subscription to complete 
 at r observables BlockingObservable blockForSingle BlockingObservable java 474 
 at r observables BlockingObservable single BlockingObservable java 348 
 at com mycompany myapp data CachedThing buildCachedThing CachedThing java 66 
 at com mycompany myapp data CachedThing &lt;init&gt; CachedThing java 28 
 at com mycompany myapp data FilterFunc call FilterFunc java 189 
 at com mycompany myapp data FilterFunc call FilterFunc java 175 
 at com mycompany myapp data CachedThing merge CachedThing java 60 
 at com mycompany myapp data ResponseCache update ResponseCache java 80 
 at com mycompany myapp data TransformFunc call TransformFunc java 105 
 at com mycompany myapp data TransformFunc call TransformFunc java 99 
 at com mycompany servercall CallState$3 map CallState java 79 
 at com mycompany servercall CallState$9 call CallState java 195 
 at com mycompany servercall CallState$9 call CallState java 193 
 at r internal operators OperatorMap$1 onNext OperatorMap java 54 
 22 more
Caused by java lang InterruptedE ception
 at java util concurrent locks AbstractQueuedSynchronizer acquireSharedInterruptibly AbstractQueuedSynchronizer java 1279 
 at java util concurrent CountDownLatch await CountDownLatch java 202 
 at r observables BlockingObservable blockForSingle BlockingObservable java 471 
 35 more
Caused by r exceptions OnErrorThrowable$OnNextValue OnError while emitting onNext value class 
 at r internal operators OperatorMap$1 onNext OperatorMap java 56 
 22 more
 CachedThing buildCachedThing has this block of code that I think is the culprit 
 </stracktrace>
 <Description>Doesnt happen on rc I can repro of the time Happens on both KitKat and Lollipop so I dont think its specific to any particular Android version I tried writing a testcase to repro but couldnt get it to fail Im guessing theres something broken between the android runtime and RxJavas thread management but I couldnt get any further than that </Description>
 <CreatedDate>28/10/2014</CreatedDate>
 <ClosedDate>08/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1827</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>alexwen</FixedByID>
 <Title>Cache Thread Scheduler Evictor should Check Removal</Title>
 <Description>Before unsubscribing the worker the Evictor should check that it actually removed the worker from the queue FIXes  
</Description>
 <CreatedDate>06/11/2014</CreatedDate>
 <ClosedDate>06/11/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1827</PullRequestID>
 <IssueID>1826</IssueID>
 <Title>Race with Cached Thread Scheduler Eviction</Title>
 <Code>
 void evictExpiredWorkers {
 if expiringWorkerQueue isEmpty {
	long currentTimestamp now ;
	Iterator&lt;ThreadWorker&gt; threadWorkerIterator e piringWorkerQueue iterator ;
	while threadWorkerIterator hasNext {
	 ThreadWorker threadWorker threadWorkerIterator Next ;
	 if threadWorker getE pirationTime &lt;  currentTimestamp {
	 threadWorkerIterator remove ;
	 threadWorker unsubscribe ;
	 } else {
	 // Queue is ordered with the worker that will e pire first in the beginning so when we
	 // find a none pired worker we can stop evicting 
	 break;
	 }
	}
	}
 }
 </Code>
 <stacktrace>
 java util concurrent RejectedExecutionE ception Task java util concurrent ScheduledThreadPoolE ecutor$ScheduledFutureTask328cda0 rejected from java util concurrent ScheduledThreadPoolE ecutor2200705dTerminated pool size 0 active threads 0 queued tasks 0 completed tasks 3
at java util concurrent ThreadPoolE ecutor$AbortPolicy rejectedExecution ThreadPoolE ecutor java 2047 ~na 1 8 0_20
at java util concurrent ThreadPoolE ecutor reject ThreadPoolE ecutor java 823 na 1 8 0_20
at java util concurrent ScheduledThreadPoolE ecutor delayedE ecute ScheduledThreadPoolE ecutor java 326 ~na 1 8 0_20
at java util concurrent ScheduledThreadPoolE ecutor schedule ScheduledThreadPoolE ecutor java 533 ~na 1 8 0_20
at java util concurrent ScheduledThreadPoolE ecutor submit ScheduledThreadPoolE ecutor java 632 ~na 1 8 0_20
at r internal schedulers NewThreadWorker scheduleActual NewThreadWorker java 66 ~sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947 jar 0 1SNAPSHOT
at r schedulers CachedThreadScheduler$EventLoopWorker schedule CachedThreadScheduler java 149 ~sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947 jar 0 1SNAPSHOT
at r schedulers CachedThreadScheduler$EventLoopWorker schedule CachedThreadScheduler java 139 ~sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947 jar 0 1SNAPSHOT
While auditing the CachedThreadScheduler I noticed a potential race condition when evicting workers from the eviction queue from CachedThreadScheduler 
 </stracktrace>
 <Description>Although I have not been able to find a way to reproduce the issue reliably I have seen the following stack several times now The evictor uses an iterator remove in order to remove the work from the queue but it does not check that this operation actually occurred The iterator though thread safe is not atomic for Next and remove so the worker could be pulled from the cache by another thread between the Next and the remove If this occurs then the the NewThreadWorker will be unsubscribed its e ecutor shutdown and the Next action that e ecutes on that worker would cause the e ception above In order to fithis race I believe the evictor would need to check that it removed the worker from the queue before attempting to unsubscribe the worker </Description>
 <CreatedDate>06/11/2014</CreatedDate>
 <ClosedDate>06/11/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1813</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Fi issue1812thatzipmayswallowrequests</Title>
 <Description>Fi ed 1812
</Description>
 <CreatedDate>31/10/2014</CreatedDate>
 <ClosedDate>31/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1813</PullRequestID>
 <IssueID>1812</IssueID>
 <Title>Multiple Zipped Observers never complete</Title>
 <Description>The following code never executes the on Complete if the number is greater than I think it has to due with back pressure which uses a default request of I am using Java I am using the following version of Java java version Java TM SE Runtime Environment build Java HotSpot TM Bit Server VM build b mixed mode </Description>
 <CreatedDate>30/10/2014</CreatedDate>
 <ClosedDate>31/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1793</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>TakeRedoUnsubscribe</Title>
 <Description>Do not do further work after unsubscribed I added a fix to take on top of the change by alexwen that fixes the source of the issue with take It now unsubscribes before onNext so side effects of onNext such as request n happen after unsubscribe and thus no further work will be scheduled I left the changes to On Subscribe Redo as they are a good safety net in case another operator has a similar issue as take an easy bug to creep in as it does no harm to redo to have the isUnsubscribed check going forward Fixes </Description>
 <CreatedDate>23/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1793</PullRequestID>
 <IssueID>1791</IssueID>
 <Title>Observable first causes retry When to trigger retry without an exception</Title>
 <Description>Noticed this behavior using netty as internally it does a take internally The test output is Emitting Emitting DONE As you can see the observable is subscribed to twice This is because take in combination with single causes the retry When producer to request another item </Description>
 <CreatedDate>23/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1792</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>alexwen</FixedByID>
 <Title>Fix for 1791</Title>
 <Description>Fixes dont retry subscribe to source if child has unsubscribed 
</Description>
 <CreatedDate>23/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1792</PullRequestID>
 <IssueID>1791</IssueID>
 <Title>Observable first causes retryWhen to trigger retry without an exception</Title>
 <Description>Noticed this behavior using netty as internally it does a take internally The test output is Emitting Emitting DONE As you can see the observable is subscribed to twice This is because take in combination with single causes the retry When producer to request another item </Description>
 <CreatedDate>23/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1784</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>PublishwithBackpressure</Title>
 <Description>Implementation of publish with backpressure This moves away from using the multicast operator and Publish Subject as per discussion in
</Description>
 <CreatedDate>23/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1784</PullRequestID>
 <IssueID>1732</IssueID>
 <Title>Backpressure Publish</Title>
 <Description>Is it possible in limited cases to support reactive pull backpressure on multicast use cases such as publish In the general case of a Connectable Observable it wouldnt be as those are hot Im interested in exploring if there are cases when it will work such as when using refCount to address use cases such as discussed in As per the example from head in the box</Description>
 <CreatedDate>07/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1784</PullRequestID>
 <IssueID>1779</IssueID>
 <Title>Remove Multicast</Title>
 <Code> 
Observable&lt;T&gt;s ;
 </Code>
 <Description>While discussing with head in the box we determined that multicast is troublesome and an implementation detail that leaked into the public API The publish replay share cache operators are what should actually be used If multicast behavior is truly still wanted with hot semantics and no backpressure it can be achieved by doing this We will remove multicast in  so as to eliminate it as a stumbling block and allow for correct backpressure propagation which doesnt work with subjects </Description>
 <CreatedDate>20/10/2014</CreatedDate>
 <ClosedDate>23/10/2014</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1777</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>abersnaze</FixedByID>
 <Title>Excludingthingsfromthejavadoc</Title>
 <Description>For one of the sub issues in exclude internal exclude RxJava Error Handler Default by deleting it 
</Description>
 <CreatedDate>19/10/2014</CreatedDate>
 <ClosedDate>21/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1777</PullRequestID>
 <IssueID>1502</IssueID>
 <Title>Javadocs Disable or Make Work</Title>
 <Description>The generation of Javadocs from the Gradle config is mostly broken and unusable formatting is default bad it doesnt exclude internal packages it breaks on different versions of the JVMRight now I generate the hosted docs using a bash script on my local machine I want this automated but correctly to at least match what is hosted at and so it works regardless of Java 7 or 8 being used </Description>
 <CreatedDate>24/07/2014</CreatedDate>
 <ClosedDate>22/06/2016</ClosedDate>
 <Labels>
<Label>Documentation</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1775</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>akarnokd</FixedByID>
 <Title>Blocking Operator Next Test test Single Source Many Iterators fix</Title>
 <Description> Blocking Operator Next Test test Single Source Many Iterators fix
</Description>
 <CreatedDate>17/10/2014</CreatedDate>
 <ClosedDate>18/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1775</PullRequestID>
 <IssueID>1655</IssueID>
 <Title>Non deterministic test failure blocking Operator Next</Title>
 <Description> </Description>
 <CreatedDate>01/09/2014</CreatedDate>
 <ClosedDate>05/02/2015</ClosedDate>
 <Labels>
<Label>TestFailures</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1767</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>loganj</FixedByID>
 <Title>Executor Scheduler deliver sun caught exceptions</Title>
 <Description>Instead of swallowing unhandled errors Executor Scheduler delivers them to the executing threads Uncaught Exception Handler This addresses the same issue as Reactive RxJava but for Executor Scheduler which does not used Scheduled Action </Description>
 <CreatedDate>16/10/2014</CreatedDate>
 <ClosedDate>16/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1767</PullRequestID>
 <IssueID>1682</IssueID>
 <Title>Scheduled Action Swallows Errors</Title>
 <Code> 
</Code>
 <Description>Scheduled Action used by observe On and other things doing scheduling swallows errors because Future Task run swallows errors inside a Future This means something like On Error Not Implemented on the Subscriber side of an observe On will throw and be swallowed and everything will fail silently The following code fails silently </Description>
 <CreatedDate>11/09/2014</CreatedDate>
 <ClosedDate>16/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1750</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fix NPE when iterable is null</Title>
 <Description>As per I prefer that throwing an Null Pointer Exception in the constructor of On Subscribe From Iterable BTW because does not return after o onCompleted ;there is still a NPE bug here 
</Description>
 <CreatedDate>12/10/2014</CreatedDate>
 <ClosedDate>13/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1750</PullRequestID>
 <IssueID>1676</IssueID>
 <Title>NPE in On Subscribe From Iterable</Title>
 <Code>
 </Code>
<stracktrace>
Caused by java lang NullPointerException
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 39 
 at r internal operators OnSubscribeFromIterable call OnSubscribeFromIterable java 29 
 at r Observable$2 call Observable java 159 
</stracktrace>
 <Description>A report from RxJava</Description>
 <CreatedDate>08/09/2014</CreatedDate>
 <ClosedDate>10/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>1742</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Empty Observer and Test Observer</Title>
 <Description> Remove Empty Observer as it was confusing compared to Observers empty fixes Make Test Observer not throw On Error Not Implemented if a delegate is not provided fixes  
</Description>
 <CreatedDate>10/10/2014</CreatedDate>
 <ClosedDate>10/10/2014</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1742</PullRequestID>
 <IssueID>1741</IssueID>
 <Title>Observer empty vs Empty Observer</Title>
 <Description>The behavior between Observer empty and Empty Observer is different This seems confusing Empty Observer swallows errors whereas Observer empty will throw On Error Not Implemented Exception if on Error is invoked Thoughts on what we should do</Description>
 <CreatedDate>10/10/2014</CreatedDate>
 <ClosedDate>10/10/2014</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
<Label>Question</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>1742</PullRequestID>
 <IssueID>1571</IssueID>
 <Title>Test Observer always delegates to EMPTY throws exception</Title>
 <Description>I noticed that Test Observer was changed to always delegate calls by default to the EMPTY Observer However the EMPTY Observer does not define on Error so any attempt to use Test Observer with an observable thats supposed to fail in a unit test crashes the test with a On Error Not Implemented Exception I wonder why this change was done It adds comple ity and surprise to something that should be void of behavior mocks should record things not perform logic IMHO </Description>
 <CreatedDate>12/08/2014</CreatedDate>
 <ClosedDate>10/10/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>463</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Added the rest overloads of Timeout operator</Title>
 <Description>Hi this PR implemented the rest overloads of Timeout operator Please take a look Thanks 
</Description>
 <CreatedDate>03/11/2013</CreatedDate>
 <ClosedDate>12/11/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>463</PullRequestID>
 <IssueID>91</IssueID>
 <Title>Operator Timeout</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>460</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>ImplementedtheAmboperator</Title>
 <Description>Hi this PR implemented the Amb operator I used varargs to support the array version and first second version in one method So in my PR there are only two variants 
</Description>
 <CreatedDate>01/11/2013</CreatedDate>
 <ClosedDate>05/11/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>460</PullRequestID>
 <IssueID>22</IssueID>
 <Title>Operator Amb</Title>
 <Description>
 </Description>
 <CreatedDate>16/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>459</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Fixed issue</Title>
 <Description>Hi I used Safe Observable Subscription to fix the issue 
</Description>
 <CreatedDate>29/10/2013</CreatedDate>
 <ClosedDate>31/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>453</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zs wing</FixedByID>
 <Title>Fixed issue 417</Title>
 <code>
 public static void main String args {
 System out println "started";
 System out println "done" ;
}
 </code>
 <Description> This issue in is because current map implementation violates the design guild Protect calls to user code from within an operator Now current map does not handle the error from the func param which may be user codes When the thread pool scheduler is involved the error from func will throw to the outside and be handled by java util concurrent Future Task The error will be dropped so the observer will not see it This PR used Safe Observer to protect map from user codes </Description>
 <CreatedDate>25/10/2013</CreatedDate>
 <ClosedDate>31/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>452</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the scheduler version of the Return operator</Title>
 <Description>Hi this is the scheduler version of the Return operator 
</Description>
 <CreatedDate>25/10/2013</CreatedDate>
 <ClosedDate>31/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>452</PullRequestID>
 <IssueID>73</IssueID>
 <Title>Operator Return</Title>
 <Description>Looks like it is an alias to just which is already implemented plus a version supporting scheduler </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>31/10/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>450</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Time Interval operator</Title>
 <Description>Hi this PR implemented the Time Interval operator Please take a look Thanks 
</Description>
 <CreatedDate>24/10/2013</CreatedDate>
 <ClosedDate>31/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>450</PullRequestID>
 <IssueID>90</IssueID>
 <Title>Operator TimeInterval</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>441</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fixed the issue that take does not call on Error</Title>
 <Description>I fixed one of the issues in System out println Observable from take map to Blocking Observable single is never terminated This issues is because take does not handle the e ception throwing from on Next correctly </Description>
 <CreatedDate>19/10/2013</CreatedDate>
 <ClosedDate>22/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>430</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fixed issue</Title>
 <Description>I fixed the issue This issus is because the wrong order of unsubscribe and emit Chunk unsubscribe will cancel the Future and the currrent threads interrupt status will be set If unsubscribe is called before emit Chunk the currrent threads interrupt status has already set before emitChunk It may confuse users when they have some codes depending on the interrupt status I put emitChunk before unsubscribe and added a unit test for it </Description>
 <CreatedDate>12/10/2013</CreatedDate>
 <ClosedDate>16/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>430</PullRequestID>
 <IssueID>428</IssueID>
 <Title>buffer using Time And Size Based Chunks incorrectly forces thread into interrupted state</Title>
 <Description>In Time And Size Based Chunks emit Chunk if emit Chunk is called from the scheduled action in create Chunk from the timeout thread calling subscription unsubscribe ends up calling cancel on the future which sets the threads interrupted state to true This state has an adverse effect on any blocking call performed in that thread </Description>
 <CreatedDate>10/10/2013</CreatedDate>
 <ClosedDate>16/10/2013</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>425</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>benjchristensen</FixedByID>
 <Title>Manual Merge of Pull Request</Title>
 <Description>Added a unit test to while testing it 
</Description>
 <CreatedDate>09/10/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>424</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Ignore Elements operator</Title>
 <Description>Hi I implemented the Ignore Elements operator Please take a look Thanks 
</Description>
 <CreatedDate>08/10/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>424</PullRequestID>
 <IssueID>54</IssueID>
 <Title>Operator IgnoreElements</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>422</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>ragalie</FixedByID>
 <Title>JRuby function wrapping support</Title>
 <Description>This PR fixes by implementing JRuby wrappers for RxJava specific function interfaces Given a set of method signatures for a Java method JRuby will select the signature that best matches the Ruby arguments provided and wrap each argument in a pro y that implements the correct Java interface Occasionally JRuby will be unable to unambiguously select one method signature over another and will either a select the correct signature but report that there was ambiguity in the method signatures or b select the wrong signature and fail By explicitly wrapping Proc arguments into wrappers that implement the correct RxJava interface JRuby will always select the correct method signature and will not need to wrap the argument in a proxy increasing both correctness and performance 
</Description>
 <CreatedDate>07/10/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>416</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Throw operator with scheduler</Title>
 <Description>Hi I implemented the Throw operator with scheduler I found that RxJava had an error method So I just implemented the scheduler overload </Description>
 <CreatedDate>30/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>416</PullRequestID>
 <IssueID>89</IssueID>
 <Title>Operator Throw</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>415</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Empty operator with scheduler</Title>
 <Description>Hi I implemented the Empty operator with scheduler Please take a look Thanks </Description>
 <CreatedDate>30/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>415</PullRequestID>
 <IssueID>42</IssueID>
 <Title>Operator Empty with scheduler</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>414</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Skip Last operator</Title>
 <Description>Hi I implemented the skip Last operator I used ReentrantLock and Linked List to implement it rather than Linked Blocking Deque like take Last for two reasons Linked Blocking Deque requires that count is greater than but skip Last can accept Linked Blocking Deque requires the elements can not be null but an observable can emit a null value In summary Linked Blocking Deque will cause issues like Please take a look Thanks </Description>
 <CreatedDate>29/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>414</PullRequestID>
 <IssueID>78</IssueID>
 <Title>Operator SkipLast</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>414</PullRequestID>
 <IssueID>85</IssueID>
 <Title>Operator TakeLast</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>13/02/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>413</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Fixed the issues of take Last items and null values</Title>
 <Description>
There are two issues about takeLast The essential cause is Linked Blocking Deque var source Observable Return TakeLast source Subscribe Console Write Line subscriber got Console Read Line null values Linked Blocking Deque requires the elements can not be null but an observable can emit a null value I used Reentrant Lock and Linked List to replace Linked Blocking Deque Please take a look Thanks 
</Description>
 <CreatedDate>29/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>413</PullRequestID>
 <IssueID>85</IssueID>
 <Title>Operator TakeLast</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>13/02/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>411</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>petermd</FixedByID>
 <Title>update counter before triggering latch</Title>
 <Description>as mentioned in concurrency Test Schedulers test Scheduling With Due Time is flaky because there is a race condition where the test can assert the counter value before it is updated fiis just to update the counter before releasing the latch 
</Description>
 <CreatedDate>26/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>411</PullRequestID>
 <IssueID>383</IssueID>
 <Title>Flaky unit tests</Title>
 <Description>It looks like there are some flaky unit tests On my machiNex this test failed today but only once </Description>
 <CreatedDate>14/09/2013</CreatedDate>
 <ClosedDate>20/05/2014</ClosedDate>
 <Labels>
<Label>Bug</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>410</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Contains operator</Title>
 <Description>Hi I implemented the Contains operator I saw the discussion about the distinct operator so I did not implement the comparator override Please take a look Thanks
</Description>
 <CreatedDate>26/09/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>410</PullRequestID>
 <IssueID>31</IssueID>
 <Title>Operator Contains</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>09/10/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>409</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented Synchronize with lock</Title>
 <Description>Hi I implemented to support that sending a lock to the synchronize operator I also found that there was a issue that test Multi Threaded With NPE and test Multi Threaded With NPE in Middle might fail in some special situation When on Error is invoked before any onNextthe last statement assert Equals busy Observer ma Concurrent Threads get in these methods will fail I also fi ed this issue in the pull request 
</Description>
 <CreatedDate>25/09/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>409</PullRequestID>
 <IssueID>84</IssueID>
 <Title>Operator Synchronize overload </Title>
 <Description>Another overload to the existing synchronize </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>403</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the cast and of Type operators</Title>
 <Description>Hi I used map to implement the cast operator I also used cast to implement the of Type operator Please take a look Thanks</Description>
 <CreatedDate>23/09/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>403</PullRequestID>
 <IssueID>26</IssueID>
 <Title>Operator Cast</Title>
 <Description>Operator Cast</Description>
 <CreatedDate>16/01/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>403</PullRequestID>
 <IssueID>67</IssueID>
 <Title>Operator Of Type</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>401</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the Default If Empty operator See</Title>
 <Description>This implements the Default If Empty operator from There are two variants However I can not get the element type in the source observable due to type erasure So I only implemented the variant with a default value Please take a look Thanks 
</Description>
 <CreatedDate>22/09/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>401</PullRequestID>
 <IssueID>34</IssueID>
 <Title>Operator Default If Empty</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>25/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>390</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the element At and element At Or Default operators see</Title>
 <Description>Hi This implements the Element At and Element At Or Default operators from For Element At if the indeis less than or greater than or equal to the number of elements in the source sequence an Inde Out Of Bounds Exception will be threw For Element At Or Default if the indeis less than an Inde Out Of Bounds Exception will be threw Whats more I added a default Value parameter I can not get the element type in the source observable due to type erasure So I can not determi Nex the default value automatically Thats why Element At Or Default needs a default Value parameter 
</Description>
 <CreatedDate>18/09/2013</CreatedDate>
 <ClosedDate>21/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>390</PullRequestID>
 <IssueID>41</IssueID>
 <Title>Operator Element At and Element At Or Default</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>385</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>zsxwing</FixedByID>
 <Title>Implemented the any operator</Title>
 <Description>This implements the operator Any from in all two variants However I encountered two problems Updated the online document aspis wrong See my later discussion Another question is if I add the any method to Observable some unit tests will fail as the method any in Observable overrides the method org mockito Matchers any java lang Class  in some unit tests subjects Replay Subject  Do I need to use another method name or just modify the unit tests? Now the any methods in r Observable are commented out Thanks 
</Description>
 <CreatedDate>16/09/2013</CreatedDate>
 <ClosedDate>21/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>385</PullRequestID>
 <IssueID>24</IssueID>
 <Title>Operator Any</Title>
 <Description>
 </Description>
 <CreatedDate>16/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>381</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Implemented map With Index</Title>
 <Description>As requested by samuelgruetter in
</Description>
 <CreatedDate>13/09/2013</CreatedDate>
 <ClosedDate>14/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>380</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Implemented distinct and distinct Until Changed variants using a comparator</Title>
 <Description>As abersnaze and benjchristensen both agreed see the discussion that theyd like the comparator versions of these two operations too I implemented them here 
</Description>
 <CreatedDate>13/09/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>379</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Makeintervalworkwithmultiplesubscribers</Title>
 <Description>As per samuelgruetters comments in I added some tests against interval together with multiple subscribers and then proceeded to fithe behavior by wrapping it in another subscription function I hope its ok now 
</Description>
 <CreatedDate>13/09/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>379</PullRequestID>
 <IssueID>55</IssueID>
 <Title>Operator Interval</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>375</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Implementeddistinctoperator</Title>
 <Description>This PR implements distinctas speficied by Again I havent implemented the NET methods taking an Equality Comparator see 
</Description>
 <CreatedDate>12/09/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>375</PullRequestID>
 <IssueID>38</IssueID>
 <Title>Operator Distinct</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>374</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Implemented distinct Until Changed operation</Title>
 <Description>This is the implementation for distinct Until Changed as described in I havent implemented the two methods from NET that are using an IEquality Comparator because I dont think it would be idiomatic Java to define an interface like this and use that here Or does somebody want that
</Description>
 <CreatedDate>12/09/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>374</PullRequestID>
 <IssueID>39</IssueID>
 <Title>Operator Distinct Until Changed</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>06/12/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>373</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>a few warnings java doc and one missing scheduler parameter</Title>
 <Description>This is just a quick fifor according to samuelgruetters comments I also removed a few unnecessary Suppress Warnings unchecked and one unnecessary semicolon 
</Description>
 <CreatedDate>12/09/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>357</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Implemented First and First Or Defaul to operations</Title>
 <Description>This PR builds upon the skip While PR which makes implementing the two first variants e tremely easy I changed first Or Default slightly from what R NET does by e plicitly requiring a default value as parameter of the function call I dont know what default value I should return otherwise e cept null and imho this would be pretty useless This PR addresses issue </Description>
 <CreatedDate>08/09/2013</CreatedDate>
 <ClosedDate>10/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>357</PullRequestID>
 <IssueID>44</IssueID>
 <Title>Operator First and First Or Default</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>11/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>356</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Added interval methods to Observable where they were still missing</Title>
 <Description>This was simply missing and forgotten in</Description>
 <CreatedDate>08/09/2013</CreatedDate>
 <ClosedDate>09/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>356</PullRequestID>
 <IssueID>55</IssueID>
 <Title>Operator Interval</Title>
 <Description>
 </Description>
 <CreatedDate>18/01/2013</CreatedDate>
 <ClosedDate>13/09/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
 <PullRequest>
 <IssueID>331</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>jmhofer</FixedByID>
 <Title>Adding super extends so that Observable is covariant</Title>
 <Description>Ok so this pull request changes a lot of lines Its mostly generalizing all the Funcs to be used like Func contra variant parameters covariant return type and all the Observer s to be used "in a contravariant way" A few of the Observable uses are covariant now too mostly zip This is the pull request for This doesnt look very good in the code thanks Java Also it doesnt seem to make Scala interop easier at all at least not yet Please take a look Im not e actly happy with the result Maybe Im doing something wrong here?Ive still got hope that theres an easier way The pull request compiles and tests ok for me except for the Clojure module but thats another story and not due to my changes 
</Description>
 <CreatedDate>31/08/2013</CreatedDate>
 <ClosedDate>04/09/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>330</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>daveray</FixedByID>
 <Title>Make Dummy Observable visible to clojure Test class path </Title>
 <Description>RxJava issue Moved Dummy Observable into main so that its compiled and available when the clojureTest task executes Perhaps someone with stronger Gradle skills can figure out how to put this Java class in src test and get things to work out Correctly For the time being several clean build cycles worked fine for me 
</Description>
 <CreatedDate>31/08/2013</CreatedDate>
 <ClosedDate>31/08/2013</ClosedDate>
 <PullRequestLabels />
 <Issues />
 </PullRequest>
 <PullRequest>
 <IssueID>323</IssueID>
 <RepoID>RxJava</RepoID>
 <FixedByID>mattrjacobs</FixedByID>
 <Title>Staticcore</Title>
 <Description>Another take on Issues typesafe RxJavacore modular jars Scala support via implicits Groovy support via extension methods No Clojure support in this PR eventually via macros Eliminated JRuby support for now 
</Description>
 <CreatedDate>29/08/2013</CreatedDate>
 <ClosedDate>30/08/2013</ClosedDate>
 <PullRequestLabels />
 <Issues>
 <Issue>
 <RepoID>RxJava</RepoID>
 <PullRequestID>323</PullRequestID>
 <IssueID>204</IssueID>
 <Title>Explore code generation for language adaptors</Title>
 <Description>RxJava was written from the beginning to target the JVM not any specific language As a sideeffect of Java not having lambdas clojures yet and other considerations Net fliused dynamic languages with it predominantly for the year of its e istence prior to open sourcing To bridge the RxJavacore written in Java with the various languages a Functional Language Adaptor is registered at runtime for each language of interest To enable this language adaptors method overloads with Object e ist in the API since Object is the only supertype that works across all languages for their various implementations of lambdas and closures This downside of this is that it breaks static typing foRxJava Scala and other statictyped languages More can be read on this issue and discussion of the subject here I would like to pursue the followingremove all Object overload methods from RxJavacore so it remains statically typed modify FunctionalLanguageAdaptors to not register with a lookup map but instead to trigger a code generation process at registration time the code generation would create the overload methods on r Observable for the types needed by that languages such as groovy lang Closure or clojure lang IFn The benefits of this are 1 Everything is statically typed so compiletime checks foRxJava Scala etc work correctly2 Method dispatch is now done via native Java bytecode using types rather than going via Object which then has to do a lookup in a map Memoization helped with the performance but each method invocation still required looking in a map for the correct adaptor With this approach the appropriate methods will be compiled into the r Observable class to correctly invoke the right adaptor without lookups The byte code generation step would happen once the first time a LanguageAdaptor is registered which is normally only at the first point of access to RxJava </Description>
 <CreatedDate>21/03/2013</CreatedDate>
 <ClosedDate>31/08/2013</ClosedDate>
 <Labels>
<Label>Enhancement</Label>
 </Labels>
 </Issue>
 </Issues>
 </PullRequest>
</PullRequests>