<Issues>
  <Issue>
    <IssueID>41926</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191019.1
- **Date Produced**: 10/19/2019 1:35 PM
- **Commit**: 605124c975c78a0aeb875c70f359737747bf55a8
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19519.1
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19519.1
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19519.1

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>20/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41925</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191019.8
- **Date Produced**: 10/20/2019 6:59 AM
- **Commit**: 878b814996cb808a525ae43b1f77559b8e2135dd
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19519.8
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19519.8
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19519.8

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

</Description>
    <CreatedDate>20/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41924</IssueID>
    <RepoID>1</RepoID>
    <Title>Update argument names for CoreLib change</Title>
    <Description>
    </Description>
    <CreatedDate>20/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41923</IssueID>
    <RepoID>1</RepoID>
    <Title>Power Bi connection to postgres</Title>
    <Description>i got this error message while attempting to pull data from postgres to power bi. How do i solve it?

Details: "An error happened while reading data from the provider: 'Could not load file or assembly 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The system cannot find the file specified.'"</Description>
    <CreatedDate>20/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41922</IssueID>
    <RepoID>1</RepoID>
    <Title>Sudden failure to roundtrip using binary serialization</Title>
    <Description>The following revision of the game Rogue Survivor Revived , https://bitbucket.org/zaimoni/roguesurvivor-revived/commits/6408564940e8cb079db23e6c8f79085a22c84fae , was able to load its own savefiles when built with Visual Studio 16.3.4, but does not do so with Visual Studio 16.3.5.  I'm not clear on where to report this.  I chose here as it looks like a reversion of https://github.com/dotnet/coreclr/pull/21193 which fixes https://github.com/dotnet/corefx/issues/33655 .  [The Actor class has a readonly struct as a member; that would be expected to fail if this fix were reverted.]

The new exception stopping loading the savefile when building with 16.3.5, that is not thrown when building with 16.3.4, is:
System.ArgumentException: 'Field in TypedReferences cannot be static or init only.'

which is thrown from BinaryFormatter::Deserialize as follows:

    public static _T_ BinaryDeserialize&lt;_T_&gt;(this string filepath)
    {
#if DEBUG
if (string.IsNullOrEmpty(filepath)) throw new ArgumentNullException(nameof(filepath));
#endif
using (Stream stream = filepath.CreateStream(false)) {
return (T)(new BinaryFormatter()).Deserialize(stream);
}
}</Description>
    <CreatedDate>20/10/2019</CreatedDate>
    <ClosedDate>20/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41921</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient does not add referer header to redirects when allowautoredirect is true</Title>
    <Description>According to 
https://docs.microsoft.com/en-us/dotnet/api/system.net.httpwebrequest.referer?view=netframework-4.8 
"If the AllowAutoRedirect property is true, the Referer property is set automatically when the request is redirected to another site."

However, this behavior does not happen. 

Quick reproducible code: 
            var request = HttpWebRequest.CreateHttp( "https://httpstat.us/302" );
            request.AllowAutoRedirect = true;
            await request.GetResponseAsync();</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41920</IssueID>
    <RepoID>1</RepoID>
    <Title>Add `Replace()` methods to `ImmutableList` builder</Title>
    <Description>`ImmutableList&lt;T&gt;.Builder` is missing the `Replace()` methods `ImmutableList&lt;T&gt;` has. This PR adds them.

The implementation is very similar to [`ImmutableList&lt;T&gt;.Replace()`](https://github.com/dotnet/corefx/blob/5e4bf872154c17a1407997a38cc013fb12d5d1af/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableList_1.cs#L397), so there is some duplication. The test cases naturally also kind of duplicate the [tests for `ImmutableList&lt;T&gt;.Replace()`](https://github.com/dotnet/corefx/blob/5e4bf872154c17a1407997a38cc013fb12d5d1af/src/System.Collections.Immutable/tests/ImmutableListTest.cs#L527).</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41919</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix XSLT tests to deterministically pick newer xsltc.exe</Title>
    <Description>My machine had several:
```
C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.7.2 Tools\xsltc.exe
C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\xsltc.exe
C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\x64\xsltc.exe
C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\xsltc.exe
```
It picked the 4th one above. It should pick the 2nd one in order to produce results matching the expected baseline.</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41918</IssueID>
    <RepoID>1</RepoID>
    <Title>A few more test scenarios for casting of nullables and open generic arrays.</Title>
    <Description>- nullables have different rules for object/type/reflection casting. Since castability depends on who is asking, there is some fragility and need for test coverage. 

- internal representation of open `T[]` arrays may reuse methodtable from `object[]` assuming that instances will not be created anyways. Type analysis must be careful to not use method tables as type info or identity for these.</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>20/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41917</IssueID>
    <RepoID>1</RepoID>
    <Title>Strange `MembersMustExist` error when adding `Replace()` method to `ImmutableList` builder</Title>
    <Description>I noticed that the [`ImmutableList&lt;T&gt;.Builder`](https://github.com/dotnet/corefx/blob/master/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableList_1.Builder.cs) class is missing the method `Replace()` [that `ImmutableList&lt;T&gt;` has](https://github.com/dotnet/corefx/blob/5e4bf872154c17a1407997a38cc013fb12d5d1af/src/System.Collections.Immutable/src/System/Collections/Immutable/ImmutableList_1.cs#L397).

So, I created a fork and [added it along with tests](https://github.com/bert2/corefx/commit/98b52e37eab65cf1e67f6c18b74f3268bfc444ba) re-using the [test cases](https://github.com/dotnet/corefx/blob/5e4bf872154c17a1407997a38cc013fb12d5d1af/src/System.Collections.Immutable/tests/ImmutableListTest.cs#L527) for `ImmutableList&lt;T&gt;.Replace()`.

However, trying to build with...
```
PS&gt; .\build.cmd -build System.Collections.Immutable
```
...shows me this error:
&gt;C:\Users\bert\.nuget\packages\microsoft.dotnet.apicompat\5.0.0-beta.19518.2\build\Microsoft.DotNet.ApiCompat.targets(143,5): error : MembersMustExist : Member 'System.Collections.Immutable.ImmutableList&lt;T&gt;.Builder.Replace(T, T)' does not exist in the reference but it does exist in the implementation. [D:\DEV\corefx\src\System.Collections.Immutable\src\System.Collections.Immutable.csproj]
C:\Users\bert\.nuget\packages\microsoft.dotnet.apicompat\5.0.0-beta.19518.2\build\Microsoft.DotNet.ApiCompat.targets(143,5): error : MembersMustExist : Member 'System.Collections.Immutable.ImmutableList&lt;T&gt;.Builder.Replace(T, T, System.Collections.Generic.IEqualityComparer&lt;T&gt;)' does not exist in the reference but it does exist in the implementation. [D:\DEV\corefx\src\System.Collections.Immutable\src\System.Collections.Immutable.csproj]
C:\Users\bert\.nuget\packages\microsoft.dotnet.apicompat\5.0.0-beta.19518.2\build\Microsoft.DotNet.ApiCompat.targets(157,5): error : MatchingRefApiCompat failed - The reference assembly doesn't match all the APIs in the implementation for 'D:\DEV\corefx\artifacts\bin\System.Collections.Immutable\netcoreapp-Debug\System.Collections.Immutable.dll'. To address either fix errors in the reference assembly (referenced as implementation in compat errors for this reverse compat check), add the issues to the baseline file 'D:\DEV\corefx\src\System.Collections.Immutable\src\MatchingRefApiCompatBaseline.txt' or disable this check by setting RunMatchingRefApiCompat=false in this project. [D:\DEV\corefx\src\System.Collections.Immutable\src\System.Collections.Immutable.csproj]

I'm not quite sure what this error is telling me or how I'm supposed to fix it. Can anyone assist, please?

The build succeeds when I remove the `&lt;Exec Command="$(_ApiCompatCommand) ...` tag from `Microsoft.DotNet.ApiCompat.targets`. By that I was able to verify that my test cases are green using:
```
PS&gt; .\build.cmd -buildtests -test System.Collections.Immutable
```

</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41916</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json - JsonSerializer.SerializeAsync?</Title>
    <Description>I create test console app,(use net core3.0), and code as below:

`using System;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;

namespace TestConsoleApp1
{
    class Program
    {
        async static Task Main(string[] args)
        {
            var obj = new { Name = "Test", Age = 18 };

            string json = string.Empty;
            using (var stream = new MemoryStream())
            {
                await JsonSerializer.SerializeAsync(stream, obj);
                stream.Position = 0;
                using var reader = new StreamReader(stream);
                json = await reader.ReadToEndAsync();
            }

            Console.WriteLine(json);    //output {"Name":"Test","Age":18}, is ok
            Console.WriteLine(await GetJson(obj));  //output {}, why?

            Console.ReadLine();
        }

        private static async Task&lt;string&gt; GetJson(object obj)
        {
            string json = string.Empty;
            using (var stream = new MemoryStream())
            {
                await JsonSerializer.SerializeAsync(stream, obj);
                stream.Position = 0;
                using var reader = new StreamReader(stream);
                json = await reader.ReadToEndAsync();
            }
            return json;
        }
    }
}
`

output
{"Name":"Test","Age":18}
{}

the same code, but to output different results, why?</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>20/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41915</IssueID>
    <RepoID>1</RepoID>
    <Title>How can I new a MultiSegment ReadOnlySequence manually for unit test purpose ?</Title>
    <Description>I just want to test/debug my code correctness for processing a MultiSegment ReadOnlySequence.</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41914</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191018.2
- **Date Produced**: 10/18/2019 9:12 PM
- **Commit**: f59f1ebe9b293ad523d3bfa4e5cffc663708ef11
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19518.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19518.2
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19518.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191018.11
- **Date Produced**: 10/19/2019 5:16 AM
- **Commit**: 4de60f765b2d98b67f59390f40d7ee4c72a2daca
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19518.11
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19518.11
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19518.11

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191018.10
- **Date Produced**: 10/19/2019 7:13 AM
- **Commit**: 5590d3896f012c1c9b7774774456331a36ba1d57
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19518.10
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19518.10

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191018.1
- **Date Produced**: 10/18/2019 12:44 PM
- **Commit**: 75deb0e823d1f1958de359e5320dff710288468d
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19518.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41913</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Composition.AttributedModel is released with mixed assembly versions.</Title>
    <Description>Starting with v1.3.0, the NuGet package of System.Composition.AttributedModel contains mixed versions!
For netstandard1.0 and portable it contains version 1.0.33, but for netstandard2.0 it is 1.0.34.

This leads to the conflict that if you reference two assemblies, one build for net4x and one build for netstandard2x, and all using System.Composition 1.3.0, you get a runtime error that System.Composition.AttributedModel 1.0.33 could not be loaded, because 1.0.34 is in the bin folder,
but the net4x assembly has a reference to the 1.0.33 assembly.

How to reproduce:
- Get https://github.com/tom-englert/TomsToolbox
- Upgrade System.Composition to 1.3.0
- Build
- Run tests
Now one test fails with an exception that System.Composition.AttributedModel 1.0.33 could not be loaded

Might be related to #41393</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41912</IssueID>
    <RepoID>1</RepoID>
    <Title>Prepare license and other files for the repo consolidation</Title>
    <Description>- The /*.md filter isn't working in AzDO, therefore we are listening the excluded files manually. 
- Renaming CODE_OF_CONDUCT.md to CODE-OF-CONDUCT.TXT to be consistent with THIRD-PARTY-NOTICES.TXT
- Rename LICENSE.TXT to LICENSE so that GH picks it up correctly and to align it with core-setup.</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41911</IssueID>
    <RepoID>1</RepoID>
    <Title>End of Stream in PostAsyncExpect100Continue_NonSuccessResponse_RequestBodyNotSent test</Title>
    <Description>System.Net.Http.Functional.Tests.SocketsHttpHandlerTest_Http2.PostAsyncExpect100Continue_NonSuccessResponse_RequestBodyNotSent
```
System.IO.IOException : End of stream

Stack trace
   at System.Net.Test.Common.Http2LoopbackConnection.ReadBodyAsync() in /_/src/Common/tests/System/Net/Http/Http2LoopbackConnection.cs:line 488
   at System.Net.Http.Functional.Tests.HttpClientHandlerTest_Http2.&lt;&gt;c__DisplayClass67_0.&lt;&lt;PostAsyncExpect100Continue_NonSuccessResponse_RequestBodyNotSent&gt;b__1&gt;d.MoveNext() in /_/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.Http2.cs:line 1931
--- End of stack trace from previous location ---
   at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks) in /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs:line 83
   at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks) in /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs:line 111
   at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout) in /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs:line 71
   at System.Net.Test.Common.Http2LoopbackServer.CreateClientAndServerAsync(Func`2 clientFunc, Func`2 serverFunc, Int32 timeout) in /_/src/Common/tests/System/Net/Http/Http2LoopbackServer.cs:line 186
   at System.Net.Http.Functional.Tests.HttpClientHandlerTest_Http2.PostAsyncExpect100Continue_NonSuccessResponse_RequestBodyNotSent() in /_/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.Http2.cs:line 1899
--- End of stack trace from previous location ---
```
https://dev.azure.com/dnceng/public/_build/results?buildId=393660&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=12233140&amp;resultId=157765&amp;paneView=debug

netcoreapp-Linux-Debug-x64-(Alpine.310.Amd64.Open)ubuntu.1604.amd64.Open</Description>
    <CreatedDate>19/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41910</IssueID>
    <RepoID>1</RepoID>
    <Title>Add UTF8Encoding compat tests</Title>
    <Description>Complementary unit tests for https://github.com/dotnet/coreclr/pull/27268. These tests ensure we haven't regressed the type's behavior in the face of users subclassing it in unanticipated ways.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41909</IssueID>
    <RepoID>1</RepoID>
    <Title>Add file creation method that takes an ACL</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41614

As soon as [the PR for directory creation ](https://github.com/dotnet/corefx/pull/41834) is merged, I'll rebase this branch to reduce the number of edited files in this PR.

@JeremyKuhne</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41908</IssueID>
    <RepoID>1</RepoID>
    <Title>WIP: Update CoreFx to CMake 3.14.</Title>
    <Description>Update CoreFx build images to have CMake 3.14 and update the build to require CMake 3.14 so we have a consistent toolset for the consolidated repository.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41907</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemAclExtensions methods should null check the "this" argument</Title>
    <Description>These methods should null check the `this` argument:

https://github.com/dotnet/corefx/blob/226f57b4f2bf91822604aa73338070c601d7a0fe/src/System.IO.FileSystem.AccessControl/src/System/IO/FileSystemAclExtensions.cs

cc @JeremyKuhne @stephentoub</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41906</IssueID>
    <RepoID>1</RepoID>
    <Title>Adding single statement if formatting rule to coding-style</Title>
    <Description>cc: @stephentoub @carlossanlop 

This came up in a recent PR and I just wanted to make it more clear in our Coding guidelines.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41904</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Reflection.DispatchProxy for nullable</Title>
    <Description>Contributes to: #40623</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41903</IssueID>
    <RepoID>1</RepoID>
    <Title>Support IDictionary&lt;string,TValue&gt; without IDictionaryEnumerator</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41329. I was unable to verify against the linked repro because `SqlMapper.DapperRow` and `.DapperTable` are not public members.

Originally this was going to also have a perf fix that removes boxing of the dictionary enumerator as well, but I decided to just have the raw fix that enables `IDictionary&lt;TKey, TValue&gt;`-derived dictionaries to work properly.

This may have some conflicts with https://github.com/dotnet/corefx/pull/41482

This is expected to be ported to 3.1.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41901</IssueID>
    <RepoID>1</RepoID>
    <Title>Guidance on HTTP2 client side and plan for HTTP3</Title>
    <Description>We have `.NET Framework 4.5`, `.NET Core 2.1`, and `.NET Standard 2.0` client libraries on Windows and Linux that all use `HttpClient`. Looking for guidance on enabling `HTTP2` whenever possible, with fallback to HTTP1.1.

For background, our servers already support HTTP2 (and some even HTTP3/Quic) and everything is over TLS 1.2.

Looking beyond, what's the plan for HTTP3/Quic on the client side? With some work from Cloudflare, we've enabled HTTP3 on some servers and the performance is again notable, so we're trying to establish the plan here.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41900</IssueID>
    <RepoID>1</RepoID>
    <Title>Better experience for investigating assembly loading issues (Could not load file or assembly &lt;assembly name&gt; or one of its dependencies. The system cannot find the file specified.)</Title>
    <Description>In my experience, this is one of the most annoying and sometimes quite time consuming errors that I get with C# apps. If my experience is shared by most developers, it means this error is wasting a lot of developer time world wide. Would there be ways to improve it to reduce wasted time? For example, the message part with `or one of its dependencies` is vague. Could the runtime detect exactly which assembly failed to load exactly which dependency and just print that broken chain out instead of `or one of its dependencies`?</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41899</IssueID>
    <RepoID>1</RepoID>
    <Title>dotnetcore Kestrel Http/2 support without https</Title>
    <Description>The Kestrel using .net core 3.0, does not support Http/2 protocol even if protocol is set.
o.ConfigureEndpointDefaults(lo =&gt; lo.Protocols = HttpProtocols.Http1AndHttp2);

and added the context switch too.
AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);

The Client application using Request.Version = 2.0 works on say "https://google.com", but fails to work on "http://google.com".
Our scenario is our URL is https, but the SSL is terminated at the load balancer, so the application server hosting the kestrel based micro service does not get https, but only http connections.

How to make the server support the http/2?
</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41898</IssueID>
    <RepoID>1</RepoID>
    <Title>`Directory.EnumerateFiles(dir, pat)` is sometimes 45-50x slower on .NET Core 3.0 compared to .NET Framework 4.8 / .NET Core 2.0</Title>
    <Description>`Directory.EnumerateFiles(dir, pat)` is sometimes 45-50x slower on .NET Core 3.0 compared to .NET Framework 4.8 / .NET Core 2.0

Discovered by @iSazonov, see https://github.com/PowerShell/PowerShell/issues/6577#issuecomment-543194018

Related:

- https://github.com/dotnet/corefx/pull/25426
- https://github.com/dotnet/corefx/pull/26806
- https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/

Methods:

- PS1(): 2000 x `Directory.EnumerateFiles(@"C:\WINDOWS\system32\", "ping.*")`
- Blog(): 2000 x `Directory.EnumerateFiles(@"d:\repos\corefx\src\System.IO.FileSystem\", "*.cs", SearchOption.AllDirectories)`

.NET | PS1() | Blog()
-----|-------|-------
.NET Framework 4.8 | 78 ms | 4393 ms
.NET Core 1.0 | 93 ms | 5298 ms
.NET Core 1.1 | 91 ms | 4712 ms
.NET Core 2.0 | 76 ms | 4729 ms
.NET Core 2.1 | 4314 ms | 1585 ms
.NET Core 2.2 | 4286 ms | 1599 ms
.NET Core 3.0 | 3788 ms | 1538 ms
.NET Core 3.1 | 3753 ms | 1538 ms

You can also test this PowerShell command

```psh
Measure-Command { for ($i=0; $i -lt 2000; $i++) { Get-Command ping &gt; $null } }
```

PS | tfm | Time (s)
---|-----|---------
PS 5.1 | net48 | 0.5251987
PS 7.0 | netcoreapp3.0 | 4.1898758

Most expensive calls:

.NET Framework 4.8 and .NET Core 2.0

```
Name                                                                                            Inc %   Inc
 consoleapp1!ConsoleApp1.Program.PS1(class System.String)                                         2.2    90
+ mscorlib.ni!Directory.EnumerateFiles                                                            1.5    62
|+ mscorlib.ni!System.IO.FileSystemEnumerableIterator`1[System.__Canon]..ctor(...)                1.5    61
||+ mscorlib.ni!System.IO.FileSystemEnumerableIterator`1[System.__Canon].CommonInit()             1.2    49
|| + mscorlib.ni!DomainNeutralILStubClass.IL_STUB_PInvoke(System.String, WIN32_FIND_DATA ByRef)   1.2    48
||  + kernelbase!FindFirstFileW                                                                   1.2    47
||   + kernelbase!FindFirstFileExW                                                                1.2    47
```

.NET Core 3.1 (3.1.100-preview1-014459)

```
Name                                                                                                     Inc %      Inc
 consoleapp1!ConsoleApp1.Program.PS1(class System.String)                                                 62.6    2,884
+ system.io.filesystem.il!System.IO.Enumeration.FileSystemEnumerator`1[System.__Canon].MoveNext()         53.8    2,479
|+ system.io.filesystem.il!System.IO.Enumeration.FileSystemEnumerator`1[System.__Canon].FindNextEntry()   47.2    2,175
||+ system.io.filesystem.il!dynamicClass.IL_STUB_PInvoke(...)                                             45.4    2,093
|||+ ntdll!NtQueryDirectoryFile                                                                           45.3    2,086
```

Repro
- Update the path to corefx repo in the source code below
- Compile the code below
- Run the executable on Windows

```C#
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            const string psPattern = "ping.*";
            const string blogPattern = "*.cs";
            for (int i = 0; i &lt; 100; i++) {
                PS1(psPattern);
                Blog(blogPattern);
            }
            var swPS1 = Stopwatch.StartNew();
            for (int i = 0; i &lt; 2000; i++)
                PS1(psPattern);
            swPS1.Stop();
            var swBlog = Stopwatch.StartNew();
            for (int i = 0; i &lt; 2000; i++)
                Blog(blogPattern);
            swBlog.Stop();
            Console.WriteLine($"{IntPtr.Size * 8}-bit");
#if NETCOREAPP1_0
            Console.WriteLine("netcoreapp1.0");
#elif NETCOREAPP1_1
            Console.WriteLine("netcoreapp1.1");
#else
            Console.WriteLine(typeof(object).Assembly.Location);
#endif
            Console.WriteLine($"PS1 : {swPS1.ElapsedMilliseconds} ms");
            Console.WriteLine($"Blog: {swBlog.ElapsedMilliseconds} ms");
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void Blog(string pattern)
        {
            foreach (string path in Directory.EnumerateFiles(@"d:\repos\corefx\src\System.IO.FileSystem\", pattern, SearchOption.AllDirectories))
            {
                Use(path);
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void PS1(string pattern)
        {
            var directories = new string[]
            {
                @"C:\WINDOWS\system32\",
            };
            foreach (var directory in directories)
            {
                foreach (var f in Directory.EnumerateFiles(directory, pattern))
                {
                    Use(f);
                }
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void Use(string s) { }
    }
}
```

```csproj
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;netcoreapp3.1;netcoreapp3.0;netcoreapp2.2;netcoreapp2.1;netcoreapp2.0;netcoreapp1.1;netcoreapp1.0;net48&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
```

```pwsh
dotnet build -c Release -f net48
dotnet publish -c Release -f netcoreapp1.0 -r win7-x64 --self-contained
dotnet publish -c Release -f netcoreapp1.1 -r win7-x64 --self-contained
dotnet publish -c Release -f netcoreapp2.0 -r win-x64 --self-contained
dotnet publish -c Release -f netcoreapp2.1 -r win-x64 --self-contained
dotnet publish -c Release -f netcoreapp2.2 -r win-x64 --self-contained
dotnet publish -c Release -f netcoreapp3.0 -r win-x64 --self-contained
dotnet publish -c Release -f netcoreapp3.1 -r win-x64 --self-contained
```

```pwsh
.\ConsoleApp1\bin\Release\net48\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp1.0\win7-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp1.1\win7-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp2.0\win-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp2.1\win-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp2.2\win-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp3.0\win-x64\publish\ConsoleApp1.exe
echo ''
.\ConsoleApp1\bin\Release\netcoreapp3.1\win-x64\publish\ConsoleApp1.exe
echo ''
```
</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41897</IssueID>
    <RepoID>1</RepoID>
    <Title>[Regression] in certificate store on OSX</Title>
    <Description>Hi,

We've run into an issue that we think it is a regression in the handling of certificates through the certificate store on Mac OS.

After installing .NET Core 3.1 preview1 on a machine, apps can't be launch from either the command line with `dotnet &lt;&lt;path-to-dll&gt;&gt;` nor the dotnet dev-certs tool is able to export existing certificates from the machine. All this works in 3.0.

This essentially blocks development from Visual Studio for Mac. More details can be found in the linked issue below.

This is the exception `dotnet dev-certs` sees when it tries to export the certificate
```console
Interop+AppleCrypto+AppleCommonCryptoCryptographicException: The user name or passphrase you entered is not correct.\n   at Interop.AppleCrypto.X509Export(X509ContentType contentType, SafeCreateHandle cfPassphrase, IntPtr[] certHandles)\n   at Interop.AppleCrypto.X509ExportPfx(IntPtr[] certHandles, SafePasswordHandle exportPassword)\n   at Internal.Cryptography.Pal.StorePal.AppleCertificateExporter.ExportPkcs12(SafePasswordHandle password)\n   at Internal.Cryptography.Pal.StorePal.AppleCertificateExporter.Export(X509ContentType contentType, SafePasswordHandle password)\n   at Internal.Cryptography.Pal.AppleCertificatePal.Export(X509ContentType contentType, SafePasswordHandle password)\n   at System.Security.Cryptography.X509Certificates.X509Certificate.Export(X509ContentType contentType, String password)\n   at Microsoft.AspNetCore.Certificates.Generation.CertificateManager.ExportCertificate(X509Certificate2 certificate, String path, Boolean includePrivateKey, String password, DiagnosticInformation diagnostics) in /Users/jacalvar/work/AspNetCore/src/Shared/CertificateGeneration/CertificateManager.cs:line 310
```

This is the exception kestrel displays in debug mode in the console
```console
dbug: Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware[1]
      Failed to authenticate HTTPS connection.
System.Security.Authentication.AuthenticationException: Authentication failed, see inner exception.
 ---&gt; Interop+AppleCrypto+SslException: Internal error
   --- End of inner exception stack trace ---
   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)
   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.ProcessAuthentication(LazyAsyncResult lazyResult, CancellationToken cancellationToken)
   at System.Net.Security.SslStream.BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, Object asyncState)
   at System.Net.Security.SslStream.&lt;&gt;c.&lt;AuthenticateAsServerAsync&gt;b__69_0(SslServerAuthenticationOptions arg1, CancellationToken arg2, AsyncCallback callback, Object state)
   at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl[TArg1,TArg2](Func`5 beginMethod, Func`2 endFunction, Action`1 endAction, TArg1 arg1, TArg2 arg2, Object state, TaskCreationOptions creationOptions)
   at System.Threading.Tasks.TaskFactory.FromAsync[TArg1,TArg2](Func`5 beginMethod, Action`1 endMethod, TArg1 arg1, TArg2 arg2, Object state, TaskCreationOptions creationOptions)
   at System.Threading.Tasks.TaskFactory.FromAsync[TArg1,TArg2](Func`5 beginMethod, Action`1 endMethod, TArg1 arg1, TArg2 arg2, Object state)
   at System.Net.Security.SslStream.AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware.InnerOnConnectionAsync(ConnectionContext context)
dbug: Microsoft.AspNetCore.Server.Kestrel[2]
      Connection id "0HLQJPMSPDN1E" stopped.
```

https://github.com/aspnet/AspNetCore/issues/15118</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41896</IssueID>
    <RepoID>1</RepoID>
    <Title>Vectorise BitArray</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41762 and https://github.com/dotnet/corefx/issues/37946
Related https://github.com/dotnet/corefx/pull/39173

This PR continues from the previous PR from @BruceForstall (#39173) in an attempt to speed up various operations of BitArray by vectorisation and using AVX2 256-bit wide instructions.

The performance difference, compared to before the optimizations were applied are as following, when operating on arrays of size 4/512/32768 (Threshold 5%):
```
summary:
better: 17, geomean: 3.773
worse: 3, geomean: 2.094
total diff: 20
```

| Slower                                                                | diff/base | Base Median (ns) | Diff Median (ns) | Modality|
| --------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 4)        |      4.76 |             0.78 |             3.72 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayNot(Size: 4)           |      1.79 |             0.92 |             1.64 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayBoolArrayCtor(Size: 4) |      1.08 |             9.83 |            10.61 |         |

| Faster                                                                      | base/diff | Base Median (ns) | Diff Median (ns) | Modality|
| --------------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Collections.Tests.Perf_BitArray.BitArrayBoolArrayCtor(Size: 32768)   |     88.64 |        116382.63 |          1312.93 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayCopyToBoolArray(Size: 32768) |     33.88 |        323823.66 |          9557.69 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayCopyToBoolArray(Size: 512)   |     25.40 |          5096.80 |           200.63 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayBoolArrayCtor(Size: 512)     |     14.80 |           407.56 |            27.54 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayNot(Size: 32768)             |      7.83 |          3679.64 |           469.90 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayNot(Size: 512)               |      6.55 |            61.56 |             9.39 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayCopyToBoolArray(Size: 4)     |      1.98 |            71.92 |            36.26 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayOr(Size: 512)                |      1.82 |            19.69 |            10.83 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 512)            |      1.75 |            53.17 |            30.31 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayAnd(Size: 512)               |      1.66 |            17.88 |            10.78 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 32768)          |      1.63 |          3078.29 |          1883.64 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayXor(Size: 512)               |      1.55 |            17.15 |            11.06 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayAnd(Size: 32768)             |      1.49 |          1259.86 |           847.41 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayXor(Size: 32768)             |      1.48 |          1261.98 |           853.47 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayOr(Size: 32768)              |      1.47 |          1238.11 |           842.76 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayLeftShift(Size: 4)           |      1.16 |             4.63 |             3.98 |         |
| System.Collections.Tests.Perf_BitArray.BitArrayCopyToByteArray(Size: 4)     |      1.10 |            23.14 |            21.08 |         |

Regarding the slowdown of `BitArraySetAll`, I have re-run the benchmarks with various sizes to see at which point the new implementation outrun the current implementation.
(Threshold 5%)
```
summary:                                                                                                                                                                                  better: 6, geomean: 1.345
worse: 2, geomean: 1.729
total diff: 8
```
| Slower                                                          | diff/base | Base Median (ns) | Diff Median (ns) | Modality|
| --------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 4)  |      2.69 |             1.39 |             3.74 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 16) |      1.11 |             3.16 |             3.50 |         |

| Faster                                                           | base/diff | Base Median (ns) | Diff Median (ns) | Modality|
| ---------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 512) |      1.76 |            53.79 |            30.51 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 64)  |      1.35 |             7.03 |             5.23 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 96)  |      1.31 |             9.52 |             7.25 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 128) |      1.30 |            11.93 |             9.21 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 256) |      1.22 |            22.09 |            18.09 |         |
| System.Collections.Tests.Perf_BitArray.BitArraySetAll(Size: 32)  |      1.20 |             4.08 |             3.40 |         |

Which suggests that it may be faster for filling BitArray that contains more than 32 elements. One thing to note though, is that the numbers for small sizes seem to fluctuate around for small sizes, so I suppose the results may be inaccurate. (Even for this benchmark, I expect the numbers to be similar for Size 4/16/32, since they are all stored in one `int` and therefore should be just a single copy of an int; but they all seem to give different results)

Furthermore, since the current implementation of `SetAll` operates on the whole of the backing array, this may result in unnecessary copying to unused area when the `BitArray.Length` has been set to make the BitArray smaller but the backing array hasn't been resized due to the new length not meeting the `_ShrinkThreshold` (in `int` counts): https://github.com/dotnet/corefx/blob/2b92fc0930b941cd0d9146971745cd717689434c/src/System.Collections/src/System/Collections/BitArray.cs#L23

The new implementation uses `GetInt32ArrayLengthFromBitLength(Length)` method to calculate where the used area are and only copies to that region. Unfortunately, since this happens for smaller sized arrays as well, this check on itself seem to results in approximately 0.7x slowdown when the array has less than 32 elements.

Regarding the use of AVX2, I figured out that AVX2 generally improved the performance despite the concerns about downclocking. This is an example comparison between various paths for BitArray(Array, int) with bool arrays (See https://github.com/dotnet/corefx/issues/41762#issuecomment-542658154 and https://github.com/dotnet/corefx/issues/41762#issuecomment-542831649 for benchmarks of And/or/xor/not and `BitArray(bool[])`):
```
// * Summary *                                                                                                          
BenchmarkDotNet=v0.11.5.1159-nightly, OS=Windows 10.0.18999                                                             Intel Core i7-8700 CPU 3.20GHz (Coffee Lake), 1 CPU, 12 logical and 6 physical cores
.NET Core SDK=5.0.100-alpha1-014899
  [Host]              : .NET Core 5.0.0-alpha1.19507.3 (CoreCLR 5.0.19.50101, CoreFX 5.0.19.50407), X64 RyuJIT
  Job-VRDFCM          : .NET Core ? (CoreCLR 5.0.19.51405, CoreFX 5.0.19.51801), X64 RyuJIT
  AVX2 Disabled       : .NET Core ? (CoreCLR 5.0.19.51405, CoreFX 5.0.19.51801), X64 RyuJIT
  Intrinsics Disabled : .NET Core ? (CoreCLR 5.0.19.51405, CoreFX 5.0.19.51801), X64 RyuJIT
```

|                  Method |                 Job |        EnvironmentVariables |                        PowerPlanMode | Toolchain | IterationTime | MaxIterationCount | MinIterationCount | WarmupCount |  Size |          Mean |      Error |     StdDev |        Median |           Min |           Max | Gen 0 | Gen 1 | Gen 2 | Allocated |
|------------------------ |-------------------- |---------------------------- |------------------------------------- |---------- |-------------- |------------------ |------------------ |------------ |------ |--------------:|-----------:|-----------:|--------------:|--------------:|--------------:|------:|------:|------:|----------:|
| BitArrayCopyToBoolArray |             Default |                       Empty | 00000000-0000-0000-0000-000000000000 |   CoreRun |   250.0000 ms |                20 |                15 |           1 |     4 |      35.90 ns |   0.218 ns |   0.203 ns |      35.84 ns |      35.60 ns |      36.26 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray |       AVX2 Disabled |        COMPlus_EnableAVX2=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default |     4 |      35.90 ns |   0.142 ns |   0.132 ns |      35.89 ns |      35.65 ns |      36.13 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray | Intrinsics Disabled | COMPlus_EnableHWIntrinsic=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default |     4 |      73.08 ns |   0.333 ns |   0.311 ns |      73.06 ns |      72.56 ns |      73.76 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray |             Default |                       Empty | 00000000-0000-0000-0000-000000000000 |   CoreRun |   250.0000 ms |                20 |                15 |           1 |   512 |     191.24 ns |   1.056 ns |   0.988 ns |     191.25 ns |     189.72 ns |     192.84 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray |       AVX2 Disabled |        COMPlus_EnableAVX2=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default |   512 |     220.78 ns |   0.819 ns |   0.766 ns |     220.75 ns |     219.00 ns |     221.94 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray | Intrinsics Disabled | COMPlus_EnableHWIntrinsic=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default |   512 |   5,221.48 ns |  16.221 ns |  12.664 ns |   5,227.59 ns |   5,202.04 ns |   5,235.70 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray |             Default |                       Empty | 00000000-0000-0000-0000-000000000000 |   CoreRun |   250.0000 ms |                20 |                15 |           1 | 32768 |   9,776.74 ns |  89.691 ns |  74.896 ns |   9,756.03 ns |   9,696.10 ns |   9,976.58 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray |       AVX2 Disabled |        COMPlus_EnableAVX2=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default | 32768 |  11,746.34 ns |  50.812 ns |  42.431 ns |  11,735.14 ns |  11,679.19 ns |  11,834.34 ns |     - |     - |     - |         - |
| BitArrayCopyToBoolArray | Intrinsics Disabled | COMPlus_EnableHWIntrinsic=0 | 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c |    Before |       Default |           Default |           Default |     Default | 32768 | 331,026.89 ns | 936.011 ns | 781.612 ns | 331,110.79 ns | 330,069.53 ns | 332,353.66 ns |     - |     - |     - |         - |</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41895</IssueID>
    <RepoID>1</RepoID>
    <Title>EnsureSuccessStatusCode should write the response content in the exception if set</Title>
    <Description>EnsureSuccessStatusCode should write the response content in the exception if set
We often face issues when using the method EnsureSuccessStatusCode and want to see the reason in application insights.
For example when calling Azure Apis or Apis that uses the APIController then the response message in case of bad requests contains more details what was going wrong. 
With the current implementation you only see the statuscode and reasonphrase but not the detailed error that occured.

Example code what should be achieved:

  private static void EnsureSuccessStatusCode(HttpResponseMessage response)
        {
            if (!response.IsSuccessStatusCode)
            {
                var responseContent = response.Content == null
                    ? "NoContent"
                    : response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                throw new HttpRequestException($"{response.StatusCode} (ReasonPhrase: {response.ReasonPhrase}, Content: {responseContent})");
            }
        }


or Async

  private static async Task EnsureSuccessStatusCodeAsync(HttpResponseMessage response)
        {
            if (!response.IsSuccessStatusCode)
            {
                var responseContent = response.Content == null
                    ? "NoContent"
                    :  await response.Content.ReadAsStringAsync();
                throw new HttpRequestException($"{response.StatusCode} (ReasonPhrase: {response.ReasonPhrase}, Content: {responseContent})");
            }
        }
</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41894</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191018.1
- **Date Produced**: 10/18/2019 8:58 AM
- **Commit**: 2b92fc0930b941cd0d9146971745cd717689434c
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19518.1
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19518.1

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191017.2
- **Date Produced**: 10/18/2019 12:24 AM
- **Commit**: 5deb1e0d2398f1460d16e7fc4e878ad5f2cb3a0d
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19517.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41893</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191017.4
- **Date Produced**: 10/18/2019 1:06 AM
- **Commit**: e4c2246075d5c8cb040f75fbe58cbc089f67a5b2
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19517.4
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19517.4
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19517.4

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41892</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191018.1
- **Date Produced**: 10/18/2019 9:40 AM
- **Commit**: 83b657163a4a0fa7f64ed635ef65d830d48753e2
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19518.1
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19518.1
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19518.1

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41891</IssueID>
    <RepoID>1</RepoID>
    <Title>Use Loopback for PreAuthenticate request test</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/39581
</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41890</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable MemoryCacheTest.Contains test</Title>
    <Description>Failed multiple times in CI. https://github.com/dotnet/corefx/issues/37989

cc @StephenMolloy, @HongGit</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41889</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove clean target and use arcade one</Title>
    <Description>We can now use the clean target provided by arcade.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41888</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove Socket.InnerSafeCloseSocket</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41551

@stephentoub @wfurt @geoffkizer ptal.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41887</IssueID>
    <RepoID>1</RepoID>
    <Title>(De)serializing stacks with JsonSerializer should round-trip</Title>
    <Description>The serializer currently doesn't roundtrip i.e serialize -&gt; deserialize -&gt; serialize does not result in the same state.

More discussion:
- https://github.com/dotnet/corefx/issues/40479#issuecomment-523586917
- https://github.com/dotnet/corefx/pull/41482#discussion_r336194875</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41886</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] About AddNewtonsoftJson</Title>
    <Description>hello,I have a problem that is 
![image](https://user-images.githubusercontent.com/37535153/67064623-d5c30c80-f19d-11e9-97fc-0ab87b0d1ceb.png)
but 
![image](https://user-images.githubusercontent.com/37535153/67064645-ea070980-f19d-11e9-96c2-5938ae881bad.png)
the method
![image](https://user-images.githubusercontent.com/37535153/67072188-e59b1a80-f1b6-11e9-9d83-f3563f38fe04.png)
Notice:
![image](https://user-images.githubusercontent.com/37535153/67072210-f21f7300-f1b6-11e9-9b13-b10fa3286de7.png)
Page:
![image](https://user-images.githubusercontent.com/37535153/67072234-ffd4f880-f1b6-11e9-868e-f1b23f2574c9.png)

please tell me how to solve?thanks</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41885</IssueID>
    <RepoID>1</RepoID>
    <Title>Handle References on Deserialization</Title>
    <Description>Second approach. Instead of using `HandleDelayedStart` I am wrapping enumarables into JsonPreservedReference&lt;T&gt; when they are read as a preserved array, that is
```json
{ 
  "$id": "1",
  "$values": []
}
```

See ground rules and feature specs in this [gist](https://gist.github.com/Jozkee/50bc307395a8caa684a425ac67a323b4)

I am still having troubles with dictionaries when they are processed as a property and `IgnoreNullValues` option is set.

Also I am having some race condition troubles when validating against `ReadStackFrame` properties in `JsonClasInfo`.

## Benchmark results:

There is a regression of 7% - 1% on below benchmarks, will try to address that.

&lt;details&gt;&lt;summary&gt;Base&lt;/summary&gt;
&lt;p&gt;

|                                                Type |                Method |         Mean |       Error |      StdDev |       Median |          Min |          Max |   Gen 0 |  Gen 1 | Gen 2 | Allocated |
|---------------------------------------------------- |---------------------- |-------------:|------------:|------------:|-------------:|-------------:|-------------:|--------:|-------:|------:|----------:|
|                                 ReadJson&lt;ArrayList&gt; | DeserializeFromString |  62,086.8 ns |   353.08 ns |   312.99 ns |  62,104.7 ns |  61,181.4 ns |  62,458.3 ns |  7.7000 |      - |     - |   32696 B |
|                                ReadJson&lt;BinaryData&gt; | DeserializeFromString |     839.3 ns |    15.56 ns |    14.56 ns |     838.5 ns |     822.7 ns |     875.2 ns |  0.2543 |      - |     - |    1072 B |
|                ReadJson&lt;Dictionary&lt;String, String&gt;&gt; | DeserializeFromString |  29,534.4 ns |   366.25 ns |   342.59 ns |  29,470.9 ns |  29,058.8 ns |  30,163.0 ns |  6.1664 |      - |     - |   25864 B |
|                           ReadJson&lt;HashSet&lt;String&gt;&gt; | DeserializeFromString |  20,690.4 ns |   204.66 ns |   181.43 ns |  20,677.6 ns |  20,377.7 ns |  21,156.4 ns |  4.1841 | 0.2461 |     - |   17504 B |
|                                 ReadJson&lt;Hashtable&gt; | DeserializeFromString |  86,380.6 ns |   752.54 ns |   628.41 ns |  86,258.1 ns |  85,341.0 ns |  87,403.7 ns | 12.0027 |      - |     - |   50912 B |
|       ReadJson&lt;ImmutableDictionary&lt;String, String&gt;&gt; | DeserializeFromString |  72,773.8 ns |   683.56 ns |   570.81 ns |  72,669.3 ns |  72,005.8 ns |  74,190.3 ns |  8.4693 | 0.9410 |     - |   35780 B |
| ReadJson&lt;ImmutableSortedDictionary&lt;String, String&gt;&gt; | DeserializeFromString | 154,006.5 ns | 1,912.73 ns | 1,789.17 ns | 153,251.6 ns | 152,418.5 ns | 158,405.6 ns |  9.8099 | 1.2262 |     - |   42629 B |
|                            ReadJson&lt;IndexViewModel&gt; | DeserializeFromString |  41,101.8 ns |   330.97 ns |   258.40 ns |  41,131.2 ns |  40,686.3 ns |  41,564.9 ns |  5.2083 | 0.5208 |     - |   22440 B |
|                                  ReadJson&lt;Location&gt; | DeserializeFromString |   1,594.5 ns |    30.50 ns |    28.53 ns |   1,589.4 ns |   1,550.7 ns |   1,654.8 ns |  0.1011 |      - |     - |     448 B |
|                            ReadJson&lt;LoginViewModel&gt; | DeserializeFromString |     607.2 ns |    23.63 ns |    26.27 ns |     596.6 ns |     573.9 ns |     662.6 ns |  0.0389 |      - |     - |     168 B |
|                   ReadJson&lt;MyEventsListerViewModel&gt; | DeserializeFromString | 484,680.8 ns | 3,486.85 ns | 3,091.00 ns | 484,555.6 ns | 478,693.3 ns | 489,668.1 ns | 17.6125 |      - |     - |   78648 B |
&lt;/p&gt;
&lt;/details&gt;

&lt;details&gt;&lt;summary&gt;After&lt;/summary&gt;
&lt;p&gt;

|                                                Type |                Method |         Mean |       Error |      StdDev |       Median |          Min |          Max |   Gen 0 |  Gen 1 | Gen 2 | Allocated |
|---------------------------------------------------- |---------------------- |-------------:|------------:|------------:|-------------:|-------------:|-------------:|--------:|-------:|------:|----------:|
|                                 ReadJson&lt;ArrayList&gt; | DeserializeFromString |  63,312.8 ns | 1,160.83 ns | 1,085.84 ns |  63,519.5 ns |  61,163.5 ns |  65,100.3 ns |  7.5834 |      - |     - |   32696 B |
|                                ReadJson&lt;BinaryData&gt; | DeserializeFromString |     869.6 ns |    20.14 ns |    17.85 ns |     867.8 ns |     845.4 ns |     914.1 ns |  0.2545 |      - |     - |    1072 B |
|                ReadJson&lt;Dictionary&lt;String, String&gt;&gt; | DeserializeFromString |  30,412.7 ns |   607.58 ns |   623.94 ns |  30,555.6 ns |  29,184.4 ns |  31,619.3 ns |  6.0643 |      - |     - |   25864 B |
|                           ReadJson&lt;HashSet&lt;String&gt;&gt; | DeserializeFromString |  22,084.2 ns |   553.97 ns |   615.73 ns |  22,386.9 ns |  21,087.2 ns |  22,867.7 ns |  4.1129 | 0.2804 |     - |   17504 B |
|                                 ReadJson&lt;Hashtable&gt; | DeserializeFromString |  93,196.1 ns | 2,177.92 ns | 2,037.23 ns |  92,961.7 ns |  90,637.1 ns |  98,416.5 ns | 12.0438 |      - |     - |   50912 B |
|       ReadJson&lt;ImmutableDictionary&lt;String, String&gt;&gt; | DeserializeFromString |  75,778.8 ns | 1,398.18 ns | 1,307.86 ns |  75,816.3 ns |  73,681.8 ns |  77,895.9 ns |  8.2889 | 1.1841 |     - |   35780 B |
| ReadJson&lt;ImmutableSortedDictionary&lt;String, String&gt;&gt; | DeserializeFromString | 164,136.6 ns | 3,202.49 ns | 2,995.61 ns | 163,523.2 ns | 160,032.1 ns | 171,265.1 ns |  9.6339 | 1.2845 |     - |   42635 B |
|                            ReadJson&lt;IndexViewModel&gt; | DeserializeFromString |  44,202.0 ns |   883.41 ns | 1,017.34 ns |  44,040.7 ns |  42,945.8 ns |  46,613.8 ns |  5.3073 | 0.3424 |     - |   22506 B |
|                                  ReadJson&lt;Location&gt; | DeserializeFromString |   1,700.3 ns |    33.40 ns |    32.80 ns |   1,703.6 ns |   1,653.2 ns |   1,758.1 ns |  0.0994 |      - |     - |     448 B |
|                            ReadJson&lt;LoginViewModel&gt; | DeserializeFromString |     627.3 ns |    15.92 ns |    17.03 ns |     622.0 ns |     607.5 ns |     662.6 ns |  0.0390 |      - |     - |     168 B |
|                   ReadJson&lt;MyEventsListerViewModel&gt; | DeserializeFromString | 488,908.5 ns | 6,081.57 ns | 5,078.38 ns | 488,549.3 ns | 479,979.8 ns | 496,211.3 ns | 17.2745 | 3.8388 |     - |   78712 B |

&lt;/p&gt;
&lt;/details&gt;</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41884</IssueID>
    <RepoID>1</RepoID>
    <Title>tracing in NameResolution should be improved</Title>
    <Description>I wrote simple app to lookup one name expected to succeed and one expected to fail:
 
```c#
Task t1 = Task.Run(() =&gt; Dns.GetHostEntry("www.foo.com"));
Task t2 = Task.Run(() =&gt; Dns.GetHostEntry("www.foo22.com"));
Task t3 = Dns.GetHostEntryAsync("www.foo.com");
Task t4 = Dns.GetHostEntryAsync("www.foo22.com"); 
```
and I enabled tracing for NameResolution (or use dotnet-trace) 
```
COMPlus_EnableEventPipe=1
COMPlus_EventPipeConfig=Microsoft-System-Net-NameResolution:0xFFFFFFFFFFFFFFFF:5
```
I get following entries for synchronous successful call:
```
&lt;Event MSec=  "6067.9290" PID="10091" PName="Process(10091)" TID="10091" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="GetHostEntry" parameters="(www.foo.com)"/&gt;
&lt;Event MSec=  "6068.6685" PID="10091" PName="Process(10091)" TID="10091" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="InternalGetHostByName" parameters="(www.foo.com)"/&gt;
&lt;Event MSec= "11089.9084" PID="10091" PName="Process(10091)" TID="10091" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="InternalGetHostByName" result="IPHostEntry#33476626"/&gt;
&lt;Event MSec= "11089.9167" PID="10091" PName="Process(10091)" TID="10091" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="GetHostEntry" result="IPHostEntry#33476626"/&gt;
```
and this for failing one:
```
&lt;Event MSec=  "4770.0633" PID="10308" PName="Process(10308)" TID="10308" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="GetHostEntry" parameters="(www.foo2.com)"/&gt;
&lt;Event MSec=  "4771.6036" PID="10308" PName="Process(10308)" TID="10308" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="InternalGetHostByName" parameters="(www.foo22.com)"/&gt;
```

There are several issue: 
- the successful case has duplicate entires - one for GetHostEntry and one for InternalGetHostByName. It seems like we should either trace entry/exit on  public function or on internal implementation. Right now we create trace entires without added value. 
- the unsuccessful case has no details or entry about failure. If somebody would use filter like `COMPlus_EventPipeConfig=*:0xFFFFFFFFFFFFFFFF:3` to get all errors (or higher) would get nothing at all. 

The Async version is similar. For two sucessfull lookups I get something like 
```
&lt;Event MSec=  "1622.1247" PID="11101" PName="Process(11101)" TID="11101" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="BeginGetHostEntry" parameters="(www.foo.com)"/&gt;
&lt;Event MSec=  "1624.5354" PID="11101" PName="Process(11101)" TID="11101" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="BeginGetHostEntry" result="DnsResolveAsyncResult#33476626"/&gt;
&lt;Event MSec=  "1624.5881" PID="11101" PName="Process(11101)" TID="11101" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="BeginGetHostEntry" parameters="(www.foo.com)"/&gt;
&lt;Event MSec=  "1625.0484" PID="11101" PName="Process(11101)" TID="11101" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="BeginGetHostEntry" result="DnsResolveAsyncResult#27252167"/&gt;
&lt;Event MSec=  "6647.5183" PID="11101" PName="Process(11101)" TID="11112" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="EndGetHostEntry" parameters="(DnsResolveAsyncResult#27252167)"/&gt;
&lt;Event MSec=  "6647.5809" PID="11101" PName="Process(11101)" TID="11109" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="EndGetHostEntry" parameters="(DnsResolveAsyncResult#33476626)"/&gt;
&lt;Event MSec=  "6647.6229" PID="11101" PName="Process(11101)" TID="11112" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="EndGetHostEntry" result="IPHostEntry#4032828"/&gt;
&lt;Event MSec=  "6647.6674" PID="11101" PName="Process(11101)" TID="11109" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="(null)" memberName="EndGetHostEntry" result="IPHostEntry#6044116"/&gt;
```

* since tasks are executed on ThreadPool I cannot anymore use TID to find matching Exit entries for Entry. So I cannot figure out how long took to do lookup and it is not possible find failing lookups by looking for missing Exit entries. 

**Proposal:** 

* We currently don't set context on entry/exit. We could set it to passed in string. That would allow us distinguish between lookups for different instances
* We could try/catch/throw in public functions but as @stephentoub quickly pointed out there is performance cost associated with that. We could do something like `catch (Exception) when (IsTracingEnabled())`  do pay the cost when tracing is enabled. However if we go with above proposal or if we find better way how to trace identity we can emit traces at the places where we throw. 

```c#
        private static object GetHostEntryOrAddressesCore(string hostName, bool justAddresses)
        {
            int hash = hostName.GetHashCode();
            if (NetEventSource.IsEnabled) NetEventSource.Enter(hostName, hostName);
            Console.WriteLine("GetHostEntryOrAddressesCore start: {0} {1}",  hostName, hostName.GetHashCode());
            ValidateHostName(hostName);

            SocketError errorCode = NameResolutionPal.TryGetAddrInfo(hostName, justAddresses, out string newHostName, out string[] aliases, out IPAddress[] addresses, out int nativeErrorCode);
            if (errorCode != SocketError.Success)
            {
+                if (NetEventSource.IsEnabled) NetEventSource.Error(hostName, $"{hostName} DNS lookup failed with {errorCode}");
                throw SocketExceptionFactory.CreateSocketException(errorCode, nativeErrorCode);
            }
```
```
&lt;Event MSec=   "322.2866" PID="14211" PName="Process(14211)" TID="14211" EventName="Info" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-263748031" memberName="GetHostEntryOrAddressesCoreAsync" message="www.foo.com"/&gt;
&lt;Event MSec=   "324.5510" PID="14211" PName="Process(14211)" TID="14211" EventName="Info" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-349866304" memberName="GetHostEntryOrAddressesCoreAsync" message="www.foo22.com"/&gt;
&lt;Event MSec=   "326.1782" PID="14211" PName="Process(14211)" TID="14219" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-263748031" memberName="GetHostEntryOrAddressesCore" parameters="(www.foo.com)"/&gt;
&lt;Event MSec=   "326.2288" PID="14211" PName="Process(14211)" TID="14221" EventName="Enter" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-349866304" memberName="GetHostEntryOrAddressesCore" parameters="(www.foo22.com)"/&gt;
&lt;Event MSec=  "5354.9991" PID="14211" PName="Process(14211)" TID="14219" EventName="Exit" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-263748031" memberName="GetHostEntryOrAddressesCore" result="IPHostEntry#6044116, 2"/&gt;
&lt;Event MSec=  "5366.5515" PID="14211" PName="Process(14211)" TID="14221" EventName="ErrorMessage" ProviderName="Microsoft-System-Net-NameResolution" thisOrContextObject="String#-349866304" memberName="GetHostEntryOrAddressesCore" message="www.foo22.com DNS lookup failed with HostNotFound"/&gt;

``` 

This would allow to pair Enter/Exit for successful cases as well as provide useful info on failures. When `*:0xFFFFFFFFFFFFFFFF:3` filter is used, it would show just the failing message without any additional craft. For that reason I think we should repeat failing name instead  of relying on Entry (as the record may not be available) 

For successful case I also throw  length of address list `result="IPHostEntry#6044116, 2"/&gt;` so the log would show to how many IP addresses name resolved to. 

```c#
 if (NetEventSource.IsEnabled) NetEventSource.Exit(hostName, result, addresses.Length);
```

</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41883</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: ImmutableArray&lt;T&gt;.Builder.Remove(T, IEqualityComparer&lt;T&gt;)</Title>
    <Description>## Proposed API
```diff
public struct ImmutableArray&lt;T&gt;
{
	public class Builder
    {
+       public bool Remove(T element, IEqualityComparer&lt;T&gt; equalityComparer);
    }
}
```

`ImmutableArray&lt;T&gt;` itself [already exposes such a method](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable.immutablearray-1.remove?view=netcore-3.0#System_Collections_Immutable_ImmutableArray_1_Remove__0_System_Collections_Generic_IEqualityComparer__0__) and adding it to the builder doesn't seem like it would take much effort.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41882</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Reflection.TypeExtensions for nullable references</Title>
    <Description>Contributes to #40623</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41881</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Diagnostics.Tests.EventLogEntryEventWrittenTest.EntryWrittenEventRaised failing with AggregateException on Windows.10.Amd64.Client19H1.ES.Open</Title>
    <Description>From https://github.com/dotnet/corefx/pull/41877

corefx-ci (Windows Build x64_Debug)
netcoreapp-Windows_NT-Debug-x64-Windows.10.Amd64.Client19H1.ES.Open

https://helix.dot.net/api/2019-06-17/jobs/3f109ae1-49d6-468a-9031-887de595b0af/workitems/System.Diagnostics.EventLog.Tests/console

```text
    System.Diagnostics.Tests.EventLogConfigurationTests.SetProperties_SaveChanges_NotAdmin_Throws [SKIP]
      Condition(s) not met: "NotElevatedAndSupportsEventLogs"
    System.Diagnostics.Tests.EventLogEntryEventWrittenTest.EntryWrittenEventRaised [FAIL]
      System.AggregateException : One or more errors occurred. (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.) (Uno de los dispositivos conectados al sistema no funciona.)
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      ---- System.ComponentModel.Win32Exception : Uno de los dispositivos conectados al sistema no funciona.
      Stack Trace:
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(47,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(30,0): at System.Diagnostics.Tests.Helpers.Retry[T](Func`1 func)
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.Retry(Action func)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.RaisingEvent(String log, String methodName, Boolean waitOnEvent)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(58,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.EntryWrittenEventRaised()
        ----- Inner Stack Trace #1 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #2 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #3 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #4 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #5 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #6 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #7 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #8 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #9 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #10 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(477,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(396,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(360,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogEntryWrittenTest.cs(51,0): at System.Diagnostics.Tests.EventLogEntryEventWrittenTest.&lt;&gt;c__DisplayClass3_0.&lt;RaisingEvent&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
  Finished:    System.Diagnostics.EventLog.Tests
=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.EventLog.Tests  Total: 140, Errors: 0, Failed: 1, Skipped: 1, Time: 77,730s
```

cc @Anipik, @wtgodbe</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41880</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Resources.ResourceWriter for nullable ref types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41879</IssueID>
    <RepoID>1</RepoID>
    <Title>System.InvalidCastException on calling System.Data.DataRowExtensions.Field for nullable enums</Title>
    <Description>Found this issue while migrating code from .NET Framework 4.8 to .NET Core 3. Calling .Field&lt;int?&gt; works on both, but .Field&lt;MyEnum?&gt; throws under .NET Core 3:

```
An exception of type 'System.InvalidCastException' occurred in System.Data.Common.dll but was not handled in user code: 'Unable to cast object of type 'System.Int32' to type 'System.Nullable`1[corefxissue.MyEnum]'.'
   at System.Data.DataRowExtensions.UnboxT`1.ReferenceOrNullableField(Object value)
   at System.Data.DataRowExtensions.Field[T](DataRow row, String columnName)
   at corefxissue.Tests.RowWithNullableEnum()
```

This issue occurs when using a DataTable from a DataSet that was filled by System.Data.Common.DbDataAdapter.Fill, but here's a minimal example that breaks the same way:

```csharp
var table = new DataTable();
var type = typeof(MyEnum?);
table.Columns.Add(new DataColumn("col", Nullable.GetUnderlyingType(type) ?? type));
var row = table.NewRow();
row["col"] = MyEnum.Foo;
table.Rows.Add(row);

var resultFromInt = (MyEnum?)table.Rows[0].Field&lt;int?&gt;("col"); // works
var resultFromEnum = table.Rows[0].Field&lt;MyEnum?&gt;("col"); // throws
```

Are nullable enums no longer supported in .Field?</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41878</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] JsonSerializer should ignore extension data if it's null when serializing + additional tests</Title>
    <Description>Ports https://github.com/dotnet/corefx/pull/40431 and more tests from https://github.com/dotnet/corefx/pull/40488, https://github.com/dotnet/corefx/pull/41877 ~(once this is merged to master)~

### Description

Do not output the extension data property when its null.

### Customer Impact:

Customer reported issue. Overflow properties annotated accordingly shouldn't show up in the generated JSON payload and it showing up in the output is incorrect. Only it's contents should show up (and when null that means nothing). Paraphrasing @CodeBlanch, this better matches the intention of `[JsonExtensionData]` and Newtonsoft.Json behavior so people aren't surprised when using the new lib.

### Regression? 

No, but this is a behavioral change from 3.0 (but that's already changed in master for 5.0).

### Risk

Low. The fix is targeted specific to extension data property. It is theoretically possible someone relies on the property itself showing up in the output, but I would be surprised if that was the case since that's not its intended behavior outside of the "null" case already.

### Tests run / added

More unit tests added.

cc @steveharter, @ericstj, @danmosemsft </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41877</IssueID>
    <RepoID>1</RepoID>
    <Title>Follow-up to add more extension data tests.</Title>
    <Description>Follow-up to https://github.com/dotnet/corefx/pull/40488, specifically https://github.com/dotnet/corefx/pull/40488#discussion_r317340978

cc @steveharter, @layomia, @CodeBlanch </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41876</IssueID>
    <RepoID>1</RepoID>
    <Title>Discard unused locals cleanup</Title>
    <Description>Contributes to #39962.

/cc @bartonjs </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41875</IssueID>
    <RepoID>1</RepoID>
    <Title>Outbound http requests leak unmanaged memory on Alpine 3.9</Title>
    <Description>Copied from https://github.com/aspnet/AspNetCore/issues/14117

TL;DR:
Using HttpClient to make outbound calls in any of the alpine3.9 docker images for .net core 2.2.7 or 3.0 results in a steady, unbounded growth of working set / unmanaged memory.

Alpine 3.8 and Alpine 3.10 Previews ( as reported by @GREsau in the original issue ) are not affected.

Please see the original issue for charts and more context.

Here is a solution that exhibits the the growing working set size: 
[Alpine39MemoryRepro.zip](https://github.com/aspnet/AspNetCore/files/3736935/Alpine39MemoryRepro.zip)

After 4 hours of runtime:
Alpine 3.8's working set size remains between 98-101MB
Alpine 3.9's working set size started at ~98 MB, and is now at 107 MB. 
GC Generations 0, 1 and 2 are all being collected and the managed memory has remained stable.

After 24 hours of runtime:
Alpine 3.8 is still at 98-101MB
Alpine 3.9 is now at almost 150 MB.

Usage for the repro:
1. Navigate to the root of the extracted zip file
1. Build 3.9 Image via: `docker build -t alpinememory -f .\Dockerfile-localtest .`
1. (Optional) Build 3.8 Image via: `docker build -t alpinememory38 -f .\Dockerfile-localtest38 .`
1. Run 3.9 Image via: `docker run -p 5001:8080 --name alpinememory -d alpinememory` ( alter host port if you wish )
1. (Optional) Run 3.8 Image via: `docker run -p 5002:8080 --name alpinememory38 -d alpinememory38`
1. Wait at least 3 hours for trends to emerge
1. Grab a report of working set size via `docker cp alpinememory:/tmp/report.csv ./report_39.csv`
1. (Optional) Grab a report of alpine 3.8 for comparison via `docker cp alpinememory38:/tmp/report.csv ./report_38.csv`

What the repro solution does:
- Relatively standard aspnet core 2.27 web api style project, with nginx reverse proxy.
- Starts 2 IHostedServices that inherit from `BackgroundWorker`.
- `Worker/ReportingWorker.cs` runs every minute and dumps memory-related information from `Process.` and `GC.` namespaces to a text file, and only exists to conveniently observe memory behavior over time without requiring any additional dependencies
- `Worker/WebRequestWorker.cs` runs every second and sends a HTTPS Get to one out of 16 pre-configured URLs. It then logs the number of A or a chars in the response, pretty sure that's unnecessary but I wanted to make sure the response content was used in some manner and nothing was optimized out.
   - The URLs were chosen from the Alexa page ranks since I wanted to make sure to only send GETs to big, established sites. 1 request every 16 seconds probably does not bother them. 👍 
   - The requests are made using the recommended pattern of using `services.AddHttpClient();` in `Startup.cs`, injecting `IHttpClientFactory` and using `CreateClient` on-demand.

Here are my results after 4 hours:
Alpine 3.9: [report_39.txt](https://github.com/aspnet/AspNetCore/files/3736982/report_39.txt)
Alpine 3.8: [report_38.txt](https://github.com/aspnet/AspNetCore/files/3736983/report_38.txt)

Results after close to 24 hours:
Alpine 3.9: [report_39.txt](https://github.com/dotnet/corefx/files/3741317/report_39.txt)
Alpine 3.8: [report_38.txt](https://github.com/dotnet/corefx/files/3741318/report_38.txt)

We are subject to time limits when it comes to applying security patches, and the OS of the container instance is no exception. As 3.8 is quite old, this issue blocks us from updating and may force us to switch to the bionic images instead, which would be pretty disappointing as we are otherwise very happy with Alpine. Thank you for your time! 👍 </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41874</IssueID>
    <RepoID>1</RepoID>
    <Title>Disabling DualModeConnectAsync test</Title>
    <Description>This one failed FAR too often. Disabling until someone has time to investigate.

https://github.com/dotnet/corefx/issues/20893</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41873</IssueID>
    <RepoID>1</RepoID>
    <Title>Store Description value of ConfigurationProperty 2</Title>
    <Description>Recreate PR to trigger CI

Because this one #41842 was reverted by #41848

</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41872</IssueID>
    <RepoID>1</RepoID>
    <Title>Don't root FileSystemWatcher unnecessarily</Title>
    <Description>We already try to do this on Unix, though it seems we don't currently have tests for it, but we don't on Windows.

Fixes https://github.com/dotnet/corefx/issues/41630
cc: @danmosemsft, @davidfowl, @JeremyKuhne </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41871</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Mutex, Semaphore, and EventWaitHandle creation extension methods that take an ACL</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41662

@JeremyKuhne </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41870</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191017.3
- **Date Produced**: 10/17/2019 7:56 PM
- **Commit**: 525f52122ad3919b6fb5df528533cc1039603d48
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview2.19517.3
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview2.19517.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview2.19517.3

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)



</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41869</IssueID>
    <RepoID>1</RepoID>
    <Title>Delete unused files</Title>
    <Description>
    </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41868</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove arcade SolutionBuildTargets hack</Title>
    <Description>We need to remove the Arcade `SolutionBuildTargets` hack for the repo consolidation as otherwise every repo would need to provide that target. Also this api wasn't approved and I will remove it in arcade after this change is merged.

The changes guarantee that the existing behavior doesn't regress.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41867</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix HttpListener restart</Title>
    <Description>Resolves #39552 throwing `ObjectDisposedException`.

The first try in https://github.com/dotnet/corefx/pull/40466 failed due to the `ThreadPoolBoundHandle` being set to null before the `DisconnectAsyncResult` callback was hit. This resolves that by keeping a private copy of the `ThreadPoolBoundHandle` around inside the `DisconnectAsyncResult`.

This is technically a use-after-Dispose, relying on our current implementation of `ThreadPoolBoundHandle` which happens to allow this, so the fix may not work long-term. A more correct fix needs more thought and is blocked on https://github.com/dotnet/coreclr/issues/26783 due to how http.sys implements cancellation, which asks us to close the handle to cancel but then requires us to use the handle to free our `OVERLAPPED` structure. `Socket` implementation might be doing something similar so that's a good place to reference.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41866</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Add a property-based test</Title>
    <Description>This PR is a proof of concept demonstrating [property-based testing](http://www.aaronstannard.com/fscheck-property-testing-csharp-part1/) for the HPack implementation. It converts the existing HPack roundtrip unit test into a property-based test. Please do not merge as it introduces an unsigned nuget dependency to the http unit tests projects.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41865</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Add back TraceListener handling for Callstack/LogicalOperationStack</Title>
    <Description>Port https://github.com/dotnet/corefx/pull/41844 to release/3.1
Per https://github.com/dotnet/corefx/pull/41844#issuecomment-543229634
Fixes https://github.com/dotnet/corefx/issues/41837
cc: @danmosemsft </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41861</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Runtime.Numerics for nullable reference types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623
cc: @buyaa-n, @safern</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41860</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Import keys from RFC7468 PEM</Title>
    <Description>Proposal:

```csharp
namespace System.Security.Cryptography {
  public partial class AsymmetricAlgorithm {
    public virtual void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);
    public virtual void ImportFromPem(ReadOnlySpan&lt;char&gt; input);
  }

  public partial class RSA : AsymmetricAlgorithm {
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);
    public override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);
  }

  public partial class DSA : AsymmetricAlgorithm {
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);
    public override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);
  }

  public partial class ECDsa : AsymmetricAlgorithm {
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);
    public override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);
  }

  public partial class ECDiffieHellman : AsymmetricAlgorithm {
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);
    public override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);
    public override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);
  }
}
```

The expected usage of this is to be able to import RFC 7468 textually encoded public and private keys with an API that "does the right thing". The intent of this API would be to allow importing keys that are encoded with a label indicating what kind of key it is.

Usage example:

```csharp
using var rsa = RSA.Create();
rsa.ImportFromPem(@"
-----BEGIN RSA PRIVATE KEY-----
MII....
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MII....
-----END CERTIFICATE-----
");
```

Rationale:

There are a few different ways that a key can be encoded, when PEM encoded, such keys may look like "BEGIN PRIVATE KEY", "BEGIN RSA PRIVATE KEY", "BEGIN PUBLIC KEY", "BEGIN RSA PUBLIC KEY", etc. .NET Core 3 introduced APIs for importing these keys. However, this leaves developers the wrangle the key out of the file themselves, and know which API to use once they do. This is often not the experience with other software that when presented with a PEM textually encoded key, it often gets it right and just works.

Behaviors:

If the API can _unambiguously_ determine the key that should be imported, it will import it, regardless of the rest of the contents such as a PEM aggregate. An example may be a PEM aggregate that contains a BEGIN CERTIFICATE and a BEGIN RSA PRIVATE KEY. In this circumstance, the BEGIN CERTIFICATE would be ignored because it is not a key.

If the contents contains multiple keys of the same algorithm, or a PKCS#8 key, an error is raised. This allows raising an error early without being forced to decode all PKCS#8 keys to determine what algorithm they are for.

For algorithms that support textually encoded parameters like DSA and ECDsa, if present, they will be imported as well and validated with the key. For example:

```
-----BEGIN EC PARAMETERS-----
BggqhkjOPQMBBw==
-----END EC PARAMETERS-----
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIA1yny8h/fosik9s5aK19sIeGCxw1bjyBDD64G7LSkXoAoGCCqGSM49
AwEHoUQDQgAEwAWFpzlNs/YtqL5RxEeA66oqLDtrF5Et7mbyfhKoRYzjx/ItNUy/
UTyAoMKfzkEwM2PUsXZ23sVIjWD1KtOvMw==
-----END EC PRIVATE KEY-----
```

This private key is nistP256, as well as the EC parameters. Both explicit and named parameters should be supported. The parameters are not required, and appear at most once.

The PEM label and the key algorithm must match.

When `ImportFromEncryptedPem` is used, the PEM must be an encrypted private key. Even if contents contain exactly one key that could be imported because it is not encrypted, an error will still be raised.

The implementation of this is dependent on something like #37748 being implemented first.

Considerations:

1. I considered `ReadOnlySpan&lt;byte&gt;` overloads, but that depends on encoding which complicates things, either by requiring one specific encoding (which?) or overloads to support all. </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41862</IssueID>
    <RepoID>1</RepoID>
    <Title>Support for GeoCoordinateWatcher from System.Device.Location</Title>
    <Description>Hi
Are there any plans or an existing solution for using/replacing GeoCoordinateWatcher class from System.Device.Location in .NET Core 3.0? I want to port this code from .NET 4.5 :

oGeoWatcher = new GeoCoordinateWatcher() ;
oGeoWatcher.TryStart(false, TimeSpan.FromMilliseconds(1000));
...
if (oGeoWatcher.Status == GeoPositionStatus.Disabled) 
..

Thanks
Artur</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41858</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Runtime.CompilerServices.VisualC for nullable reference types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623
cc: @buyaa-n, @safern

This assembly really doesn't matter for nullability, as it's only meant to be used with C++/CLI and only by infrastructure.  There's also no annotations necessary on any of the contained attributes, as they are either parameterless or take a parameter that shouldn't be null.  Even so, we may as well mark the assembly as being annotated, so that its status is appropriately reflected by tools.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41857</IssueID>
    <RepoID>1</RepoID>
    <Title>.NET Core 3.0  - Assembly.ReflectionOnlyLoadFrom throws System.PlatformNotSupportedException</Title>
    <Description>This API works fine on .NET Framework 4.6.1

I used this overload of `System.Reflection.Assembly.ReflectionOnlyLoadFrom` to load `Newtonsoft.json.dll` l.  Tests with version 9 and version 12 of NewtonSoft produced the same error.

`public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);`

**Exception message**

```
System.PlatformNotSupportedException
  HResult=0x80131539
  Message=ReflectionOnly loading is not supported on this platform.
  Source=System.Private.CoreLib


```

Is the method `ReflectionOnlyLoadFrom` deprecated? If so then the method should be marked with `Obsolete` attribute and alternative method provided.

Thanks,
Sau
</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41856</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Runtime.InteropServices.RuntimeInformation for nullable reference types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623
cc: @buyaa-n, @safern</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41855</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Runtime.CompilerServices.Unsafe for nullable reference types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623
cc: @buyaa-n, @safern 

The actual implementation is in IL, and there'd be no benefit to adding annotations there, so I've only annotated the C# ref assembly.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41854</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Web.HttpUtility for nullable reference types</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623
cc: @buyaa-n, @safern </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41853</IssueID>
    <RepoID>1</RepoID>
    <Title>Windows 10 19H1 Client SKUs are slowing down CI noticeably</Title>
    <Description>from @MattGal:

&gt; Just a heads up, both of these Client SKUs are VERY slow to provision as Azure VMs, and you might consider if you haven't had specific scenarios where stuff was broken just for a Client SKU not using these for CI.

@stephentoub asked for equivalent Server SKUs being available.</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41852</IssueID>
    <RepoID>1</RepoID>
    <Title>configurable HTTP/2 PING timeouts in HttpClient</Title>
    <Description>I've been evaluating the new gRPC-dotnet and particularly its streaming feature in a long lived connected scenario. 
I needed the [HTTP/2 PING feature](https://http2.github.io/http2-spec/#PING) to detect the zombie connections (basically to know: "Am I still having an up and running connection to the client?") on both server and client side.
It seems that this feature won't be implement-able on the client side as long as there's no support of an API in the HttpClient, as the client part of gRPC-dotnet [relies on HttpClient](https://github.com/grpc/grpc-dotnet/blob/master/src/Grpc.Net.Client/GrpcChannel.cs).

It seems that HttpClient already responds to ping but can not send any on demand. Am I right?

So I would like to request a new method in HttpClient class to support sending Http/2 pings or even better a kind of keep alive ping timeout to do it automatically in case there's no traffic...

BTW: I have also created [an issue](https://github.com/aspnet/AspNetCore/issues/15104) for the same feature for kestrel (I don't know what kestrel is using underneath).</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41851</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191016.3
- **Date Produced**: 10/17/2019 12:59 AM
- **Commit**: f3060ceeef92858052384f6d14cc8eafa6d02a50
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19516.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19516.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19516.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41850</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191017.8
- **Date Produced**: 10/17/2019 10:37 PM
- **Commit**: b47a997282b4d347cb079d26515ea4147e2ac548
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19517.8
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19517.8
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19517.8

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)


[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191016.19
- **Date Produced**: 10/17/2019 7:56 AM
- **Commit**: 5a80ffb6df74d986b366155cdb24545e99022a4d
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19516.19
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19516.19
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19516.19

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191016.16
- **Date Produced**: 10/17/2019 4:25 AM
- **Commit**: b9186cfa3566ee24e5f16e45c542a3078e128dc6
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19516.16
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19516.16

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191016.1
- **Date Produced**: 10/16/2019 12:58 PM
- **Commit**: e55a881e204a9b011e1d8827ccd9fda0bbfe2ef5
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19516.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)


</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41849</IssueID>
    <RepoID>1</RepoID>
    <Title>NumberDecimalSeparator and possibly other IFormatProvider options aren't working on WinUI</Title>
    <Description>Starting with Windows 19H1 the following tests are failing:

```
Windows.UI.Tests.ColorTests.ToString_Invoke_ReturnsExpected(color: #01020304, format: \"abc\", formatProvider: null, expected: \"sc#abc, abc, abc, abc\")

Assert.Equal() Failure\r\n ↓ (pos 1)\r\nExpected: 1,2\r\nActual: 1;2\r\n ↑ (pos 1)
   at Windows.Foundation.Tests.PointTests.ToString_Invoke_ReturnsExpected(Point point, String format, IFormatProvider formatProvider, String expected) in /_/src/System.Runtime.WindowsRuntime/tests/Windows/Foundation/PointTests.cs:line 110
```

```
Windows.Foundation.Tests.RectTests.ToString_Invoke_ReturnsExpected(rect: 1;2;3;4, format: \"abc\", formatProvider: null, expected: \"abc,abc,abc,abc\")

Assert.Equal() Failure\r\n ? (pos 3)\r\nExpected: abc,abc,abc,abc\r\nActual: abc;abc;abc;abc\r\n ? (pos 3)
   at Windows.Foundation.Tests.RectTests.ToString_Invoke_ReturnsExpected(Rect rect, String format, IFormatProvider formatProvider, String expected) in /_/src/System.Runtime.WindowsRuntime/tests/Windows/Foundation/RectTests.cs:line 324
```

cc @danmosemsft @jkotas </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41848</IssueID>
    <RepoID>1</RepoID>
    <Title>Revert "Store Description value of ConfigurationProperty"</Title>
    <Description>This reverts commit b9186cfa3566ee24e5f16e45c542a3078e128dc6.

cc @JeremyKuhne @Marusyk </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41847</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failure:System.ConfigurationTests.ConfigurationPropertyTests.DescriptionValueIsExposed</Title>
    <Description>Test `System.ConfigurationTests.ConfigurationPropertyTests.DescriptionValueIsExposed` has failed.

```
===========================================================================================================

C:\dotnetbuild\work\35165409-6629-4a12-9e3e-5fe3b57f69b7\Work\7abe8f93-bd4a-49ed-8077-f4263ff8d2c1\Exec&gt;set DEVPATH=C:\dotnetbuild\work\35165409-6629-4a12-9e3e-5fe3b57f69b7\Payload 

C:\dotnetbuild\work\35165409-6629-4a12-9e3e-5fe3b57f69b7\Work\7abe8f93-bd4a-49ed-8077-f4263ff8d2c1\Exec&gt;xunit.console.exe System.Configuration.ConfigurationManager.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=nonnetfxtests -notrait category=nonwindowstests -maxthreads 1 -noappdomain -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  
  Discovering: System.Configuration.ConfigurationManager.Tests (app domain = off, method display = ClassAndMethod, method display options = None)
  Discovered:  System.Configuration.ConfigurationManager.Tests (found 481 of 498 test cases)
  Starting:    System.Configuration.ConfigurationManager.Tests (parallel test collections = on, max threads = 1)
    System.ConfigurationTests.ConfigurationPropertyTests.DescriptionValueIsExposed [FAIL]
      Assert.Equal() Failure
      Expected: bar
      Actual:   (null)
      Stack Trace:
        /_/src/System.Configuration.ConfigurationManager/tests/System/Configuration/ConfigurationPropertyTests.cs(148,0): at System.ConfigurationTests.ConfigurationPropertyTests.DescriptionValueIsExposed()
  Finished:    System.Configuration.ConfigurationManager.Tests
=== TEST EXECUTION SUMMARY ===
   System.Configuration.ConfigurationManager.Tests  Total: 601, Errors: 0, Failed: 1, Skipped: 0, Time: 1.240s
----- end Thu 10/17/2019  2:55:43.26 ----- exit code 1 ----------------------------------------------------------
```

**Build:**
[20191016.54](https://dnceng.visualstudio.com/public/_build/results?buildId=390994)(Master)

**OS &amp; Arch:**
Windows x64 &amp; Windows x86

**Details:**
https://helix.dot.net/api/2019-06-17/jobs/35165409-6629-4a12-9e3e-5fe3b57f69b7/workitems/System.Configuration.ConfigurationManager.Tests/console</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41846</IssueID>
    <RepoID>1</RepoID>
    <Title>CustomAttribute with Array Properties sets nulls incorrectly</Title>
    <Description>An attribute with two array properties does not behave as expected if the first array property is set to a value and the second array property is set to null. If the two arrays are of the same type, the second property is set to the same value as the first property. If the two types are incompatible, an exception is thrown when the attribute is constructed, stating that the second property cannot be found.

Attached are two variations on a simple program that replicates each issue.

[Same Type](https://github.com/dotnet/corefx/files/3737962/Program.txt)
[Incompatible Types](https://github.com/dotnet/corefx/files/3737971/Program.2.txt)

</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41845</IssueID>
    <RepoID>1</RepoID>
    <Title>Use Sse2 instrinsics to make NeedsEscaping check faster for large JSON strings</Title>
    <Description>Here's the whole analysis and experimentation of different alternatives with benchmark results: https://gist.github.com/ahsonkhan/c566f5e7d65c1fde5a83a67be290c4ee

Ignore the uap target changes (they were borrowed from https://github.com/dotnet/corefx/pull/41759) since it was happening anyway and I am not yet sure if its worth the effort to create different constants for uap (since intrinsics aren't built for that configuration).

Here's the conclusion and next steps.

## Conclusions:
Here's a summary of the results when the user doesn't customize the encoder via the `JsonSerializerOptions` or `JsonWriterOptions` (i.e. uses the default encoder behavior).
1) For end-to-end scenario (such as serializing commonly found objects/payloads), there is a 10-20% improvement.
2) Writing relatively large JSON strings using the writer got ~30% faster (i.e. greater than 16 characters).
3) Checking for escaping strings that are less than 8 characters is ~20-50% slower, but larger strings (i.e. greater than 16 character) got 2-3x faster.
4) If a character is found that needs escaping within the first 8 characters, there is a 20-90% regression. Otherwise, there is a a 2-3x performance improvement depending on where the first character that needs escaping is found (say index greater than 16).

## Next Steps:
~1) Add similar support and tests for UTF-8 bytes, not just UTF-16 characters.~
2) Evaluate if the trade-off is worth it for property names which tend to be small (2-8 characters), compared to values.
3) Consider optimizing the commonly used built-in `JavascriptEncoder` statics using similar techniques.
4) Apply non-Sse2 based optimizations where Sse2 isn't supported rather than processing one character at a time.
5) Rather than returning the first index to escape, return the whole mask and escape all characters that need to be escaped at once (within the block of 8) and return back to the "fast" non-escaping path, rather than writing one character at a time whenever a single character is found that needs escaping.

cc @steveharter, @tannergooding, @GrabYourPitchforks </Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41844</IssueID>
    <RepoID>1</RepoID>
    <Title>Add back TraceListener handling for Callstack/LogicalOperationStack</Title>
    <Description>For .NET Core 2.0, PR https://github.com/dotnet/corefx/pull/13320 added back TraceOptions.Callstack and TraceOptions.LogicalOperationStack, but it didn't add back the code in TraceListener.WriteFooter that respects these options.    Then PR https://github.com/dotnet/corefx/pull/18185 added back checking for TraceOptions.LogicalOperationStack in DelimitedListTraceListener.WriteFooter, but for some reason didn't do so for TraceOptions.Callstack.

This adds back the handling for both, copying the product code from reference source.

Contributes to https://github.com/dotnet/corefx/issues/41837
cc: @safern</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41863</IssueID>
    <RepoID>1</RepoID>
    <Title>DbCommand boolean property SupportsNamedParameters</Title>
    <Description>I think it would be great if the DbCommand object in System.Data.Common had a read only boolean property that indicates whether or not the ADO.Net provider implementation that inherits from that object supports named parameters.  Or in some cases some providers support both like Oracle/Postgres.  In the case of Postgres named parameters were not always possible so the inheriting provider could based on the server version property of the DbConnection object know if named parameters are supported.

There are several ORM frameworks out there that build out SQL by taking in a class object as a generic parameter.  Using the public properties as columns and associated values.  Using this property a correctly parameterized SQL statement could be generated based on whether or not the ADO.NET implementer supports named or positional parameters.

Looking in Oracle.Managed.Client.OracleCommand, that object has a property that is a boolean flag that specifies the binding method in the parameters collection

https://docs.oracle.com/cd/B19306_01/win.102/b14307/OracleCommandClass.htm#i997666</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41843</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix possible NRE in DirectoryEntry from System.DirectoryServices</Title>
    <Description>https://github.com/dotnet/corefx/blob/b49a8a9be1d53cd9e50cb68fd8540be25c65d433/src/System.DirectoryServices/src/System/DirectoryServices/DirectoryEntry.cs#L983-L991
In the method, there's a check `propertyNames != null`. But above you can see a few access operations by this potentially null reference — `propertyNames.Length` and `propertyNames[i]`. The result is quite predictable — the occurrence of an exception of the `NullReferenceExcepption` type in case if a null reference is passed to the method.

As a `RefreshCache` is a public method in the public class then we can do this to break it down:
```csharp
DirectoryEntry de = new DirectoryEntry();
de.RefreshCache(null);
```

Please review
Thank you in advance</Description>
    <CreatedDate>17/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41842</IssueID>
    <RepoID>1</RepoID>
    <Title>Store Description value of ConfigurationProperty</Title>
    <Description>It seems that description parameter isn't used:
https://github.com/dotnet/corefx/blob/58a4d24eb808936f7dc61e68265e968291470b42/src/System.Configuration.ConfigurationManager/src/System/Configuration/ConfigurationProperty.cs#L56-L67

but according to [docs](https://docs.microsoft.com/en-us/dotnet/api/system.configuration.configurationproperty.-ctor?view=netframework-4.8#System_Configuration_ConfigurationProperty__ctor_System_String_System_Type_System_Object_System_ComponentModel_TypeConverter_System_Configuration_ConfigurationValidatorBase_System_Configuration_ConfigurationPropertyOptions_System_String_) it should

Please review and let me know if code authors intentionally don't use it or it is a bug
Thank you in advance</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41841</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher does not fire events on MacOS when NotifyFilter = LastAccess</Title>
    <Description>MacOS Versions tested: Mojave 10.14, Catalina 10.15

Code used.

```
     using (var watcher = new FileSystemWatcher (Directory.GetCurrentDirectory (), "*.txt")) {
            watcher.IncludeSubdirectories = true;
            watcher.NotifyFilter = NotifyFilters.LastAccess;

            watcher.Changed += (sender, e) =&gt; {
               Console.WriteLine (e.FullPath);
            };

            watcher.EnableRaisingEvents = true;

            // Wait for the user to quit the program.
            Console.WriteLine ("Press 'q' to quit the sample.");
            while (Console.Read () != 'q');
         }
```
if I run cat sometextfile.txt, the event in the code above is never fired.

Alternate Code that works in Mojave but not in Catalina

 ```
 public abstract class AccessTime {
      public abstract DateTime GetLastAccessTime (string filename);
   }

   public class AccessTimeUnix : AccessTime {
      public override DateTime GetLastAccessTime (string filename) {
         return new Mono.Unix.UnixFileInfo (filename).LastAccessTime;
      }
   }

   public class AccessTimeWindows : AccessTime {
      public override DateTime GetLastAccessTime (string filename) {
         FileInfo temp = new FileInfo (filename);
         temp.Refresh ();
         return temp.LastAccessTime;
      }
   }

public static AccessTime _accessTime;

public static void Main (string [] args) {
         if (Environment.OSVersion.Platform ==  PlatformID.Unix) {
            _accessTime = new AccessTimeUnix ();
         } else {
            _accessTime = new AccessTimeWindows ();  
         }

        DateTime currentTime = _accessTime.GetLastAccessTime ("sometextfile.txt");

        File.ReadAllText ("sometextfile.txt")

        DateTime newTime = _accessTime.GetLastAccessTime ("sometextfile.txt");

        //Note currentTime and newTime will be different
}
```

By using the technique above I can run a loop continuing to watch for files that are being read but not changed because the LastAccessTime is changing.

For some reason on Catalina, the LastAccessTime is not being updated not sure why it's probably a bug in Catalina.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41840</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Avx.CompareXXX convenience methods for float/double</Title>
    <Description>## Background

For SSE/SSE2, Intel defined convenience intrinsics for all float comparison pseudo-ops, which map to CMPPS/CMPPD (and CMPSS/CPMSD) with different control values.

For example:

```
__m128 _mm_cmpeq_ps (__m128 a, __m128 b)
#include &lt;xmmintrin.h&gt;
Instruction: cmpps xmm, xmm, imm
CPUID Flags: SSE
```

Which is exposed in System.Runtime.Intrinsics as:

```C#
/// &lt;summary&gt;
/// __m128 _mm_cmpeq_ps (__m128 a,  __m128 b)
///   CMPPS xmm, xmm/m128, imm8(0)
/// &lt;/summary&gt;
public static Vector128&lt;float&gt; CompareEqual(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right)
```

This gives API parity between the integer and floating point types, which combined with the inheritance in the S.R.I API makes `CompareEqual` overloads for all primitive numeric types available from e.g. `Sse41`

In AVX, the control value was extended to support more flag values for float comparisons, and Intel dropped the `_mm256` forms of those convenience intrinsics.

The Intel intrinsics were mirrored in S.R.I, meaning that from `Avx2`, `CompareEqual` has overloads that accept `Vector128&lt;T&gt;` of all 10 primitive numeric types but only 8 of the 10 (integer only) for `Vector256&lt;T&gt;`.


## Rationale

Although the current API does mirror the Intel intrinsics, it makes the API less discoverable for .NET users due to the inconsistency.  Additionally, it can be difficult to grok the behavior of the float comparison flags, meaning it can be difficult/confusing to map the SSE methods to their AVX equivalents.

Given the ease with which we can write code for different ISAs in .NET, achieving parity between SSE code and AVX code is a common goal.

```C#
if (Sse.IsSupported &amp;&amp; !Avx.IsSupported)
{
    Vector128&lt;float&gt; vec1, vec2;
    /// ... do some stuff
    var mask = Sse.CompareGreaterThan(vec1, vec2);
    /// ... use the mask
}
else if (Avx.IsSupported)
{
    Vector256&lt;float&gt; vec1, vec2;
    /// ... do some stuff
    var mask = Avx.Compare(vec1, vec2, FloatComparisonMode.OrderedGreaterThanNonSignaling); // ???
    /// ... use the mask
}
```

Forgiving the awkward ordering of the conditions there, it's not clear that these branches have different handling of NaN values.  In fact, it takes a good deal of reading to find that "greater than" isn't actually a thing in SSE and that `Sse.CompareGreaterThan` emits the `CMPNLEPS` pseudo-op.  To get the equivalent VEX.256 instruction, we'd have to use `FloatComparisonMode.UnorderedNotLessThanOrEqualSignaling`, which is pretty far from intuitive.

If we could use `Avx.CompareGreaterThan` to express the same behavior just on the wider vector, it would be far easier to reason in these situations.

## Proposal

It would be nice to add a set of convenience overloads for AVX that mirror the SSE float psuedo-ops. These could have managed-only implementations that invoke `Avx.Compare` with the correct `FloatComparisonMode`

```C#
public abstract class Avx : Sse42
{
    public static Vector256&lt;float&gt; CompareEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareGreaterThan(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareGreaterThan(Vector256&lt;double&gt; left,  Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareGreaterThanOrEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareGreaterThanOrEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareLessThan(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareLessThan(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareLessThanOrEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareLessThanOrEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareNotEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareNotEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareNotGreaterThan(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareNotGreaterThan(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareNotGreaterThanOrEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareNotGreaterThanOrEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareNotLessThan(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareNotLessThan(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareNotLessThanOrEqual(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareNotLessThanOrEqual(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    // The justification for these is questionable as the equivalent FloatComparisonMode is obvious.
    public static Vector256&lt;float&gt; CompareOrdered(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareOrdered(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);

    public static Vector256&lt;float&gt; CompareUnordered(Vector256&lt;float&gt; left, Vector256&lt;float&gt; right);
    public static Vector256&lt;double&gt; CompareUnordered(Vector256&lt;double&gt; left, Vector256&lt;double&gt; right);
}
```
</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41839</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] Null ref when attempting to deserialize an json object as an array</Title>
    <Description>Ran in to this by accident. Not entirely sure if it's already fixed \ tracked since there's a few that are pretty similar to this one:

```C#
using System.Text.Json;

namespace ConsoleApp3
{
    class Program
    {
        static void Main(string[] args)
        {
            var json = JsonSerializer.Deserialize&lt;int[]&gt;("{ \"a\": \"b\" }");
        }
    }
}
```

```
Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Text.Json.JsonClassInfo.GetProperty(ReadOnlySpan`1 propertyName, ReadStackFrame&amp; frame)
   at System.Text.Json.JsonSerializer.HandlePropertyName(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```
</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41838</IssueID>
    <RepoID>1</RepoID>
    <Title>Add pipe creation extension methods that take an ACL</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41657</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41837</IssueID>
    <RepoID>1</RepoID>
    <Title>TraceOptions.Callstack ignored</Title>
    <Description>Consider the following static method called from the Main method of a console project:

```
static void TraceTest()
{
    Trace.Listeners.Clear();

    TextWriterTraceListener tl = new TextWriterTraceListener(Console.Out);
    tl.TraceOutputOptions = TraceOptions.DateTime | TraceOptions.Callstack;

    Trace.Listeners.Add(tl);

    Trace.TraceWarning("Alert");
}
```

If the console project is .NET Framework, the stack trace is included:

&gt; TraceConsFwk.exe Warning: 0 : Alert
&gt;     DateTime=2019-10-16T21:53:58.7416455Z
&gt;     Callstack=   at System.Environment.GetStackTrace(Exception e, Boolean needFileInfo)
&gt;    at System.Environment.get_StackTrace()
&gt;    at System.Diagnostics.TraceEventCache.get_Callstack()
&gt;    at System.Diagnostics.TraceListener.WriteFooter(TraceEventCache eventCache)
&gt;    at System.Diagnostics.TraceListener.TraceEvent(TraceEventCache eventCache, String source, TraceEventType eventType, Int32 id, String message)
&gt;    at System.Diagnostics.TraceInternal.TraceEvent(TraceEventType eventType, Int32 id, String format, Object[] args)
&gt;    at System.Diagnostics.Trace.TraceWarning(String message)
&gt;    at Testing.TraceTestX.TraceTest() in C:\Users\Eric\source\repos\GcMon\TraceConsFwk\Program.cs:line 23
&gt;    at Testing.TraceTestX.Main() in C:\Users\Eric\source\repos\GcMon\TraceConsFwk\Program.cs:line 28

However, if the console project is .NET Core, the stack trace is absent:

&gt; GcMon Warning: 0 : Alert
&gt;     DateTime=2019-10-16T21:52:26.1178378Z

Expected: The TraceOptions.Callstack flag is respected on .NET Core.

Tested with .NET Core 3.0 in VS 2019.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41836</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient.DefaultRequestVersion of HTTP/2 is not honored if using SendAsync</Title>
    <Description>This will send a request via HTTP/1.1:

```c#
var client = new HttpClient() { DefaultRequestVersion = HttpVersion.Version20 };
var msg = new HttpRequestMessage { Method = HttpMethod.Get, RequestUri = new Uri("https://contoso.com") };
client.SendAsync(msg);
```

The default version is only being used for the convenience methods (`GetAsync` etc.).</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41835</IssueID>
    <RepoID>1</RepoID>
    <Title>Don't tie Platform Package version to Product version</Title>
    <Description>Decouples the platforms package version from the product version, as we only want to increment this version when we ship changes to it. Unblocks https://github.com/dotnet/core-setup/pull/8554

CC @ericstj @safern @joperezr @mmitche </Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41834</IssueID>
    <RepoID>1</RepoID>
    <Title>Add directory creation method that takes an ACL</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41614

@JeremyKuhne </Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41833</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpStress: add a yaml pipeline</Title>
    <Description>This PR introduces the following changes

* Adds a first iteration of an [AzDops stress testing job](https://dev.azure.com/dnceng/public/_build/results?buildId=390120) which uses corefx bits built from source.

* Makes changes to the `load-corefx-testhost.*` scripts. In particular the logic will now copy the aspnetcore runtime bits from the bootstrap sdk to the `testhost` shared folder. While I'm not the biggest fan of this approach, it's an orthogonal change to our CI infrastructure and I can maintain it until a better alternative comes along.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41832</IssueID>
    <RepoID>1</RepoID>
    <Title>Move analyzers restore to a .depproj to follow arcade Tools.proj convention</Title>
    <Description>More info on why this is better here: https://github.com/dotnet/arcade/pull/4124

We want to avoid bringing SDK targets in Tools.proj restore... more details here: https://github.com/dotnet/arcade/issues/4102

This unblocks arcade update.

FYI: @stephentoub</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41831</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve error when socket ValueTask consumed incorrectly</Title>
    <Description>Related to https://github.com/dotnet/corefx/issues/41830</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41830</IssueID>
    <RepoID>1</RepoID>
    <Title>Unhandled exception AwaitableSocketAsyncEventArgs.s_availableSentinel at PerformIOCompletionCallback</Title>
    <Description>We have number of Kestrel Asp.net MVC Core 3.0.100 hosts and SocketHttpHandler backed HttpClients looking at them all in same process. Most of them using Http1.1 unsecure. Sometimes unhandled exception occurs which results in process termination. It seems like our code is not involved and there is tricky racing in SocketHttpHandler/Socket.Tasks. Can anyone provide hints how we can diagnose it further?

```
System.Exception: s_availableSentinel
   at void System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.s_availableSentinel(object state)
   at void System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.InvokeContinuation(Action&lt;object&gt; continuation, object state, bool forceAsync, bool requiresExecutionContextFlow)
   at void System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.OnCompleted(SocketAsyncEventArgs _)
   at void System.Threading._IOCompletionCallback.PerformIOCompletionCallback(uint errorCode, uint numBytes, NativeOverlapped* pNativeOverlapped)
```</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41829</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve ConfigurableArrayPool's Bucket Rent/Release codegen</Title>
    <Description>Functionally exactly the same, just yields better codegen according to [SharpLab](https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwDoAqALATgUzABMBLAOwHMBuAWACh7ElNMBPAB3yQF4UMBJMsADMAJloM65YPlxkwAGyQRCC/ERSikAIQCuAYwDW+YPQDe9JFaTTZ8pQWIB7MgtY2hSAPoAjXQDN/WQAZfEpgbAlrJHZcEgA3MBkkRyIXN2Y2TgBtAF087z9A2QgJS2tYhKSuAGV2cmCnI28FJsMoirjE5OlvciJ8AA8Oq3KrWzlFHQNjYAAKXqKg3FDw7AAaD2AkMl0oH1kAeX89YtwIAEoxpAs6aOivVubeMnwAdyQ6hra5i5H73wBZYQHg7d6ZDj4bK7fZHE5Akr5XL/B5LEJhCgRUFolYYiL/AC+12uE3sEJyuSQACUwvMrndrLd7tYWJC8gUcSDeICzqVrtFWRSkDjQbsFAoUdZ+dYfE4nEonoZMGBjGRQf5FCpNoontVTst1Zr8JKrMBcKxpVYmcyAYr0ABRISyOYEfxIRXK1V/eiW+4kN1zLz9IZIAA8woR53Qq0x2HpNvu1oTzJFvE52SDZAGg2RvoT6cz2YA1EXKS9dOKTcmdU09ZHsfXuOXK3nrESGcz2wn/OQdRaO4nW+MAx6VWELi02g7BiR5hqFCpvQPol2bb7/Ug5jX9HWzvGbUnk6mwR9BVCecsYxFc8u2z7b1Y4AB2CNnQkkp2TJRngo0oSiX5rkPAUsihSljzFCVfV9WV5XdNpPTCQ0F3wbVxVrGR9VkZCVCrM1+wTYCbR/JFX2BUELxKKsHjtR0ZFwF18DdUcvWoqUH2TXpg0GCjuLY5kNzmOZdGkC5uLDTcRKEC5OWjPE4yHQcOOTGVGzIkpsm4m8VJU9MtNFCsoOUnTCyGEt+OrdCd0wtSRRIEFIIsldfVXZke3sNxfSIgSRwQscyAnR4p3tGc5yNJcE1c+51wDbdd2WfdmW8+4IPBH9KNxNZtJtdtfWfdTcHfAcP3osk4AAFmpExdDkOYSKQMBcFwMBWESm4YLlBU/NVHDjV9fCvMUoKjAdT9GOY7rxzKYzh03UyeIAQl4BA2sIxTUUjCBsgAWm2+aywapqWosqLnI49y+0GmabF8oxEICycRpC2c5nnRcqyiqLSSmCqquAGqyAA+rGua1qgI6uCWKQ3g3r6jiBo45KaOCsbXXgu7/IinTFK4rMQ25PicYDcSlqQFbFKRm1uN2pzrAyrb9N4EHjvWunqe2k6XN9C7xQIg8ic3KGHuGwxpxe2Gsc7a52wJIA).</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41828</IssueID>
    <RepoID>1</RepoID>
    <Title>Kestrel Web Server completely broken when TLS 1.3 is enabled; having TLS 1.2 enabled doesn't help</Title>
    <Description>_From @jhudsoncedaron on Tuesday, October 15, 2019 11:12:16 PM_

### Describe the bug
Kestrel Web Server completely broken when TLS 1.3 is enabled. Firefox reports PR_END_OF_FILE_ERROR, and the only working client is net core's own HttpClient. Failing clients: Firefox, IE, openssl s_client, Edge (Edge's failure appears to be no TLS 1.3 but I can't really tell).

### Expected behavior
It just works.

### Additional context
```
      Request starting HTTP/1.1 GET http://localhost:5104/Heartbeat/Pulse  
info: Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker[3]
      Route matched with {action = "Pulse", controller = "Heartbeat", area = ""}. Executing controller action with signature Microsoft.AspNetCore.Mvc.IActionResult Pulse() on controller Cedaron.FormBuilder.Presentation.Controllers.HeartbeatController (Cedaron.FormBuilder.Presentation).
info: Microsoft.AspNetCore.Mvc.StatusCodeResult[1]
      Executing HttpStatusCodeResult, setting HTTP status code 204
info: Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker[2]
      Executed action Cedaron.FormBuilder.Presentation.Controllers.HeartbeatController.Pulse (Cedaron.FormBuilder.Presentation) in 1.2453ms
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished in 2.4098ms 204 
fail: Microsoft.AspNetCore.Server.Kestrel[0]
      Unhandled exception while processing 0HLQHOG2JCIDM.
System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Buffer.Memmove(Byte&amp; dest, Byte&amp; src, UInt64 len)
   at System.Net.Security.SafeDeleteContext.AcceptSecurityContext(SafeFreeCredentials&amp; inCredentials, SafeDeleteContext&amp; refContext, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1 inSecBuffers, SecurityBuffer&amp; outSecBuffer, ContextFlags&amp; outFlags)
   at System.Net.SSPISecureChannelType.AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext&amp; context, ReadOnlySpan`1 inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer&amp; outputBuffer, ContextFlags&amp; outFlags)
   at System.Net.SSPIWrapper.AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext&amp; context, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1 inputBuffers, SecurityBuffer&amp; outputBuffer, ContextFlags&amp; outFlags)
   at System.Net.Security.SslStreamPal.AcceptSecurityContext(SafeFreeCredentials&amp; credentialsHandle, SafeDeleteContext&amp; context, ArraySegment`1 input, Byte[]&amp; outputBuffer, SslAuthenticationOptions sslAuthenticationOptions)
   at System.Net.Security.SecureChannel.GenerateToken(Byte[] input, Int32 offset, Int32 count, Byte[]&amp; output)
   at System.Net.Security.SecureChannel.NextMessage(Byte[] incoming, Int32 offset, Int32 count)
   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   at System.Net.Security.SslStream.PartialFrameCallback(AsyncProtocolRequest asyncRequest)
--- End of stack trace from previous location where exception was thrown ---
   at System.Net.Security.SslStream.ThrowIfExceptional()
   at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
   at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
   at System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult asyncResult)
   at System.Net.Security.SslStream.&lt;&gt;c.&lt;AuthenticateAsServerAsync&gt;b__69_1(IAsyncResult iar)
   at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Server.Kestrel.Https.Internal.HttpsConnectionMiddleware.InnerOnConnectionAsync(ConnectionContext context)
   at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Infrastructure.KestrelConnection.ExecuteAsync()
```

Include the output of `dotnet --info`

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100
 Commit:    04339c3a26

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100\

Host (useful for support):
  Version: 3.0.0
  Commit:  7d57652f33

.NET Core SDKs installed:
  1.1.14 [C:\Program Files\dotnet\sdk]
  2.1.403 [C:\Program Files\dotnet\sdk]
  2.1.604 [C:\Program Files\dotnet\sdk]
  2.1.700 [C:\Program Files\dotnet\sdk]
  2.1.701 [C:\Program Files\dotnet\sdk]
  2.1.801 [C:\Program Files\dotnet\sdk]
  2.1.802 [C:\Program Files\dotnet\sdk]
  3.0.100 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.16 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```


_Copied from original issue: aspnet/AspNetCore#15041_</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41827</IssueID>
    <RepoID>1</RepoID>
    <Title>Make ShellExecuteOnSTAThread's thread a background thread</Title>
    <Description>cc: @danmosemsft </Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41826</IssueID>
    <RepoID>1</RepoID>
    <Title>.Net Core 3.0 CredentialCache empty</Title>
    <Description>
When accessing the `CredentialCache.DefaultCredentials` or `CredentialCache.DefaultNetworkCredentials` both returned Credentials are empty.

### Code to Reproduce:

This code produces 2 empty Credentials:
```c#
class Program {
    static void Main(string[] args) {

        var defaultCred = CredentialCache.DefaultCredentials;
        var defaultNetCred = CredentialCache.DefaultNetworkCredentials;

    }
}
```

I expected to get at least one Credentials to be filled with my User-Credentials.

This Code has been tested in .net Core 3.0 and .net Framework 4.7.1 on Windows 7 and Windows 10.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41825</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json does not serialize values in Dictionary&lt;string, IInterface&gt;</Title>
    <Description>Serializing `Dictionary&lt;string, IInterface&gt;` causes the output to be like Dictionary with null values when they're not nulls.

e.g.
```C#
    JsonSerializer.Serialize(new Dictionary&lt;string, IFoo&gt; {{"test", new Foo {X = 100}}});

    public class Foo : IFoo
    {
        public int X { get; set; }
    }

    public interface IFoo
    {
    }
```

Wrong output:
```
{"test":{}}
```

Newtonsoft produces the correct output:
```
{"test":{"X":100}}
```

If you explicitly cast Value to object, serialization works correctly.
e.g. 
```C#
JsonSerializer.Serialize(new Dictionary&lt;string, IFoo&gt; {{"test", new Foo {X = 100}}}
.ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; (object) kvp.Value));
```

Correct output:
```
{"test":{"x":100}}
```</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41824</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191015.3
- **Date Produced**: 10/16/2019 12:55 AM
- **Commit**: 535984200521b3e8dd1338bbc4d50b1617fb077a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19515.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19515.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19515.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41823</IssueID>
    <RepoID>1</RepoID>
    <Title>TransformBlock's MaxDegreeOfParallelism is not working as expected</Title>
    <Description>**Problem Definition**

I'm trying to execute multiple Async tasks in parallel by using TransformBlock in ASP.NET core API.
The problem that I'm facing is if I set MaxDegreeOfParallelism to 1, it executes multiple messages in parallel but as per my understanding it should only execute 1 message at a time because MaxDegreeOfParallelism is set to 1.

My code looks like following :

    public static async Task&lt;List&lt;object&gt;&gt; ParallelTaskExecutor(object[] data, Func&lt;object, Task&lt;object&gt;&gt; taskToExecute, int maxDegreeOfParallelism, CancellationToken cancellationToken)
    {
        var options = new ExecutionDataflowBlockOptions()
        {
            CancellationToken = cancellationToken,
            MaxDegreeOfParallelism = maxDegreeOfParallelism
        };
    
        // Append task for parallel execution.
        var workerBlock = new TransformBlock&lt;object, Task&lt;object&gt;&gt;(taskToExecute, options);
        for (var index = 0; index &lt; data.Length; index++)
        {
            workerBlock.Post(new object[] { data[index], options.CancellationToken,});
        }
    
        // Get result of tasks as it finishes.
        var finalResult = new List&lt;object&gt;();
        for (var i = 0; i &lt; data.Length; i++)
        {
            var result = await workerBlock.Receive().ConfigureAwait(false);
            finalResult.Add(result);
        }
    
        return finalResult;
    }


I tried adding log to check the execution flow and it produced flow as following :

    Process start for task: 1
    Process start for task: 2
    Process start for task: 3
    Process start for task: 4
    
    Process end for task: 4
    Process end for task: 3
    Process end for task: 2
    Process end for task: 1


Above log shows that all the tasks are started in parallel and ended in the same sequence.
I also tried replacing TransformBlock with ActionBlock just for the sake of confirmation and flow is as following :

    Process start for task: 1
    Process end for task: 1
    
    Process start for task: 2
    Process end for task: 2
    
    Process start for task: 3
    Process end for task: 3
    
    Process start for task: 4
    Process end for task: 4

which is expected out put because MaxDegreeOfParallelism is set to 1 and thus task 2 should not start before task 1 finishes its job.

_Note : Above tasks actually send HTTP request to specific server._

**Expected Output**
Task2 should not start until Task1 ends because MaxDegreeOfParalellism is set to 1, so it sould only execute 1 message at a time. Similar to ActionBlock.

**Question**
Is this expected behavior or is it a bug?</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41822</IssueID>
    <RepoID>1</RepoID>
    <Title>API: long Math.BigMult(long, long, out long)</Title>
    <Description>To return 128 bit result (as per `long BigMul(int a, int b)`)
```csharp
partial class Math
{
    ulong Math.BigMult(ulong a, ulong b, out ulong high);
    long Math.BigMult(long a, long b, out long high);

    ulong Math.MultHigh(ulong a, ulong b);
    long Math.MultHigh(long a, long b);
}
```
While it is what the asm does (i.e. `RDX:RAX ← RAX ∗ SRC`) the apis either use a 128bit value or the split pair.

MSVC: 
```cpp
__int64 _mul128(__int64 Multiplier, __int64 Multiplicand, __int64 *HighProduct)
__int64 __mulh(__int64 a, __int64 b)
```
Others use `*` overloading on a `__uint128_t` type

Not sure best api shape (e.g. should it return a 128bit type `Vector128&lt;long&gt;`? /cc @tannergooding </Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41821</IssueID>
    <RepoID>1</RepoID>
    <Title>Consolidate files which were split by tfms which aren't supported anymore</Title>
    <Description>In example `ProcessTests.netcoreapp.cs` should be consolidated with `ProcessTests.cs`. As we just removed UWP we have multiple places to clean-up.

cc @stephentoub </Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41820</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191016.2
- **Date Produced**: 10/16/2019 8:55 PM
- **Commit**: 617091aa904c74fe8a42cebf7fcb56677c60c079
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview2.19516.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview2.19516.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview2.19516.2

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)



</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41819</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Threading.Channels. Ability to delete an item from channel queue only after its successful processing.</Title>
    <Description>Hi,
Is it possible to somehow organize reading from the System.Threading.Channel with confirmation?
I want to read data from a channel, and if I could not process it, so that the data remains in the channel queue, for example, until the next processing attempt.
```
var channel = Channel.CreateBounded&lt;LogItem&gt;(new BoundedChannelOptions(100)
            {
                FullMode = BoundedChannelFullMode.DropOldest,
                AllowSynchronousContinuations = true,
                SingleReader = true,
                SingleWriter = false
            });
//...
var item = await channel.Reader.ReadAsync();
await DoSomeWorkOnItemAsync(item); //Now, if DoSomeWorkOnItemAsync throws exception, I will lose item
```
Of course, I can add an item to the top of the queue, but I need the old items that have not been processed to be pushed out of the queue when it is full.

Is it possible for the channel to have an API like below?:
```
using (PickedResult&lt;LogItem&gt; peekedItem = await channel.Reader.PeekAsync())
{
    await DoSomeWorkOnItemAsync(peekedItem.Value);
    peekedItem.CommitRead(); // Confirmed read. Item removes from channel's queue
}
```

Thank you very much for your reply in advance.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41818</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failure: System.Numerics.Tests.ToStringTest.RunRegionSpecificStandardFormatToStringTests</Title>
    <Description>Test `System.Numerics.Tests.ToStringTest.RunRegionSpecificStandardFormatToStringTests` has failed

```
===========================================================================================================

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;for /F %f in ('dir /b /s "C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\Runner\"|find /i /v ".pri"') do @(set relPath=%f  &amp; set relPath=!relPath:C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\Runner\=!  &amp; if exist %f\nul (if not exist !relPath! mkdir !relPath! )  else (if not exist !relPath! mklink /h !relPath! %f  1&gt;NUL ) ) 

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;for /R "C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\UAPLayout\" %I in (*) do @if not exist "%~nxI" (mklink /H "%~nxI" "%I"  1&gt;NUL ) 

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;copy /y "C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\UAPLayout\System.Private.CoreLib.dll" System.Private.CoreLib.ni.dll 
        1 file(s) copied.

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;call "C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\Launcher\WindowsStoreAppLauncher.exe" -install appxmanifest.xml System.Runtime.Numerics.Tests.dll 
Got manifest file appxmanifest.xml
Removing any previous installation...
Installing the application...
Package Full Name is 5cd54353-3ed7-4a6e-a72f-db349f28867c_1.0.0.0_x64__v52bfwc2c21ha

SUCCESS
ExitCode 100

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;XUnitRunnerUap System.Runtime.Numerics.Tests.dll -xml "C:\Users\runner\AppData\Local\Packages\5cd54353-3ed7-4a6e-a72f-db349f28867c_v52bfwc2c21ha\LocalState\System.Runtime.Numerics.Tests.xml" -nologo -nocolor -notrait category=nonuaptests -notrait category=nonwindowstests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  
  Discovering: System.Runtime.Numerics.Tests (method display = ClassAndMethod, method display options = None)
  Discovered:  System.Runtime.Numerics.Tests (found 209 of 214 test cases)
  Starting:    System.Runtime.Numerics.Tests (parallel test collections = on, max threads = 2)
Unhandled exception. Xunit.Sdk.EqualException: Assert.Equal() Failure
Expected: 850
Actual:   851
   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer) in C:\Dev\xunit\xunit\src\xunit.assert\Asserts\EqualityAsserts.cs:line 41
   at Xunit.Assert.Equal[T](T expected, T actual) in C:\Dev\xunit\xunit\src\xunit.assert\Asserts\EqualityAsserts.cs:line 25
   at System.Numerics.Tests.ToStringTest.VerifyExpectedStringResult(String expectedResult, String result) in /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs:line 1447
   at System.Numerics.Tests.ToStringTest.VerifyToString(String test, String format, IFormatProvider provider, Boolean expectError, String expectedResult) in /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs:line 1431
   at System.Numerics.Tests.ToStringTest.RunStandardFormatToStringTests(Random random, String format, String negativeSign, Int32 precision, StringFormatter formatter) in /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs:line 468
   at System.Numerics.Tests.ToStringTest.&lt;&gt;c.&lt;RunRegionSpecificStandardFormatToStringTests&gt;b__7_0() in /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs:line 206
--- End of stack trace from previous location ---
   at Xunit.ConsoleClient.RemoteExecutor.Execute(String[] args)
   at Xunit.ConsoleClient.ConsoleRunner.EntryPoint(String[] args)
   at Xunit.ConsoleClient.Program.Main(String[] args)
    System.Numerics.Tests.ToStringTest.RunRegionSpecificStandardFormatToStringTests [FAIL]
      Microsoft.DotNet.RemoteExecutor.RemoteExecutionException : Remote process failed with an unhandled exception.
      Stack Trace:
        
        Child exception:
          Xunit.Sdk.EqualException: Assert.Equal() Failure
        Expected: 850
        Actual:   851
        /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs(1447,0): at System.Numerics.Tests.ToStringTest.VerifyExpectedStringResult(String expectedResult, String result)
        /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs(1431,0): at System.Numerics.Tests.ToStringTest.VerifyToString(String test, String format, IFormatProvider provider, Boolean expectError, String expectedResult)
        /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs(468,0): at System.Numerics.Tests.ToStringTest.RunStandardFormatToStringTests(Random random, String format, String negativeSign, Int32 precision, StringFormatter formatter)
        /_/src/System.Runtime.Numerics/tests/BigInteger/BigIntegerToStringTests.cs(206,0): at System.Numerics.Tests.ToStringTest.&lt;&gt;c.&lt;RunRegionSpecificStandardFormatToStringTests&gt;b__7_0()
        
        Child process:
          System.Runtime.Numerics.Tests, Version=4.1.1.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51 System.Numerics.Tests.ToStringTest+&lt;&gt;c Void &lt;RunRegionSpecificStandardFormatToStringTests&gt;b__7_0()
        
        
  Finished:    System.Runtime.Numerics.Tests
=== TEST EXECUTION SUMMARY ===
   System.Runtime.Numerics.Tests  Total: 1619, Errors: 0, Failed: 1, Skipped: 0, Time: 11.859s

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;set ERRORLEVEL=1 

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;move /Y "C:\Users\runner\AppData\Local\Packages\5cd54353-3ed7-4a6e-a72f-db349f28867c_v52bfwc2c21ha\LocalState\System.Runtime.Numerics.Tests.xml" .\testResults.xml 
        1 file(s) moved.

C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Work\3fe2f8e8-9f77-4423-8b23-bedaecebfa4a\Exec&gt;call "C:\dotnetbuild\work\191db5eb-01a4-4ef4-acce-408be6d9ef5c\Payload\Launcher\WindowsStoreAppLauncher.exe" -uninstall appxmanifest.xml System.Runtime.Numerics.Tests.dll 
Got manifest file appxmanifest.xml
Removing the application...

SUCCESS
ExitCode 100
----- end Wed 10/16/2019  3:06:51.86 ----- exit code 1 ----------------------------------------------------------
```

Build:[20191015.66](https://dnceng.visualstudio.com/public/_build/results?buildId=389370)(Master)

Details:
https://helix.dot.net/api/2019-06-17/jobs/191db5eb-01a4-4ef4-acce-408be6d9ef5c/workitems/System.Runtime.Numerics.Tests/console</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41817</IssueID>
    <RepoID>1</RepoID>
    <Title>error NETSDK1084: There is no application host available for the specified RuntimeIdentifier 'linux-x86'</Title>
    <Description>Trying to publish a project for `linux-x86` fails:
```
λ dotnet publish -c Release -o --self-contained --runtime linux-x86
Microsoft (R) Build Engine version 16.3.0+0f4c62fea for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.FrameworkReferenceResolution.targets(87,5): error NETSDK1084: There is no application host available for the specified RuntimeIdentifier 'linux-x86'. [C:\src\test\Test.Worker.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.FrameworkReferenceResolution.targets(87,5): error NETSDK1084: There is no application host available for the specified RuntimeIdentifier 'linux-x86'. [C:\src\test\Test.Worker.csproj]
```

`linux-x64` works fine though.

Can `--self-contained` not be used for 32-bit Linux builds?</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41816</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Sse2.StoreScalar(int*)</Title>
    <Description>## Background

`System.Runtime.Intrinsics.X86.Sse2` exposes load and store methods accepting address arguments for most supported types, but methods to store to an `int*` are missing.

The load versions of the methods are present:

```C#
/// &lt;summary&gt;
/// __m128i _mm_loadl_epi32 (__m128i const* mem_addr)
/// MOVD xmm, reg/m32
/// The above native signature does not exist. We provide this additional overload for completeness.
/// &lt;/summary&gt;
public static unsafe Vector128&lt;int&gt; LoadScalarVector128(int* address) =&gt; LoadScalarVector128(address);
/// &lt;summary&gt;
/// __m128i _mm_loadl_epi32 (__m128i const* mem_addr)
/// MOVD xmm, reg/m32
/// The above native signature does not exist. We provide this additional overload for completeness.
/// &lt;/summary&gt;
public static unsafe Vector128&lt;uint&gt; LoadScalarVector128(uint* address) =&gt; LoadScalarVector128(address);
```

As noted in the comments, `_mm_loadl_epi32` doesn't exist in the Intel intrinsics guide.  However, there is a matching signature under `_mm_loadu_si32`

```
__m128i _mm_loadu_si32 (void const* mem_addr)
#include &lt;immintrin.h&gt;
Instruction: movd xmm, m32
CPUID Flags: SSE2
```

Its counterpart for storing a scalar int32 also exists:

```
void _mm_storeu_si32 (void* mem_addr, __m128i a)
#include &lt;immintrin.h&gt;
Instruction: movd m32, xmm
CPUID Flags: SSE2
```

However the `StoreScalar` pair that would correspond to that intrinsic is missing.

## Rationale

`StoreScalar` is implemented with address arguments for `float`, `double` and `long`, but not for `int`.

`StoreScalar` methods for `int` would mirror the existing `LoadScalarVector128(int *)` methods and would complete the set of supported types for stores.

## Poposed API

```C#
public abstract class Sse2 : Sse
{
     /// &lt;summary&gt;
     /// void _mm_storeu_si32 (void* mem_addr, __m128i a)
     ///   MOVD m32, xmm
     /// &lt;/summary&gt;
    public static unsafe void StoreScalar(int* address, Vector128&lt;int&gt; source);
     /// &lt;summary&gt;
     /// void _mm_storeu_si32 (void* mem_addr, __m128i a)
     ///   MOVD m32, xmm
     /// &lt;/summary&gt;
    public static unsafe void StoreScalar(uint* address, Vector128&lt;uint&gt; source);
}
```
</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41815</IssueID>
    <RepoID>1</RepoID>
    <Title>Random class return always 0</Title>
    <Description>There is an issue/bug in all dotnet versions in the Random.cs class https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Random.cs in which a Random class could start continuously returning 0 instead of returning random values. 
We understand that it is not a ThreadSafe class, but the result expected by the developers is that there can be at most a collision of random numbers, never that the class stays unusable.

We are attaching an exploit through which, through a race condition, it is possible to clean the seed of the random class, producing the class to return always 0 as a value.

The problem resides in the lines https://github.com/dotnet/corefx/blob/b5ef4ea045bdd3dc8d528e6408360bf812eefd17/src/Common/src/CoreLib/System/Random.cs#L97-L103 since it can occur that on the line:

`_seedArray [locINext] - _seedArray [locINextp];`

locINext and locINextp could be the same value, as multiple threads could alter this variable at same time.

This would produce that on line

`_seedArray [locINext] = retVal;`

the value will be setted to 0.

Within few iterations (you can verify in the attached POC that it is almost automatic), the seed would be completely cleaned leaving the object unusable.

[POC.zip](https://github.com/dotnet/corefx/files/3732606/POC.zip)

```
POC output

ORIGINAL SEED
0,1261245938,2001160549,2054970582,1511994205,588873991,480746266,1779797753,665659865,1854996623,1938082469,2108912300,347917445,845739246,368227379,1423652656,593794754,217633842,1072839460,322608053,574779412,305273214,98102373,304075016,995970494,1508209844,196886427,1236393058,129781740,1614679893,1748376148,22713167,568943384,1329296790,1787809206,1267184514,616255838,2039008312,722324858,651872233,1486516453,1054557708,1523587302,1315697345,1567279153,2074108332,1149686098,1016370253,281684058,165594665,350276570,1016924035,1697075198,202215719,867808149,814569218
EMPTY SEED
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Random seed was empty!
Test Next: 0
Test Next: 0
Test Next: 0
Test Next: 0
Test NextBytes: 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
```</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41814</IssueID>
    <RepoID>1</RepoID>
    <Title>OleDbTransaction.Commit Exception ''SQLNCLI11' failed with no error message available</Title>
    <Description>* `netcoreapp2.1`
* `System.Data.OleDB 4.6.0`

Calling `OleDbTransaction.Commit` throws this exception:

    System.Data.OleDb.OleDbException: ''SQLNCLI11' failed with no error message available, result code: E_NOINTERFACE(0x80004002).'

This does not occur when targeting net461.

If I execute the operations without a transaction they appear to work correctly.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41813</IssueID>
    <RepoID>1</RepoID>
    <Title>CamelCase not applied to list of KeyValuePair</Title>
    <Description>CamelCase naming policy is not applied to list of KeyValuePair.

Code to reproduce:

JsonSerializerOptions options = new JsonSerializerOptions()
{
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
};
           
Dictionary&lt;string, object&gt; dict = new Dictionary&lt;string, object&gt;();
dict.Add("Item1", "Value1");
dict.Add("Item2", 22);

string json = JsonSerializer.Serialize(dict.ToList(), options);

Console.WriteLine(json);

Actual results:

[
  {
    "Key": "Item1",
    "Value": "Value1"
  },
  {
    "Key": "Item2",
    "Value": 22
  }
]

Expected results:

[
  {
    "key": "Item1",
    "value": "Value1"
  },
  {
    "key": "Item2",
    "value": 22
  }
]






</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41812</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable deterministically failing outerloop CNG tests</Title>
    <Description>https://github.com/dotnet/corefx/issues/41610
cc: @bartonjs</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41902</IssueID>
    <RepoID>1</RepoID>
    <Title>Migrate to 3.0 misleading message to reference System.Data.SqlClient</Title>
    <Description># General

Migrating to core 3.0 from 2.2 issues a message over SqlParameter `SqlParameter is now in System.Data.SqlClient`. Adding the package yield a runtime message `System.InvalidCastException: The SqlParameterCollection only accepts non-null SqlParameter type objects`.

# Resolution

Adding a reference to Microsoft.Data.SqlClient, as does the underlaying Microsoft.EntityFrameworkCore, rather than to System.Data.SqlClient - works.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41811</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json support for DynamicObject.</Title>
    <Description>I was trying to convert our project to use System.Text.Json (v3 latest stable) and noticed that it's not deserializing values to DynamicObject or deriving types. When deserializing the `DynamicObject` the `TrySetMember` should be called and it is not.

This might also reference: https://github.com/dotnet/corefx/issues/38007 

We have a [Delta&lt;T&gt;](https://github.com/exceptionless/Exceptionless/blob/feature/elastic7/src/Exceptionless.Web/Utility/Delta/Delta.cs) that has been modified from [OData days](https://github.com/mono/aspnetwebstack/blob/master/src/System.Web.Http.OData/OData/Delta.cs#L16) and I noticed that our patches were failing via integration tests. So I wrote a simple test:

```cs
public class Delta&lt;TEntityType&gt; : DynamicObject where TEntityType : class {} 
....

public class NewToken {
        public NewToken() {
            Scopes = new HashSet&lt;string&gt;();
        }

        public string OrganizationId { get; set; }
        public string ProjectId { get; set; }
        public string DefaultProjectId { get; set; }
        public HashSet&lt;string&gt; Scopes { get; set; }
        public DateTime? ExpiresUtc { get; set; }
        public string Notes { get; set; }
    }

        [Fact]
        public void CanSerializeSimpleModel() {
            var token = new NewToken {
                OrganizationId = "TEST_ORG_ID",
                ProjectId = "TEST_PROJECT_ID"
            };

            string json = System.Text.Json.JsonSerializer.Serialize(token);
            _logger.LogInformation(json);
            var delta = System.Text.Json.JsonSerializer.Deserialize&lt;Delta&lt;NewToken&gt;&gt;(json, settings);
            Assert.Equal(2, delta.GetChangedPropertyNames().Count());
        }
```

with serializer settings defined as:
```cs
            options.AllowTrailingCommas = true;
            options.DictionaryKeyPolicy = null;
            options.IgnoreNullValues = true;
            options.IgnoreReadOnlyProperties = false;
            options.PropertyNameCaseInsensitive = true;
            //options.PropertyNamingPolicy = new SnakeCaseJsonNamingPolicy();
            options.ReadCommentHandling = JsonCommentHandling.Skip;
            options.WriteIndented = false;
```</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41810</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Encoding extensions which work with sequences</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41166.
Fixes https://github.com/dotnet/corefx/issues/41326.

This PR adds a static `EncodingExtensions` type. This type contains extension methods which allow consumers to use `Encoding`, `Encoder`, and `Decoder` with `ReadOnlySequence&lt;T&gt;` and `IBufferWriter&lt;T&gt;`.

Unit tests will not pass because they're blocked on https://github.com/dotnet/coreclr/issues/27191 being fixed.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41809</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @dotnet-maestro[bot]
* @danmosemsft
* @ViktorHofer
* @mmitche
* @Anipik

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41808</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.ObjectModel for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41807</IssueID>
    <RepoID>1</RepoID>
    <Title>Pass down /warnaserror switch for package testing</Title>
    <Description>Related to: https://github.com/dotnet/corefx/pull/41800

It should fail on the first build iteration until that other PR is merged.

Did it as separate PRs to prove that this would solve the package testing issue.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41806</IssueID>
    <RepoID>1</RepoID>
    <Title>Add ConnectCallback to SocketsHttpHandler</Title>
    <Description>Adds SocketsHandler.ConnectCallback. Resolves #35404</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41805</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Huffman encoding for headers. </Title>
    <Description>Add Huffman encoding for HTTP2 headers. It falls back to uncompressed when the value would be expanded. Resolves #31308

In benchmarks I'm seeing a difference right on the edge of SNR. This makes a trivial HTTP2 request about 0.5% slower than current state.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41804</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20191015.2
- **Date Produced**: 10/15/2019 7:05 PM
- **Commit**: ecfe3bca7cfbd413415af9d2bcccb5f9a361f962
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.1-servicing.19515.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.1-servicing.19515.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.1-servicing.19515.2

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41802</IssueID>
    <RepoID>1</RepoID>
    <Title>Add unit tests to cover DecoderNLS.Convert 'completed' scenarios</Title>
    <Description>Unit tests for https://github.com/dotnet/coreclr/pull/27210. These unit tests will not pass until the nightly coreclr build makes its way to corefx.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41801</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable finalization of bogus SafeWaitHandles</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41635#issuecomment-542409299.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41800</IssueID>
    <RepoID>1</RepoID>
    <Title>Add stable versions for Microsoft.Bcl.* packages</Title>
    <Description>Core-Setup hasn't consumed CoreFx in 11 days failing with error:
/root/coresetup/src/managed/Microsoft.Extensions.DependencyModel/Microsoft.Extensions.DependencyModel.csproj(0,0): error NU1603: System.Text.Json 5.0.0-alpha1.19515.2 depends on Microsoft.Bcl.AsyncInterfaces (&gt;= 1.0.0-alpha1.19515.2) but Microsoft.Bcl.AsyncInterfaces 1.0.0-alpha1.19515.2 was not found. An approximate best match of Microsoft.Bcl.AsyncInterfaces 1.0.0-preview6.19230.11 was resolved.

https://github.com/dotnet/core-setup/pull/8477

The reason for that is because we removed the `Microsoft.Bcl` packages in: https://github.com/dotnet/corefx/pull/41270

However, the package index was not updated accordingly, since we were lacking the stable versions in the package index for these packages, System.Text.Json, was getting a dependency to a `non-stable` package based on the current build version suffix.

FYI: @scalablecory </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41799</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2. I'm a robot and am configured to help you automatically keep release/2.2 up to date, so I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @wtgodbe
* @ViktorHofer

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/2.1
git pull --ff-only
git checkout release/2.2
git pull --ff-only
git merge --no-ff release/2.1

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/2.1-to-release/2.2'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41798</IssueID>
    <RepoID>1</RepoID>
    <Title>Clear out packages.builds for 2.1.14</Title>
    <Description>The Platforms package hasn't changes since 2.1.13, so we should turn off its build for 2.1.14.

@safern @joperezr PTAL

CC @danmosemsft @Anipik </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41797</IssueID>
    <RepoID>1</RepoID>
    <Title>Clear out packages.builds for 2.2.8</Title>
    <Description>The Platforms package hasn't changes since 2.2.7, so we should turn off its build for 2.2.8.

@safern @joperezr PTAL

CC @danmosemsft @Anipik </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41796</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Fixing NullReferenceException in XmlSchemaAnyAttribute.Namespace</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41704
Ports https://github.com/dotnet/corefx/pull/41731
Regressed by https://github.com/dotnet/corefx/commit/2c22af8903522e54f71225c40ddd383b15632ae0

#### Description

This is a regression. Customer reports that using "empty" instance of XmlSchemaAnyAttribute (i.e. `&lt;xs:anyAttribute/&gt;`) and accessing Namespace property is causing NRE. This feature is used to to tell that any attribute not defined by schema is allowed which is not very rare scenario. Reported by 2 customers at least one of which is porting.
		
#### Customer Impact

Customers using XML Schema moving forward to 3.0 may get NRE in an app which previously worked correctly. The only workaround is not to use `Namespace` property since there is currently no way of predicting when it will throw with public APIs except for manually re-parsing XML and searching for this specific case.

#### Regression?

Yes. Regressing fix came with tests but did not check for empty namespace.

#### Risk

Small. Adds extra null check. Fix comes with a test exercising this and similar scenario.

cc: @danmosemsft @buyaa-n @martin-frydl @stephentoub </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41795</IssueID>
    <RepoID>1</RepoID>
    <Title>Build missed OOB packages for 3.0.1</Title>
    <Description>We missed adding these 3 OOB packages to `packages.builds`, and therefore aren't currently exposing the changes to them from the following PRs for 3.0.1:

https://github.com/dotnet/corefx/pull/41202
https://github.com/dotnet/corefx/pull/41660
https://github.com/dotnet/corefx/pull/41484

@safern PTAL
CC @danmosemsft @bartonjs @JeremyKuhne @Anipik 

@mmitche we should get this in ASAP for 3.0.1

This change should be reverted once we bump branding for 3.0.2.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41794</IssueID>
    <RepoID>1</RepoID>
    <Title>add RID for new FreeBSD releases</Title>
    <Description>This adds entry for FreeBSD 12 (stable) and Freebsd 13 (snapshots) 
I used #41397 as example and dropped minor versions so we will track only major releases like we do for Centos. Based on my testing, binaries build on 11.x works fine on 12 (with already submitted threading fix) so I see no reason to track them separate. I have not done testing on 13 but I assume it will be similar. When we did builds last time we used  `freebsd-x64 `

cc: @jasonpugsley

fixes #40865

</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41864</IssueID>
    <RepoID>1</RepoID>
    <Title>ElapsedEventArgs doesn't have a public constructor</Title>
    <Description>System.Timers.ElapsedEventArgs doesn't have a public constructor, despite just being a data class containing one property.  This makes it unnecessarily awkward to write a mock for something that uses an ElapsedEventHandler, because you need to use a workaround just to create this one object.

It's impossible to solve this by subclassing ElapsedEventArgs, because the SignalTime property is read-only and therefore cannot be set by your constructor.

</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41792</IssueID>
    <RepoID>1</RepoID>
    <Title>.net core 3.0 upload big file faild</Title>
    <Description>1 IDE
![image](https://user-images.githubusercontent.com/32727597/66853046-f7ab6c00-efb0-11e9-83a0-d9df9a4d2fb5.png)

2 .net core version (my project version)
![image](https://user-images.githubusercontent.com/32727597/66853134-23c6ed00-efb1-11e9-8344-ac4b64d6fe3d.png)

3 controller &amp; api
![image](https://user-images.githubusercontent.com/32727597/66853188-40632500-efb1-11e9-9187-c126b7048774.png)

4 startup config
![image](https://user-images.githubusercontent.com/32727597/66853234-5a9d0300-efb1-11e9-8694-6d9bc0877efd.png)

5 upload file 
![image](https://user-images.githubusercontent.com/32727597/66853743-92f11100-efb2-11e9-802e-94b120b4784a.png)


5 error stack (error file size is &gt;16MB)
![image](https://user-images.githubusercontent.com/32727597/66853429-dbf49580-efb1-11e9-8927-037ce56da6d6.png)

6.success condition (file size is 1KB )
![image](https://user-images.githubusercontent.com/32727597/66853827-c2078280-efb2-11e9-87d9-b0f1edefeef3.png)

small file is success accepted
![image](https://user-images.githubusercontent.com/32727597/66854055-2f1b1800-efb3-11e9-8068-132c8d631e7d.png)

is this config not effect or i config wrong? 
when i use .net core 2.2 ,that file[5] was success uploaded...

here is my code on github 
https://github.com/1369521908/Obsidian.git

</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41791</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.1] Add Fedora 32 and CentOS 8 runtime ids</Title>
    <Description>This is a combined backport of:

- PR #41397: commit 6f82bd59a05ea9556397596ae9e59f39b904b222
- PR #40786: commit 86fc9e751c424278a9c4e163e0a71a9d7e30c8e7

Do I need to bump the version in `pkg/Microsoft.NETCore.Platforms/Microsoft.NETCore.Platforms.pkgproj`?</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41790</IssueID>
    <RepoID>1</RepoID>
    <Title>Rewrite UriHelper.UnescapeString to remove unsafe code and improve perf</Title>
    <Description>PR https://github.com/dotnet/corefx/pull/41772 rewrote EscapeString with safe code, and it not only removed unsafe code from a key networking-exposed area of the system, it also resulting in performance benefits and cleaner code.  We should look at doing the same thing for the other direction with UnescapeString.  It's likely to be a bit more challenging, as it currently has more modes for configuration.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41789</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.2] Add CentOS 8 Runtime ID to the graph</Title>
    <Description>CentOS 8 has been released:
https://wiki.centos.org/Manuals/ReleaseNotes/CentOSLinux8

    $ cat /etc/os-release
    NAME="CentOS Linux"
    VERSION="8 (Core)"
    ID="centos"
    ID_LIKE="rhel fedora"
    VERSION_ID="8"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="CentOS Linux 8 (Core)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:centos:centos:8"
    HOME_URL="https://www.centos.org/"
    BUG_REPORT_URL="https://bugs.centos.org/"
    CENTOS_MANTISBT_PROJECT="CentOS-8"
    CENTOS_MANTISBT_PROJECT_VERSION="8"
    REDHAT_SUPPORT_PRODUCT="centos"
    REDHAT_SUPPORT_PRODUCT_VERSION="8"

This is a backport of https://github.com/dotnet/corefx/pull/41397 and
commit c939f5d441979a45aeac84e5f2e16e62748f607b.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41788</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2. I'm a robot and am configured to help you automatically keep release/2.2 up to date, so I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @ViktorHofer

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/2.1
git pull --ff-only
git checkout release/2.2
git pull --ff-only
git merge --no-ff release/2.1

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/2.1-to-release/2.2'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41787</IssueID>
    <RepoID>1</RepoID>
    <Title>Synchronize HTTP/2 Framing and HPACK code with ASP.NET Core</Title>
    <Description>**Things to share:**
- HPACK (Encoding/Decoding), These are similar today, so it should be a simple unification
- Framing code, different representations/organization, but not a lot of code.

Primary is corefx, with ASP.NET Core as secondary. This means all changes to shared code should start in corefx and merged up to ASP.NET Core. We also have a script for inner loop development to test against each repo as well as potentially a unit test to verify shared source is up to date.

The hardest part of this change will be creating a bot to copy source from corefx to aspnetcore. This needs to work on each branch from 3.0 up. Hypothetically this is a simple bot:
check if a subfolder in corefx has a new commit/new commits in it. If it does, checkout aspnetcore and copy the contents. @mmitche can we sync about this?

**Actionable items:**
- [x] Synchronize aspnetcore and corefx HPACK implementation (still need a reaction PR in AspNetCore)
- [ ] Readme
- [ ] Inner loop copy script (both directions)
- [ ] Move more unit tests from ASP.NET Core to corefx 
- [ ] Create a bot to sync code from corefx to aspnetcore.
- [ ] Validation/verification to make sure code is "in sync" 
- [ ] Create github group/ code owners to make sure all stakeholders are added to PRs

**Open questions:**
- Copyrights
- Namespaces
- Resource strings

cc @Tratcher @scalablecory </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41786</IssueID>
    <RepoID>1</RepoID>
    <Title>Support for Unix ACLs?</Title>
    <Description>What is our story for ACL's on Unix, where file system supports it?

[Mono.Posix](https://www.nuget.org/packages/Mono.Posix.NETStandard) (what we point at for API for Unix primitives) does not support them. Do we need to offer support for them somewhere? 

Whereever that support lies, do we need to add extension methods (like [this](https://github.com/dotnet/corefx/issues/41614)) to allow objects to be created with the ACL applied?  If not, what is the story for folks porting Windows code using ACL's to Linux?

This assumes we do not want to attempt to overload types like `DirectorySecurity`, which were designed with Windows in mind, to accommodate Unix.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41785</IssueID>
    <RepoID>1</RepoID>
    <Title>Move test helper linked files into CoreFx.Private.TestUtilities</Title>
    <Description>The helper files and the strategy to link them into the test projects directly existed long before CoreFx.Private.TestUtilities was added (during the UWP bringup phase in 2017). Every helper which is linked into more than one test project should be moved to the TestUtilities library.

cc @stephentoub</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41784</IssueID>
    <RepoID>1</RepoID>
    <Title>Make Type implement IEquatable&lt;Type&gt;</Title>
    <Description>I'm not sure why this hasn't been done as `Type` already has an `Equals(Type)` method but I'd like `Type` to implement `IEquatable&lt;Type&gt;` so I can use `Type` as a type argument where there's a generic type constraint of `IEquatable&lt;T&gt;` such as in [DictionarySlim](https://github.com/dotnet/corefxlab/blob/master/src/Microsoft.Experimental.Collections/Microsoft/Collections/Extensions/DictionarySlim.cs#L31).</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41783</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: Unsafe.NullRef, IsNullRef</Title>
    <Description>Proposed API
---
``` csharp
namespace System.Runtime.CompilerServices
{
    public class Unsafe
    {
        public bool IsNullRef&lt;T&gt;(ref T);
        public ref T NullRef&lt;T&gt;();
    }
}
```

`ref` cannot be null pointer in C#, but it is perfectly valid in IL. `ref` containing null pointers are useful for low-level optimizations. For example, https://github.com/dotnet/coreclr/pull/27195 uses them to make Dictionary lookups about 10% faster. There are several other examples in the .NET Core framework where we have used `ref` containing null pointers.

The Unsafe class does have building blocks that allow operations on null `ref` pointers (e.g. `Unsafe.AsPointer&lt;T&gt;(null)` creates null ref), but it obfuscates the intent and it is not as straightforward and lean as it can be. The proposed APIs will make it easier.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41782</IssueID>
    <RepoID>1</RepoID>
    <Title>How can I host AspNetCore in Windows Service with https url?</Title>
    <Description>I have a AspNetCore which will host in Windows Service.
The CreateHostBuilder method as below.

``` csharp
public static IHostBuilder CreateHostBuilder(string[] args)
{
	return Host
		.CreateDefaultBuilder(args)
		.UseWindowsService()
		.ConfigureServices((context, services) =&gt;
		{
			services.AddHostedService&lt;Worker&gt;();
		})
		.ConfigureWebHostDefaults(builder =&gt;
		{
			builder.UseUrls("http://localhost:6000/", "https://localhost:6001/");
			builder.UseStartup&lt;Startup&gt;();
		});
}
```

When I run it in Console, everything works fine.
However, when I install it as Windows Service, and request the http://localhost:6000/ or https://localhost:6001/, there is nothing returned.
Seems the UseUrls only support one url with http scheme, like 
``` csharp
builder.UseUrls("http://localhost:6000/");
```</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41781</IssueID>
    <RepoID>1</RepoID>
    <Title>SslStream AuthenticateAsClientAsync blocks if the current user has no access to the client cert private key (windows certificate store)</Title>
    <Description>I've tried to create a SSL connection with SslStream on top of Socket.
This works IF the current user has access to the private key of the client cert, stored in the windows certificate store.
If the current user has NO access to the private key, the call to _AuthenticateAsClientAsync_ will block forever.

I've tested with .NET Core 3 on a Windows 10 (1903 18362.388) machine. 

```

const String hostName = "hostName";
var ipHostInfo = await Dns.GetHostEntryAsync( hostName )
						  .ConfigureAwait( false );
var ipAddress = ipHostInfo.AddressList[0];
var remoteEndPoint = new IPEndPoint( ipAddress, 61000 );

var socket = new Socket( ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp );
await socket.ConnectAsync( remoteEndPoint )
			.ConfigureAwait( false );

var networkStream = new NetworkStream( socket, true );
var sslStream = new SslStream( 
	networkStream,
	false,
	( sender, certificate, chain, sslPolicyErrors ) =&gt; true, // Accept invalid cert...testing
	( sender, targetHost, localCertificates, remoteCertificate, acceptableIssuers ) =&gt;
	{
	   if ( localCertificates.Count == 1 )
		   return localCertificates[0];

	   if ( localCertificates.Count &lt;= 1 )
		   return null;

	   const String subject = "CertSubject";
	   var match = localCertificates.Cast&lt;X509Certificate2&gt;()
									.FirstOrDefault( certificate =&gt; String.Compare( certificate.Subject, subject, StringComparison.OrdinalIgnoreCase ) == 0 );
	   return match;
	} );

using var store = new X509Store( "My", StoreLocation.LocalMachine );
store.Open( OpenFlags.ReadOnly );
var collection = store.Certificates;

await sslStream.AuthenticateAsClientAsync( hostName, collection, SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12 | SslProtocols.Tls13, false )
                .ConfigureAwait( false );
```
</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41780</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json: JsonExtensionData should use configured PropertyNamingPolicy</Title>
    <Description>Hi,

I think it would be reasonable to expect that when we use JsonExtensionData to flatten the dictionary contents as properties, that the serializer would respect whatever PropertyNamingPolicy was defined in the serializer options.

Or maybe add an option to JsonExtensionData to control how the serializer should handle the flattened properties:

`[JsonExtensionData(UsePropertyNamingPolicy = true)]`

```csharp
public class Test1 
{
    [Fact]
    public void JsonExtensionData_should_respect_PropertyNamingPolicy_YesOrNo()
    {
        var obj = new TestClass()
        {
            Foo = "Hello",                
            ExtensionData = new Dictionary&lt;string, object&gt;() {
                { "Bar", true }
            }
        };

        var options = new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
        var serializedJson = JsonSerializer.Serialize(obj, options);

        string expectedJson = "{\"foo\":\"Hello\",\"bar\":true}";


        Assert.Equal(expectedJson, serializedJson);
        // this fails as of dotnet 3.0 
        //                            ↓ (pos 16)
        // Expected: { "foo":"Hello","bar":true}
        //   Actual: { "foo":"Hello","Bar":true}
        //                            ↑ (pos 16)

    }

    public class TestClass
    {
        public string Foo { get; set; }

        [JsonExtensionData]
        public Dictionary&lt;string, object&gt; ExtensionData { get; set; }
    }
}
```
</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41779</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonStringTests.TestDateTimeOffset test failure</Title>
    <Description>This test failed on my machine for `dateTime: 0001-01-01T00:00:00.0000000Z`:
```xml
      &lt;test name="System.Text.Json.Tests.JsonStringTests.TestDateTimeOffset(dateTime: 0001-01-01T00:00:00.0000000Z)" type="System.Text.Json.Tests.JsonStringTests" method="TestDateTimeOffset" time="0.0904563" result="Fail"&gt;
        &lt;failure exception-type="System.FormatException"&gt;
          &lt;message&gt;&lt;![CDATA[System.FormatException : The UTC representation of the date '0001-01-01T00:00:00' falls outside the year range 1-9999.]]&gt;&lt;/message&gt;
          &lt;stack-trace&gt;&lt;![CDATA[   at System.DateTimeParse.ParseExact(ReadOnlySpan`1 s, ReadOnlySpan`1 format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan&amp; offset) in /_/src/System.Private.CoreLib/shared/System/Globalization/DateTimeParse.cs:line 46
   at System.DateTimeOffset.ParseExact(String input, String format, IFormatProvider formatProvider, DateTimeStyles styles) in /_/src/System.Private.CoreLib/shared/System/DateTimeOffset.cs:line 542
   at System.DateTimeOffset.ParseExact(String input, String format, IFormatProvider formatProvider) in /_/src/System.Private.CoreLib/shared/System/DateTimeOffset.cs:line 528
   at System.Text.Json.Tests.JsonStringTests.TestDateTimeOffset(DateTime dateTime) in /home/tmds/repos/corefx/src/System.Text.Json/tests/JsonStringTests.cs:line 112]]&gt;&lt;/stack-trace&gt;
        &lt;/failure&gt;
      &lt;/test&gt;
```</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41778</IssueID>
    <RepoID>1</RepoID>
    <Title>Happy Eyeballs support in Dns and Sockets</Title>
    <Description>This proposal adds APIs needed to implement RFC 8305 "Happy Eyeballs" in `Socket.Connect`.

See https://github.com/dotnet/corefx/issues/29716#issuecomment-540141586 where we decided to explore this as a general `Socket` feature rather than only `SocketsHttpClient`.

(API has cancellation support added where there previously hasn't been, to avoid needing to add yet more APIs later. See related #37118 #40586)

```c#
class System.Net.Dns
{
    // set the ai_family hint in getaddrinfo.
    public static IPAddress[] GetHostAddresses(string hostNameOrAddress, AddressFamily family);
    public static ValueTask&lt;IPAddress[]&gt; GetHostAddressesAsync(string hostNameOrAddress, AddressFamily family, CancellationToken cancellationToken = default);

    // also consider GetHostAddresses
}

class System.Net.Sockets.Socket
{
    public void Connect (string host, int port, ConnectFlags connectFlags);
    public void Connect (IPAddress[] addresses, int port, ConnectFlags connectFlags);
    public void Connect (EndPoint remoteEP, ConnectFlags connectFlags);
    public static bool ConnectAsync (SocketType socketType, ProtocolType protocolType, ConnectFlags connectFlags, SocketAsyncEventArgs e, CancellationToken cancellationToken = default);
}

class System.Net.Sockets.SocketTaskExtensions
{
    public static ValueTask ConnectAsync(this Socket socket, string host, int port, ConnectFlags connectFlags, CancellationToken cancellationToken = default);
    public static ValueTask ConnectAsync(this Socket socket, IPAddress[] addresses, int port, ConnectFlags connectFlags, CancellationToken cancellationToken = default);
    public static ValueTask ConnectAsync(this Socket socket, EndPoint remoteEP, ConnectFlags connectFlags, CancellationToken cancellationToken = default);
}

[Flags]
enum System.Net.Sockets.ConnectFlags
{
    // use existing behavior.
    None,

    // use a Happy Eyeballs-like algorithm to connect.
    Parallel = 1
}
```

This is a blocker for #29716.</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41777</IssueID>
    <RepoID>1</RepoID>
    <Title>Add support to produce WebAssembly runtime assets</Title>
    <Description>This enables a build for webassembly as a OSGroup-ArchGroup using a Linux implementation detail from our sources and produces a package with System.Native pal as a native asset using `emscripten` to build it.

The package would be `runtime.webassembly-wasm.Microsoft.Private.CoreFx.NETCoreApp`.

Worked in collaboration with @vargaz in order to tweak the native sources to have a clean build.

cc: @danmosemsft @marek-safar @lewing </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41776</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix cast in CacheMemoryMonitor</Title>
    <Description>Avoid overflow.
cc: @KKhurin </Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41775</IssueID>
    <RepoID>1</RepoID>
    <Title>X509Extension.Format() doesn't work well in macOS system </Title>
    <Description>MacOs:
PS &gt; $ext.Format($false)
3042304006082B06010505073002863468747470733A2F2F73632D7072642D636F6D702D76633035342E656E672E766D776172652E636F6D2F6166642F766563732F6361

While the same certificate in Ubuntu:
PS &gt; $ext.Format($false) CA Issuers - URI:https://sc-prd-comp-vc054.eng.vmware.com/afd/vecs/ca

Expected behavior
In the MacOs, it should return the same result with the one in Ubuntu</Description>
    <CreatedDate>15/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41774</IssueID>
    <RepoID>1</RepoID>
    <Title>Backup important wiki information</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/36057

Original documents in this PR:
- ~~[Building .NET Core 2.X on FreeBSD](https://github.com/dotnet/corefx/wiki/Building-.NET-Core--2.x-on-FreeBSD)~~
- [Building .NET Core 3.X on FreeBSD](https://github.com/dotnet/corefx/wiki/Building-.NET-Core-3.x-on-FreeBSD)
- ~~[Links](https://github.com/dotnet/corefx/wiki/Links)~~
- [Pick Issue](https://github.com/dotnet/corefx/wiki/Pick-issue) - Only rescued two labels mentioned here that we were not mentioning in the CoreFX documentation.
- Also added the links to the FreeBSD instructions in unix-instructions.md.
</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41772</IssueID>
    <RepoID>1</RepoID>
    <Title>Rewrite Uri.EscapeString</Title>
    <Description>Several public methods (Uri.EscapeDataString, Uri.EscapeUriString) and a bunch of internal call sites rely on the internal EscapeString helper.  This helper has several issues with it:
- It uses unsafe code.
- It unnecessarily requires and copies through a char[] to get to a string when a string is the required result.
- It has a lot of complexity around the handling of unicode.

This PR rewrites it to utilize Span, Rune, and other newer features in a way that enables it to be both safe and efficient.  Most inputs ends up being faster, and for very long inputs, it's much, much faster.  The use of ValueStringBuilder also results in less memory allocation, in some cases significantly.

The use of Rune also fixes two arguable bugs in the existing implementation around invalid Unicode sequences, which is why a couple tests were tweaked:
- Some but not all invalid unicode patterns result in replacement characters being used: a few invalid sequences (e.g. just a high surrogate) result in an exception.  We should be standardized on using replacement characters for all such invalid sequences.
- Some patterns with invalid unicode patterns actually result in unnecessary encoding, e.g. `Uri.EscapeDataString("\uD800\uD800a")` results in `a` being encoded.

|     Method | Tool | Length |                 Kind |                Mean | Ratio |    Allocated |
|----------- |---------- |------- |--------------------- |--------------------:|------:|-------------:|
| EscapeData | new       |     10 |           Unreserved |            19.92 ns |  0.23 |            - |
| EscapeData | old       |     10 |           Unreserved |            84.86 ns |  1.00 |            - |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |     10 |           Unreserved |            17.00 ns |  0.17 |            - |
|  EscapeUri | old       |     10 |           Unreserved |           103.09 ns |  1.00 |            - |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |     10 |              Unicode |           316.53 ns |  0.96 |        264 B |
| EscapeData | old       |     10 |              Unicode |           330.18 ns |  1.00 |       1248 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |     10 |              Unicode |           313.91 ns |  0.95 |        264 B |
|  EscapeUri | old       |     10 |              Unicode |           328.76 ns |  1.00 |       1248 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |     10 | OneRe(...)erved [25] |           154.93 ns |  1.04 |         48 B |
| EscapeData | old       |     10 | OneRe(...)erved [25] |           149.36 ns |  1.00 |        312 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |     10 | OneRe(...)erved [25] |           152.34 ns |  0.85 |         48 B |
|  EscapeUri | old       |     10 | OneRe(...)erved [25] |           179.05 ns |  1.00 |        312 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |     10 |          Alternating |           192.87 ns |  0.73 |        120 B |
| EscapeData | old       |     10 |          Alternating |           262.74 ns |  1.00 |        392 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |     10 |          Alternating |           189.67 ns |  0.65 |        120 B |
|  EscapeUri | old       |     10 |          Alternating |           289.09 ns |  1.00 |        392 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |    100 |           Unreserved |            83.99 ns |  0.13 |            - |
| EscapeData | old       |    100 |           Unreserved |           660.66 ns |  1.00 |            - |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |    100 |           Unreserved |            83.69 ns |  0.09 |            - |
|  EscapeUri | old       |    100 |           Unreserved |           943.46 ns |  1.00 |            - |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |    100 |              Unicode |         3,015.49 ns |  0.96 |       2424 B |
| EscapeData | old       |    100 |              Unicode |         3,150.40 ns |  1.00 |      12144 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |    100 |              Unicode |         3,004.75 ns |  0.90 |       2424 B |
|  EscapeUri | old       |    100 |              Unicode |         3,334.80 ns |  1.00 |      12144 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |    100 | OneRe(...)erved [25] |           997.48 ns |  0.96 |        232 B |
| EscapeData | old       |    100 | OneRe(...)erved [25] |         1,034.85 ns |  1.00 |        496 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |    100 | OneRe(...)erved [25] |         1,009.19 ns |  0.89 |        232 B |
|  EscapeUri | old       |    100 | OneRe(...)erved [25] |         1,126.74 ns |  1.00 |        496 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       |    100 |          Alternating |         1,705.95 ns |  0.72 |       1080 B |
| EscapeData | old       |    100 |          Alternating |         2,361.35 ns |  1.00 |       2536 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       |    100 |          Alternating |         1,690.50 ns |  0.63 |       1080 B |
|  EscapeUri | old       |    100 |          Alternating |         2,691.28 ns |  1.00 |       2536 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       | 100000 |           Unreserved |        66,052.21 ns |  0.09 |            - |
| EscapeData | old       | 100000 |           Unreserved |       710,216.92 ns |  1.00 |            - |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       | 100000 |           Unreserved |        66,393.07 ns |  0.08 |            - |
|  EscapeUri | old       | 100000 |           Unreserved |       874,426.80 ns |  1.00 |          1 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       | 100000 |              Unicode |     4,295,295.08 ns | 0.003 |    6594352 B |
| EscapeData | old       | 100000 |              Unicode | 1,490,528,971.72 ns | 1.000 | 6006095568 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       | 100000 |              Unicode |     4,214,907.36 ns | 0.003 |    6594359 B |
|  EscapeUri | old       | 100000 |              Unicode | 1,517,378,125.77 ns | 1.000 | 6006096360 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       | 100000 | OneRe(...)erved [25] |       939,019.21 ns |  0.94 |     200033 B |
| EscapeData | old       | 100000 | OneRe(...)erved [25] |       984,792.58 ns |  1.00 |     400328 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       | 100000 | OneRe(...)erved [25] |       966,883.99 ns |  0.89 |     200040 B |
|  EscapeUri | old       | 100000 | OneRe(...)erved [25] |     1,082,288.94 ns |  1.00 |     400331 B |
|            |           |        |                      |                     |       |              |
| EscapeData | new       | 100000 |          Alternating |     1,751,153.61 ns |  0.01 |    1066679 B |
| EscapeData | old       | 100000 |          Alternating |   146,994,750.75 ns |  1.00 |  615528622 B |
|            |           |        |                      |                     |       |              |
|  EscapeUri | new       | 100000 |          Alternating |     1,735,597.85 ns |  0.01 |    1066676 B |
|  EscapeUri | old       | 100000 |          Alternating |   151,358,658.00 ns |  1.00 |  615528920 B |

```C#
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Running;
using System;
using System.Linq;
using System.Text;

[MemoryDiagnoser]
public class Program
{
    static void Main(string[] args) =&gt; BenchmarkSwitcher.FromTypes(new[] { typeof(Program) }).Run(args);

    [Params(10, 100, 100_000)]
    public int Length { get; set; }

    [Params(InputKind.Unreserved, InputKind.Unicode, InputKind.OneReservedThenUnreserved, InputKind.Alternating)]
    public InputKind Kind { get; set; }

    public enum InputKind
    {
        Unreserved, Unicode, OneReservedThenUnreserved, Alternating
    }

    [GlobalSetup]
    public void Setup()
    {
        switch (Kind)
        {
            case InputKind.Unreserved: _input = new string('s', Length); break;
            case InputKind.Unicode: _input = string.Concat(Enumerable.Repeat("\xD83D\xDE00", Length)); break;
            case InputKind.OneReservedThenUnreserved: _input = "&lt;" + new string('s', Length - 1); break;
            case InputKind.Alternating:
                var sb = new StringBuilder(Length);
                for (int i = 0; i &lt; Length; i++)
                {
                    switch (i % 3)
                    {
                        case 0: sb.Append('s'); break;
                        case 1: sb.Append('&lt;'); break;
                        default: sb.Append("\xD83D\xDE00"); break;
                    }
                }
                _input = sb.ToString();
                break;
        }
    }

    private string _input;

    [Benchmark] public string EscapeData() =&gt; Uri.EscapeDataString(_input);
    [Benchmark] public string EscapeUri() =&gt; Uri.EscapeUriString(_input);
}
```

cc: @davidsh, @GrabYourPitchforks, @alnikola 

@alnikola, I realize this conflicts with your PR.  Apologies.  But seeing your PR is what led me to want to do this.  I suggest we look at doing something similar to this PR for the "Unescape" paths as well.</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41771</IssueID>
    <RepoID>1</RepoID>
    <Title>Port perf changes and issues</Title>
    <Description>The "No Merge" label is there to ensure when this is merged,the individual commits are NOT squashed (one commit here per original commit in master).

Peformance and three bug fixes:
Fixes #40449
Fixes #40704 
Fixes #41425 

On performance:
•	Serialization is ~1.2x to ~1.5x faster than 3.0
•	Deserialization is ~1.2x faster than 3.0

Ports the following:

Issue | Type | 5.0 PR | 5.0 Commit | Description | Customer Impact | Risk
-- | -- | -- | -- | -- | -- | --
40449 | Bug | 40501 | 5dbbdfa | Change a NullReferenceException to   JsonException when invalid JSON is encountered in certain cases. | Reported by the community. Invalid   JSON can result in a NullReferenceException which is not expected and likely   not in any Try\Catch. | Low. The fix has been in master   for several weeks. Not likely to be “breaking” since changing from   NullReferenceException to another (valid) exception is not considered   breaking.
40704 | Bug | 40787 | 7829d4a | Non-ASCII dictionary key names and   object property names are always escaped. | Reported by the community.   Non-ASCII locales have additional JSON payload size and in general this is   not expected. | Low. The fix has been in master   for several weeks. Appropriate tests added.
  | Perf | 40889 | 27ddbe9 | Minor deserialization perf   improvements for collection by removing unnecessary allocations. | (perf) | Low. The fix has been in master   for several weeks.
  | Perf | 40998 | d3c6628 | Major perf deserialzation perf   gains primarily due to changes to property name lookup. | (perf) | Low. The fix has been in master   for several weeks. Appropriate tests added.
  | Perf | 41098 | 017a038 | Major serialization perf   improvements based on [AggressiveInlining] and enumerator changes. | (perf) | Low. The fix has been in master   for several weeks.
  | Perf | 41238 | 527595f | Medium perf gains on deserialize   and serialize using a variety of changes. | (perf) | Low. The fix has been in master   for two weeks. Appropriate tests added.
  | Perf | 41363 | 4cfc7ec | Minor perf gains with the   JsonCamelCaseNamingPolicy. This decreases warmup time but can help at runtime   when using the naming policy on Dictionaries. | (perf) | Low. The fix has been in master   for two weeks.
  | Perf | 41414 | 8655ef9 | Minor perf gains on   deserialization; includes some clean-up and addresses late comments from   previous PR. | (perf) | Low. Appropriate tests added.
41425 | Bug | 41653 | 4580a4d | A [JsonConverter] attribute when   applied to a collection property to specify a custom converter does not work   (does nothing). | Reported by the community. Having   a broken feature is confusing\not expected when encountered. Note there is a   work-around to add the converter at run-time (instead of an attribute). | Low. The fix is contained in a   single method and new tests added.

</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41770</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient connection refused on Debian</Title>
    <Description>Hi,

I'v copy pasted this code:

```
using System; using System.Net.Http; using System.Threading.Tasks; class Program { static void Main() { Task t = new Task(DownloadPageAsync); t.Start(); Console.WriteLine("Downloading page..."); Console.ReadLine(); } static async void DownloadPageAsync() {
        // ... Target page.
        string page = "http://en.wikipedia.org/";

        // ... Use HttpClient.
        using (HttpClient client = new HttpClient()) using (HttpResponseMessage response = await client.GetAsync(page)) using (HttpContent content = response.Content) {
            // ... Read the string.
            string result = await content.ReadAsStringAsync();

            // ... Display the result.
            if (result != null &amp;&amp; result.Length &gt;= 50) { Console.WriteLine(result.Substring(0, 50) + "..."); } } } }
```

from [here](https://www.dotnetperls.com/httpclient) and I'm getting error:

```
Unhandled exception. System.Net.Http.HttpRequestException: Connection refused
 ---&gt; System.Net.Sockets.SocketException (111): Connection refused
   at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port, CancellationToken cancellationToken)
   --- End of inner exception stack trace ---
   at System.Net.Http.ConnectHelper.ConnectAsync(String host, Int32 port, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean allowHttp2, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.GetHttpConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)
   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
   at test.httpclient.Program.DownloadPageAsync() in /home/myuser/scripts/dotnet/scraper/scraper/test.httpclient/Program.cs:line 21
   at test.httpclient.Program.Main() in /home/myuser/scripts/dotnet/scraper/scraper/test.httpclient/Program.cs:line 11
   at test.httpclient.Program.&lt;Main&gt;()
```

----------

Operating System: Debian GNU/Linux 9 (stretch)
Kernel: Linux 4.9.0-11-amd64
Architecture: x86-64

dotnet --version
3.0.100</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41769</IssueID>
    <RepoID>1</RepoID>
    <Title>Announcement: .NET Core 3.0 concludes the .NET Framework API porting project</Title>
    <Description>We started in .NET Core 1.0 with a very minimal API set that only included \~18K of the .NET Framework APIs. With [.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-0/), we tried to make it much more viable to share code between .NET Framework, .NET Core, and Xamarin which resulted in approximately 38K .NET Frameworks APIs being available in .NET Core 2.0. We also built the [Windows Compatibility Pack](https://devblogs.microsoft.com/dotnet/announcing-the-windows-compatibility-pack-for-net-core/) which made another 21K .NET Framework APIs available to .NET Core, resulting in almost 60K additional APIs. And in .NET Core 3.0 we added WPF and WinForms, which increased the number of .NET Framework APIs ported to .NET Core to over 120k, which is more than half of all .NET Framework APIs.

It’s also worth pointing out that we added about 62K APIs to .NET Core that don’t exist in .NET Framework. If we compare their total number of APIs, .NET Core has about 80% of the API surface of .NET Framework.

&lt;p align="center"&gt;
&lt;img src="https://user-images.githubusercontent.com/5169960/66777114-f8db7c80-ee7c-11e9-9161-acfe1c491586.png" width="600" align="center"&gt;
&lt;/p&gt;

We announced that the [future of .NET](https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/) will be based on .NET Core. And at Build 2019, [Scott Hunter stated](https://www.youtube.com/watch?v=ZlO1utbB2GQ&amp;t=54m20s) that AppDomains, remoting, Web Forms, WCF server, and Windows Workflow won’t be ported to .NET Core.

With .NET Core 3.0, we’re at the point where we’ve ported all technologies that are required for modern workloads, be that desktop apps, mobile apps, console apps, web sites, or cloud services. That’s not to say that we don’t have any gaps or opportunities for new technologies, but we generally believe we won’t be finding them in the .NET Framework code base anymore. Moving forward, we’re focusing our resources on incorporating new technologies.

Simultaneously, we’re looking into releasing more of the [.NET Framework code base under the MIT license](https://github.com/microsoft/referencesource) on GitHub to allow the community to create OSS projects for technologies we’re not intending to bring to .NET Core. For example, there already are community projects for [CoreWF](https://github.com/UiPath/corewf) and [CoreWCF](https://github.com/CoreWCF/CoreWCF).

We’d like to thank everyone who filed issues with requests for APIs being ported. Those issues allowed us to prioritize and close the gaps that prevented people from porting to .NET Core.

But since we generally no longer plan to bring existing technologies from .NET Framework to .NET Core we’ll be closing all issues that are [labeled with port-to-core](https://github.com/dotnet/corefx/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+label%3Aport-to-core).</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41768</IssueID>
    <RepoID>1</RepoID>
    <Title>use background thread to wait for address changes on OSX</Title>
    <Description>we should not block process exit. 

fixes #41740

</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41767</IssueID>
    <RepoID>1</RepoID>
    <Title>System.IO.FileSystem.MoveFile(...) Delete Source File When Overwrite is True</Title>
    <Description>Solves #41009. System.IO.FileSystem.MoveFile(...) did not remove the source file after copying the file to a different file system.

No tests added since it requires two filesystems, but it was tested locally on my own machine and it worked. No tests cover this branch since before, and therefore I assume that a test is not necessary. If you have suggestions for how it can be tested, feel free to point it out.</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41766</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.2] Add alpine 3.10 to testing matrix</Title>
    <Description>Related to https://github.com/dotnet/corefx/issues/41038

cc @leecow </Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41765</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.1] Add alpine 3.10 to testing matrix</Title>
    <Description>Related to https://github.com/dotnet/corefx/issues/41038

cc @leecow </Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41764</IssueID>
    <RepoID>1</RepoID>
    <Title>Return all local IPs on Linux</Title>
    <Description>As per discussion in the #32611, for local host name return also `getifaddrs` IPs and not just `getaddrinfo` ones.
The current fix has been benchmarked against the master.

Method | hostName | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated
-- | -- | -- | -- | -- | -- | -- | -- | -- | --
GetHostAddresses new | manicka-pc | 49,736.0 ns | 475.718 ns | 444.986 ns | 49,494.6 ns | 0.0610 | - | - | 432 B
GetHostAddresses old | manicka-pc | 7,567.3 ns | 147.82 ns | 145.18 ns | 7,572.7 ns | 0.0305 | - | - | 168 B

**The fixed version is ~40us slower.** This is an intentional performance regression in order to make the behavior more consistent across OSes.

Fixes #32611

### Complete numbers
#### Explanation
The original `GetHostAddresses` only called `getaddrinfo` which essentially either takes data from `etc/hosts` (`getaddrinfo` for microsoft.com) or does a DNS query (`getaddrinfo` for ibm.com). You can clearly see the performance difference in between those two (10us vs 100ms). For local host `getaddrinfo` usually returned only the single IP listed in `etc/hosts`, which was the main difference between Windows and Linux version (see original issue #32611). Yes, you can manually add more addresses to the file and they will be returned. I guess it can do a DNS query for local host name as well depending on the [nsswitch.conf](http://man7.org/linux/man-pages/man5/nsswitch.conf.5.html). Tough the proposed solution was to add the IP addresses of all network interfaces (via `getifaddrs`) if `GetHostAddresses` is called for the local host name. So the performance regression is premeditated and has been measured in the original issue. This can be seen on the line with `GetHostAddresses` for manicka-pc, the number there shows that the method, in that particular case, has slowed and the difference corresponds to the system call of `getiffaddrs` (3rd line from the top).

I also ran PerfCollect on the fixed version and did direct time measurement with `Stopwatch` on the master and fixed version and haven't found any obvious performance problems. Actually, the fixed version was a bit faster in the `ParseHostEntry`. Probably since it doesn't fetch and convert IP address one by one through interop, but rather get's them all at once.

#### The fix:

Method | hostName | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated
-- | -- | -- | -- | -- | -- | -- | -- | -- | --
GetHostName | ? | 515.0 ns | 3.339 ns | 2.788 ns | 514.2 ns | 0.0105 | - | - | 48 B
Adapters | ? | 426,529.4 ns | 1,572.995 ns | 1,471.381 ns | 426,984.1 ns | 41.5039 | - | - | 175856 B
getifaddrs | ? | 38,262.4 ns | 326.961 ns | 305.839 ns | 38,169.9 ns | 0.0610 | - | - | 384 B
GetHostAddresses | ibm.com | 160,548,952.9 ns | 40,232,817.945 ns | 113,477,376.838 ns | 133,815,611.3 ns | - | - | - | 72 B
getaddrinfo | ibm.com | 121,347,416.4 ns | 30,647,103.141 ns | 87,932,283.906 ns | 94,461,035.3 ns | - | - | - | 168 B
GetHostAddresses | manicka-pc | 49,736.0 ns | 475.718 ns | 444.986 ns | 49,494.6 ns | 0.0610 | - | - | 432 B
getaddrinfo | manicka-pc | 6,516.5 ns | 17.000 ns | 14.196 ns | 6,516.5 ns | 0.0381 | - | - | 168 B
GetHostAddresses | microsoft.com | 7,264.0 ns | 32.249 ns | 30.166 ns | 7,261.7 ns | 0.0153 | - | - | 72 B
getaddrinfo | microsoft.com | 6,689.2 ns | 30.766 ns | 24.020 ns | 6,688.9 ns | 0.0381 | - | - | 168 B

#### The master:

Method | hostName | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated
-- | -- | -- | -- | -- | -- | -- | -- | -- | --
GetHostName | ? | 558.0 ns | 10.93 ns | 13.42 ns | 551.7 ns | 0.0114 | - | - | 48 B
Adapters | ? | 471,709.3 ns | 9,209.42 ns | 14,063.76 ns | 467,884.4 ns | 41.5039 | - | - | 175688 B
getifaddrs | ? | 41,697.4 ns | 818.68 ns | 1,005.41 ns | 41,385.4 ns | 0.0610 | - | - | 384 B
GetHostAddresses | ibm.com | 31,173,248.4 ns | 2,757,460.81 ns | 7,264,254.71 ns | 30,084,315.6 ns | - | - | - | 168 B
getaddrinfo | ibm.com | 34,948,165.7 ns | 3,831,926.31 ns | 10,294,221.19 ns | 31,398,652.5 ns | - | - | - | 168 B
GetHostAddresses | manicka-pc | 7,567.3 ns | 147.82 ns | 145.18 ns | 7,572.7 ns | 0.0305 | - | - | 168 B
getaddrinfo | manicka-pc | 7,568.3 ns | 151.08 ns | 398.00 ns | 7,510.9 ns | 0.0381 | - | - | 168 B
GetHostAddresses | microsoft.com | 7,310.1 ns | 137.50 ns | 147.12 ns | 7,284.0 ns | 0.0381 | - | - | 168 B
getaddrinfo | microsoft.com | 7,024.3 ns | 139.63 ns | 155.20 ns | 7,011.7 ns | 0.0381 | - | - | 168 B
</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41763</IssueID>
    <RepoID>1</RepoID>
    <Title>Socket.Select: increase ref count while the handle is in use</Title>
    <Description>CC @stephentoub </Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41762</IssueID>
    <RepoID>1</RepoID>
    <Title>Finish BitArray performance optimizations using AVX from #39173</Title>
    <Description>@BruceForstall has done some great job optimizing `BitArray` in  https://github.com/dotnet/corefx/pull/39173 . The PR was closed because Bruce has currently no time to finish it.

A contributor who would like to work on this issue should:

* pick Bruce's work from https://github.com/dotnet/corefx/pull/39173
* finish the todo mentioned in this comment: https://github.com/dotnet/corefx/pull/39173#issuecomment-509328893
* run [these](https://github.com/dotnet/performance/blob/master/src/benchmarks/micro/corefx/System.Collections/Perf.BitArray.cs) micro benchmarks from the performance repo and provide updated results (before &amp; after)

The issue should be a great excercie for somebody who wants to learn more about vectorizing code using the new .NET Core 3.0 CPU [Intrinsics API](https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/)</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41761</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191014.5
- **Date Produced**: 10/15/2019 1:45 AM
- **Commit**: 0f71a90f41cfae2a9675bb37150d3a7d4e8b1423
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19514.5
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19514.5
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19514.5

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)



</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41760</IssueID>
    <RepoID>1</RepoID>
    <Title>Socket: consider handle exposed when user gets Socket.SafeHandle.</Title>
    <Description>CC @stephentoub </Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41759</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove UAP target</Title>
    <Description>cc @safern @danmosemsft</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>17/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41758</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json ignores JsonPropertyName on BaseClass</Title>
    <Description>I'm not sure if this is a bug or by design, but while moving from JSON.NET to System.Text.Json I discovered the following behavior: 

"JsonPropertyNames" are ignored on base classes.

```
    class Program
    {
        static void Main(string[] args)
        {
            RealClass test = new RealClass();

            // output will be "{"Link":"Foo"}" 
            // and not {"_LinkFromBaseClass":"Foo"}

            Console.WriteLine(JsonSerializer.Serialize(test));


            Console.WriteLine("Hello World!");
        }
    }

    public abstract class SomeBaseClass
    {
        [JsonPropertyName("_LinkFromBaseClass")]
        public virtual string Link { get;  }
    }

    public class RealClass : SomeBaseClass
    {
        public RealClass()
        {
        }

        public override string Link { get { return "Foo"; } }
    }
```

Is this "by design"? Currently we just put the "JsonPropertyName" attribute on all implementations for the baseclass, but it's quite easy to miss.
I also checked the JsonSerializerOptions, but didn't find anything useful, but maybe I miss something.</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41757</IssueID>
    <RepoID>1</RepoID>
    <Title>Invalid file path generated from valid file path string</Title>
    <Description>```
var expected = "C:\\PRN.json";
var path = Path.GetFullPath(expected);
Assert.AreEqual(expected, path);
```
```
Assert.AreEqual failed.
Expected:&lt;C:\PRN.json&gt;.
Actual:&lt;\\.\PRN&gt;.
```</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41756</IssueID>
    <RepoID>1</RepoID>
    <Title>BoundedChannel. Initial size of Deque </Title>
    <Description>```BoundedChannel``` uses ```Deque&lt;T&gt;``` as a buffer.
```Deque&lt;T&gt;``` represents an ring buffer that expands 2 times if necessary (and copies items).
It`s initial size is 0.
I suggest adding a parameter - the initial size of the queue, to prevent unnecessary costs at startup.


**Proposed API**

https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Threading/Channels/ChannelOptions.cs

```csharp
public abstract class BoundedChannelOptions
{
     public InitialBufferSize {get; set;} // check &gt;=0
     ....
}
```

https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Collections/Generic/Deque.cs

```csharp

internal sealed class Deque&lt;T&gt;
{
        public Deque(int initialBufferSize)
        {
              _array = initialBufferSize &gt; 0 ?new T[initialBufferSize] : Array.Empty&lt;T&gt;();
              //tail..
             //head..
        }
}


```

Related issues.
```RingBuffer&lt;T&gt;``` https://github.com/dotnet/corefx/issues/40489
```Deque&lt;T&gt;``` https://github.com/dotnet/corefx/issues/32790



**P.S.**
In the implementation of the queue, you can replace the whole array with chunks, use the pool.



</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41755</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider marking HandleProcessCorruptedStateExceptionsAttribute as obsolete/hidden</Title>
    <Description>[`System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute`](https://docs.microsoft.com/en-gb/dotnet/api/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute) is an attribute used to enable handling of corrupted state exception (e.g. `AccessViolationException`) from the managed code, introduced in .NET Framework 4.0. This allows the consumers to deal with `AccessViolationException`s with the `try-catch`/`try-finally` clause and either swallow or log the exception instead of `FailFast`ing. However, I personally have not seen legitimate use of the attribute but to work around crashes caused by flaky libraries or unsafe codes, and swallowing exceptions in such case can introduce a security risk.

[Furthermore, there was a decision to disable the handling mechanisms of corrupted state exceptions in .NET Core.](https://github.com/dotnet/coreclr/issues/9045#issuecomment-290159433)

&gt; Handling of corrupted state exceptions is set of low-level desktop features that tried to make it possible to write managed code for what would be best written in plain C. We have abandoned this direction and not included features from this set in .NET Core whenever we had opportunity to do so. Constrained Execution Regions (CERs) or stack overflow handling are other features in this set. None of them are in .NET Core, so we are differing in this area from desktop in general. Also, the different features in this set are tied together e.g. if you really want to write robust handler for corrupted exceptions, you would need CERs for that in desktop, so it does not make sense to pick and choose them in isolation. 

Given that this attribute does not work anymore on .NET Core &amp; it is inherently dangerous to use this attribute to handle such exceptions in the first place, I think the attribute should be obsoleted or hidden from the IDE to discourage the use of it. At the moment, it does not appear that this incompatibility is not so widely known (Searching on Bing/Google or looking at MS docs barely give any information about the state of the attribute on .NET Core). I believe that either of those options would effectively discourage the use of the type.</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41754</IssueID>
    <RepoID>1</RepoID>
    <Title>Add tests to verify that JSON deserializer doesn't do any multiplication or addition on the string length</Title>
    <Description>Fixes #41687

Unfortuntately, I'm unable to run these tests locally due to OutOfMemoryException.

cc @steveharter @ahsonkhan</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41753</IssueID>
    <RepoID>1</RepoID>
    <Title>Cache polymorphic properties</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41638.

When a polymorphic property (i.e. one whose type is `object`) is serialized, its `JsonPropertyInfo` is created every time, based on the runtime type of the property. This is a problem, because it means accessing the property will JIT compile the `Get` delegate every time, which takes a lot of time.

This PR changes that, by caching the `JsonPropertyInfo` for each encountered runtime type. This should be an okay thing to do, since most polymorphic properties should only use a small number of types.

One case where this could cause an issue is if doing this prevents the type from unloading. But, as far as I can tell, that is already a problem with System.Text.Json, and one that can be solved by switching the instance of `JsonSerializerOptions` that's used.

After [adding a benchmark for this case](https://github.com/svick/performance/commit/7ffcc2c) the results of comparing System.Text.Json.Serialization microbenchmarks show clear improvement (up to 68x) for the new benchmark and no real change for other benchmarks:

summary:
better: 17, geomean: 5.809
worse: 4, geomean: 1.041
total diff: 21

| Slower                                                                           | diff/base | Base Median (ns) | Diff Median (ns) | Modality|
| -------------------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Text.Json.Serialization.Tests.WriteJson\&lt;Location&gt;.SerializeToUtf8Bytes    |      1.05 |          1855.03 |          1944.15 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;MyEventsListerViewModel&gt;.Deseriali |      1.05 |       1310030.00 |       1370308.74 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;Hashtable&gt;.DeserializeFromString   |      1.04 |        163849.84 |        171039.26 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;IndexViewModel&gt;.DeserializeFromStr |      1.03 |        100573.41 |        103365.76 |         |

| Faster                                                                           | base/diff | Base Median (ns) | Diff Median (ns) | Modality|
| -------------------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|
| System.Text.Json.Serialization.Tests.WriteJson\&lt;HashSet\&lt;String&gt;&gt;.SerializeObjectP |     68.80 |       2275620.83 |         33077.25 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;ArrayList&gt;.SerializeObjectPropert |     52.81 |       2110367.71 |         39958.59 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;Dictionary\&lt;String, String&gt;&gt;.Seria |     45.75 |       2337101.79 |         51079.52 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;Hashtable&gt;.SerializeObjectPropert |     30.13 |       2100212.50 |         69707.29 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;ImmutableSortedDictionary\&lt;String, |     24.85 |       2287553.75 |         92056.69 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;ImmutableDictionary\&lt;String, Strin |     20.94 |       2423108.75 |        115724.54 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;LoginViewModel&gt;.SerializeObjectPr |     17.77 |         21066.59 |          1185.80 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;BinaryData&gt;.SerializeObjectProper |     12.87 |         21884.38 |          1700.18 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;Location&gt;.SerializeObjectProperty |      9.01 |         21679.90 |          2404.95 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;IndexViewModel&gt;.SerializeObjectPr |      1.42 |         79311.34 |         56018.97 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;Location&gt;.SerializeToStream       |      1.04 |          2222.72 |          2127.47 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;ArrayList&gt;.DeserializeFromStream   |      1.04 |        116964.02 |        112564.32 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;ImmutableSortedDictionary\&lt;String,  |      1.04 |        374212.71 |        360219.74 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;HashSet\&lt;String&gt;&gt;.SerializeToStrea |      1.04 |         26759.54 |         25804.20 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;MyEventsListerViewModel&gt;.Serializ |      1.04 |       1186575.00 |       1144969.42 |         |
| System.Text.Json.Serialization.Tests.ReadJson\&lt;Location&gt;.DeserializeFromStream    |      1.03 |          3750.12 |          3632.62 |         |
| System.Text.Json.Serialization.Tests.WriteJson\&lt;MyEventsListerViewModel&gt;.Serializ |      1.03 |       1191000.89 |       1159996.21 |         |</Description>
    <CreatedDate>13/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41751</IssueID>
    <RepoID>1</RepoID>
    <Title>LINQ IndexOf extension method</Title>
    <Description>I keep finding myself writing an `IndexOf` LINQ expression for `IEnumerable&lt;T&gt;` that is predicate based to find the index of the first item in a collection that satisfy a criteria

Currently, this could be achieved using ⏬ combo which is not ideal and not very readable at first glance:
``` C#
source
   .Select((item, index) =&gt; new { item, index })
   .FirstOrDefault(x =&gt; predicate(x.item))?.index ?? -1;
```
Let's add new LINQ extensions for this purpose that work exactly like `First` except it returns the index.

A reference implementation:

``` C#
public static int IndexOf&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)
{
   int i = 0;
   foreach (var item in source)
   {
      if (predicate(item))
         return i;
      i++;
   }
   return -1;
}

public static int IndexOf&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate, int start)
{
    var index = source.Skip(start).IndexOf(predicate);
    return index == -1 ? -1 : index + start;
}
```

Related to https://github.com/dotnet/corefx/issues/39689 and https://github.com/dotnet/corefx/issues/25459
</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41750</IssueID>
    <RepoID>1</RepoID>
    <Title>Add runtime id for Arch Linux</Title>
    <Description>Like gentoo, Arch Linux is a rolling release and doesn't have explicit version numbers.

```
$ docker run -it archlinux/base cat /etc/os-release
NAME="Arch Linux"
PRETTY_NAME="Arch Linux"
ID=arch
BUILD_ID=rolling
ANSI_COLOR="0;36"
HOME_URL="https://www.archlinux.org/"
DOCUMENTATION_URL="https://wiki.archlinux.org/"
SUPPORT_URL="https://bbs.archlinux.org/"
BUG_REPORT_URL="https://bugs.archlinux.org/"
LOGO=archlinux
```

cc @alucryd</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41749</IssueID>
    <RepoID>1</RepoID>
    <Title>Test ci</Title>
    <Description>
    </Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41748</IssueID>
    <RepoID>1</RepoID>
    <Title>dotnet 3.1 Release date</Title>
    <Description>Some questions:

1. When is due 3.1? I can read "Scheduled for November 2019" here:
   - https://github.com/dotnet/core/blob/master/roadmap.md
   - https://dotnet.microsoft.com/platform/support/policy/dotnet-core

  But I can see here:
   - https://github.com/aspnet/AspNetCore/milestone/64
  "_3.1.0-preview3 Due by December 03, 2019_"

 2. Will System.Text.Json support no default parameter-less constructors in 3.1?

 3. Is there any 3.1 preview package now?</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41747</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json.JsonSerializer exception for derived objects</Title>
    <Description>I don't know if this is an issue or it is the behavior by design. However Newtonsoft.Json works well in described example below.
New JsonSerializer throws an exception (The JSON property name for '{propertyName}' collides with another property.) in both if deserializes json to object as well as serializes object to json.
Example:
    class Program
    {
        static void Main(string[] args)
        {
            var obj1 = System.Text.Json.JsonSerializer.Deserialize&lt;Bar&gt;("{ \"Value\": 1.23 }"); // throws an exception

            var obj2 = new Bar { Value = 1.23, };
            var text = System.Text.Json.JsonSerializer.Serialize(obj2); // throws an exception as well
        }
    }

    public class Foo
    {
        public int Value { get; set; }
    }

    public class Bar : Foo
    {
        public new double Value { get; set; }
    }
</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>12/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41746</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Make WebRequest.GetSystemWebProxy() return a working proxy (#41692)</Title>
    <Description>Port #41692 to release/3.0

## Description

Libraries like the Azure AMQP lib are using WebRequest.DefaultWebProxy with ClientWebSocket as a way to set the default web proxy.  This works with .NET Framework because ClientWebSocket under the covers on netfx establishes its connection with WebRequest, but on .NET Core it uses different mechanisms.  In fact, with netstandard2.0 APIs, there is no way to specify that ClientWebSocket should use the default proxy.  This breaks such libraries in environments such as those in enterprises where proxies are common and configured implicitly for everyone on the network.

In .NET Core 3.0 we added HttpClient.DefaultProxy, which implements IWebProxy and serves as a full cross-platform implementation for the default proxy.  The change is to make WebRequest.DefaultWebProxy return it, rather than just returning a dummy singleton used only for its reference identity.

## Customer Impact

Libraries like the Azure AMQP library don't work in enterprise environments, or any environments where default proxies are needed.

## Regression?

Yes, from .NET Framework.

## Testing

All existing tests, plus a new test.

## Risk

Our automated testing around proxies isn't great; this change, however, isn't changing any logic to do with actual proxy resolution or discovery, just using the same class in more places.  This change also stops throwing a NotSupportedException on some platforms that was previously thrown, though it's unlikely someone took a real dependency on that.

cc: @Petermarcu </Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41745</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191012.2
- **Date Produced**: 10/13/2019 1:01 AM
- **Commit**: fd0ca99c4214538de6f821db6a38c9b6aca5ee62
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19512.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19512.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19512.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)



</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41744</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191015.2
- **Date Produced**: 10/16/2019 5:29 AM
- **Commit**: cbfa29d4e859622ada3d226f90f103f659665d31
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19515.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19515.2
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19515.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)





[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191015.17
- **Date Produced**: 10/16/2019 6:28 AM
- **Commit**: 0ceceab994c8e965bf50b11fc230dc2ea67aa1ec
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19515.17
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19515.17
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19515.17

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)





[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191015.14
- **Date Produced**: 10/16/2019 5:58 AM
- **Commit**: b50bd0a1d3f0326fc717706cb5c5950ab41cf437
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19515.14
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19515.14

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)





[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191015.1
- **Date Produced**: 10/15/2019 12:50 PM
- **Commit**: 0f9ebb0caff93e8f274b8c14785554a41922dad2
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19515.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)





















</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41743</IssueID>
    <RepoID>1</RepoID>
    <Title>Could ConfigurationProviders load their data in parallel on start-up?</Title>
    <Description>I’m using both Azure KeyVault and Azure App Configuraton as ConfigurationProviders in a .NET Core 3 web application, also when I’m debugging. For me KeyVault adds about 5 seconds extra during launch, and App Configuration about 1 second. And this adds up to 6 seconds extra delay.

But couldn’t these providers load their data in parallel? It looks to me like they are running in serial, which make me loose one second every time I start to debug. </Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41742</IssueID>
    <RepoID>1</RepoID>
    <Title>Update Area Owners for System.Data.SqlClient</Title>
    <Description>
    </Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>12/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41741</IssueID>
    <RepoID>1</RepoID>
    <Title>Reduce RemoteInvoke usage in tests</Title>
    <Description>Many of our RemoteInvokes are there purely because of needing to change the current thread culture but on UAP that actually impacting the whole process.  Until that's addressed, we can at least avoid the RemoteInvoke on all platforms other than UAP. There are also some RemoteInvokes that can be avoided by just serializing all of the (small number of) tests in a test assembly. And there's some additional cleanup to be done as well around not explicitly returning an exit code unless required.

This reduction helps measurably with test performance.  Consider the System.ComponentModel.Annotations test suite.  On my machine, prior to these changes, it took ~25 seconds; after these changes, it takes ~0.3. It helps even more when running against a checked runtime, where all of our test costs are magnified.  With a checked runtime, prior to these changes, it takes ~196 seconds; after these changes, it takes ~2.5 seconds.  This should help measurably with CI time in coreclr.

I recommend reviewing with whitespace disabled:
https://github.com/dotnet/corefx/pull/41741/files?w=1

cc: @ViktorHofer, @jkotas (@jaredpar, just FYI)
Closes https://github.com/dotnet/corefx/issues/40773</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41740</IssueID>
    <RepoID>1</RepoID>
    <Title>NetworkAddressChanged event hangs process on Mac</Title>
    <Description># Repro steps

1. Install 3.0 RTM
2. `dotnet new console`
3. Replace Program.cs with the following:

```C#
using System;

namespace MacMinimal
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            System.Net.NetworkInformation.NetworkChange.NetworkAddressChanged += (sender, e) =&gt; {
                
            };
        }
    }
}
```

# Expected Result

The process should exit.

# Actual Result

The process does not exit.

# Details

Thread dumps indicate that this line is the problem:

https://github.com/dotnet/corefx/blob/d3911035f2ba3eb5c44310342cc1d654e42aa316/src/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkAddressChange.OSX.cs#L184

We believe that this Thread should be marked as background so it doesn't block the process exiting.

## Real world cases

We found this when we noticed that applications which use AppInsights don't close when they would normally exit on a Mac. This isn't noticed normally because the normal workflow for AspNetCore apps is that when you want the server to exit you send Ctrl-C.

CC @danmosemsft @karelz @davidfowl </Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41738</IssueID>
    <RepoID>1</RepoID>
    <Title>[Linux] X.509 chain building:  EndCertificateOnly does not work when end entity is covered only by OCSP</Title>
    <Description>Found while investigating https://github.com/dotnet/corefx/issues/41475.

CC @bartonjs</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41737</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @EgorBo</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41736</IssueID>
    <RepoID>1</RepoID>
    <Title>Regenerating the System.Runtime.Intrinsics.Experimental ref assembly</Title>
    <Description>CoreFX side changes to https://github.com/dotnet/coreclr/pull/25508</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>12/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41735</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191010.2
- **Date Produced**: 10/10/2019 3:56 PM
- **Commit**: 54dcbe32cfe5db393e1e6cc6a52593e98e96e94a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19510.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19510.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19510.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191010.15
- **Date Produced**: 10/11/2019 6:45 AM
- **Commit**: 901c370c2379ad0885bcc5a1921c4164104586aa
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19510.15
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19510.15

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191010.2
- **Date Produced**: 10/10/2019 12:49 PM
- **Commit**: 9e457715f9487ece662586f5784051455d3da20c
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19510.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41734</IssueID>
    <RepoID>1</RepoID>
    <Title>System.IO.Directory.Move fails between two mounts on Linux</Title>
    <Description>On Linux/netcore3 `System.IO.Directory.Move` throws `System.IO.IOException: Invalid cross-device link` when trying to move a folder between two mounts/disks in Linux.

`System.IO.Directory.Move("/tmp/foo","/tmp/baz"); //works` 
`System.IO.Directory.Move("/mnt/notsamedisk/foo","/tmp/baz"); //throws`
```
Unhandled exception. System.IO.IOException: Invalid cross-device link
   at System.IO.FileSystem.MoveDirectory(String sourceFullPath, String destFullPath)
   at System.IO.Directory.Move(String sourceDirName, String destDirName)
   at tmp.Program.Main(String[] args) in /home/easysky/tmp/Program.cs:line 9
```

```csharp
using System;

namespace tmp
{
    class Program
    {
        static void Main(string[] args)
        {
            System.IO.Directory.Move("/datadrive/tmp/foo","/tmp/foo");
        }
    }
}
```
 
uname -a `
Linux Test 5.0.0-1018-azure #19~18.04.1-Ubuntu SMP Wed Aug 21 05:13:05 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux`

```
dotnet --version
3.0.100
```
</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41733</IssueID>
    <RepoID>1</RepoID>
    <Title>Uri.ToString() replacing %20 for spaces generates a non-compliant uri-reference</Title>
    <Description>I have created a new Uri to use in [OpenApiOAuthFlows](https://github.com/microsoft/OpenAPI.NET/blob/master/src/Microsoft.OpenApi/Models/OpenApiOAuthFlow.cs) which contains query parameters with %20 instead of spaces.

OpenApiOAuthFlows is used to generate a JSON file to comply with OpenAPI in Swagger but the %20 are replaced with spaces, which in the end create a Uri not compliant with [RCF3986](https://tools.ietf.org/html/rfc3986#appendix-B).

Here's an example:
`var authorizationUri = new Uri("https://token-host/connect/authorize?client_id=secure.platform&amp;response_type=id_token%20token&amp;scope=openid%20profile%20email");`

Using that Uri as the AuthorizationUrl for a new OpenApiOAuthFlow when the JSON is generated it shows
`"authorizationUrl": "https://token-host/connect/authorize?client_id=secure.platform&amp;response_type=id_token token&amp;scope=openid profile email"`

I was going to suggest to have a parameter in ToString to chose whether to keep the encoded values or not but maybe is better to have a property in Uri to specify whether to replace them or not.

Also I have not tested this issue with other characters but I am sure it can raise futher compliance errors.</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41732</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpUtility.ParseQueryString doesn't roundtrip when there are keys that only differ by case</Title>
    <Description>Using .NET Core 3.0, `HttpUtility.ParseQueryString` doesn't rountrip when there are keys in the query string that only differ by case.

```f#
let input = "type=foo&amp;TYPE=bar"
let values = System.Web.HttpUtility.ParseQueryString(input)
let output = values.ToString()
Assert.Equal(input, output)  // not equal; is "type=foo&amp;type=bar"
```

AFAIK [query strings are case sensitive](https://stackoverflow.com/a/24700171/2978652).

Possibly related: https://github.com/dotnet/corefx/issues/32575</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41731</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixing NullReferenceException in XmlSchemaAnyAttribute.Namespace</Title>
    <Description>Fix for issue #41704 with test,</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41730</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191010.1
- **Date Produced**: 10/10/2019 12:54 PM
- **Commit**: 6b13065e7ac88671795a01577e017ff7cdc26f35
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19510.1
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19510.1
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19510.1

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41729</IssueID>
    <RepoID>1</RepoID>
    <Title>Quick Start Guide for New Contributors Guide</Title>
    <Description>The changes in #41555 are great since the wiki was really outdated and lacking. However, as I quite recently was a new contributor I would like to see some short and concise _Quick Start Guide_ or similar since that would be really helpful for me when I was new here. When first looking into this project it may seem very overwhelming to make your first contribution, and a simple quick start guide could be good to get the new contributors on track faster. 

Of course, they need to read some of the more elaborate documents to make contributions, but the _Quick Start Guide_ could serve as a simple introduction to get the contributors up and running and familiar with the most basic parts of developing for this project. I could try to make a first draft for this _Quick Start Guide_ if it's deemed appropriate to add to this project.</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41739</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Reflection.RuntimeAssembly not serializable</Title>
    <Description># Computing a hash of the calling assembly

I would compute the hash of the calling assembly, similar to the way it can be done in .NET Framework using the code below:

```
var assembly = Assembly.GetCallingAssembly();

var hash = new Hash(assembly);

var hashVal = hash.GenerateHash(new SHA512Managed());
```

Since this does not seem to be possible in .NET Core, I have tried to use the Binary Formatter to serialize the object returned from `Assembly.GetCallingAssembly()`, using the code below:

```
var assembly = Assembly.GetCallingAssembly();

BinaryFormatter formatter = new BinaryFormatter();
MemoryStream stream = new MemoryStream();

formatter.Serialize(stream, assembly);

SHA512 sha = SHA512.Create();

var hash = Convert.ToBase64String(sha.ComputeHash(stream));
```

This gives me the error:
```
System.Reflection.RuntimeAssembly' in Assembly 'System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e' is not marked as serializable.'
```

## Question

Is there a best practise of how the hash of the calling assembly can be computed or is there any plan of making the `System.Reflection.RuntimeAssembly` serializable?
</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>13/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41728</IssueID>
    <RepoID>1</RepoID>
    <Title>StackOverflowException not happening in Release</Title>
    <Description>Hi,

by mistake we have created a recursive call with endless loop and in `Debug` this flow throws after few seconds SOE, but when running in `Release`, the recursive call loop never ends. I do not think that this is by design?

Repository:
https://github.com/ppekrol/ravendb/tree/RavenDB-13682-hang

Test: `SlowTests.MailingList.Nberardi.Spatial_Search_Should_Integrate_Distance_As_A_Boost_Factor`

Problematic code:
a) Test: https://github.com/ppekrol/ravendb/blob/RavenDB-13682-hang/test/SlowTests/MailingList/nberardi.cs#L53-L56
b) Endless recursive call: https://github.com/ppekrol/ravendb/blob/RavenDB-13682-hang/src/Raven.Client/Documents/Session/AbstractDocumentQuery.Spatial.cs#L119

Behavior:
a) Debug - 2 events in Event Log:

```
Faulting application name: dotnet.exe, version: 3.0.19.46305, time stamp: 0x5d7bb03a
Faulting module name: unknown, version: 0.0.0.0, time stamp: 0x00000000
Exception code: 0xc00000fd
Fault offset: 0x00007ff975cd7b37
Faulting process id: 0x4f08
Faulting application start time: 0x01d5801a96c749d9
Faulting application path: C:\Program Files\dotnet\dotnet.exe
Faulting module path: unknown
Report Id: a889719a-f600-47e2-8b2c-e672209e8aae
Faulting package full name: 
Faulting package-relative application ID: 
```

```
Fault bucket 1888251967040835289, type 5
Event Name: CLR20r3
Response: Not available
Cab Id: 0

Problem signature:
P1: C:\Program Files\dotnet\dotnet.exe
P2: 3.0.19.46305
P3: 5d7bb03a
P4: Raven.Client
P5: 4.2.4.42
P6: e5db14ba
P7: 968
P8: 1
P9: System.StackOverflowException
P10: 

Attached files:
\\?\C:\ProgramData\Microsoft\Windows\WER\Temp\WERBD3.tmp.mdmp
\\?\C:\ProgramData\Microsoft\Windows\WER\Temp\WER7924.tmp.WERInternalMetadata.xml
\\?\C:\ProgramData\Microsoft\Windows\WER\Temp\WER7964.tmp.xml
\\?\C:\ProgramData\Microsoft\Windows\WER\Temp\WER7962.tmp.csv
\\?\C:\ProgramData\Microsoft\Windows\WER\Temp\WER79C1.tmp.txt

These files may be available here:
\\?\C:\ProgramData\Microsoft\Windows\WER\ReportArchive\AppCrash_C__Program Files_209ac05da5c7fd849f852450409f7c9ca02224f7_58b55f8a_3959cacf-4593-4163-9568-1abdc1197665

Analysis symbol: 
Rechecking for solution: 0
Report Id: a889719a-f600-47e2-8b2c-e672209e8aae
Report Status: 268435456
Hashed bucket: 2604fd66b8114d5fba346b28dde6ced9
Cab Guid: 0
```

b) Release (running this via VS2019 Test Runner) - test still runs after 10min

My environment:
a) Windows 10 x64 Pro
b) .NET Core 2.2.7
</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41727</IssueID>
    <RepoID>1</RepoID>
    <Title>binderEquivalenceCache prevents unloading assembly</Title>
    <Description>I am stuck on unloading an assembly because BinderEquivalence.cs caches ICSharpBinder which references that assembly's types.

This is the pinned handle: 
```
HandleTable:
    000001F88CBC15C0 (pinned handle)
    -&gt; 000001F89EA2C580 System.Object[]
    -&gt; 000001F88F2D8F88 System.Collections.Concurrent.ConcurrentDictionary`2[[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp],[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp]]
    -&gt; 000001F88F2D9140 System.Collections.Concurrent.ConcurrentDictionary`2+Tables[[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp],[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp]]
    -&gt; 000001F88F2D9028 System.Collections.Concurrent.ConcurrentDictionary`2+Node[[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp],[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp]][]
    -&gt; 000001F88F2D9168 System.Collections.Concurrent.ConcurrentDictionary`2+Node[[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp],[Microsoft.CSharp.RuntimeBinder.ICSharpBinder, Microsoft.CSharp]]
    -&gt; 000001F88F2D0B38 Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder
    -&gt; 000001F88F1301D8 System.RuntimeType
    -&gt; 000001F88F12B398 System.Reflection.LoaderAllocator
```
This is the offending source code line:
```
private static readonly ConcurrentDictionary&lt;ICSharpBinder, ICSharpBinder&gt; binderEquivalenceCache =
            new ConcurrentDictionary&lt;ICSharpBinder, ICSharpBinder&gt;(concurrencyLevel: 2, capacity: 32, new BinderEqualityComparer()); 
```

It should be cleared before assembly unload or give us the ability to do so manually.

Edit: after further investigation it seems that a bunch of other stuff is kept as well. Mostly statics from namespace Microsoft.CSharp.RuntimeBinder.Semantics. I haven't gone much further yet. We use **dynamic** type in the unloadable assembly.

Edit2: This is the code that fixes it, however, the next dynamic type usage crashes with null value.
 ```
Assembly ass = ...;
var type1 = ass.GetType("Microsoft.CSharp.RuntimeBinder.BinderEquivalence");
if (type1 != null) {
    var cache_field = type1.GetField("binderEquivalenceCache", BindingFlags.NonPublic | BindingFlags.Static);
    var cache = cache_field.GetValue(null);
    var clear_method = cache.GetType().GetMethod("Clear");
    clear_method.Invoke(cache, null);
}
var type2 = ass.GetType("Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMembers");
if (type2 != null) {
    var field1 = type2.GetField("_methods", BindingFlags.NonPublic | BindingFlags.Static);
    var arr1 = field1.GetValue(null) as Array;
    var len1 = arr1.Length;
    for (int i = 0; i &lt; len1; ++i) {
        arr1.SetValue(null, i);
    }

    var field2 = type2.GetField("_properties", BindingFlags.NonPublic | BindingFlags.Static);
    var arr2 = field2.GetValue(null) as Array;
    var len2 = arr2.Length;
    for (int i = 0; i &lt; len2; ++i) {
        arr2.SetValue(null, i);
    }
}
var type3 = ass.GetType("Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceSymbol");
if (type3 != null) {
    var field = type3.GetField("Root", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
    var root = field.GetValue(null);
    var fields = new List&lt;FieldInfo&gt;();
    ObjectUtil.GetFieldsForType(root.GetType(), fields);
    foreach (var f in fields) {
        if (f.Name == "firstChild" || f.Name == "_lastChild" ||
            f.Name == "nextChild" || f.Name == "nextSameName") {
            f.SetValue(root, null);
        }
    }
}
var type4 = ass.GetType("Microsoft.CSharp.RuntimeBinder.Semantics.SymbolStore");
if (type4 != null) {
    var field = type4.GetField("s_dictionary", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
    var dict = field.GetValue(null);
    var clear_method = dict.GetType().GetMethod("Clear");
    clear_method.Invoke(dict, null);
}
var type5 = ass.GetType("Microsoft.CSharp.RuntimeBinder.Semantics.TypeArray");
if (type5 != null) {
    var field = type5.GetField("s_tableTypeArrays", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
    var dict = field.GetValue(null);
    var clear_method = dict.GetType().GetMethod("Clear");
    clear_method.Invoke(dict, null);
}
var type6 = ass.GetType("Microsoft.CSharp.RuntimeBinder.Semantics.TypeTable");
if (type6 != null) {
    var fields = type6.GetFields(BindingFlags.Static | BindingFlags.NonPublic);
    foreach (var field in fields) {
        var dict = field.GetValue(null);
        var clear_method = dict.GetType().GetMethod("Clear");
        clear_method.Invoke(dict, null);
    }
}
```</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41726</IssueID>
    <RepoID>1</RepoID>
    <Title>update DualModeConnect_BeginAccept_Helper to be more liberal and consistent with DualModeConnect_AcceptAsync_Helper</Title>
    <Description>We have seen BeginAcceptV4BoundToAnyV6_Success and DualModeBeginAccept.BeginAcceptV4BoundToAnyV4_Success failing occasionally in CI with:

```
18:18:24       Assert.Equal() Failure
18:18:24       Expected: ::ffff:127.0.0.1
18:18:24       Actual:   ::127.0.0.1
```

I could not reproduce it on my system. However when looking at the tests, I notices that when connecting on v4 loopback ( like two tests above), there is also ready code to accept variations from ValidIPv6Loopbacks: 


https://github.com/dotnet/corefx/blob/901c370c2379ad0885bcc5a1921c4164104586aa/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs#L856-L864

and 

```c# 
       protected static IPAddress[] ValidIPv6Loopbacks = new IPAddress[] {
            new IPAddress(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 1 }, 0),  // ::127.0.0.1
            IPAddress.Loopback.MapToIPv6(),                                                     // ::ffff:127.0.0.1
            IPAddress.IPv6Loopback                                                              // ::1
        };
```

But it seems like the 864 line is there extra by mistake, invalidating previous statement. I also look at DualModeConnect_AcceptAsync_Helper and it validates result same way as we will now with this change.

fixes #6681
fixes #41685
</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41725</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @tannergooding</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41724</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191010.7
- **Date Produced**: 10/10/2019 9:48 PM
- **Commit**: e38f3722a98ea66b805f388cd613ac587a44d7d2
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview2.19510.7
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview2.19510.7
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview2.19510.7

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41723</IssueID>
    <RepoID>1</RepoID>
    <Title>Bumping the assembly version to 5.0.0.0</Title>
    <Description>
    </Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41722</IssueID>
    <RepoID>1</RepoID>
    <Title>UWP: System.Reflection.MissingRuntimeArtifactException caused by Encoding.GetString(Byte*,Int32) reflection.</Title>
    <Description>Microsoft AppCenter is trying to use System.Reflection.Metadata v1.7.0.

We are trying to extract some information about the native image from a stack trace frame for our crash reporting tool for apps compiled in .NET Native but not distributed in Windows Store.

One part of the code is using `System.Reflection.PortableExecutable.PEReader` and in particular the `ReadCodeViewDebugDirectoryData` that at some point calls `Encoding.GetString(System.Byte*, System.Int32)` via reflection: https://github.com/dotnet/corefx/blob/d3911035f2ba3eb5c44310342cc1d654e42aa316/src/System.Reflection.Metadata/src/System/Reflection/Internal/Utilities/EncodingHelper.cs#L122-L123

When .NET native is enabled on a release x86 app build, we get:

```
System.Reflection.MissingRuntimeArtifactException
  HResult=0x8013151A
  Message=Object_NotInvokable, System.Text.Encoding.GetString(System.Byte*,System.Int32)
  Source=&lt;Cannot evaluate the exception source&gt;
  StackTrace:
&lt;Cannot evaluate the exception stack trace&gt;
```

We tried adding various rules in the `Default.rd.xml` of our test application but without luck so far.

I isolated the problem here to reproduce the problem with an app that builds very fast because very small: https://github.com/guperrot/uwp-rd-test/blob/master/UwpRdTest/App.xaml.cs#L37

And the rules: https://github.com/guperrot/uwp-rd-test/blob/master/UwpRdTest/Properties/Default.rd.xml we tried a lot of combinations of Type, Assembly, Namespace etc... but we are unable to find the rule that would solve this reflection issue.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41721</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpStress: Add scripts for loading the corefx testhost in the environment</Title>
    <Description>Adds a pair of bash &amp; powershell scripts intended for loading the `testhost` sdk in the current environment. Effectively it can be used to run httpstress against the current corefx in three commands:
```powershell
# Build corefx from source
PS&gt; .\build.sh -c Release
# Load the testhost sdk in the current environment, must match build configuration
PS&gt; . .\src\System.Net.Http\tests\StressTests\HttpStress\load-corefx-testhost.ps1 -c Release
# run the stress suite with the new bits
PS&gt; cd .\src\System.Net.Http\tests\StressTests\HttpStress ; dotnet run -r win10-x64 
```
Equivalently using bash
```bash
# Build corefx from source
$ ./build.sh -c Release
# Load the testhost sdk in the current environment, must match build configuration
$ source src/System.Net.Http/tests/StressTests/HttpStress/load-corefx-testhost.sh -c Release
# run the stress suite with the new bits
$ cd src/System.Net.Http/tests/StressTests/HttpStress &amp;&amp; dotnet run -r linux-x64 
```

The powershell script has been tested with powershell core on linux and the bash script works with mingw on Windows. I've placed the scripts in the stress folder for now, but I think there's value in moving these more centrally in the repo.

Motivation is simplifying steps required for running HttpStress in CI.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41719</IssueID>
    <RepoID>1</RepoID>
    <Title>Ensure FileStatus' Unix exception throwing behavior matches Windows</Title>
    <Description>Initially reported by @davidfowl and discussed via email with @JeremyKuhne : we need to make sure Unix matches Windows when it comes to capturing and throwing exceptions.

David got this callstack when the Docker container got disconnected:

```
Unhandled exception. Unhandled exception. System.IO.IOException: Input/output error
   at System.IO.FileStatus.EnsureStatInitialized(ReadOnlySpan`1 path, Boolean continueOnError)
   at System.IO.FileStatus.GetLastWriteTime(ReadOnlySpan`1 path, Boolean continueOnError)
   at Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.GetLastWriteTimeUtc()
   at Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.get_HasChanged()
   at Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.RaiseChangeEvents(Object state)
   at System.Threading.TimerQueueTimer.CallCallback(Boolean isThreadPool)
   at System.Threading.TimerQueueTimer.Fire(Boolean isThreadPool)
   at System.Threading.TimerQueue.FireNextTimers()System.IO.IOException: Input/output error
   at System.IO.FileStatus.EnsureStatInitialized(ReadOnlySpan`1 path, Boolean continueOnError)
   at System.IO.FileStatus.GetLastWriteTime(ReadOnlySpan`1 path, Boolean continueOnError)
   at Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.GetLastWriteTimeUtc()
   at Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.get_HasChanged()
   at Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.RaiseChangeEvents(Object state)
   at System.Threading.TimerQueueTimer.CallCallback(Boolean isThreadPool)
   at System.Threading.TimerQueueTimer.Fire(Boolean isThreadPool)
   at System.Threading.ThreadPoolWorkQueue.Dispatch()

```</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41718</IssueID>
    <RepoID>1</RepoID>
    <Title>Re-enable NoCallback_RevokedCertificate_NoRevocationChecking_Succeeds</Title>
    <Description>The third-party server we use for this test, revoked.badssl.com, now has a new
certificate that is good for another two years and is also revoked. So, we can
re-enable this test.

Fixes #41108</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41717</IssueID>
    <RepoID>1</RepoID>
    <Title>update branding for preview2</Title>
    <Description>
    </Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41716</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix branch distance calculation</Title>
    <Description>Port  #26621 to master</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41715</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix branch distance calculation</Title>
    <Description>Port fix https://github.com/dotnet/corefx/pull/28493 of https://github.com/dotnet/corefx/issues/26621 from release/2.1 to release/3.1.

Fixes https://github.com/dotnet/corefx/issues/41710

The original fix was merged to release/2.1, but not to master at that time and did not flow to 3.0.
3.0 thus regressed because it didn't contain the fix. This change is bringing the fix back in 3.1.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41713</IssueID>
    <RepoID>1</RepoID>
    <Title>.NET standard needs a monotonic clock that only increases when the debugger is paused.</Title>
    <Description>Consider that you need to implement a timeout for some asynchronous thread running inside your .NET program.  You might choose to rely on [Environment.TickCount64](https://docs.microsoft.com/en-us/dotnet/api/system.environment.tickcount64?view=netcore-3.0) as a monotonic clock (to mark the passage of time).

Unfortunately, if you were to use a debugger to pause your program, you might discover that all of your timeouts had expired when the program was resumed.  Thus, you are prevented from debugging the "normal" behavior of your program.

It might be nice if there was perhaps an `Environment.DebuggerPausedTickCount64` property which increased monotonically, but only while the debugger had paused the program.  Thus a developer would be able to implement a special kind of monotonic clock using a trivial expression:

```cs
Environment.TickCount64 - Environment.DebuggerPausedTickCount64
```

The expression above would be a kind of monotonic clock that is robust against the usage of the debugger.  It would be useful for implementing timeouts for anything occurring asynchronously within the current process.  (Obviously anything running out of process is not stopped by the debugger so there are some cases where the clock would be inappropriate.)</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41712</IssueID>
    <RepoID>1</RepoID>
    <Title>Only pass the needed sub-struct in WriteUncompressedPublicKey.</Title>
    <Description>Just some general tidiness that was in a prototyping branch that seemed worth keeping.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41711</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json Datetimeoffset should support +0000 offset</Title>
    <Description>Currently only offset presented by `+00:00` is supported, but `+0000` or `+00` is also allowed in ISO standard so these should be supported as well. 

`+02:00`, `+0200`, `+02`

`
An offset of zero, in addition to having the special representation "Z", can also be stated numerically as "+00:00", "+0000", or "+00". 
`</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41710</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect branch distance calculation present in .NET core 3.0+</Title>
    <Description>Issue #26621 is still present in .NET core 3.0 onwards as the fix #28493 was not merged into the 3.0 source stream.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41709</IssueID>
    <RepoID>1</RepoID>
    <Title>Could not load file or assembly 'System.IO.Ports, Version 4.0.1.0, Culture...' after upgrade to System.IO.Ports 4.6.0.</Title>
    <Description>After upgrade my .NETStandard v2.0 projects to System.IO.Ports Nuget package 4.6.0. I'm having the next error: 

&gt; Could not load file or assembly 'System.IO.Ports, Version 4.0.1.0, Culture...'. The located assembly's manifest definition does not match the assembly reference.

The project's metadata shows references to `System.IO.Ports` version **4.0.1.0**, but the deployed version is **4.0.2.0**.

Analyzing the assemblies in the NuGet package, I can see the assembly in the `ref\netstandard2.0` folder has version **4.0.1.0** but the other assemblies (folder `lib\netstandard2.0, runtimes\osx\lib\netstandard2.0, runtimes\linux\lib\netstandard2.0, runtimes\win\lib\netstandard2.0`) has version **4.0.2.0**.
</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41708</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/corefx dotnet/standard dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191009.26
- **Date Produced**: 10/10/2019 3:16 AM
- **Commit**: 30280e07adc3c1f0776ef9531b47a769e2b45420
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19509.26
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19509.26

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191009.1
- **Date Produced**: 10/9/2019 12:35 PM
- **Commit**: 1e2d0bc743db548ffde0beaf732b4fdd1348bdba
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19509.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191010.4
- **Date Produced**: 10/10/2019 5:59 PM
- **Commit**: 8cd48078f550fbcbd4f684b897b14db207397b52
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19510.4
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19510.4
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19510.4

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41707</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Drawing.Common: Require at least libgdiplus 6.0.1 on macOS</Title>
    <Description>As discussed in #24525, make sure that a recent version of libgdiplus is installed on Unix.

- I chose 6.0.1. as the baseline:
  * It contains a couple of access violation fixes.
  * IIRC I could get all System.Drawing.Common tests to run on that version without the test process crashing. Lots of tests would still fail on Unix, though.
  * By the time .NET 5 is released, that version will be 1 year old, so hopefully Homebrew &amp; the Linux distros have picked it up
- A PNSE will be thrown from within the GdiplusNative constructor. That's early. On the other hand, System.Drawing.Common really isn't that useful if you don't have a stable version of libgdiplus.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41706</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonString node doesn't round-trip DateTimeOffset correctly</Title>
    <Description>in System.Text.Json serializing and deserializing datetimeoffset looses precision and most important part the offset part.

There is no different between datetime and datetimeoffset after serialization. In multi time environments it cases serious issues since all times are treated as UTC,

JsonString uses "s" format

```c#
 public JsonString(DateTimeOffset value) =&gt; Value = value.ToString("s", CultureInfo.InvariantCulture);
```

Which is not producing right value. It totally ignores offset.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41705</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191009.1
- **Date Produced**: 10/9/2019 1:01 PM
- **Commit**: 9e6f164a41cfe6af6a7de2765eb4a6cc695032cd
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19509.1
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19509.1
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19509.1

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41704</IssueID>
    <RepoID>1</RepoID>
    <Title>XmlSchemaAnyAttribute.Namespace throws NRE when not set before</Title>
    <Description>When I have "empty" instance of XmlSchemaAnyAttribute and access Namespace property, it throws NullReferenceException. This is caused by commit 2c22af8903522e54f71225c40ddd383b15632ae0 which now calls NamespaceList.ToString().

According to XML schema specification, namespace attribute is optional so it is valid to have it set to null. For example when I read XML schema with &lt;xs:anyAttribute/&gt;, .NET XML reader will create exactly the same instance - with null _ns field and also null NamespaceList. Later when I try to access the field, I get NRE. I get it also when I try to save schema back to serialized form. This time the exception is thrown from serialization due to optimization - the line of code in XmlSchemaAnyAttribute is not visible in exception stack trace.

How to reproduce:
var x = new XmlSchemaAnyAttribute().Namespace;</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41703</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191009.5
- **Date Produced**: 10/9/2019 10:22 PM
- **Commit**: 1acb4c3ce4c6497388752adad31825ae7cdb7e2a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19509.5
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19509.5
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19509.5

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41702</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient .NET Core 2.1/3.0 Different behaviour to Fullframework when uploading files using Windows Authentication (NTLM): An existing connection was forcibly closed by the remote host</Title>
    <Description>We try to upload a file to a windows hosted web server. 
Using the Fullframework everything works fine. 
We use the follwing code:

```
using (var httpClient = new HttpClient(new HttpClientHandler {UseDefaultCredentials = true}) {BaseAddress = new Uri($"{Host}/rest-ws/service/")})
{
    var requestUri = $"dms/{itemId}/content?filename={fileName}.{fileExtension}";

    var requestContent = new MultipartFormDataContent();

    var byteArrayContent = new ByteArrayContent(fileData);
    byteArrayContent.Headers.ContentType = MediaTypeHeaderValue.Parse("text/plain");
    requestContent.Add(byteArrayContent, fileName, "{fileName}.{fileExtension}");

    var responseMessage = await httpClient.PostAsync(requestUri, requestContent);
}
```

When we use the exact code in .NET Core we receive an error.

&gt; System.Net.Http.HttpRequestException
&gt;   HResult=0x80131620
&gt;   Message=An error occurred while sending the request.
&gt;   Source=System.Net.Http
&gt;   StackTrace:
&gt;    at System.Net.Http.HttpConnection.&lt;SendAsyncCore&gt;d__53.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.AuthenticationHelper.&lt;SendWithNtAuthAsync&gt;d__47.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.HttpConnectionPool.&lt;SendWithNtConnectionAuthAsync&gt;d__48.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.HttpConnectionPool.&lt;SendWithRetryAsync&gt;d__47.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.AuthenticationHelper.&lt;SendWithAuthAsync&gt;d__17.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.RedirectHandler.&lt;SendAsync&gt;d__4.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.DiagnosticsHandler.&lt;SendAsync&gt;d__2.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult()
&gt;    at System.Net.Http.HttpClient.&lt;FinishSendAsyncBuffered&gt;d__70.MoveNext()
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
&gt;    at Core.Console.Program.&lt;UploadDocument&gt;d__2.MoveNext() in C:\git\econ-main\src\PoC\ReproHttpClient\ReproHttpClient\Core.Console\Program.cs:line 49
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
&gt;    at Core.Console.Program.&lt;Main&gt;d__1.MoveNext() in C:\git\econ-main\src\PoC\ReproHttpClient\ReproHttpClient\Core.Console\Program.cs:line 18
&gt; 
&gt; Inner Exception 1:
&gt; IOException: Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host..
&gt; 
&gt; Inner Exception 2:
&gt; SocketException: An existing connection was forcibly closed by the remote host.
&gt; 

**HTTP/TCP Stream for full framework:**

&gt; POST /rest-ws/service/dms/42863508DFF541C49B0C298C7C4A3EA3/content?filename=test.txt HTTP/1.1
&gt; Content-Type: multipart/form-data; boundary="af9cb1b0-4999-47f6-95ac-b91ec572edf3"
&gt; **Authorization: NTLM** TlRMTVNTUAABAAAAB7IIogMAAwA2AAAADgAOACgAAAAKAO5CAAAAD0RFRTRFNzQ5M0I2NUNFUENX
&gt; Host: enaio-web-dev.pcw.local
&gt; Content-Length: 0
&gt; 
&gt; HTTP/1.1 401 Unauthorized
&gt; WWW-Authenticate: NTLM TlRMTVNTUAACAAAABgAGADgAAAAFgomiuIB1rGBkz1kAAAAAAAAAAIYAhgA+AAAABgOAJQAAAA9QAEMAVwACAAYAUABDAFcAAQASAEQARQBMAEUASQA0ADQANgAxAAQAEgBwAGMAdwAuAGwAbwBjAGEAbAADACYARABFAEwARQBJADQANAA2ADEALgBwAGMAdwAuAGwAbwBjAGEAbAAFABIAcABjAHcALgBsAG8AYwBhAGwABwAIAEb+j2i6ftUBAAAAAA==
&gt; Connection: keep-alive
&gt; Transfer-Encoding: chunked
&gt; 
&gt; POST /rest-ws/service/dms/42863508DFF541C49B0C298C7C4A3EA3/content?filename=test.txt HTTP/1.1
&gt; Content-Type: multipart/form-data; boundary="af9cb1b0-4999-47f6-95ac-b91ec572edf3"
&gt; **Authorization: NTLM** TlRMTVNTUAADAAAAGAAYAJYAAABGAUYBrgAAAAYABgBYAAAAHAAcAF4AAAAcABwAegAAAAAAAAD0AQAABYKIogoA7kIAAAAPEbCaOQL9OyvKrDhOAwzVmVAAQwBXAEEAbABlAHgAYQBuAGQAZQByAC4AVABhAG4AawBEAEUARQA0AEUANwA0ADkAMwBCADYANQBDAEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZCUzvh3aE3JHGgoP/w5ihQEBAAAAAAAARv6PaLp+1QH1umYM8m/M/wAAAAACAAYAUABDAFcAAQASAEQARQBMAEUASQA0ADQANgAxAAQAEgBwAGMAdwAuAGwAbwBjAGEAbAADACYARABFAEwARQBJADQANAA2ADEALgBwAGMAdwAuAGwAbwBjAGEAbAAFABIAcABjAHcALgBsAG8AYwBhAGwABwAIAEb+j2i6ftUBBgAEAAIAAAAIADAAMAAAAAAAAAAAAAAAADAAAA3oSg1RakvSibPBI+7YwrVkmqjdyu0lOsOQM14VA0j1CgAQAAAAAAAAAAAAAAAAAAAAAAAJADgASABUAFQAUAAvAGUAbgBhAGkAbwAtAHcAZQBiAC0AZABlAHYALgBwAGMAdwAuAGwAbwBjAGEAbAAAAAAAAAAAAAAAAAA=
&gt; Host: enaio-web-dev.pcw.local
&gt; Content-Length: 116336
&gt; **Expect: 100-continue**
&gt; 
&gt; --af9cb1b0-4999-47f6-95ac-b91ec572edf3
&gt; Content-Type: text/plain
&gt; Content-Disposition: form-data; name=test; filename="{fileName}.{fileExtension}"; filename*=utf-8''%7BfileName%7D.%7BfileExtension%7D
&gt; 
&gt; ...UPLOADED FILE CONTENT
&gt; --af9cb1b0-4999-47f6-95ac-b91ec572edf3--
&gt; 
&gt; HTTP/1.1 201 Created
&gt; Set-Cookie: GWSESSIONID=node015onigrgvwlxy1sylpb0trlbwk182.node0;Path=/
&gt; Expires: Thu, 01 Jan 1970 00:00:00 GMT
&gt; X-Application-Context: gateway:prodsso,cloud,red:80
&gt; X-Powered-By: Undertow/1
&gt; Set-Cookie: JSESSIONID_10.49.3.203_8080=jVf77qn98PARc89FAEeX4ciuRCqd3xVu1tN_xD3j.delei4461; path=/rest-ws
&gt; Server: WildFly/9
&gt; Location: http://***/rest-ws/service/dms/42863508DFF541C49B0C298C7C4A3EA3/content?index=0&amp;type=contractdocument
&gt; Date: Wed, 09 Oct 2019 15:58:36 GMT
&gt; Connection: keep-alive
&gt; X-Os-Id: 42863508DFF541C49B0C298C7C4A3EA3
&gt; Content-Type: application/json;charset=utf-8
&gt; Transfer-Encoding: chunked
&gt; 
&gt; {"id":"42863508DFF541C49B0C298C7C4A3EA3","uri":"http://***/rest-ws/service/dms/42863508DFF541C49B0C298C7C4A3EA3/content?index=0&amp;type=contractdocument"}
&gt; 

**HTTP/TCP Stream for .NET Core 3.0:**

&gt; POST /rest-ws/service/dms/42863508DFF541C49B0C298C7C4A3EA3/content?filename=test.txt HTTP/1.1
&gt; Host: enaio-web-dev.pcw.local
&gt; Content-Type: multipart/form-data; boundary="0145d6df-9419-4027-9095-629778dbbd72"
&gt; Content-Length: 116336
&gt; 
&gt; --0145d6df-9419-4027-9095-629778dbbd72
&gt; Content-Type: text/plain
&gt; Content-Disposition: form-data; name=test; filename="{fileName}.{fileExtension}"; filename*=utf-8''%7BfileName%7D.%7BfileExtension%7D
&gt; 
&gt; ...FILE CONTENT
&gt; 
&gt; HTTP/1.1 401 Unauthorized
&gt; WWW-Authenticate: NTLM
&gt; Connection: keep-alive
&gt; Content-Language: en-US
&gt; Content-Type: text/html;charset=utf-8
&gt; Transfer-Encoding: chunked
&gt; 
&gt; &lt;!DOCTYPE html&gt;
&gt; ...


As you can see the full framework is sending 2 additional headers:

- Authorization: NTLM

- Expect: 100-continue

We also noticed that when we send a very small file or an empty byte array the authentication is working for .NET Core 3.0

Our workaround right now is to first send a small Get request to authenticate against the server and receive an authentication cookie and then upload the file. So all following requests just use the authentication cookie and no NTLM. </Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41701</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient: Improve logging and error messages when mismatch between client and server protocol/TLS</Title>
    <Description>My experience with gRPC is that it is very common to run into trouble establishing a connection between the client and the server because of incorrect protocol/TLS.

The logging and error messages in HttpClient should do as much as possible to to help developers fix their own mistakes.

Common problem situations:
1. Client (HTTP/2 with and without TLS) calling HTTP/1 only port
2. Client (HTTP/1 with and without TLS) calling HTTP/2 only port
3. Client (HTTP/2 without TLS) calling HTTP/1 and HTTP/2 port (will fail because no negotiation and default to 1.1)
4. Client (no TLS) calling TLS port
5. Client (TLS) calling no TLS port

Previous issue: https://github.com/dotnet/corefx/issues/37431 (note: now considering making HTTP/2 without TLS a more first-class experience - https://github.com/dotnet/corefx/issues/41621)</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41700</IssueID>
    <RepoID>1</RepoID>
    <Title>Directory.GetFiles works on Win but not *nix</Title>
    <Description>Hi team,

I'm trying to use a dotnet core global tool in a docker build process but getting caught up on the fact that this line of code works on Windows and finds the files, but in a Linux environment it doesn't seem to. 

    Directory.GetFiles(currentWorkingDirectory, "*.csproj", SearchOption.AllDirectories)

For the Windows docker image, I'm using `microsoft/dotnet:2.2-sdk-nanoserver-sac2016` and for the Linux one I'm trying to migrate to I'm using `mcr.microsoft.com/dotnet/core/sdk:2.2`.

I've done some searching online and can't find anything (official or otherwise) that would indicate what I'm trying to do is not supported on Linux, so I'm a bit stumped. Any help would be greatly appreciated.

Cheers,
Ben</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41699</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failure: System.Tests.StringTests.ToUpper_TurkishI_EnglishUSCulture</Title>
    <Description>Test `System.Tests.StringTests.ToUpper_TurkishI_EnglishUSCulture` has failed.

```
 System.Tests.StringTests.ToUpper_TurkishI_EnglishUSCulture(s: "I", expected: "I") [FAIL]
      Timed out at 10/10/2019 12:49:19 AM after 60000ms waiting for remote process.
      	Process ID: 6716
      	Handle: 1244
      	Name: dotnet
      	MainModule: C:\dotnetbuild\work\5f1b1b2e-29d1-4e69-9a86-dd1963109f53\Payload\dotnet.exe
      	StartTime: 10/10/2019 12:48:19 AM
      	TotalProcessorTime: 00:00:00.1562500
      	Threads:
      		Thread #1 (OS 0x1A48) 
      			[InlinedCallFrame]
      			System.Environment.Exit(Int32)
      			Microsoft.DotNet.RemoteExecutor.Program.Main(System.String[])
      			[GCFrame]
      			[GCFrame]
      		Thread #2 (OS 0x1A0C) [Finalizer]
      			[DebuggerU2MCatchHandlerFrame]
      		Thread #3 (OS 0x1970) [Thread pool worker]
      
      Stack Trace:
        /_/src/Microsoft.DotNet.RemoteExecutor/src/RemoteInvokeHandle.cs(131,0): at Microsoft.DotNet.RemoteExecutor.RemoteInvokeHandle.Dispose(Boolean disposing)
        /_/src/Microsoft.DotNet.RemoteExecutor/src/RemoteInvokeHandle.cs(55,0): at Microsoft.DotNet.RemoteExecutor.RemoteInvokeHandle.Dispose()
        /_/src/Common/tests/Tests/System/StringTests.cs(5647,0): at System.Tests.StringTests.ToUpper_TurkishI_EnglishUSCulture(String s, String expected)
  Finished:    System.Runtime.Tests
=== TEST EXECUTION SUMMARY ===
   System.Runtime.Tests  Total: 34299, Errors: 0, Failed: 1, Skipped: 19, Time: 78.532s
----- end Thu 10/10/2019  0:49:21.82 ----- exit code 1 ----------------------------------------------------------
```

Build:[20191009.59](https://dnceng.visualstudio.com/public/_build/results?buildId=383488)(Master)

Details:
https://helix.dot.net/api/2019-06-17/jobs/5f1b1b2e-29d1-4e69-9a86-dd1963109f53/workitems/System.Runtime.Tests/console</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41698</IssueID>
    <RepoID>1</RepoID>
    <Title>https://apisof.net/ is having certificate error again</Title>
    <Description>The certificate seems to have expired on October 7, 2019.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41697</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect output double when formatting using format specifier G</Title>
    <Description>
```
double d1 = (0.60000000000000009);
Console.WriteLine(d1.ToString("G"));

double d2 = (0.20000000000000001);
Console.WriteLine(d2.ToString("G"));
				
//.net 4.6.2
//0,6
//0,2

//.net Core 3.0
//0,6000000000000001
//0,2
```</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41696</IssueID>
    <RepoID>1</RepoID>
    <Title>PhysicalAddress.Parse case-insensitive and support new formats</Title>
    <Description>This pull request is to fix #41518 

System.Net.NetworkInformation.PhysicalAddress.Parse() method currently support only following formats:
```
001122334455
F0-E1-D2-C3-B4-A5
```
Change provide support to parse the following formats:
```
00:11:22:33:44:55
0011:2233:4455
0011.2233.4455
```
as well as supporting lowercase hexadecimal characters, ex: 
```
f0-e1-d2-c3-b4-a5
```
</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41720</IssueID>
    <RepoID>1</RepoID>
    <Title>Cannot connect when IPv6 is specified in .NET Core 2.2 FtpWebRequest</Title>
    <Description># Issue Title

Cannot connect when IPv6 is specified in .NET Core 2.2 FtpWebRequest

# General
An exception occurred when Ipv6 was specified in FtpWebRequest in .NET Core 2.2 as shown below.
If it was confirmed with the same code in .NET Core 3.0, it was successful, so is it a problem before .NET Core 3.0?

```
private static async void CreateDirectory()
{
    try
    {
	UriBuilder uriBuilder = new UriBuilder("ftp", "fe80::1439:5ee0:f81b:93bf");
	Uri reqUri = new Uri(uriBuilder.Uri, "TestDir");
	FtpWebRequest ftpWebRequest = (FtpWebRequest)WebRequest.CreateDefault(reqUri);
	ftpWebRequest.Credentials = new NetworkCredential("User1", "Password1");
	ftpWebRequest.Method = WebRequestMethods.Ftp.MakeDirectory;

        FtpWebResponse response = (FtpWebResponse) await ftpWebRequest.GetResponseAsync().ConfigureAwait(false);
    }
    catch (Exception ex)
    {
        Console.WriteLine("Message : " + ex.Message);
        Console.WriteLine("Exception :\n" + ex.ToString());
    }
}
```
Message : This protocol version is not supported.
Exception :
System.Net.WebException: This protocol version is not supported. ---&gt; System.NotSupportedException: This protocol version is not supported.
at System.Net.Sockets.Socket.BeginConnect(IPAddress address, Int32 port, AsyncCallback requestCallback, Object state)
at System.Net.Sockets.Socket.BeginConnect(String host, Int32 port, AsyncCallback requestCallback, Object state)
at System.Net.Sockets.TcpClient.BeginConnect(String host, Int32 port, AsyncCallback requestCallback, `Object` state)
at System.Net.Sockets.TcpClient.&lt;&gt;c.b__28_0(String targetHost, Int32 targetPort, AsyncCallback callback, Object state)
at System.Threading.Tasks.TaskFactory1.FromAsyncImpl[TArg1,TArg2](Func5 beginMethod, Func2 endFunction, Action1 endAction, TArg1 arg1, TArg2 arg2, Object state, TaskCreationOptions creationOptions)
at System.Threading.Tasks.TaskFactory.FromAsync[TArg1,TArg2](Func5 beginMethod, Action1 endMethod, TArg1 arg1, TArg2 arg2, Object state)
at System.Net.Sockets.TcpClient.ConnectAsync(String host, Int32 port)
at System.Net.FtpWebRequest.CreateConnectionAsync()
--- End of inner exception stack trace ---
at System.Net.FtpWebRequest.EndGetResponse(IAsyncResult asyncResult)
at System.Net.WebRequest.&lt;&gt;c.b__68_2(IAsyncResult iar)
at System.Threading.Tasks.TaskFactory1.FromAsyncCoreLogic(IAsyncResult iar, Func2 endFunction, Action1 endAction, Task1 promise, Boolean requiresSynchronization)
--- End of stack trace from previous location where exception was thrown ---</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41695</IssueID>
    <RepoID>1</RepoID>
    <Title>Mark Assembly.CodeBase as obsolete</Title>
    <Description>`Assembly.Location` and `Assembly.CodeBase` are very similar, but not the same thing. To reduce confusion, we should mark it as obsolete.

### Reason

Having two things that are similar, but not identical always causes confusion. Here is [an example](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-537286033).

As @jkotas [said](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-538606720):

&gt; `Assembly.Location` is strictly better than `Assembly.CodeBase`.
&gt; 
&gt; `Assembly.CodeBase` is an obsolete property. The only reason why it was included in .NET Core was .NET Framework compatibility. The original purpose of `Assembly.CodeBase` was CAS (Code Access Security). It was meant to describe where the assembly was downloaded from for the Internet Zone security checks. It also explains some of its weird behaviors. For example, if the assembly is loaded as byte array, it returns the location of the caller of the `Assembly.Load` method.

### Proposed API

```C#
namespace System.Reflection
{
    public partial class Assembly
    {
        [Obsolete("Use Location instead.")]
        public virtual string CodeBase { get; }
    }
}
```
</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41694</IssueID>
    <RepoID>1</RepoID>
    <Title>Backup wiki information before documentation consolidation</Title>
    <Description>Before we merge the repos, and potentially lose all the information located in the [wiki](https://github.com/dotnet/corefx/wiki) (the wiki has its own repo), we need to make sure we backup those `*.md` files here.

This is the first step of the documentation consolidation effort I proposed and described here: https://github.com/dotnet/corefx/issues/36057#issuecomment-540237320

I added a `README.md` file to describe the root of the wiki folder, so any visitors know what we're doing.

CC @ViktorHofer @karelz @wtgodbe please review.

Also CC @scalablecory who has been actively modifying [this HTTP2 wiki document](https://github.com/dotnet/corefx/wiki/HTTP-2-Implementation-Status). If you prefer to move this file to another location within the Documentation folder of the corefx repo, please let me know.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41693</IssueID>
    <RepoID>1</RepoID>
    <Title>Stop using vfork with musl libc and credentials</Title>
    <Description>Port https://github.com/dotnet/corefx/pull/41457 to master.  We should have started with this master; we can later refine it if desired.
#41432</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41714</IssueID>
    <RepoID>1</RepoID>
    <Title>Encoding UTF8 GetString behaving differently in .net core 3.0</Title>
    <Description>```
var encoding = new System.Text.UTF8Encoding();
var bytes = new Byte[] { 240, 142 };
```
//Outputs two null (?) UTF8 characters in .net core 3.0 but in .net core 2.2, .net 4.7.2 framework 
//returns only one null character
`encoding.GetString(bytes);`

Did something got changed with .net core 3.0.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41692</IssueID>
    <RepoID>1</RepoID>
    <Title>Make WebRequest.GetSystemWebProxy() return a working proxy</Title>
    <Description>Today it returns a singleton on .NET Core that throws PlatformNotSupportedExceptions, and is only used for its reference identity by the WebRequest implementation.  This is problematic for existing code that's taking this proxy and passing it to, for example, ClientWebSocket's Proxy, as it will end up being an expensive nop.  In fact, there's currently no way when targeting netstandard2.0 to tell ClientWebSocket to use a default proxy.

With this fix, WebRequest.DefaultWebProxy (which just defaults to GetSystemWebProxy()) will now return HttpClient.DefaultProxy, which is actually a working proxy implementation.

This should hopefully address https://github.com/Azure/azure-sdk-for-net/issues/7899 once ported back to release/3.0.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>12/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41691</IssueID>
    <RepoID>1</RepoID>
    <Title>DictionaryKeyPolicy not applied to keys that contain non primitive ty…</Title>
    <Description>…pes #41176

https://github.com/dotnet/corefx/issues/41176#event-2697607085</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41690</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Dictionary&lt;Enum, TValue&gt; converter example with JSON syntax of object+property</Title>
    <Description>Additional converter example plus some clean-up on existing examples including late feedback on original [PR for Dictionary samples](https://github.com/dotnet/corefx/pull/41469).

Linking to https://github.com/dotnet/corefx/issues/40120 where other examples are provided and there was a request for an Enum-based converter using a JSON format of object+property syntax (instead of a JSON syntax using KeyValuePair array).

cc @tdykstra</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41689</IssueID>
    <RepoID>1</RepoID>
    <Title>Test mini dump creation and uploading</Title>
    <Description>DO NOT MERGE</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41688</IssueID>
    <RepoID>1</RepoID>
    <Title>Add support for wasm to gen-buildsys-clang.sh</Title>
    <Description>
    </Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41687</IssueID>
    <RepoID>1</RepoID>
    <Title>Add deserialization tests for long input strings</Title>
    <Description>To address https://github.com/dotnet/corefx/pull/41414#discussion_r330845194

The deserializer doesn't currently do any multiplication on the length, so this would be a preventative test.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41686</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unnecessary length restriction on Uri.Escape{Data/Uri}String</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/1936</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41685</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Net.Sockets.Tests.DualModeBeginAccept.BeginAcceptV4BoundToAnyV4_Success failed on CI</Title>
    <Description>```
  Discovering: System.Net.Sockets.Tests (method display = ClassAndMethod, method display options = None)
  Discovered:  System.Net.Sockets.Tests (found 719 of 1096 test cases)
  Starting:    System.Net.Sockets.Tests (parallel test collections = on, max threads = 4)
    System.Net.Sockets.Tests.KeepAliveTest.Socket_KeepAlive_RetryCount_Failure [SKIP]
      Condition(s) not met: "IsWindowsBelow1703"
    System.Net.Sockets.Tests.DualModeBeginAccept.BeginAcceptV4BoundToAnyV4_Success [FAIL]
      Assert.Equal() Failure
      Expected: ::ffff:127.0.0.1
      Actual:   ::127.0.0.1
      Stack Trace:
        /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(864,0): at System.Net.Sockets.Tests.DualModeBeginAccept.DualModeConnect_BeginAccept_Helper(IPAddress listenOn, IPAddress connectTo)
        /_/src/System.Net.Sockets/tests/FunctionalTests/DualModeSocketTest.cs(787,0): at System.Net.Sockets.Tests.DualModeBeginAccept.BeginAcceptV4BoundToAnyV4_Success()
    System.Net.Sockets.Tests.UnixDomainSocketTest.Socket_CreateUnixDomainSocket_Throws_OnWindows [SKIP]
      Condition(s) not met: "IsSubWindows10"
    System.Net.Sockets.Tests.CreateSocket.Ctor_Raw_Supported_Success [SKIP]
      Condition(s) not met: "SupportsRawSockets"
  Finished:    System.Net.Sockets.Tests
=== TEST EXECUTION SUMMARY ===
   System.Net.Sockets.Tests  Total: 930, Errors: 0, Failed: 1, Skipped: 3, Time: 9.362s
```

https://dev.azure.com/dnceng/public/_build/results?buildId=382637&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11824072&amp;resultId=145135&amp;paneView=attachments

cc: @karelz</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41684</IssueID>
    <RepoID>1</RepoID>
    <Title>Uri.UnescapeDataString and Uri.UnescapeString reuse the original string when possible</Title>
    <Description>Uri.UnespaceDataString and Uri.UnescapeString retrieve an array from the pool to use as a temporary data storage for unescaping algorithm instead of a new string or array allocation on each call. After the processing completes, they compare the result stored in the buffer against the original string and return the original object without extra allocation if no changes have been made.
Fixes #16040

|                Method |                                                                      Toolchain |     Mean |    Error |   StdDev |   Median | Ratio | RatioSD |      Gen 0 | Gen 1 | Gen 2 | Allocated |
|---------------------- |------------------------------------------------------------------------------- |---------:|---------:|---------:|---------:|------:|--------:|-----------:|------:|------:|----------:|
| UnescapeRandomStrings | **master** | 290.9 ms | 5.810 ms | 12.75 ms | 288.9 ms |  1.00 |    0.00 | 44000.0000 |     - |     - | 178.54 MB |
| UnescapeRandomStrings | **This PR** | 263.3 ms | 5.260 ms | 14.40 ms | 271.5 ms |  0.89 |    0.07 | 15000.0000 |     - |     - |  63.82 MB |

Benchmark code
```C#
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System;
using System.Text;

namespace UriEscapeUnescapeTest
{
    public class Program
    {
        static void Main(string[] args) =&gt; BenchmarkSwitcher.FromTypes(new[] { typeof(Test) }).Run(args);

        [MemoryDiagnoser]
        public class Test
        {
            private string[] escapedStrings = new string[10000];

            [GlobalSetup]
            public void Setup()
            {
                for(var i = 0; i &lt; escapedStrings.Length; i++)
                {
                    escapedStrings[i] = GenenerateRandomEscapedString();
                }
            }

            public static string GenenerateRandomEscapedString()
            {
                StringBuilder sb = new StringBuilder();
                Random r = new Random();
                for (int i = 0; i &lt; 1000; i++)
                {
                    sb.Append("aa");
                    int val = r.Next(0, 3);
                    switch (val)
                    {
                        case 0:
                            sb.Append("%2F%2F");
                            break;
                        case 1:
                            sb.Append("%3A");
                            break;
                        case 2:
                            sb.Append("%21");
                            break;
                        default:
                            break;
                    }
                }
                return sb.ToString();
            }

            [Benchmark]
            public void UnescapeRandomStrings()
            {
                for(var i = 0; i &lt; escapedStrings.Length; i++)
                {
                    Uri.UnescapeDataString(escapedStrings[i]);
                }
            }
        }
    }
}
```

This PR is based on the original idea of @safern </Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41683</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191009.1
- **Date Produced**: 10/9/2019 9:11 AM
- **Commit**: a7ee8cdccce7d2607d58f9b93ce319209a238f7a
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19509.1
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19509.1

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191008.1
- **Date Produced**: 10/8/2019 12:44 PM
- **Commit**: 7d61c4f64f395734624b345206af693643e4c40a
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19508.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41682</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191008.2
- **Date Produced**: 10/9/2019 12:51 AM
- **Commit**: b3efcae9f917f57417418f462c4244e0feade689
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19508.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19508.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19508.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41681</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191008.9
- **Date Produced**: 10/9/2019 5:01 AM
- **Commit**: 5491acd84b92034d5d53e226682f053a7b376ad9
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19508.9
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19508.9
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19508.9

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41680</IssueID>
    <RepoID>1</RepoID>
    <Title>ThreadLocal implementation does not match documentation</Title>
    <Description>The documentation for ThreadLocal states:

&gt; If this instance was not previously initialized for the current thread, accessing Value will attempt to initialize it. If an initialization function was supplied during the construction, that initialization will happen by invoking the function to retrieve the initial value for Value. Otherwise, the default value will be used. If an exception is thrown, that exception is cached and thrown on each subsequent access of the property.

However, the current implementation appears to not cache the exception, and to reevaluate the initialization function on every access to Value.

Is the documentation incorrect, or is the implementation incorrect?</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41679</IssueID>
    <RepoID>1</RepoID>
    <Title>UriBuilder adds explicit port to Uri.OriginalString even if not present in original Uri</Title>
    <Description>When passing a `Uri` to `UriBuilder`, the resulting `builder.Uri` has a different `OriginalString`. Specifically, the port has been added to `OriginalString` where it was not present originally.

```f#
open System
open System.Web

let uri = "http://example.com"
Uri(uri).OriginalString  // is "http://example.com"
UriBuilder(Uri(uri)).Uri.OriginalString  // is "http://example.com:80/"
```

This has implications e.g. for serialization of URIs. Newtonsoft.Json seems to use `Uri.OriginalString` when serializing URIs. This means that after having been through a `UriBuilder` (e.g. to add path segments), all my URIs come out with ports where they originally had none.

Note that a slash is also added.

This bug exists in at least .NET Core 3.0 and 2.2</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41678</IssueID>
    <RepoID>1</RepoID>
    <Title>Tiny typo in polymorphic</Title>
    <Description>Tiny typo in polymorphic</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41677</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json not working as expected (how Newtonsoft.json did) with [FromBody] WebApi parameter</Title>
    <Description>before with Newtonsoft.json when calling a webapi like this

```
 [HttpPost]
public async Task&lt;ActionResult&gt; Post([FromBody]string someValue)
```

this worked:

`curl -H "Content-Type:application/json" https://localhost:5000/api/controller-X POST -d "'dsfdsafasf'" -v`

now with `System.Text.Json` there are no way to pass a simple string as a parameter.

I tried various combinatin like` {"someValue":"fsdfsdfsdf"}` or `{'someValue':'fsdfsdfsdf'}` or `someValue'=asdfsdfsdf` but without success

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41676</IssueID>
    <RepoID>1</RepoID>
    <Title>Load X509Certificate2 from raw : GetPrivateKey : keyset does not exist</Title>
    <Description>Hi

I use .NET Core 2.2 on Linux AND Windows, I do not want to use the stores. I try to add permissions to IIS or Everyone for test on "C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys" it does not work.. The file is created and I can open it ! But why my program can't do it ?

```
X509KeyStorageFlags flags = X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable;
X509Certificate2 cert = new X509Certificate2(rawCert, "myPassword", flags);

bool result = cert.HasPrivateKey(); // true
var pk =  cert.GetRSAPrivateKey(); // Exception
```

I get this exception :

&gt; Internal.Cryptography.CryptoThrowHelper.WindowsCryptographicException HResult=0x80090016 Message=keyset does not exist
&gt; Source=System.Security.Cryptography.Csp Arborescence des appels de procédure : at Internal.NativeCrypto.CapiHelper.CreateProvHandle(CspParameters parameters, Boolean randomKeyContainer) at System.Security.Cryptography.RSACryptoServiceProvider.get_SafeProvHandle() at System.Security.Cryptography.RSACryptoServiceProvider.get_SafeKeyHandle() at System.Security.Cryptography.RSACryptoServiceProvider..ctor(Int32 keySize, CspParameters parameters, Boolean useDefaultKeySize) at System.Security.Cryptography.RSACryptoServiceProvider..ctor(CspParameters parameters) at Internal.Cryptography.Pal.CertificatePal.&lt;&gt;c.b__66_0(CspParameters csp) at Internal.Cryptography.Pal.CertificatePal.GetPrivateKey[T](Func2
&gt;   createCsp, Func2 createCng) at Internal.Cryptography.Pal.CertificatePal.GetRSAPrivateKey() at Internal.Cryptography.Pal.CertificateExtensionsCommon.GetPrivateKey[T](X509Certificate2 certificate, Predicate`1 matchesConstraints) at System.Security.Cryptography.X509Certificates.RSACertificateExtensions.GetRSAPrivateKey(X509Certificate2 certificate) at ConsoleTest.Program.Main(String[] args) in ...


I've so many problems with the certificate management..  
I've try to use the store, it's work on Windows but not on Linux... (https://github.com/dotnet/corefx/issues/41466#issuecomment-538544491). 
I just want get my private key, the same way on Windows as on Linux 

Thanks everyone
</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41675</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Drawing.Common.Tests failed with exit code 134</Title>
    <Description>Test `System.Drawing.Common.Tests` has failed.

**Log:**
```
~/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec ~/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec
  Discovering: System.Drawing.Common.Tests (method display = ClassAndMethod, method display options = None)
  Discovered:  System.Drawing.Common.Tests (found 1501 of 1972 test cases)
  Starting:    System.Drawing.Common.Tests (parallel test collections = on, max threads = 2)
    System.Drawing.Printing.Tests.PrinterSettingsTests.IsPlotter_ReturnsExpected [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PrinterSettingsTests.Collate_Default_ReturnsExpected [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PrinterSettingsTests.Clone_Success [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PrinterSettingsTests.MaximumCopies_ReturnsExpected [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PrinterSettingsTests.Static_InstalledPrinters_ReturnsExpected [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PrinterSettingsTests.LandscapeAngle_ReturnsExpected [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PreviewPrintControllerTests.OnStartPrint_InvokeWithDocument_Success [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PreviewPrintControllerTests.OnStartPage_InvokeWithPrint_ReturnsNull [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
    System.Drawing.Printing.Tests.PreviewPrintControllerTests.OnStartPage_InvokeNullEventArgsPageSettings_ReturnsNull [SKIP]
      Condition(s) not met: "IsAnyInstalledPrinters"
*** Error in `/home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/dotnet': double free or corruption (fasttop): 0x00007fa50c00f280 ***
======= Backtrace: =========
/lib64/libc.so.6(+0x7415f)[0x7fa5d5f7115f]
/lib64/libc.so.6(+0x795d6)[0x7fa5d5f765d6]
/lib64/libc.so.6(+0x7a41b)[0x7fa5d5f7741b]
/usr/lib64/libgdiplus.so(mono_cairo_font_face_destroy+0x2f)[0x7fa5bf66b26f]
/usr/lib64/libgdiplus.so(+0x55d56)[0x7fa5bf66bd56]
/usr/lib64/libgdiplus.so(mono_cairo_destroy+0x52)[0x7fa5bf665962]
/usr/lib64/libgdiplus.so(GdipDeleteGraphics+0x85)[0x7fa5bf637545]
[0x7fa55c9e8412]
======= Memory map: ========
00400000-00410000 r-xp 00000000 08:04 50567007                           /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/dotnet
0060f000-00610000 r--p 0000f000 08:04 50567007                           /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/dotnet
00610000-00611000 rw-p 00010000 08:04 50567007                           /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/dotnet
01161000-0166a000 rw-p 00000000 00:00 0                                  [heap]
7fa50c000000-7fa50c1f3000 rw-p 00000000 00:00 0 
7fa50c1f3000-7fa510000000 ---p 00000000 00:00 0 
7fa510000000-7fa510021000 rw-p 00000000 00:00 0 
7fa510021000-7fa514000000 ---p 00000000 00:00 0 
7fa514000000-7fa5141c4000 rw-p 00000000 00:00 0 
7fa5141c4000-7fa518000000 ---p 00000000 00:00 0 
7fa518000000-7fa518021000 rw-p 00000000 00:00 0 
7fa518021000-7fa51c000000 ---p 00000000 00:00 0 
7fa51c000000-7fa51c021000 rw-p 00000000 00:00 0 
7fa51c021000-7fa520000000 ---p 00000000 00:00 0 
7fa520000000-7fa52004a000 rw-p 00000000 00:00 0 
7fa52004a000-7fa524000000 ---p 00000000 00:00 0 
7fa524000000-7fa524021000 rw-p 00000000 00:00 0 
7fa524021000-7fa528000000 ---p 00000000 00:00 0 
7fa528000000-7fa528021000 rw-p 00000000 00:00 0 
7fa528021000-7fa52c000000 ---p 00000000 00:00 0 
7fa52c000000-7fa52c021000 rw-p 00000000 00:00 0 
7fa52c021000-7fa530000000 ---p 00000000 00:00 0 
7fa532ffc000-7fa532ffd000 ---p 00000000 00:00 0 
7fa532ffd000-7fa5337fd000 rw-p 00000000 00:00 0 
7fa5337fd000-7fa5337fe000 ---p 00000000 00:00 0 
7fa5337fe000-7fa5351b0000 rw-p 00000000 00:00 0 
7fa5351b0000-7fa543ffe000 ---p 00000000 00:00 0 
7fa543ffe000-7fa54407c000 rw-p 00000000 00:00 0 
7fa54407c000-7fa54c000000 ---p 00000000 00:00 0 
7fa54c000000-7fa54c021000 rw-p 00000000 00:00 0 
7fa54c021000-7fa550000000 ---p 00000000 00:00 0 
7fa550000000-7fa550021000 rw-p 00000000 00:00 0 
7fa550021000-7fa554000000 ---p 00000000 00:00 0 
7fa554000000-7fa554021000 rw-p 00000000 00:00 0 
7fa554021000-7fa558000000 ---p 00000000 00:00 0 
7fa558537000-7fa55855a000 r-xp 00000000 08:04 50332502                   /lib64/libselinux.so.1
7fa55855a000-7fa558759000 ---p 00023000 08:04 50332502                   /lib64/libselinux.so.1
7fa558759000-7fa55875a000 r--p 00022000 08:04 50332502                   /lib64/libselinux.so.1
7fa55875a000-7fa55875b000 rw-p 00023000 08:04 50332502                   /lib64/libselinux.so.1
7fa55875b000-7fa55875d000 rw-p 00000000 00:00 0 
7fa55875d000-7fa558771000 r-xp 00000000 08:04 50332500                   /lib64/libresolv-2.22.so
7fa558771000-7fa558970000 ---p 00014000 08:04 50332500                   /lib64/libresolv-2.22.so
7fa558970000-7fa558971000 r--p 00013000 08:04 50332500                   /lib64/libresolv-2.22.so
7fa558971000-7fa558972000 rw-p 00014000 08:04 50332500                   /lib64/libresolv-2.22.so
7fa558972000-7fa558974000 rw-p 00000000 00:00 0 
7fa558974000-7fa558977000 r-xp 00000000 08:04 50332476                   /lib64/libkeyutils.so.1.5
7fa558977000-7fa558b76000 ---p 00003000 08:04 50332476                   /lib64/libkeyutils.so.1.5
7fa558b76000-7fa558b77000 r--p 00002000 08:04 50332476                   /lib64/libkeyutils.so.1.5
7fa558b77000-7fa558b78000 rw-p 00003000 08:04 50332476                   /lib64/libkeyutils.so.1.5
7fa558b78000-7fa558bbd000 r-xp 00000000 08:04 50332465                   /lib64/libdbus-1.so.3.8.14
7fa558bbd000-7fa558dbd000 ---p 00045000 08:04 50332465                   /lib64/libdbus-1.so.3.8.14
7fa558dbd000-7fa558dbe000 r--p 00045000 08:04 50332465                   /lib64/libdbus-1.so.3.8.14
7fa558dbe000-7fa558dbf000 rw-p 00046000 08:04 50332465                   /lib64/libdbus-1.so.3.8.14
7fa558dbf000-7fa558dcb000 r-xp 00000000 08:04 34176257                   /usr/lib64/libkrb5support.so.0.1
7fa558dcb000-7fa558fca000 ---p 0000c000 08:04 34176257                   /usr/lib64/libkrb5support.so.0.1
7fa558fca000-7fa558fcb000 r--p 0000b000 08:04 34176257                   /usr/lib64/libkrb5support.so.0.1
7fa558fcb000-7fa558fcc000 rw-p 0000c000 08:04 34176257                   /usr/lib64/libkrb5support.so.0.1
7fa558fcc000-7fa558fcf000 r-xp 00000000 08:04 34139040                   /usr/lib64/libcom_err.so.2.1
7fa558fcf000-7fa5591ce000 ---p 00003000 08:04 34139040                   /usr/lib64/libcom_err.so.2.1
7fa5591ce000-7fa5591cf000 r--p 00002000 08:04 34139040                   /usr/lib64/libcom_err.so.2.1
7fa5591cf000-7fa5591d0000 rw-p 00003000 08:04 34139040                   /usr/lib64/libcom_err.so.2.1
7fa5591d0000-7fa5591fd000 r-xp 00000000 08:04 34139130                   /usr/lib64/libk5crypto.so.3.1
7fa5591fd000-7fa5593fc000 ---p 0002d000 08:04 34139130                   /usr/lib64/libk5crypto.so.3.1
7fa5593fc000-7fa5593fe000 r--p 0002c000 08:04 34139130                   /usr/lib64/libk5crypto.so.3.1
7fa5593fe000-7fa5593ff000 rw-p 0002e000 08:04 34139130                   /usr/lib64/libk5crypto.so.3.1
7fa5593ff000-7fa559400000 rw-p 00000000 00:00 0 
7fa559400000-7fa5594c1000 r-xp 00000000 08:04 34176256                   /usr/lib64/libkrb5.so.3.3
7fa5594c1000-7fa5596c0000 ---p 000c1000 08:04 34176256                   /usr/lib64/libkrb5.so.3.3
7fa5596c0000-7fa5596cd000 r--p 000c0000 08:04 34176256                   /usr/lib64/libkrb5.so.3.3
7fa5596cd000-7fa5596d0000 rw-p 000cd000 08:04 34176256                   /usr/lib64/libkrb5.so.3.3
7fa5596d0000-7fa5596e0000 r-xp 00000000 08:04 34139029                   /usr/lib64/libavahi-client.so.3.2.9
7fa5596e0000-7fa5598df000 ---p 00010000 08:04 34139029                   /usr/lib64/libavahi-client.so.3.2.9
7fa5598df000-7fa5598e0000 r--p 0000f000 08:04 34139029                   /usr/lib64/libavahi-client.so.3.2.9
7fa5598e0000-7fa5598e1000 rw-p 00010000 08:04 34139029                   /usr/lib64/libavahi-client.so.3.2.9
7fa5598e1000-7fa5598ed000 r-xp 00000000 08:04 34139030                   /usr/lib64/libavahi-common.so.3.5.3
7fa5598ed000-7fa559aec000 ---p 0000c000 08:04 34139030                   /usr/lib64/libavahi-common.so.3.5.3
7fa559aec000-7fa559aed000 r--p 0000b000 08:04 34139030                   /usr/lib64/libavahi-common.so.3.5.3
7fa559aed000-7fa559aee000 rw-p 0000c000 08:04 34139030                   /usr/lib64/libavahi-common.so.3.5.3
7fa559aee000-7fa559d2a000 r-xp 00000000 08:04 50332464                   /lib64/libcrypto.so.1.0.0
7fa559d2a000-7fa559f29000 ---p 0023c000 08:04 50332464                   /lib64/libcrypto.so.1.0.0
7fa559f29000-7fa559f45000 r--p 0023b000 08:04 50332464                   /lib64/libcrypto.so.1.0.0
7fa559f45000-7fa559f52000 rw-p 00257000 08:04 50332464                   /lib64/libcrypto.so.1.0.0
7fa559f52000-7fa559f56000 rw-p 00000000 00:00 0 
7fa559f56000-7fa559fb9000 r-xp 00000000 08:04 50332504                   /lib64/libssl.so.1.0.0
7fa559fb9000-7fa55a1b9000 ---p 00063000 08:04 50332504                   /lib64/libssl.so.1.0.0
7fa55a1b9000-7fa55a1be000 r--p 00063000 08:04 50332504                   /lib64/libssl.so.1.0.0
7fa55a1be000-7fa55a1c4000 rw-p 00068000 08:04 50332504                   /lib64/libssl.so.1.0.0
7fa55a1c4000-7fa55a20a000 r-xp 00000000 08:04 34139107                   /usr/lib64/libgssapi_krb5.so.2.2
7fa55a20a000-7fa55a40a000 ---p 00046000 08:04 34139107                   /usr/lib64/libgssapi_krb5.so.2.2
7fa55a40a000-7fa55a40b000 r--p 00046000 08:04 34139107                   /usr/lib64/libgssapi_krb5.so.2.2
7fa55a40b000-7fa55a40d000 rw-p 00047000 08:04 34139107                   /usr/lib64/libgssapi_krb5.so.2.2
7fa55a40d000-7fa55a48e000 r-xp 00000000 08:04 34139045                   /usr/lib64/libcups.so.2
7fa55a48e000-7fa55a68d000 ---p 00081000 08:04 34139045                   /usr/lib64/libcups.so.2
7fa55a68d000-7fa55a694000 r--p 00080000 08:04 34139045                   /usr/lib64/libcups.so.2
7fa55a694000-7fa55a695000 rw-p 00087000 08:04 34139045                   /usr/lib64/libcups.so.2
7fa55a695000-7fa55a696000 rw-p 00000000 00:00 0 
7fa55a696000-7fa55a697000 ---p 00000000 00:00 0 
7fa55a697000-7fa55ae97000 rw-p 00000000 00:00 0 
7fa55ae97000-7fa55ae9a000 r-xp 00000000 08:04 34139013                   /usr/lib64/libXau.so.6.0.0
7fa55ae9a000-7fa55b099000 ---p 00003000 08:04 34139013                   /usr/lib64/libXau.so.6.0.0
7fa55b099000-7fa55b09a000 r--p 00002000 08:04 34139013                   /usr/lib64/libXau.so.6.0.0
7fa55b09a000-7fa55b09b000 rw-p 00003000 08:04 34139013                   /usr/lib64/libXau.so.6.0.0
7fa55b09b000-7fa55b0c2000 r-xp 00000000 08:04 34139076                   /usr/lib64/libexpat.so.1.6.0
7fa55b0c2000-7fa55b2c2000 ---p 00027000 08:04 34139076                   /usr/lib64/libexpat.so.1.6.0
7fa55b2c2000-7fa55b2c4000 r--p 00027000 08:04 34139076                   /usr/lib64/libexpat.so.1.6.0
7fa55b2c4000-7fa55b2c5000 rw-p 00029000 08:04 34139076                   /usr/lib64/libexpat.so.1.6.0
7fa55b2c5000-7fa55b2ce000 r-xp 00000000 08:04 34705770                   /usr/lib64/libjbig.so.2.0
7fa55b2ce000-7fa55b4cd000 ---p 00009000 08:04 34705770                   /usr/lib64/libjbig.so.2.0
7fa55b4cd000-7fa55b4ce000 r--p 00008000 08:04 34705770                   /usr/lib64/libjbig.so.2.0
7fa55b4ce000-7fa55b4d1000 rw-p 00009000 08:04 34705770                   /usr/lib64/libjbig.so.2.0
7fa55b4d1000-7fa55b4f5000 r-xp 00000000 08:04 34176269                   /usr/lib64/liblzma.so.5.0.5
7fa55b4f5000-7fa55b6f5000 ---p 00024000 08:04 34176269                   /usr/lib64/liblzma.so.5.0.5
7fa55b6f5000-7fa55b6f6000 r--p 00024000 08:04 34176269                   /usr/lib64/liblzma.so.5.0.5
7fa55b6f6000-7fa55b6f7000 rw-p 00025000 08:04 34176269                   /usr/lib64/liblzma.so.5.0.5
7fa55b6f7000-7fa55b700000 ---p 00000000 00:00 0 
7fa55b700000-7fa55b701000 rw-p 00000000 00:00 0 
7fa55b701000-7fa55b703000 ---p 00000000 00:00 0 
7fa55b703000-7fa55b704000 rwxp 00000000 00:00 0 
7fa55b704000-7fa55b70d000 rw-p 00000000 00:00 0 
7fa55b70d000-7fa55b70e000 rwxp 00000000 00:00 0 
7fa55b70e000-7fa55b710000 ---p 00000000 00:00 0 
7fa55b710000-7fa55b714000 rw-p 00000000 00:00 0 
7fa55b714000-7fa55b716000 ---p 00000000 00:00 0 
7fa55b716000-7fa55b719000 rw-p 00000000 00:00 0 
7fa55b719000-7fa55b71f000 ---p 00000000 00:00 0 
7fa55b71f000-7fa55b723000 rwxp 00000000 00:00 0 
7fa55b723000-7fa55b728000 rwxp 00000000 00:00 0 
7fa55b728000-7fa55b754000 ---p 00000000 00:00 0 
7fa55b754000-7fa55b75d000 rwxp 00000000 00:00 0 
7fa55b75d000-7fa55b7b0000 ---p 00000000 00:00 0 
7fa55b7b0000-7fa55b7b1000 r--p 00000000 08:04 659148                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.CoreLib.dll
7fa55b7b1000-7fa55b7c0000 ---p 00000000 00:00 0 
7fa55b7c0000-7fa55b7df000 rw-p 00000000 08:04 659148                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.CoreLib.dll
7fa55b7df000-7fa55b7ee000 ---p 00000000 00:00 0 
7fa55b7ee000-7fa55bfc4000 r-xp 0001e000 08:04 659148                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.CoreLib.dll
7fa55bfc4000-7fa55bfd3000 ---p 00000000 00:00 0 
7fa55bfd3000-7fa55bfda000 r--p 007f3000 08:04 659148                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.CoreLib.dll
7fa55bfda000-7fa55bfe0000 ---p 00000000 00:00 0 
7fa55bfe0000-7fa55c01f000 rw-p 00000000 00:00 0 
7fa55c01f000-7fa55c020000 ---p 00000000 00:00 0 
7fa55c020000-7fa55c040000 rw-p 00000000 00:00 0 
7fa55c040000-7fa55c085000 rwxp 00000000 00:00 0 
7fa55c085000-7fa55c0c0000 ---p 00000000 00:00 0 
7fa55c0c0000-7fa55c0e0000 rw-p 00000000 00:00 0 
7fa55c0e0000-7fa55c0ef000 rw-p 00000000 00:00 0 
7fa55c0ef000-7fa55c0f0000 ---p 00000000 00:00 0 
7fa55c0f0000-7fa55c110000 rw-p 00000000 00:00 0 
7fa55c110000-7fa55c120000 rw-p 00000000 00:00 0 
7fa55c120000-7fa55c130000 rw-p 00000000 00:00 0 
7fa55c130000-7fa55c15f000 rw-p 00000000 00:00 0 
7fa55c15f000-7fa55c160000 ---p 00000000 00:00 0 
7fa55c160000-7fa55c170000 rw-p 00000000 00:00 0 
7fa55c170000-7fa55c180000 rw-p 00000000 00:00 0 
7fa55c180000-7fa55c190000 rw-p 00000000 00:00 0 
7fa55c190000-7fa55c1a0000 rw-p 00000000 00:00 0 
7fa55c1a0000-7fa55c1c0000 rw-p 00000000 00:00 0 
7fa55c1c0000-7fa55c1d0000 rw-p 00000000 00:00 0 
7fa55c1d0000-7fa55c1f0000 rw-p 00000000 00:00 0 
7fa55c1f0000-7fa55c200000 rw-p 00000000 00:00 0 
7fa55c200000-7fa55c210000 rw-p 00000000 00:00 0 
7fa55c210000-7fa55c220000 rw-p 00000000 00:00 0 
7fa55c220000-7fa55c230000 rw-p 00000000 00:00 0 
7fa55c230000-7fa55c240000 rw-p 00000000 00:00 0 
7fa55c240000-7fa55c250000 rw-p 00000000 00:00 0 
7fa55c250000-7fa55c28e000 rwxp 00000000 00:00 0 
7fa55c28e000-7fa55c2d0000 ---p 00000000 00:00 0 
7fa55c2d0000-7fa55c2df000 rw-p 00000000 00:00 0 
7fa55c2df000-7fa55c2e0000 ---p 00000000 00:00 0 
7fa55c2e0000-7fa55c2f0000 rw-p 00000000 00:00 0 
7fa55c2f0000-7fa55c300000 rw-p 00000000 00:00 0 
7fa55c300000-7fa55c310000 rw-p 00000000 00:00 0 
7fa55c310000-7fa55c312000 rw-p 00000000 00:00 0 
7fa55c312000-7fa55c320000 ---p 00000000 00:00 0 
7fa55c320000-7fa55c370000 rw-p 00000000 00:00 0 
7fa55c370000-7fa55c380000 rw-p 00000000 00:00 0 
7fa55c380000-7fa55c390000 rw-p 00000000 00:00 0 
7fa55c390000-7fa55c3a0000 rw-p 00000000 00:00 0 
7fa55c3a0000-7fa55c3b7000 rw-p 00000000 00:00 0 
7fa55c3b7000-7fa55c3c0000 ---p 00000000 00:00 0 
7fa55c3c0000-7fa55c3df000 rw-p 00000000 00:00 0 
7fa55c3df000-7fa55c3e0000 ---p 00000000 00:00 0 
7fa55c3e0000-7fa55c3f0000 rw-p 00000000 00:00 0 
7fa55c3f0000-7fa55c410000 rw-p 00000000 00:00 0 
7fa55c410000-7fa55c420000 rw-p 00000000 00:00 0 
7fa55c420000-7fa55c42f000 rw-p 00000000 00:00 0 
7fa55c42f000-7fa55c430000 ---p 00000000 00:00 0 
7fa55c430000-7fa55c440000 rw-p 00000000 00:00 0 
7fa55c440000-7fa55c460000 rw-p 00000000 00:00 0 
7fa55c460000-7fa55c470000 rw-p 00000000 00:00 0 
7fa55c470000-7fa55c490000 rw-p 00000000 00:00 0 
7fa55c490000-7fa55c494000 rw-p 00000000 00:00 0 
7fa55c494000-7fa55c4a0000 ---p 00000000 00:00 0 
7fa55c4a0000-7fa55c4d0000 rw-p 00000000 00:00 0 
7fa55c4d0000-7fa55c4e0000 rw-p 00000000 00:00 0 
7fa55c4e0000-7fa55c4f0000 rw-p 00000000 00:00 0 
7fa55c4f0000-7fa55c520000 rw-p 00000000 00:00 0 
7fa55c520000-7fa55c530000 rw-p 00000000 00:00 0 
7fa55c530000-7fa55c550000 rw-p 00000000 00:00 0 
7fa55c550000-7fa55c560000 rw-p 00000000 00:00 0 
7fa55c560000-7fa55c570000 rw-p 00000000 00:00 0 
7fa55c570000-7fa55c580000 rw-p 00000000 00:00 0 
7fa55c580000-7fa55c590000 rw-p 00000000 00:00 0 
7fa55c590000-7fa55c593000 rw-p 00000000 00:00 0 
7fa55c593000-7fa55c5a0000 ---p 00000000 00:00 0 
7fa55c5a0000-7fa55c5b0000 rw-p 00000000 00:00 0 
7fa55c5b0000-7fa55c5da000 rw-p 00000000 00:00 0 
7fa55c5da000-7fa55c5e0000 ---p 00000000 00:00 0 
7fa55c5e0000-7fa55c5f0000 rw-p 00000000 00:00 0 
7fa55c5f0000-7fa55c610000 rw-p 00000000 00:00 0 
7fa55c610000-7fa55c65e000 rwxp 00000000 00:00 0 
7fa55c65e000-7fa55c690000 ---p 00000000 00:00 0 
7fa55c690000-7fa55c6c0000 rw-p 00000000 00:00 0 
7fa55c6c0000-7fa55c6d0000 rw-p 00000000 00:00 0 
7fa55c6d0000-7fa55c700000 rw-p 00000000 00:00 0 
7fa55c700000-7fa55c710000 rw-p 00000000 00:00 0 
7fa55c710000-7fa55c720000 rw-p 00000000 00:00 0 
7fa55c720000-7fa55c72e000 rw-p 00000000 00:00 0 
7fa55c72e000-7fa55c730000 ---p 00000000 00:00 0 
7fa55c730000-7fa55c740000 rw-p 00000000 00:00 0 
7fa55c740000-7fa55c770000 rw-p 00000000 00:00 0 
7fa55c770000-7fa55c790000 rw-p 00000000 00:00 0 
7fa55c790000-7fa55c7a0000 rw-p 00000000 00:00 0 
7fa55c7a0000-7fa55c7c0000 rw-p 00000000 00:00 0 
7fa55c7c0000-7fa55c7d0000 rw-p 00000000 00:00 0 
7fa55c7d0000-7fa55c7f0000 rw-p 00000000 00:00 0 
7fa55c7f0000-7fa55c800000 rw-p 00000000 00:00 0 
7fa55c800000-7fa55c810000 rw-p 00000000 00:00 0 
7fa55c810000-7fa55c86f000 rwxp 00000000 00:00 0 
7fa55c86f000-7fa55c890000 ---p 00000000 00:00 0 
7fa55c890000-7fa55c89d000 rw-p 00000000 00:00 0 
7fa55c89d000-7fa55c8a0000 ---p 00000000 00:00 0 
7fa55c8a0000-7fa55c8b0000 rw-p 00000000 00:00 0 
7fa55c8b0000-7fa55c8bf000 rw-p 00000000 00:00 0 
7fa55c8bf000-7fa55c8c0000 ---p 00000000 00:00 0 
7fa55c8c0000-7fa55c8d0000 rw-p 00000000 00:00 0 
7fa55c8d0000-7fa55c8e0000 rw-p 00000000 00:00 0 
7fa55c8e0000-7fa55c8f0000 rw-p 00000000 00:00 0 
7fa55c8f0000-7fa55c910000 rw-p 00000000 00:00 0 
7fa55c910000-7fa55c91f000 rw-p 00000000 00:00 0 
7fa55c91f000-7fa55c920000 ---p 00000000 00:00 0 
7fa55c920000-7fa55c930000 rw-p 00000000 00:00 0 
7fa55c930000-7fa55c931000 rwxp 00000000 00:00 0 
7fa55c931000-7fa55c940000 ---p 00000000 00:00 0 
7fa55c940000-7fa55c950000 rw-p 00000000 00:00 0 
7fa55c950000-7fa55c970000 rw-p 00000000 00:00 0 
7fa55c970000-7fa55c980000 rw-p 00000000 00:00 0 
7fa55c980000-7fa55c990000 rw-p 00000000 00:00 0 
7fa55c990000-7fa55c9a0000 rw-p 00000000 00:00 0 
7fa55c9a0000-7fa55c9b0000 rw-p 00000000 00:00 0 
7fa55c9b0000-7fa55c9c0000 rw-p 00000000 00:00 0 
7fa55c9c0000-7fa55c9d0000 rw-p 00000000 00:00 0 
7fa55c9d0000-7fa55c9e0000 rw-p 00000000 00:00 0 
7fa55c9e0000-7fa55ca48000 rwxp 00000000 00:00 0 
7fa55ca48000-7fa55ca60000 ---p 00000000 00:00 0 
7fa55ca60000-7fa55ca70000 rw-p 00000000 00:00 0 
7fa55ca70000-7fa55ca80000 rw-p 00000000 00:00 0 
7fa55ca80000-7fa55ca90000 rw-p 00000000 00:00 0 
7fa55ca90000-7fa55caa0000 rw-p 00000000 00:00 0 
7fa55caa0000-7fa55cac0000 rw-p 00000000 00:00 0 
7fa55cac0000-7fa55cac7000 rw-p 00000000 00:00 0 
7fa55cac7000-7fa55cad0000 ---p 00000000 00:00 0 
7fa55cad0000-7fa55cad4000 rw-p 00000000 00:00 0 
7fa55cad4000-7fa5bd2e7000 ---p 00000000 00:00 0 
7fa5bd3d0000-7fa5bd3e0000 r--s 00000000 08:04 17325687                   /var/cache/fontconfig/7ef2298fde41cc6eeb7af42e48b7d293-x86_64.cache-4
7fa5bd3e0000-7fa5bd3e1000 ---p 00000000 00:00 0 
7fa5bd3e1000-7fa5bd3e4000 rw-p 00000000 00:00 0 
7fa5bd3e4000-7fa5bd3e6000 r--s 00000000 08:04 659233                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.ComponentModel.dll
7fa5bd3e6000-7fa5bd3e8000 r--s 00000000 08:04 658928                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Resources.ResourceManager.dll
7fa5bd3e8000-7fa5bd3ee000 r--s 00000000 08:04 658348                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.ComponentModel.Primitives.dll
7fa5bd3ee000-7fa5bd3ef000 ---p 00000000 00:00 0 
7fa5bd3ef000-7fa5bd3f2000 rw-p 00000000 00:00 0 
7fa5bd3f2000-7fa5bd3fb000 r--s 00000000 08:04 659004                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.ObjectModel.dll
7fa5bd3fb000-7fa5bd480000 r--s 00000000 08:04 658918                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Linq.Expressions.dll
7fa5bd480000-7fa5bd4b5000 r--s 00000000 00:16 25012                      /run/nscd/passwd
7fa5bd4b5000-7fa5bd4b6000 ---p 00000000 00:00 0 
7fa5bd4b6000-7fa5bd4b9000 rw-p 00000000 00:00 0 
7fa5bd4b9000-7fa5bd4bb000 r--s 00000000 08:04 659122                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Text.Encoding.dll
7fa5bd4bb000-7fa5bd4bc000 ---p 00000000 00:00 0 
7fa5bd4bc000-7fa5bd4bf000 rw-p 00000000 00:00 0 
7fa5bd4bf000-7fa5bd4c1000 r--s 00000000 08:04 658945                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.Primitives.dll
7fa5bd4c1000-7fa5bd4c3000 r--s 00000000 08:04 658430                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.Emit.Lightweight.dll
7fa5bd4c3000-7fa5bd4e2000 r-xp 00000000 08:04 34210835                   /usr/lib64/libxcb.so.1.1.0
7fa5bd4e2000-7fa5bd6e1000 ---p 0001f000 08:04 34210835                   /usr/lib64/libxcb.so.1.1.0
7fa5bd6e1000-7fa5bd6e2000 r--p 0001e000 08:04 34210835                   /usr/lib64/libxcb.so.1.1.0
7fa5bd6e2000-7fa5bd6e3000 rw-p 0001f000 08:04 34210835                   /usr/lib64/libxcb.so.1.1.0
7fa5bd6e3000-7fa5bd6f1000 r-xp 00000000 08:04 34139036                   /usr/lib64/libbz2.so.1.0.6
7fa5bd6f1000-7fa5bd8f0000 ---p 0000e000 08:04 34139036                   /usr/lib64/libbz2.so.1.0.6
7fa5bd8f0000-7fa5bd8f1000 r--p 0000d000 08:04 34139036                   /usr/lib64/libbz2.so.1.0.6
7fa5bd8f1000-7fa5bd8f2000 rw-p 0000e000 08:04 34139036                   /usr/lib64/libbz2.so.1.0.6
7fa5bd8f2000-7fa5bd960000 r-xp 00000000 08:04 34201506                   /usr/lib64/libpcre.so.1.2.7
7fa5bd960000-7fa5bdb5f000 ---p 0006e000 08:04 34201506                   /usr/lib64/libpcre.so.1.2.7
7fa5bdb5f000-7fa5bdb60000 r--p 0006d000 08:04 34201506                   /usr/lib64/libpcre.so.1.2.7
7fa5bdb60000-7fa5bdb61000 rw-p 0006e000 08:04 34201506                   /usr/lib64/libpcre.so.1.2.7
7fa5bdb61000-7fa5bdb9d000 r-xp 00000000 08:04 34139085                   /usr/lib64/libfontconfig.so.1.8.0
7fa5bdb9d000-7fa5bdd9c000 ---p 0003c000 08:04 34139085                   /usr/lib64/libfontconfig.so.1.8.0
7fa5bdd9c000-7fa5bdd9e000 r--p 0003b000 08:04 34139085                   /usr/lib64/libfontconfig.so.1.8.0
7fa5bdd9e000-7fa5bdd9f000 rw-p 0003d000 08:04 34139085                   /usr/lib64/libfontconfig.so.1.8.0
7fa5bdd9f000-7fa5bddd1000 r-xp 00000000 08:04 34705760                   /usr/lib64/libexif.so.12.3.3
7fa5bddd1000-7fa5bdfd0000 ---p 00032000 08:04 34705760                   /usr/lib64/libexif.so.12.3.3
7fa5bdfd0000-7fa5bdfe3000 r--p 00031000 08:04 34705760                   /usr/lib64/libexif.so.12.3.3
7fa5bdfe3000-7fa5bdfe4000 rw-p 00044000 08:04 34705760                   /usr/lib64/libexif.so.12.3.3
7fa5bdfe4000-7fa5bdffa000 r-xp 00000000 08:04 50332546                   /lib64/libz.so.1.2.11
7fa5bdffa000-7fa5be1f9000 ---p 00016000 08:04 50332546                   /lib64/libz.so.1.2.11
7fa5be1f9000-7fa5be1fa000 r--p 00015000 08:04 50332546                   /lib64/libz.so.1.2.11
7fa5be1fa000-7fa5be1fb000 rw-p 00016000 08:04 50332546                   /lib64/libz.so.1.2.11
7fa5be1fb000-7fa5be236000 r-xp 00000000 08:04 34201511                   /usr/lib64/libpng16.so.16.8.0
7fa5be236000-7fa5be436000 ---p 0003b000 08:04 34201511                   /usr/lib64/libpng16.so.16.8.0
7fa5be436000-7fa5be437000 r--p 0003b000 08:04 34201511                   /usr/lib64/libpng16.so.16.8.0
7fa5be437000-7fa5be438000 rw-p 0003c000 08:04 34201511                   /usr/lib64/libpng16.so.16.8.0
7fa5be438000-7fa5be440000 r-xp 00000000 08:04 34705766                   /usr/lib64/libgif.so.6.0.1
7fa5be440000-7fa5be63f000 ---p 00008000 08:04 34705766                   /usr/lib64/libgif.so.6.0.1
7fa5be63f000-7fa5be640000 r--p 00007000 08:04 34705766                   /usr/lib64/libgif.so.6.0.1
7fa5be640000-7fa5be641000 rw-p 00008000 08:04 34705766                   /usr/lib64/libgif.so.6.0.1
7fa5be641000-7fa5be6b5000 r-xp 00000000 08:04 34705776                   /usr/lib64/libtiff.so.5.3.0
7fa5be6b5000-7fa5be8b4000 ---p 00074000 08:04 34705776                   /usr/lib64/libtiff.so.5.3.0
7fa5be8b4000-7fa5be8b8000 r--p 00073000 08:04 34705776                   /usr/lib64/libtiff.so.5.3.0
7fa5be8b8000-7fa5be8b9000 rw-p 00077000 08:04 34705776                   /usr/lib64/libtiff.so.5.3.0
7fa5be8b9000-7fa5be921000 r-xp 00000000 08:04 34705774                   /usr/lib64/libjpeg.so.8.1.2
7fa5be921000-7fa5beb21000 ---p 00068000 08:04 34705774                   /usr/lib64/libjpeg.so.8.1.2
7fa5beb21000-7fa5beb22000 r--p 00068000 08:04 34705774                   /usr/lib64/libjpeg.so.8.1.2
7fa5beb22000-7fa5beb23000 rw-p 00069000 08:04 34705774                   /usr/lib64/libjpeg.so.8.1.2
7fa5beb23000-7fa5bec5a000 r-xp 00000000 08:04 34139012                   /usr/lib64/libX11.so.6.3.0
7fa5bec5a000-7fa5bee5a000 ---p 00137000 08:04 34139012                   /usr/lib64/libX11.so.6.3.0
7fa5bee5a000-7fa5bee5b000 r--p 00137000 08:04 34139012                   /usr/lib64/libX11.so.6.3.0
7fa5bee5b000-7fa5bee60000 rw-p 00138000 08:04 34139012                   /usr/lib64/libX11.so.6.3.0
7fa5bee60000-7fa5bee69000 r-xp 00000000 08:04 34139018                   /usr/lib64/libXrender.so.1.3.0
7fa5bee69000-7fa5bf068000 ---p 00009000 08:04 34139018                   /usr/lib64/libXrender.so.1.3.0
7fa5bf068000-7fa5bf069000 r--p 00008000 08:04 34139018                   /usr/lib64/libXrender.so.1.3.0
7fa5bf069000-7fa5bf06a000 rw-p 00009000 08:04 34139018                   /usr/lib64/libXrender.so.1.3.0
7fa5bf06a000-7fa5bf100000 r-xp 00000000 08:04 34139090                   /usr/lib64/libfreetype.so.6.12.3
7fa5bf100000-7fa5bf2ff000 ---p 00096000 08:04 34139090                   /usr/lib64/libfreetype.so.6.12.3
7fa5bf2ff000-7fa5bf305000 r--p 00095000 08:04 34139090                   /usr/lib64/libfreetype.so.6.12.3
7fa5bf305000-7fa5bf306000 rw-p 0009b000 08:04 34139090                   /usr/lib64/libfreetype.so.6.12.3
7fa5bf306000-7fa5bf414000 r-xp 00000000 08:04 34139101                   /usr/lib64/libglib-2.0.so.0.4800.2
7fa5bf414000-7fa5bf613000 ---p 0010e000 08:04 34139101                   /usr/lib64/libglib-2.0.so.0.4800.2
7fa5bf613000-7fa5bf614000 r--p 0010d000 08:04 34139101                   /usr/lib64/libglib-2.0.so.0.4800.2
7fa5bf614000-7fa5bf615000 rw-p 0010e000 08:04 34139101                   /usr/lib64/libglib-2.0.so.0.4800.2
7fa5bf615000-7fa5bf616000 rw-p 00000000 00:00 0 
7fa5bf616000-7fa5bf705000 r-xp 00000000 08:04 34705781                   /usr/lib64/libgdiplus.so.0.0.0
7fa5bf705000-7fa5bf904000 ---p 000ef000 08:04 34705781                   /usr/lib64/libgdiplus.so.0.0.0
7fa5bf904000-7fa5bf907000 r--p 000ee000 08:04 34705781                   /usr/lib64/libgdiplus.so.0.0.0
7fa5bf907000-7fa5bf909000 rw-p 000f1000 08:04 34705781                   /usr/lib64/libgdiplus.so.0.0.0
7fa5bf909000-7fa5bf90a000 rw-p 00000000 00:00 0 
7fa5bf90b000-7fa5bf914000 r--s 00000000 08:04 658535                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Collections.Specialized.dll
7fa5bf914000-7fa5bf916000 r--s 00000000 08:04 659278                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.Emit.ILGeneration.dll
7fa5bf916000-7fa5bf918000 r--s 00000000 08:04 658419                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Threading.ThreadPool.dll
7fa5bf918000-7fa5bf919000 ---p 00000000 00:00 0 
7fa5bf919000-7fa5c0119000 rw-p 00000000 00:00 0 
7fa5c0119000-7fa5c011a000 ---p 00000000 00:00 0 
7fa5c011a000-7fa5c011d000 rw-p 00000000 00:00 0 
7fa5c011d000-7fa5c011e000 ---p 00000000 00:00 0 
7fa5c011e000-7fa5c091e000 rw-p 00000000 00:00 0 
7fa5c091e000-7fa5c0921000 r--s 00000000 08:04 658876                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.TypeExtensions.dll
7fa5c0921000-7fa5c0923000 r--s 00000000 08:04 659169                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Threading.Thread.dll
7fa5c0923000-7fa5c0925000 r--s 00000000 08:04 659179                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Globalization.dll
7fa5c0925000-7fa5c0926000 ---p 00000000 00:00 0 
7fa5c0926000-7fa5c1126000 rw-p 00000000 00:00 0 
7fa5c1126000-7fa5c1253000 r--s 00000000 08:04 17535609                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/System.Drawing.Common.Tests.dll
7fa5c1253000-7fa5c1311000 r--s 00000000 08:04 17535607                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/Microsoft.Diagnostics.Runtime.dll
7fa5c1311000-7fa5c15fa000 r--s 00000000 08:04 659172                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.Xml.dll
7fa5c15fa000-7fa5c15fb000 ---p 00000000 00:00 0 
7fa5c15fb000-7fa5c163b000 rw-p 00000000 00:00 0 
7fa5c163b000-7fa5c163c000 ---p 00000000 00:00 0 
7fa5c163c000-7fa5c1e3c000 rw-p 00000000 00:00 0 
7fa5c1e3d000-7fa5c1e3f000 r--s 00000000 08:04 658924                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.IO.dll
7fa5c1e3f000-7fa5c1e41000 r--s 00000000 08:04 658997                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.Extensions.dll
7fa5c1e41000-7fa5c1e43000 r--s 00000000 08:04 658453                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Text.Encoding.Extensions.dll
7fa5c1e43000-7fa5c1e45000 r--s 00000000 08:04 659007                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/Microsoft.Win32.Primitives.dll
7fa5c1e45000-7fa5c1e9e000 r--s 00000000 08:04 658530                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Drawing.Common.dll
7fa5c1e9e000-7fa5c1eaa000 r--s 00000000 08:04 658993                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Drawing.Primitives.dll
7fa5c1eaa000-7fa5c1ecb000 r--s 00000000 08:04 658951                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Net.Requests.dll
7fa5c1ecb000-7fa5c1ed7000 r--s 00000000 08:04 17535602                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/CoreFx.Private.TestUtilities.dll
7fa5c1ed7000-7fa5c1f14000 r--s 00000000 08:04 17535598                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.execution.dotnet.dll
7fa5c1f14000-7fa5c1f1f000 r--s 00000000 08:04 658355                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Diagnostics.TraceSource.dll
7fa5c1f1f000-7fa5c1f2a000 r--s 00000000 08:04 17535597                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/Microsoft.DotNet.XUnitExtensions.dll
7fa5c1f2a000-7fa5c1f3f000 r--s 00000000 08:04 659161                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Net.Primitives.dll
7fa5c1f3f000-7fa5c1fc3000 r--s 00000000 08:04 658912                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Net.Http.dll
7fa5c1fc3000-7fa5c1fd5000 r--s 00000000 08:04 17535595                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.runner.reporters.netcoreapp10.dll
7fa5c1fd5000-7fa5c1fe3000 r--s 00000000 08:04 17535592                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.core.dll
7fa5c1fe3000-7fa5c2004000 r--s 00000000 08:04 659328                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Private.Xml.Linq.dll
7fa5c2004000-7fa5c366f000 r--s 00000000 08:04 34518177                   /usr/share/icu/52.1/icudt52l.dat
7fa5c366f000-7fa5c3872000 r-xp 00000000 08:04 34139114                   /usr/lib64/libicui18n.so.52.1
7fa5c3872000-7fa5c3a72000 ---p 00203000 08:04 34139114                   /usr/lib64/libicui18n.so.52.1
7fa5c3a72000-7fa5c3a7e000 r--p 00203000 08:04 34139114                   /usr/lib64/libicui18n.so.52.1
7fa5c3a7e000-7fa5c3a80000 rw-p 0020f000 08:04 34139114                   /usr/lib64/libicui18n.so.52.1
7fa5c3a80000-7fa5c3a81000 rw-p 00000000 00:00 0 
7fa5c3a81000-7fa5c3a82000 r--p 00000000 08:04 34139113                   /usr/lib64/libicudata.so.52.1
7fa5c3a82000-7fa5c3c81000 ---p 00001000 08:04 34139113                   /usr/lib64/libicudata.so.52.1
7fa5c3c81000-7fa5c3c82000 r--p 00000000 08:04 34139113                   /usr/lib64/libicudata.so.52.1
7fa5c3c82000-7fa5c3deb000 r-xp 00000000 08:04 34139120                   /usr/lib64/libicuuc.so.52.1
7fa5c3deb000-7fa5c3feb000 ---p 00169000 08:04 34139120                   /usr/lib64/libicuuc.so.52.1
7fa5c3feb000-7fa5c3ffb000 r--p 00169000 08:04 34139120                   /usr/lib64/libicuuc.so.52.1
7fa5c3ffb000-7fa5c3ffc000 rw-p 00179000 08:04 34139120                   /usr/lib64/libicuuc.so.52.1
7fa5c3ffc000-7fa5c4000000 rw-p 00000000 00:00 0 
7fa5c4000000-7fa5c4021000 rw-p 00000000 00:00 0 
7fa5c4021000-7fa5c8000000 ---p 00000000 00:00 0 
7fa5c8000000-7fa5c8021000 rw-p 00000000 00:00 0 
7fa5c8021000-7fa5cc000000 ---p 00000000 00:00 0 
7fa5cc000000-7fa5cc021000 rw-p 00000000 00:00 0 
7fa5cc021000-7fa5d0000000 ---p 00000000 00:00 0 
7fa5d0000000-7fa5d0002000 r--s 00000000 08:04 659188                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Reflection.dll
7fa5d0002000-7fa5d0019000 r--s 00000000 08:04 659077                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/netstandard.dll
7fa5d0019000-7fa5d001f000 r--s 00000000 08:04 17535591                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/Microsoft.DotNet.PlatformAbstractions.dll
7fa5d001f000-7fa5d0020000 ---p 00000000 00:00 0 
7fa5d0020000-7fa5d0023000 rw-p 00000000 00:00 0 
7fa5d0023000-7fa5d0024000 ---p 00000000 00:00 0 
7fa5d0024000-7fa5d0028000 rw-p 00000000 00:00 0 
7fa5d0028000-7fa5d002a000 r--s 00000000 08:04 659117                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Threading.Tasks.dll
7fa5d002a000-7fa5d003c000 r--s 00000000 08:04 17535593                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.assert.dll
7fa5d003c000-7fa5d0045000 r--s 00000000 08:04 17535590                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/Microsoft.DotNet.RemoteExecutor.dll
7fa5d0045000-7fa5d0046000 rw-p 00000000 00:00 0 
7fa5d0046000-7fa5d0048000 r--s 00000000 08:04 658448                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Xml.XDocument.dll
7fa5d0048000-7fa5d004a000 r--s 00000000 08:04 658914                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Diagnostics.Debug.dll
7fa5d004a000-7fa5d0080000 r--s 00000000 08:04 17535600                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.runner.utility.netcoreapp10.dll
7fa5d0080000-7fa5d00a2000 r--s 00000000 08:04 659159                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Text.RegularExpressions.dll
7fa5d00a2000-7fa5d00ab000 r--s 00000000 08:04 659076                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Threading.dll
7fa5d00ab000-7fa5d00b2000 r--s 00000000 08:04 659173                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Runtime.InteropServices.dll
7fa5d00b2000-7fa5d00b5000 r--s 00000000 08:04 659127                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Runtime.InteropServices.RuntimeInformation.dll
7fa5d00b5000-7fa5d00c8000 r--s 00000000 08:04 659170                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Collections.Concurrent.dll
7fa5d00c8000-7fa5d00d3000 r-xp 00000000 08:04 659084                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Globalization.Native.so
7fa5d00d3000-7fa5d02d2000 ---p 0000b000 08:04 659084                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Globalization.Native.so
7fa5d02d2000-7fa5d02d3000 r--p 0000a000 08:04 659084                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Globalization.Native.so
7fa5d02d3000-7fa5d02d4000 rw-p 0000b000 08:04 659084                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Globalization.Native.so
7fa5d02d4000-7fa5d02ec000 r--s 00000000 08:04 658522                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Collections.dll
7fa5d02ec000-7fa5d02fb000 r-xp 00000000 08:04 659150                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Native.so
7fa5d02fb000-7fa5d04fa000 ---p 0000f000 08:04 659150                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Native.so
7fa5d04fa000-7fa5d04fb000 r--p 0000e000 08:04 659150                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Native.so
7fa5d04fb000-7fa5d04fc000 rw-p 0000f000 08:04 659150                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Native.so
7fa5d04fc000-7fa5d050f000 r--s 00000000 08:04 658308                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Runtime.Extensions.dll
7fa5d050f000-7fa5d0523000 r--s 00000000 08:04 659184                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.IO.FileSystem.dll
7fa5d0523000-7fa5d0544000 r--s 00000000 08:04 658942                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Linq.dll
7fa5d0544000-7fa5d0557000 r--s 00000000 08:04 658833                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Console.dll
7fa5d0557000-7fa5d0804000 r-xp 00000000 08:04 658499                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libclrjit.so
7fa5d0804000-7fa5d0816000 r--p 002ac000 08:04 658499                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libclrjit.so
7fa5d0816000-7fa5d0818000 rw-p 002be000 08:04 658499                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libclrjit.so
7fa5d0818000-7fa5d083d000 rw-p 00000000 00:00 0 
7fa5d083d000-7fa5d083e000 ---p 00000000 00:00 0 
7fa5d083e000-7fa5d103e000 rw-p 00000000 00:00 0 
7fa5d103e000-7fa5d103f000 ---p 00000000 00:00 0 
7fa5d103f000-7fa5d18b8000 rw-p 00000000 00:00 0 
7fa5d18b8000-7fa5d1bb8000 ---p 00000000 00:00 0 
7fa5d1bb8000-7fa5d1bb9000 ---p 00000000 00:00 0 
7fa5d1bb9000-7fa5d23b9000 rw-p 00000000 00:00 0 
7fa5d23b9000-7fa5d23ba000 ---p 00000000 00:00 0 
7fa5d23ba000-7fa5d2bba000 rw-p 00000000 00:00 0 
7fa5d2bba000-7fa5d2bc4000 r-xp 00000000 08:04 34176305                   /usr/lib64/libnuma.so.1
7fa5d2bc4000-7fa5d2dc4000 ---p 0000a000 08:04 34176305                   /usr/lib64/libnuma.so.1
7fa5d2dc4000-7fa5d2dc5000 r--p 0000a000 08:04 34176305                   /usr/lib64/libnuma.so.1
7fa5d2dc5000-7fa5d2dc6000 rw-p 0000b000 08:04 34176305                   /usr/lib64/libnuma.so.1
7fa5d2dc6000-7fa5d2dc7000 ---p 00000000 00:00 0 
7fa5d2dc7000-7fa5d35c7000 rw-p 00000000 00:00 0 
7fa5d35c7000-7fa5d35c8000 ---p 00000000 00:00 0 
7fa5d35c8000-7fa5d3dc8000 rw-p 00000000 00:00 0 
7fa5d3dc8000-7fa5d3dc9000 ---p 00000000 00:00 0 
7fa5d3dc9000-7fa5d45c9000 rw-p 00000000 00:00 0 
7fa5d45c9000-7fa5d45cf000 r-xp 00000000 08:04 34709651                   /usr/lib64/liburcu-cds.so.2.0.0
7fa5d45cf000-7fa5d47cf000 ---p 00006000 08:04 34709651                   /usr/lib64/liburcu-cds.so.2.0.0
7fa5d47cf000-7fa5d47d0000 r--p 00006000 08:04 34709651                   /usr/lib64/liburcu-cds.so.2.0.0
7fa5d47d0000-7fa5d47d1000 rw-p 00007000 08:04 34709651                   /usr/lib64/liburcu-cds.so.2.0.0
7fa5d47d1000-7fa5d47d8000 r-xp 00000000 08:04 34709649                   /usr/lib64/liburcu-bp.so.2.0.0
7fa5d47d8000-7fa5d49d7000 ---p 00007000 08:04 34709649                   /usr/lib64/liburcu-bp.so.2.0.0
7fa5d49d7000-7fa5d49d8000 r--p 00006000 08:04 34709649                   /usr/lib64/liburcu-bp.so.2.0.0
7fa5d49d8000-7fa5d49d9000 rw-p 00007000 08:04 34709649                   /usr/lib64/liburcu-bp.so.2.0.0
7fa5d49d9000-7fa5d49e2000 r-xp 00000000 08:04 34723917                   /usr/lib64/liblttng-ust-tracepoint.so.0.0.0
7fa5d49e2000-7fa5d4be2000 ---p 00009000 08:04 34723917                   /usr/lib64/liblttng-ust-tracepoint.so.0.0.0
7fa5d4be2000-7fa5d4be3000 r--p 00009000 08:04 34723917                   /usr/lib64/liblttng-ust-tracepoint.so.0.0.0
7fa5d4be3000-7fa5d4be4000 rw-p 0000a000 08:04 34723917                   /usr/lib64/liblttng-ust-tracepoint.so.0.0.0
7fa5d4be4000-7fa5d4bf4000 rw-p 00000000 00:00 0 
7fa5d4bf4000-7fa5d4c47000 r-xp 00000000 08:04 34723919                   /usr/lib64/liblttng-ust.so.0.0.0
7fa5d4c47000-7fa5d4e47000 ---p 00053000 08:04 34723919                   /usr/lib64/liblttng-ust.so.0.0.0
7fa5d4e47000-7fa5d4e4a000 r--p 00053000 08:04 34723919                   /usr/lib64/liblttng-ust.so.0.0.0
7fa5d4e4a000-7fa5d4e50000 rw-p 00056000 08:04 34723919                   /usr/lib64/liblttng-ust.so.0.0.0
7fa5d4e50000-7fa5d4e9d000 r-xp 00000000 08:04 659167                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclrtraceptprovider.so
7fa5d4e9d000-7fa5d509d000 ---p 0004d000 08:04 659167                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclrtraceptprovider.so
7fa5d509d000-7fa5d50de000 r--p 0004d000 08:04 659167                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclrtraceptprovider.so
7fa5d50de000-7fa5d50df000 rw-p 0008e000 08:04 659167                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclrtraceptprovider.so
7fa5d50df000-7fa5d50e6000 r-xp 00000000 08:04 50332501                   /lib64/librt-2.22.so
7fa5d50e6000-7fa5d52e5000 ---p 00007000 08:04 50332501                   /lib64/librt-2.22.so
7fa5d52e5000-7fa5d52e6000 r--p 00006000 08:04 50332501                   /lib64/librt-2.22.so
7fa5d52e6000-7fa5d52e7000 rw-p 00007000 08:04 50332501                   /lib64/librt-2.22.so
7fa5d52e7000-7fa5d5534000 r-xp 00000000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d5534000-7fa5d5535000 rwxp 0024d000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d5535000-7fa5d581e000 r-xp 0024e000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d581e000-7fa5d581f000 r--p 00537000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d581f000-7fa5d59d2000 r-xp 00538000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d59d2000-7fa5d59d3000 ---p 006eb000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d59d3000-7fa5d5a21000 r--p 006eb000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d5a21000-7fa5d5a2b000 rw-p 00739000 08:04 658822                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libcoreclr.so
7fa5d5a2b000-7fa5d5a6a000 rw-p 00000000 00:00 0 
7fa5d5a6a000-7fa5d5aad000 r-xp 00000000 08:04 658415                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libhostpolicy.so
7fa5d5aad000-7fa5d5cad000 ---p 00043000 08:04 658415                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libhostpolicy.so
7fa5d5cad000-7fa5d5cae000 r--p 00043000 08:04 658415                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libhostpolicy.so
7fa5d5cae000-7fa5d5caf000 rw-p 00044000 08:04 658415                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/libhostpolicy.so
7fa5d5caf000-7fa5d5cfc000 r-xp 00000000 08:04 16970919                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/host/fxr/5.0.0/libhostfxr.so
7fa5d5cfc000-7fa5d5efb000 ---p 0004d000 08:04 16970919                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/host/fxr/5.0.0/libhostfxr.so
7fa5d5efb000-7fa5d5efc000 r--p 0004c000 08:04 16970919                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/host/fxr/5.0.0/libhostfxr.so
7fa5d5efc000-7fa5d5efd000 rw-p 0004d000 08:04 16970919                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/host/fxr/5.0.0/libhostfxr.so
7fa5d5efd000-7fa5d6099000 r-xp 00000000 08:04 50332460                   /lib64/libc-2.22.so
7fa5d6099000-7fa5d6298000 ---p 0019c000 08:04 50332460                   /lib64/libc-2.22.so
7fa5d6298000-7fa5d629c000 r--p 0019b000 08:04 50332460                   /lib64/libc-2.22.so
7fa5d629c000-7fa5d629e000 rw-p 0019f000 08:04 50332460                   /lib64/libc-2.22.so
7fa5d629e000-7fa5d62a2000 rw-p 00000000 00:00 0 
7fa5d62a2000-7fa5d62b9000 r-xp 00000000 08:04 50332473                   /lib64/libgcc_s.so.1
7fa5d62b9000-7fa5d64b8000 ---p 00017000 08:04 50332473                   /lib64/libgcc_s.so.1
7fa5d64b8000-7fa5d64b9000 r--p 00016000 08:04 50332473                   /lib64/libgcc_s.so.1
7fa5d64b9000-7fa5d64ba000 rw-p 00017000 08:04 50332473                   /lib64/libgcc_s.so.1
7fa5d64ba000-7fa5d65b5000 r-xp 00000000 08:04 50332479                   /lib64/libm-2.22.so
7fa5d65b5000-7fa5d67b5000 ---p 000fb000 08:04 50332479                   /lib64/libm-2.22.so
7fa5d67b5000-7fa5d67b6000 r--p 000fb000 08:04 50332479                   /lib64/libm-2.22.so
7fa5d67b6000-7fa5d67b7000 rw-p 000fc000 08:04 50332479                   /lib64/libm-2.22.so
7fa5d67b7000-7fa5d6932000 r-xp 00000000 08:04 34201549                   /usr/lib64/libstdc++.so.6.0.25
7fa5d6932000-7fa5d6b32000 ---p 0017b000 08:04 34201549                   /usr/lib64/libstdc++.so.6.0.25
7fa5d6b32000-7fa5d6b3c000 r--p 0017b000 08:04 34201549                   /usr/lib64/libstdc++.so.6.0.25
7fa5d6b3c000-7fa5d6b3e000 rw-p 00185000 08:04 34201549                   /usr/lib64/libstdc++.so.6.0.25
7fa5d6b3e000-7fa5d6b41000 rw-p 00000000 00:00 0 
7fa5d6b41000-7fa5d6b43000 r-xp 00000000 08:04 50332471                   /lib64/libdl-2.22.so
7fa5d6b43000-7fa5d6d43000 ---p 00002000 08:04 50332471                   /lib64/libdl-2.22.so
7fa5d6d43000-7fa5d6d44000 r--p 00002000 08:04 50332471                   /lib64/libdl-2.22.so
7fa5d6d44000-7fa5d6d45000 rw-p 00003000 08:04 50332471                   /lib64/libdl-2.22.so
7fa5d6d45000-7fa5d6d5d000 r-xp 00000000 08:04 50332498                   /lib64/libpthread-2.22.so
7fa5d6d5d000-7fa5d6f5c000 ---p 00018000 08:04 50332498                   /lib64/libpthread-2.22.so
7fa5d6f5c000-7fa5d6f5d000 r--p 00017000 08:04 50332498                   /lib64/libpthread-2.22.so
7fa5d6f5d000-7fa5d6f5e000 rw-p 00018000 08:04 50332498                   /lib64/libpthread-2.22.so
7fa5d6f5e000-7fa5d6f62000 rw-p 00000000 00:00 0 
7fa5d6f62000-7fa5d6f83000 r-xp 00000000 08:04 50332452                   /lib64/ld-2.22.so
7fa5d6f83000-7fa5d6f85000 r--s 00000000 08:04 658835                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Buffers.dll
7fa5d6f85000-7fa5d6f91000 r--s 00000000 08:04 659013                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Memory.dll
7fa5d6f91000-7fa5d6f97000 r--s 00000000 08:04 17535601                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.abstractions.dll
7fa5d6f97000-7fa5d6fa0000 r--s 00000000 08:04 659190                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Runtime.dll
7fa5d6fa0000-7fa5d6fc6000 r--s 00000000 08:04 17535588                   /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec/xunit.console.dll
7fa5d6fc6000-7fa5d6fc7000 ---p 00000000 00:00 0 
7fa5d6fc7000-7fa5d6fca000 rw-p 00000000 00:00 0 
7fa5d6fca000-7fa5d6fcb000 ---p 00000000 00:00 0 
7fa5d6fcb000-7fa5d700b000 rw-p 00000000 00:00 0 
7fa5d700b000-7fa5d700c000 ---p 00000000 00:00 0 
7fa5d700c000-7fa5d701f000 rw-p 00000000 00:00 0 
7fa5d701f000-7fa5d7020000 ---p 00000000 00:00 0 
7fa5d7020000-7fa5d7149000 rw-p 00000000 00:00 0 
7fa5d7149000-7fa5d714a000 ---p 00000000 00:00 0 
7fa5d714a000-7fa5d714d000 rw-p 00000000 00:00 0 
7fa5d714d000-7fa5d714e000 ---p 00000000 00:00 0 
7fa5d714e000-7fa5d7151000 rw-p 00000000 00:00 0 
7fa5d7151000-7fa5d7160000 ---p 00000000 00:00 0 
7fa5d7160000-7fa5d7168000 rw-p 00000000 00:00 0 
7fa5d7168000-7fa5d7171000 ---p 00000000 00:00 0 
7fa5d7171000-7fa5d717a000 rw-p 00000000 00:00 0 
7fa5d717a000-7fa5d717c000 r--s 00000000 08:04 658525                     /home/helixbot/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Payload/shared/Microsoft.NETCore.App/5.0.0/System.Runtime.Loader.dll
7fa5d717c000-7fa5d717d000 ---p 00000000 00:00 0 
7fa5d717d000-7fa5d717e000 ---p 00000000 00:00 0 
7fa5d717e000-7fa5d7181000 rw-p 00000000 00:00 0 
7fa5d7181000-7fa5d7182000 r--s 00000000 00:14 30333                      /dev/shm/lttng-ust-wait-6-1000
7fa5d7182000-7fa5d7183000 r--s 00000000 00:14 29643                      /dev/shm/lttng-ust-wait-6
7fa5d7183000-7fa5d7184000 r--p 00021000 08:04 50332452                   /lib64/ld-2.22.so
7fa5d7184000-7fa5d7185000 rw-p 00022000 08:04 50332452                   /lib64/ld-2.22.so
7fa5d7185000-7fa5d7186000 rw-p 00000000 00:00 0 
7ffdff731000-7ffdff752000 rw-p 00000000 00:00 0                          [stack]
7ffdff798000-7ffdff79b000 r--p 00000000 00:00 0                          [vvar]
7ffdff79b000-7ffdff79d000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
./RunTests.sh: line 161:  2571 Aborted                 (core dumped) "$RUNTIME_PATH/dotnet" exec --runtimeconfig System.Drawing.Common.Tests.runtimeconfig.json xunit.console.dll System.Drawing.Common.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=nonnetcoreapptests -notrait category=nonlinuxtests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing $RSP_FILE
~/work/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/Work/a7b3d572-ab2a-4375-af7b-e53d5c98fa60/Exec
----- end Wed Oct 9 04:05:37 UTC 2019 ----- exit code 134 ----------------------------------------------------------
exit code 134 means SIGABRT Abort. Managed or native assert, or runtime check such as heap corruption, caused call to abort(). Core dumped.
```
**Build:**
[20191008.53](https://dnceng.visualstudio.com/public/_build/results?buildId=382413)(Master)

**Details:**
https://helix.dot.net/api/2019-06-17/jobs/fd126e26-4e15-4d8d-b7ce-e08ef6f5adea/workitems/System.Drawing.Common.Tests/console
</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41674</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove obsolete CodeCoverageAssemblyAttribute</Title>
    <Description>We don't need this attribute anymore as with Coverlet we are white-listing assemblies instead of black-listing.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41673</IssueID>
    <RepoID>1</RepoID>
    <Title>TLS 1.2 The handshake failed due to an unexpected packet format</Title>
    <Description>We have an environment where we always get the error "One or more errors occurred. (The SSL connection could not be established, see inner exception.): The handshake failed due to an unexpected packet format". If you use the switch `AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", false)`, then there is no problem with the connection setup. 
It happens with a netcoreapp3.0.

```csharp
for (int i = 0; i &lt; 4; i++)
{
   var client = new HttpClient();
   var result = Task.Run(()=&gt;client.GetAsync(@"https://hubfe.solutiondocondemand.com/solutiondoc_hub.asmx?wsdl")).Result;
   result.EnsureSuccessStatusCode();
   Console.WriteLine("returned Ok");
}
```
Mostly the error happens in the second and the forth call
</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41671</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Vector APIs for cross product for 2D/4D</Title>
    <Description>Here is the pull request with only the addition of the two new methods as discussed.

Fixes #35434</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41670</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr,corert</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr,corert


**Please REBASE this PR when merging**

 cc @EgorBo</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41669</IssueID>
    <RepoID>1</RepoID>
    <Title>.Net Core 2.2 Memory</Title>
    <Description>.Net Core 2.2 API
Memory
https://imgur.com/Gri252Z

.Net Core 2.2 Console 安裝 https://www.nuget.org/packages/Quartz/
Memory
https://imgur.com/sZ2KSuX

.Net Core 2.2 Razor Page 和 MVC
Memory
https://imgur.com/53J9bUg

我有設定 csproj ，Memory 上漲速度有減緩但依舊無法停止每天上漲的 Memory，都不會降下來
`
&lt;ServerGarbageCollection&gt;false&lt;/ServerGarbageCollection&gt;
`

.Net Core 3.0 初始API 也有此狀況 , 記憶體不會下降到原本
https://imgur.com/lavFW6r

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>12/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41668</IssueID>
    <RepoID>1</RepoID>
    <Title>XML signature fails to verify</Title>
    <Description>An XML signature in a SAML response fails to verify using System.Security.Cryptography.Xml.SignedXml.

I believe the XML signature should verify as it does when using a Java application.

The attached zip includes:

samlresponse-fails.xml - signed XML that fails to verify
samlresponse-verifies.xml - signed XML that does verify, for comparison

Program.cs - .NET Core console application demonstrating the problem
VerifySignature.java - Java application that can successfully verify the signatures for both files

The samlresponse-fails.xml includes a SAML response that's signed and a SAML assertion that's also signed. It's the SAML response signature that fails to verify in the .NET Core console application but does verify in the Java application.

The samlresponse-verifies.xml includes a SAML response that's signed and this verifies in both the .NET Core console application and the Java application.

The .NET Core console application was built using .NET Core 3.0 and System.Security.Cryptography.Xml v4.6.

dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100
 Commit:    04339c3a26

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100\

[xml-signature-issue.zip](https://github.com/dotnet/corefx/files/3705136/xml-signature-issue.zip)

</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41667</IssueID>
    <RepoID>1</RepoID>
    <Title>Suggestion: Give warning/error if model attribute will have no effect such as Newtonsoft [JsonIgnore] Being Replaced in .NET Core 3.0</Title>
    <Description>Is it possible to consider giving a warning if a Model Attribute is not valid?

An example is that `[JsonIgnore]` used `using Newtonsoft.Json;` in .NET Core 2.2 but in .NET Core 3.0 this was removed so the `[JsonIgnore]` attribute then had no effect but generates no errors or warnings.

The fix is to switch the using statement to:
```
using System.Text.Json;
using System.Text.Json.Serialization;
```

However it would be good if the serializer could support attributes to check validity helping to track down issues and save having to debug the compiled program.</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41666</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @CoffeeFlux</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41665</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Net.WebHeaderCollection for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41663</IssueID>
    <RepoID>1</RepoID>
    <Title>Support using ICU when running on Windows </Title>
    <Description>Windows 10 now carrying a version of ICU. It will be good to allow .NET Core take advantage of that.

**Goals** 

There are 2 goals which if we do will get us in the much better position regarding the globalization support. 

- Allow using the installed Windows version of ICU when running on Windows 10 19H1 and up. 
- Allow using the app ICU version which the app carry with. 

Doing these 2 goals will give the flexibility to the apps to decide if want to use whatever ICU version shipping with Windows or decide to carry its own version of ICU.  

**How we can support ICU on Windows** 

- We'll merge System.Globalization.Native code to coreclr and include this code for Windows build too. System.Globalization.Native has the ICU interop.
- Adding a shim to load the ICU libraries like what we are doing on Linux, but we’ll try to load it from different places (From System32 folder or app folder for Windows). 
- Having the inteop cs code which is compiled for Linux to be included for Windows too. Of course, we must refactor the current code more and instead of having Windows and Linux cs files, we’ll have NLS and ICU code paths instead. 

**Loading Default installed ICU on Windows** 

Windows RS2 started carrying ICU. The ICU DLLs are installed on %WINDIR%\System32 folder.  
On RS2, there are 2 DLLs installed there named icuuc.dll and icuin.dll. On 19H1, Windows combined these 2 DLLs into a single DLL named icu.dll. 
We'll support the loading ICU on Windows starting from 19H1 version and up. The reason is the previous versions require COM initialization which can cause some issues.

**NLS or ICU as a default?** 

We'll use ICU by default as this is the future direction and we want to get users switch to that. Of course this will be kind of breaking change especially for sorting  behavior and locale data. We are going to provide a config switch to allow using NLS if any app wanted to switch back to the old behavior.

**Loading non-ICU default libraries** 

As the second goal is to allow using a specific version of ICU which not necessary the same version shipped with Windows. We are working with Windows team to have them produce ICU NuGet package which apps can get and install with their app (under the app folder). The apps will install it under the app folder for the reasons:  

- Not try to access any files outside the app folder. That will be more secure. 
- The app can be self-contained and possibly can get the ICU package work seamlessly with the .NET Core csproj which will place the ICU DLLs under the app published folder. 

The app can opt-in to the app version using the config switch. We’ll try to find the libraries under the app folder according to the layout decided by NuGet package. 
The ICU NuGet package will support running on down level Windows versions (e.g. Windows 7). That can give advantage of using ICU there too. 

**Config Switch**  

We need the config switch for 2 reasons:  

To opt-in/out to or from using ICU/NLS. 
To opt-in use the local app ICU version instead of the global version. 

Note, we can have this switch work on Linux too. so, we’ll allow apps to carry their own ICU version if they need to. 

The suggesting is to have a config switch named System.Globalization.ICU and will have the possible values:  

- None 		means use the ICU (default value). 
- NLS	        means use NLS APIs and not ICU. this value will be supported on Windows only. 
- Local		use app local version (maybe we need to specify the version in the value but need some more investigation about that). 

We’ll support the switch through environment variable too called DOTNET_SYSTEM_GLOBALIZATION_ICU. 

**Falling back**  

- If the app didn't opt-in to use NLS and we fail to load the ICU libraries, we’ll fallback to NLS APIs
- If the app opt-in to use local app version of ICU and failed to load it, we'll fail the app and fail fast. 

**Invariant Mode**  

 If the globalization invariant mode is enabled, we honor it and will not try to load ICU at all. 
</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41662</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add Mutex, Semaphore, and EventWaitHandle creation extension methods that take an ACL</Title>
    <Description>### Summary

Similar to #41614, we don't currently have a way to create a synchronization object with a given ACL in .NET Core. We can modify the ACL, but it would be more secure to have the proper ACL on the object from the start.

The related ACLs are already exposed in the `System.Threading.AccessControl` assembly , we should add creation extension methods to the existing `ThreadingAclExtensions`.

### Proposal

Add the following three creation methods to the existing `ThreadingAclExtensions` class in the `System.Threading.AccessControl` assembly:

``` C#
namespace System.Threading
{
    public static class ThreadingAclExtensions
    {
        // Add
        public static EventWaitHandle CreateEventWaitHandle(
            this EventWaitHandleSecurity eventSecurity
            bool initialState,
            EventResetMode mode,
            string name,
            out bool createdNew);

        public static Mutex CreateMutex(
            this MutexSecurity mutexSecurity,
            bool initiallyOwned,
            string name,
            out bool createdNew);

        public static Semaphore CreateSemaphore(
            this SemaphoreSecurity semaphoreSecurity,
            int initialCount,
            int maximumCount,
            string name,
            out bool createdNew);

        // Existing
        public static EventWaitHandleSecurity GetAccessControl(this EventWaitHandle handle);
        public static void SetAccessControl(this EventWaitHandle handle, EventWaitHandleSecurity eventSecurity);
        public static MutexSecurity GetAccessControl(this Mutex mutex);
        public static void SetAccessControl(this Mutex mutex, MutexSecurity mutexSecurity);
        public static SemaphoreSecurity GetAccessControl(this Semaphore semaphore);
        public static void SetAccessControl(this Semaphore semaphore, SemaphoreSecurity semaphoreSecurity);
    }
}
```

### Details

These primitives live in CoreLib.

We **can not** support creating unnamed objects without adding new constructors to the types. With names, we can create and then call the open existing methods. If we want to support unnamed I would suggest we add new `OpenExisting()` overloads that take the handle that our extension methods create. It may not be critical as you need the handle to the unnamed object, so discrete ACL setting should be ok...

### Related Issues

#41614 API Proposal: Add file and directory creation methods that take an ACL

CC: @danmosemsft, @ericstj, @terrajobst, @kouvel</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41661</IssueID>
    <RepoID>1</RepoID>
    <Title>(WIP of #41002) Add support for Reference Handling on Deserialization.</Title>
    <Description>Add support for metadata properties ($id, $ref and $values) used for reference handling on Deserialization.

This is a work in progress and as such, some things in the implementation are still missing, like correctly handling exception messages, property names, etc.

The main purpose of this PR for me is to validate with the area owners if I am on the right path on the prototype/implementation.

This PR only covers the Read or Deserializaiton part, I will address Write/Serialization in a separate PR.
</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41660</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Handle "too small" success from CNG and clear out decryption residuals.</Title>
    <Description>* When NCryptEncrypt or NCryptDecrypt reports success with a cbResult value that doesn't make sense, normalize the error to NTE_BUFFER_TOO_SMALL.
* When resizing arrays for the array-returning implementation, clear out the temporary arrays to reduce the amount of time they're sitting in memory before the GC clears the memory for reissuance.

Port of #41331 to release/3.0.
Undoes #41360 (because it fixed the tests).</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41659</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.1] Handle "too small" success from CNG and clear out decryption residuals.</Title>
    <Description>* When NCryptEncrypt or NCryptDecrypt reports success with a cbResult value that doesn't make sense, normalize the error to NTE_BUFFER_TOO_SMALL.
* When resizing arrays for the array-returning implementation, clear out the temporary arrays to reduce the amount of time they're sitting in memory before the GC clears the memory for reissuance.

Port of #41331 to release/2.1.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41658</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTPS Proxy support feature requests</Title>
    <Description>Hello,
As the support of HTTPS proxies is becoming more common, we need to execute HTTP and HTTPS requests through an HTTPS proxy.

To be clear, this is not about executing an HTTPS request through an HTTP proxy (which works well), it is about connecting to the proxy itself using HTTPS.

As an additional requirement, we are also supposed to authenticate the client using client certificates.

When I try to use a proxy created from an https URI
```c#
            HttpClientHandler handler = new HttpClientHandler();
            handler.Proxy = new WebProxy("https://127.0.0.1");
            HttpClient client = new HttpClient(handler);
```
I receive an `Only the 'http' scheme is allowed for proxies.` `NotSupportedException`.

I found some indication at https://github.com/dotnet/corefx/issues/20435 that this is not supported at all, so I am reopening this as a feature request.

Thanks</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41657</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add pipe creation extension methods that take an ACL</Title>
    <Description>### Summary

Similar to #41614, we don't currently have a way to create a pipe with a given ACL in .NET Core. We can modify the ACL, but it would be more secure to have the proper ACL on the pipe from the start.

The Pipe ACL `PipeSecurity` is already exposed in the `System.IO.Pipes` assembly , we should add creation extension methods to the existing `PipesAclExtensions`.

### Proposal

Add the following two creation methods to the existing `PipesAclExtensions` class in the `System.IO.Pipes` assembly:

``` C#
namespace System.IO.Pipes
{
    public static class PipesAclExtensions
    {
        // Add
        public AnonymousPipeServerStream CreateAnonymousPipeServerStream(
            this PipeSecurity pipeSecurity
            PipeDirection direction,
            HandleInheritability inheritability,
            int bufferSize);

        public NamedPipeServerStream CreateNamedPipeServerStream(
            this PipeSecurity pipeSecurity
            string pipeName,
            PipeDirection direction,
            int maxNumberOfServerInstances,
            PipeTransmissionMode transmissionMode,
            PipeOptions options,
            int inBufferSize,
            int outBufferSize,
            HandleInheritability inheritability = HandleInheritability.None,
            PipeAccessRights additionalAccessRights = default);

        // Existing
        public static PipeSecurity GetAccessControl(this PipeStream stream);
        public static void SetAccessControl(this PipeStream stream, PipeSecurity pipeSecurity);
    }
}
```

### Details

Since these are already in the same assembly as the modified types it should be pretty straight-forward to implement.

### Related Issues

#41614 API Proposal: Add file and directory creation methods that take an ACL

CC: @danmosemsft, @ericstj, @terrajobst</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41656</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix NRE when context value is null in method Save from Principal class</Title>
    <Description>Related to #41655

Please review.
Thank you in advance</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41655</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException in System.DirectoryServices.AccountManagement</Title>
    <Description>In method `Save` from `Principal` class, the `context` object was used before it was verified against null:

https://github.com/dotnet/corefx/blob/7c586d32edce94c910fc8b402f4adedaa3cf05fd/src/System.DirectoryServices.AccountManagement/src/System/DirectoryServices/AccountManagement/Principal.cs#L340-L350

The null value for the context parameter is invalid and we are expecting InvalidOperationException.

This code will generate `NullReferenceException` when

```csharp
GroupPrincipal groupPrincipal 
  = new GroupPrincipal(new PrincipalContext(ContextType.Machine));
groupPrincipal.Save(null);
```
Context:
System.DirectoryServices.AccountManagement v4.6.0</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41654</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Port `MemoryMappedFileSecurity` and add extensions for `MemoryMappedFile`</Title>
    <Description>### Summary

We did not port `System.IO.MemoryMappedFiles.MemoryMappedFileSecurity` to Core as it wasn't cross-plat. There is still a need to set security on memory mapped files for Windows, just as there is for files/directories/etc. We should port these to `System.IO.FileSystem.AccessControl` and add extension methods for `MemoryMappedFile` there so Windows specific codebases can be ported and retain their security model.

### Proposal

Port the following types from .NET Framework to Core and add them to `System.IO.FileSystem.AccessControl`:

``` C#
namespace System.IO.MemoryMappedFiles
{
    // See enum's full definition in .NET Framework
    [Flags]
    public enum MemoryMappedFileRights;

    public class MemoryMappedFileSecurity : ObjectSecurity&lt;MemoryMappedFileRights&gt; 
    {
        public MemoryMappedFileSecurity();
    }
}
```

Add the following extension methods for  `MemoryMappedFile` to System.IO.FileSystemAclExtensions:

``` C#
namespace System.IO
{
    public static class FileSystemAclExtensions
    {
        public static MemoryMappedFile CreateFromFile(
            this MemoryMappedFileSecurity memoryMappedFileSecurity,
            FileStream fileStream,
            string mapName,
            long capacity,
            MemoryMappedFileAccess access,
            HandleInheritability inheritability,
            bool leaveOpen);

        public static MemoryMappedFile CreateNew(
            this MemoryMappedFileSecurity memoryMappedFileSecurity,
            string mapName,
            long capacity,
            MemoryMappedFileAccess access,
            MemoryMappedFileOptions options,
            HandleInheritability inheritability);

        public static MemoryMappedFile CreateOrOpenMappedFile(
            this MemoryMappedFileSecurity memoryMappedFileSecurity,
            string mapName,
            long capacity,
            MemoryMappedFileAccess access,
            MemoryMappedFileOptions options,
            HandleInheritability inheritability);

        public static MemoryMappedFileSecurity GetAccessControl(
            this MemoryMappedFile memoryMappedFile);

        public static void SetAccessControl(
            this MemoryMappedFile memoryMappedFile,
            MemoryMappedFileSecurity memoryMappedFileSecurity);
    }
}
```

### Details

We could create a new extensions class, but this still can logically fit with "file system". Same goes for the assembly- there isn't enough value in creating a new assembly for this.

Creating a non-extension static class is also possible, but I'd rather try to come up with a more generic security model that can abstract platform differences and add a more x-plat friendly model. Hanging platform specific helpers off of platform specific types contains this somewhat.

I didn't make more descriptive names as these match exactly with what is missing on `MemoryMappedFile`. Theory is it helps discovery.

Note that the implementation of `MemoryMappedFileSecurity` is trivial, it adds nothing to `ObjectSecurity&lt;T&gt;` other than the `T`. Implementing the extension methods is a little more complicated- we may want to try and factor out a more generic set of `CreateFile` helpers that take `NativeObjectSecurity` to reduce duplication.

### Related Issues

#29546 MemoryMappedFile is missing CreateFromFile overload that takes MemoryMappedFileSecurity
#41614 API Proposal: Add file and directory creation methods that take an ACL

CC: @danmosemsft, @ericstj, @terrajobst</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41653</IssueID>
    <RepoID>1</RepoID>
    <Title>Support JsonConverterAttribute on enumerable properties</Title>
    <Description>Addresses issue where the `JsonConverterAttribute` doesn't work when applied to an enumerable property. See https://github.com/dotnet/corefx/issues/41425.

This is expected to be ported to 3.1 since it is blocking scenarios.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41651</IssueID>
    <RepoID>1</RepoID>
    <Title>Simple HKDF implementation</Title>
    <Description>Simple, non-spanified HKDF implementation as a starting point for #29660 </Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41650</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Drawbacks of setting HttpClient.Timeout = Timeout.InfiniteTimespan?</Title>
    <Description>Query for HttpClient folks:

gRPC can have long running streaming calls. A streaming call might not return any response for over 100 seconds, which then triggers a cancellation based on `HttpClient.Timeout`.

I am considering setting `HttpClient.Timeout` to `Timeout.InfiniteTimespan` when the gRPC channel's internal HttpClient is created. What drawbacks to this that I should be aware of? Is this recommended?

Note: gRPC has its own mechanism for timeouts called [deadlines](https://grpc.io/blog/deadlines/). Deadline is the standardized way of limiting the duration of unresponsive gRPC calls. I would like developers to only think about setting a deadline and not think about it AND `HttpClient.Timeout`. There is no deadline by default.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41649</IssueID>
    <RepoID>1</RepoID>
    <Title>Creating custom TimeZoneInfo from existing TimeZoneInfo in Ubuntu fails</Title>
    <Description>I was trying to create custom time zones from the time zones returned by `TimeZoneInfo.GetSystemTimeZones()` in Ubuntu. I got "System.InvalidTimeZoneException: The elements of the AdjustmentRule array must be in chronological order and must not overlap." exception.

This is the simplified version of my code:
```csharp
IList&lt;TimeZoneInfo&gt; customТimeZones = new List&lt;TimeZoneInfo&gt;();
foreach (var timezone in TimeZoneInfo.GetSystemTimeZones())
{
	customТimeZones.Add(
		TimeZoneInfo.CreateCustomTimeZone(
			timezone.Id,
			timezone.BaseUtcOffset,
			timezone.DisplayName,
			timezone.DisplayName,
			timezone.DaylightName,
			timezone.GetAdjustmentRules()));
}
```

I see two potential problems:
1. In Windows `AdjustmentRule.DateStart` of the next rule is always one day after `AdjustmentRule.DateEnd` of the last rule. In Ubuntu they are the same.
Windows:
![Mountain Standard Time Windows](https://user-images.githubusercontent.com/7841361/66427552-373aec80-e9e2-11e9-8d1f-8d95fc4fe824.jpg)

Ubuntu:
![Mountain Standard Time Ubuntu1](https://user-images.githubusercontent.com/7841361/66427562-3bffa080-e9e2-11e9-8a44-0dc2647031c5.jpg)

2. Some of the rules in Ubuntu are messy. For example, "America/Phoenix" has 12 adjustment rules, but there is no continuity after zone with DateEnd = {1/1/1944 12:00:00 AM}. Next zones overlap each other:
![Mountain Standard Time Ubuntu](https://user-images.githubusercontent.com/7841361/66427589-4e79da00-e9e2-11e9-94b7-c7b28d970253.jpg)

</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41664</IssueID>
    <RepoID>1</RepoID>
    <Title>[Feature request] A way to customize the line separator in StringBuilder</Title>
    <Description>Right now it's impossible to get consistent behavior across platforms. Which is kind of important when working with file formats or network protocols that are sensitive to the line separator.

A commonly used workaround is an extension method like:
```cs
public static StringBuilder AppendLineLf(this StringBuilder sb, string line)
   =&gt; sb.Append(line).Append('\n');
```
but this approach can't be used when we are passing the StringBuilder to a library from nuget.

The proposal is to add a separate constructor that accepts a line separator.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41648</IssueID>
    <RepoID>1</RepoID>
    <Title>EnumMemberAttribute support</Title>
    <Description>1. Added support for using EnumMemberAttribute with JsonStringEnumConverter to change the value written/read from JSON when processing enums.

Example:
```csharp
        [JsonConverter(typeof(JsonStringEnumConverter))]
        public enum MyCustomEnum
        {
            First = 1,
            Second = 2,
            [EnumMember(Value = "third value")]
            Third = 3
        }
```
In that example MyCustomEnum.Third will round-trip as "third value" in JSON.

This gives System.Text.Json parity with Json.Net wrt Enums.

2. Fixed JsonNamingPolicy round-trip issue.

If for some reason you define a JsonNamingPolicy that builds values Enum.Parse won't understand, than enums won't round-trip.

Example:
```csharp
        internal class JsonUpperInvariantWithUnderscoreNamingPolicy : JsonNamingPolicy
        {
            public override string ConvertName(string name) =&gt; $"_{name.ToUpperInvariant()}";
        }
```

That JsonNamingPolicy will create values during serialization that won't be understood during deserialization.

# Issues
Resolves https://github.com/dotnet/corefx/issues/41578</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41647</IssueID>
    <RepoID>1</RepoID>
    <Title>Prevent ImplicitTransform of index getter method (#41418)</Title>
    <Description>## Description

Cherry-pick of #41418 to release/3.1

Fix for the exception thrown in dotnet/coreclr#26890 that is a fallout of the issue being fixed in `DiagnosticSourceEventSource` in conjunction with aspnet/AspNetCore#11730.

&lt;details&gt;
    &lt;summary&gt;small repro (click to expand)&lt;/summary&gt;

---
Attach `dotnet trace` to this app and turn on the `Microsoft-Diagnostics-DiagnosticSource` provider.

```csharp
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine($"PID: {System.Diagnostics.Process.GetCurrentProcess().Id}");
            var diagnosticListener = new DiagnosticListener("MySource");
            while (true)
            {
                Console.Write("&gt;");
                var input = Console.ReadLine();
                if (input == "exit")
                    break;

                diagnosticListener.Write("MyEvent", new List&lt;int&gt; { 1, 2, 3 });
            }
        }
    }
```
---
&lt;/details&gt;

### Root Cause of Exception:
The getter for the implicit `Item` property for the index operator takes an argument, and `DiagnosticSourceEventSource` makes the assumption that property getters don't take arguments.  It tries to bind the resulting delegate of type `[retval] get_Item(int32 index)` to the type `Func&lt;TObject, TProperty&gt;` so the binding fails and we get the exception you see in dotnet/coreclr#26890.

This change prevents `DiagnosticSourceEventSource` from attempting to serialize the implicit `Item` property by blocking index getters.

## Customer Impact

ASP.NET Core has used `DiagnosticSourceEventSource` for their eventing.  Since they changed their event types to inherit from `IReadOnlyCollection` in 3.0, they will all hit the exception in dotnet/coreclr#26890 when turned on causing a bad diagnostic experience if you do not explicitly specify a transform.

## Regression

I don't believe this is a regression as the code existed in the 2.0 time frame as well, but it was rarely encountered.  The difference now being that after aspnet/AspNetCore#11730, the behavior is being hit routinely by ASP.NET Core when diagnosing an MVC app.

## Risk

Minimal.  This code prevents an exception from being thrown and prevents bad behavior without changing expected behavior.

## Tests

A test were added to validate that this change prevents the implicit index getter from being serialized.

CC - @tommcdon @noahfalk </Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41645</IssueID>
    <RepoID>1</RepoID>
    <Title>Http/2 support for HttpWebRequest</Title>
    <Description>Http/2 has been supported in HttpClient. The underlying implementation of HttpWebRequest is HttpClient. However, HttpWebRequest does not support Http/2.

https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/

![image](https://user-images.githubusercontent.com/5714438/66382556-052f8780-e9ee-11e9-852c-e704c516b1b9.png)

https://github.com/dotnet/corefx/blob/5ad15fcb189a9c232051d03c1e889f985f62232b/src/System.Net.Requests/src/System/Net/HttpWebRequest.cs#L1156-L1243

https://github.com/dotnet/corefx/blob/5ad15fcb189a9c232051d03c1e889f985f62232b/src/System.Net.Requests/src/System/Net/HttpWebRequest.cs#L816-L844

https://github.com/dotnet/corefx/blob/5ad15fcb189a9c232051d03c1e889f985f62232b/src/System.Net.HttpListener/src/System/Net/Windows/HttpListenerResponse.Windows.cs#L80-L97
</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41644</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException when Deserializing with null PropertyNamingPolicy option</Title>
    <Description>Deserializing a complex object (I could not replicate the error with a dummy object) with a null PropertyNamingPolicy throws NullReferenceException.

My code : 
```C#
var a = JsonSerializer.Deserialize&lt;T&gt;(jsonString,options);  // options.PropertyNamingPolicy = null
```
Stack trace:

```
System.NullReferenceException
  HResult=0x80004003
  Message=Object reference not set to an instance of an object.
  Source=System.Text.Json
  StackTrace:
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonPropertyInfo.cs:line 345
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.HandleValue.cs:line 28
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.cs:line 50
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 22
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 73
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options) in /_/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 28
```

The jsonString 
```javascript
{"General":{"InnerRegionMode":"Hole"},"File":{"Format":"svg","PreferZip":false,"PreferOneFile":false,"SupportedFormats":[["svg"]]},"Coordinates":{"System":{"Projection":{"Name":"ETRS-TM35FIN"},"Scale":1000.0,"Origin":{"X":0.0,"Y":0.0,"Z":0.0},"Unit":{"UnitOf":2,"Name":"millimetre","Scale":0.001,"Symbol":"mm"}},"Flatten":false,"Centering":false,"Grids":null,"OneMetre":1.0,"OneMillimetre":0.001,"OneCentimetre":0.01},"Terrain":{"Exaggerate":2.5,"Contours":{"Closed":true,"Delta":0.5,"Reduce":0.1,"Smooth":0.0,"MinArea":9.0,"Highlights":{"N":10,"OutlineColor":"rgba(0,0,0,0.54)","FillColor":null,"StrokeWidth":0.9,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Labels":1,"LabelSpacing":50.0,"IndividualLayers":false,"OutlineColor":"rgba(0,0,0,0.29)","FillColor":null,"StrokeWidth":0.5,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Mesh":null,"Compression":{"InnerDensity":1.0,"OuterDensity":1.0,"DensityProfile":"Flat","InnerRegionTemplateId":null,"Enabled":false,"Layer":null,"Flatten":false,"ClipMode":0},"Texture":{"Colors":["rgba(69,114,45,1)","rgba(144,160,110,1)","rgba(195,160,105,1)","rgba(243,243,243,1)"],"ColorMap":{"Colors":["69, 114, 45","144, 160, 110","195, 160, 105","243, 243, 243"],"WaterColor":"","Contrast":0.0,"Min":0.0,"Max":1.0,"IsClear":false},"FlatColor":"DarkGray","Style":"ColorMap","SupportedStyles":null,"Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"CellLimit":0.0,"Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Shores":{"GuessDepth":false,"OutlineColor":"rgba(0,100,200,0.59)","FillColor":"rgba(66,164,194,0.48)","StrokeWidth":1.0,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Roads":{"DefaultWidth":3.0,"ExtraWidth":0.0,"OutlineColor":"rgba(53,51,51,0.92)","FillColor":"rgba(184,167,167,1)","StrokeWidth":1.0,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Buildings":{"GuessHeight":false,"ManualHeight":0.0,"ShowID":false,"OutlineColor":"rgba(0,0,0,1)","FillColor":"rgba(138,138,138,1)","StrokeWidth":1.0,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Properties":{"Text":{"ProportionalSize":true,"MinSize":1.0,"MaxSize":50.0,"OutlineColor":"rgba(0,0,0,1)","FillColor":"rgba(255,255,255,1)","StrokeWidth":4.0,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0},"Markers":{"ShowAccuracyBounds":true,"ShowID":false,"OutlineColor":"rgba(255,0,255,1)","FillColor":null,"StrokeWidth":0.3,"DataStyle":"Outline2D","Enabled":false,"Layer":null,"Flatten":false,"ClipMode":0},"OutlineColor":"rgba(132,35,221,0.79)","FillColor":null,"StrokeWidth":1.0,"DataStyle":"Outline2D","Enabled":true,"Layer":null,"Flatten":false,"ClipMode":0}}
```

The type it maps to has a lot of code so I won't be posting it here. The deserialization 'works', but everything is null after deserialization when using JsonNamingPolicy.CamelCase.
If using PropertyNameCaseInsensitive = true and JsonNamingPolicy.CamelCase then it will again throw NullReferenceException on the same line as before...

EDIT:
-------------------------------------

This seemed to be caused by having a custom JsonConverter&lt;System.Drawing.Color?&gt;, but no JsonConverter&lt;System.Drawing.Color&gt; defined... The complex class contained both Color and Color? objects. Adding the non-nullable version fixed the issue. The error was quite unhelpful however.





</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41643</IssueID>
    <RepoID>1</RepoID>
    <Title>Httpstress: add max execution time argument</Title>
    <Description>Makes the following changes to the stress suite app:

* Adds a `-maxExecutionTime` argument. Need this to enable running the stress suite for a predetermined amount of time on Azure pipelines.
* Return nonzero exit code if there are errors.
* Also adds nullable reference type annotations.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41642</IssueID>
    <RepoID>1</RepoID>
    <Title>Async XmlWriter is calling sync Stream Write/Flush</Title>
    <Description>### Describe the bug
I originally opened the bug in ASPNET repo https://github.com/aspnet/AspNetCore/issues/14811. In ASP.NET Core 3.x it is not possible to directly write data into a HTTP Response, because SyncIO is now disabled by default.
**Unfortunately, even if the user does not do any sync calls (see repo below), the code in corefx does sync calls on closing the writer.**

https://github.com/dotnet/corefx/blob/c1092870c306b8da256e455cec0814486255d0c1/src/System.Private.Xml/src/System/Xml/Core/XmlWellFormedWriter.cs#L1266
If you take a look at the flush implementation in ``XmlUtf8RawTextWriter``.
https://github.com/dotnet/corefx/blob/c1092870c306b8da256e455cec0814486255d0c1/src/System.Private.Xml/src/System/Xml/Core/XmlUtf8RawTextWriter.cs#L674
You see that it writes to stream regardless of the bufPos, a few lines below the bufPos is set to 1 https://github.com/dotnet/corefx/blob/c1092870c306b8da256e455cec0814486255d0c1/src/System.Private.Xml/src/System/Xml/Core/XmlUtf8RawTextWriter.cs#L701
That means even if the bufPos is 1, the write method is called with length 0.

Unfortunately this poses a problem in ``HttpResponseStream`` (Kestrel/IIS):
https://github.com/aspnet/AspNetCore/blob/354d859d50f252526be5a6264434d1765df86450/src/Servers/Kestrel/Core/src/Internal/Http/HttpResponseStream.cs#L80-L83
There the SyncIO Check is done without checking for the count argument, meaning it always throws.

Possible solutions:
1. Make the writers proper Async Dispose, implementing ``IAsyncDisposable`` and doing async close/flush.

2. Change XmlUtf8RawTextWriter in ``FlushBuffer`` to only write to the stream if length &gt; 0, unfortunately this still leaves the flush stream in both ``Close`` and ``Flush``. For that ``bufPos`` needs to be tracked in there too (making that idea kinda ugly).

3. Add another setting to XmlWriterSettings, e.g. ``FlushOnClose`` similar to the ``WriteEndDocumentOnClose`` and put the writer.Flush behind a check for it in ``XmlWellFormedWriter``

4. Change those SyncIO Checks to only throw on count &gt; 0 (I tried with that solution in the other repo, but @davidfowl  was not in favor of it)

May I suggest that you consider adding the first solution to the backlog for 5.0, I know it's too late for any of the solutions for 3.1, but atleast there are multiple workarounds documented.

The 4th way is currently what I'm trying in my solution, instead of using bodystream directly, I use a wrapperstream checking for the count == 0 case and make the flush a NOP, because in my code I know I flushed the data.

```csharp
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (count &gt; 0)
            {
                _input.Write(buffer, offset, count);
            }
        }
```

### To Reproduce
Steps to reproduce the behavior:
1. Using this version of ASP.NET Core '3.0'
2. Run this code (see repro below)
3. With these arguments: none
4. See error


### Expected behavior
No exception, it works.
### Screenshots
If applicable, add screenshots to help explain your problem.


### Additional context

Repro:
```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Xml;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace XmlWriterRepro
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();

            app.UseEndpoints(endpoints =&gt; { endpoints.MapGet("/", async context =&gt; { await WriteXmlAsync(context.Response.Body, "Hello World"); }); });
        }

        private static async Task WriteXmlAsync(Stream output, string text)
        {
            using (var xmlWriter = XmlWriter.Create(output, new XmlWriterSettings {Async = true, CloseOutput = false, WriteEndDocumentOnClose = false, CheckCharacters = false}))
            {
                await xmlWriter.WriteStartDocumentAsync().ConfigureAwait(false);
                await xmlWriter.WriteElementStringAsync(null, "Value", null, text).ConfigureAwait(false);
                await xmlWriter.WriteEndDocumentAsync().ConfigureAwait(false);
                await xmlWriter.FlushAsync().ConfigureAwait(false);
            }
        }
    }
}

```
With wrapper stream, just fyi:
&lt;details&gt;

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace XmlWriterRepro
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt; { webBuilder.UseStartup&lt;Startup&gt;(); });
    }

    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();

            app.UseEndpoints(endpoints =&gt; { endpoints.MapGet("/", async context =&gt; { await WriteXmlAsync(new WriteCheckWrapperStream(context.Response.Body), "Hello World"); }); });
        }

        private static async Task WriteXmlAsync(Stream output, string text)
        {
            using (var xmlWriter = XmlWriter.Create(output, new XmlWriterSettings {Async = true, CloseOutput = false, WriteEndDocumentOnClose = false, CheckCharacters = false}))
            {
                await xmlWriter.WriteStartDocumentAsync().ConfigureAwait(false);
                await xmlWriter.WriteElementStringAsync(null, "Value", null, text).ConfigureAwait(false);
                await xmlWriter.WriteEndDocumentAsync().ConfigureAwait(false);
                await xmlWriter.FlushAsync().ConfigureAwait(false);
            }
        }
    }

    public class WriteCheckWrapperStream : Stream
    {
        private readonly Stream _input;

        public WriteCheckWrapperStream(Stream input)
        {
            _input = input;
        }

        public override Task FlushAsync(CancellationToken cancellationToken)
        {
            return _input.FlushAsync(cancellationToken);
        }

        public override void Flush()
        {
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            return _input.Read(buffer, offset, count);
        }

        public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
        {
            return _input.CopyToAsync(destination, bufferSize, cancellationToken);
        }

        public override Task&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            return _input.ReadAsync(buffer, offset, count, cancellationToken);
        }

        public override ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken = default)
        {
            return _input.ReadAsync(buffer, cancellationToken);
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            return _input.Seek(offset, origin);
        }

        public override void SetLength(long value)
        {
            _input.SetLength(value);
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            if (count &gt; 0)
            {
                _input.Write(buffer, offset, count);
            }
        }

        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            return _input.WriteAsync(buffer, offset, count, cancellationToken);
        }

        public override ValueTask WriteAsync(ReadOnlyMemory&lt;byte&gt; buffer, CancellationToken cancellationToken = new CancellationToken())
        {
            return _input.WriteAsync(buffer, cancellationToken);
        }

        public override bool CanRead =&gt; _input.CanRead;

        public override bool CanSeek =&gt; _input.CanSeek;

        public override bool CanWrite =&gt; _input.CanWrite;

        public override long Length =&gt; _input.Length;

        public override long Position
        {
            get =&gt; _input.Position;
            set =&gt; _input.Position = value;
        }
    }
}
```
&lt;/details&gt;
</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41641</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/uwp6.2] Clean up some tests and move to new Azure endpoint</Title>
    <Description>**Test only fixes**

Port PR #36018 from master branch (and similar #41603 from release/2.1 branch)

This PR changes the Azure test endpoint to use Azure App Service instead of the classic Azure
Cloud Service endpoint. The use of the classic Azure Cloud Service is no longer recommended
since it is harder to maintain.

Once all remaining branches are converted, we will shut down the corefx-net.cloudapp.net
endpoint.

This PR also includes some other test fixes and tests disabled due to active issues.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41640</IssueID>
    <RepoID>1</RepoID>
    <Title>Several improvements to SocketsHttpHandler perf</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/39835

Commit 1:
Per https://github.com/dotnet/corefx/issues/39835#issuecomment-538755366, the intent of HttpHeaders.TryAddWithoutValidation was that we wouldn't validate the headers.  But while we're currently not validating them as part of that API call itself, we're currently validating them as part of enumerating the headers to write the out to the wire, for both HTTP/1.1 and HTTP/2.0.  Stop doing that.  This does mean that we could end up writing out something that would render the HTTP request invalid, but that's the nature of "WithoutValidation" and what the developer asked for.

Commit 2:
Several releases ago, when we weren't paying attention to ExpectContinue, we optimized away the backing field for it into a lazily-initialized collection; that made it cheaper when not accessed but more expensive when accessed, which was fine, as we wouldn't access it from the implementation and developers would rarely set it.  But now SocketsHttpHandler checks it on every request, which means we're paying for the more expensive thing always. So, revert the optimization for this field.

Commit 3:
When we enumerate the headers to write them out, we currently allocate a string[] for each.  We can instead just fill the same array over and over and over.

Benchmark:

|  Method |        Toolchain |     Mean |    Error |   StdDev | Ratio |  Gen 0 | Allocated |
|-------- |----------------- |---------:|---------:|---------:|------:|-------:|----------:|
| HttpGet | \old\corerun.exe | 66.44 us | 0.886 us | 0.828 us |  1.00 | 0.8545 |   5.58 KB |
| HttpGet | \new\corerun.exe | 61.88 us | 0.935 us | 0.780 us |  0.93 | 0.4883 |   3.15 KB |

```C#
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Running;
using System;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

[MemoryDiagnoser]
public class Program
{
    static void Main(string[] args) =&gt; BenchmarkSwitcher.FromTypes(new[] { typeof(Program) }).Run(args);

    private static Socket s_listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    private static HttpClient s_client = new HttpClient(new HttpClientHandler() { ServerCertificateCustomValidationCallback = delegate { return true; } });
    private static Uri s_uri;

    [Benchmark]
    public async Task HttpGet()
    {
        var m = new HttpRequestMessage(HttpMethod.Get, s_uri);
        m.Headers.TryAddWithoutValidation("Authorization", "ANYTHING SOMEKEY");
        m.Headers.TryAddWithoutValidation("Referer", "http://someuri.com");
        m.Headers.TryAddWithoutValidation("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36");
        m.Headers.TryAddWithoutValidation("Host", "www.somehost.com");
        (await s_client.SendAsync(m, default)).Dispose();
    }

    [GlobalSetup]
    public void CreateSocketServer()
    {
        s_listener.Bind(new IPEndPoint(IPAddress.Loopback, 0));
        s_listener.Listen(int.MaxValue);
        var ep = (IPEndPoint)s_listener.LocalEndPoint;
        s_uri = new Uri($"http://{ep.Address}:{ep.Port}/");
        byte[] response = Encoding.UTF8.GetBytes("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n");
        byte[] endSequence = new byte[] { (byte)'\r', (byte)'\n', (byte)'\r', (byte)'\n' };

        Task.Run(async () =&gt;
        {
            while (true)
            {
                Socket s = await s_listener.AcceptAsync();
                _ = Task.Run(() =&gt;
                {
                    using (var ns = new NetworkStream(s, true))
                    {
                        byte[] buffer = new byte[1024];
                        int totalRead = 0;
                        while (true)
                        {
                            totalRead += ns.Read(buffer.AsSpan(totalRead));
                            if (buffer.AsSpan(0, totalRead).IndexOf(endSequence) == -1)
                            {
                                if (totalRead == buffer.Length) Array.Resize(ref buffer, buffer.Length * 2);
                                continue;
                            }

                            ns.Write(response);

                            totalRead = 0;
                        }
                    }
                });
            }
        });
    }
}
```</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41639</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable UnixDomainSock ConcurrentSendReceive test</Title>
    <Description>https://github.com/dotnet/corefx/issues/29742</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41638</IssueID>
    <RepoID>1</RepoID>
    <Title>Huge performance degradation using System.Text.Json to serialize a model with an Object type property</Title>
    <Description>I've been troubleshooting some performance issues that came up during a core 2.2 -&gt; 3.0 upgrade, and was stumped why a particular ASP.NET Core API endpoint showed terrible performance compared to the others. 

After countless hours I finally discovered the cause; the model being serialized contained a child class, with a collection property that was simply defined with type Object, i.e. what should have been:
```c#
public IEnumerable&lt;Table&gt; Tables { get; set; }
```
was defined as: 
```c#
public object Tables { get; set; }
```
The reasons for this odd coding choice are unfortunately lost in history, but it works fine, was insidiously hard to diagnose, and the perf impact was very severe, with the API going from **~300 requests/sec** under local load tests to **~3300 requests/sec** after fixing. 

I assume that the poor performance is due to reflection being used to serialize when there's an unknown object type, and I guess it only gets worse because it's a list. It's not clear to me if there's a way of fixing this, or if it would be necessary to remove support for serializing `Object` altogether. Perhaps just log a warning to make it easier to catch? 

I'd be happy to try my hand with a PR, if someone could point me in the right direction?  </Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41637</IssueID>
    <RepoID>1</RepoID>
    <Title>Port infra  and test changes to release/3.0</Title>
    <Description>Infra and test changes only. No risk.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41636</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable finalization of bogus SafeWaitHandles</Title>
    <Description>Fixes #41635</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41635</IssueID>
    <RepoID>1</RepoID>
    <Title>SafeWaitHandle tests run finalizer with invalid values</Title>
    <Description>Originally reported as https://github.com/mono/mono/issues/17224.

At least one SafeWaitHandle test constructs the `SafeWaitHandle` object with invalid handle value:

https://github.com/dotnet/corefx/blob/95e35e10d7c52a7eea38c2ae6402d29e2a01efc6/src/System.Runtime.Handles/tests/SafeWaitHandle.cs#L19-L25

The `SafeWaitHandle` is left in this invalid state and when the finalizer runs the `ReleaseHandle` method is called with the invalid value. Current Mono implementation is not resilient to these invalid values while the CoreCLR implementation is.

The test should be fixed to either reset the `SafeWaitHandle` to invalid value using `SetHandleAsInvalid()` call, or to use derived class with overrridden `ReleaseHandle` method (like [here](https://github.com/dotnet/corefx/blob/7407443d51b92780914732d880e65ffaabbba17c/src/System.Runtime.Handles/tests/SafeHandle.cs#L11-L35)).</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41646</IssueID>
    <RepoID>1</RepoID>
    <Title>.Net Core 3.0 TimeSpan (de)serialization error</Title>
    <Description>I am using .Net Core 3.0 and have the following string which I need to deserialize with Newtonsoft.Json:
```
{
	"userId": null,
	"accessToken": null,
	"refreshToken": null,
	"sessionId": null,
	"cookieExpireTimeSpan": {
		"ticks": 0,
		"days": 0,
		"hours": 0,
		"milliseconds": 0,
		"minutes": 0,
		"seconds": 0,
		"totalDays": 0,
		"totalHours": 0,
		"totalMilliseconds": 0,
		"totalMinutes": 0,
		"totalSeconds": 0
	},
	"claims": null,
	"success": false,
	"errors": [
		{
			"code": "Forbidden",
			"description": "Invalid username unknown!"
		}
	]
}
```
and bump into the following error:
```
   Newtonsoft.Json.JsonSerializationException : Cannot deserialize the current JSON object (e.g. {"name":"value"}) into type 'System.TimeSpan' because the type requires a JSON primitive value (e.g. string, number, boolean, null) to deserialize correctly.
To fix this error either change the JSON to a JSON primitive value (e.g. string, number, boolean, null) or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List&lt;T&gt;) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object.
Path 'cookieExpireTimeSpan.ticks', line 1, position 103.
```
The error string actually happens when reading the content of HttpResponseMessage:
```
var httpResponse = await _client.PostAsync("/api/auth/login", new StringContent(JsonConvert.SerializeObject(new API.Models.Request.LoginRequest()), Encoding.UTF8, "application/json"));
var stringResponse = await httpResponse.Content.ReadAsStringAsync();
```
The server controller method returns:
```
return new JsonResult(result) { StatusCode = whatever; };
```
https://stackoverflow.com/questions/58283761/net-core-3-0-timespan-deserialization-error</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41634</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191008.1
- **Date Produced**: 10/8/2019 8:59 AM
- **Commit**: c1092870c306b8da256e455cec0814486255d0c1
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19508.1
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19508.1

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191007.2
- **Date Produced**: 10/7/2019 12:41 PM
- **Commit**: 30adc7e9aa13a7d35c999a2c2e37e271b2e61cbf
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19507.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41773</IssueID>
    <RepoID>1</RepoID>
    <Title>Support Generic Methods in Expression Trees</Title>
    <Description>Currently, S.L.Expressions.Expression and subclasses cannot infer the types of generic methods. This makes the generated lambdas unsuitable for dealing with code-generation not available at run-time. 

Given the following:
```c#
static class Class1
{
  public static T MethodName&lt;T&gt;(T instance)
  {
    return instance;
  }
}
```
One cannot create a lambda that invokes MethodName, without knowing the binding parameter first, like this:
```c#
var method = typeof(Class1).GetMethod(nameof(Class1.MethodName), BindgingFlags.Public | BindingFlags.Static);
var parameter = Expression.Parameter(typeof(??));
var lambda = Expression.Lambda(Expression.Call(method, parameter), parameter), parameter);
```
To do so, one must know the generic type first (in the double question marks). Unfortunately, this makes a whole class of code generation strategies very cumbersome, since, in order to compile (and invoke) the methods, one must do expression generation, compilation, etc., at every first unique binding at least:
```c#
Expression&lt;Lambda&lt;Func&lt;T, T&gt;&gt; MakeLambda&lt;T&gt;()
{
  var compiledLambdas = new ConcurrentDictionary&lt;Type, Delegate&gt;();
  var method = typeof(Class1).GetMethod(nameof(Class1.MethodName), BindgingFlags.Public | BindingFlags.Static);

  var parameter = Expression.Parameter(typeof(T));
  var lambda = Expression.Lambda(Expression.Call(method, parameter), parameter), parameter);
}

private readonly ConcurrentDictionary&lt;Type, Func&lt;object, object&gt;&gt; m_Lambdas;

Expression&lt;Func&lt;object, object&gt;&gt; MakeGenericLambda(Type type)
{
  return m_Lambdas.TryGetValue(type,
    key =&gt; 
    {
      var parameter = Expression.Parameter(typeof(object));
      return Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(
        Expression.Convert(
          Expression.Invoke(
            typeof(this)
              .GetMethod(nameof(MakeLambda), BindingFlags.NonPublic | BindingFlags.Instance)
              .MakeGenericMethod(type)
              .Invoke(this, null),
            parameter),
          typeof(object)), parameter);
   });
}
```
It gets worse if one considers more complex scenarios, with multiple generic type arguments.

The proposition:
1. Add GenericTypeParameterExpression, created with Expression.GenericTypeParameter(string typeName);
2. Change Expression.Parameter, Expression.Variable, to accept also a variant with GenericTypeParameterExpression as well;
3. Change Expression.Lambda to support GenericTypeParameterExpression:
```c#
Expression.Lambda(body, GenericTypeParameter[] genericTypeArguments, params ParameterExpression parameters);
```
4. Add Expression.Lambda&lt;TDelegate, T1, T2, ...&gt; variants, with type binding.
This would be especially useful in combination with Expression.CompileToMethod (which would be a nice addition to .net core as well), and would greatly eliminate the need to write complex boxing/unboxing, cached lambdas, etc.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41633</IssueID>
    <RepoID>1</RepoID>
    <Title>Support for [JsonObject(MemberSerialization.OptIn)] attribute</Title>
    <Description>Newtonsoft.Json supports a convenient way to serialize certain types of classes using attributes only, by specifying the [JsonObject(MemberSerialization.OptIn)] attribute on the class, and then picking the desired properties to serialize using the [JsonProperty] attribute on the. This does not seem to be supported yet?

Is there a viable workaround other than writing custom converters for all those classes?</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41632</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191007.3
- **Date Produced**: 10/8/2019 12:58 AM
- **Commit**: 2d80d4fc6b81108ce396db46212cc7baccbddd29
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19507.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19507.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19507.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41631</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191007.10
- **Date Produced**: 10/8/2019 5:40 AM
- **Commit**: 57ba280ee32511c6f5c2ebcd2bfaaf4a1db74648
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19507.10
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19507.10
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19507.10

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41652</IssueID>
    <RepoID>1</RepoID>
    <Title>AuthenticationException in Centos 7 using WCF from .NET Core 2.1.13</Title>
    <Description>**Describe the bug**
I use the WCF client from .NET Core to access Windows WCF services from Linux.
Everything works correctly using .NET Core 2.1.3

Upgrading to 2.1.13 results in the exception below when calling the WCF client.
I also see the same problem with .NET Core 2.2 latest or 3.0 latest.

**Expected behavior**
I use the WCF client from .NET Core to access Windows WCF services from Linux.
Everything works correctly using .NET Core 2.1.3

I expected this to continue working in newer versions of .NET Core.

**Additional context**
I use `kinit` before making this call to ensure that I'm authenticated correctly.
Am I missing some dependencies, or could this be something else?

**Linux Version**
```
cat /etc/os-release
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```

**.NET Core Version**
```
dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.802
 Commit:    177d0b2525

Runtime Environment:
 OS Name:     centos
 OS Version:  7
 OS Platform: Linux
 RID:         centos.7-x64
 Base Path:   /usr/share/dotnet/sdk/2.1.802/

Host (useful for support):
  Version: 2.1.13
  Commit:  1a165a1588

.NET Core SDKs installed:
  2.1.802 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.13 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.13 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.13 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

```

**Full Stack trace**
```
System.ComponentModel.Win32Exception: GSSAPI operation failed with error - Unspecified GSS failure.  Minor code may provide more information (Server not found in Kerberos database).

The above exception was the direct cause of the following exception:

System.Security.Authentication.AuthenticationException: Authentication failed, see inner exception.
   at System.Net.Security.NegoState.StartSendAuthResetSignal(LazyAsyncResult lazyResult, Byte[] message, Exception exception)
   at System.Net.Security.NegoState.StartSendBlob(Byte[] message, LazyAsyncResult lazyResult)
   at System.Net.Security.NegoState.ProcessAuthentication(LazyAsyncResult lazyResult)
   at System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, Object asyncState)
   at System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(NetworkCredential credential, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, Object asyncState)
   at System.Net.Security.NegotiateStream.&lt;&gt;c__DisplayClass27_0.&lt;AuthenticateAsClientAsync&gt;b__0(AsyncCallback callback, Object state)
   at System.Threading.Tasks.TaskFactory`1.FromAsyncImpl(Func`3 beginMethod, Func`2 endFunction, Action`1 endAction, Object state, TaskCreationOptions creationOptions)
   at System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential credential, String targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel)
   at System.ServiceModel.Channels.WindowsStreamSecurityUpgradeProvider.WindowsStreamSecurityUpgradeInitiator.OnInitiateUpgradeAsync(Stream stream, OutWrapper`1 remoteSecurity)

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
System.ServiceModel.Security.SecurityNegotiationException: Authentication failed, see inner exception.
   at System.ServiceModel.Channels.WindowsStreamSecurityUpgradeProvider.WindowsStreamSecurityUpgradeInitiator.OnInitiateUpgradeAsync(Stream stream, OutWrapper`1 remoteSecurity)
   at System.ServiceModel.Channels.StreamSecurityUpgradeInitiatorBase.InitiateUpgradeAsync(Stream stream)
   at System.ServiceModel.Channels.ConnectionUpgradeHelper.InitiateUpgradeAsync(StreamUpgradeInitiator upgradeInitiator, OutWrapper`1 connectionWrapper, ClientFramingDecoder decoder, IDefaultCommunicationTimeouts defaultTimeouts, TimeSpan timeout)
   at System.ServiceModel.Channels.ClientFramingDuplexSessionChannel.SendPreambleAsync(IConnection connection, ArraySegment`1 preamble, TimeSpan timeout)
   at System.ServiceModel.Channels.ConnectionPoolHelper.EstablishConnectionAsync(TimeSpan timeout)
   at System.ServiceModel.Channels.ClientFramingDuplexSessionChannel.OnOpenAsync(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.OnOpenAsyncInternal(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.System.ServiceModel.IAsyncCommunicationObject.OpenAsync(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.OpenAsyncInternal(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.Open(TimeSpan timeout)
   at System.Runtime.TaskHelpers.CallActionAsync[TArg](Action`1 action, TArg argument)
   at System.ServiceModel.Channels.CommunicationObject.OpenOtherAsync(ICommunicationObject other, TimeSpan timeout)
   at System.ServiceModel.Channels.ServiceChannel.OnOpenAsync(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.OnOpenAsyncInternal(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.System.ServiceModel.IAsyncCommunicationObject.OpenAsync(TimeSpan timeout)
   at System.ServiceModel.Channels.CommunicationObject.OpenAsyncInternal(TimeSpan timeout)
   at System.ServiceModel.Channels.ServiceChannel.CallOpenOnce.System.ServiceModel.Channels.ServiceChannel.ICallOnce.Call(ServiceChannel channel, TimeSpan timeout)
   at System.ServiceModel.Channels.ServiceChannel.CallOnceManager.CallOnce(TimeSpan timeout, CallOnceManager cascade)
   at System.ServiceModel.Channels.ServiceChannel.EnsureOpened(TimeSpan timeout)
   at System.ServiceModel.Channels.ServiceChannel.Call(String action, Boolean oneway, ProxyOperationRuntime operation, Object[] ins, Object[] outs, TimeSpan timeout)
   at System.ServiceModel.Channels.ServiceChannelProxy.InvokeService(MethodCall methodCall, ProxyOperationRuntime operation)
   at System.ServiceModel.Channels.ServiceChannelProxy.Invoke(MethodInfo targetMethod, Object[] args)
--- End of stack trace from previous location where exception was thrown ---
   at System.Reflection.DispatchProxyGenerator.Invoke(Object[] args)
   at generatedProxy_1.GetById(Int32 )
   at MyApp.Client.Connections.BaseConnection`1.ExecuteOnSingleUseChannel[T](Func`2 activity)
```</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41630</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher leaks when EnableRaisingEvents set</Title>
    <Description>Related to #41321 (at least this was found while debugging the same issue). Creating a `FileSystemWatcher` and `EnableRaisingEvents` set to true will root the `FileSystemWatcher` instance by the handle table. 

We had a customer creating a `FileSystemWatcher` per request (indirectly) in an ASP.NET Core and it lead to a memory leak.

```
&gt; gcroot -all 000001ff54786c20                                                                                                                                     HandleTable:
    000001FBD45913C8 (async pinned handle)
    -&gt; 000001FF54788E28 System.Threading.OverlappedData
    -&gt; 000001FF54788DE0 System.Threading.ThreadPoolBoundHandleOverlapped
    -&gt; 000001FF54788D80 System.Threading.IOCompletionCallback
    -&gt; 000001FF54786C20 System.IO.FileSystemWatcher
```</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41629</IssueID>
    <RepoID>1</RepoID>
    <Title>URL and filename safe base64 encoding</Title>
    <Description>### Summary

The requirement of URL and filename safe alphabets in base64 strings is common in many applications that deal with resources over the network, not limited to web applications. Existing base64 encoding APIs do not provide option to encode in safe alphabets, forcing consumer to manually replace characters before and after the decoding and encoding operations respectively. Therefore, extending the existing base64 encoding API set in `System.Convert` to support safe alphabets would be quite useful in terms of completeness.

### Rationale and Usage

In order to achieve Base64Url encoding, one of the common technique is to call `System.Convert.ToBase64String` on the input, then truncate (or percentage-encode) the trailing `=` characters, and finally replace `+` characters with `-` and `/` with `_`. For example, the JSON Web Signature (JWS) RFC 7571 gives a C# example with [similar code](https://tools.ietf.org/html/rfc7515#appendix-C). This approach is also suggested in the [top answer](https://stackoverflow.com/a/26354677/863980) on SO. However, this approach is rendered inefficient under a high load, when compared to the spanified implementation internally used in `OpenSslX509ChainProcessor`: https://github.com/dotnet/corefx/blob/e70e76159b3f34e4e35d241daf39d4f57f4bd82c/src/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Unix/OpenSslX509ChainProcessor.cs#L544

or in WebEncoders from AspNetCore: https://github.com/aspnet/AspNetCore/blob/fd060ce8c36ffe195b9e9a69a1bbd8fb53cc6d7c/src/Shared/WebEncoders/WebEncoders.cs#L347

A unified efficient implementation, that conforms with [RFC 4648 - Section 5](https://tools.ietf.org/html/rfc4648#page-7) would prevent consumers from looking for it elsewhere. For reference, [this API](https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html#getUrlEncoder--) was included in Java 8 (in 2014).

### Proposed API

```diff
namespace System
{
    public static class Convert
    {
        // existing
        public static byte[] FromBase64CharArray(char[] inArray, int offset, int length);
        public static byte[] FromBase64String(string s);
        public static string ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32);
        public static string ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32, Base64FormattingOptions);
        public static string ToBase64String(Byte[], Int32, Int32, Base64FormattingOptions) 	 
        public static string ToBase64String(Byte[], Int32, Int32) 	
        public static string ToBase64String(Byte[], Base64FormattingOptions) 	
        public static string ToBase64String(Byte[]) 	
        public static string ToBase64String(ReadOnlySpan&lt;Byte&gt;, Base64FormattingOptions)
        public static bool TryFromBase64Chars(ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes,
            out int bytesWritten);
        public static bool TryFromBase64String(string s, Span&lt;byte&gt; bytes,
            out int bytesWritten);
        public static bool TryToBase64Chars(ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars,
            out int charsWritten, Base64FormattingOptions options = Base64FormattingOptions.None);

        // proposed
+       public static byte[] FromBase64UrlCharArray(char[] inArray, int offset, int length);
+       public static byte[] FromBase64UrlString(string s);
+       public static string ToBase64UrlCharArray(Byte[], Int32, Int32, Char[], Int32);
+       public static string ToBase64UrlCharArray(Byte[], Int32, Int32, Char[], Int32, Base64FormattingOptions);
+       public static string ToBase64UrlString(Byte[], Int32, Int32, Base64FormattingOptions) 	 
+       public static string ToBase64UrlString(Byte[], Int32, Int32) 	
+       public static string ToBase64UrlString(Byte[], Base64FormattingOptions) 	
+       public static string ToBase64UrlString(Byte[]) 	
+       public static string ToBase64UrlString(ReadOnlySpan&lt;Byte&gt;, Base64FormattingOptions)
+       public static bool TryFromBase64UrlChars(ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes,
+           out int bytesWritten);
+       public static bool TryFromBase64UrlString(string s, Span&lt;byte&gt; bytes,
+           out int bytesWritten);
+       public static bool TryToBase64UrlChars(ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars,
+           out int charsWritten, Base64FormattingOptions options = Base64FormattingOptions.None);

    }
}
```

### Details

* The reason for `*Base64Url*` names is because RFC 4648 explicitly calls it out. `Base64Url` encoded string is not a valid base64 string due to non-base64 (`-`, `_` and `%`) characters.
  * If that was not the case, `UrlAndPathSafeAlphabets = 2,` could had been considered  in `enum Base64FormattingOptions` for existing `{To,From}Base64{CharArray,String}` APIs.
* `ToBase64Url..` methods are conformant to RFC 4648. If the input length is known (which is the case here) and there is a pad characters `=` , it will be truncated (as opposed to percentage encoded).
* `FromBase64Url..` methods accept all cases of RFC 4648 and two non-RFC ones, `%2B` and `%2F` mentioned in the case below:
  * `OpenSslX509ChainProcessor.Base64UrlEncode` is not conforming to RFC as it percentage-encodes `+` (`%2B`) and `/` (`%2F`) characters, whereas RFC only calls out pad character `=` to be optionally percentage-encoded and which can be dropped if length is known.
  * ASP.NET Core's &lt;code&gt;WebEncoders.Base64Url&lt;ins&gt;De&lt;/ins&gt;code&lt;/code&gt; is also not conforming to RFC 4648. For example, the input `TestString` can be encoded as any of the following, but `Base64UrlDecode` only recognizes first two and throws `FormatException` for the third:
    * `VGVzdFN0cmluZw`
    * `VGVzdFN0cmluZw==`
    * `VGVzdFN0cmluZw%3D%3D`

### Open Questions
&gt; * `ToBase64Url..` methods are conformant to RFC 4648. If the input length is known (which is the case here) and there is a pad characters `=` , it will be truncated (as opposed to percentage encoded).

Are there cases where consumer explicitly do *not* want to omit the pad character and expect the API to percentage-encode it? For example, going by the usage of `OpenSslX509ChainProcessor.Base64UrlEncode`, it is not clear whether it will break something if this method simply omits `=` and replace `+` and `/` with `-` and `_` respectively.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41628</IssueID>
    <RepoID>1</RepoID>
    <Title>Allow circular reference support for the new dotnet core 3 json api's</Title>
    <Description>The new System.Text.Json API's do not support ignoring circular references while serializing.
This is an issue because EF Core produces circular references by default when using navigation properties.

This results in an exception being thrown when you serialize a result set from EF Core.</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41627</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix serialization of elements with an empty-string child text node</Title>
    <Description>Related to #41574

Output after change
```
&lt;root&gt;
  &lt;Elem&gt;&lt;/Elem&gt;
&lt;/root&gt;
```

Can we skip the length check?

Please review.
Thank you in advance</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41626</IssueID>
    <RepoID>1</RepoID>
    <Title>Update ReportGenerator global repo tool version to 4.3.0</Title>
    <Description>Contains fixes such as https://github.com/danielpalme/ReportGenerator/issues/284 amongst others

https://github.com/danielpalme/ReportGenerator/blob/57b12cb92f245c0b085bf10f4e1054fda4d9854a/src/Readme.txt#L64-L72

cc @ViktorHofer, @danielpalme </Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41625</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2. I'm a robot and am configured to help you automatically keep release/2.2 up to date, so I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @davidsh

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/2.1
git pull --ff-only
git checkout release/2.2
git pull --ff-only
git merge --no-ff release/2.1

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/2.1-to-release/2.2'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41624</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix copy&amp;paste globalization test bug</Title>
    <Description>
    </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41623</IssueID>
    <RepoID>1</RepoID>
    <Title>Bumping the version of OOB packages to match product version</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/40544</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41622</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable SslStream server options per-hostname (in callback)</Title>
    <Description>Hello,

Our service is a reverse proxy running on IIS (on top of HttpSys). We are moving to .NET core and while running on Kestrel, ran into a scenario blocker with client certificates.

In our current application, we use HttpSys APIs to configure client certificate negotiation per hostname and also to set up CTL stores.

The specific API we use is : https://docs.microsoft.com/en-us/windows/win32/http/add-sslcert

Examples of usage:
1) netsh http add sslcert hostnameport=a.b.microsoftonline.com:443 
certhash=EC9CA6E0E645AAB24F8AD890DF75A448824D2C37 appid='{4dc3e181-e14b-4a21-b022-59fc669b0914}' certstorename=MY 
verifyclientcertrevocation=disable

2) netsh http add sslcert hostnameport=c.windows.net:443 
certhash=EB3C3B94F10E948463929BCF4C7000C1E7BD0AC1 appid='{4dc3e181-e14b-4a21-b022-59fc669b0914}' certstorename=MY 
clientcertnegotiation=enable verifyclientcertrevocation=disable

3) netsh http add sslcert hostnameport=device.a.b.microsoftonline.com:443 
certhash=963B55D3E94101B70F1654FBF90D6006BAFAD513 appid='{4dc3e181-e14b-4a21-b022-59fc669b0914}' certstorename=MY 
clientcertnegotiation=enable verifyclientcertrevocation=disable sslctlstorename=DeviceLoginCTLStore

We want the ability to perform these operations in the Kestrel webserver. (The workaround of using the HttpSysServer does not work for us, I will not go into the reasons in this issue, I will create a separate one for that).

Kestrel already provides SNI support (ability to select server certificate on a per hostname basis). However, the problem is that the client certificate negotiation (and CTL store) support is application wide and not per hostname. 

https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.server.kestrel.https.clientcertificatemode?view=aspnetcore-2.2#Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_NoCertificate.

To be specific: 
1) When a SNI binding is set up in Kestrel, provide the ability to enable/disable client certificate negotiation. (an equivalent to the "clientcertnegotiation" property in HttpSys.)
2) When a SNI binding is set up in Kestrel, provide the ability to select the exact CTL store for this binding. (an equivalent to the "sslctlstorename" property in HttpSys)
3) When a SNI binding is set up in Kestrel, provide the ability to turn on or off the verification of revocation of client certificates. 
 (an equivalent to the "verifyclientcertrevocation" property in HttpSys.)

This is a major blocker for us to migrate to .NET core. 


</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41621</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Consider supporting h2c without AppContext switch</Title>
    <Description>Today users must set an AppContext switch to be able to use h2c (HTTP/2 without TLS) with HttpClient. This switch was added in .NET Core 3.0 to make it easier to debug the content of HttpClient traffic by having it sent without TLS.

```cs
AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);
```

This setting has turned out to be very useful, and has a lot of legitimate uses outside of just debugging. I think HttpClient should support h2c without setting this switch.

Although browsers require a web server to always encrypt HTTP/2 content, it is common for back end services to send HTTP/2 API calls without TLS, especially during development. Most development ecosystems don't have the TLS-by-default focus that .NET has.

For example, a gRPC service hosted written in Java/Go/C++ probably won't have a TLS cert setup in development, and .NET devs will need to jump through additional hoops to figure out how to successfully call it.

Another example of where h2c is required is ASP.NET Core gRPC on macOS. .NET Core ASP.NET on Mac doesn't support server TLS, so users have to develop with h2c - https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-3.0#unable-to-start-aspnet-core-grpc-app-on-macos

@shirhatti </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41620</IssueID>
    <RepoID>1</RepoID>
    <Title>Update infra owners</Title>
    <Description>
    </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41618</IssueID>
    <RepoID>1</RepoID>
    <Title>Crypto DecryptEnvelopedEmptyOctetString test crashes on CI</Title>
    <Description>Configuration: `netfx-Windows_NT-Release-x86-Windows.10.Amd64.ClientRS5.Open`

https://dev.azure.com/dnceng/public/_build/results?buildId=380511&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11762370&amp;paneView=debug

Dump is available: https://helix.dot.net/api/2019-06-17/jobs/948bbfd1-1a8d-4f80-98c7-87f70a914f20/workitems/System.Security.Cryptography.Pkcs.Tests/files/xunit.console.exe.6212.dmp

```
C:\dotnetbuild\work\948bbfd1-1a8d-4f80-98c7-87f70a914f20\Work\cf8fae2e-31fb-4c36-bc96-bc2f3e1ee396\Exec&gt;xunit.console.exe System.Security.Cryptography.Pkcs.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=nonnetfxtests -notrait category=nonwindowstests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  
  Discovering: System.Security.Cryptography.Pkcs.Tests (app domain = on [no shadow copy], method display = ClassAndMethod, method display options = None)
  Discovered:  System.Security.Cryptography.Pkcs.Tests (found 309 of 378 test cases)
  Starting:    System.Security.Cryptography.Pkcs.Tests (parallel test collections = on, max threads = 2)
    System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.KeyTransRecipientInfoRsaOaepCertTests.TestKeyTransEncryptKey_RsaOaepCertificate_NoPlatformSupport_Throws [SKIP]
      Condition(s) not met: "DoesNotSupportRsaOaepCerts"
    System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.KeyAgreeRecipientInfoTests.TestKeyAgreement_PlatformNotSupported [SKIP]
      Condition(s) not met: "DoesNotSupportDiffieHellman"

Unhandled Exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.
   at System.Security.Cryptography.X509Certificates.X509Utils._LoadCertFromBlob(Byte[] rawData, IntPtr password, UInt32 dwFlags, Boolean persistKeySet, SafeCertContextHandle&amp; pCertCtx)
   at System.Security.Cryptography.X509Certificates.X509Utils.LoadCertFromBlob(Byte[] rawData, IntPtr password, UInt32 dwFlags, Boolean persistKeySet, SafeCertContextHandle pCertCtx)
   at System.Security.Cryptography.X509Certificates.X509Certificate.LoadCertificateFromBlob(Byte[] rawData, Object password, X509KeyStorageFlags keyStorageFlags)
   at System.Security.Cryptography.X509Certificates.X509Certificate2..ctor(Byte[] rawData, String password, X509KeyStorageFlags keyStorageFlags)
   at Test.Cryptography.CertLoader.TryGetCertificateWithPrivateKey(Boolean exportable) in /_/src/System.Security.Cryptography.Pkcs/tests/CertLoader.cs:line 86
   at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.VerifySimpleDecrypt(Byte[] encodedMessage, CertLoader certLoader, ContentInfo expectedContent) in /_/src/System.Security.Cryptography.Pkcs/tests/EnvelopedCms/DecryptTests.cs:line 834
   at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.TestSimpleDecrypt_RoundTrip(CertLoader certLoader, ContentInfo contentInfo, String algorithmOidValue, SubjectIdentifierType type, ContentInfo expectedContentInfo) in /_/src/System.Security.Cryptography.Pkcs/tests/EnvelopedCms/DecryptTests.cs:line 827
   at System.Security.Cryptography.Pkcs.EnvelopedCmsTests.Tests.DecryptTests.DecryptEnvelopedEmptyOctetString() in /_/src/System.Security.Cryptography.Pkcs/tests/EnvelopedCms/DecryptTests.cs:line 755
   --- End of inner exception stack trace ---
   at System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor)
   at System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(Object obj, Object[] parameters, Object[] arguments)
   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
   at Xunit.Sdk.TestInvoker`1.CallTestMethod(Object testClassInstance) in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs:line 150
   at Xunit.Sdk.TestInvoker`1.&lt;&gt;c__DisplayClass48_1.&lt;&lt;InvokeTestMethodAsync&gt;b__1&gt;d.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs:line 257
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestInvoker`1.&lt;&gt;c__DisplayClass48_1.&lt;InvokeTestMethodAsync&gt;b__1()
   at Xunit.Sdk.ExecutionTimer.&lt;AggregateAsync&gt;d__4.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\ExecutionTimer.cs:line 48
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.ExecutionTimer.AggregateAsync(Func`1 asyncAction)
   at Xunit.Sdk.ExceptionAggregator.&lt;RunAsync&gt;d__9.MoveNext() in C:\Dev\xunit\xunit\src\xunit.core\Sdk\ExceptionAggregator.cs:line 90
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.ExceptionAggregator.RunAsync(Func`1 code)
   at Xunit.Sdk.TestInvoker`1.&lt;InvokeTestMethodAsync&gt;d__48.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs:line 239
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestInvoker`1.InvokeTestMethodAsync(Object testClassInstance)
   at Xunit.Sdk.TestInvoker`1.&lt;&lt;RunAsync&gt;b__47_0&gt;d.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestInvoker.cs:line 206
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestInvoker`1.&lt;RunAsync&gt;b__47_0()
   at Xunit.Sdk.ExceptionAggregator.&lt;RunAsync&gt;d__10`1.MoveNext() in C:\Dev\xunit\xunit\src\xunit.core\Sdk\ExceptionAggregator.cs:line 107
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.ExceptionAggregator.RunAsync[T](Func`1 code)
   at Xunit.Sdk.XunitTestRunner.&lt;InvokeTestAsync&gt;d__4.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestRunner.cs:line 67
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.XunitTestRunner.InvokeTestAsync(ExceptionAggregator aggregator)
   at Xunit.Sdk.ExceptionAggregator.&lt;RunAsync&gt;d__10`1.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.ExceptionAggregator.RunAsync[T](Func`1 code)
   at Xunit.Sdk.TestRunner`1.&lt;RunAsync&gt;d__43.MoveNext()
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestRunner`1.RunAsync()
   at Xunit.Sdk.TestCaseRunner`1.&lt;RunAsync&gt;d__19.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestCaseRunner.cs:line 82
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestCaseRunner`1.RunAsync()
   at Xunit.Sdk.XunitTestMethodRunner.RunTestCaseAsync(IXunitTestCase testCase) in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestMethodRunner.cs:line 45
   at Xunit.Sdk.TestMethodRunner`1.&lt;RunTestCasesAsync&gt;d__32.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs:line 136
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestMethodRunner`1.RunTestCasesAsync()
   at Xunit.Sdk.TestMethodRunner`1.&lt;RunAsync&gt;d__31.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestMethodRunner.cs:line 106
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestMethodRunner`1.RunAsync()
   at Xunit.Sdk.TestClassRunner`1.&lt;RunTestMethodsAsync&gt;d__38.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs:line 213
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestClassRunner`1.RunTestMethodsAsync()
   at Xunit.Sdk.TestClassRunner`1.&lt;RunAsync&gt;d__37.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestClassRunner.cs:line 171
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestClassRunner`1.RunAsync()
   at Xunit.Sdk.TestCollectionRunner`1.&lt;RunTestClassesAsync&gt;d__28.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs:line 130
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestCollectionRunner`1.RunTestClassesAsync()
   at Xunit.Sdk.TestCollectionRunner`1.&lt;RunAsync&gt;d__27.MoveNext() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\TestCollectionRunner.cs:line 101
   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start[TStateMachine](TStateMachine&amp; stateMachine)
   at Xunit.Sdk.TestCollectionRunner`1.RunAsync()
   at Xunit.Sdk.XunitTestAssemblyRunner.&lt;&gt;c__DisplayClass14_2.&lt;RunTestCollectionsAsync&gt;b__2() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Frameworks\Runners\XunitTestAssemblyRunner.cs:line 184
   at System.Threading.Tasks.Task`1.InnerInvoke()
   at System.Threading.Tasks.Task.Execute()
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task&amp; currentTaskSlot)
   at System.Threading.Tasks.Task.ExecuteEntry(Boolean bPreventDoubleExecution)
   at Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(SendOrPostCallback callback, Object state) in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs:line 107
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at Xunit.Sdk.ExecutionContextHelper.Run(Object context, Action`1 action) in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\Utility\ExecutionContextHelper.cs:line 22
   at Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc() in C:\Dev\xunit\xunit\src\xunit.execution\Sdk\MaxConcurrencySyncContext.cs:line 89
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.ThreadHelper.ThreadStart(Object obj)
----- end Mon 10/07/2019 20:21:24.52 ----- exit code -532462766 ----------------------------------------------------------
```

cc @bartonjs @krwq @GrabYourPitchforks </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41617</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing comma</Title>
    <Description>
    </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41616</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.2] fix typo in packageIndex.json</Title>
    <Description>
    </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41615</IssueID>
    <RepoID>1</RepoID>
    <Title>Update issue-guide.md</Title>
    <Description>Now I finally now why I never got emails for the infra area.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41614</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add file and directory creation methods that take an ACL</Title>
    <Description>### Summary

.NET ACL (Access Control List) support is Windows specific (`FileSecurity` and `DirectorySecurity`). We keep support in `System.IO.FileSystem.AccessControl` and do not have references to the ACL types in base `System.IO` types in .NET Core (e.g. `File`, `DirectoryInfo`, `FileStream`). We have extension methods in `System.IO.FileSystemAclExtensions` to get and set ACLs instead. We do not, however, have methods that let you create files and directories with a specific ACL set.

This presents a few problems:

- Potential security hole as files/directories can be accessed between creation and modification
- Porting difficulties as there isn't a 1-1 API replacement
- Stability issues with background processes (file filters) can prevent modifying ACLs right after creation (typically surfaces as a security exception)

We need to add helper methods that prevent these problems. Adding back API isn't feasible as `FileStream` lives in CoreLib and would require pulling down a rather large closure (above and beyond putting Windows specific API in front of Unix/cross-plat developers). Having these as extension methods also facilitates writing .NET Standard libraries.

### Proposal

``` C#
using System.Security.AccessControl;

namespace System.IO
{
    public static class FileSystemAclExtensions
    {
        // Add
        public static FileStream Create(
            this FileInfo fileInfo,
            FileMode mode,
            FileSystemRights rights,
            FileShare share,
            int bufferSize,
            FileOptions options,
            FileSecurity fileSecurity);

        public static void Create(
            this DirectoryInfo directoryInfo,
            DirectorySecurity directorySecurity);

        public static FileStream CreateFile(
            this FileSecurity fileSecurity,
            string path,
            FileMode mode,
            FileSystemRights rights,
            FileShare share,
            int bufferSize,
            FileOptions options);

        public static DirectoryInfo CreateDirectory(
            this DirectorySecurity directorySecurity
            string path);

        // Existing
        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo);
        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo, AccessControlSections includeSections);
        public static FileSecurity GetAccessControl(this FileInfo fileInfo);
        public static FileSecurity GetAccessControl(this FileInfo fileInfo, AccessControlSections includeSections);
        public static FileSecurity GetAccessControl(this FileStream fileStream);
        public static void SetAccessControl(this DirectoryInfo directoryInfo, DirectorySecurity directorySecurity);
        public static void SetAccessControl(this FileInfo fileInfo, FileSecurity fileSecurity);
        public static void SetAccessControl(this FileStream fileStream, FileSecurity fileSecurity);
}
```

### Details

Heuristics would follow .NET Framework as closely as possible. Directory creation is the most important of the two as you can prevent malicious file access if the directory is locked from the start.

For directory creation we would likely include the same sources that `System.IO.FileSystem` uses as the directory creation helper there already sets a "default" security object and would just need to have an overload added (which would allow creation heuristics to match properly, including error states).

File creation is a bit more complicated as the logic may take a bit more refactoring, but we should strive to include the same sources as well.

Marking as 3.1 as internal partners are hitting this in porting efforts.

### Related Issues

#31488

CC: @danmosemsft, @ericstj, @terrajobst</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41613</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable flaky member descriptor test</Title>
    <Description>Failed multiple times in CI: https://github.com/dotnet/corefx/issues/40948

The issue itself could be a product bug and @stephentoub set the milestone and label to track it accordingly. This should not hinder us disabling the test in CI.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41612</IssueID>
    <RepoID>1</RepoID>
    <Title>Change JsonSerializer default settings</Title>
    <Description>Provide a way to change the default settings for the static `JsonSerializer` class. In Json.NET, you could do:

```cs
JsonConvert.DefaultSettings = () =&gt; new JsonSerializerSettings();
```

Currently you have to keep passing the options around and remembering to pass it to each call to `[De]Serialize`</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41610</IssueID>
    <RepoID>1</RepoID>
    <Title>6 crypto cng tests are failing consistently in outerloop Windows</Title>
    <Description>Example build: https://dev.azure.com/dnceng/public/_build/results?buildId=378973&amp;view=ms.vss-test-web.build-test-results-tab

```
System.Security.Cryptography.Cng.Tests.AesCngTests.VerifyPersistedKey
System.Security.Cryptography.Cng.Tests.TripleDESCngTests.VerifyPersistedKey
System.Security.Cryptography.Cng.Tests.TripleDESCngTests.SetKey_DetachesFromPersistedKey
System.Security.Cryptography.Cng.Tests.AesCngTests.SetKey_DetachesFromPersistedKey
System.Security.Cryptography.Cng.Tests.AesCngTests.VerifyMachineKey
System.Security.Cryptography.Cng.Tests.TripleDESCngTests.VerifyMachineKey

Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : The parameter is incorrect.

at System.Security.Cryptography.CngKey.SetProperty(CngProperty property) in /_/src/System.Security.Cryptography.Cng/src/System/Security/Cryptography/CngKey.Properties.cs:line 71
   at Internal.Cryptography.BasicSymmetricCipherNCrypt..ctor(Func`1 cngKeyFactory, CipherMode cipherMode, Int32 blockSizeInBytes, Byte[] iv, Boolean encrypting) in /_/src/System.Security.Cryptography.Cng/src/Internal/Cryptography/BasicSymmetricCipherNCrypt.cs:line 36
   at Internal.Cryptography.CngSymmetricAlgorithmCore.CreatePersistedCryptoTransformCore(Func`1 cngKeyFactory, Byte[] iv, Boolean encrypting) in /_/src/System.Security.Cryptography.Cng/src/Internal/Cryptography/CngSymmetricAlgorithmCore.cs:line 181
   at Internal.Cryptography.CngSymmetricAlgorithmCore.CreateCryptoTransform(Boolean encrypting) in /_/src/System.Security.Cryptography.Cng/src/Internal/Cryptography/CngSymmetricAlgorithmCore.cs:line 130
   at Internal.Cryptography.CngSymmetricAlgorithmCore.CreateEncryptor() in /_/src/System.Security.Cryptography.Cng/src/Internal/Cryptography/CngSymmetricAlgorithmCore.cs:line 105
   at System.Security.Cryptography.TripleDESCng.CreateEncryptor() in /_/src/System.Security.Cryptography.Cng/src/System/Security/Cryptography/TripleDESCng.cs:line 79
   at System.Security.Cryptography.Cng.Tests.SymmetricCngTestHelpers.SetKey_DetachesFromPersistedKey(CngAlgorithm algorithm, Func`2 persistedFunc) in /_/src/System.Security.Cryptography.Cng/tests/SymmetricCngTestHelpers.cs:line 159
   at System.Security.Cryptography.Cng.Tests.TripleDESCngTests.SetKey_DetachesFromPersistedKey() in /_/src/System.Security.Cryptography.Cng/tests/TripleDESCngTests.cs:line 53
```

cc @bartonjs @krwq @GrabYourPitchforks</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41609</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable arm64 tests on Win and limit UWP testing</Title>
    <Description>Limit UWP testing to a bare minimum (x64) and disable arm64 testing as we currently don't have enough machines and it's not officially supported.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41607</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.1] Switch to new OSX pool</Title>
    <Description>
    </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41606</IssueID>
    <RepoID>1</RepoID>
    <Title>Updating corefx prerequisites for latest VS 2019 workloads</Title>
    <Description>cc @ViktorHofer, @safern  </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41605</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Add Fedora 32 and CentOS 8 runtime ids</Title>
    <Description>This is combined backport of:

- PR #41397: commit 6f82bd59a05ea9556397596ae9e59f39b904b222
- PR #40786: commit 86fc9e751c424278a9c4e163e0a71a9d7e30c8e7

See also: https://github.com/dotnet/corefx/pull/41549</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41604</IssueID>
    <RepoID>1</RepoID>
    <Title>Ignore ERROR_NOT_FOUND in File.Encrypt test</Title>
    <Description>Makes the test pass when EFS (Encrypted File System) is not available.

I have also fixed the interop definition for Encrypt/DecryptFile P/Invokes while I was on it.

Fixes #39211</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41603</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/2.1] Clean up some tests and move to new Azure endpoint</Title>
    <Description>**Test only fixes**

Port PR #36018 from master branch

This PR changes the Azure test endpoint to use Azure App Service instead of the classic Azure
Cloud Service endpoint. The use of the classic Azure Cloud Service is no longer recommended
since it is harder to maintain.

Once all remaining branches are converted, we will shut down the corefx-net.cloudapp.net
endpoint.

This PR also includes some other test fixes and tests disabled due to active issues.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41601</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace tfm based constants with SDK ones</Title>
    <Description>Fix #40484

Replace constants with SDK constants in Directory.Build.Props.
These SDK constants are based on https://docs.microsoft.com/en-us/dotnet/standard/frameworks#how-to-specify-target-frameworks

cc @ViktorHofer </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41602</IssueID>
    <RepoID>1</RepoID>
    <Title>RSA.ImportRSAPublicKey doesn't work for PEM .net core 3</Title>
    <Description>I'm trying to import public-key parameters from PEM with RSA.ImportRSAPublicKey but it throws System.Security.Cryptography.CryptographicException: 'ASN1 corrupted data'. RSA.ImportRSAPrivateKey works fine for import private-key parameters.

Example:

**for private key** (works fine):

var privateKey = "MIICXAIBAAKBgQCJHYcuRHdJ5S8GYcz/IgF5hJY+vvchVaeKyD+GGSoiD58pRJ3kx5b7YbbP/EyzwhUxWncvbsiWZFdqca/DHsFKxNnRgvidoyq2dgA+erP91aFHpccH2ykNxC6LTzMXX4XWp5mXKm6XfMkBFzsVC4/a7A6UHnsL7MU2b4lec+WkSwIDAQABAoGAMV1zLOIzfGRKAOc3MefhVgm5Og/w04yODHY6AKKQu8CaEfaFTjfZkNnGQq1YRCOtE565aFdfWl335vfVSs+I0UTKYtUdU0DkeZ93nB+eaUIQ/7UC99UlcdSrlRfXGwBxdcwM+Ek93VeITWERydh+xyXN3VxzaYtApA1fB/YGnzkCQQDcb8X6xFigw0qSpHXX+qpBQcTSbIQ5u47vK0VRIkDI3vN3tGBeIpU78kK3E+cHG8e74Nobn1/nJ09TKS4jzoudAkEAnzyDQPD269xzwTvICVMDvezEN4sy3+XJdJjtOdtL4RZKRqOUiaJmKhR1QUtlrG71LqudUiwZ7DnzloKyvLYvBwJAXCyw0GcB2FdQ+3ihfipmvtrNfl+5+poe7otddMup41S24bsfAL3dQS/QDdXYqPRI1Jr1GM/PvkyFsvRpQre/UQJBAIavIDVlmvSUWjQu5Fs+pAOYp75zNmy6Z1L/pmcxXVTdDaYB5jkj61XcR/EaXL0kfK0k6sP+GU79FVNQ6O1FCzECQAD8SLqaJOGbiPYrf+gRx337xQTatlaaXIaRrtNKj4E3/WtyKQQXEILCMDS1Xa88sK12nQgu6DVxOtIs+7cEvds=";
var rsa = RSA.Create();
rsa.ImportRSAPrivateKey(Convert.FromBase64String(privateKey), out _); 

**for public key**(throws exception):

var publicKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCJHYcuRHdJ5S8GYcz/IgF5hJY+vvchVaeKyD+GGSoiD58pRJ3kx5b7YbbP/EyzwhUxWncvbsiWZFdqca/DHsFKxNnRgvidoyq2dgA+erP91aFHpccH2ykNxC6LTzMXX4XWp5mXKm6XfMkBFzsVC4/a7A6UHnsL7MU2b4lec+WkSwIDAQAB";
var rsa = RSA.Create();
rsa.ImportRSAPublicKey(Convert.FromBase64String(publicKey), out _);


Maybe I'm doing something wrong?</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41600</IssueID>
    <RepoID>1</RepoID>
    <Title>Add ImmutableInterlocked.Update overloads for ImmutableArray</Title>
    <Description>The implementations and tests just copy the exist Update overloads, tweaked to work with ImmutableArray.

Fixes https://github.com/dotnet/corefx/issues/19408
cc: @sharwell, @AArnott </Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41599</IssueID>
    <RepoID>1</RepoID>
    <Title>Converting newtonsoft code to System.Text.Json. what's equivalent of  JObject.Parse</Title>
    <Description>I am converting my newtonsooft implementeation to new javascript library in .net core 3.0
I have one of the following code

```
 public static bool IsValidJson(string json)
        {
            try
            {                
                
                JObject.Parse(json);
                return true;
            }
            catch (Exception ex)
            {
                Logger.ErrorFormat("Invalid Json Received {0}", json);
                Logger.Fatal(ex.Message);
                return false;
            }
        }
```

I am not able to find any equivalent for  JObject.Parse(json);

Also what will be the attribute JsonProperty equivalent 

 public class ResponseJson
    {
        [JsonProperty(PropertyName = "status")]
        public bool Status { get; set; }
        [JsonProperty(PropertyName = "message")]
        public string Message { get; set; }
        [JsonProperty(PropertyName = "Log_id")]
        public string LogId { get; set; }
        [JsonProperty(PropertyName = "Log_status")]
        public string LogStatus { get; set; }

        public string FailureReason { get; set; }
    }</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41598</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json - Collection was of a fixed size. Error on IEnumerable property</Title>
    <Description>I have a class with this:

```
class Dealer {
        [JsonIgnore]
        [StringLength( MaxNetworksLength )]
        public string Networks {
            get =&gt; _Networks;
            set =&gt; _Networks = value ?? string.Empty;
        }

        public IEnumerable&lt;string&gt; NetworkCodeList {
            get =&gt; !string.IsNullOrEmpty( Networks ) ? Networks?.Split( ',' ) : new string[0];
            set =&gt; Networks = (value != null) ? string.Join( ",", value ) : string.Empty;
        }
}
```

The Networks property is used by Dapper to read/write to and from the database.
The NetworkCodeList is sent/received to and from a web page.

I am getting an error when ASP.NET is Deserializing the object. This worked fine with Json.Net.
Any ideas what I can do here?

```
System.NotSupportedException: Collection was of a fixed size.
   at System.SZArrayHelper.Add[T](T value)
   at System.Text.Json.JsonSerializer.ApplyValueToEnumerable[TProperty](TProperty&amp; value, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfoNotNullable`4.OnReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.ReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadCore(JsonReaderState&amp; readerState, Boolean isFinalBlock, ReadOnlySpan`1 buffer, JsonSerializerOptions options, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadAsync[TValue](Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonInputFormatter.ReadRequestBodyAsync(InputFormatterContext context, Encoding encoding)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonInputFormatter.ReadRequestBodyAsync(InputFormatterContext context, Encoding encoding)
   at Microsoft.AspNetCore.Mvc.ModelBinding.Binders.BodyModelBinder.BindModelAsync(ModelBindingContext bindingContext)
   at Microsoft.AspNetCore.Mvc.ModelBinding.ParameterBinder.BindModelAsync(ActionContext actionContext, IModelBinder modelBinder, IValueProvider valueProvider, ParameterDescriptor parameter, ModelMetadata metadata, Object value)
   at Microsoft.AspNetCore.Mvc.Controllers.ControllerBinderDelegateProvider.&lt;&gt;c__DisplayClass0_0.&lt;&lt;CreateBinderDelegate&gt;g__Bind|0&gt;d.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.&lt;InvokeInnerFilterAsync&gt;g__Awaited|13_0(ControllerActionInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeFilterPipelineAsync&gt;g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware.&lt;Invoke&gt;g__Awaited|6_0(ExceptionHandlerMiddleware middleware, HttpContext context, Task task)
```
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41597</IssueID>
    <RepoID>1</RepoID>
    <Title>Add ConcurrentDictionary.TryRemove(KeyValuePair)</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/24770</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41596</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191006.5
- **Date Produced**: 10/6/2019 8:31 PM
- **Commit**: 3fccad76fc65967dc194983284c3a43de37e95a0
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19506.5
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19506.5
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19506.5

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191006.4
- **Date Produced**: 10/7/2019 1:07 AM
- **Commit**: 38aa9151607cb63bb569beb42880057ba2cd3da0
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19506.4
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19506.4

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191006.2
- **Date Produced**: 10/6/2019 12:57 PM
- **Commit**: e404989701df61ba81c357933113e3037c1624c0
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19506.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41595</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: Add compression support in WebSocket</Title>
    <Description>See discussion here #15430.

At the moment the WebSocket doesn't support per-message deflate (see https://tools.ietf.org/html/rfc7692#section-7). Adding support for it in the BCL will mean that people (myself including) will no longer resort to implementing custom WebSockets in order to use it.

Proposed API
---
``` csharp
/// &lt;summary&gt;
/// Options to enable per-message deflate compression for &lt;seealso cref="WebSocket" /&gt;.
/// &lt;/summary&gt;
public sealed class WebSocketCompressionOptions
{
    /// &lt;summary&gt;
    /// This parameter indicates the base-2 logarithm of the LZ77 sliding window size of the client context.
    /// Must be a value between 8 and 15 or -1 indicating no preferences. The default is -1.
    /// &lt;/summary&gt;
    public int ClientMaxWindowBits { get; set; } = -1;

    /// &lt;summary&gt;
    /// When true, the client informs the peer server of a hint that even if the server doesn't include the
    /// "client_no_context_takeover" extension parameter in the corresponding
    /// extension negotiation response to the offer, the client is not going to use context takeover. The default is false.
    /// &lt;/summary&gt;
    public bool ClientNoContextTakeover { get; set; }

    /// &lt;summary&gt;
    /// This parameter indicates the base-2 logarithm of the LZ77 sliding window size of the server context.
    /// Must be a value between 8 and 15 or -1 indicating no preferences. The default is -1.
    /// &lt;/summary&gt;
    public int ServerMaxWindowBits { get; set; } = -1;

    /// &lt;summary&gt;
    /// When true, the client prevents the peer server from using context takeover. If the peer server doesn't use context
    /// takeover, the client doesn't need to reserve memory to retain the LZ77 sliding window between messages. The default is false.
    /// &lt;/summary&gt;
    public bool ServerNoContextTakeover { get; set; }
}

public sealed class ClientWebSocketOptions
{
    /// &lt;summary&gt;
    /// Instructs the &lt;seealso cref="ClientWebSocket" /&gt; to try and negotiate per-message compression.
    /// &lt;/summary&gt;
    public WebSocketCompressionOptions Compression { get; set; }
}

public enum WebSocketOutputCompression
{
    /// &lt;summary&gt;
    /// Enables output compression if the underlying &lt;seealso cref="WebSocket" /&gt; supports it.
    /// &lt;/summary&gt;
    Default,

    /// &lt;summary&gt;
    /// Suppresses output compression for the next message.
    /// &lt;/summary&gt;
    SuppressOne,

    /// &lt;summary&gt;
    /// Suppresses output compression.
    /// &lt;/summary&gt;
    Suppress
}

public abstract class WebSocket
{
    /// &lt;summary&gt;
    /// Instructs the socket to compress (or not to) the messages being sent when
    /// compression has been successfully negotiated.
    /// &lt;/summary&gt;
    public WebSocketOutputCompression OutputCompression { get; set; } 

    public static WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval, WebSocketCompressionOptions compression);
}
```

Rationale and Usage
---

The main drive behind the API is that we should not introduce any breaking changes. WebSockets already built will work as is. This is why I suggest we add new **CreateFromStream** method with `WebSocketCompressionOptions` parameter instead of adding it to the existing one.

There are a few options built in the WebSocket compression protocol that are considered advance use - controlling the size of the LZ77 sliding window, context takeover. We could easily hide them and choose reasonable defaults, but I think there are good use cases for them and as such we should expose them. See this blog post for good example of their usage: https://www.igvita.com/2013/11/27/configuring-and-optimizing-websocket-compression/.

The usage of the WebSocket would not change at all. By default a WebSocket created with compression options would compress all messages if the connection on the other end supports it. We introduce `OutputCompression` property to allow explicit opt out. The property has no effect if compression is not supported for the current connection.

Here is example of how we would disable compression for specific messages:
``` csharp
var socket = GetWebSocket();

// Disable compression for the next message only
socket.OutputCompression = WebSocketCompressionOptions.SuppressOne;
await socket.SendAsync(...);
```

Here is example for WebSocketClient:
``` csharp
var client = new WebSocketClient();

// Indicate that we want compression if server supports it
client.Options.Compression = new WebSocketCompressionOptions();

await client.ConnectAsync(...);

// Same as before. If compression is enabled it will be performed automatically.
client.SendAsync(...); 

// If we need to explicitly disable compression for a time or specific messages
client.OutputCompression = WebSocketOutputCompression.Suppress;

// Send one or more messages
// ...

// Restore default compression state
client.OutputCompression = WebSocketOutputCompression.Default; 
```

 Additional work will be required in AspNetCore repository and more specifically WebSocketMiddleware to light up the compression feature.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41594</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191006.2
- **Date Produced**: 10/7/2019 1:37 AM
- **Commit**: af55c1b707d27a938c65742dc2522d88d7580108
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19506.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19506.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19506.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41593</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191006.1
- **Date Produced**: 10/6/2019 12:59 PM
- **Commit**: 7acc732c615d2c2326cd347c8c1841a300a632cb
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19506.1
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19506.1
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19506.1

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41592</IssueID>
    <RepoID>1</RepoID>
    <Title>Where are the unit tests for Systems.Collections.Generic?</Title>
    <Description>I've not been able to find the tests for any of the types in https://github.com/dotnet/corefx/tree/master/src/Common/src/CoreLib/System/Collections/Generic

System.Linq has tests in a directory called tests (e.g. https://github.com/dotnet/corefx/blob/master/src/System.Linq/tests/FirstTests.cs).
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41591</IssueID>
    <RepoID>1</RepoID>
    <Title> Could not load type 'System.Text.Json.JsonDocumentOptions' from assembly 'System.Text.Json, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'</Title>
    <Description>Hi I am having this issue when trying to migrate my identityserver4 server to dotnetcore3.0 : 

`TypeLoadException: Could not load type 'System.Text.Json.JsonDocumentOptions' from assembly 'System.Text.Json, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51'.
Microsoft.AspNetCore.Authentication.Google.GoogleHandler.CreateTicketAsync(ClaimsIdentity identity, AuthenticationProperties properties, OAuthTokenResponse tokens)
System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine)
System.Runtime.CompilerServices.AsyncTaskMethodBuilder&lt;TResult&gt;.Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine)
Microsoft.AspNetCore.Authentication.Google.GoogleHandler.CreateTicketAsync(ClaimsIdentity identity, AuthenticationProperties properties, OAuthTokenResponse tokens)
Microsoft.AspNetCore.Authentication.OAuth.OAuthHandler&lt;TOptions&gt;.HandleRemoteAuthenticateAsync()
Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler&lt;TOptions&gt;.HandleRequestAsync()`

The version I am using : 
`
Host (useful for support):
  Version: 3.0.0-preview-27324-5
  Commit:  63a01b08e5

.NET Core runtimes installed:
  Microsoft.AspNetCore.App 3.0.0-preview-19075-0444 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 3.0.0-preview-27324-5 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

`

Thanks !</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41590</IssueID>
    <RepoID>1</RepoID>
    <Title>InvalidCastException when deserialising invalid List/IEnumerable from JSON</Title>
    <Description>```csharp
using System;
using System.Collections.Generic;
using System.Text.Json;

namespace DotNetTest
{
    class Program
    {
        static void Main(string[] args)
        {
            var json = @"{ ""MyList"": ""not a list!"" }";
            try
            {
                JsonSerializer.Deserialize&lt;ModelWithList&gt;(json);
                Console.WriteLine($"Deserialization of '{json}' to ModelWithList succeeded!");
            }
            catch (Exception e)
            {
                Console.Write($"Deserialization of '{json}' to ModelWithList failed: ");
                Console.WriteLine(e);
            }
        }
    }

    class ModelWithList
    {
        public List&lt;string&gt; MyList { get; set; }
    }
}
```

I would expect this to result in a JsonException, but it actually results in an InvalidCastException:
```
Deserialization of '{ "MyList": "not a list!" }' to ModelWithList failed: System.InvalidCastException: Unable to cast object of type 'System.String' to type 'System.Collections.Generic.IEnumerable`1[System.String]'.
   at System.Text.Json.JsonPropertyInfoCommon`4.SetValueAsObject(Object obj, Object value)
   at System.Text.Json.JsonSerializer.ApplyValueToEnumerable[TProperty](TProperty&amp; value, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfoNotNullable`4.OnReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.ReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
   at DotNetTest.Program.Main(String[] args) in C:\work\DotNetTest\Program.cs:line 14
```</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41589</IssueID>
    <RepoID>1</RepoID>
    <Title>Updating global.json to pick preview SDKs</Title>
    <Description>Using the spec from https://github.com/dotnet/designs/pull/71. This behavior is implemented but not yet documented.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41611</IssueID>
    <RepoID>1</RepoID>
    <Title>DateTime.Date ToString() - .net core 2.2. - console/windowsservice differences</Title>
    <Description># Issue Title

DateTime.Date ToString() - .net core 2.2. - console/windowsservice differences
# General

Hi, i`v found an issue with DateTime.Date in app runned as a console and as a windows service (Local System user)

Log:
As a console app:
2019/10/07 10:59:32.864|DEBUG|: DateTime.Now: 2019-10-07 10:59:32 DateTime.Now.Date: **2019-10-07 0:00:00** 
As a windows service:
2019/10/07 10:59:36.370|DEBUG|: DateTime.Now: 10/7/2019 10:59:36 AM DateTime.Now.Date: **10/7/2019 12:00:00 AM** 

Arythmethic operations are calulated ok (from the midnight), but returned time part is wrong
2019/10/07 10:59:36.372|DEBUG|: DateTime.Now.AddHours(-11): 10/6/2019 11:59:36 PM DateTime.Now.AddHours(-11).Date: **10/6/2019 12:00:00 AM** 

Both tests have:
2019/10/07 10:59:32.872|DEBUG|: CultureInfo.CurrentCulture: en-US 
2019/10/07 10:59:32.872|DEBUG|: TimeZoneInfo.Local.GetUtcOffset(02:00:00)
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41587</IssueID>
    <RepoID>1</RepoID>
    <Title>MemoryCache use of seldom used fields</Title>
    <Description>I've noticed that a portion of the memory allocated by [MemoryCache ](https://github.com/dotnet/corefx/blob/0cc22ccba707d7552159363d586262fa9c4e8a2a/src/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCacheEntry.cs) is on this internal class called [SeldomUsedFields](https://github.com/dotnet/corefx/blob/0cc22ccba707d7552159363d586262fa9c4e8a2a/src/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCacheEntry.cs#L33) and it seems to me that it is being allocated without reason most of the time.
MemoryCacheEntry, which is the object holding the value on the cache store, checks whether there are interested parties to receive notifications but it does so by checking if the collection is null 
https://github.com/dotnet/corefx/blob/0cc22ccba707d7552159363d586262fa9c4e8a2a/src/System.Runtime.Caching/src/System/Runtime/Caching/MemoryCacheEntry.cs#L149-L154

however it will never be null when a cache policy is present since CacheItemPolicy will not allow it 

https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.Runtime.Caching/src/System/Runtime/Caching/CacheItemPolicy.cs#L25-L35

Therefore I dont see how it is posible to tell MemoryCache to use an expiration offset (or any other kind of directive) and at the same time avoid SeldomUsedFields allocations. Is the condition (checking for nulls) wrong or is there another way to skip SeldomUsedFields to reduce allocated memory? We're trying to store between 300k and 500k objects and it would make an impact on that effort.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41586</IssueID>
    <RepoID>1</RepoID>
    <Title>Where is SO_BINDTODEVICE in System.Net.Sockets.SocketOptionName ?</Title>
    <Description>Hey,

I would like to perform a HTTP query with `Socket` using a specific linux interface, by example eth1, how its possible to do this ?

Thank you!!
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41585</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @jkotas</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41584</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Fix HtmlEncode handling of surrogate pairs (#41576)</Title>
    <Description>Port #41576 to release/3.0.
Fixes https://github.com/dotnet/corefx/issues/41570

## Description

WebUtility.HtmlEncode (which is also the implementation for HttpUtility.HtmlEncode) was changed in 3.0 from using pointers to using span.  In doing so, a regression was introduced where as it iterates through all of the characters, when it finds a surrogate, rather than looking at the current two characters in the string, it instead looks at the first two characters in the string, thus making the wrong replacement.

## Customer Impact

Surrogate pairs that appear anywhere other than at the beginning of the string being encoded are encoded incorrectly.

## Regression?

Yes, from .NET Core 2.2 and .NET Framework.

## Testing

New tests were added.  Previously tests were only validating when the surrogate pair was at the beginning.

## Risk

Low.  It's changing some indexing to be based off of the current position rather than off of 0, all accesses are bounds-checked, if the index was 0 it's obvious from a code inspection that there's no change in behavior, and if the index isn't 0 it was already wrong.</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41583</IssueID>
    <RepoID>1</RepoID>
    <Title>Support `string` and `int` enums simultaneously in Text.Json</Title>
    <Description>I have an endpoint that receives payloads from a third party which sends the enums as string, so I added `new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } }` to my adapter. However, this broke the rest of the endpoints that receive enums as int.

Both the default int enum converter and `JsonStringEnumConverter` should work at the same time.</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41582</IssueID>
    <RepoID>1</RepoID>
    <Title>Unable to use System.Management facilities on MacOs</Title>
    <Description>Repro steps:

- Create a .NET Core 3.0 app test project (using SpecFlow and xUnit)
- Create a .NET Core 3.0 library project
- Use `System.Management`-related code within the library project

Expected: It just works (and it used to)
Actual: It doesn't (which is frustrating)

More info:
Error - System.PlatformNotSupportedException : System.Management currently is only supported for Windows desktop applications.
Env - MacOs latest, running from VS for Mac latest
Stack Trace - includes the code `ManagementObjectSearcher searcher = new ManagementObjectSearcher
                ("Select * From Win32_Process Where ParentProcessID=" + pid);`

It looks like this should have never worked but apparently it did...</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41581</IssueID>
    <RepoID>1</RepoID>
    <Title>Change an internal Hashtable to a Dictionary.</Title>
    <Description>
    </Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41580</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191005.3
- **Date Produced**: 10/6/2019 12:49 AM
- **Commit**: d364ea3043c45eb91b0b0f1d6bedba3cca129a96
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19505.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19505.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19505.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41579</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191005.1
- **Date Produced**: 10/5/2019 12:53 PM
- **Commit**: 13e1dbd86223eaa797655bf14070ea28ce6461e3
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19505.1
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19505.1
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19505.1

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191005.6
- **Date Produced**: 10/6/2019 4:22 AM
- **Commit**: 575362a5705c749dce2eb4797f9d23fe4731884a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19505.6
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19505.6
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19505.6

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191005.5
- **Date Produced**: 10/6/2019 3:54 AM
- **Commit**: 6de42378223c6cb138d28f812c440092718c7a19
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19505.5
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19505.5

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191005.2
- **Date Produced**: 10/5/2019 12:42 PM
- **Commit**: 30c26d7b843b73049def6e34fd48615e0db724d9
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19505.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41578</IssueID>
    <RepoID>1</RepoID>
    <Title>Support for EnumMemberAttribute in JsonConverterEnum</Title>
    <Description>Hi, I wonder if supporting EnumMemberAttribute in JsonConverterEnum is planned and if so what the ETA is?

&gt;Json.NET supports EnumMemberAttribute to customize enum name values. It is a well used feature.
&gt;
&gt;You don't need it in 3.0, but you will get a lot of requests for customizing enum names. Design for adding it in the future.
&gt;
&gt;_Originally posted by @JamesNK in https://github.com/dotnet/corefx/pull/38702#issuecomment-503777812_</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41577</IssueID>
    <RepoID>1</RepoID>
    <Title>Added a test scenario to verify that  Nullable&lt;T&gt; is not assignable from T</Title>
    <Description>For any substitution of `T`, like for example `int` there is assignability.
For example  `Nullable&lt;int&gt;` is assignable from `int`  because boxed forms have the same representation.

However generically `Nullable&lt;T&gt;` is not assignable from `T`.

This is subtle and easy to regress when touching castability. (as I found in https://github.com/dotnet/coreclr/pull/23548).

Looks like we have no tests for this. So adding a scenario.</Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41576</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix HtmlEncode handling of surrogate pairs</Title>
    <Description>Due to a regression that came as part of changing the code from using pointers to using spans, when the surrogate pair isn't at the beginning of the the input, it's incorrectly encoded.

Fixes https://github.com/dotnet/corefx/issues/41570
cc: @ViktorHofer, @GrabYourPitchforks </Description>
    <CreatedDate>06/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41588</IssueID>
    <RepoID>1</RepoID>
    <Title>TcpClient very slow connecting to "localhost"</Title>
    <Description># Issue Title

TcpClient very slow connecting to "localhost"

# General

We are seeing a major performance regression when connecting using "localhost" . This use to take less than 1 millisecond, but now takes over 2 seconds.  The following snipped replicates the behaviour.

TcpClient client = new TcpClient();
client.Connect ("localhost",5060);

Using 127.0.0.1 as a workaround does not have this problem.
The code in Dot Net Framework 4,4.5,4.7,4.8, and Dot Net Core 2.1 does not exhibit this delay.

Connecting to IIS on port 80, does not exhibiting this delay.

Tested against latest version of Windows 10, and Visual Studio 16,3,2, and Dot Net Core 3.0 RTM

We are experiencing this on our InMemory.Net Database server. This can be downloaded from https://www.inmemory.net

</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41575</IssueID>
    <RepoID>1</RepoID>
    <Title>Q: How to work on System.Threading.Tasks and System.Threading?</Title>
    <Description>Currently almost all of the classes from `System.Threading.Tasks` and `System.Threading` namespaces are placed in [https://github.com/dotnet/corefx/tree/master/src/Common/src/CoreLib/System/Threading](https://github.com/dotnet/corefx/tree/master/src/Common/src/CoreLib/System/Threading) and they don't have any solutions to work with. How could I work on them and contribute? What's the dev/contributer-guide?</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41574</IssueID>
    <RepoID>1</RepoID>
    <Title>XmlDocument incorrectly serializes elements with an empty-string child text node when pretty-printing</Title>
    <Description>`System.Xml.XmlDocument` - unlike `System.Xml.Linq.XDocument` - incorrectly serializes an element that has an empty-string child text node when producing pretty-printed output.

(The idea behind creating an empty-string child text node - as opposed to using a _truly empty_ (childless) element - is to force serialization of such an element in the `&lt;tag&gt;&lt;/tag&gt;` form, as opposed to in the self-closing empty-tag form (`&lt;tag /&gt;`).
For a real-world scenario and manifestation of this bug, see [this StackOverflow question](https://stackoverflow.com/q/58246585/45375).)

### Steps to reproduce:

```csharp
using System;
using System.Xml;
using System.IO;

public static class Program
{
  public static void Main()
  {

    var xd = new XmlDocument();
    xd.LoadXml("&lt;root&gt;&lt;Elem/&gt;&lt;/root&gt;");

    // Add an empty-string child text node to &lt;Elem&gt;
    xd.DocumentElement.FirstChild.InnerText = "";
    
    xd.Save("t.xml");

    Console.WriteLine(File.ReadAllText("t.xml"));
 }

}
```

### Expected output:

```none
&lt;root&gt;
  &lt;Elem&gt;&lt;/Elem&gt;
&lt;/root&gt;
```
That is, the element should serialize in the `&lt;tag&gt;...&lt;/tag&gt;` form, with the empty string as the (implied) inner text.

### Actual output:

```
&lt;root&gt;
  &lt;Elem&gt;
  &lt;/Elem&gt;
&lt;/root&gt;
```

That is, the element unexpectedly serialized across _two lines_, which introduced extraneous whitespace as the value of the `&lt;Elem&gt;` element (the value of its child text node).
</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41573</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer.Serialize(this) ignores derived class members</Title>
    <Description>The following code produces results differently for System.Text.Json and Newtonsoft.Json

```csharp
class Program
{
    static void Main(string[] args)
    {
        var b = new PlayerA { Name = "I am Player A", Test = "Hello" };
        var blowJson = b.GetJson();
        var goodJson = b.GetNewtonsoftJson();
        
        Console.WriteLine(blowJson);
        // {}

        Console.WriteLine(goodJson);
        // {"Name":"I am Player A","Test":"Hello"}
    }
}

public class JsonablePlayer
{
    public string GetJson()
    {
        return System.Text.Json.JsonSerializer.Serialize(this);
    }

    public string GetNewtonsoftJson()
    {
        return Newtonsoft.Json.JsonConvert.SerializeObject(this);
    }
}

class PlayerA : JsonablePlayer
{
    public string Name { get; set; }
    public string Test { get; set; }
}
```

I am migrating Newtonsoft.Json to System.Text.Json. And this caused a bug in my system. 

My design was using this trick to serialize settings classes into database: https://github.com/EdiWang/Moonglade/blob/master/src/Moonglade.Configuration/BlogConfig.cs#L89

I put GetJson() method in a base class instead of in an Interface so that I don't have to implement the interface every time with the same code in every settings class

Base Class:
https://github.com/EdiWang/Moonglade/blob/master/src/Moonglade.Configuration/Abstraction/MoongladeSettings.cs

Example Settings Class:
https://github.com/EdiWang/Moonglade/blob/master/src/Moonglade.Configuration/GeneralSettings.cs.

It worked perfectly with Newtonsoft.Json. I wonder if there is a workaround for this in System.Text.Json?</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41572</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191004.6
- **Date Produced**: 10/5/2019 1:01 AM
- **Commit**: 9d92b3b23309ebb5f65707e206a004d2115a6f91
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19504.6
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19504.6
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19504.6

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41571</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191004.2
- **Date Produced**: 10/5/2019 1:24 AM
- **Commit**: 380eaaf663b425943754a15b29e814df0bb1b078
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19504.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19504.2
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19504.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191004.16
- **Date Produced**: 10/5/2019 3:32 AM
- **Commit**: 96ed7d1ffb1a3662751bc650a8d6bd09511f11e3
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19504.16
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19504.16
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19504.16

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191004.9
- **Date Produced**: 10/5/2019 3:05 AM
- **Commit**: 99ea2b5aebf7361a5baa638c978cb6214fca5217
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19504.9
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19504.9

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191004.1
- **Date Produced**: 10/4/2019 12:41 PM
- **Commit**: 67beb7a84fca6966fe99f7f3d028666fd8cb73ec
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19504.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41570</IssueID>
    <RepoID>1</RepoID>
    <Title>mistakes on WebUtility.HtmlEncode</Title>
    <Description>https://github.com/dotnet/corefx/blob/99ea2b5aebf7361a5baa638c978cb6214fca5217/src/System.Runtime.Extensions/src/System/Net/WebUtility.cs#L651

should be 
`char leadingSurrogate = input[index];`</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41569</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace Stack with Stack&lt;T&gt; in XmlDataLoader</Title>
    <Description>This looks like the only remaining uses of the non-generic Stack in a trimmed web api app.</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41568</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unused usings from System.Security.Cryptography.Xml</Title>
    <Description>I was looking for uses of "using System.Linq;".  One file had it, but it turned out to be unused/unnecessary, so as long as I was removing it, I ran VS' "remove unused usings" on the project.</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41567</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Linq dependency from System.Security.Cryptography.Encoding</Title>
    <Description>
    </Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41566</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Linq dependency from System.Net.NetworkInformation</Title>
    <Description>It was only being used on Unix, and the uses are all easily replaced with more efficient implementations.</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41565</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191004.3
- **Date Produced**: 10/4/2019 10:28 PM
- **Commit**: 28f54a4013e85774e2a2793c5c7ca2b36948f996
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19504.3
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19504.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19504.3

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41564</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Linq dependency from System.Security.Cryptography.X509Certificates</Title>
    <Description>System.Linq was only being used in two places:
- In Pkcs10CertificateRequestInfo, it was using Collection&lt;&gt;.Select(...).ToArray().  We can replace it with a simple for loop, which is both faster (e.g. fewer delegate invocations) and fewer generic instantiations (no one else is going to have an instantiation with AttributeAsn).
- In LoadMachineStores on Linux, it was using Prepend.  We can avoid the need for Prepend (and the associated allocations) entirely by slightly reorganizing the method and using a local function.</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41563</IssueID>
    <RepoID>1</RepoID>
    <Title>RSA.ImportRSAPublicKey in .Net Core 3 not working</Title>
    <Description>I'm trying to initialize an RSA instance via `ImportRSAPublicKey` and I'm getting an `ASN1 corrupted data.` error.

Simple case:
```
var r1 = RSA.Create();
var base = new RSACryptoServiceProvider(4096);

// throws
r1.ImportRSAPublicKey(base.ExportSubjectPublicKeyInfo(), out _);

// what I want/need
return new RsaSecurityKey(r1);
```

Version Info reference:
```
#region Assembly System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// C:\Program Files (x86)\dotnet\packs\Microsoft.NETCore.App.Ref\3.0.0\ref\netcoreapp3.0\System.Security.Cryptography.Algorithms.dll
#endregion
```

Do I need to do some other conversion first?</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>06/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41562</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix naming of the relevant methods to Deserialize/Serialize in docs</Title>
    <Description>Needed after https://github.com/dotnet/corefx/pull/38933

cc @ahsonkhan </Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41561</IssueID>
    <RepoID>1</RepoID>
    <Title>Update the hex value for DarkSeaGreen color</Title>
    <Description>Update the hex value for DarkSeaGreen color to 0xFF8FBC8F.

Based on W3 definition, the hex value for DarkSeaGreen color needs to be fixed:
https://www.w3.org/wiki/CSS/Properties/color/keywords

No issues were created for this problem but one comment has been made previously:
https://github.com/dotnet/corefx/commit/97c736e09f2e119d6ec3d3ebebb7234dee48145d#r35239355
</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41560</IssueID>
    <RepoID>1</RepoID>
    <Title>Xamarin app is throwing System.NotImplementedException: byref delegate</Title>
    <Description>Looking at the code reference below the exception is getting thrown where a return used to exist..(commented out)

Are there plans to update and return a valid value? causes multiple exceptions per day per user

https://github.com/dotnet/corefx/blob/09698dd91c53e123d3a0f1240b5f611b3c14639c/src/System.Linq.Expressions/src/System/Linq/Expressions/Interpreter/LightLambda.cs#L352

Exception thrown is:
System.NotImplementedException: byref delegate
  at System.Linq.Expressions.Interpreter.LightLambda.CreateCustomDelegate (System.Type delegateType) &lt;0x1052b3620 + 0x00738&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Linq.Expressions.Interpreter.LightLambda.MakeDelegate (System.Type delegateType) &lt;0x1052b3da0 + 0x0005f&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Linq.Expressions.Interpreter.LightDelegateCreator.CreateDelegate (System.Runtime.CompilerServices.IStrongBox[] closure) &lt;0x1052ac220 + 0x0006f&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Linq.Expressions.Interpreter.LightDelegateCreator.CreateDelegate () &lt;0x1052ac1e0 + 0x0002f&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Linq.Expressions.Expression`1[TDelegate].Compile (System.Boolean preferInterpretation) &lt;0x105274ea0 + 0x0005f&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Linq.Expressions.Expression`1[TDelegate].Compile () &lt;0x105274e60 + 0x0002f&gt; in &lt;b17c8f8ec0e94e6aa946d54abe0cfd86#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at Unity.UnityContainer+&lt;&gt;c__DisplayClass111_0.&lt;OptimizingFactory&gt;b__1 () &lt;0x106163780 + 0x003a3&gt; in &lt;f5d5eaafc5e641898d8fba8b91c55f8c#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Threading.Tasks.Task.InnerInvoke () &lt;0x104c02870 + 0x00077&gt; in &lt;939d99b14d934342858948926287beba#d5047ea47da6b88a294b7510b13ff6ef&gt;:0 
  at System.Threading.Tasks.Task.Execute () &lt;0x104c02550 + 0x0003b&gt; in &lt;939d99b14d934342858948926287beba#d5047ea47da6b88a294b7510b13ff6ef&gt;:0</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41559</IssueID>
    <RepoID>1</RepoID>
    <Title>Support For Getting base-64 String as Byte Array</Title>
    <Description>Reimplementation to solve problems from #41464. Only added one test where the method returns false as suggested:

&gt; This needs a lot more tests... whitespace-containing, two trailing =, zero trailing =, something that returns false (including zero, one, and two trailing = in the false-returning inputs)

but the rest of these cases should with this reimplementation be covered by [Convert.FromBase64.cs](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/tests/System/Convert.FromBase64.cs).

Solves #41132. Implemented support for getting JsonString encoded in base-64 as an equivalent byte array.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41558</IssueID>
    <RepoID>1</RepoID>
    <Title>Simple vanilla WebAPI causes problems in containers - inotify limits</Title>
    <Description>Hi,

We have the following setup:
- Docker version 18.09.6-dev, build 95c7371304f9cef494efe93f0a8ffd53a75eac21
- .NET Core 2.2 
- Unix system (based on Yocto OS)

We measured the number of notify instances with:
```for foo in /proc/*/fd/*; do readlink -f $foo; done | grep inotify | sort | uniq -c | sort -nr```

Once we hit the configured number of inotify instances we see the following errors:
```
Unhandled Exception: System.IO.IOException: The configured user limit (128) on the number of inotify instances has been reached.
   at System.IO.FileSystemWatcher.StartRaisingEvents()
   at System.IO.FileSystemWatcher.StartRaisingEventsIfNotDisposed()
   at System.IO.FileSystemWatcher.set_EnableRaisingEvents(Boolean value)
   at Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.TryEnableFileSystemWatcher()
   at Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.CreateFileChangeToken(String filter)
   at Microsoft.Extensions.FileProviders.PhysicalFileProvider.Watch(String filter)
   at Microsoft.Extensions.Configuration.FileConfigurationProvider.&lt;.ctor&gt;b__0_0()
   at Microsoft.Extensions.Primitives.ChangeToken.OnChange(Func`1 changeTokenProducer, Action changeTokenConsumer)
   at Microsoft.Extensions.Configuration.FileConfigurationProvider..ctor(FileConfigurationSource source)
   at Microsoft.Extensions.Configuration.Json.JsonConfigurationSource.Build(IConfigurationBuilder builder)
grabbing logs: error opening journald follow descriptor: "Too many open files"
grabbing logs: error opening journald follow descriptor: "Too many open files"
```

Temporary we fixed the error by configuring a larger number: ```sysctl -w fs.inotify.max_user_instances=512```. 

But this is not ok having into account that containers can be restarted multiple times and we will still hit this limit after 10 restarts.


What we tried:
1. Disable reloadOnChange by using custom WebHostBuilder
```
  public static IWebHostBuilder DefaultWebHostBuilder(string[] args)
        {
            return new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .ConfigureAppConfiguration((hostingContext, config) =&gt;
                {
                    config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: false);
                    config.AddEnvironmentVariables();
                    if (args != null)
                    {
                        config.AddCommandLine(args);
                    }
                })
                .ConfigureLogging((hostingContext, logging) =&gt;
                {
                    logging.AddConfiguration(hostingContext.Configuration.GetSection("Logging"));
                    logging.AddConsole(options =&gt; options.IncludeScopes = true);
                })
                .UseDefaultServiceProvider((context, options) =&gt;
                {
                    options.ValidateScopes = context.HostingEnvironment.IsDevelopment();
                });
      }
```
This didn’t help. The number of inotify instances still increased after container restart.

2. Configure ENV DOTNET_USE_POLLING_FILE_WATCHER=true in dockerfile.

This didn’t help either. The number of inotify objects increased after container restart.

We don't need any file watching, the file handle should be closed properly after the file has been read. How can we accomplish this? Updating to asp .netcore 3.0 isn't an option, a fix should be provided.

Any info and update is welcome, we can provide more info if needed.


This is related to: https://github.com/dotnet/corefx/issues/32024 however this was closed without a proper fix to turn off the file watching.





</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41557</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Utf8String ref asms, react to API changes</Title>
    <Description>Ref assemblies and unit tests for https://github.com/dotnet/coreclr/pull/27046. This PR will not pass CI until the corresponding coreclr PR has merged and made its way over to corefx.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41556</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191004.2
- **Date Produced**: 10/4/2019 6:50 PM
- **Commit**: 5fcd92cd8e44172b4bdd266fba9ce8938418540e
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19504.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19504.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19504.2

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41555</IssueID>
    <RepoID>1</RepoID>
    <Title>Changing readme to point to the docs in the repo</Title>
    <Description>The wiki is old and crufty and will not be carried to the new repo. Changing readme to point to the docs in the repo, which should be up to date.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41554</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Linq dependency from System.Security.Cryptography.Algorithms</Title>
    <Description>It's not being used.  Remove it.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41553</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unnecessary LINQ usage from System.Text.Json</Title>
    <Description>
    </Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41552</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unnecessary System.Linq usage from Microsoft.CSharp</Title>
    <Description>Most of the usage was just as easily (if not more easily) done without LINQ.  In some cases the use was entirely superfluous (e.g. MethodReturningNewArray().ToArray()).</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41551</IssueID>
    <RepoID>1</RepoID>
    <Title>Consolidate SafeSocketHandle / InnerSocketCloseHandle</Title>
    <Description>Socket's safe handle is actually two layers of safe handles: SafeSocketHandle, which is the one exposed to the rest of the implementation (and publicly), and then InnerSocketCloseHandle, which actually owns the handle / file descriptor and which is wrapped by SafeSocketHandle.

This layering should no longer be necessary, adds a lot of complication to the implementation, and makes creating sockets more expensive (two SafeHandles for each instead of one).

We should look at merging InnerSocketCloseHandle back into SafeSocketHandle.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41550</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/corert,coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/corert,coreclr


**Please REBASE this PR when merging**

 cc @idlerboris @stephentoub</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41549</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Add Fedora 32, and CentOS 8 runtime ids</Title>
    <Description>This is combined backport of:

- PR #41397: commit 6f82bd59a05ea9556397596ae9e59f39b904b222
- PR #40786: commit 86fc9e751c424278a9c4e163e0a71a9d7e30c8e7

This hasn't been releaesd yet; do I need to update project/build files like in https://github.com/dotnet/corefx/pull/35297 ?</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41548</IssueID>
    <RepoID>1</RepoID>
    <Title>The ReadOnlyIPAddress class does not do anything the property is alre…</Title>
    <Description>…ady readonly for IPAddress. IPv4 is using it but not IPv6?

The ReadOnlyIPAddress class does not do anything the property is already readonly for IPAddress. IPv4 is using it but not IPv6?</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41547</IssueID>
    <RepoID>1</RepoID>
    <Title>TCPListener doesn't create a new socket on Stop</Title>
    <Description>TCPListener.Stop disposes the socket and resets the reference. New socket is created only on the next Start call.
Fixes #26170 </Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41546</IssueID>
    <RepoID>1</RepoID>
    <Title>Regex failing to parse valid JS regular expression, even when RegexOptions.ECMAScript is specified</Title>
    <Description>The following regular expression works in JavaScript (at least in Chrome and IE): `/[^]/`.

However, this same pattern causes an `ArgumentException` when passed to .NET's regex class in ECMAScript compliance mode:

```
var regex = new Regex("[^]", RegexOptions.ECMAScript);
```

&gt; parsing "[^]" - Unterminated [] set.




</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41545</IssueID>
    <RepoID>1</RepoID>
    <Title>Please allow injecting JsonSerializer instances as a dependency</Title>
    <Description>Could it be possible to have system.Text. serializers also available as instance types that could implement some interface ? that way I could inject serialization as a dependency. 
Something similiar as this: https://github.com/vpaulino/Facades.Serialization</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41544</IssueID>
    <RepoID>1</RepoID>
    <Title>Enumerating StringCollection via ForEach allocates redundantly.</Title>
    <Description>StringCollection uses ArrayList as a backing collection. The current stringlist enumerator is a reference type. By adopting a private version for the current state of StringCollection as is present in List&lt;&gt; we can cut enumeration times in half and avoid allocating by ignoring the ArrayList enumerator and use a variant of the List&lt;&gt; enumerator. Also, the ArrayList indexer can easily avoid one range check by using the optimization present in the List&lt;&gt; indexer:
`if((uint)index &gt;= (uint)_size) throw...`
Finally, to the best of my knowledge methods which throw directly are not inlined. The ArrayList Indexer throws, unlike the List&lt;&gt; Indexer which uses a throw helper. We should also introduce a throwhelper for ArrayList</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41543</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191003.3
- **Date Produced**: 10/4/2019 1:19 AM
- **Commit**: 073ad7ef1b6a7112eefc965aed362c7b5923682a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19503.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19503.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19503.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41542</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191003.13
- **Date Produced**: 10/4/2019 6:49 AM
- **Commit**: 21049ddbb7aa7e3e46451aeedd74444a6c931058
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19503.13
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19503.13
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19503.13

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191003.5
- **Date Produced**: 10/4/2019 1:12 AM
- **Commit**: eff9fbf446468ca411bf5e0475916f316eea7223
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19503.5
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19503.5

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191003.2
- **Date Produced**: 10/3/2019 12:42 PM
- **Commit**: 2b7a93c5bdddf2cb30097179d428d082d73a1b27
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19503.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41541</IssueID>
    <RepoID>1</RepoID>
    <Title>IAsyncDisposable TransactionScope</Title>
    <Description>`TransactionScope` is a disposable type that almost always has I/O work to do on disposal.

Are there any plans for making `TransactionScope` implement `IAsyncDisposable`? (I am not aware of how readily the ADO.NET methods involved are available as async.)</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41540</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace PrintF with Console.WriteLine and cleanups</Title>
    <Description>The three usages of these vararg wrapper functions are using fixed number of arguments (1).</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41538</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191003.4
- **Date Produced**: 10/4/2019 3:25 AM
- **Commit**: 97838277c6790c5c98f68772569790489967740c
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19503.4
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19503.4
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19503.4

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41537</IssueID>
    <RepoID>1</RepoID>
    <Title>Add JsonPath support to JsonDocument/JsonElement</Title>
    <Description>Hi,  

I'd like to request JsonPath support for querying the JsonDocument/JsonElement classes.  JsonPath provides similar capability to XPath (and even Sql) in that it allows queries to be performed against Json documents.  This currently represents a major gap for us shifting from Newtonsoft to system.text.json, as we provide JsonPath values as an input parameter to a data load process which can't be worked around via code.

The JsonPath syntax is described [here](https://goessner.net/articles/JsonPath/).

The equivalent functionality in the Newtonsoft library is:

```csharp
var jsonPath = "$.my.path";
var json = JToken.Parse(jsonString);
var token = json.SelectToken(jsonPath);
```

The following proposed syntax would work well in the JsonDocument structure:

```csharp
var jsonPath = "$.my.path";
var jsonDoc = JsonDocument.Parse(json);
var element = jsonDoc.SelectElement(jsonPath); //returns JsonElement
var elements = jsonDoc.SelectElements(jsonPath); //returns JsonElement.ArrayEnumerator
```

Thanks.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41536</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: SequenceReader&lt;T&gt;.ClearCache() method to allow the reader to re-use previously allocated memory</Title>
    <Description>## Purpose
Provide a method that allows consumers of the SequenceReader&lt;T&gt; to indicate that it is no longer interested in the previously returned results and that the SequenceReader&lt;T&gt; may re-use memory it has internally allocated before.

```cs
public partial ref struct SequenceReader&lt;T&gt;
{
    void ClearCache();
}
```
## Background
There are cases where the SequenceReader needs to allocate memory in order to return results because the requested data is crossing segment boundaries and cannot be returned as a contiguous range of memory otherwise.
In the context of https://github.com/dotnet/corefx/issues/40962, additional SequenceReader methods will be added where this can happen.
The reasons why this needs to happen and why it cannot be avoided in order to make reasonable use of the SequenceReader&lt;T&gt; are already discussed in various other issues.
Those APIs can be used in reasonable ways with low rates of extra-allocation and in less reasonable ways (see here https://github.com/dotnet/corefx/issues/40871#issuecomment-530088885 for some figures regarding allocation probability depending on the length of requested data)

## Example
Consider the following parsing loop:
```cs
void Parse(ref ReadOnlySequence&lt;byte&gt; buffer)
{
    var reader = new SequenceReader&lt;byte&gt;(buffer);

    while (!reader.End)
    {
        if (!reader.TryRead(8, out ReadOnlySpan&lt;byte&gt; payload)))
        {
			return;
        }

        // Do something with those 8 payload bytes
    }
}
```

## Problem
Even in very reasonable use cases like the above, there's one problem: The allocations that the SequenceReader&lt;T&gt; needs to make, are adding up over time as the SequenceReader&lt;T&gt; needs to make sure that all returned results remain valid during the readers lifetime as it cannot make any assumptions about the calling code's interest in results returned previously (in the example above: it doesn't know that there's a loop and and the calling code looses interest in earlier result with each iteration).

## Solution
We need to provide a method that allows the calling code to tell the SequenceReader&lt;T&gt; that it is no longer interested in earlier results.
This in turn will allow the internal implementation of the SequenceReader&lt;T&gt; to re-use previously allocated memory for future results - which makes that memory become a kind of "cache".

Hence this API proposal for a **ClearCache()** method.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41535</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191003.2
- **Date Produced**: 10/3/2019 7:57 PM
- **Commit**: e02a3e1c914f1a042c471a4195bc6e4428b0fb19
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19503.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19503.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19503.2

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41539</IssueID>
    <RepoID>1</RepoID>
    <Title>Using Expression Trees With Pointers?</Title>
    <Description># Issue Title

Unable to build expression trees that use simd operations due to SIMD intrinsics requiring pointers.

# General

My goal was to try doing an Expression Tree compiled function and see how it behaved with the new .net core 3.0 intrinsics. Create functions like Transform, Reduce, etc and then given basic expressions like 

```
using System;
using VM.Core;
using System.Buffers;
using System.Linq.Expressions;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

namespace VM.Math
{
    public static class VMExpression
    {
        private static Expression BuildLessThanForLoop(Expression index,Expression end,Expression step,Func&lt;Expression,Expression&gt; block)
        {
            LabelTarget endLoop = Expression.Label();
            return Expression.Loop(Expression.Block(new Expression[]
            {
                Expression.IfThen(Expression.LessThan(index,end),Expression.Break(endLoop)),
                block(index),
                Expression.AddAssign(index,step)
            }),endLoop);              
        }

        private static Expression CalculateVectorLength(Expression arrayLength,ConstantExpression vectorLength)
        {
            return Expression.And(arrayLength,Expression.OnesComplement(Expression.Subtract(vectorLength,Expression.Constant(1))));
        }

        private static Expression LoadAlignedVector128Float(Expression vector,Expression ptr)
        {
            return Expression.Assign(vector,Expression.Call(typeof(Sse2).GetMethod("LoadAlignedVector128",new Type[] { typeof(float*) }),new Expression[] { ptr }));
        }

        private static Expression StoreAligned128Float(Expression vector,Expression ptr)
        {
            return Expression.Call(typeof(Sse2).GetMethod("StoreAligned",new Type[] { typeof(float*), typeof(Vector128&lt;float&gt;) }),new Expression[] { ptr, vector });            
        }
        private static Expression Index(Expression array,Expression index)
        {
             return Expression.ArrayIndex(array,new Expression[] { index });
        }

        private static Expression Add128Float(Expression vx, Expression vy)
        {
            return Expression.Call(typeof(Sse2).GetMethod("Add",new Type[] { typeof(Vector128&lt;float&gt;), typeof(Vector128&lt;float&gt;) }), new Expression[] { vx, vy });
        }

        private static Expression CreateAlignedArray(Expression count)
        {
            return Expression.New(typeof(AlignedFloatArray).GetConstructor(new Type[]{ typeof(int) }), new Expression[] { count });
        }

        public static unsafe Func&lt;AlignedFloatArray,AlignedFloatArray,AlignedFloatArray&gt; Transform(Expression&lt;Func&lt;float,float,float&gt;&gt; expr)
        {
            var paramX = Expression.Parameter(typeof(AlignedFloatArray),"x");
            var paramY = Expression.Parameter(typeof(AlignedFloatArray),"y");
            var parameters = new ParameterExpression[] { paramX, paramY };

            var result = Expression.Variable(typeof(AlignedFloatArray),"result");
            var memX = Expression.Variable(typeof(Memory&lt;float&gt;),"memX");
            var memY = Expression.Variable(typeof(Memory&lt;float&gt;),"memY");
            var memZ = Expression.Variable(typeof(Memory&lt;float&gt;),"memZ");

            var pinX = Expression.Variable(typeof(MemoryHandle),"pinX");
            var pinY = Expression.Variable(typeof(MemoryHandle),"pinY");
            var pinZ = Expression.Variable(typeof(MemoryHandle),"pinZ");

            var ptrX = Expression.Variable(typeof(float*),"ptrX");
            var ptrY = Expression.Variable(typeof(float*),"ptrY");
            var ptrZ =  Expression.Variable(typeof(float*),"ptrZ");

            var i = Expression.Variable(typeof(int),"i");
            var n = Expression.Variable(typeof(int),"n");
            var step = Expression.Constant(Vector128&lt;float&gt;.Count);
            var length = Expression.Variable(typeof(int),"length");
            var vx = Expression.Variable(typeof(Vector128&lt;float&gt;));
            var vy = Expression.Variable(typeof(Vector128&lt;float&gt;));

            var returnLabel = Expression.Label();

            var methodBlock = Expression.Block(parameters, new Expression[]
            {
                Expression.Assign(result,CreateAlignedArray(Expression.PropertyOrField(paramX,"Length"))),
                Expression.Assign(memX,Expression.Call(paramX,typeof(AlignedFloatArray).GetMethod("AsMemory"))),
                Expression.Assign(memY,Expression.Call(paramY,typeof(AlignedFloatArray).GetMethod("AsMemory"))),
                Expression.Assign(memZ,Expression.Call(result,typeof(AlignedFloatArray).GetMethod("AsMemory"))),
                Expression.Assign(pinX,Expression.Call(memX,typeof(Memory&lt;float&gt;).GetMethod("Pin"))),
                Expression.Assign(pinY,Expression.Call(memY,typeof(Memory&lt;float&gt;).GetMethod("Pin"))),
                Expression.Assign(pinZ,Expression.Call(memZ,typeof(Memory&lt;float&gt;).GetMethod("Pin"))),
                Expression.Assign(ptrX,Expression.Convert(Expression.PropertyOrField(pinX,"Pointer"),typeof(float*))),
                Expression.Assign(ptrY,Expression.Convert(Expression.PropertyOrField(pinY,"Pointer"),typeof(float*))),
                Expression.Assign(ptrZ,Expression.Convert(Expression.PropertyOrField(pinZ,"Pointer"),typeof(float*))),
                Expression.TryFinally(Expression.Block(new Expression[]
                {
                    Expression.Assign(i,Expression.Constant(0)),
                    Expression.Assign(length,Expression.PropertyOrField(paramX,"Length")),
                    Expression.Assign(n,CalculateVectorLength(length,step)), 
                    Expression.IfThen(Expression.GreaterThanOrEqual(n,step),Expression.Block(new Expression[]
                    {
                        BuildLessThanForLoop(i,n,step,(index) =&gt; {
                            return Expression.Block(new Expression[]
                            {
                                LoadAlignedVector128Float(vx,ptrX),
                                LoadAlignedVector128Float(vy,ptrY),
                                StoreAligned128Float(ptrZ,Add128Float(vx,vy))
                            });
                        })
                    })),
                    BuildLessThanForLoop(i,length,Expression.Constant(1),(index) =&gt;
                    {
                        return Expression.Block(new Expression[]
                        {
                          Expression.Assign(Index(ptrZ,index),Expression.Add(Index(ptrX,index),Index(ptrY,index)))
                        });
                    }),
                    Expression.Return(returnLabel,result)
                }),
                Expression.Block(new Expression[]
                {
                    Expression.Call(pinX,typeof(MemoryHandle).GetMethod("Dispose")),
                    Expression.Call(pinY,typeof(MemoryHandle).GetMethod("Dispose")),
                    Expression.Call(pinZ,typeof(MemoryHandle).GetMethod("Dispose"))
                }))
            });

           return (Func&lt;AlignedFloatArray,AlignedFloatArray,AlignedFloatArray&gt;)Expression.Lambda(methodBlock,parameters).Compile(false);
        }        
    }
}
```

At the moment there doesn't appear to be any reasonable way to do a load or store though using expression trees because they require pointer types. I get an exception if I try to declare a pointer variable in an expression tree. 

&gt; Exception has occurred: CLR/System.ArgumentException
&gt; An unhandled exception of type 'System.ArgumentException' occurred in System.Linq.Expressions.dll: 'Type must not be a pointer type'
&gt;    at System.Dynamic.Utils.TypeUtils.ValidateType(Type type, String paramName, Boolean allowByRef, Boolean allowPointer)
&gt;    at System.Linq.Expressions.Expression.Validate(Type type, Boolean allowByRef)
&gt;    at System.Linq.Expressions.Expression.Variable(Type type, String name)
&gt;    at MLNet.Math.VMExpression.Transform(Expression`1 expr) in /home/mltrainer/Desktop/mlnet/math/VM-Expression.cs:line 67
&gt;    at MLNet.Program.Main(String[] args) in /home/mltrainer/Desktop/mlnet/Program.cs:line 23

I also don't see any OpCodes to output through System.Reflection.Emit either that correspond to what would appear like the new Vector instructions. 

Is there any way to compile an unsafe function using the new SIMD operations through any mechanism that is currently supported within .net core? Would make C# able to do some operations that would normally have a large number of temporaries very efficiently compared to other languages like python and even C++ where expression templates are used by libraries like Eigen.

</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41534</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json: Method not found System.Text.Encodings.Web.TextEncoder.FindFirstCharacterToEncodeUtf8</Title>
    <Description>Works perfectly well in every project _except_ Azure Functions (v2).
Simply HTTP trigger an Azure Function and try and serialize (or deserialize) an object.</Description>
    <CreatedDate>04/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41533</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Linq.Parallel for nullable ref types</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41532</IssueID>
    <RepoID>1</RepoID>
    <Title>Installing System.Net.Http using Install-Package fails with "Dependency loop detected for package"</Title>
    <Description>I am installing packages to a folder using the following pwsh commands:

`Register-PackageSource -Location https://www.nuget.org/api/v2 -Name Nuget -ProviderName Nuget -Trusted -force`

`Install-Package -Name System.Net.Http  -ProviderName Nuget -Destination $somedir`

It fails with:
```
Install-Package : Dependency loop detected for package 'System.Net.Http'.
At C:\git\mobiltracker-ps-docker\Publish-PackageDll.ps1:81 char:1
+ Install-Package -Name $Name -ProviderName Nuget -Destination $Source  ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : Deadlock detected: (System.Net.Http:String) [Install-Package], Exception
+ FullyQualifiedErrorId : DependencyLoopDetected,Microsoft.PowerShell.PackageManagement.Cmdlets.InstallPackage
```
It looks like the offending package is System.Diagnostics.DiagnosticSource v4.6.0

**Workaround:**

Installing in the current order works:

1. `Install-Package System.Diagnostics.DiagnosticSource -RequiredVersion 4.5.1 -Provider nuget`
2. `Install-Package System.Net.Http -Provider nuget`
3. `Install-Package System.Diagnostics.DiagnosticSource -Provider nuget`
</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41531</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update experimental IsShipping and block stable properties (#41513)</Title>
    <Description>When I moved to use the arcade `IsShipping` convention, I disabled publishing to NuGet.org for experimental packages. The reasoning of that, is because anything mark as non-shipping, will not make it to NuGet.org.

So we need to mark them only as `IsShippingAssembly=false` so that the `AssemblyInformationalVersion` in metadata isn't stable whenever we ship stable. Also, mark them as `SuppressFinalPackageVersion` so that it doesn't produce a stable version of the package whenever we build those. `SuppressFinalPackageVersion` is the new `BlockStable` property: https://github.com/dotnet/arcade/issues/1213

cc: @danmosemsft </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41530</IssueID>
    <RepoID>1</RepoID>
    <Title>Why is System.Text.Json.JsonSerializer not using the TypeDescriptor API to get attributes?</Title>
    <Description>I was trying to add some `JsonPropertyNameAttribute` to properties at runtime through a `TypeDescriptorProvider` and to my despair it did not work, despite of seeing that `TypeDescriptor` correctly returns them.

I checked the [source code](https://github.com/dotnet/corefx/blob/d39276b9d4af15aebd829eaf1fbd7d43212a1f15/src/System.Text.Json/src/System/Text/Json/Serialization/JsonPropertyInfo.cs#L254) and it seems it is using `PropertyInfo.GetCustomAttribute`, which as far as I know, does not play with `TypeDescriptor`.

I do not have much experience in `TypeDescriptor`, but I succeeded doing this with other tools. I wonder which is the reason behind this decision in the new `JsonSerializer`.

Is there any alternative?</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41529</IssueID>
    <RepoID>1</RepoID>
    <Title>Setting Console.CursorVisible property does not change visibility in Linux</Title>
    <Description>Hello! I've been using the Console cursor APIs for .NET Core 3.0 in WSL 2. I've noticed that the `Console.CursorVisible` property has non-intuitive behavior (to me) in Linux (Ubuntu). When getting the property, a `PlatformNotSupportedException` is thrown. When setting the property, no exception is thrown, but nothing appears to happen - the cursor is still visible.

Is there any intention to support setting the visibility of the cursor across all platforms? Thanks!

#### Additional Investigation Notes
Looking through the source, it appears `ConsolePal.Unix` is responsible for handling this API. Upon the set, it appears we try to write some standard string to the console:

```
        public static bool CursorVisible
        {
            get { throw new PlatformNotSupportedException(); }
            set
            {
                if (!Console.IsOutputRedirected)
                {
                    WriteStdoutAnsiString(value ?
                        TerminalFormatStrings.Instance.CursorVisible :
                        TerminalFormatStrings.Instance.CursorInvisible);
                }
            }
        }
```

It appears that `TerminalFormatStrings.CursorInvisible` refers to `CursorInvisible = db.GetString(TermInfo.WellKnownStrings.CursorInvisible);` wherein `TermInfo` is an enum stored in a database. I've ended my investigation at this point - I'm guessing this is designed behavior.

</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41528</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.RegularExpressions.Tests.RegexCacheTests.Ctor_Cache_Uses_dictionary_linked_list_switch_does_not_throw failed on PR</Title>
    <Description>Error Message: 
&gt;Timed out at 10/2/2019 7:51:03 PM after 60000ms waiting for remote process.\n\tProcess ID: 5178\n\tHandle: 940\n

Stack Trace:
```
at Microsoft.DotNet.RemoteExecutor.RemoteInvokeHandle.Dispose(Boolean disposing) in /_/src/Microsoft.DotNet.RemoteExecutor/src/RemoteInvokeHandle.cs:line 131
   at Microsoft.DotNet.RemoteExecutor.RemoteInvokeHandle.Dispose() in /_/src/Microsoft.DotNet.RemoteExecutor/src/RemoteInvokeHandle.cs:line 55
   at System.Text.RegularExpressions.Tests.RegexCacheTests.Ctor_Cache_Uses_dictionary_linked_list_switch_does_not_throw() in /_/src/System.Text.RegularExpressions/tests/Regex.Cache.Tests.cs:line 110
```

https://dev.azure.com/dnceng/public/_build/results?buildId=374243&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11449956&amp;resultId=158563&amp;paneView=debug

cc: @ViktorHofer @maryamariyan </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41525</IssueID>
    <RepoID>1</RepoID>
    <Title>memory leak by TaskDelay inside a loop</Title>
    <Description>this is the issue I try to figure out:

https://github.com/chkr1011/MQTTnet/issues/767

is it possible that task.delay is leaking memory if used inside a longrunning loop?

I know that the aspnet team invented this:
https://github.com/aspnet/AspNetCore/blob/3cd5054eb5d8851b25881cd05cccb931aaa022e6/src/SignalR/common/Shared/TimerAwaitable.cs

but there are no docs on that type and there are no hints on msdn that you should not use Task.delay inside loops

</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41524</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191003.1
- **Date Produced**: 10/3/2019 9:53 AM
- **Commit**: 5af8549566116dbc3c6347036076d664db949e33
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19503.1
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19503.1
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19503.1

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191002.6
- **Date Produced**: 10/3/2019 2:33 AM
- **Commit**: c8c2917540a568869ba761afa6e4dba6edeb433b
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19502.6
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19502.6

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191002.2
- **Date Produced**: 10/2/2019 12:55 PM
- **Commit**: 087d3a4cac6e9bf65b9fdac7a0ee73187fb207c9
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19502.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41523</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Improve JsonSerializer support for derived types (#40654)</Title>
    <Description>Ports https://github.com/dotnet/corefx/pull/40654 to 3.1

## Description
- When determining whether to handle a derived type as `IList` (i.e populating directly, without using a converter), check whether the runtime type is assignable to `IList`, not the declared type.
This fixes https://github.com/dotnet/corefx/issues/40597.
- Preemptively throw `NotSupportedException` on deserialization of implementing types that don't have default constructors. This prevents a `NullReferenceException` when we try to create the instance.
- Detect and use the implemented type of abstract implementing types for (de)serialization. This allows us to correctly throw `NotSupportedException` on deserialization (because abstract types have no default constructor).
- Document expectations of (de)serializing collections in `System.Collections.ObjectModel` in tests.

## Customer Impact

- Prevents `NullReferenceException` when trying to deserialize a derived type without a parameterless ctor (https://github.com/dotnet/corefx/issues/41242).
- Enables support for System.Collections.ObjectModel collections where applicable, throws `NotSupportedException` otherwise
(https://github.com/dotnet/corefx/issues/40597).

## Regression?

No.

## Risk

Low. This PR does not modify already existing features, so the possibility of breaking functionality or introducing regressions is limited. Extensive test cases were added to ensure that the new changes work as expected.</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41522</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191002.2
- **Date Produced**: 10/3/2019 1:10 AM
- **Commit**: f1d2cd463508a3fe437043979673fec427c8b0ff
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19502.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19502.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19502.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41521</IssueID>
    <RepoID>1</RepoID>
    <Title>Porting test fixes from master to release/3.x</Title>
    <Description>cc @eiriktsarpalis @safern 

CI in master is in a good state now. Porting the remaining test fixes and infra changes to release/3.x.</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41520</IssueID>
    <RepoID>1</RepoID>
    <Title>DateTime.TryParse out datetime fails for simple &lt; , &gt; condition</Title>
    <Description>DateTime.TryParse out datetime fails for simple &lt; , &gt; condition


for e.g. 

using string value "03-10-2019 08:26:44"
//date time now is  03-10-2019 04:33:44
if (DateTime.TryParse( "03-10-2019 08:26:44", out DateTime val))
                            {
                                if ((DateTime.Now &lt;  val))
                                {
// this statement should be executed but it fails and comes to else
                                }
else{
// this code executes instead of above if 
}





with values here updating for clarification.

            //val = {04-10-2019 08:26:44}
            //DateTime.Now = {04-10-2019 03:18:10}
            // my system date format dd-MM-yyyy hh:mm:ss
            
            if (DateTime.TryParse("04-10-2019 08:26:44", out DateTime val))
            {
                if ((DateTime.Now &lt; val))
                {
                    // this statement should be executed but it fails and comes to else
                }
                else
                {
                    // this code executes instead of above if 
                }
            }

but using the same value of val string instead of parsing string value if I pass to constructor argument in date time object it simply works fine that executes if statements but in case of value converted from string it is not working , for clarification I am not using any date time format , i know there are format available but in my case all things are in default format, 




repro can be done on windows 10 , console core app with .net core 3 , 2.2 </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41526</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect behavior of System.IO methods</Title>
    <Description># Path.GetFileNameWithoutExtension does not throw

After upgrading to .NET Core 3.0 I noticed that when passing an path containing invalid characters (e.g. "file|name.txt") the method no longer throws ArgumentException as it did before. According to the [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.io.path.getfilenamewithoutextension?view=netcore-3.0), this should still be the case.
Same applies to Directory.EnumerateDirectories method, in which not only the path is not checked and the method throws IO exception instead, neither the search patter argument is verified.</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41519</IssueID>
    <RepoID>1</RepoID>
    <Title>ECDiffieHellman: obtaining the shared secret</Title>
    <Description>`ECDiffieHellman` has a method `DeriveKeyFromHash` that returns:

&gt; HASH(secretPrepend || sharedSecret || secretAppend)

There isn't an method to obtain the sharedSecret, for example to implement:

&gt; HASH(secretPrepend || transform(sharedSecret) || secretAppend)

For OpenSSL, the shared secret can be obtained using `EVP_PKEY_derive`.
This is what is used by the `ECDiffieHellmanOpenSSL.DeriveKeyFromHash` implementation.

`ECDiffieHellmanCng.DeriveKeyFromHash` implementation calls `NCryptDeriveKey`. I'm not sure if there is a Windows API to obtain the shared secret?

cc @bartonjs </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41518</IssueID>
    <RepoID>1</RepoID>
    <Title>PhysicalAddress.Parse should be case-insensitive and support new formats</Title>
    <Description>Split from #29740  See triage conclusion https://github.com/dotnet/corefx/issues/29740#issuecomment-537243912

1. [System.Net.NetworkInformation.PhysicalAddress.Parse()](http://source.dot.net/#System.Net.NetworkInformation/System/Net/NetworkInformation/PhysicalAddress.cs,118) method [currently support](https://msdn.microsoft.com/en-us/library/system.net.networkinformation.physicaladdress.parse%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396) only following formats:
```
001122334455

00-11-22-33-44-55
```

Really we can find that [more formats](https://www.lifewire.com/introduction-to-mac-addresses-817937) is used by verdors and humans:

```
00:11:22:33:44:55
0011:2233:4455
```
2. Also docs says that the Parse() method only support upper-case letters as hexadecimal digits but some application and humans can type macs in lower-case - it will be not so big overhead to make the method _case-insensitive_.
</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41517</IssueID>
    <RepoID>1</RepoID>
    <Title>MemoryMappedFile Race Condition</Title>
    <Description>I am trying to use MemoryMappedFile so that multiple threads in my application can read from the same file. The problem occurs when I run this code to try to access the same file in quick succession.
```MemoryMappedFile.CreateFromFile(FilePath);```
I attempt to fix this problem by using OpenExisting() method and named a memory when I use CreateFromFile(). 

```    
try
{
    MemoryMappedViewStream mmvs = MemoryMappedFile.OpenExisting(Path.GetFullPath(FilePath).GetHashCode().ToString()).CreateViewStream();
}
catch (FileNotFoundException)
{
    MemoryMappedViewStream mmvs = MemoryMappedFile.CreateFromFile(FilePath, System.IO.FileMode.Open, Path.GetFullPath(FilePath).GetHashCode().ToString()).CreateViewStream();
}
```

The solution above works well for windows os. However, since, other os doesn't support naming of a memory block, can someone offers insight on how to solve the original problem?</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41516</IssueID>
    <RepoID>1</RepoID>
    <Title>IPInterfaceProperties.DhcpServerAddresses does not work on Ubuntu</Title>
    <Description>This collection always returns empty list even if DHCP is configured and used.  

Code to process DHCP is hardcoded  in `System/Net/NetworkInformation/NetworkFiles.cs`
```c#
 public const string DHClientLeasesFile = "/var/lib/dhcp/dhclient.leases";System/Net/NetworkInformation/NetworkFiles.cs:        public const string DHClientLeasesFile = "/var/lib/dhcp/dhclient.leases";
```
But on Ubuntu (and perhaps other Linux distributions) DHCP configuration is files specific to interface. That makes more sense and you many need more instances and writing to single global file hard.

```
furt@net-dale:/var/lib/dhcp$ ps axu| grep dhcp
root      1952  0.0  0.0  25660  3356 ?        Ss   Apr24   0:00 /sbin/dhclient -1 -4 -v -pf /run/dhclient.eno1.pid -lf /var/lib/dhcp/dhclient.eno1.leases -I -df /var/lib/dhcp/dhclient6.eno1.leases eno1
```


</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41515</IssueID>
    <RepoID>1</RepoID>
    <Title>GetAllNetworkInterfaces issues on Linux</Title>
    <Description>I did recently more testing with `GetAllNetworkInterfaces` on Linux and there is number of issues:

1. Following fragments _always_ throw on Linux. (works on OSX and Windows)
```c#
foreach (NetworkInterface n in list)
{
    Console.WriteLine("Interafce {0}: {1} {2}", n.Name, n.Speed, n.OperationalStatus);
}
```

This because code trying to get speed does not understand that some interfaces like `lo` loopback may not have a speed. On Windows we return -1. (thanks @ManickaP)
Even if Speed is not accessed we always throw internally and creating and catching exception is causing performance degradation. 

2. Implementation is based on address callbacks. We can miss interfaces without address.

```
$ip link
242: tun0: &lt;POINTOPOINT,MULTICAST,NOARP&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 500
    link/none
243: tap0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether ea:86:ec:53:b3:c2 brd ff:ff:ff:ff:ff:ff
```
From pair tun/tap  only tap is visible in `GetAllNetworkInterfaces`. This could happen on other tunneling or point2point interfaces as well. 

3. accessing IsReceiveOnly will always throw.
Since Linux does not have concept of OnlyReceaving we should return `false` IMHO. 

4. GetIPProperties().GetIPv6Properties().GetScopeId() will always throw. 
Linux uses interface index for scopeId. We should use it as needed instead of throwing.  

I think in general we should not throw when accessing properties and we should return reasonable default (like -1 for speed on Windows) 

</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41514</IssueID>
    <RepoID>1</RepoID>
    <Title>Expose, test, and use ExceptionDispatchInfo.SetCurrentStackTrace</Title>
    <Description>Depends on https://github.com/dotnet/coreclr/pull/27004.
Fixes https://github.com/dotnet/corefx/issues/19416.</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>05/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41513</IssueID>
    <RepoID>1</RepoID>
    <Title>Update experimental IsShipping and block stable properties</Title>
    <Description>When I moved to use the arcade `IsShipping` convention, I disabled publishing to NuGet.org for experimental packages. The reasoning of that, is because anything mark as non-shipping, will not make it to NuGet.org.

So we need to mark them only as `IsShippingAssembly=false` so that the `AssemblyInformationalVersion` in metadata isn't stable whenever we ship stable. Also, mark them as `SuppressFinalPackageVersion` so that it doesn't produce a stable version of the package whenever we build those. `SuppressFinalPackageVersion` is the new `BlockStable` property: https://github.com/dotnet/arcade/issues/1213

This will need to go into 3.1 in order to ship the experimental packages to NuGet.org.

FYI: @GrabYourPitchforks @tannergooding 

cc: @danmosemsft </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41512</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove Configuration Group and OS Group from the Our config system</Title>
    <Description>The 3 major tasks here will to be able to 
- Cross-Compile.
- able to pass to project to project dependencies.
- should be able to find the best configurations from the project while building from the root.

The starting point here will be to make this work for a smaller repo.

cc @ericstj @danmosemsft @safern @ViktorHofer </Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41511</IssueID>
    <RepoID>1</RepoID>
    <Title>updating packageindex with stable versions</Title>
    <Description>
    </Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41510</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] Add Utf8JsonReader.SetState(...) method to improve custom converters performance</Title>
    <Description>I suggest adding the `Utf8JsonReader.SetState(JsonReaderState state)` method that allows you to set the reader state to any of the previous states so that you can read the JSON token, go back and read it again. This is a very useful feature especially when you are working with a custom `JsonConverter`.

---

Let's look at an example.

### What we have

Imagine, we have the following models:

````cs
interface IDevice
{
    string Kind { get; }
}

class Phone : IDevice
{
    public string Kind =&gt; "phone";

    public string Model { get; set; }
    public string Number { get; set; }
}

class Laptop : IDevice
{
    public string Kind =&gt; "laptop";

    public string Model { get; set; }
    public string Processor { get; set; }
}
````

### What we want

And we want to deserialize the following JSON to `List&lt;IDevice&gt;`:

````json
[
  {
    "kind": "phone",
    "model": "oneplus",
    "number": "123456789"
  },
  {
    "kind": "laptop",
    "model": "lenovo",
    "processor": "core i7"
  }
]
````

### What we have to do

To do this, we create our own `JsonConverter&lt;IDevice&gt;`, and if we want to achieve maximum performance, we do it like this:

````cs
class FastCustomConverter : JsonConverter&lt;IDevice&gt;
{
    public override IDevice Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        reader.Read();
        reader.Read();

        if (reader.ValueTextEquals("phone"))
        {
            var phone = new Phone();

            reader.Read();
            reader.Read();
            phone.Model = reader.GetString();

            reader.Read();
            reader.Read();
            phone.Number = reader.GetString();

            reader.Read();
            return phone;
        }
        else if (reader.ValueTextEquals("laptop"))
        {
            var laptop = new Laptop();

            reader.Read();
            reader.Read();
            laptop.Model = reader.GetString();

            reader.Read();
            reader.Read();
            laptop.Processor = reader.GetString();

            reader.Read();
            return laptop;
        }
        else
        {
            throw new JsonException();
        }
    }

    public override void Write(Utf8JsonWriter writer, IDevice value, JsonSerializerOptions options)
    {
        throw new NotImplementedException();
    }
}
````
And it works! Moreover, it works amazingly, and the performance is awesome in comparison with Newtonsoft.Json. But...

### What's wrong

But sometimes (in fact almost always) we prefer to have well-readable code instead of maximum performance. Do you agree that writing such a converter for complex types with a large number of nested objects, to put it mildly, is a headache?

### What we want to do

So, we want to do it as follows:

````cs
class ReadableCustomConverter : JsonConverter&lt;IDevice&gt;
{
    public override IDevice Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var root = JsonDocument.ParseValue(ref reader).RootElement;

        return root.GetProperty("kind").GetString() switch
        {
            "phone" =&gt; JsonSerializer.Deserialize&lt;Phone&gt;(root.GetRawText()),
            "laptop" =&gt; JsonSerializer.Deserialize&lt;Laptop&gt;(root.GetRawText()),
            _ =&gt; throw new JsonException()
        };
    }

    public override void Write(Utf8JsonWriter writer, IDevice value, JsonSerializerOptions options)
    {
        throw new NotImplementedException();
    }
}
````

### What's wrong

This also works, but much slower (~3 times slower). Obviously, we have a big overhead since we parse JSON to `JsonDocument` then convert it to raw string and then deserialize it to a specific type. Pretty dumb...

The problem is that we cannot just read the `"kind"` value to determine the correct type for deserialization, and then deserialize it, because the reader position is no longer at the beginning of the object.

### Solution

That's why I suggest adding a function to change the position (state) of the reader, so we can create our own converter as follows:

````cs
class ReadableJsonConverter : JsonConverter&lt;IDevice&gt;
{
    public override IDevice Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // remember where is the beginning of the object
        var initial = reader.CurrentState;

        // find out the desired type
        reader.Read();
        reader.Read();
        var kind = reader.GetString();

        // return to the beginning of the object
        reader.SetState(initial); //                &lt;---------- that's what I suggest

        // deserialize the object to the desired type
        return kind switch
        {
            "phone" =&gt; JsonSerializer.Deserialize&lt;Phone&gt;(ref reader),
            "laptop" =&gt; JsonSerializer.Deserialize&lt;Laptop&gt;(ref reader),
            _ =&gt; throw new JsonException()
        };
    }

    public override void Write(Utf8JsonWriter writer, IDevice value, JsonSerializerOptions options)
    {
        throw new NotImplementedException();
    }
}
````

Pretty short code and minimal overhead.

---

Unfortunately, this is a fairly common case when people have to work with JSON arrays of objects of different types, and it would be great to have an effective mechanism to handle this.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41509</IssueID>
    <RepoID>1</RepoID>
    <Title>An existing connection was forcibly closed by the remote host</Title>
    <Description>am using a valid wildcard certificate for a 2.2 project the failure have after a successful login and about to load the default page

`IOException: Unable to read data from the transport connection: An existing connection was forcibly closed by the remote host.
System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.ThrowException(SocketError error)
System.Net.Sockets.Socket+AwaitableSocketAsyncEventArgs.GetResult(short token)
System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
System.Net.Security.SslState.ThrowIfExceptional()
System.Net.Security.SslState.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
System.Net.Security.SslState.EndProcessAuthentication(IAsyncResult result)
System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
System.Net.Security.SslStream+&lt;&gt;c.&lt;AuthenticateAsClientAsync&gt;b__47_1(IAsyncResult iar)
System.Threading.Tasks.TaskFactory&lt;TResult&gt;.FromAsyncCoreLogic(IAsyncResult iar, Func&lt;IAsyncResult, TResult&gt; endFunction, Action&lt;IAsyncResult&gt; endAction, Task&lt;TResult&gt; promise, bool requiresSynchronization)
System.Net.Http.ConnectHelper.EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken)

HttpRequestException: The SSL connection could not be established, see inner exception.
System.Net.Http.ConnectHelper.EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken)
System.Threading.Tasks.ValueTask&lt;TResult&gt;.get_Result()
System.Net.Http.HttpConnectionPool.CreateConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)
System.Threading.Tasks.ValueTask&lt;TResult&gt;.get_Result()
System.Net.Http.HttpConnectionPool.WaitForCreatedConnectionAsync(ValueTask&lt;ValueTuple&lt;HttpConnection, HttpResponseMessage&gt;&gt; creationTask)
System.Threading.Tasks.ValueTask&lt;TResult&gt;.get_Result()
System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, bool doRequestAuth, CancellationToken cancellationToken)
Microsoft.Extensions.Http.Logging.LoggingHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
Microsoft.Extensions.Http.Logging.LoggingScopeHttpMessageHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task&lt;HttpResponseMessage&gt; sendTask, HttpRequestMessage request, CancellationTokenSource cts, bool disposeCts)
`</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41508</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider throwing a meaningful error if the serializer is asked to serialize a `Task` </Title>
    <Description>Consider

```C#
var value = SomeAsyncFunc(); // This returns Task&lt;SomeModel&gt;
var json = JsonSerializer.Serialize(value);
```

This currently throws the following error:

```C#
An unhandled exception occurred while processing the request.JsonSerializationException: Self referencing loop detected for property 'task' with type 'System.Runtime.CompilerServices.AsyncTaskMethodBuilder 1+AsyncStateMachineBox 1 [System.Collections.Generic.List 1[XXXX.Models.YYY],System.Runtime.CompilerServices.IAsyncStateMachine]'. Path 'stateMachine.&lt;&gt;t__builder'. Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
```

It's almost always an indication of a non-awaited task if it's passed in to the serializer. Could this throw a more meaningful error up front if this is detected? See https://github.com/aspnet/AspNetCore/issues/13272 for previous discussions on this.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41507</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Threading.Tasks.Tests.ParallelForTests.TestInvokeDOPAndCancel failed in CI</Title>
    <Description>https://dev.azure.com/dnceng/public/_build/results?buildId=374084&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11444164&amp;resultId=132449&amp;paneView=debug

Configuration: `netcoreapp-Linux-Debug-x64-Debian.9.Amd64.Open`

```
TestInvokeDOPAndCancel: &gt; FAILED! Cancellation+exception not effected.\nExpected: False\nActual: True

   at System.Threading.Tasks.Tests.ParallelForTests.TestInvokeDOPAndCancel() in /_/src/System.Threading.Tasks.Parallel/tests/ParallelForTests.cs:line 1074
```

cc @stephentoub </Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41506</IssueID>
    <RepoID>1</RepoID>
    <Title>Update coding-style.md</Title>
    <Description>Changed Keyboard shortcut to show white space. There was a wrong shortcut of View White Space (Ctrl+E, S) and correct one is (Ctrl+R, Ctrl+W). I don't know is it allows us to contribute/change in guidelines or not. It's my first PR. I hope it will be accepted.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41505</IssueID>
    <RepoID>1</RepoID>
    <Title>Inconsistent floating-point parsing exceptions</Title>
    <Description>Per the documentation the following should throw an OverflowException when using Single.Parse and Double.Parse:

```csharp
Single.Parse("-3.40282347E+39");
Single.Parse("3.40282347E+39");
Double.Parse("-1.7976931348623157E+309");
Double.Parse("1.7976931348623157E+309");
```

As expected, an exception is thrown on .NET Framework. On .NET Core 3.0.100 I am instead getting +/-Infinity.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41504</IssueID>
    <RepoID>1</RepoID>
    <Title>Increasing arm64 timeout on Linux</Title>
    <Description>https://github.com/dotnet/core-eng/issues/8011</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41503</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient.GetAsync causes the subsequent async method to deadlock</Title>
    <Description>After I've obtained the result from a `GetAsync()` method, when I try to call `await` on another async method, the program deadlocks for no apparent reason. I suspect it's caused by some side effects introduced by the `HttpClient`, because the program completes as expected when I replace the `GetAsync()` with a fake IO bound operation. 

Would someone help me with how did a deadlock happen? And is this a bug with the `System.Net.Http` library?

System.Net.Http Version (Deadlocks)
```
public static class DeadLock
{
    static DeadLock()
    {
        // should not block async method in general
        // but static constructor cannot be async
        int result = Setup().Result;
    }
    private static async Task&lt;int&gt; Setup()
    {
        string project = await GetProjects();

        Console.WriteLine("Project retrieved ");
        Console.WriteLine(project);

        Task&lt;int&gt; simpleRequest = DoNothing(); // The program deadlocks here

        Console.WriteLine("Projects dispatched");
        return 0;
    }
    private static async Task&lt;string&gt; GetProjects()
    {
        HttpClient httpClient = new HttpClient();
        await httpClient.GetAsync("https://www.zazzle.com");
        return "Project A";
    }
    private static async Task&lt;int&gt; DoSomething() {
        Thread.Sleep(2000);
        return 0;
    }
    private static async Task&lt;int&gt; DoNothing() { return 0;}
    public static string Talk() { return "Hi"; }
}

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Done " + DeadLock.Talk());
        Console.ReadLine();
    }
}
```

Fake IO-bound operation (Completes)
```
public static class DeadLock
{
    static DeadLock()
    {
        int result = Setup().Result;
    }
    private static async Task&lt;int&gt; Setup()
    {
        string project = await GetProjects();

        Console.WriteLine("Project retrieved ");
        Console.WriteLine(project);

        Task&lt;int&gt; simpleRequest = DoNothing();

        Console.WriteLine("Projects dispatched");
        return 0;
    }
    private static async Task&lt;string&gt; GetProjects()
    {
        await DoSomething();
        return "Project A";
    }
    private static async Task&lt;int&gt; DoSomething() {
        Thread.Sleep(2000);
        return 0;
    }
    private static async Task&lt;int&gt; DoNothing() { return 0;}
    public static string Talk() { return "Hi"; }
}

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Done " + DeadLock.Talk());
        Console.ReadLine();
    }
}
```

The expected output is:
```
Project retrieved
Project A
Projects dispatched
Done Hi
```
Whereas the version with HttpClient gives me
```
Project retrieved
Project A
```
And it hangs ...


Environment
IDE: Microsoft Visual Studio Professional 2017 Version 15.9.14
OS: Windows Server 2019 Standard
Cores: 16

supportedRuntime version="v4.0" 
sku=".NETFramework,Version=v4.6.1"

Thanks you!
</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41502</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Microsoft.NET.Sdk.IL to the repo restore phase</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/33953</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41501</IssueID>
    <RepoID>1</RepoID>
    <Title>System.PlatformNotSupportedException raised on System.IO.Ports.SerialPort.GetPortNames()</Title>
    <Description>I am trying to enumerate serial ports in an UWP application using  SerialPort.GetPortNames() because Windows.Devices.SerialCommunication SerialDevice does not enumerate correctly for my target device (returns null).  

UWP Target: Windows 10 1809
Min Version: Windows 10 1809

Windows Enterprise 10.01.18362
MS VS Version 15.9.15
MS .NET Framework Version 4.8.0.03752
Microsoft.Windows.Compatibility Version 3.0.0

</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41499</IssueID>
    <RepoID>1</RepoID>
    <Title>Add tests to improving TimeSpan precision</Title>
    <Description>Fixes [dotnet/corefx#41380](https://github.com/dotnet/corefx/issues/41380)

Related coreclr PR [dotnet/coreclr#26992](https://github.com/dotnet/coreclr/pull/26992)</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41497</IssueID>
    <RepoID>1</RepoID>
    <Title>CoreFx tests cannot use nuget packages with runtimeTargets</Title>
    <Description>Related https://github.com/dotnet/source-build/issues/1267

I was trying to remove the sni package reference from runtime.depproj and instead just reference it from test projects that required it.  This produced the right information in the project assets file, but unfortunately all native assets were being removed in the final deps file.  This appears to be a bug/unexpected behavior from the GenerateDepsFile task.  I think we are confusing the task since we don't build with a shared framework reference in our tests, yet we do run against one.  I found that adding a `RuntimeFramework` item fixed the deps file, but broke the runtimeconfig (it was now missing the framework reference 😕).  I'm sure there is something more subtle going on here.  We should look deeper and make it so that our tests can reference packages with runtime specific assets and avoid putting things in our test shared framework that aren't in the real shared framework.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41498</IssueID>
    <RepoID>1</RepoID>
    <Title>DateTime.Now returns incorrect time on windows computer when time zone has changed</Title>
    <Description># Issue Title

DateTime.Now returns incorrect time on windows computer when time zone has changed

# General

### Details
I was running a windows service created in C# when I noticed my computer was set to the wrong time zone. I switched it to the correct timezone and waited for my service to do something. It did not. I restarted the service and it worked correctly. I created a test app in C# and noticed that If I change my timezone, DateTime.Now does not use the updated time. I then created a test app in .NET Core to see if it had the same behavior, and it does.

### .NET Core version
.NET Core 2.1

### Operating System version
Windows 10 Pro - 1903 (18362.207)

### Test Code
````
using System;

namespace DateTimeNowTest
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(DateTime.Now);
            Console.ReadLine();
            //Before pressing enter, change time zone
            Console.WriteLine(DateTime.Now);
        }
    }
}
````
</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41496</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Stabilize packages for 3.0.1</Title>
    <Description>
    </Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41500</IssueID>
    <RepoID>1</RepoID>
    <Title>ArgumentException: "Parameter is not valid" in Bitmap when file is not found or null</Title>
    <Description># Issue Title

A Wrong exception of class Bitmap

# General

I have a code: 

```
            using (Bitmap bitmap = new Bitmap(fileName))
            {
                Console.WriteLine(bitmap.Size);
            }
```

If a file on path the fileName null or file not found I have an exception: 
`Unhandled Exception: System.ArgumentException: Parameter is not valid.`

I had this bug with 3 other ways: 
```
.NET Core SDK (reflecting any global.json):
 Version:   2.1.505
 Commit:    b220231234

Runtime Environment:
 OS Name:     altlinux
 OS Version:  8.2
 OS Platform: Linux
 RID:         linux-x64
 Base Path:   /usr/lib64/dotnet/sdk/2.1.505/
```
```Version:   3.0.100
 Commit:    04339c3a26

 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100\

Host (useful for support):
  Version: 3.0.0
  Commit:  7d57652f33
```

And with docker which I get from based images of Microsoft 
`FROM mcr.microsoft.com/dotnet/core/runtime:2.1`

[ConsoleApp2.zip](https://github.com/dotnet/core/files/3681659/ConsoleApp2.zip)



</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41495</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Drawing.Common] Relax IconTests.CorrectColorDepthExtracted test</Title>
    <Description>…to work on newer libgdiplus on Unix.

Related: https://github.com/mono/libgdiplus/pull/599

libgdiplus on Unix uses Cairo as the backend library for manipulating the bitmaps. Unfortunately Cairo has very limited support for different pixel formats. Thus the ARGB32 format has to be emulated using the PARGB32 format (individual channels are premultiplied with the alpha value). This may result in slight loss of precision and rounding errors when converting between the formats back and forth. Adjust the tests to be more forgiving for this scenario.

Note that it worked on older libgdiplus only because there was couple of bugs that were canceling itself out. Cairo surfaces were often created with the non-premultiplied ARGB32 data and drawing operations performed on them resulted in the alpha channel not being applied correctly.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41494</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Drawing.Common] Fix argument name in exception of Bitmap constructor</Title>
    <Description>
    </Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41493</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191002.2
- **Date Produced**: 10/2/2019 10:19 AM
- **Commit**: ba2095a5755a040850bdc4b423fab1ca26da4025
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19502.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19502.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19502.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20191001.13
- **Date Produced**: 10/2/2019 4:05 AM
- **Commit**: dcc9f626eeb0751d4ba4499f623aac42d2e95c10
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19501.13
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19501.13

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20191001.2
- **Date Produced**: 10/1/2019 12:47 PM
- **Commit**: 8546a718287c4ff280199c45cc0184cbd6153c0c
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19501.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191002.11
- **Date Produced**: 10/2/2019 11:34 PM
- **Commit**: da75c6547c64a91eb8a9cecf8c503331c2cc394a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19502.11
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19502.11
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19502.11

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41492</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20191001.4
- **Date Produced**: 10/1/2019 10:24 PM
- **Commit**: c21a409f11386d22c6083198176868d3974de832
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19501.4
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19501.4
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19501.4

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41491</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Composition.ImportAttribute cannot be used on fields</Title>
    <Description>I am getting some compilation issue after updating an older codebase to System.Composition.

![image](https://user-images.githubusercontent.com/985774/66028363-3b0bd200-e4fd-11e9-88a1-b9a7da8507ba.png)

Is it possible that `AttributeUsage.Field` should be added to the declaration here?

https://github.com/dotnet/corefx/blob/dcc9f626eeb0751d4ba4499f623aac42d2e95c10/src/System.Composition.AttributedModel/src/System/Composition/ImportAttribute.cs#L13

The documentation on https://docs.microsoft.com/en-us/dotnet/api/system.composition.importattribute?view=dotnet-plat-ext-3.0 states:

&gt; Specifies that a property, **field**, or parameter value should be provided by the host container.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41490</IssueID>
    <RepoID>1</RepoID>
    <Title>improve performance of GetAllNetworkInterfaces on Linux</Title>
    <Description>This is somewhat related to discussion in #32611 and fixes some low-hanging issues. 
It does not change way how we get information but it avoids unnecessary processing.  

Right now when we iterate through interfaces we always do: 
1. get again routing table for v4/6 for each interface. 
- this is particularly expensive as kernel needs to walk routing table and dump it as text while processing packets.
- this can be  expensive if we ever run on system with dynamic routing
2. we read and parse /etc/resolver.conf twice for each interface
3. MTU is property of interface on Linux
- we read same value once for each protocol family. 

This change simple reads common properties once and that it used later instead if creating new copies. 

The benefit depends on number of interfaces we process. With my Ubuntu VM, I get

|Branch      |                  Method  |     Mean |     Error |    StdDev | Ratio |
|--|------------------------ |---------:|---------:|---------:|---------:|
|PR| GetAllNetworkInterfaces | 632.1 us | 12.16 us | 32.68 us | 622.5 us |
| master| GetAllNetworkInterfaces | 901.1 us | 21.86 us | 42.64 us | 883.4 us |

I also have physical machine with two interfaces and few virtual interfaces created by Docker

|Branch      |                  Method  |     Mean |     Error |    StdDev | Ratio |
|-------|------------------------ |---------:|----------:|----------:|------:|
| PR|GetAllNetworkInterfaces |  1.933 ms | 0.0112 ms | 0.0099 ms |  1.00 |
| master|GetAllNetworkInterfaces | 3.271 ms | 0.0091 ms | 0.0076 ms |  1.69 |

Note that we still throw while internally while trying to get speed for loopback and virtual interfaces. 
```
$ cat /sys/class/net/lo/speed
cat: /sys/class/net/lo/speed: Invalid argument
```</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41489</IssueID>
    <RepoID>1</RepoID>
    <Title>WCF on Linux - Kerberos Authentication with UpnEndpointIdentity seems to be sending the wrong name-type to the KDC.</Title>
    <Description>Hi,

So I'm really struggling with getting a .NET Core app running on Linux because of Kerberos. The app is a client that is communicating with a WCF service running on a windows server. The Service runs under a service account, so the client specifies a UpnEndpointIdentity. This works great on windows, but when trying to run it on Ubuntu, I'm getting GSSAPI errors. Specifically this: 

&gt;System.ServiceModel.Security.SecurityNegotiationException: Authentication failed, see inner exception.
&gt;  ---&gt; System.Security.Authentication.AuthenticationException: Authentication failed, see inner exception.
&gt; ---&gt; System.ComponentModel.Win32Exception (0x80090020): GSSAPI operation failed with error - Unspecified GSS failure.  Minor code may provide more information (Server not found in Kerberos database).

I'm no Kerberos expert, but I've started to dig into the Wireshark traces and it looks like on windows it's sending a request to the KDC with an sname name-type of `kRB5-NT-SRV-HST (3)`. On Ubuntu, it's instead sending name-type: `kRB5-NT-PRINCIPAL (1)`. The KDC is rejecting the request with `KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN`, which makes sense since the client is asking for a host instead of a principal.

Also, I'm able to correctly acquire a service ticket using `kgetcred` for the UPN, and I can see it correctly sent in the wireshark trace. Is this a bug in .NET Cores interaction with GSSAPI, or WCF, or am I just missing something? @davidsh Wrote some of this code so I'm hoping he can help.

I'm happy to provide the Wireshark traces if that will help, or any more details needed.

Thanks!</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41488</IssueID>
    <RepoID>1</RepoID>
    <Title>Building .NET Core 3.0 RTM on FreeBSD</Title>
    <Description>I hope this is the right place to ask.

As .NET Core 3.0 matured to RTM are there any works to have an official distro for FreeBSD or at least building guidelines? Right now, top google result is [Building .NET Core 3.x on FreeBSD](https://github.com/dotnet/corefx/wiki/Building-.NET-Core-3.x-on-FreeBSD) guide by @wfurt, but it looks like it's not updated/working with .NET Core 3.0 RTM.

Thank you!</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41487</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: StringSplitOptions.TrimEntries</Title>
    <Description>How many times have we all written the below code?

```cs
string[] entries = someString.Split(',');

for (int i = 0; i &lt; entries.Length; i++)
{
    string entry = entries[i].Trim();
    /* operate on entry */
}
```

Even just a cursory search of our own Framework reference sources shows that this is a common pattern:

 * https://referencesource.microsoft.com/#mscorlib/system/enum.cs,434
 * https://referencesource.microsoft.com/#mscorlib/system/AppContext/AppContextDefaultValues.cs,122
 * https://referencesource.microsoft.com/#PresentationFramework/src/Framework/System/Windows/Annotations/Annotation.cs,665
 * https://referencesource.microsoft.com/#System/compmod/system/codedom/compiler/CodeDomConfigurationHandler.cs,262
 * https://referencesource.microsoft.com/#System/net/System/Net/_AutoWebProxyScriptHelper.cs,582
 * https://referencesource.microsoft.com/#System/net/System/Net/_HeaderInfoTable.cs,84
 * etc.

I propose adding an enum value `StringSplitOptions.TrimEntries` that would make this pattern a bit easier for folks by eliminating the need for developers to call `Trim`.

```cs
[Flags]
public enum StringSplitOptions
{
    None = 0,
    RemoveEmptyEntries = 1,
    TrimEntries = 2 /* new value */
}
```

The behavior of `string.Split` and related APIs would be as follows:

If _None_ or _RemoveEmpyEntries_ is provided, the behavior of `string.Split` under this proposal is unchanged from its behavior today.

If _TrimEntries_ is provided by itself, the `string.Split` method performs the equivalent of calling `string.Trim()` on each element of the returned array. That is, no element in the returned array will have leading or trailing whitespace. The array may contain zero-length strings for entries.

```cs
Assert.Equal(new[] { "Doe", "John" }, "Doe, John".Split(',', StringSplitOptions.TrimEntries));
Assert.Equal(new[] { "1", "", "2", "3" }, "1, , 2 , 3 ".Split(',', StringSplitOptions.TrimEntries));
Assert.Equal(new[] { "", "" }, ", ".Split(',', StringSplitOptions.TrimEntries));
```

If _TrimEntries_ and _RemoveEmptyEntries_ are both provided, the entries are trimmed first, _and then_ zero-length entries are removed from the returned array.

```cs
Assert.Equal(new[] { "Doe", "John" }, "Doe, John".Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries));
Assert.Equal(new[] { "1", "2", "3" }, "1, , 2 , 3 ".Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries));
Assert.Equal(new string[0], ", ".Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries));
```

Adding this enum value may be considered a breaking change if we expect that third-party components aside from `string.Split` are _consuming_ the `StringSplitOptions` enum, not simply generating the value. In theory any such third-party components should be checking their inputs and rejecting unknown flags.</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41486</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixing the official build</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41485</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpStress: Automate stress runs</Title>
    <Description>Forking from conversation started in #41069 per @ViktorHofer's request.

We keep a [standalone console app](https://github.com/dotnet/corefx/tree/master/src/System.Net.Http/tests/StressTests/HttpStress) in the corefx repo which stress tests using the existing sdk. Currently, we run this by manually building corefx and running the suite against compiled bits. We're looking for a way to trigger this automatically against PR branches, ideally using an `/azp` subcommand.

Things to consider:

* Should probably support multiple OSes (e.g. Windows, Linux &amp; OSX).
* Should be allowed to run for arbitrary amounts of time.
* Manual auditing of stress run logs (as opposed to automatically passing or failing runs).
* More long-term, we should probably consider hosting client and server in separate VMs for a variety of reasons.
* Want to use the httpstress as a pilot project for adding additional networking stress/performance tests. We're also looking at [aspnet/benchmarks](https://github.com/aspnet/benchmarks) for ideas here.
* Should stress/performance projects live in the corefx repo? We already have the [performance](https://github.com/dotnet/performance) repo for hosting microbenchmarks, so wondering if it makes sense to do something similar with networking.

I should note that @jkotalik has created an Azure pipeline that [just runs the stress suite](https://dnceng.visualstudio.com/public/_build?definitionId=560&amp;_a=summary). I'd argue for the sake of simplicity that we should probably do just that and iterate as necessary.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41484</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update Microsoft.Windows.Compatibility package for WCF and remove S.R.WindowsRuntime*</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/41403

&gt; The type 'IAsyncAction' is defined in an assembly that is not referenced. You must add a reference to assembly 'Windows, Version=255.255.255.255, Culture=neutral, PublicKeyToken=null, ContentType=WindowsRuntime'

 We're removing the WinRT assemblies from the compat pack because the compiler has lightup code that automatically tries to resolve types in it when present and async is used (even though those types are never referenced).  Since we don't have a scenario for including these in the compat pack, we're removing them.  This should not impact the shipping WinRT scenarios since those carry their own reference to these packages.

Also, as part of this change, I'm updating our WCF dependency of the compat pack to target the latest stable packages shipped in 3.0

cc: @danmosemsft 

</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41483</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20191001.2
- **Date Produced**: 10/1/2019 6:38 PM
- **Commit**: b5d201599d9aff5c26327a2f65828ed635911382
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19501.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19501.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19501.2

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41482</IssueID>
    <RepoID>1</RepoID>
    <Title>Populate non-immutable collections directly on deserialize</Title>
    <Description>This PR improves performance collections previously deserialized with the use of converters. This includes types derived from native (System.Collections[.Generic]) collections, and native collections that don't implement `ILIst`, `IDictionary`, or `IDictionary&lt;&gt;`. See https://github.com/dotnet/corefx/pull/41482#issuecomment-538115500 for the improvements.

The deserialization logic for collections is as follows:

- Types implementing IList, or are assignable from List&lt;&gt;, are populated in one pass using IList(&lt;&gt;).Add
- Non dictionary enumerables (do not implement IDictionary, IDictionary&lt;.&gt;, or IReadOnlyDictionary&lt;&gt;) that implement ICollection&lt;&gt;, or are assignable from HashSet&lt;&gt;, are populated with reflection using the void ICollection&lt;&gt;.Add method
- Non dictionary enumerables that implement Stack&lt;&gt;, Queue&lt;&gt;, Stack, or Queue are populated with reflection using the corresponding void .Push or .Enqueue method.
- All other non-dictionary enumerables are not supported for deserialization, and the serializer will throw a NSE if deserialization is attempted.
- Dictionary enumerables that implement one of IDictionary, or IDictionary&lt;,&gt;, or are assignable from Dictionary&lt;,&gt;, are populated using the dictionary indexer.
- All other dictionaries e.g. types implementing only IReadOnlyDictionary&lt;,&gt;, are not supported for deserialization, and the serializer will throw a NSE if deserialization is attempted.

Fixes https://github.com/dotnet/corefx/issues/41427 - higher order inheritance for derived types is now supported
Fixes https://github.com/dotnet/corefx/issues/40479 - reflection is now used to support more types.
Fixes https://github.com/dotnet/corefx/issues/41034 - types that implement IDictionary are now supported for serialization.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41481</IssueID>
    <RepoID>1</RepoID>
    <Title>Building 3.0 on Arch Linux</Title>
    <Description>Tracking [#7996](https://github.com/dotnet/core-eng/issues/7996) </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41480</IssueID>
    <RepoID>1</RepoID>
    <Title>Removing the platforms package from building</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41479</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable UWP pkg publishing to fix official builds</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41478</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/corert,coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/corert,coreclr


**Please REBASE this PR when merging**

 cc @tannergooding</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41477</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable Save_SimpleSettings_Ok test in all platforms</Title>
    <Description>It's been failing on windows for the past few weeks, disabling while issue is open to have a cleaner CI.

cc: @stephentoub @ViktorHofer </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41476</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @ericstj

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41475</IssueID>
    <RepoID>1</RepoID>
    <Title>X509Chain.Build failed on Linux(netcore3.0) with OCSP configured</Title>
    <Description>Encounter an issue on Linux when trying to call X509Chain.Build method on a leaf certificate. The CA has configured OCSP but not CRL.

The ChainStatus has "unable to get certificate CRL". 

According to https://github.com/dotnet/corefx/pull/35367#issuecomment-535727309, CRL should not be checked if OCSP responds correctly.

Here are the repro steps:
    
1.	Download the netcoreapp3.0.zip
[netcoreapp3.0.zip](https://github.com/dotnet/corefx/files/3677735/netcoreapp3.0.zip)
 to your machine. 

2.	Open a session(naming as session 1) on Linux, copy the netcoreapp3.0 folder to the Linux machine.

3.	Run command:  dotnet ./netcoreapp3.0/ConsoleApp3.dll

3 certificates files will be generated under netcoreapp3.0 folder.  They’re 0.cer (leaf), 1.cer(intermediate), 2.cer(root)
  
Simulated CA servers will start running. (No CRL respond is configured, but OCSP respond is configured )

There will be following messages displayed:

The responds of simulated OCSP server to each requests will be displayed , when trying to run X509Chain.Build on the leaf certificate(0.cer)
(Every OCSP requests will have respond info(nonce &amp; certificate status) displayed on session 1
```
CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (0f813155-18a9-4748-affd-dce5493ca3ab)
1 OCSP respond(s) is sent..
   nonce is #0410549e5736285ac06ad3f6d992123aff06
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (0f813155-18a9-4748-affd-dce5493ca3ab)
1 OCSP respond(s) is sent..
   nonce is #04109e605bd153602b04981ea21592d70ea1
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (0f813155-18a9-4748-affd-dce5493ca3ab)
1 OCSP respond(s) is sent..
   nonce is #0410fae8e895c936da8060ebc7ec62057f12
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (0f813155-18a9-4748-affd-dce5493ca3ab)
1 OCSP respond(s) is sent..
   nonce is #04109d32979804212d5c36112e0eee6edc5e
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Root Certificate Authority (7985adab-a107-415f-b2e8-81f1b161d709)
1 OCSP respond(s) is sent..
   nonce is #04101d22bbc6a0ffd7a85873fdf46cbb5814
   certificateStatus : Good
```
The results of chian.Build (go through ChainElement  of the chain.ChainElements and prints all chainElementStatus)
```
Revocation flag:  ExcludeRoot
chain building results are as following:
certificate.Subject is : CN=NuGet Test Timestamp Service (26558ee9-d5af-4ef8-87b5-3764eb322e94), O=NuGet, L=Redmond, S=WA, C=US
certificate.FriendlyName is :
=================   The (0) th certificate is   :=================
File path:  /home/henli/repos/NuGetTest/netcoreapp3.0/0.cer
chainElement.Certificate.Subject : (CN=NuGet Test Timestamp Service (26558ee9-d5af-4ef8-87b5-3764eb322e94), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (8906F366C606DCFFC348B71DD11EB4C093AE5177)
chainElement.Certificate.isvalid : (False)
    --------   The chainElementStatus are : -------
  status : (RevocationStatusUnknown)
  info: (unable to get certificate CRL)
=================   The (1) th certificate is   :=================
File path:  /home/henli/repos/NuGetTest/netcoreapp3.0/1.cer
chainElement.Certificate.Subject : (CN=NuGet Test Intermediate Certificate Authority (0f813155-18a9-4748-affd-dce5493ca3ab), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (D14A10A221063426451026C156E7C9AB46970554)
chainElement.Certificate.isvalid : (False)
    --------   The chainElementStatus are : -------
  status : (RevocationStatusUnknown)
  info: (unable to get certificate CRL)
=================   The (2) th certificate is   :=================
File path:  /home/henli/repos/NuGetTest/netcoreapp3.0/2.cer
chainElement.Certificate.Subject : (CN=NuGet Test Root Certificate Authority (7985adab-a107-415f-b2e8-81f1b161d709), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (8E95B08D328C0414890E244DFCD2FB5A09EF81F4)
chainElement.Certificate.isvalid : (False)
    --------   The chainElementStatus are : -------
  status : (RevocationStatusUnknown)
  info: (unable to get certificate CRL)
```
4.	When “The CA servers are running, you may start another session to test ..” is displayed, duplicate a session on Linux (naming as session 2).

5.	On session 2, open netcoreapp3.0 folder, run the following commands to generate .pem files for certificate files generated in step3:

  openssl x509 -in ./0.cer -inform der -outform pem -out ./0.pem

  openssl x509 -in ./1.cer -inform der -outform pem -out ./1.pem

   openssl x509 -in ./2.cer -inform der -outform pem -out ./2.pem

6.	On session 2, run command “openssl x509 -in ./0.pem -text -noout” , find the  OCSP URL( the line starts with OCSP – URI)

7.	On session 2, run command ```openssl ocsp -issuer ./1.pem -cert ./0.pem -text -url ``` + the URL we  got from step 6

8.	Compare the outputs on session 1 and session 2, the nonce from session 1(OCSP respond) and the nonce from session 2(OCSP request) should be the same.  And the openssl verify results from session 2 is good.
```
Response verify OK
./0.pem: good
```

So step 8 shows that the CA server has configured OCSP respond with correct nonce and status. 
But the step 3 shows that the chain.Build failed for unable to get certificate CRL.

Above are the repro steps on Linux.

If we repro on windows(netcoreapp3.0), we have following different results:
Compared to step 3 on Linux, Windows has a null nonce in OCSP respond:

```
CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Root Certificate Authority (86b412bb-d4bf-40bd-a544-263ae3ed26be)
1 OCSP respond(s) is sent..
   nonce is null
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (9c6012a9-2ce2-4e07-b1a2-789dc2f2f219)
1 OCSP respond(s) is sent..
   nonce is null
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (9c6012a9-2ce2-4e07-b1a2-789dc2f2f219)
1 OCSP respond(s) is sent..
   nonce is null
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Root Certificate Authority (86b412bb-d4bf-40bd-a544-263ae3ed26be)
1 OCSP respond(s) is sent..
   nonce is null
   certificateStatus : Good

CertificateAuthority is : C=US,ST=WA,L=Redmond,O=NuGet,CN=NuGet Test Intermediate Certificate Authority (9c6012a9-2ce2-4e07-b1a2-789dc2f2f219)
1 OCSP respond(s) is sent..
   nonce is null
   certificateStatus : Good
```

Windows has chain.Build running successfully: (status are empty)

```
Revocation flag:  ExcludeRoot
chain building results are as following:
certificate.Subject is : CN=NuGet Test Timestamp Service (9cef8b66-4871-46ae-b6ee-a411937ebecf), O=NuGet, L=Redmond, S=WA, C=US
certificate.FriendlyName is :
=================   The (0) th certificate is   :=================
File path:  C:\repos\NuGet.Client\test\NuGet.Core.FuncTests\ConsoleApp3\bin\Debug\netcoreapp3.0\0.cer
chainElement.Certificate.Subject : (CN=NuGet Test Timestamp Service (9cef8b66-4871-46ae-b6ee-a411937ebecf), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (13C3BFE21E62DF8D916B56BE8EE026CA35F98C92)
chainElement.Certificate.isvalid : (True)
    --------   The chainElementStatus are : -------
=================   The (1) th certificate is   :=================
File path:  C:\repos\NuGet.Client\test\NuGet.Core.FuncTests\ConsoleApp3\bin\Debug\netcoreapp3.0\1.cer
chainElement.Certificate.Subject : (CN=NuGet Test Intermediate Certificate Authority (9c6012a9-2ce2-4e07-b1a2-789dc2f2f219), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (F909EF774F675E0C262B5EF4D62830BA4C36EF8E)
chainElement.Certificate.isvalid : (True)
    --------   The chainElementStatus are : -------
=================   The (2) th certificate is   :=================
File path:  C:\repos\NuGet.Client\test\NuGet.Core.FuncTests\ConsoleApp3\bin\Debug\netcoreapp3.0\2.cer
chainElement.Certificate.Subject : (CN=NuGet Test Root Certificate Authority (86b412bb-d4bf-40bd-a544-263ae3ed26be), O=NuGet, L=Redmond, S=WA, C=US)
chainElement.Certificate.Thumbprint : (C3DBDC6825FB9C2348F0441494463073B55EAE4E)
chainElement.Certificate.isvalid : (True)
--------   The chainElementStatus are : -------
```

We also tried to run “openssl verify” command on Linux to verify certificate as following:
1.	On Linux session 2, run following command to  concatenate a chain:
cat ./1.pem &gt; ./chain.pem
cat ./2.pem &gt;&gt; ./chain.pem

2.	Run “openssl verify -verbose -CAfile ./chain.pem ./0.pem”
```Result is :   ./0.pem: OK```
</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41474</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider moving ReadOnlySequence and IBufferWriter into CoreLib</Title>
    <Description>See https://github.com/dotnet/corefx/issues/41166#issuecomment-537141144 for further information.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41473</IssueID>
    <RepoID>1</RepoID>
    <Title>freezing the version for the System.IO.Pipes.AccessControl </Title>
    <Description>Fixes #40978</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41471</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix broken markdown link in porting.md</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41470</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unnecessary dependencies from System.Net.Http</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41469</IssueID>
    <RepoID>1</RepoID>
    <Title>Demonstrate converter for Dictionary&lt;TKey,&gt; where TKey is not String</Title>
    <Description>Based on questions from https://github.com/dotnet/corefx/issues/40120 and elsewhere, demonstrate how a custom converter can be written to handle this for the 3.x timeframe.

In 5.0 we may have a way to do add a built-in converter pending semantics.

These tests may be ported to release/3.0 in order to prevent regressions.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41468</IssueID>
    <RepoID>1</RepoID>
    <Title>Assembly.GetTypes() and Assembly.GetType() differ on netstandard assembly</Title>
    <Description># Summary

Note: This is distilled down from a larger code base where we have encountered the problem.

When called on the Assembly for `netstandard`, the results of the `Assembly.GetTypes()` ( https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettypes?view=netcore-3.0 ) and `Assembly.GetType(string)` ( https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.gettype?view=netcore-3.0#System_Reflection_Assembly_GetType_System_String_ ) functions differ. Specifically, `GetTypes()` returns an empty list whereas `GetType(string)` is able to find Type objects.

# Reproducer

```C#
	class Program
	{

		static Tuple&lt;Assembly,Type&gt; FindTypeViaGetTypes(Assembly[] assemblies, string typename)
		{
			foreach ( var a in assemblies )
			{
				Type[] types = a.GetTypes();
				foreach ( var type in types )
				{
					if( type.FullName == typename )
						return new Tuple&lt;Assembly,Type&gt;(a, type );
				}
			}
			return null;
		}

		static Tuple&lt;Assembly, Type&gt; FindTypeViaGetType(Assembly[] assemblies, string typename)
		{
			foreach( var a in assemblies )
			{
				var type = a.GetType( typename );
				if( type != null )
					return new Tuple&lt;Assembly, Type&gt;( a, type );
			}
			return null;
		}

		static void Main( string[] args )
		{
			Assembly.Load( "netstandard" ); // To force the assembly to load
			string typename = "System.Diagnostics.FileVersionInfo";
			AppDomain domain = AppDomain.CurrentDomain;
			Assembly[] items = domain.GetAssemblies();

			var scanType = FindTypeViaGetTypes( items, typename );
			var directType = FindTypeViaGetType( items, typename );

			if( scanType != null )
			{
				var assembly = scanType.Item1;
				var type = scanType.Item2;
				string msg = "Found Type object via scanning Assembly.GetTypes()\n" +
					$"\tFound in Assembly: {assembly.FullName}\n" +
					$"\tTypeName: {type.FullName}\n" +
					$"\tType's Assembly: {type.AssemblyQualifiedName}";
				Console.WriteLine( msg );
			}

			if (directType != null)
			{
				var assembly = directType.Item1;
				var type = directType.Item2;
				string msg = "Found Type object via direct query Assembly.GetType(string)\n" +
					$"\tFound in Assembly: {assembly.FullName}\n" +
					$"\tTypeName: {type.FullName}\n" +
					$"\tType's Assembly: {type.AssemblyQualifiedName}";
				Console.WriteLine( msg );
			}

			return;
		}
	}
```

# Result

.NET Core 3.0:
```
bin\Release\netcoreapp3.0\win-x64&gt;
Found Type object via direct query Assembly.GetType(string)
        Found in Assembly: netstandard, Version=2.1.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51
        TypeName: System.Diagnostics.FileVersionInfo
        Type's Assembly: System.Diagnostics.FileVersionInfo, System.Diagnostics.FileVersionInfo, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
```

.NET Core 2.2:
```
bin\Release\netcoreapp2.2\win-x64&gt;
Found Type object via direct query Assembly.GetType(string)
        Found in Assembly: netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51
        TypeName: System.Diagnostics.FileVersionInfo
        Type's Assembly: System.Diagnostics.FileVersionInfo, System.Diagnostics.FileVersionInfo, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
```

# Expected

The `Type` for `System.Diagnostics.FileVersionInfo` should be found via both `Assembly.GetTypes()` and `Assembly.GetType(string)`</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41467</IssueID>
    <RepoID>1</RepoID>
    <Title>Support For Getting base-64 String as Byte Array</Title>
    <Description>Reimplementation to solve problems from #41464. Only added one test where the method returns false as suggested:

&gt; This needs a lot more tests... whitespace-containing, two trailing =, zero trailing =, something that returns false (including zero, one, and two trailing = in the false-returning inputs)

but the rest of these cases should with this reimplementation be covered by [Convert.FromBase64.cs](https://github.com/dotnet/corefx/blob/master/src/System.Runtime.Extensions/tests/System/Convert.FromBase64.cs).

Solves #41132. Implemented support for getting JsonString encoded in base-64 as an equivalent byte array.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41466</IssueID>
    <RepoID>1</RepoID>
    <Title>ComputeSignature on Linux : OpenSslCryptographicException: error:04075093:rsa routines:RSA_sign:value missing</Title>
    <Description>Hi,

I would like to know why my code work on Windows and not on Linux.

```
private void SignManifestFile(PassGeneratorRequest request)
{

            Trace.TraceInformation("Signing the manifest file...");

            try
            {

                ContentInfo contentInfo = new ContentInfo(manifestFile);

                SignedCms signing = new SignedCms(contentInfo, true);

                CmsSigner signer = new CmsSigner(SubjectIdentifierType.SubjectKeyIdentifier, passCert)
                {
                    IncludeOption = X509IncludeOption.None
                };

                Trace.TraceInformation("Fetching Apple Certificate for signing..");
                Trace.TraceInformation("Constructing the certificate chain..");
                signer.Certificates.Add(appleCert);
                signer.Certificates.Add(passCert);

                signer.SignedAttributes.Add(new Pkcs9SigningTime());

                Trace.TraceInformation("Processing the signature..");
                signing.ComputeSignature(signer); //&lt; ----------- EXCEPTION

                signatureFile = signing.Encode();

                Trace.TraceInformation("The file has been successfully signed!");
            }
            catch (Exception exp)
            {
                Trace.TraceError("Failed to sign the manifest file: [{0}]", exp.Message);
                throw new ManifestSigningException("Failed to sign manifest", exp);
            }
}
```
```
Error :
&gt;  ---&gt; Interop+Crypto+OpenSslCryptographicException: error:04075093:rsa routines:RSA_sign:value missing
&gt;    at System.Security.Cryptography.RSAOpenSsl.TrySignHash(ReadOnlySpan`1 hash, Span`1 destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Boolean allocateSignature, Int32&amp; bytesWritten, Byte[]&amp; signature)
&gt;    at System.Security.Cryptography.RSAOpenSsl.TrySignHash(ReadOnlySpan`1 hash, Span`1 destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32&amp; bytesWritten)
&gt;    at System.Security.Cryptography.Pkcs.CmsSignature.RSAPkcs1CmsSignature.Sign(ReadOnlySpan`1 dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, Boolean silent, Oid&amp; signatureAlgorithm, Byte[]&amp; signatureValue)
&gt;    at System.Security.Cryptography.Pkcs.CmsSignature.Sign(ReadOnlySpan`1 dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, Boolean silent, Oid&amp; oid, ReadOnlyMemory`1&amp; signatureValue)
&gt;    at System.Security.Cryptography.Pkcs.CmsSigner.Sign(ReadOnlyMemory`1 data, String contentTypeOid, Boolean silent, X509Certificate2Collection&amp; chainCerts)
&gt;    at System.Security.Cryptography.Pkcs.SignedCms.ComputeSignature(CmsSigner signer, Boolean silent)
&gt;    at Avomark.VirtualWallet.ApplePay.PassGenerator.SignManifestFile(PassGeneratorRequest request)
```
Ubuntu 16.04
Net core : 2.2.402


Thanks everyone :)

[@danmosemsft added formatting]</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41465</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher doesn't notify on linux when file is moved to the watched folder</Title>
    <Description>### Steps to Reproduce
Move a file to watch folder from outside to thereof. It produces no events.

### Expected Behavior
`WatcherChangeTypes.Created` event should be fired.

### Actual Behavior
No event is fired.

### Environment
```
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100
 Commit:    04339c3a26

Runtime Environment:
 OS Name:     fedora
 OS Version:  30
 OS Platform: Linux
 RID:         fedora.30-x64
 Base Path:   /usr/share/dotnet/sdk/3.0.100/

Host (useful for support):
  Version: 3.0.0
  Commit:  95a0a61858

.NET Core SDKs installed:
  3.0.100 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.App 3.0.0 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 3.0.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]
```

### Example Project

[FSWatcherMacCore.zip](https://github.com/dotnet/corefx/files/3676996/FSWatcherMacCore.zip)


</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41464</IssueID>
    <RepoID>1</RepoID>
    <Title>Support For Getting base-64 String as Byte Array</Title>
    <Description>Solves #41132. Implemented support for getting `JsonString`  encoded in base-64 as an equivalent byte array.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41463</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20191001.1
- **Date Produced**: 10/1/2019 9:05 AM
- **Commit**: b51799c4f5cee439b248310a17d7edaddfbee8af
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19501.1
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19501.1
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19501.1

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190930.12
- **Date Produced**: 10/1/2019 3:39 AM
- **Commit**: 969ce665afee70b2d591e5c271525c927a8834d0
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19480.12
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19480.12

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41462</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpWebRequest caches HttpClient in simple cases</Title>
    <Description>HttpWebRequest caches and tries to reuse a single static HttpClient instance when it's safe to share the same instance among concurrent requests with the given parameters.
Fixes #15460</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41461</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190930.3
- **Date Produced**: 9/30/2019 8:25 PM
- **Commit**: 238f1bbb23ba67616818d0b242c5b55a18edec55
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19480.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19480.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19480.3

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41460</IssueID>
    <RepoID>1</RepoID>
    <Title>Microsoft.XmlSerializer.Generator does not work when using multiple targetframeworks</Title>
    <Description>When using Microsoft.XmlSerialization.Generator version 2.1.0 package, with the following csproj:
```
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFrameworks&gt;netstandard2.0;netcoreapp3.0&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.XmlSerializer.Generator" Version="2.1.0" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
```

The generation fails with the following error:

```
  Restore completed in 106,92 ms for C:\code\tests\SampleApp1\ClassLibrary1\ClassLibrary1.csproj.
  ClassLibrary1 -&gt; C:\code\tests\SampleApp1\ClassLibrary1\bin\Debug\netstandard2.0\ClassLibrary1.dll
  Could not execute because the specified command or file was not found.
  Possible reasons for this include:
    * You misspelled a built-in dotnet command.
    * You intended to execute a .NET Core program, but dotnet-Microsoft.XmlSerializer.Generator does not exist.
    * You intended to run a global tool, but a dotnet-prefixed executable with this name could not be found on the PATH.
C:\Users\Thomas\.nuget\packages\microsoft.xmlserializer.generator\2.1.0\build\Microsoft.XmlSerializer.Generator.targets(37,5): warning MSB3073: The command "dotnet Microsoft.XmlSerializer.Generator "obj\Debug\netstandard2.0\ClassLibrary1.dll" --force --quiet obj\Debug\netstandard2.0\sgen.rsp" exited with code 1. [C:\code\tests\SampleApp1\ClassLibrary1\ClassLibrary1.csproj]
C:\Users\Thomas\.nuget\packages\microsoft.xmlserializer.generator\2.1.0\build\Microsoft.XmlSerializer.Generator.targets(38,5): warning : SGEN: Failed to generate the serializer for ClassLibrary1.dll. Please follow the instructions at https://go.microsoft.com/fwlink/?linkid=858594 and try again. [C:\code\tests\SampleApp1\ClassLibrary1\ClassLibrary1.csproj]
  ClassLibrary1 -&gt; C:\code\tests\SampleApp1\ClassLibrary1\bin\Debug\netcoreapp3.0\ClassLibrary1.dll
  Could not execute because the specified command or file was not found.
  Possible reasons for this include:
    * You misspelled a built-in dotnet command.
    * You intended to execute a .NET Core program, but dotnet-Microsoft.XmlSerializer.Generator does not exist.
    * You intended to run a global tool, but a dotnet-prefixed executable with this name could not be found on the PATH.
C:\Users\Thomas\.nuget\packages\microsoft.xmlserializer.generator\2.1.0\build\Microsoft.XmlSerializer.Generator.targets(37,5): warning MSB3073: The command "dotnet Microsoft.XmlSerializer.Generator "obj\Debug\netcoreapp3.0\ClassLibrary1.dll" --force --quiet obj\Debug\netcoreapp3.0\sgen.rsp" exited with code 1. [C:\code\tests\SampleApp1\ClassLibrary1\ClassLibrary1.csproj]
C:\Users\Thomas\.nuget\packages\microsoft.xmlserializer.generator\2.1.0\build\Microsoft.XmlSerializer.Generator.targets(38,5): warning : SGEN: Failed to generate the serializer for ClassLibrary1.dll. Please follow the instructions at https://go.microsoft.com/fwlink/?linkid=858594 and try again. [C:\code\tests\SampleApp1\ClassLibrary1\ClassLibrary1.csproj]
```

Switching to a single TargetFramework resolves the problem (either netstandard or netcoreapp).</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41459</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json crash on deserializing invalid json </Title>
    <Description>with the following structure deserializing invalid json ( see end of issue ) crash instead of using appropriate exeption 
```
class ArticleTypesData
    {
        public IList&lt;ArticleType&gt; ItemTypes { get; set; }
    }
    class ArticleType
    {
        public string Name { get; set; }
    }
```

logic used : 
```
var options = new JsonSerializerOptions
 {
    AllowTrailingCommas = true
};

var ArticleTypesDatas = JsonSerializer.Deserialize&lt;ArticleTypesData&gt;(file, options);

```

Actual result : Null ptr exeption : 

Expeted result : 
use of System.Text.Json.JsonException . with message like 
`System.Text.Json.JsonException : ''"' is an invalid start of an object Array. Expected a '{'. Path: $.ItemTypes[0] | LineNumber: 4 | BytePositionInLine: .'`


valid json : 

```
{
    "ItemTypes": [
    
        {
			"Name": "Where to Stay",
		},
		{
			"Name": "Where to Stay",
		},
    
	]
}
```


invalid json : 
```
{
    "ItemTypes": [

			"Name": "Where to Stay",

			"Name": "Where to Stay",

	]
}

```</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41458</IssueID>
    <RepoID>1</RepoID>
    <Title>LangVersion latest ignores C# 8</Title>
    <Description>The interpretation of `&lt;LangVersion&gt;latest&lt;/LangVersion&gt;` ignores C# 8. Instead, C# 7 is selected.

Tested in both `netcoreapp3.0` and `netstandard2.0` projects.

While I'm aware that the `netcoreapp3.0` project could simply omit the `LangVersion`, this still looks like incorrect (and counterintuitive) behavior. In practice it's annoying for existing project templates and for projects being upgraded.

(For `netstandard2.0` projects, even though we could argue about the usefulness of C# 8 there, I believe that `&lt;LangVersion&gt;latest&lt;/LangVersion&gt;` expresses a clear intent to use the latest possible version - without having to update the value as potential new versions become available. That intent should be honored.)</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41457</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Stop using vfork with musl libc and credentials</Title>
    <Description>Edited by @stephentoub...

Fixes #41432.  Works around an issue in musl libc.

## Description

In .NET Core 3.0 we changed Process.Start on Unix to use `vfork` rather than `fork`, as a perf optimization (in particularly around memory usage).  However, there's an issue when running on musl libc (e.g. on Alpine) where the call to `vfork` ends up hanging when also setting process credentials.

## Customer Impact

Process.Start on Alpine hangs when starting the process with credentials.

## Regression?

Yes, from .NET Core 2.2.

## Risk

Low; this is just reverting back to using `fork` in some cases (we used to always use `fork`).  The biggest risk here IMHO isn't the changes in this PR; it's that we might find additional cases we want to revert as well.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41456</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json default date handling</Title>
    <Description>In JSON.NET you can:
```
JsonConvert.DefaultSettings = () =&gt; new JsonSerializerSettings {
    DateTimeZoneHandling = DateTimeZoneHandling.Utc
};
```

Is there anything similar in `System.Text.Json`?
If there is not an option to set the default, can it be passed in manually?

Also, what is the default (`Local`, `Utc`, `Unspecified`)?</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41455</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @adamsitnik</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41454</IssueID>
    <RepoID>1</RepoID>
    <Title>Break the ACL classes into files</Title>
    <Description>
    </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41453</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190930.2
- **Date Produced**: 9/30/2019 7:06 PM
- **Commit**: 0303386d3bdc4dc9b9ea59fbaadfe0d896f960ee
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19480.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19480.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19480.2

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41452</IssueID>
    <RepoID>1</RepoID>
    <Title>Unit tests to verify DirectoryInfo.Parent.ToString (CoreFX/Framework)</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/38215
The `DirectoryInfo.Parent.ToString()` method returns a different value in Core and in Framework. I already documented it in Docs, now we need to make sure it has unit tests.</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41451</IssueID>
    <RepoID>1</RepoID>
    <Title>Find zip file end of central directory backwards up to max possible size (resubmit due to build break)</Title>
    <Description>Original PR https://github.com/dotnet/corefx/pull/41007
There was a conflict with a recent Compression change that added nullable checks. The CI passed in my PR, but it ran before the nullable fix was merged.

</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41450</IssueID>
    <RepoID>1</RepoID>
    <Title>Add SystemNative_ThreadInterruptionRequested() to all `EINTR` loops.</Title>
    <Description>In Mono, we need a way of interrupting `errno == EINTR` loops on thread abort and runtime shutdown.  We could either break all those loops and always return to managed on `EINTR` - or call a special function that will check whether it is safe to loop.

This should fix the problem outlined in https://github.com/mono/mono/issues/14737.</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41449</IssueID>
    <RepoID>1</RepoID>
    <Title>Revert "Find zip file end of central directory backwards up to max possible size"</Title>
    <Description>Reverts dotnet/corefx#41007

This change broke the build due to conflicts with https://github.com/dotnet/corefx/pull/41322
</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41448</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable Building of packages in 3.1 branch</Title>
    <Description>
    </Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41447</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @Anipik

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41446</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr,corert</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr,corert


**Please REBASE this PR when merging**

 cc @Youssef1313</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41443</IssueID>
    <RepoID>1</RepoID>
    <Title>ClientWebSocket.ReceiveAsync() throws IOException when cancelled</Title>
    <Description>If a `ClientWebSocket.ReceiveAsync()` is cancelled with a `CancellationToken`, it throws an `IOException`. I was expecting an `OperationCanceledException`? Please see the repro below:

``` C#
static async Task Main(string[] args)
{
	System.Net.WebSockets.ClientWebSocket clientWebSocket = new System.Net.WebSockets.ClientWebSocket();
	var rcvBytes = new byte[128];
	var rcvBuffer = new ArraySegment&lt;byte&gt;(rcvBytes);
	var cancellationTokenSource = new System.Threading.CancellationTokenSource();
	var cancellationToken = cancellationTokenSource.Token;
	await clientWebSocket.ConnectAsync(new Uri(
		"wss://echo.websocket.org"), cancellationToken);
	var t = Task.Run(async () =&gt; {
		while (true)
		{
			System.Net.WebSockets.WebSocketReceiveResult rcvResult = await 
				clientWebSocket.ReceiveAsync(
						rcvBuffer,
						cancellationToken);
			byte[] msgBytes = rcvBuffer.Skip(rcvBuffer.Offset).Take(rcvResult.Count).ToArray();
					string rcvMsg = Encoding.UTF8.GetString(msgBytes);
					Console.WriteLine("Received: {0}", rcvMsg);
		} });
	await Task.Delay(500);
	cancellationTokenSource.Cancel();
	Console.WriteLine("cts cancelled");
}
```

Throws:
```
System.IO.IOException
  HResult=0x80131620
  Message=Unable to read data from the transport connection: The I/O operation has been aborted because of either a thread exit or an application request..
  Source=System.Net.Sockets
  StackTrace:
   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)

Inner Exception 1:
SocketException: The I/O operation has been aborted because of either a thread exit or an application request.
```

In .net core 3.0 and 2.2 on VSE 2019 16.3.1 on Windows 10 x64

May be related to #5200?</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41442</IssueID>
    <RepoID>1</RepoID>
    <Title>What is the recomendation of using System.Text.Json and double NaN values ?</Title>
    <Description>_From @valeriob on Monday, September 30, 2019 12:49:01 PM_

Hi,
we are upgrading some applications to aspnetcore 3.0, we have been bitten by something unexpected : System.Text.Json refuse to serialize double.NaN values.
This cause really nasty bugs because something that works suddenly does not because some result of some calculation is different, or some data changes in some way.
I see that the recommendation (https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;tabs=visual-studio#jsonnet-support) is to use Json.Net.

But how can ppl use this library if such a simple and common use case is not covered ?
I do not know any application that can live without this feature, i understand the fact that there is a specification, but it may very well be unpractical.
https://thefactotum.xyz/post/the-devil-is-in-the-json-details/
Python, Go, Javascript,Rust, Ruby handle it without making much fuss 😄 

Thanks
Valerio

_Copied from original issue: aspnet/AspNetCore#14571_</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41441</IssueID>
    <RepoID>1</RepoID>
    <Title>Build corefx from build.cmd fails</Title>
    <Description>Visual Studio Community 2019  16.4.0 Preview 1.0
Windows 10 1903 build SO 18362.387
NET Core 3.0.100
CMake 3.14.5

After has been pulling the latest comimts the build procedure fails with these two errors:

```
C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\MSBuild\Microsoft\VC\v160\Microsoft.CppCommon.targets(230,5): error MSB8065: Custom build for item "D:\Sources\NetFoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug-x64\CMakeFiles\af7b5fb01ed3438277a908fb1341432f\INSTALL_force.rule" succeeded, but specified output "d:\sources\netfoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-windows_nt-debug-x64\cmakefiles\install_force" has not been created. This may cause incremental build to work incorrectly. [D:\Sources\NetFoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug-x64\install.vcxproj] [D:\Sources\NetFoundation\dotnet\corefx\src\Native\build-native.proj]
C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\MSBuild\Microsoft\VC\v160\Microsoft.CppCommon.targets(230,5): error MSB8065: Custom build for item "D:\Sources\NetFoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug-x64\CMakeFiles\af7b5fb01ed3438277a908fb1341432f\INSTALL_force.rule" succeeded, but specified output "d:\sources\netfoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-windows_nt-debug-x64\cmakefiles\install_force" has not been created. This may cause incremental build to work incorrectly. [D:\Sources\NetFoundation\dotnet\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug-x64\install.vcxproj] [D:\Sources\NetFoundation\dotnet\corefx\src\Native\build-native.proj]
```
`git clean -xdf` has no effects</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41440</IssueID>
    <RepoID>1</RepoID>
    <Title>Code example in DiagnosticSourceUsersGuide.md is outdated</Title>
    <Description>In section **Discovery of DiagnosticListeners** of https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md, the example is incorrect, it passes delegate directly to DiagnosticListener.AllListeners.Subscribe, the needed parameter is IObserver.

Seems the correct code is in https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/tests/DiagnosticSourceTests.cs#L423.</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41439</IssueID>
    <RepoID>1</RepoID>
    <Title>Add API to validate file system paths</Title>
    <Description>## Rationale ##

In PowerShell Core repo we actively manipulate paths and do path validation by:
```c#
            try
            {
                FileInfo testFile = new FileInfo(path);
            }
            catch (Exception e)
            {
                if ((e is ArgumentNullException) ||
                    (e is ArgumentException) ||
                    (e is System.Security.SecurityException) ||
                    (e is UnauthorizedAccessException) ||
                    (e is PathTooLongException) ||
                    (e is NotSupportedException))
                {
                    return false;
                }
            }
```
The code allocates many unneeded FileInfo objects and exceptions.

## Proposed API ##

```c#
namespace System.IO
{
    // Fast, no allocations, no exceptions, no check that file/directory exists
    public static class Path
    {
        public static bool IsValid(string path);
    }
}
```

Related #27049</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41444</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpRequest Method Changes during Execution</Title>
    <Description>** Overview **
Trying to send a post message to Azure DevOps and while executing the httpRequest method changes from being Post to Get. The response I get back from Azure DevOps is Http Method not allowed.

** System Details **
Mac OSX 10.4.15
.Net Framework Versions:
Ice@Ices-MacBook-Pro-2  /  dotnet --list-sdks
2.1.700 [/usr/local/share/dotnet/sdk]
3.0.100 [/usr/local/share/dotnet/sdk]

** Code **   
```
public WorkItemQueryResult GetListOfStories(string queryString, string tfsInstance, string PAT)
        {
            var client = new HttpClient();
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", $"{GetPatAsEncodedString(PAT)}");

            var request = new HttpRequestMessage()
            {
                Content = new StringContent(queryString, Encoding.UTF8, "application/json" ),
                Method = HttpMethod.Post,
                RequestUri = new Uri($"{tfsInstance}_apis/wit/wiql?api-version=5.1")
            };
            
            request.Headers.Authorization = new AuthenticationHeaderValue("Basic", $"{GetPatAsEncodedString(PAT)}");
            request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            var task = Task.Run(() =&gt; client.SendAsync(request)); 
            task.Wait();

            if (!task.Result.IsSuccessStatusCode) return new WorkItemQueryResult();
            
            var response = task.Result.Content.ReadAsAsync&lt;WorkItemQueryResult&gt;();
            return response.Result;
        }
```

With a break point on Task.Run, the request method looks like the following: 
&lt;img width="1945" alt="Screen Shot 2019-09-30 at 11 47 52 am" src="https://user-images.githubusercontent.com/18162364/65844242-babc6400-e378-11e9-8d55-eba93a61cac6.png"&gt;

After waiting for the task the request looks like the following:
&lt;img width="1602" alt="Screen Shot 2019-09-30 at 11 51 08 am" src="https://user-images.githubusercontent.com/18162364/65844260-d162bb00-e378-11e9-8950-501853ffc79b.png"&gt;

The response code that I'm receiving is 405 - Method Not Allowed.

** Items Tried **
- I've tried using both versions of .Net Core in case there was a bug that somehow hadn't been found.
- Tried using .PostAsync instead. 

It's most likely something silly, but I've not been able to ascertain what the issue is, my google foo is letting me down.</Description>
    <CreatedDate>30/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41438</IssueID>
    <RepoID>1</RepoID>
    <Title>CertificateRequest Crashing (SIGILL) on MacOS</Title>
    <Description>I've run into an odd issue where I'm hitting a SIGILL on MacOS 10.14.6 during the CertificateRequest constructor on Mac. I've tried every combination of hash methods, key sizes and types (RSA and ECDSA), padding methods, etc and they all appear to fail.  The test case below shows the behavior: 

	using System;
	using System.Security.Cryptography;
	using System.Security.Cryptography.X509Certificates;

	namespace MacCertCrash {
		class Program {
			static void Main(string[] args) {
				Console.WriteLine("Step 1");
				var rsa = RSA.Create(2048);
				Console.WriteLine("Step 2");
				var name = new X500DistinguishedName("C=US/ST=Foo/L=Bar/O=Baz/OU=Hax/CN=tempest");
				Console.WriteLine("Step 3");
				var req = new CertificateRequest(name, rsa, HashAlgorithmName.SHA512,
					RSASignaturePadding.Pss); // CRASH HERE
				Console.WriteLine("Step 4");
				var cert = req.CreateSelfSigned(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddYears(10));
				Console.WriteLine("Done?");
				Console.WriteLine(cert);
			}
		}
	}

The crash occurs in standard debug or release builds.</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41437</IssueID>
    <RepoID>1</RepoID>
    <Title>Console.Beep() does not works under RDP</Title>
    <Description># Console.Beep() does not works under RDP
Example:
`Console.Beep();`


But it **works if called with arguments.**
Example:
`Console.Beep(500, 300);`

# How to reproduce
Both client and server: Windows 10 x64 1903 Build 18990
Microsoft Remote Desktop from Store: https://www.microsoft.com/store/productId/9WZDNCRFJ3PS</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41445</IssueID>
    <RepoID>1</RepoID>
    <Title>'GroupCollection' does not contain a definition for 'Count'</Title>
    <Description>I recently tried to move my web application from .net cor 2.2 to 3.0. While the following code used to compile and run just fine, it now gives the error at every occurrence where Count is invoked on a System.Text.RegularExpressions.Match object

internal virtual bool IsValidKeywordFormat(Match m, out string error)
        {

            int matches = m.Groups.Count(t =&gt; t.Success);
            ......


Error: CS1061 : 'GroupCollection' does not contain a definition for 'Count' and no accessible extension method 'Count' accepting a first argument of type 'GroupCollection' could be found (are you missing a using directive or an assembly reference?)

</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41436</IssueID>
    <RepoID>1</RepoID>
    <Title>How do I set the JSON DateTime format?</Title>
    <Description>var json = JsonSerializer.Serialize(new { D = DateTime.Now });
I want to format it as "yyyy-mm-dd HH: MM :ss"
How can I solve it?</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>29/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41435</IssueID>
    <RepoID>1</RepoID>
    <Title>Console.OutputEncoding = Encoding.BigEndianUnicode; throw Exception.</Title>
    <Description>
    </Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>29/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41434</IssueID>
    <RepoID>1</RepoID>
    <Title>private set PropertyInfo GetSetMethod Is null</Title>
    <Description>my class has two property

public long Id =&gt; 2;
public long OrganizationId { get; private set; }

OrganizationId  PropertyInfo GetSetMethod Is null,
but IL Code has method

![image](https://user-images.githubusercontent.com/13499426/65831588-0970ec00-e2ee-11e9-8202-39840f3c4f16.png)

![image](https://user-images.githubusercontent.com/13499426/65831645-8ac87e80-e2ee-11e9-8d84-780729d28e91.png)

what's  happen?
</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41433</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json.JsonSerializer can't deserialize readonly collection property</Title>
    <Description>I have a Config class which contains a readonly property named Items.
I serialize it to json string, and then deserialize the json string back as below.
After run the Run() method, cfg2.Items is empty when cfg3.Items contains one item.

``` csharp
public class Config
{
    public HashSet&lt;string&gt; Items { get; } = new HashSet&lt;string&gt;();
}

public class ConfigTest
{
    public void Run()
    {
        var cfg = new Config();
        cfg.Items.Add("item1");
        var json = System.Text.Json.JsonSerializer.Serialize(cfg);
        var cfg2 = System.Text.Json.JsonSerializer.Deserialize&lt;Config&gt;(json);
        var cfg3 = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Config&gt;(json);
    }
}

```
</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41432</IssueID>
    <RepoID>1</RepoID>
    <Title>Process.Start() stuck forever on Alpine Linux when UserName is set in StartInfo</Title>
    <Description>Code example:

```csharp
using System;
using System.Diagnostics;

namespace test
{
    class Program
    {
        static void Main(string[] args)
        {
            var p = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "/bin/sh",
                    UserName = "root",
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false
                },
                EnableRaisingEvents = true
            };

            Console.WriteLine("Trying to start /bin/sh");
            p.Start();
            Console.WriteLine("/bin/sh started successfully");
        }
    }
}
```

Publish the project with `dotnet publish -c Release -r linux-musl-x64 --self-contained` and copy the output to a fresh-installed Alpine Linux VM.

```
localhost:~/test# ./test
Trying to start /bin/sh
```
(output stuck here)

The process tree looks like this
![image](https://user-images.githubusercontent.com/1969802/65828964-3cf24d00-e2d3-11e9-8a85-4e9bf2f7a7a2.png)

```
localhost:~# cat /proc/2421/stack
[&lt;0&gt;] _do_fork+0x21c/0x2fe
[&lt;0&gt;] do_syscall_64+0x50/0xeb
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x44/0xa9
[&lt;0&gt;] 0xffffffffffffffff
localhost:~# cat /proc/2429/stack
[&lt;0&gt;] futex_wait_queue_me+0xbc/0x101
[&lt;0&gt;] futex_wait+0xd7/0x1f1
[&lt;0&gt;] do_futex+0x131/0x9a5
[&lt;0&gt;] __se_sys_futex+0x139/0x15e
[&lt;0&gt;] do_syscall_64+0x50/0xeb
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x44/0xa9
[&lt;0&gt;] 0xffffffffffffffff
```

It seems that the parent process already called vfork() but child has not yet exec or exit, leaving the parent in the uninterruptible sleep state. Related framework code could possibly be [here](https://github.com/dotnet/corefx/blob/5c83394112febe1b481ab1c0b61a45c850677165/src/Native/Unix/System.Native/pal_process.c#L342)

Environment info
.NET Core SDK version: 3.0.100
OS: Alpine Linux 3.10 latest</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41431</IssueID>
    <RepoID>1</RepoID>
    <Title>Enumerable.OfType should use where TResult:notnull</Title>
    <Description>Null will never get into result because of it's semantics. So it should be disallowed on the type parameter.

Since nullable annotation of `System.Linq` hasn't been shipped now, the change isn't breaking.</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41430</IssueID>
    <RepoID>1</RepoID>
    <Title>How do I host a WebApi in WPF application directly since they have different project SDK?</Title>
    <Description>Currently, I add a project reference to a webapi project.
How do I host a webapi in WPF application directly since they have different project SDK?</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>29/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41429</IssueID>
    <RepoID>1</RepoID>
    <Title>how can I make a JsonConverter to Converter Enum</Title>
    <Description>``` C#
public class User
{
   public UserSex Sex { get; set; }
}
public enum UserSex
{
    unknown = 0,
    male,
    female,
}

var user = new User
{
    Sex = UserSex.female,
};

var jsetting = new JsonSerializerOptions();

return JsonSerializer.Serialize(user, jsetting);
// print
// {"Sex":2}
```
but I want it is `{ "Sex": "female" }`
how can I do?
Thanks!
</Description>
    <CreatedDate>29/09/2019</CreatedDate>
    <ClosedDate>29/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41428</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Composition: CompositionContext.TryGetExport throws CompositionFailedException</Title>
    <Description>The `CompositionContext.TryGetExport` method can throw a `CompositionFailedException`. This violates the common convention/expectation that `TryXXX` methods don't throw, instead they just return false. 

I would expect that calling `GetExport` would throw an exception in this situation but I would expect that `TryGetExport` would simply return `false`.

Stack Trace:
```
An exception of type 'System.Composition.Hosting.CompositionFailedException' occurred in System.Composition.Hosting.dll but was not handled in user code: 'The component (unknown) cannot be created outside the Scoped sharing boundary.'
   at System.Composition.Hosting.Core.LifetimeContext.FindContextWithin(String sharingBoundary)
   at System.Composition.TypedParts.ActivationFeatures.LifetimeFeature.&lt;&gt;c__DisplayClass1_0.&lt;RewriteActivator&gt;b__0(LifetimeContext c, CompositionOperation o)
   at System.Composition.Hosting.Core.CompositionOperation.Run(LifetimeContext outermostLifetimeContext, CompositeActivator compositionRootActivator)
   at System.Composition.Hosting.Core.LifetimeContext.TryGetExport(CompositionContract contract, Object&amp; export)
   at System.Composition.CompositionContext.TryGetExport(Type exportType, String contractName, Object&amp; export)
   at System.Composition.CompositionContext.TryGetExport(Type exportType, Object&amp; export)
```
</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41427</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json fails on deserializing into sub-subclasses of system collections</Title>
    <Description>When trying to deserialize into a class that has a class being a valid deserialization target for a collection higher in the class inheritance graph than its direct parent, the deserialization fails.

Example code:
```cs
namespace JsonProblem {

using System.Collections.Generic;
using System.Text.Json;

class ListString : List&lt;string&gt; {
}

class MyList&lt;T&gt; : List&lt;T&gt; {
}

class MyMyList&lt;T&gt; : MyList&lt;T&gt; {
}

class MyListString : MyList&lt;string&gt; {
}

class Program {
    const string JSON = "[\"test\"]";

    static void Main( string[] args ) {
        JsonSerializer.Deserialize( JSON, typeof(string[]) ); // works
        JsonSerializer.Deserialize( JSON, typeof(List&lt;string&gt;) ); // works
        JsonSerializer.Deserialize( JSON, typeof(ListString) ); // also works
        JsonSerializer.Deserialize( JSON, typeof(MyList&lt;string&gt;) ); // works
        JsonSerializer.Deserialize( JSON, typeof(MyMyList&lt;string&gt;) ); // doesn't work
        JsonSerializer.Deserialize( JSON, typeof(MyListString) ); // doesn't work
    }
}

}
```

All the above classes worked OK in Json.NET - IMVHO, the deserializer should handle them, which it doesn't.</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41472</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer cant Deserialize dynamic objects</Title>
    <Description>hi I hope this is a good place to ask this question
It seems we can't deserialize dynamic objects
i used this code but not worked is there any way to do this?
```
var objList = System.Text.Json.JsonSerializer.Deserialize&lt;List&lt;dynamic&gt;&gt;(json);
```
</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41426</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Re-entrantable AsyncLock</Title>
    <Description>Inspired by #34073 and it's related resources.

## Usage
Instead of using semaphore (SempahoreSlim) as a means to use to lock asynchronous content, which may result in deadlock if it is re-acquired without prior releasing on the same Task execution context.

It would be a good idea if we have a low cost, yet that prevents deadlocking upon re-entrant.
Inspired by #34073, I tested out the possibility by combining the usage of `AsyncLocal` and `SempahoreSlim`, [[Here in this Repo]](https://github.com/jasonkuo41/CellWars.Threading.AsyncLock).

Upon writing tests, it is suggested that this is possibly do-able.
Here's more of the detail of how I approached this idea:

&gt; AsyncLock utilizes two main classes SemphoreSlim and AsyncLocal; the actual lock is maintained by SemphoreSlim and the re-entrant check is done by using AsyncLocal.

&gt; When locking with AsyncLock, it returns an object implementing ILockHandle, which can either contain actual content that does the unlocking when Dispose() is called, or does absolutely nothing. The former one is acquired when the current Task has not acquired AsyncLock, the latter one is returned when AsyncLock detects when it already acquired the lock.

&gt; The detection of the current lock acquired by the current task is achieved through AsyncLocal, the underlying value of AsyncLocal is (almost) different when it's in different Task. When it's underlying value is null we know that the current Task hasn't acquired the lock and is put into the semaphore; if it's not null then we know the current Task has already acquired a lock given by this current AsyncLock instance, and would not await the semaphore and returns an empty ILockHandle.

## Thoughts and Questions

Few problems araised when there's a limitation of what AsyncLocal can do.
If the lock acquiring process is inside the scope of `ExecutionContext.SuppressFlow()`, this would effectively break the re-entrant check.
A good solution I came up with would be further integrating with `Task`, making it maintain a record of acquired `AsyncLock` without being affected by `SuppressFlow` (or just make SuppressFlow ignore the tracking of acquired locks) </Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41425</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonConverterAttribute can't be used to deserialize IEnumerable properties</Title>
    <Description>When trying to deserialize an object where one of the properties is an IEnumerable/collection and has a custom converter set by `JsonConverterAttribute`, a `JsonException` is thrown. Repro:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace JsonConverterRepro
{
    class Program
    {
        static void Main(string[] args)
        {
            var options = new JsonSerializerOptions();
            // Program works as expected when this line is uncommented:
            // options.Converters.Add(new DummyConverter());

            var json = @"{ ""Items"": [""hello"", 1, true] }";
            var model = JsonSerializer.Deserialize&lt;MyModel&gt;(json, options);

            Console.WriteLine(string.Join(", ", model.Items));
        }

        class MyModel
        {
            [JsonConverter(typeof(ToStringConverter))]
            public List&lt;string&gt; Items { get; set; }
        }

        // This converter coerces list items into strings when deserializing
        class ToStringConverter : JsonConverter&lt;List&lt;string&gt;&gt;
        {
            public override List&lt;string&gt; Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                using var doc = JsonDocument.ParseValue(ref reader);
                return doc.RootElement.EnumerateArray().Select(e =&gt; e.ToString()).ToList();
            }

            public override void Write(Utf8JsonWriter writer, List&lt;string&gt; value, JsonSerializerOptions options)
            {
                JsonSerializer.Serialize(writer, value, options);
            }
        }

        class DummyConverter : JsonConverter&lt;List&lt;string&gt;&gt;
        {
            public override List&lt;string&gt; Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =&gt;
                throw new NotImplementedException();

            public override void Write(Utf8JsonWriter writer, List&lt;string&gt; value, JsonSerializerOptions options) =&gt;
                throw new NotImplementedException();
        }
    }
}
```

This program should output `hello, 1, True`. However, when this is actually run, this exception is thrown:
```
Unhandled exception. System.Text.Json.JsonException: The JSON value could not be converted to System.Collections.Generic.List`1[System.String]. Path: $.Items | LineNumber: 0 | BytePositionInLine: 12.
 ---&gt; System.InvalidOperationException: Cannot get the value of a token type 'StartArray' as a string.
   at System.Text.Json.Utf8JsonReader.GetString()
   at System.Text.Json.Serialization.Converters.JsonConverterString.Read(Utf8JsonReader&amp; reader, Type typeToConvert, JsonSerializerOptions options)
   at System.Text.Json.JsonPropertyInfoNotNullable`4.OnReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.ReadEnumerable(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack&amp; state, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   --- End of inner exception stack trace ---
   at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack&amp; readStack, Utf8JsonReader&amp; reader, Exception ex)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
   at JsonConverterRepro.Program.Main(String[] args) in H:\projects\JsonConverterRepro\Program.cs:line 17
```

The correct behaviour is observed when when a custom converter for that property's type is added to the `JsonSerializerOptions`, even if that custom converter doesn't get used. This program also works correctly when the `ToStringConverter` is added to the `JsonSerializerOptions` instead of being set via an attribute.

Although this repro uses `List&lt;string&gt;`, the same problem occurs with other collection types and item types e.g. `IEnumerable&lt;string&gt;`, `HashSet&lt;int&gt;`.

Tested on .NET Core 3.0.100</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41424</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190927.2
- **Date Produced**: 9/27/2019 6:33 PM
- **Commit**: 14abaee3dba41fbe608431fb6a4f4b2435dcac33
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19477.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19477.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19477.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)



[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190929.2
- **Date Produced**: 9/30/2019 4:03 AM
- **Commit**: 98ee997ccb0ae479a4c03b23c682a198b12dd682
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19479.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19479.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19479.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)



[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190927.7
- **Date Produced**: 9/28/2019 1:48 AM
- **Commit**: 7e9a177824cbefaee8985a9b517ebb0ea2e17a81
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19477.7
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19477.7

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)



[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190928.2
- **Date Produced**: 9/28/2019 12:44 PM
- **Commit**: 949c55afe5a49627f76713b71883567a4fdbb2ff
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19478.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)











</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41423</IssueID>
    <RepoID>1</RepoID>
    <Title>UnmanagedType.AnsiBStr is marked as obsolete with no alternative given</Title>
    <Description>Title says it all. After a load of searching I came upon issue #34949 and pull request  #35161 in which it states:

&gt; I am leaving the attribute on the following though:
&gt; 
&gt;     UnmanagedType.AnsiBStr
&gt;     UnmanagedType.AsAny
&gt;     UnmanagedType.Currency
&gt;     UnmanagedType.TBStr
&gt;     UnmanagedType.VBByRefStr
&gt; 
&gt; My reasoning is because the BSTR ones are incredibly nuanced and cause more stress than need be and should be actively discouraged.
&gt; ...

and from issue #34949:

&gt; If your application is targeting Windows and only Windows, this API is fine to use and will be around for years to come. If there are plans for your application to run on non-Windows platforms, I would suggest avoiding any API that relates to VARIANT for the time being since support on non-Windows platform is still in question.

I think that using the `Obsolete` attribute for this is wrong considering the intention seems to be to stop people from using it because of cross-incompatibility. Can a new attribute with a bit more explanation or intention not be built in? Or maybe at least giving a but more of a specific reason in the obsolete attribute.

It's a bit weird to support calling windows API's but mark specific feature Obsolete.

Also, the documentation of UnmanagedType at https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.unmanagedtype?view=netcore-3.0 does not mention obsolete or the reasoning behind it at all.

For anyone else looking, currently the only workaround I know of is switch off warnings for error 618

```C#
#pragma warning disable 618
//and then after the call
#pragma warning restore 618
```</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41421</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json forces double quote on name</Title>
    <Description>The following json works fine with Newtonsoft.Json, but does not work with System.Text.Json
```
{
  name: "value"
}

```

It says: 

&gt; System.Text.Json.JsonException: ''m' is an invalid start of a property name. Expected a '"'. Path: $ | LineNumber: 1 | BytePositionInLine: 0.'

I tried to find if there is anything in `JsonSerializerOptions `that can help me to support this, but I could not find one.

I know System.Text.Json has better performance that's why I switched to it. I don't want to switch back if there is solution.

There are cases that we have no control over the source json to be in double-quoted name format.</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41420</IssueID>
    <RepoID>1</RepoID>
    <Title>Unable to serialize ValueTuple using System.Text.Json</Title>
    <Description>To reproduce:
Take the sample default ASPNET Core 3.0 app (API-based template), change the WeatherForecast class to include a ValueTuple:

    public class WeatherForecast
    {
...

        public (int x, int y) Location { get; set; }
    }

Change the Get method to populate Location with arbitrary values. Run the project: JSON returned has an empty location. Serializing ValueTuple's is possible with Newtonsoft (being unable to do so wrecks existing code I have that uses ValueTuples successfully with Core 2.1, moving to Core 3.0).</Description>
    <CreatedDate>28/09/2019</CreatedDate>
    <ClosedDate>28/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41419</IssueID>
    <RepoID>1</RepoID>
    <Title>Update Microsoft.Windows.Compatibility package for WCF and remove S.R.WindowsRuntime*</Title>
    <Description>Contributes to: #41335 
Contributes to: #41403 

See: https://github.com/dotnet/corefx/issues/41403#issuecomment-536105027

This will need to go into 3.0 to get serviced

</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41418</IssueID>
    <RepoID>1</RepoID>
    <Title>Prevent ImplicitTransform of index getter method</Title>
    <Description>partially resolves dotnet/coreclr#26890

&lt;details&gt;
    &lt;summary&gt;small repro (click to expand)&lt;/summary&gt;

---
Attach `dotnet trace` to this app and turn on the `Microsoft-Diagnostics-DiagnosticSource` provider.

```csharp
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine($"PID: {System.Diagnostics.Process.GetCurrentProcess().Id}");
            var diagnosticListener = new DiagnosticListener("MySource");
            while (true)
            {
                Console.Write("&gt;");
                var input = Console.ReadLine();
                if (input == "exit")
                    break;

                diagnosticListener.Write("MyEvent", new List&lt;int&gt; { 1, 2, 3 });
            }
        }
    }
```
---
&lt;/details&gt;

### Root Cause of Exception:
The getter for the implicit `Item` property for the index operator takes an argument, and `DiagnosticSourceEventSource` makes the assumption that property getters don't take arguments.  It tries to bind the resulting delegate of type `[retval] get_Item(int32 index)` to the type `Func&lt;TObject, TProperty&gt;` so the binding fails and we get the exception you see in dotnet/coreclr#26890.

offending code:
https://github.com/dotnet/corefx/blob/ac99a1b7168bd32046a954c3f06012c0fa909bed/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/DiagnosticSourceEventSource.cs#L890-L901

This change should prevent `DiagnosticSourceEventSource` from attempting to serialize the implicit `Item` property by blocking index getters.

I am intending for this change to be back ported to 3.1 and hopefully 3.0, since ASP.NET Core has used `DiagnosticSourceEventSource` for their eventing.  Since they changed their event types to inherit from `IReadOnlyCollection`, they will all hit the exception in dotnet/coreclr#26890 causing a bad diagnostic experience if you do not explicitly specify a transform.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41417</IssueID>
    <RepoID>1</RepoID>
    <Title>Set IsShipping only for experimental and IsShippingPackages only for private packages</Title>
    <Description>### Description
Fixes: https://github.com/dotnet/corefx/issues/41315

.NET Core App product assemblies that contain `Private` in their name, like `System.Private.Xml` contain wrong `AssemblyInformationalVersion` in its metadata.

### Customer Impact:

For people that read that to know what release the assembly is coming from, it would lead to the wrong release because it would always include a prerelease suffix on the version (depending on the build date). This also affected the display in http://bing.com/version

### Regression? 

Yes, infrastructure regression when adopting `IsShipping` and `NonShipping` conventions from arcade to adopt stages.

### Risk

Low, it just changes metadata information.

### Tests run / added

Manual testing:
![image](https://user-images.githubusercontent.com/22899328/65660774-9c571100-dfe4-11e9-9a79-62beea3de501.png)

![image](https://user-images.githubusercontent.com/22899328/65660801-ada01d80-dfe4-11e9-9431-4de9654c03bf.png)

![image](https://user-images.githubusercontent.com/22899328/65660810-b85ab280-dfe4-11e9-8c2c-fc1551d1bf88.png)

![image](https://user-images.githubusercontent.com/22899328/65660838-ca3c5580-dfe4-11e9-857d-ed46bfe60a46.png)

cc: @danmosemsft 
</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41416</IssueID>
    <RepoID>1</RepoID>
    <Title>Update System.Data ownership</Title>
    <Description>@glennc do you know who should be the main owner of System.Data now?
@roji should I add you to the list of owners?</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41415</IssueID>
    <RepoID>1</RepoID>
    <Title>Make ResolveEventArgs.Name not nullable</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/41404

cc: @jnm2 @stephentoub @jkotas </Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41414</IssueID>
    <RepoID>1</RepoID>
    <Title>Address misc feedback and issues from recent perf changes</Title>
    <Description>Address late feedback from previous perf PR #41098 and other misc perf-related deserialization changes.

Results in deserialization perf increase of ~1% - ~2% for simple object.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41413</IssueID>
    <RepoID>1</RepoID>
    <Title>added cross product for 2D and 4D following discussion at </Title>
    <Description>https://github.com/dotnet/corefx/issues/35434</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41412</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: size of http response headers</Title>
    <Description>## Rationale and Usage

Download managers, or other applications that wish to closely monitor network performance, when using `HttpClient` may be interested in the number of bytes a response header was, in order to calculate a bytes/second metric from that HTTP server. Right now the best we can do count the bytes of the response's content stream, but responses with no body are treated as zero bytes transferred, despite the fact that it did indeed transfer bytes over the network.

Here's a simplistic example of what I'd like to be able to do:
```csharp
var requestTime = Stopwatch.StartNew();
var headerTime = Stopwatch.StartNew();
var response = client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
headerTime.Stop();

var responseData = await response.Content.ReadAsByteArrayAsync();
requestTime.Stop();

networkTelemetry.OnComplete(request.RequestUri, headerTime.Elapsed, response.HeaderBytesTransferred, responseTime.Elapsed, responseData.Length);
```

I work on NuGet and due to the design on how it works, we expect a large number of our requests to return 404's. Therefore not being able to take into account header size impacts our ability to better understand our own network usage, or the network connectivity of the customer's machine to the host it's trying to download from.

## Proposed API
I'd like the input of experts in the area, as I'm not sure where this would go, assuming the concept is agreeable.

One possibility is to add a `Size` property to `HttpResponseHeaders`, however, this makes it sound like there was a header returned with the name "Size". So it doesn't feel right to me.

Another possibility is to add a `HeaderSize` property to `HttpResponseMessage`, but it also feels a bit out of place.

A third option is along the lines of #41408, but rather than having position set to zero at the start of the body, the position is zero before headers are read and the position when `HttpClient.SendAsync` returns determines the size of the headers. The position once the full body has been read is therefore the body size plus the header size. For example:

```csharp
var response = client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
var stream = await response.Content.ReadAsStreamAsync();
var headerSize = stream.Position;
await ProcessStreamToEnd(stream);
var bodySize = stream.Position - headerSize;
```

## Open Questions

Unfortunately I'm not an expert in the HTTP protocol. My understanding is that with HTTP 1.x, response headers are not compressed, but with HTTP 2.0 they will be. Therefore there is a question if the header size should be the number of bytes before of after decompression. Since I am interested in measuring the network connectivity to the HTTP host, I would prefer the compressed size, which would give a more consistent result, regardless of whether the header was highly or poorly compressible for a particular response.

I assume that TLS streams are the same size encrypted and decrypted and therefore they hopefully won't complicate the issue further.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41411</IssueID>
    <RepoID>1</RepoID>
    <Title>[WIP] Try fixing failing IpPacketInformationTest</Title>
    <Description>* Increases socket receive timeout.
* Adds disambiguating messages to assertions.

Attempts to fix #41361</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41410</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: Stream with BaseStream</Title>
    <Description>There are multiple classes that extend `Stream` and add a `BaseStream` property, such as [`DeflateStream`](https://github.com/dotnet/corefx/blob/e667c29636a622eb4f9493f75232b44e0ae90b29/src/System.IO.Compression/src/System/IO/Compression/DeflateZLib/DeflateStream.cs#L120), [`GzipStream`](https://github.com/dotnet/corefx/blob/e667c29636a622eb4f9493f75232b44e0ae90b29/src/System.IO.Compression/src/System/IO/Compression/GZipStream.cs#L170) and [`BrotliStream`](https://github.com/dotnet/corefx/blob/e667c29636a622eb4f9493f75232b44e0ae90b29/src/System.IO.Compression.Brotli/src/System/IO/Compression/BrotliStream.cs#L131).

I think this would be useful for applications that want to monitor network performance, such as download managers (I work on NuGet). Coupled with #41408 it would become very easy to measure the number of bytes downloaded, taking into account compressed responses.

## Rationale and Usage
Currently to find the base stream, my method would need to either cast to each type known in advance that has a base stream, or use reflection to look for a property named `BaseStream`. If this proposal is implemented, then it would be possible to simply cast to a single type and get the property directly.

An example of this would be getting the base stream from an HttpClient response:

```csharp
var response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead);
var stream = await response.Content.ReadAsStreamAsync();

Stream baseStream;
if (stream is GZipStream gzipStream)
{
    baseStream = gzipStream.BaseStream;
}
else if (stream is DeflateStream deflateStream)
{
    baseStream = deflateStream.BaseStream;
}
else if (stream is BrotliStream brotliStream)
{
    baseStream = brotliStream.BaseStream;
}
```

With this proposal, it would be simplified to this:
```csharp
var response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead);
var stream = await response.Content.ReadAsStreamAsync();

Stream baseStream;
if (stream is StreamWrapper streamWrapper)
{
    baseStream = streamWrapper.BaseStream;
}
```

This is not only less code, but it's also adaptable to `HttpClient` implementing new compression types.

## Proposed API
```csharp
public abstract class StreamWrapper : Stream
{
    public Stream BaseStream { get; }

    protected StreamWrapper(Stream baseStream);
}
```

`DeflateStream`, `GzipStream` and `BrotliStream` should be changed to extend this class, but there may be others that are relevant as well.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41409</IssueID>
    <RepoID>1</RepoID>
    <Title>Make mutable generic collection interfaces implement read-only collection interfaces</Title>
    <Description>## Rationale
It's long been a source of confusion that the mutable generic collection interfaces don't implement their respective read-only collection interfaces. This was of course due to the read-only collection interfaces being added after the fact and thus would cause breaking changes by changing a published interface API.

With the addition of default interface implementations in C#8/.NET Core 3.0 I think the mutable generic collection interfaces, `ICollection&lt;T&gt;`, `IList&lt;T&gt;`, and `IDictionary&lt;K, V&gt;` should now implicitly inherit their respective read-only collection interfaces. This can now be done without causing breaking changes.

While it would have been nice for these interfaces to share members, I think the proposed API below is the best we can possibly do with the read-only interfaces being added after the fact.

As an added bonus, this should allow some simplification of the type checking in LINQ code to check for the read-only interfaces instead of the mutable interfaces.

## Proposed API

```diff
 namespace System.Collections.Generic {
-    public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt; {
+    public interface ICollection&lt;T&gt; : IReadOnlyCollection&lt;T&gt; {
-        int Count { get; }
+        new int Count { get; }
+        int IReadOnlyCollection&lt;T&gt;.Count =&gt; Count;
     }
-    public interface IList&lt;T&gt; : ICollection&lt;T&gt; {
+    public interface IList&lt;T&gt; : ICollection&lt;T&gt;, IReadOnlyList&lt;T&gt; {
-        T this[int index] { get; set; }
+        new T this[int index] { get; set; }
+        T IReadOnlyList&lt;T&gt;.this[int index] =&gt; this[index];
     }
-    public interface IDictionary&lt;TKey, TValue&gt; : ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; {
+    public interface IDictionary&lt;TKey, TValue&gt; : ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IReadOnlyDictionary&lt;TKey, TValue&gt; {
-        TValue this[TKey key] { get; set; }
+        new TValue this[TKey key] { get; set; }
-        ICollection&lt;TKey&gt; Keys { get; }
+        new ICollection&lt;TKey&gt; Keys { get; }
-        ICollection&lt;TValue&gt; Values { get; }
+        new ICollection&lt;TValue&gt; Values { get; }
-        bool ContainsKey(TKey key);
+        new bool ContainsKey(TKey key);
-        bool TryGetValue(TKey key, out TValue value);
+        new bool TryGetValue(TKey key, out TValue value);
+        TValue IReadOnlyDictionary&lt;TKey, TValue&gt;.this[TKey key] =&gt; this[key];
+        IEnumerable&lt;TKey&gt; IReadOnlyDictionary&lt;TKey, TValue&gt;.Keys =&gt; Keys;
+        IEnumerable&lt;TValue&gt; IReadOnlyDictionary&lt;TKey, TValue&gt;.Values =&gt; Values;
+        bool IReadOnlyDictionary&lt;TKey, TValue&gt;.ContainsKey(TKey key) =&gt; ContainsKey(key);
+        bool IReadOnlyDictionary&lt;TKey, TValue&gt;.TryGetValue(TKey key, out TValue value) =&gt; TryGetValue(key, out value);
     }
 }
```

## Binary Compatibility Test
I was able to test that this change isn't a breaking change with the following custom interfaces and by simply dropping the new interfaces dll to the publish folder without recompiling the consuming code, the `IMyReadOnlyList&lt;T&gt;` interface was automatically supported without breaking the code.

### Original Interfaces DLL code
```c#
namespace InterfaceTest
{
    public interface IMyReadOnlyList&lt;T&gt;
    {
        int Count { get; }
        T this[int index] { get; }
    }

    public interface IMyList&lt;T&gt;
    {
        int Count { get; }
        T this[int index] { get; set; }
    }
}
```

### New Interfaces DLL code
```c#
namespace InterfaceTest
{
    public interface IMyReadOnlyList&lt;T&gt;
    {
        int Count { get; }
        T this[int index] { get; }
    }

    public interface IMyList&lt;T&gt; : IMyReadOnlyList&lt;T&gt;
    {
        new int Count { get; }
        new T this[int index] { get; set; }
        int IMyReadOnlyList&lt;T&gt;.Count =&gt; Count;
        T IMyReadOnlyList&lt;T&gt;.this[int index] =&gt; this[index];
    }
}
```

### Consuming Code
```c#
using System;
using System.Collections.Generic;

namespace InterfaceTest
{
    class Program
    {
        static void Main()
        {
            var myList = new MyList&lt;int&gt;();
            Console.WriteLine($"MyList&lt;int&gt;.Count: {myList.Count}");
            Console.WriteLine($"IMyList&lt;int&gt;.Count: {((IMyList&lt;int&gt;)myList).Count}");
            Console.WriteLine($"IMyReadOnlyList&lt;int&gt;.Count: {(myList as IMyReadOnlyList&lt;int&gt;)?.Count}");
            Console.WriteLine($"MyList&lt;int&gt;[1]: {myList[1]}");
            Console.WriteLine($"IMyList&lt;int&gt;[1]: {((IMyList&lt;int&gt;)myList)[1]}");
            Console.WriteLine($"IMyReadOnlyList&lt;int&gt;[1]: {(myList as IMyReadOnlyList&lt;int&gt;)?[1]}");
        }
    }

    public class MyList&lt;T&gt; : IMyList&lt;T&gt;
    {
        private readonly List&lt;T&gt; _list = new List&lt;T&gt; { default, default };

        public T this[int index] { get =&gt; _list[index]; set =&gt; _list[index] = value; }

        public int Count =&gt; _list.Count;
    }
}
```

### Original Output
```
MyList&lt;int&gt;.Count: 2
IMyList&lt;int&gt;.Count: 2
IMyReadOnlyList&lt;int&gt;.Count:
MyList&lt;int&gt;[1]: 0
IMyList&lt;int&gt;[1]: 0
IMyReadOnlyList&lt;int&gt;[1]:
```

### New Output
```
MyList&lt;int&gt;.Count: 2
IMyList&lt;int&gt;.Count: 2
IMyReadOnlyList&lt;int&gt;.Count: 2
MyList&lt;int&gt;[1]: 0
IMyList&lt;int&gt;[1]: 0
IMyReadOnlyList&lt;int&gt;[1]: 0
```

Moved from #5489 </Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41408</IssueID>
    <RepoID>1</RepoID>
    <Title>implement HttpContentReadStream.Position getter</Title>
    <Description>There are some scenarios where knowing the number of bytes downloaded from an HttpClient response stream would be useful. For example, showing progress during a large download, or reporting on how many bytes were transferred after the response stream is processed, when `HttpResposeMessage.Content.Headers.ContentLength` is not available and a buffered stream of the entire response was not used. I'm fine with this not working with the WinHttpHandler, but working in both the HTTP 1.x SocketsHttpHandler and the HTTP2 handler would be useful.

I think complexities from HTTP keepalive, pipelineing and HTTP2 streams are out of scope. I think this code snippet explains why better than I can describe with words:

```csharp
var response = client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
var stream = await response.Content.ReadAsStreamAsync();
Assert.AreEqual(0, stream.Position);
```

I care about the position of the individual response stream. The total number of bytes received since the TCP connection was opened is not important to me (and if needed should be obtained though something other than the HTTP response's content stream).

`HttpBaseStream` currently [throws a `NotSupportedException`](https://github.com/dotnet/corefx/blob/61a6264018989e06d314b68d57bd91b4b72e4360/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/HttpBaseStream.cs#L34-L38). I do have a workaround, which is to use my own stream wrapper, something similar to:

```csharp
internal class PositionStream : Stream
{
    private long _position;
    private Stream _baseStream;

    public PositionStream(Stream baseStream)
    {
        _position = 0;
        _baseStream = baseStream;
    }

    public override long Position { get =&gt; _position; set =&gt; throw new NotSupportedException(); }

    public override int Read(byte[] buffer, int offset, int count)
    {
        var read = _baseStream.Read(buffer, offset, count);
        _position += read;
        return read;
    }

    // the rest of the class
}
```

This is what I'd like `HttpConentReadStream` to implement. While this is a simple workaround and therefore it's tempting to keep it out of the BCL, the problem is that when `AutomaticDecompression` is used, it measures a different number of bytes that may be relevant, depending on what the app author wants to measure.

[SocketsHttpHandler already has code to use the correct decompression algorithm based on content encoding](https://github.com/dotnet/corefx/blob/61a6264018989e06d314b68d57bd91b4b72e4360/src/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/DecompressionHandler.cs#L68-L79), but it's in a private class, so I can't call it from my own code, meaning if a new compression type becomes available, I'd have to update my code. Perhaps if the code that uses the right decompression based on `AutomaticDecompression` settings and content-encoding, if that is made public, then it would be an alternative to my proposal as it would be possible to use my own byte-counting stream wrapper while also being forwards-compatible with new compressions types being added to HTTP responses in the future.

Here's a simple example of what I'd like to be able to do:

```csharp
var sw = Stopwatch.StartNew();
var response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead);
var stream = await response.Content.ReadAsStreamAsync();

Stream baseStream;
if (stream is GZipStream gzipStream)
{
    baseStream = gzipStream.BaseStream;
}
else if (stream is DeflateStream deflateStream)
{
    baseStream = deflateStream.BaseStream;
}
else if (stream is BrotliStream brotliStream)
{
    baseStream = brotliStream.BaseStream;
}
else
{
    baseStream = stream;
}

var value = Deserialize&lt;T&gt;(stream);

sw.Stop();
networkTelemetry.OnComplete(uri, sw.Elapsed, bytesTransferred: baseStream.Position);
```
</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41407</IssueID>
    <RepoID>1</RepoID>
    <Title>  Nullable annotation for System.IO.Pipelines</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41405</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove [DisallowNull] from EqualityComparer.GetHashCode</Title>
    <Description>Visual Studio 16.3.1 generates code like this for GetHashCode specifically because this way the null check is handled. EqualityComparer.GetHashCode is well-known to return 0 if you pass null:

```cs
struct Foo
{
    public string? Bar { get; }

    public override int GetHashCode()
    {
        // CS8604 Possible null reference argument for parameter 'obj' in
        // 'int EqualityComparer&lt;string?&gt;.GetHashCode(string? obj)'.      ↓
        return 1739646154 + EqualityComparer&lt;string?&gt;.Default.GetHashCode(Bar);
    }
}
```

Rather than generating a `!` to go along with it, could `[DisallowNull]` be removed from `EqualityComparer&lt;&gt;.GetHashCode` as a kind of contravariance, even though `IEqualityComparer&lt;&gt;.GetHashCode` has it? It would reflect the true behavior of the `EqualityComparer&lt;&gt;` class.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41404</IssueID>
    <RepoID>1</RepoID>
    <Title>Should ResolveEventArgs.Name be nullable?</Title>
    <Description>Is [`AppDomain.AssemblyResolve`](https://docs.microsoft.com/en-us/dotnet/api/system.appdomain.assemblyresolve?view=netcore-3.0) ever raised with a null [`ResolveEventArgs.Name`](https://docs.microsoft.com/en-us/dotnet/api/system.resolveeventargs.name?view=netcore-3.0) property? It doesn't seem like anything useful could be done by the event handler if `Name` is null.

It would save having to write `if (e.Name is null) return null;` in every handler if `ResolveEventArgs.Name` could be non-nullable to guarantee that the handler won't be called unless there is some name.

https://github.com/dotnet/corefx/blob/967eb3c5cb5fd36c8bb56d06f4c840f6a7a5a754/src/Common/src/CoreLib/System/ResolveEventArgs.cs#L11-L23</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41403</IssueID>
    <RepoID>1</RepoID>
    <Title>Updating Microsoft.Windows.Compatibility to v3.0.0 Results in Build Errors</Title>
    <Description>I recently update my Microsoft.Windows.Compatibility nuget from v3.0.0-preview5.19224.8 to v3.0.0.  After updating, I'm not longer able to build.  The build generates many errors similar to:

```
File.cs(1814,20): error CS0012: The type 'IAsyncAction' is defined in an assembly that is not referenced. You must add a reference to assembly 'Windows, Version=255.255.255.255, Culture=neutral, PublicKeyToken=null, ContentType=WindowsRuntime'. [G:\Project.NetCore_015px2u3_wpftmp.csproj]
```

This error is repeated for `IAsyncAction`, `IAsyncActionWithProgress&lt;&gt;`, `IAsyncOperation&lt;&gt;`, and `IAsyncOperationWithProgress&lt;&gt;`.

The lines that are generating these errors are places that we are awaiting a custom object that contains a Task&lt;bool&gt;.  That object has a `GetAwaiter` extension method that returns a TaskAwaiter&lt;bool&gt; - obtained from the contained Task&lt;bool&gt;.

The project's in question have Sdk="Microsoft.NET.Sdk.WindowsDesktop", and UseWpf and UseWindowsForms set to 'true'.

I've tried reproducing these build errors in a smaller application, but I haven't had any luck yet.  I'll keep trying to reproduce, but in the meantime, does anyone have any ideas?</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41401</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json Headers</Title>
    <Description>I'm switching to System.Text.Json from Json.Net, and the following is no longer serializable:
`Microsoft.AspNetCore.Http.FormFile`

The exception is:
```
System.NotSupportedException : The collection type 'Microsoft.AspNetCore.Http.IHeaderDictionary' on 'Microsoft.AspNetCore.Http.FormFile.Headers' is not supported.`
```

Will this be supported? Are there any workarounds?</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41399</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json ModelStateDictionary</Title>
    <Description>I'm switching to System.Text.Json from Json.Net, and the following is no longer serializable:
`Microsoft.AspNetCore.Mvc.ModelBinding.ModelStateDictionary`.

The exception is:
```
System.InvalidCastException : Unable to cast object of type 'Enumerator' to type 'System.Collections.IDictionaryEnumerator'.
   at System.Text.Json.JsonSerializer.HandleDictionary(JsonClassInfo elementClassInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack&amp; state)
   at System.Text.Json.JsonSerializer.HandleObject(JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack&amp; state)
   at System.Text.Json.JsonSerializer.WriteObject(JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack&amp; state)
   at System.Text.Json.JsonSerializer.Write(Utf8JsonWriter writer, Int32 originalWriterDepth, Int32 flushThreshold, JsonSerializerOptions options, WriteStack&amp; state)
   at System.Text.Json.JsonSerializer.WriteAsyncCore(Stream utf8Json, Object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
   at 
```

Will this be supported? Are there any workarounds?</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41398</IssueID>
    <RepoID>1</RepoID>
    <Title>Generate Json serializers at build time to reduce startup time</Title>
    <Description>The generation of Json serializers via reflection at runtime has non-trivial startup costs. This has been identified as a bottleneck during prototyping of fast small cloud-first micro-services: 

Repro: https://gist.github.com/jkotas/b0671e154791e287c38a627ca81d7197

The Json serializer generated using reflection at runtime has startup cost ~30ms. The manually written Json serializer has startup cost ~1ms.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41397</IssueID>
    <RepoID>1</RepoID>
    <Title>Add CentOS 8 runtime ids</Title>
    <Description>CentOS 8 has been released:
https://wiki.centos.org/Manuals/ReleaseNotes/CentOSLinux8

    $ cat /etc/os-release
    NAME="CentOS Linux"
    VERSION="8 (Core)"
    ID="centos"
    ID_LIKE="rhel fedora"
    VERSION_ID="8"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="CentOS Linux 8 (Core)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:centos:centos:8"
    HOME_URL="https://www.centos.org/"
    BUG_REPORT_URL="https://bugs.centos.org/"
    CENTOS_MANTISBT_PROJECT="CentOS-8"
    CENTOS_MANTISBT_PROJECT_VERSION="8"
    REDHAT_SUPPORT_PRODUCT="centos"
    REDHAT_SUPPORT_PRODUCT_VERSION="8"</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41396</IssueID>
    <RepoID>1</RepoID>
    <Title>Out of bounds error with CryptoStream.Write using FromBase64Transform</Title>
    <Description>The following code worked fine in .net framework 4.7.1, but in .net core 2.1/2.2/3.0 throws an ArgumentException `Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection` on the `CryptoStream.Write` method.

 ```csharp
public byte[] DecryptBase64(byte[] data)
{
      FromBase64Transform tBase64 = new FromBase64Transform();
      MemoryStream streamDecrypted = new MemoryStream();
      CryptoStream stream = new CryptoStream(streamDecrypted, tBase64, CryptoStreamMode.Write);

      stream.Write(data, 0, data.Length);
      stream.FlushFinalBlock();
      stream.Close();

      return streamDecrypted.ToArray();
}
```
The  `data` param has 2316 elements (0-2315), the offset is 0 and length is 2316. It does not make any sense to me an out of bounds error when calling  `stream.Write(data, 0, data.Length)`.

This issue seems to be related to #24033 and #23311, the problem for my team is that we can't make use of the `DES.Create()` workaround because, as you can see, we are using `FromBase64Transform`</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41394</IssueID>
    <RepoID>1</RepoID>
    <Title>Test demonstrating that on disposing HttpClient affects outgoing stream</Title>
    <Description>This PR demonstrates a unexpected behavior of HttpClient which I ran into while working on #15460 . I'm not sure if these are real bugs in HttpClient behavior or just nuances of our test framework (meaning, no prod scenarios affected), so, as we discussed previously, I created this PR which reliably reproduces issues found to get feedback from all the corefx contributors and decide if there any bugs to be fixed or not.

**Important.** All investigations were done **only for HTTP 1.1** by running 2 tests: SocketsHttpHandler_HttpClientHandler_Finalization_Http11_Test.ClientNotDisposed_ServerReadsFromStream_ServerHangs and SocketsHttpHandler_HttpClientHandler_Finalization_Http11_Test.ClientNotDisposed_ClientSendsSecondRequest_ClientHangs

Specifically, the issues I found are:

1. Disposing HttpClient affects the pooled connection the last request was made on. It's demonstrated in the test ClientNotDisposed_ServerReadsFromStream_ServerHangs where the server waits to read a next byte from the stream and this operation gets cancelled when HttpClient gets disposed, not when the read operation timeout is reached. I would expect that HttpClient always return a connection to the pool after an HTTP request completes, so disposing it should not affect the connection in any way.

2. Making a second request to the LoopbackServer on the same HttpClient hangs indefinitely despite the fact I closed the first response stream. It's demonstrated in the test ClientNotDisposed_ClientSendsSecondRequest_ClientHangs. If I understand this correctly, when I make the second GetStreamAsync call a connection should be retrieved from the pool regardless of whether or not the first one is closed, and the request should be sent to the server again, however the second request never reaches the server.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41393</IssueID>
    <RepoID>1</RepoID>
    <Title>Nuget update of System.Composition V1.3.0 breaks the code</Title>
    <Description>Hi, 
I have issues when updating to the latest packages.

I updated Nuget packages to the latest version of System.Component. 

When updating System.Composition to version 1.3.0 I get an error in code that the "CompositionContext" is not in the correct assembly. 

This is the error:             
&gt; Error CS0012: The type 'CompositionContext' is defined in an assembly that is not referenced. You must add a reference to assembly 'System.Composition.Runtime, Version=1.0.31.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. 

This is the line of code which fails:

`MefHostServices compositionHost = MefHostServices.Create(assemblies);`

When I set the revision to 1.2.0, the error is no longer there but the I get runtime errors of "TypeLoadException" for immutableCollection. 
Like mentioned all packages (including immutableCollection) is set to the latest revision.

All Microsoft and System references are controlled using Nuget.
I run "Get-Project –All | Add-BindingRedirect" in nuget package manager console to update binding redirects.

Any idea on what is wrong ? 

Kind regards
Bram</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41392</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190927.1
- **Date Produced**: 9/27/2019 10:07 AM
- **Commit**: 7e3c99a9229d29443b94770de5628f066bfa17fa
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19477.1
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19477.1
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19477.1

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190926.10
- **Date Produced**: 9/27/2019 5:59 AM
- **Commit**: 296c0e71ddcc4885d30af18dea829c1923cfdc5c
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19476.10
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19476.10

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190926.1
- **Date Produced**: 9/26/2019 12:54 PM
- **Commit**: 2a3116f8dade5c20f7b28cf175432def433f28ff
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19476.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41391</IssueID>
    <RepoID>1</RepoID>
    <Title>Bring System.Speech to .Net Core or add some alternative</Title>
    <Description>System.Speech API is not available in .Net Core or .Net standard. Currently, there are no alternatives for synthesizing audio locally in these frameworks. Kindly bring an API for this.

I am trying to migrate a [project ](https://github.com/vishnuprasadv/CaptchaGen) from .Net Framework to .Net Core but this is preventing it.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41390</IssueID>
    <RepoID>1</RepoID>
    <Title>Failing to create NuGet lib packages running clean build</Title>
    <Description>```cs
Error when creating nuget lib package from C:\Users\gotos\source\repos\corefx2\artifacts\packages\Debug\specs\Microsoft.NETCore.Targets.nuspec. System.ArgumentOutOfRangeException: The DateTimeOffset specified cannot be converted into a Zip file timestamp. (Parameter 'value') [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
   at System.IO.Compression.ZipArchiveEntry.set_LastWriteTime(DateTimeOffset value) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
   at NuGet.Packaging.PackageBuilder.CreatePart(ZipArchive package, String path, Stream sourceStream, DateTimeOffset lastWriteTime) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
   at NuGet.Packaging.PackageBuilder.WriteFiles(ZipArchive package, HashSet`1 filesWithoutExtensions) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
   at NuGet.Packaging.PackageBuilder.Save(Stream stream) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
   at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Pack(String nuspecPath, String nupkgPath, Manifest manifest, Boolean packSymbols) in /_/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetPack.cs:line 297 [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Targets\Microsoft.NETCore.Targets.pkgproj]
Error when creating nuget lib package from C:\Users\gotos\source\repos\corefx2\artifacts\packages\Debug\specs\Microsoft.NETCore.Platforms.nuspec. System.ArgumentOutOfRangeException: The DateTimeOffset specified cannot be converted into a Zip file timestamp. (Parameter 'value') [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
   at System.IO.Compression.ZipArchiveEntry.set_LastWriteTime(DateTimeOffset value) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
   at NuGet.Packaging.PackageBuilder.CreatePart(ZipArchive package, String path, Stream sourceStream, DateTimeOffset lastWriteTime) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
   at NuGet.Packaging.PackageBuilder.WriteFiles(ZipArchive package, HashSet`1 filesWithoutExtensions) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
   at NuGet.Packaging.PackageBuilder.Save(Stream stream) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
   at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Pack(String nuspecPath, String nupkgPath, Manifest manifest, Boolean packSymbols) in /_/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetPack.cs:line 297 [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms\Microsoft.NETCore.Platforms.pkgproj]
Error when creating nuget lib package from C:\Users\gotos\source\repos\corefx2\artifacts\packages\Debug\specs\Microsoft.NETCore.Platforms.Future.nuspec. System.ArgumentOutOfRangeException: The DateTimeOffset specified cannot be converted into a Zip file timestamp. (Parameter 'value') [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
   at System.IO.Compression.ZipArchiveEntry.set_LastWriteTime(DateTimeOffset value) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
   at NuGet.Packaging.PackageBuilder.CreatePart(ZipArchive package, String path, Stream sourceStream, DateTimeOffset lastWriteTime) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
   at NuGet.Packaging.PackageBuilder.WriteFiles(ZipArchive package, HashSet`1 filesWithoutExtensions) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
   at NuGet.Packaging.PackageBuilder.Save(Stream stream) [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
   at Microsoft.DotNet.Build.Tasks.Packaging.NuGetPack.Pack(String nuspecPath, String nupkgPath, Manifest manifest, Boolean packSymbols) in /_/src/Microsoft.DotNet.Build.Tasks.Packaging/src/NuGetPack.cs:line 297 [C:\Users\gotos\source\repos\corefx2\pkg\Microsoft.NETCore.Platforms.Future\Microsoft.NETCore.Platforms.Future.pkgproj]
```
Running on Windows 10 Pro Insider Edition (18990) Korean, x64. Ran `build` on the VS2019 preview CMD (Currently have VS Community edition 16.4 P1 installed), clean clone from the latest state of the master branch (@ https://github.com/dotnet/corefx/commit/296c0e71ddcc4885d30af18dea829c1923cfdc5c). I can send the binlog file if anyone wants it (can't upload due to size limit).

</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41389</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @tannergooding</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41388</IssueID>
    <RepoID>1</RepoID>
    <Title>System.DateTimeOffset Property - StartTimeOfDay</Title>
    <Description>I would like to propose a new `StartTimeOfDay` property that contribute for readability.


e.g.
```
private static void Main()
{
    var now = DateTimeOffset.Now;
    var midnight = now - now.TimeOfDay;
}
```
to
```
private static void Main()
{
    var midnight = DateTimeOffset.Now.StartTimeOfDay;
}
```

I don't want to make extention methods in 'DateUtil' class.</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41387</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190926.6
- **Date Produced**: 9/27/2019 1:21 AM
- **Commit**: b449f372df1a3374ebdc85f42ff137dcda08776b
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19476.6
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19476.6
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19476.6

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41386</IssueID>
    <RepoID>1</RepoID>
    <Title>Add some DebuggerDisplay attributes in System.Linq</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/22520

e.g.
before:
![image](https://user-images.githubusercontent.com/2642209/65766318-a36f4380-e0f8-11e9-978c-f47f2c42139d.png)

after:
![image](https://user-images.githubusercontent.com/2642209/65766268-820e5780-e0f8-11e9-8856-9bdedad93d7f.png)
</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41385</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Security.Principal.Windows different versions lib vs ref</Title>
    <Description>I'm using the latest 4.6.0 version of the package and noticed after a while that the assembly version for netstandard2.0 in lib is **4.1.2.0** while in ref, for the same framework it is **4.1.1.0**.

This is causing problems at runtime because the build numbers are different. I tried using **bindingRedirect**  in the meanwhile but I couldn't get it to work so far.

The error at runtime:

`=== Pre-bind state information ===
LOG: DisplayName = System.Security.Principal.Windows, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
 (Fully-specified)`

`LOG: Assembly Name is: System.Security.Principal.Windows, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
WRN: Comparing the assembly name resulted in the mismatch: Build Number
ERR: The assembly reference did not match the assembly definition found.
ERR: Run-from-source setup phase failed with hr = 0x80131040.
ERR: Failed to complete setup of assembly (hr = 0x80131040). Probing terminated.`
</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41384</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json.JsonNamingPolicy Deafult</Title>
    <Description>Developers need to be able to use it pass through PascalCase
```
    public abstract partial class JsonNamingPolicy
    {
        protected JsonNamingPolicy() { }
        public static System.Text.Json.JsonNamingPolicy CamelCase { get { throw null; } }
        public static System.Text.Json.JsonNamingPolicy SnakeCase { get { throw null; } }
/// &lt;summary&gt;
/// Property names are not changed
/// &lt;/summary&gt;
public static System.Text.Json.JsonNamingPolicy Deafult{ get { throw null; } }
```

_Originally posted by @VassilAtanasov in https://github.com/dotnet/corefx/pull/41354_</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41383</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonNamingPolicy.Default internal property should be made public</Title>
    <Description>Why this is internal? Developers need to be able to use it pass through PascalCase

_Originally posted by @VassilAtanasov in https://github.com/dotnet/corefx/pull/41354_</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41382</IssueID>
    <RepoID>1</RepoID>
    <Title>The type name 'SqlConnection' could not be found in the namespace 'System.Data.SqlClient'</Title>
    <Description>Hi,

Why this happens? Should I install another package instead of `System.Data.SqlClient`?</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41381</IssueID>
    <RepoID>1</RepoID>
    <Title>How can I use Microsoft.AspNetCore.Mvc.Internal.ActionSelector in ASP.NET Core 3.0/.NET Core 3.0 or alternative solution in Core 3.0? </Title>
    <Description>reference MSDN:

https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.internal.actionselector?view=aspnetcore-2.2

c# code in .NET Core 2.2, for your reference:

https://github.com/Microshaoft/Microshaoft.Common.Utilities.Net.4x/blob/aace0a952433f09d24d5977ad7fae7adf40a18d4/CommonUtilities.Shared/WebApi.Common.Controllers/SyncAsyncActionSelector.cs#L8</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41380</IssueID>
    <RepoID>1</RepoID>
    <Title>TimeSpan precision was affected by core 3.0 release</Title>
    <Description>Hi, there is a pull request https://github.com/dotnet/coreclr/pull/24279 which was merged to core 3.0. 

It removes an additional sum in TimeSpan.Interval method (`value &gt;= 0 ? 0.5 : -0.5`) with comment in the description 
&gt;This line was added because casting double to long was dropping the decimal part and we expect it to rounded off. This wont be the case anymore.

But, actually, it's still the case, because in the next line we have casting to long (`new TimeSpan((long)ticks)`). So, after upgrading to dotnet core 3.0, some TimeSpan conversions became slightly incorrect (i.e. the precision was actually decreased). For instance, you can use the following simple example and check it before and after that pull request:

```
var ts = TimeSpan.FromMilliseconds(34967800);
var ts2 = TimeSpan.FromSeconds(ts.TotalSeconds);
Assert.Equal(ts, ts2);
```</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41379</IssueID>
    <RepoID>1</RepoID>
    <Title>Is there any special reason to not providing an interface or abstraction of HttpClient?</Title>
    <Description># Is there any special reason to not providing an interface or abstraction of HttpClient?

Although, it is possible to register dependency with HttpClient concrete class but what if I want to mock its implementation. I can define my own interface with all given methods in HttpClient class but this approach is not much appealing. Do you have any plan to provide its interface or abstraction in future? Or, there is any special reason to keep it concrete?
</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41378</IssueID>
    <RepoID>1</RepoID>
    <Title>ASP.NET Core 3.0 doesn't stream IAsyncEnumerable&lt;T&gt; as chunk of data</Title>
    <Description>I start the sample project with ASP.NET Core 3.0 API and implement the Route like

``` CSharp
    [ApiController]
    [Route("[controller]")]
    public class WeatherForecastController : ControllerBase
    {
        private static readonly string[] Summaries = new[]
        {
            "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
        };

        private readonly ILogger&lt;WeatherForecastController&gt; _logger;

        public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)
        {
            _logger = logger;
        }

        [HttpGet]
        public async IAsyncEnumerable&lt;WeatherForecast&gt; Get()
        {
            var rng = new Random();
            for (var index = 0; index &lt; 10; ++index)
            {
                yield return new WeatherForecast
                {
                    Date = DateTime.Now.AddDays(index),
                    TemperatureC = rng.Next(-20, 55),
                    Summary = Summaries[rng.Next(Summaries.Length)]
                };
                await Task.Delay(2000).ConfigureAwait(false);
            }
        }
    }
```

The hit the F5 in VS 2019. On browser http://localhost:53237/weatherforecast I need to wait after the 20s then receive the full JSON array. I found on headers response include Content-Length: &lt;number&gt;
I expect ASP.NET Core should return in-stream JSON item continuously instead wait to full buffer then return the whole large JSON. 

Is there any configuration to enable to allow stream data chunk to the client immediately without blocking and wait?


</Description>
    <CreatedDate>27/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41377</IssueID>
    <RepoID>1</RepoID>
    <Title>Just for testing</Title>
    <Description>
    </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41376</IssueID>
    <RepoID>1</RepoID>
    <Title>Add support for reading/writing key files for explicit parameter ECC</Title>
    <Description>* Prime curves
  * ECPrivateKey
  * Pkcs8
  * EncryptedPkcs8
  * SubjectPublicKeyInfo
* Characteristic-2 curves
  * ECPrivateKey
  * Pkcs8
  * EncryptedPkcs8
  * SubjectPublicKeyInfo

This is a precursor to being able to use our own PFX reader/writer (#40539).  It's needed because existing tests load a PFX with an explicit-parameters EC key.

And, yes "c2pnb163v1" is really what that curve is called :smile:.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41375</IssueID>
    <RepoID>1</RepoID>
    <Title>Port test fixes from master into release/3.x</Title>
    <Description>cc @wfurt @stephentoub @davidsh @eiriktsarpalis</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41374</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json fails to deserialize an array of POCO's inside another POCO</Title>
    <Description>It appears that System.Text.Json.Deserialize does not properly handle an array of POCO's inside another POCO.

Build the following console application:
`
using Newtonsoft.Json;
using System;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello Json!");

            string json = "{\"pStatus\":0,\"pError\":\"\",\"pResult\":[{\"processIdentifier\":"
                + "\"ANES - 2019 - 9955\",\"associatedProcessIdentifier\":\"\",\"dashboard\":\" "
                + "| SPD_Version | 5 | SPD_AnesthesiaType | Choice | SPD_BloodProducts ||\"},"
                + "{\"processIdentifier\":\"ANES - 2019 - 9964\",\"associatedProcessIdentifier\":\"\","
                + "\"dashboard\":\" | SPD_Version | 5 | SPD_AnesthesiaType | Choice | SPD_BloodProducts ||\""
                + "}]}";

            var newton = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;ServiceResult&lt;Process_DD[]&gt;&gt;(json);

            var stjo = new System.Text.Json.JsonSerializerOptions();
            stjo.PropertyNameCaseInsensitive = true;
            var stj = System.Text.Json.JsonSerializer.Deserialize&lt;ServiceResult&lt;Process_DD[]&gt;&gt;(json, stjo);
        }
    }

    public class ServiceResult&lt;ServiceResultType&gt;
    {
        public enum eStatus { OK, Error };
        public eStatus pStatus { get; set; }
        public string pError { get; set; }
        public ServiceResultType pResult { get; set; }

        public ServiceResult() { }
        public ServiceResult(
            ServiceResultType p_Result,
            eStatus p_Status = eStatus.OK,
            string p_Error = "")
        {
            pStatus = p_Status;
            pError = p_Error;
            pResult = p_Result;
        }
    }

    public class Process_DD
    {
        public string ProcessIdentifier;
        public string AssociatedProcessIdentifier;
        public string Dashboard;

        public Process_DD()
        {
        }
        public Process_DD(string processIdentifier, string associatedProcessIdentifier, string dashboard)
        {
            this.ProcessIdentifier = processIdentifier;
            this.AssociatedProcessIdentifier = associatedProcessIdentifier;
            this.Dashboard = dashboard;
        }
    }

}
`
using the following csproj:
`
&amp;lt;Project Sdk="Microsoft.NET.Sdk"&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include="Newtonsoft.Json" Version="12.0.2" /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
`
Debug the program and step through both deserializations. Note that the Newtonsoft result has appropriate values for the two array elements of type Process_DD. The System.Text.Json result has null values for the properties.

C:\Users\ms&gt;dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100
 Commit:    04339c3a26

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100\

Host (useful for support):
  Version: 3.0.0
  Commit:  7d57652f33

.NET Core SDKs installed:
  2.1.802 [C:\Program Files\dotnet\sdk]
  2.2.402 [C:\Program Files\dotnet\sdk]
  3.0.100 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41373</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove a few initialization allocations from Cng</Title>
    <Description>Save four "startup" allocations in System.Security.Cryptography.Cng.

- Appending the '\0' is better done at the call site, because then the concat is done with two constants at compile time.
- There's no benefit to using ToCharArray instead of just passing in the string.
- Once we get rid of those, we can just inline the construction into the declarations.

cc: @bartonjs </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41372</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @ViktorHofer
* @mmitche
* @dotnet-maestro[bot]
* @Anipik
* @ahsonkhan
* @stephentoub
* @msftbot[bot]
* @danmosemsft
* @safern

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41371</IssueID>
    <RepoID>1</RepoID>
    <Title>Switch to Embedded Package Icons</Title>
    <Description>Once we move to the 3.0.100 SDK in our rel/3.0 branches, we'll start hitting NU5048. This is about moving from `PackageIconUrl` (a link in the nuspec to a URL where the package icon image lives), to an embedded image in the package itself. We need to react to this in CoreFx once we update the SDK - see https://github.com/aspnet/Blazor/pull/1896 for an example PR.

CC @ericstj @Anipik @safern @ViktorHofer 

We should make sure somebody is doing this for CoreClr/Core-Setup/Standard as well</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41370</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable S.N.Security tests on arm64 Windows</Title>
    <Description>Disabling the `System.Net.Security.Tests` workitem on arm64 on Windows until the arm64 queue is updated: https://github.com/dotnet/core-eng/issues/5118. This is achieved by removing all sources from the test assembly.

cc @safern </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41368</IssueID>
    <RepoID>1</RepoID>
    <Title>corefx is not getting indexed by source.dot.net</Title>
    <Description>cc: @ahsonkhan, @alexperovich </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41367</IssueID>
    <RepoID>1</RepoID>
    <Title>Make Delegate.GetMethodInfo extension return non-nullable</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41346
cc: @safern</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41366</IssueID>
    <RepoID>1</RepoID>
    <Title>GetAsync_ExpectContinueTrue_NoContent_StillSendsHeader failing in CI</Title>
    <Description>https://dnceng.visualstudio.com/public/_build/results?buildId=366818&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11098392&amp;resultId=100001&amp;paneView=attachments

Configuration: `netcoreapp-Windows_NT-Release-arm64-Windows.10.Arm64.Open`

```
System.Net.Http.Functional.Tests.SocketsHttpHandlerTest_HttpClientHandlerTest_Http2.GetAsync_ExpectContinueTrue_NoContent_StillSendsHeader [FAIL]
      System.TimeoutException : Task timed out after 00:01:00
      Stack Trace:
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(44,0): at System.Threading.Tasks.TaskTimeoutExtensions.TimeoutAfter(Task task, TimeSpan timeout)
        /_/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.cs(1939,0): at System.Net.Http.Functional.Tests.HttpClientHandlerTest.GetAsync_ExpectContinueTrue_NoContent_StillSendsHeader()
        --- End of stack trace from previous location where exception was thrown ---
```

@geoffkizer, @wfurt, @davidsh, @scalablecory, @eiriktsarpalis, @karelz</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41363</IssueID>
    <RepoID>1</RepoID>
    <Title>Avoid ToCharArray allocation in JsonCamelCaseNamingPolicy</Title>
    <Description>Microbenchmark calling ConvertName with either "PascalCase" or "camelCased":
```
| Method |       Text |      Mean |     Error |    StdDev |  Gen 0 | Gen 1 | Gen 2 | Allocated |
|------- |----------- |----------:|----------:|----------:|-------:|------:|------:|----------:|
|    Old | PascalCase | 35.724 ns | 1.3263 ns | 3.7410 ns | 0.0458 |     - |     - |      96 B |
|    New | PascalCase | 26.932 ns | 0.7734 ns | 2.2683 ns | 0.0229 |     - |     - |      48 B |
|    Old | camelCased |  3.323 ns | 0.1484 ns | 0.4211 ns |      - |     - |     - |         - |
|    New | camelCased |  2.685 ns | 0.1435 ns | 0.4186 ns |      - |     - |     - |         - |
```
cc: @steveharter, @ahsonkhan </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41361</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Net.Sockets.Tests.IPPacketInformationTest.Equals_NonDefaultValue_Success failing in CI</Title>
    <Description>https://dnceng.visualstudio.com/public/_build/results?buildId=366911&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=11102506&amp;paneView=debug

Configuration: `netcoreapp-Linux-Release-x64-Debian.9.Amd64.Open`

```
System.Net.Sockets.Tests.IPPacketInformationTest.Equals_NonDefaultValue_Success

Assert.True() Failure\nExpected: True\nActual: False

 at System.Net.Sockets.Tests.IPPacketInformationTest.GetNonDefaultIPPacketInformation() in /_/src/System.Net.Sockets/tests/FunctionalTests/IPPacketInformationTest.cs:line 74
   at System.Net.Sockets.Tests.IPPacketInformationTest.Equals_NonDefaultValue_Success() in /_/src/System.Net.Sockets/tests/FunctionalTests/IPPacketInformationTest.cs:line 30
```

@davidsh, @wfurt, @scalablecory, @eiriktsarpalis, @karelz</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41360</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Disable XML crypto test failing on Windows 10</Title>
    <Description>Disabling an RSAES-PKCS#1-based test failing due to an OS issue (tracked by #40759).

Port of #40775.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41359</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable Git LFS and merge the corefx-testdata repo with corefx</Title>
    <Description>From my conversation with @ericstj, the steps would be:

- Make corefx-testdata adopt arcade.
- Create a rolling build.
- Have corefx subscribe to the output of that build.

cc @safern @joperezr @ViktorHofer @Anipik </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41358</IssueID>
    <RepoID>1</RepoID>
    <Title>Add serializer support for IAsyncEnumerable</Title>
    <Description>This is a placeholder to uptake the recent `IAsyncEnumerable` feature for the serializer.

This includes creating an enumerator class that that implements `IAsyncEnumerable` and accepts a `Stream` in its constructor (and others TBD) that contains the actual JSON which can be accessed asynchronously:

```cs
public class SerializerAsyncEnumerable&lt;T&gt; : IAsyncEnumerable&lt;T&gt;
{
    public SerializerAsyncEnumerable(Stream stream);
    public SerializerAsyncEnumerable(Stream stream, JsonSerializerOptions options);
...
}
```

and also likely exposed from the `JsonSerializer` static class:
```cs
public static class JsonSerializer
{
...
    public SerializerAsyncEnumerable&lt;T&gt; DeserializeEnumerableAsync(Stream stream);
    public SerializerAsyncEnumerable&lt;T&gt; DeserializeEnumerableAsync(Stream stream, JsonSerializerOptions options);
...
}
```

The implementation will leverage the same patterns as in the existing async methods which preserve the unprocessed data from the stream (since the stream just returns raw JSON which won't align with object instances) and the "state" for continuing object deserialization as new JSON is obtained.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41357</IssueID>
    <RepoID>1</RepoID>
    <Title>SslStreamStreamToStreamTest_BeginEnd tests failing due to timeout</Title>
    <Description>Saw these failures on rolling build.

https://helix.dot.net/api/2019-06-17/jobs/e8cca62d-7a69-413d-880a-7ece3f93d213/workitems/System.Net.Security.Tests/console

&lt;details&gt;&lt;summary&gt;Detail&lt;/summary&gt;
&lt;p&gt;

```
    System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.SslStream_StreamToStream_LargeWrites_Success(randomizedData: True) [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)) (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.))
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      Stack Trace:
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(109,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(71,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(808,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.&lt;&gt;c__DisplayClass0_0.&lt;&lt;DoHandshake&gt;b__0&gt;d.MoveNext()
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(42,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.WithServerCertificate(X509Certificate serverCertificate, Func`3 func)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(804,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.DoHandshake(SslStream clientSslStream, SslStream serverSslStream, X509Certificate serverCertificate, X509Certificate clientCertificate)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(273,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.SslStream_StreamToStream_LargeWrites_Success(Boolean randomizedData)
        --- End of stack trace from previous location where exception was thrown ---
        ----- Inner Stack Trace #1 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(241,0): at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        ----- Inner Stack Trace #2 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(288,0): at System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(83,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
    System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.SslStream_StreamToStream_WriteAsync_ReadByte_Success [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)) (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.))
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      Stack Trace:
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(109,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(71,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(808,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.&lt;&gt;c__DisplayClass0_0.&lt;&lt;DoHandshake&gt;b__0&gt;d.MoveNext()
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(42,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.WithServerCertificate(X509Certificate serverCertificate, Func`3 func)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(804,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.DoHandshake(SslStream clientSslStream, SslStream serverSslStream, X509Certificate serverCertificate, X509Certificate clientCertificate)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(381,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.SslStream_StreamToStream_WriteAsync_ReadByte_Success()
        --- End of stack trace from previous location where exception was thrown ---
        ----- Inner Stack Trace #1 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(241,0): at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        ----- Inner Stack Trace #2 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(288,0): at System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(83,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
    System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.SslStream_StreamToStream_Dispose_Throws [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)) (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.))
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      Stack Trace:
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(109,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(71,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(808,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.&lt;&gt;c__DisplayClass0_0.&lt;&lt;DoHandshake&gt;b__0&gt;d.MoveNext()
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(42,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.WithServerCertificate(X509Certificate serverCertificate, Func`3 func)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(804,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.DoHandshake(SslStream clientSslStream, SslStream serverSslStream, X509Certificate serverCertificate, X509Certificate clientCertificate)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(506,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.SslStream_StreamToStream_Dispose_Throws()
        --- End of stack trace from previous location where exception was thrown ---
        ----- Inner Stack Trace #1 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(241,0): at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        ----- Inner Stack Trace #2 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(288,0): at System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(83,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
    System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.SslStream_StreamToStream_Write_ReadByte_Success [FAIL]
      System.AggregateException : One or more errors occurred. (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)) (One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.))
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      ---- System.AggregateException : One or more errors occurred. (VirtualNetwork: Timeout reading the next frame.)
      -------- System.TimeoutException : VirtualNetwork: Timeout reading the next frame.
      Stack Trace:
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(109,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(71,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks, Int32 millisecondsTimeout)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(808,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.&lt;&gt;c__DisplayClass0_0.&lt;&lt;DoHandshake&gt;b__0&gt;d.MoveNext()
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(42,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.WithServerCertificate(X509Certificate serverCertificate, Func`3 func)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(804,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest_BeginEnd.DoHandshake(SslStream clientSslStream, SslStream serverSslStream, X509Certificate serverCertificate, X509Certificate clientCertificate)
        /_/src/System.Net.Security/tests/FunctionalTests/SslStreamStreamToStreamTest.cs(358,0): at System.Net.Security.Tests.SslStreamStreamToStreamTest.SslStream_StreamToStream_Write_ReadByte_Success()
        --- End of stack trace from previous location where exception was thrown ---
        ----- Inner Stack Trace #1 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(241,0): at System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        ----- Inner Stack Trace #2 (System.AggregateException) -----
        
        ----- Inner Stack Trace -----
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetwork.cs(61,0): at System.Net.Test.Common.VirtualNetwork.ReadFrameCoreAsync(Boolean server, Boolean sync, CancellationToken cancellationToken)
        /_/src/Common/tests/System/Net/VirtualNetwork/VirtualNetworkStream.cs(101,0): at System.Net.Test.Common.VirtualNetworkStream.ReadAsync(Byte[] buffer, Int32 offset, Int32 count, CancellationToken cancellationToken)
        /_/src/System.Net.Security/src/System/Net/FixedSizeReader.cs(57,0): at System.Net.FixedSizeReader.ReadPacketAsync(Stream transport, AsyncProtocolRequest request)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(843,0): at System.Net.Security.SslStream.&lt;ThrowIfExceptional&gt;g__ThrowExceptional|141_0(ExceptionDispatchInfo e)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(437,0): at System.Net.Security.SslStream.InternalEndProcessAuthentication(LazyAsyncResult lazyResult)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.Implementation.cs(407,0): at System.Net.Security.SslStream.EndProcessAuthentication(IAsyncResult result)
        /_/src/System.Net.Security/src/System/Net/Security/SslStream.cs(288,0): at System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult asyncResult)
        /_/src/System.Private.CoreLib/shared/System/Threading/Tasks/FutureFactory.cs(546,0): at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic(IAsyncResult iar, Func`2 endFunction, Action`1 endAction, Task`1 promise, Boolean requiresSynchronization)
        --- End of stack trace from previous location where exception was thrown ---
        /_/src/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs(83,0): at System.Threading.Tasks.TaskTimeoutExtensions.WhenAllOrAnyFailed(Task[] tasks)
  Finished:    System.Net.Security.Tests
```
&lt;/p&gt;
&lt;/details&gt;

Looks like we could use some retry logic here.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41356</IssueID>
    <RepoID>1</RepoID>
    <Title>When CurrentCulture is "fr-FR" , double.TryParse("0.0000", out double d) return false.</Title>
    <Description>In .net framework 4.0, .net framework 4.6, .net core 2.1 and .net core 3.0 throw exception.

       static void Main(string[] args)
        {
            Thread.CurrentThread.CurrentCulture = new CultureInfo("fr-FR");
            //Thread.CurrentThread.CurrentUICulture = new CultureInfo("fr-FR");

            if (double.TryParse("0.0000", out double d) == false) {
                throw new Exception("double.TryParse(\"0.0000\",out double d) is Error.");
            }

            Console.WriteLine("double.TryParse(\"0.0000\",out double d) is OK.");
        }</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41355</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Alpine 3.10 to CI</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41037

Current OS support matrix doc: https://github.com/dotnet/core/blob/master/release-notes/3.0/3.0-supported-os.md

cc @MattGal @mthalman</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41354</IssueID>
    <RepoID>1</RepoID>
    <Title>Added snake case naming policy to the JSON serializer</Title>
    <Description>Fixes #39564. The code is written some time ago for our ADO.NET driver for PostgreSQL where snake case is the common and default naming style.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41362</IssueID>
    <RepoID>1</RepoID>
    <Title>Dotnet-sdk error</Title>
    <Description>Problem encountered on https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/install
Operating System: Linux RHEL 7 - x64

Provide details about the problem you are experiencing. Include your operating system version, exact error message, code sample, and anything else that is relevant.

After following the instructions
mkdir -p $HOME/dotnet &amp;&amp; tar zxf dotnet-sdk-3.0.100-rhel.6-x64.tar.gz -C $HOME/dotnet
export DOTNET_ROOT=$HOME/dotnet
export PATH=$PATH:$HOME/dotnet

"dotnet new console -o myApp" and every dotnet command 

throws error

System.TypeInitializationException: The type initializer for 'Crypto' threw an exception.
 ---&gt; System.DllNotFoundException: Unable to load shared library 'System.Security.Cryptography.Native.OpenSsl' or one of its dependencies. In order to help diagnose loading problems, consider setting the LD_DEBUG environment variable: libSystem.Security.Cryptography.Native.OpenSsl: cannot open shared object file: No such file or directory
   at Interop.Crypto.GetMaxMdSize()
   at Interop.Crypto..cctor()
   --- End of inner exception stack trace ---
   at Interop.Crypto.EvpSha256()
   at Internal.Cryptography.HashProviderDispenser.CreateHashProvider(String hashAlgorithmId)
   at System.Security.Cryptography.SHA256.Implementation..ctor()
   at System.Security.Cryptography.SHA256.Create()
   at Microsoft.DotNet.Cli.Telemetry.Sha256Hasher.Hash(String text)
   at Microsoft.DotNet.Cli.Telemetry.TelemetryCommonProperties.GetTelemetryCommonProperties()
   at Microsoft.DotNet.Cli.Telemetry.Telemetry.InitializeTelemetry()


</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41353</IssueID>
    <RepoID>1</RepoID>
    <Title>add more IsSuffix test cases</Title>
    <Description>this time I want to add the tests before I start improving EndsWith ;)</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41352</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190925.24
- **Date Produced**: 9/26/2019 7:03 AM
- **Commit**: d0160877a2485212c80f3bc2a2ded2d3719e1d28
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19475.24
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19475.24
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19475.24

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190926.1
- **Date Produced**: 9/26/2019 9:11 AM
- **Commit**: 0a1850cc370986c7348e09bcd1c1adcf522d6db3
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19476.1
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19476.1

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41351</IssueID>
    <RepoID>1</RepoID>
    <Title>string.Compare function does not work when deployed to linux (.Net Version 2.0)</Title>
    <Description>Issue moved from here: https://github.com/aspnet/AspNetCore/issues/14461#event-2664828155
on advice of javiercn 

If you create a .Net Api project on a windows pc then use the following commands:

dotnet restore -r ubuntu.16.04-x64
dotnet build -r ubuntu.16.04-x64
dotnet publish -f netcoreapp2.0 -c Release -r ubuntu.16.04-x64

Then publish onto Ubuntu

Then do:
string myValue = "False";
var resultA = string.Compare(myValue , "false", false);
var resultB = string.Compare(myValue , "false", true);
Both resultA and resultB are equal to -1

I have a work around so this is for information only, so close the bug whenever you want to.
I have not yet got round to upgrading to ,Net Version 3, so I don't know if it is still an issue.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41527</IssueID>
    <RepoID>1</RepoID>
    <Title>System Drawing image.fromstream parameter is not valid (HEIC File)</Title>
    <Description># Issue Title

System Drawing image.fromstream parameter is not valid

# General

When attempting to convert a heic file into an image, I'm getting "parameter is not valid" error.

Entire method is below. Error is thrown on :  ` var sourceImage = System.Drawing.Image.FromStream(await file.GetFileStream());`

```c#
public async Task&lt;SaveResultDto&lt;string&gt;&gt; ExecuteAsync(int contractId, int companyId, string userId, int imageTypeId, IEnumerable&lt;IFormFile&gt; files)
        {
            using (var unitOfWork = _unitOfWorkFactory.CreateTransactional())
            {
                var result = new SaveResultDto&lt;string&gt;();
                try
                {
                    var newBlobName = "";
                    var company = await unitOfWork.CompanyRepository.FindByIdAsync(companyId);
                    if (company == null)
                        throw new UnauthorizedAccessException();

                    var containerName = company.SubDomain.ToLower();

                    //create a file for each form file
                    foreach (var file in files)
                    {
                        var sourceImage = System.Drawing.Image.FromStream(await file.GetFileStream());
                        sourceImage.ExifRotate();

                        var entity = new Data.Models.ContractImage();

                        newBlobName = $"{Guid.NewGuid()}.{Path.GetExtension(file.FileName)}";

                        var newFileStream = new MemoryStream();
                        sourceImage.Save(newFileStream, ImageFormat.Jpeg);
                        sourceImage.Dispose();
                        await unitOfWork.BlobRepository.CreateAsync(new Blob
                        {
                            ContainerId = containerName,
                            Id = newBlobName,
                            Content = newFileStream.ToArray()
                        });
                        
                        entity.BlobName = newBlobName;
                        entity.FileName = file.FileName;
                        entity.ContentType = string.IsNullOrEmpty(file.ContentType) ? MimeTypes.GetMimeType(file.FileName) : file.ContentType;
                        entity.Company = company;
                        entity.ImageTypeId = imageTypeId;
                        entity.ContractId = contractId;

                        await unitOfWork.ContractImageRepository.CreateAsync(entity);
                    }

                    await unitOfWork.SaveChangesAsync();
                    unitOfWork.CommitTransaction();
                    result.Id = newBlobName;
                }
                catch(Exception ex)
                {
                    result.Id = "";
                    result.Errors.Add(ex.Message);
                }

                return result;
            }
        }
```</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41350</IssueID>
    <RepoID>1</RepoID>
    <Title>StartsWith more edge cases</Title>
    <Description>Test case for https://github.com/unicode-org/icu/pull/840 to make sure that ICU 65 solves the problem for good.

`"o\u0000\u0308".StartsWith("o")` to make sure https://github.com/dotnet/coreclr/pull/26621 does not break it</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41349</IssueID>
    <RepoID>1</RepoID>
    <Title>Issue regarding AddAuthenticationCore and cookies</Title>
    <Description>Before in my old code, I used to do:

```csharp
services
    .AddAuthentication(options =&gt;
    {
        options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;
        options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    })
    .AddCookie(options =&gt;
    {
        options.LoginPath = "/Admin/Account/Login";
    });
```

To get auth with cookies working. 

Now, after migrating to .NET Core 3 while still using the above code, my identity showed as never authenticated. I found something referring to something being moved around, and concluded I needed to use `AddAuthenticationCore`.

I couldn't find any documentation on how to get the same working with that, so I ended up with the following code:

```csharp
services.AddAuthenticationCore(options =&gt;
{
    options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;

    options.AddScheme&lt;CookieAuthenticationHandler&gt;(CookieAuthenticationDefaults.AuthenticationScheme, null);
});
```

But now I get the following error:

&gt; Unable to resolve service for type 'Microsoft.AspNetCore.Authentication.ISystemClock' while attempting to activate 'Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler'.

The reason I tried using this approach, is that `AddCookie` no longer exists with the new method approach.

What can I do to get this working?</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>28/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41348</IssueID>
    <RepoID>1</RepoID>
    <Title>Serialization issues with System.Text.Json in SignalR</Title>
    <Description>#### Original issue: 
aspnet/AspNetCore/issues/14422

Serialization of TimeZoneInfo.Local fails and results in an incorrect json when sending over SignalR.

The Client uses version 3.0.
The Server is built on .NET core 2.2. 

Client code:
`HubConnection.SendAsync("Initialize", DateTime.UtcNow, TimeZoneInfo.Local);`

Server code:
`[public async Task Initialize(DateTime clientTimeInUTC, TimeZoneInfo clientTimeZone) { .. }]`

### Expected  behavior
How the TimeZoneInfo should be parsed, and is parsed if I use NewtonSoft serializer directly.
```
{
  "id": "W. Europe Standard Time",
  "displayName": "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
  "standardName": "W. Europe Standard Time",
  "daylightName": "W. Europe Daylight Time",
  "baseUtcOffset": {
    "ticks": 36000000000,
    "days": 0,
    "hours": 1,
    "milliseconds": 0,
    "minutes": 0,
    "seconds": 0,
    "totalDays": 0.041666666666666664,
    "totalHours": 1,
    "totalMilliseconds": 3600000,
    "totalMinutes": 60,
    "totalSeconds": 3600
  },
  "supportsDaylightSavingTime": true
}
```

### Actual behavior
How it is sent via SignalR.  You can see an extra curly bracket on line 1 in the JSON. These are ONLY added if I sent through signalR. If I serialize TimeZoneInfo using NewtonSoft in either the server or the client, this works perfect and gives the json listed above. 
```
{{
  "id": "W. Europe Standard Time",
  "displayName": "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
  "standardName": "W. Europe Standard Time",
  "daylightName": "W. Europe Daylight Time",
  "baseUtcOffset": {
    "ticks": 36000000000,
    "days": 0,
    "hours": 1,
    "milliseconds": 0,
    "minutes": 0,
    "seconds": 0,
    "totalDays": 0.041666666666666664,
    "totalHours": 1,
    "totalMilliseconds": 3600000,
    "totalMinutes": 60,
    "totalSeconds": 3600
  },
  "supportsDaylightSavingTime": true
}}
```

#### Exception
Exception message: _System.Runtime.Serialization.SerializationException: Member 'Id' was not found._
```
2019-09-25 10:41:37 Failed to invoke hub method '"Initialize"'.
System.IO.InvalidDataException: Error binding arguments. Make sure that the types of the provided values match the types of the hub method being invoked. ---&gt; System.Runtime.Serialization.SerializationException: Member 'Id' was not found.
   at System.Runtime.Serialization.SerializationInfo.GetElement(String name, Type&amp; foundType)
   at System.Runtime.Serialization.SerializationInfo.GetValue(String name, Type type)
   at System.TimeZoneInfo..ctor(SerializationInfo info, StreamingContext context)
   at lambda_method(Closure , Object[] )
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)
   at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType)
   at Microsoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.BindArguments(JsonTextReader reader, IReadOnlyList`1 paramTypes)
   --- End of inner exception stack trace ---
   at Microsoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.BindArguments(JsonTextReader reader, IReadOnlyList`1 paramTypes)
   at Microsoft.AspNetCore.SignalR.Protocol.JsonHubProtocol.ParseMessage(Utf8BufferTextReader textReader, IInvocationBinder binder)
```


#### Workaround
We've current added NewtonSoftJson to our HubConnection builder `.AddNewtonsoftJsonProtocol()` which solved the issue and everything is now working as before the update. 
[MSDN: switch to Newtonsoftjson](https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.0&amp;tabs=visual-studio#switch-to-newtonsoftjson)</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41347</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] serialize/deserialize any object</Title>
    <Description>I try to convert my Newtonsoft.Json code to System.Text.Json and I came along a problem.
I need to serialize/deserialize any object. I don't know the objects type at compile time.

With Newtonsoft.Json I did this:

	JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings() { TypeNameHandling = TypeNameHandling.All };

    // serialize
    object value = GetSomeObject();
    string json = JsonConvert.SerializeObject(value, jsonSerializerSettings);

    // deserialize
    object value = JsonConvert.DeserializeObject(json, jsonSerializerSettings);

The serialized json contained a "$type" with the full name of the type (namespace, classname, assemblyname).
With this info the deserializer knew what object to instantiate.

Is this also possible with System.Text.Json? How?
</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41346</IssueID>
    <RepoID>1</RepoID>
    <Title>Delegate.GetMethodInfo may return null?</Title>
    <Description>Why is the result of [`RuntimeReflectionExtensions.GetMethodInfo(this Delegate)`](https://github.com/dotnet/corefx/blame/0a1850cc370986c7348e09bcd1c1adcf522d6db3/src/System.Runtime/src/System/Reflection/RuntimeReflectionExtensions.cs#L103) marked as nullable? It only seems to touch the `Delegate.Method` property which is not nullable. If that's intended, could you please describe the reason in a comment?</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41345</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json fails to serialize Dictionary with int keys</Title>
    <Description>```
var dictionary = new Dictionary&lt;int, int&gt;()
            {
                [0] = 1
            };

 var serialized = System.Text.Json.JsonSerializer.Serialize(dictionary);
```

This simple serialization is handled well by the former default Newtonsoft json library by serializing the int key as string. On System.Text.Json is throws a not supported exception.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41344</IssueID>
    <RepoID>1</RepoID>
    <Title>Compile error in Visual Studio 2019</Title>
    <Description>I get the following error:

&gt; ETSDK1013	The TargetFramework value '' was not recognized. It may be misspelled. If not, then the TargetFrameworkIdentifier and/or TargetFrameworkVersion properties must be specified explicitly.	System.Text.Json (src\System.Text.Json)	C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.TargetFrameworkInference.targets

When trying to compile `System.Text.Json`.

I really want to contribute more, so this is a bummer.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41342</IssueID>
    <RepoID>1</RepoID>
    <Title>Optimize Enumerable.SkipLast() for IPartition and IList</Title>
    <Description>Enumerable.SkipLast() can be cast to Enumerable.Take() when source type is IPartition or IList.

performance test see #40014</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41341</IssueID>
    <RepoID>1</RepoID>
    <Title>Set IsShipping only for experimental and IsShippingPackages only for private packages</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/41315

We only need to set `IsShippingPackages` to false, when we're building a pkgproj and it's name contains, `Experimental` or `Private`. We set `IsShippingPackages=false` only for `Private` and `IsShipping=false` for `Experimental` because `Experimental` should cover both the package and assembly information to be non-stable.

cc: @dagood @mjsabby </Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41340</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @benaadams</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41339</IssueID>
    <RepoID>1</RepoID>
    <Title>SendAsync method of System.Net.Http.HttpClient behaves differently on .NET Framework and .NET Core for a response with Content-Location header</Title>
    <Description>Sample code to reproduce (ask for a response with **Content-Location** header):

```
            HttpClient httpClient = new HttpClient();
            HttpRequestMessage request = new HttpRequestMessage()
            {
                Method = HttpMethod.Post,
                RequestUri = new Uri("https://httpbin.org/response-headers?Content-Location=https%3A%2F%2Ffoo")
            };
            Console.WriteLine("before httpClient.SendAsync: " + request.RequestUri);
            var response = httpClient.SendAsync(request);
            response.Wait();
            Console.WriteLine("after httpClient.SendAsync: " + request.RequestUri);
```

On .NET Framework (4.6.1 or 4.8), output is:

```
before httpClient.SendAsync: https://httpbin.org/response-headers?Content-Location=https%3A%2F%2Ffoo
after httpClient.SendAsync: https://foo/
```

On .NET Core (2.1 or 2.2), output is:

```
before httpClient.SendAsync: https://httpbin.org/response-headers?Content-Location=https%3A%2F%2Ffoo
after httpClient.SendAsync: https://httpbin.org/response-headers?Content-Location=https%3A%2F%2Ffoo
```

In realworld we are using PUT, instead of POST as in sample code, anyway got same behaviour.

I am not sure which is the expected behaviour, but IMO SendAsync method should not modify input parameter, at least not for Content-Location in PUT/POST, which is not defined in RFC 2616.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41338</IssueID>
    <RepoID>1</RepoID>
    <Title>JSON Serialization Name Collision with hidden properties</Title>
    <Description>Take Two Classes:

```cs
public class ClassA
{
    public List&lt;int&gt; SomeList { get; set; }
}

public class ClassB : ClassA
{
    new public IEnumerable&lt;int&gt; SomeList { get; set; }
}
```

If `ClassB` is serialized an exception is thrown:

&gt;The JSON property name for 'ClassB.SomeList' collides with another property.

This seems like unwanted behavior.</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41337</IssueID>
    <RepoID>1</RepoID>
    <Title>Problems serializing Dictionary&lt;string,string&gt; when is a property of an object</Title>
    <Description>When I try to serialize a Dictionary&lt;string, string&gt; directly like this:
```csharp
var dic = new Dictionary&lt;string, string&gt;
{
    {"key1","value1" },
    {"key2","value2" },
};
var json = System.Text.Json.JsonSerializer.Serialize(dic);
```
I get the right output:
```json
{"key1":"value1","key2":"value2"}
```

But when the dictionary is a property of an object, the Dictionary is not serialized at all:
```csharp
public class Dto
{
    public string Id { get; set; }
    public IDictionary&lt;string, string&gt; Dic = new Dictionary&lt;string, string&gt;();
}

var dto = new Dto { Id = "aaaaaa" };
dto.Dic.Add("key1", "aaaa");
dto.Dic.Add("key2", "bbbb");            
var json = System.Text.Json.JsonSerializer.Serialize(dto);
```
Result:
```json
{"Id":"aaaaaa"}
```

</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41336</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @GrabYourPitchforks</Description>
    <CreatedDate>26/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41335</IssueID>
    <RepoID>1</RepoID>
    <Title>Update WCF pkg versions in the compat pack.</Title>
    <Description>- [ ] release/3.0
         Update the WCF packages in the compat pack to version 4.6.0 for the next servicing release '3.0.1'.

- [ ] release/3.1 and master
         The WCF master branch (vNext for us is release 3.1) has numerous new APIs not added in release/3.0.0 which we would like to see reflected in the 'apisof.net'.
         Our master branch default channel: `(497)  https://github.com/dotnet/wcf @ refs/heads/master -&gt; .NET Core 5 Dev`</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41334</IssueID>
    <RepoID>1</RepoID>
    <Title>Create WCF binary drops for adding new APIs to docs.microsoft.com</Title>
    <Description>- [x] Drop for .NET Core 2.1 using WCF packages version 4.5.3

- [x] Drop for .NET Core 3.0 using WCF packages version 4.6.0

WCF Packages...
[System.ServiceModel.Duplex](https://www.nuget.org/packages/System.ServiceModel.Duplex/)
[System.ServiceModel.Http](https://www.nuget.org/packages/System.ServiceModel.Http/)
[System.ServiceModel.NetTcp](https://www.nuget.org/packages/System.ServiceModel.NetTcp/)
[System.ServiceModel.Primitives](https://www.nuget.org/packages/System.ServiceModel.Primitives/)
[System.ServiceModel.Security](https://www.nuget.org/packages/System.ServiceModel.Security/)

@mairaw Once the docs are created would it be possible to get a list of them so that we can review them. I assume that since all the APIs we've added in Core also exist in the full framework the docs will basically be a copy. There are some where we may want to make some additional changes due to functionality changes in porting them to Core.

Thanks.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41333</IssueID>
    <RepoID>1</RepoID>
    <Title>Breaking change proposal: OrdinalIgnoreCase string comparison, ToUpperInvariant, and ToLowerInvariant to use ICU on all platforms</Title>
    <Description>## Proposal

.NET Core provides APIs to compare strings for ordinal case-insensitive equality (such as via `StringComparer.OrdinalIgnoreCase`). The current implementation of this API is to call `ToUpperInvariant` on each string, then compare the resulting uppercase strings for bitwise equality.

.NET Core also provides methods to convert `char`s, `Rune`s, and `string`s to uppercase or lowercase using the "invariant" culture (`ToUpperInvariant` / `ToLowerInvariant`). The current implementation of this API is to p/invoke [NLS](https://docs.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-lcmapstringex) on Windows or [ICU](https://ssl.icu-project.org/apiref/icu4c/) on non-Windows.

I propose changing the logic so that .NET Core carries its own copy of the ICU "simple" casing tables, and we consult our copies of those tables on all operating systems. This would affect string comparison only when using an `OrdinalIgnoreCase` comparison, and it would affect string casing only when using `CultureInfo.InvariantCulture`.

## Justification

Today, when processing UTF-8 data in a case-insensitive manner (such as via `Equals(..., OrdinalIgnoreCase)`), we must first transcode the data to UTF-16 so that it can go through the normal p/invoke routines. This transcoding and p/invoke adds unnecessary overhead. With this proposal, we'd be able to consult our own local copies of the casing table, which eliminates much of this overhead and streamlines the comparison process. This performance boost should also be applicable to existing UTF-16 APIs such as `string.ToUpperInvariant` and `string.ToLowerInvariant` since we'd be able to optimize those calls.

As mentioned earlier, today's casing tables involve p/invoking NLS or ICU, depending on platform. This means that comparison / invariant casing APIs could provide different results on different operating systems. Even within the same operating system family, the casing tables can change based on OS version. (Windows 10 1703 has different casing tables than Windows 10 1903, for instance.)

Here are some concrete examples demonstrating the problems:

```cs
// 'ß' is U+00DF LATIN SMALL LETTER SHARP S
// 'ẞ' is U+1E9E LATIN CAPITAL LETTER SHARP S

string toUpper = "ß".ToUpperInvariant(); // returns "ß" on all OSes
string toLower = "ẞ".ToLowerInvariant(); // returns "ẞ" on Windows, otherwise "ß"
bool areEqual = "ß".Equals("ẞ", StringComparison.OrdinalIgnoreCase); // returns "False" on Windows, otherwise "True"
```

With this proposal, the code above will behave the same across all OSes. They would follow what is today's non-Windows behavior. They'd be locked to whatever version of the Unicode data we include in the product as part of the `CharUnicodeInfo` class. This data changes each release to reflect recent modifications to the Unicode Standard. As of this writing, the data contained within the `CharUnicodeInfo` class follows the Unicode Standard 11.0.0.

## Breaking change discussion

Affected APIs:

 * `string` / `char` / `Rune` equality methods or hash code generation routines which take `StringComparison.OrdinalIgnoreCase` as a parameter. All other comparisons are unchanged.
 * `string` / `char` / `Rune` case changing methods when `CultureInfo.InvariantCulture` is provided. All other cultures are unchanged.
 * Extension methods on `ReadOnlySpan&lt;char&gt;` which provide equivalent functionality to the above.
 * `StringComparer.OrdinalIgnoreCase`. All other `StringComparer` instances are unchanged.
 * Case changing methods on `CultureInfo.InvariantCulture.TextInfo`.

If `GlobalizationMode.Invariant` is specified, the behavior will be the same as it is today, where non-ASCII characters remain unchanged.

Applications which depend on `OrdinalIgnoreCase` equality being stable may be affected by this proposed change. That is, if an application relies on `"ß"` and `"ẞ"` being not equal under an `OrdinalIgnoreCase` comparer, that application is likely to experience odd behavior in the future.

In general, applications _cannot_ rely on such behavior anyway, because as previously mentioned the operating system historically has updated casing tables under the covers without the application getting a say. For example, after installing a new Windows version, a comparison which previously returned _false_ might start returning _true_:

```cs
string a = "ꝍ"; // U+A74D
string b = "Ꝍ"; // U+A74C

// today, may be "True" or "False" depending on which Windows version the app is running on.
// with this proposal, always returns "True"
bool areEqual = string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
```

Furthermore, the string equality and case mapping information might be different between a web frontend application and the database it's using for backend storage. So performing such checks at the application level was never 100% reliable to begin with.

There is a potential oddity with this proposal: depending on operating system, two strings which compare as equal using `OrdinalIgnoreCase` might compare as not equal using `InvariantCultureIgnoreCase`. For example:

```cs
// with this proposal, returns "True" across all OSes
bool equalsOIC = "ß".Equals("ẞ", StringComparison.OrdinalIgnoreCase);

// with this proposal, returns "False" on Windows, "True" otherwise
bool equalsICIC = "ß".Equals("ẞ", StringComparison.InvariantCultureIgnoreCase);
```

I don't expect this to trip up most applications because I don't believe it to be common for an application to compare a string pair using two _different_ comparers, but it is worth pointing out as a curious edge case.

This may also lead to a discrepancy between managed code which uses `StringComparison.OrdinalIgnoreCase` and unmanaged code (including within the runtime) which uses [`CompareStringOrdinal`](https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringordinal) on Windows. I cannot think offhand of any components which do this, but we need to be mindful that such a discrepancy might occur.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41332</IssueID>
    <RepoID>1</RepoID>
    <Title>Unable to read ReturnTypeCustomAttributes when using System.Reflection.MetadataLoadContext</Title>
    <Description>I was trying to use SR.MetadataLoadContext 4.6.0  in order to reflect an assembly and inspect for nullable reference types.    In order to do that I must get the custom attributes for a method's `ReturnType` using `ReturnTypeCustomAttributes`.

If you attempt to call `ICustomAttributeProvider.GetCustomAttributes(bool)` on `ReturnTypeCustomAttributes`, you get the following exception:

```console
Unhandled exception: System.InvalidOperationException: The requested operation cannot be used on objects loaded by a MetadataLoadContext.
   at System.Reflection.TypeLoading.RoParameter.GetCustomAttributes(Boolean inherit)
```

Is there another way to get the custom attributes for a return type to inspect `NullableAttribute` and `NullableContextAttribute` with MetadataLoadContext?

Current unwanted workaround is to reflect the property from the interface implementation, which lets me see the attributes:
```csharp
MethodInfo mi;
var attributes = mi.ReturnTypeCustomAttributes.GetType().GetProperty("CustomAttributes").GetValue(mi) as IEnumerable&lt;CustomAttributeData&gt;;
```
</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41331</IssueID>
    <RepoID>1</RepoID>
    <Title>Clear out RSA decryption array-returning residuals.</Title>
    <Description>Initial draft has a non-resource exception and some commented out code to see if the UAP failure from the last PR that had this is repeatable so we can get exception diagnostics from it.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41330</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**

 cc @jkotas</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41329</IssueID>
    <RepoID>1</RepoID>
    <Title>Serializer errors for dictionaries that don't implement IDictionary</Title>
    <Description>Trying to serialize the results of this Dapper query.

```
var installations = (await Db.QueryAsync&lt;object&gt;( @"select InstallationID AS Value, Name AS Text
                                                   from [AIS].[Abs].Installation" )).ToList();
var inst = JsonSerializer.Serialize( installations );
```

The error I get is:
```
Message: 
    System.InvalidCastException : Unable to cast object of type '&lt;GetEnumerator&gt;d__9' to type 'System.Collections.IDictionaryEnumerator'.
  Stack Trace: 
    JsonSerializer.HandleDictionary(JsonClassInfo elementClassInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack&amp; state)
    JsonSerializer.Write(Utf8JsonWriter writer, Int32 originalWriterDepth, Int32 flushThreshold, JsonSerializerOptions options, WriteStack&amp; state)
    JsonSerializer.WriteCore(Utf8JsonWriter writer, PooledByteBufferWriter output, Object value, Type type, JsonSerializerOptions options)
    JsonSerializer.WriteCore(PooledByteBufferWriter output, Object value, Type type, JsonSerializerOptions options)
    JsonSerializer.WriteCoreString(Object value, Type type, JsonSerializerOptions options)
    JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)
```

Should this work? Works fine in Json.Net.


</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41328</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Español Windows 19H1 queue in PRs</Title>
    <Description>
    </Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41327</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190925.2
- **Date Produced**: 9/25/2019 5:58 PM
- **Commit**: 68ff240063fc2ddb9b03275ae5d5063a09d38ace
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.1-servicing.19475.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.1-servicing.19475.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.1-servicing.19475.2

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41326</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add Encoder/Decoder for new System.Buffer types</Title>
    <Description>#41166 Discusses APIs for the Encoding classes in while this issue is about the stateful **Encoder** and **Decoder** types:

```C#
#nullable enable
namespace System.Text
{
    public static class EncodingExtensions
    {
            public static void Convert(this Encoder encoder,
                ReadOnlySpan&lt;char&gt; chars,
                IBufferWriter&lt;byte&gt; writer,
                bool flush,
                out long bytesUsed,
                out bool completed);

            public static void Convert(
                this Encoder encoder,
                in ReadOnlySequence&lt;char&gt; chars,
                IBufferWriter&lt;byte&gt; writer,
                bool flush,
                out long bytesUsed,
                out bool completed);

            public static void Convert(
                this Decoder decoder,
                in ReadOnlySequence&lt;byte&gt; bytes,
                Span&lt;char&gt; chars,
                bool flush,
                out SequencePosition bytesUsedPosition,
                out int charsUsed,
                out bool completed);

            public static void Convert(
                this Decoder decoder,
                in ReadOnlySequence&lt;byte&gt; bytes,
                IBufferWriter&lt;char&gt; writer,
                bool flush,
                out long charsUsed,
                out bool completed);
    }
}
```

These extensions would likely live in the same assembly as these abstractions since encoding couldn't directly take a dependency on those types (unless we push them lower in the stack).

cc @GrabYourPitchforks </Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41325</IssueID>
    <RepoID>1</RepoID>
    <Title>Deserialize interfaces using System.Text.Json.JsonSerializer</Title>
    <Description>How can I deserialize json to a class type that contain interface properties? I have a tree based structure that looks like this:
```csharp
interface INode { }

class Node : INode
{
    public List&lt;INode&gt; Nodes { get; set; }
}

class Leaf : INode
{
    public string Value { get; set; }
}
```

With Json.NET I am able to deserialize it by defining custom JsonConverter:
```csharp
class InterfaceJsonConverter : JsonConverter
{
    public override bool CanConvert(Type objectType)
    {
        return objectType.IsInterface &amp;&amp; typeof(INode).IsAssignableFrom(objectType);
    }
    ....
}
```

With with System.Text.Json.JsonSerializer I can also implement custom converter that inherits from `JsonConverter&lt;INode&gt;`. However, when I try to deserialize the json, I get following exception:
```
NotSupportedException:  Deserialization of interface types is not supported.
```

Is it a way how to deserialize interfaces using JsonSerializer at this time? If not is it planned for future releases? </Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41324</IssueID>
    <RepoID>1</RepoID>
    <Title>Breaking change proposal: StringInfo and TextElementEnumerator to support extended grapheme clusters</Title>
    <Description>## Proposal

The `StringInfo` class (see [MSDN docs](https://docs.microsoft.com/en-us/dotnet/api/system.globalization.stringinfo)) and `TextElementEnumerator` class provide APIs to get information about single display characters (sometimes called "graphemes") in a string. This is useful for applications which need to avoid breaking grapheme clusters improperly, such as applications which perform automatic text truncation or word wrapping.

Today, the logic in this type uses a very old, outdated algorithm which has since been superceded by [UAX29](https://www.unicode.org/reports/tr29/). I propose updating the logic in `StringInfo` so that it uses the concept of _extended grapheme clusters_ for determining the boundaries of single display characters. The logic would only be updated to understand culture-invariant grapheme cluster boundaries, not culture-aware word or sentence boundaries as specified elsewhere in UAX29.

This issue covers __only__ the breaking change proposal and doesn't discuss changing or adding API surface. For discussion on potential new API surface on these types, see other issues such as https://github.com/dotnet/corefx/issues/13824.

## Justification

Consider the sequence "🤹🏽‍♀️", which represents a woman with medium skin tone juggling. This sequence actually consists of five distinct Unicode scalar values (`Rune`s, if you prefer):

 * `U+1F939 JUGGLING`
 * `U+1F3FD EMOJI MODIFIER FITZPATRICK TYPE-4`
 * `U+200D ZERO WIDTH JOINER`
 * `U+2640 FEMALE SIGN`
 * `U+FE0F VARIATION SELECTOR-16`

The base emoji character is the juggler, and the Fitzpatrick modifier ("medium skin tone") and female sign are applied atop the base character to form the single logical grapheme. The zero-width joiner and variation selector-16 are the "glue" that keeps everything together.

Because the `StringInfo` type has no knowledge of extended grapheme clusters, asking it to enumerate the display characters in the string will result in the following sequence:

 * `U+1F939` (🤹)
 * `U+1F3FD` (🏽)
 * `U+200D`
 * `U+2640 U+FE0F` (♀)

That is, today's `StringInfo` says that this should actually be displayed as _four different characters_ one after another: 🤹, 🏽, (blank), ♀. With this proposal, `StringInfo` would properly return that the entire string consists of a single logical grapheme.

As another example, consider the string "I♥🇨🇭", which is a three-display-character string consisting of the letter 'I', a heart, and the Swiss flag. (Depending on your operating system, the letters 'CH' may be displayed instead of the Swiss flag.) This sequence consists of four distinct Unicode scalar values:

 * `U+0049 LATIN CAPITAL LETTER I`
 * `U+2665 BLACK HEART SUIT`
 * `U+1F1E8 REGIONAL INDICATOR SYMBOL LETTER C`
 * `U+1F1ED REGIONAL INDICATOR SYMBOL LETTER H`

Today's `StringInfo` will improperly return that this consists of four distinct display characters: 'I', '♥', '🇨', '🇭'. With this proposal, the '🇨' and '🇭' will be kept together a single '🇨🇭' character. This should keep the Swiss flag from being improperly split.

## Breaking change discussion

Though this does "fix" the `StringInfo` and `TextElementEnumerator` types to be compliant with the guidance laid out in UAX29, it does represent a breaking change from the existing behavior of `StringInfo`. Applications whose correct behavior relies on the older standard may encounter unexpected behaviors if this change is approved. I cannot think of examples of any such applications, but I did nevertheless want to call out the potential for breaks.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41323</IssueID>
    <RepoID>1</RepoID>
    <Title>Add System.Object converter sample to have semantics similar to Newtonsoft Json.NET</Title>
    <Description>Sample converter and tests for converting JSON to System.Object-declared properties using similar semantics as Json.NET.
- TokenType.True -&gt; System.Bool (true)
- TokenType.False-&gt; System.Bool (false)
- TokenType.Number -&gt; System.Long or System.Double
- TokenType.String -&gt; System.String or System.DateTime
- TokenType.Null -&gt; null
- Other (object, array) -&gt; JsonElement (not the same)

related to discussion from https://github.com/dotnet/corefx/issues/38713</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41322</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.IO.Compression for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41321</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher.EnableRaisingEvents captures the ExecutionContext</Title>
    <Description>This might be deemed a feature but it can unintentionally end up rooting async locals for a very long time. The way this happens is extremely implicit which is why it feels like it should be improved (or at least be given a cleaner way to opt out). 

On Windows, the flow looks like this:

```
FileSystemWatcher.EnableRaisingEvents -&gt; new PreAllocatedOverlapped -&gt; new ThreadPoolBoundHandleOverlapped -&gt; Overlapped.Pack -&gt; ExecutionContext.Capture()
```

On Linux:

```
FileSystemWatcher.EnableRaisingEvents -&gt; RunningInstance.Start -&gt; Task.Factory.StartNew() -&gt; ExecutionContext.Capture()
```
This happens as a result of setting the property which IMO is extremely implicit and indirect. If it's desirable to capture the `ExecutionContext` then it should be captured explicitly in the consturctor (with a boolean option to turn it off), not indirectly by the property setter.

This is a result of looking at a customer application that might have been doing bad things but it was magnified by the fact that async locals from the http request were being captured by the file watcher.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41319</IssueID>
    <RepoID>1</RepoID>
    <Title>OdbcCommand ExecuteReaderObject SchemaOnly Confusion</Title>
    <Description>Hello,

I was reading through the [OdbcCommand source](https://github.com/dotnet/corefx/blob/master/src/System.Data.Odbc/src/System/Data/Odbc/OdbcCommand.cs) and became confused about a couple of if-statements that seemed contradictory. 

The code in question starts at [708](https://github.com/dotnet/corefx/blob/ac99a1b7168bd32046a954c3f06012c0fa909bed/src/System.Data.Odbc/src/System/Data/Odbc/OdbcCommand.cs#L708)

```
if (!localReader.IsBehavior(CommandBehavior.SchemaOnly))
 {
     // Can't get the KeyInfo after command execution (SQL Server only since it does not support multiple
    // results on the same connection). Stored procedures (SP) do not return metadata before actual execution
    // Need to check the column count since the command type may not be set to SP for a SP.
    if ((localReader.IsBehavior(CommandBehavior.KeyInfo) || localReader.IsBehavior(CommandBehavior.SchemaOnly))
        &amp;&amp; (CommandType != CommandType.StoredProcedure))
    {
    ...
```

So on 708, SchemaOnly command behaviors are excluded from the following code block, but inside said code block, SchemaOnly is tested again. It seems to me that that SchemaOnly test will always fail, no?</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41318</IssueID>
    <RepoID>1</RepoID>
    <Title>Change dependsOn Parameter when calling post-build tempalte to react …</Title>
    <Description>…to Arcade breaking change

Test build for this: https://dev.azure.com/dnceng/internal/_build/results?buildId=365845&amp;view=results (canceled the builds, but the stage flow looks correct again)</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41317</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190924.3
- **Date Produced**: 9/24/2019 6:16 PM
- **Commit**: 0e9ffd6464aff37aef2dc41dc2162d258f266e32
- **Branch**: refs/heads/release/3.x
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19474.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19474.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19474.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19474.3

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41316</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)
## From https://github.com/dotnet/arcade
- **Build**: 20190924.3
- **Date Produced**: 9/24/2019 6:16 PM
- **Commit**: 0e9ffd6464aff37aef2dc41dc2162d258f266e32
- **Branch**: refs/heads/release/3.x
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19474.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19474.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19474.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19474.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19474.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19474.3

[marker]: &lt;&gt; (End:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)

</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41315</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Private assemblies don't get stable product version in AssemblyInformationalVersion</Title>
    <Description>This is true for all System.Private assemblies that ship in the shared framework and needs to be fixed in CoreFx and CoreCLR.

Thank you @mjsabby for the report and @dagood for investigating.

Bug is here in CoreFx: 
https://github.com/dotnet/corefx/blob/4ac4c0367003fe3973a3648eb0715ddb0e3bbcea/Directory.Build.props#L393

To fix we may want to change the behavior to consider IsNetCoreApp where we don't set this for libraries that are part of the shared framework.  For CoreCLR we might just explicitly set it in the corelib project.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41314</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @stephentoub</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41313</IssueID>
    <RepoID>1</RepoID>
    <Title>StartsWith extremly slow on Linux if Culture is not en-US</Title>
    <Description>I noticed some situations where String.StartsWith is getting extremly slow on Linux-x64 under certain conditions:
 - CultureInfo of the Thread is not en-US (depending on OS-Environment) 
- using StringComparison.CurrentCulture (which is default for .NET Core!!!!)
Output of my test program on Linux:
sc: CurrentCulture       ci: en-US  time:                28443 µs
sc: CurrentCulture       ci: en-EN  time:              1722245 µs
sc: CurrentCulture       ci: de-DE  time:              1381201 µs
sc: CurrentCulture       ci: fr-FR  time:              1411512 µs
sc: InvariantCulture     ci: en-US  time:                 6705 µs
sc: Ordinal              ci: en-US  time:                 1355 µs


[StartsWithSlow.zip](https://github.com/dotnet/corefx/files/3652751/StartsWithSlow.zip)
</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41312</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190924.3
- **Date Produced**: 9/24/2019 7:06 PM
- **Commit**: da147ece700c2502b91e57d99213feadcfb9c1f0
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19474.3
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19474.3

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190924.1
- **Date Produced**: 9/24/2019 12:45 PM
- **Commit**: 8dac25a9de201d6ec24c245f79cd964bfbb35502
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19474.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41311</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190924.1
- **Date Produced**: 9/24/2019 4:18 PM
- **Commit**: d7f6c5e944e500f44b8536aed8f6a05320f7729a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19474.1
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19474.1
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19474.1

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41310</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json does not seem capable of deserializing nullable custom structs</Title>
    <Description>Example below, where we see that my object was serialized unconventionally, then could not be deserialized.

**First Problem**

    public class MyClass
    {
        public MyDate? Date { get; set; }
    }

    public struct MyDate
    {
        public int Year { get; set; }
    }

    // Code
    var original = new MyClass { Date = new MyDate { Year = 2 } };

    var json = System.Text.Json.JsonSerializer.Serialize(original);
    Console.WriteLine($"JSON: {json}");

    var after = System.Text.Json.JsonSerializer.Deserialize&lt;MyClass&gt;(json);
    Console.WriteLine($"Original: {original.Date == null}");
    Console.WriteLine($"After: {after.Date == null}");

Output of the program:

    JSON: {"Date":{"HasValue":true,"Value":{"Year":2}}}
    Original: False
    After: True

Found after migrating similar code to ASP.NET Core 3 when my API was not deserializing my nullable structs.

**Second Problem**
Furthermore, I believe the following is a related bug:

    var json2 = "{\"Date\":{\"Year\":2}}";
    var after2 = System.Text.Json.JsonSerializer.Deserialize&lt;MyClass&gt;(json2);
    Console.WriteLine($"After2: {after.Date == null}"); // Outputs True

From this example we see that System.Text.Json doesn't even expect the "conventional" way of serializing nullables. Does this mean that it just does not support nullable custom structs at all?

**Expected**
What I expect and what I call the "conventional" way is to output null for any Nullable&lt;X&gt; which is null, and otherwise just write the JSON of X directly (ignoring HasValue and Value). This is the approach of Newtonsoft JSON.NET, as well as what browsers seem to do.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41309</IssueID>
    <RepoID>1</RepoID>
    <Title>KeyValuePair is not properly serialized with JsonNamingPolicy.CamelCase - System.Text.Json</Title>
    <Description>When serializing a collection of KeyValuePair with CamelCase enabled the properties are serialized in PascalCase:

MVC Configuration is: 
```c#
.AddJsonOptions(options =&gt;
{
    options.JsonSerializerOptions.DictionaryKeyPolicy = JsonNamingPolicy.CamelCase;
    options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
}
```

The result is:
```
{ Key: "Test", Value: "Test1" }
```

Expected result:
```
{ key: "Test", value: "Test1" }
```</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41308</IssueID>
    <RepoID>1</RepoID>
    <Title>API suggestion: CharUnicodeInfo.UnicodeVersion</Title>
    <Description>Suggest adding an API that allows callers to determine the version of the Unicode Standard currently supported by the `CharUnicodeInfo` class.

```cs
namespace System.Globalization
{
    public static class CharUnicodeInfo
    {
        public static Version UnicodeVersion { get; }
    }
}
```

This will return a `System.Version` representing the Unicode data files which have been ingested to form the `CharUnicodeInfo` backing tables. As of this writing, the return value would be "11.0.0". Once we update the backing data, it'll read "12.1.0". And so on each time we ingest new data.

Per the versioning scheme listed at https://www.unicode.org/versions/#Version_Numbering, Unicode Standard version numbers are always in the format _\&lt;major\&gt;.\&lt;minor\&gt;.\&lt;update\&gt;_. So this makes the `System.Version` class ideal for representing such data.

/cc @tarekgh </Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41307</IssueID>
    <RepoID>1</RepoID>
    <Title>Make JsonStringEnumConverter support nullable enums</Title>
    <Description>Right now, the `JsonStringEnumConverter` converter does not support nullable enums.

I think it should.</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41306</IssueID>
    <RepoID>1</RepoID>
    <Title>Add CollectionsMarshal ref assemblies</Title>
    <Description>Resolves dotnet/corefx#31597

/cc @tannergooding @ahsonkhan </Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41305</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json interface member deserialization handling</Title>
    <Description>For some reasons that Json for configuration use, I did a test on how the System.Text.Json handles the interface deserialization. I read the API and can't find anything about this function. First I tried `IEnumerable&lt;T&gt;`. Here is the code:
``` csharp
using System.Collections.Generic;
using System.Text.Json;

namespace dotnet30test
{
    class Program2
    {
        static void Main(string[] args)
        {
            var obj = new TestSerializationObj2
            {
                Names = new HashSet&lt;string&gt; { "1", "2" }
            };
            var sysContent = JsonSerializer.Serialize(obj, new JsonSerializerOptions { WriteIndented = true, });
            var sysNewObj = JsonSerializer.Deserialize&lt;TestSerializationObj&gt;(sysContent);
        }
    }

    public class TestSerializationObj2
    {
        public IEnumerable&lt;string&gt; Names { get; set; }
    }
}
```
The `Names` property is forced to convert from `Hashset&lt;string&gt;` to `List&lt;string&gt;`, but it works successfully indeedly. 
And then I try the custom interface, it throws `JsonException`. What I think that needed is something like Json.NET's auto type name handling. Here is the code:
``` csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using NewtonJson = Newtonsoft.Json;
using SysJson = System.Text.Json;

namespace dotnet30test
{
    class Program
    {
        static void Main(string[] args)
        {
            var obj = new TestSerializationObj
            {
                CustomObj = new DefaultCustom()
            };

            var newtonContent = NewtonJson.JsonConvert.SerializeObject(obj,
                new NewtonJson.JsonSerializerSettings
                {
                    TypeNameHandling = NewtonJson.TypeNameHandling.Auto,
                    Formatting = NewtonJson.Formatting.Indented
                });
            var newtonNewObj = NewtonJson.JsonConvert.DeserializeObject&lt;TestSerializationObj&gt;(newtonContent,
                new NewtonJson.JsonSerializerSettings { TypeNameHandling = NewtonJson.TypeNameHandling.Auto }); // works

            var sysContent = SysJson.JsonSerializer.Serialize(obj, new SysJson.JsonSerializerOptions { WriteIndented = true, });
            var sysNewObj = SysJson.JsonSerializer.Deserialize&lt;TestSerializationObj&gt;(sysContent); // throws exception
        }
    }


    public sealed class TestSerializationObj
    {
        public Dictionary&lt;string, int&gt; Dictionary { get; set; } = new Dictionary&lt;string, int&gt;() { ["a"] = 0, ["b"] = 1 };
        public ICustom CustomObj { get; set; }
    }

    public class DefaultCustom : ICustom
    {
        public string Name { get; set; } = "Default Implementation";
        public int Id { get; set; } = 300;
    }

    public interface ICustom
    {
        int Id { get; set; }
    }
}

```

Thanks!</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41304</IssueID>
    <RepoID>1</RepoID>
    <Title>In async the System.Text.Json throw "The input does not contain any JSON tokens. Expected the input to start with a valid JSON token, when isFinalBlock is true. LineNumber: 0 | BytePositionInLine: 0."</Title>
    <Description>The code like this:
```Charp
class Program
{
    static async Task Main(string[] args)
    {
        try
        {
            var type = typeof(TestModel);
            var testModel = new TestModel {Id = Guid.NewGuid(), Name = "Test"};

            await using var ms = new MemoryStream();
            await JsonSerializer.SerializeAsync(ms, testModel, type);
            var result = await JsonSerializer.DeserializeAsync(ms, type);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
    }
}

public class TestModel
{
    public Guid Id { get; set; }
    public string Name { get; set; }
}
```</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41303</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @GrabYourPitchforks @benaadams</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41320</IssueID>
    <RepoID>1</RepoID>
    <Title>The SSL connection could not be established, see inner exception.</Title>
    <Description># Issue Title
When I initiate a request with a certificate   The program has an error    is   The SSL connection could not be established, see inner exception.

# General

```c#
  private static string HttpPost(string url, string postdata, X509Certificate cer)
        {
            using (HttpClientHandler handler = new HttpClientHandler())
            {
                var httpClientHandler = new HttpClientHandler
                {
                    ServerCertificateCustomValidationCallback = (message, certificate2, arg3, arg4) =&gt; true
                };
                handler.ClientCertificates.Add(cer);
                using (HttpClient httpClient = new HttpClient(handler))
                {
                    //AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", false);
                    HttpContent httpContent = new StringContent(postdata);
                    var response = httpClient.PostAsync(url, httpContent).Result;

                    var body = response.Content.ReadAsStringAsync().Result;

                    return body;
                }
            }
```
</Description>
    <CreatedDate>25/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41302</IssueID>
    <RepoID>1</RepoID>
    <Title>Add unit tests for Utf8Span, react to Utf8String changes</Title>
    <Description>Ref asm + unit tests for https://github.com/dotnet/coreclr/pull/26711. This PR will not pass CI until that build makes its way from coreclr to corefx.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41301</IssueID>
    <RepoID>1</RepoID>
    <Title>Update dotnet SDK to 3.0.100 + darc update</Title>
    <Description>Updating the dotnet SDK to the latest stable version 3.0.100.

cc @danmosemsft @ericstj </Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41300</IssueID>
    <RepoID>1</RepoID>
    <Title>Exploration: Retry STATUS_UNSUCCESSFUL from CNG</Title>
    <Description>This is an attempt to address #37994, but since it's a very intermittent failure it's not really easy to say if the fix "works" or not.

Success will be measured by seeing no failures in CI for a month or so.  If it doesn't work, we'll just back it out.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41299</IssueID>
    <RepoID>1</RepoID>
    <Title>Indenting and unindenting JSON should be easier</Title>
    <Description>Imagine I need to unindent some raw JSON (for example, for error messages and logging). There is no simple way to do that; instead, I ended up writing the following, which seems a bit clunky:

```C#
public static string ChangeIndentation(string value, bool indented)
{
    using (var stream = new MemoryStream())
    {
        var options = new JsonWriterOptions { Indented = indented };

        using (var writer = new Utf8JsonWriter(stream, options))
        {
            using var document = JsonDocument.Parse(value);
            document.WriteTo(writer);
        }

        stream.Position = 0;

        using (var reader = new StreamReader(stream))
            return reader.ReadToEnd();
    }
}
```

### Proposal

```C#
namespace System.Text.Json
{
    partial class JsonDocument
    {
        public override string ToString() =&gt; ToString(indented: true);
        public string ToString(bool indented);
    }
}
```

### Usage

```C#
public static string ChangeIndentation(string value, bool indented)
{
    using var document = JsonDocument.Parse(value);
    return document.ToString(indented);
}
```</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41298</IssueID>
    <RepoID>1</RepoID>
    <Title>NuGet: System.Collections.Concurrent targeting .NetCore,Version=5? preventing the library reference.</Title>
    <Description>NuGet: System.Collections.Concurrent targeting .NetCore,Version=5? preventing the library reference.

![image](https://user-images.githubusercontent.com/621804/65554412-160cd300-deef-11e9-9c21-f70caf93e852.png)
</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41295</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Support receiving dynamic table headers</Title>
    <Description>Dynamic table code was actually fixed/tested in 3.0, but the feature was left disabled. This re-enables it and adds functional tests to verify it. Resolves #41208 

A future change might add an API to let users configure the dynamic table size. Currently it is kept at default of 4KiB.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41294</IssueID>
    <RepoID>1</RepoID>
    <Title>freezing the version for the System.IO.Pipes.AccessControl</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/40978
</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41293</IssueID>
    <RepoID>1</RepoID>
    <Title>Updating branding to 3.0.1-servicing</Title>
    <Description>
    </Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41292</IssueID>
    <RepoID>1</RepoID>
    <Title>DrawString render issue with .Net Core 3.0</Title>
    <Description>### **Related to:** https://www.nuget.org/packages/System.Drawing.Common/ (4.6.0)

With everything else being equal; simply upgrading a project from .Net Core 2.2 to .Net Core 3.0 results in a new `DrawString` render issue; downgrading from 3.0 to 2.2 resolves this? (see attached screen shots)

**Note:** 
I tried a number of different font families including `GenericSansSerif`, `GenericSerif` and `GenericMonospace` -- all result in the same render issue. It works as expected on .Net Core 2.2 but not on .Net Core 3.0

**.Dot Net 2.2** 
![dotnetcore22](https://user-images.githubusercontent.com/22223342/65538811-70665d80-df08-11e9-9a4e-90301233206f.png)

**.Dot Net 3.0** 
![dotnetcore30](https://user-images.githubusercontent.com/22223342/65538813-72302100-df08-11e9-9732-5a98379a9a43.png)







</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41291</IssueID>
    <RepoID>1</RepoID>
    <Title>Missing API: Guid.TryWriteBytes(..., out int bytesWritten)</Title>
    <Description>Per API review, our `Guid.TryWriteBytes` method should have an overload which outs the number of bytes written to the destination buffer.

@tannergooding - you had also mentioned adding a similar API to `decimal`, but I don't see offhand which overload would be affected.

/cc @bartonjs</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41290</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer.Deserialize&lt;dynamic&gt; is not producing a dynamic</Title>
    <Description>JsonSerializer.Deserialize&amp;lt;dynamic&amp;gt; does not produce a dynamic, but System.Text.Json.JsonElement instead. Is this going to be supported in the near future?</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41289</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @jkotas @stephentoub</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41288</IssueID>
    <RepoID>1</RepoID>
    <Title>Throws an exception on a simple JSON structure return.</Title>
    <Description>I don't have time to figure out exactly what's buggy about the **System.Text.JSON**, but this code was working in .NET Core 2.2.

```
            return this.Ok(
                new
                {
                    deletedEntityTrees,
                    entities,
                    entityTrees,
                    users,
                });

```
Now I get:

&gt; fail: Microsoft.AspNetCore.Server.Kestrel[13]
&gt;       Connection id "0HLQ11IPL386G", Request id "0HLQ11IPL386G:00000001": An unhandled exception was thrown by the application.
&gt; System.Text.Json.JsonException: A possible object cycle was detected which is not supported. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 32.
&gt;    at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_SerializerCycleDetected(Int32 maxDepth)
&gt;    at System.Text.Json.JsonSerializer.Write(Utf8JsonWriter writer, Int32 originalWriterDepth, Int32 flushThreshold, JsonSerializerOptions options, WriteStack&amp; state)
&gt;    at System.Text.Json.JsonSerializer.WriteAsyncCore(Stream utf8Json, Object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken)
&gt;    at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
&gt;    at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextResultFilterAsync&gt;g__Awaited|29_0[TFilter,TFilterAsync](ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResultExecutedContextSealed context)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.ResultNext[TFilter,TFilterAsync](State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeResultFilters()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextResourceFilter&gt;g__Awaited|24_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResourceExecutedContextSealed context)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeFilterPipelineAsync()
&gt; --- End of stack trace from previous location where exception was thrown ---
&gt;    at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)
&gt;    at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
&gt;    at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
&gt;    at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)
&gt;    at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication`1 application)
&gt; 

When I switch back to NewtonSoft, it works just like it did before the upgrade to .NET Core 3.0.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41287</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Numerics.Vectors and System.Threading.Tasks.Extensions still in preview?</Title>
    <Description>With the release of .NET Core 3.0, I thought these would become official releases as well.  What are the plans to make these two packages "final" releases?</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41285</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixing outdated method name</Title>
    <Description>.Net Core release notes lead to this sample for JSON serializing, it's using non-existent static `ToString` method though, this changes updates the docs</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41284</IssueID>
    <RepoID>1</RepoID>
    <Title>Skip codepath Environment.OSVersion.Platform on publish trimmed with linker</Title>
    <Description>The publish trimmed feature in .NET core 3 is not trimming code on specific code paths (see example below) which are  unable to get hit when published with specific runtime-rid e.g. windows and readytorun

Another approach would be #if but this has several disadvantages in Visual Studio etc.

```csharp
public static IServiceCollection AddSocketCAN(this IServiceCollection serviceCollection)
        {
            if (Environment.OSVersion.Platform != PlatformID.Unix)
                return serviceCollection;

            serviceCollection
                .AddSingleton&lt;ICanFactory, SocketCanFactory&gt;()
                .AddSingleton&lt;ISafetyRequestProvider, UnixDiagramSafetyRequestProvider&gt;();
            
            return serviceCollection;
        }

</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41283</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json cannot serialize dictionary with deep values</Title>
    <Description>Project to reproduce the error:
[JsonDemo.zip](https://github.com/dotnet/corefx/files/3647718/JsonDemo.zip)

Using `.NET Core 3.0.100`

Error:
```xml
System.NotSupportedException: The collection type 'System.Collections.Generic.Dictionary`2[System.Int32,JsonDemo.Controllers.Root]' on 'JsonDemo.Controllers.RootTest.Roots' is not supported.
   at System.Text.Json.JsonClassInfo.GetElementType(Type propertyType, Type parentType, MemberInfo memberInfo, JsonSerializerOptions options)
   at System.Text.Json.JsonClassInfo.CreateProperty(Type declaredPropertyType, Type runtimePropertyType, Type implementedPropertyType, PropertyInfo propertyInfo, Type parentClassType, JsonConverter converter, JsonSerializerOptions options)
   at System.Text.Json.JsonClassInfo.AddProperty(Type propertyType, PropertyInfo propertyInfo, Type classType, JsonSerializerOptions options)
   at System.Text.Json.JsonClassInfo..ctor(Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializerOptions.GetOrAddClass(Type classType)
   at System.Text.Json.WriteStackFrame.Initialize(Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.WriteAsyncCore(Stream utf8Json, Object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
   at Microsoft.AspNetCore.Mvc.Formatters.SystemTextJsonOutputFormatter.WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextResultFilterAsync&gt;g__Awaited|29_0[TFilter,TFilterAsync](ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResultExecutedContextSealed context)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.ResultNext[TFilter,TFilterAsync](State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeResultFilters()
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeFilterPipelineAsync&gt;g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)
   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Logged|17_1(ResourceInvoker invoker)
   at Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
```

Using the `Newtonsoft` NuGet package and adding `AddNewtonsoftJson()` in `Startup.cs` worked. This is the expected result from the object that I'm trying to serialize:
```json
{
    "roots": {
        "1": {
            "rootId": 1,
            "rootChildrens": {
                "1": {
                    "rootChildrenId": 1,
                    "childrenDetails": [{
                            "data": "Children One Data"
                        }
                    ]
                },
                "2": {
                    "rootChildrenId": 2,
                    "childrenDetails": [{
                            "data": "Children Two Data"
                        }
                    ]
                }
            }
        },
        "2": {
            "rootId": 2,
            "rootChildrens": {
                "3": {
                    "rootChildrenId": 3,
                    "childrenDetails": [{
                            "data": "Children Three Data"
                        }
                    ]
                }
            }
        }
    }
}
```

</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41282</IssueID>
    <RepoID>1</RepoID>
    <Title>Synchronous deserialize and serialize to a stream with JsonSerializer.</Title>
    <Description>We have a serializer interface (https://github.com/FoundatioFx/Foundatio/blob/master/src/Foundatio/Serializer/ISerializer.cs#L6-L9) which takes a stream as the input and we have extensions that work from it. In our use cases the payloads are usually very small and fit inside normal buffer lengths. Now I totally understand async io and the benefits but we use in memory streams for our serialization and we don't want to do async serialization as it totally kills performance and really complicates some scenarios (esp in messaging handlers at scale). Can you add overloads for this? It would make  it a little bit easier for this use case?

I propose that we add overloads to both `System.Text.Json.JsonSerializer.Serialize` and `System.Text.Json.JsonSerializer.Deserialize` that take streams. As @ahsonkhan provided the following code which sums up what needs to happen signature wise.

```cs
public static partial class JsonSerializer
{
    // Existing APIs:
    public static ValueTask&lt;object&gt; DeserializeAsync(Stream utf8Json, 
        Type returnType, 
        JsonSerializerOptions options = null, 
        CancellationToken cancellationToken = default);
    
    public static ValueTask&lt;TValue&gt; DeserializeAsync&lt;TValue&gt;(Stream utf8Json,
        JsonSerializerOptions options = null,
        CancellationToken cancellationToken = default);

    public static Task SerializeAsync(Stream utf8Json, 
        object value, 
        Type inputType, 
        JsonSerializerOptions options = null, 
        CancellationToken cancellationToken = default);
    
    public static Task SerializeAsync&lt;TValue&gt;(Stream utf8Json, 
        TValue value, 
        JsonSerializerOptions options = null, 
        CancellationToken cancellationToken = default);

    // Proposal to add following synchronous APIs:
    public static object Deserialize(Stream utf8Json, 
        Type returnType, 
        JsonSerializerOptions options = null);
    
    public static TValue Deserialize&lt;TValue&gt;(Stream utf8Json,
        JsonSerializerOptions options = null);

    public static void Serialize(Stream utf8Json, 
        object value, 
        Type inputType, 
        JsonSerializerOptions options = null);
    
    public static void Serialize&lt;TValue&gt;(Stream utf8Json, 
        TValue value, 
        JsonSerializerOptions options = null);
}
```

**Edit by @ahsonkhan:** Just modified some indentation/spacing so the API surface aligns better.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41286</IssueID>
    <RepoID>1</RepoID>
    <Title>AssemblyLoadContext crash when collectible assembly use XmlSerializer</Title>
    <Description>When creating a collectible AssemblyLoadContext and then use `System.Xml.Serialization.XmlSerializer` inside of a collectible assembly you will get a crash.

I have a repro project: https://github.com/uffebjorklund/AssemblyLoadContextBug

Have tried a few different things
 - If creating the ALC as `collectible = false` there is no crash
 - If the `XmlSerializer` code is removed from the collectible assembly there is no crash
 - The crash will occur regardless of using `netstandard2.0` or `netstandard2.1` on the collectible assembly

## Exception
`A non-collectible assembly may not reference a collectible assembly`

## Stacktrace
```
at System.Reflection.Emit.ModuleBuilder.GetTypeRef(QCallModule module, String strFullName, QCallModule refedModule, String strRefedModuleFileName, Int32 tkResolution)
at System.Reflection.Emit.ModuleBuilder.GetTypeRefNested(Type type, Module refedModule, String strRefedModuleFileName)
at System.Reflection.Emit.ModuleBuilder.GetTypeTokenWorkerNoLock(Type type, Boolean getGenericDefinition)
at System.Reflection.Emit.ModuleBuilder.GetTypeTokenInternal(Type type, Boolean getGenericDefinition)
at System.Reflection.Emit.ILGenerator.Emit(OpCode opcode, Type cls)
at System.Xml.Serialization.CodeGenerator.Castclass(Type target)
at System.Xml.Serialization.CodeGenerator.InternalConvert(Type source, Type target, Boolean isAddress)
at System.Xml.Serialization.SourceInfo.InternalLoad(Type elementType, Boolean asAddress)
at System.Xml.Serialization.XmlSerializationWriterILGen.WriteElement(SourceInfo source, ElementAccessor element, String arrayName, Boolean writeAccessor)
at System.Xml.Serialization.XmlSerializationWriterILGen.WriteElements(SourceInfo source, String enumSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, String arrayName, Boolean writeAccessors, Boolean isNullable)
at System.Xml.Serialization.XmlSerializationWriterILGen.WriteMember(SourceInfo source, String choiceSource, ElementAccessor[] elements, TextAccessor text, ChoiceIdentifierAccessor choice, TypeDesc memberTypeDesc, Boolean writeAccessors)
at System.Xml.Serialization.XmlSerializationWriterILGen.GenerateTypeElement(XmlTypeMapping xmlTypeMapping)
at System.Xml.Serialization.XmlSerializationWriterILGen.GenerateElement(XmlMapping xmlMapping)
at System.Xml.Serialization.TempAssembly.GenerateRefEmitAssembly(XmlMapping[] xmlMappings, Type[] types, String defaultNamespace)
at System.Xml.Serialization.TempAssembly..ctor(XmlMapping[] xmlMappings, Type[] types, String defaultNamespace, String location)
at System.Xml.Serialization.XmlSerializer.GenerateTempAssembly(XmlMapping xmlMapping, Type type, String defaultNamespace, String location)
at System.Xml.Serialization.XmlSerializer..ctor(Type type, String defaultNamespace)
```

## dotnet --info
```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100
 Commit:    04339c3a26

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.13
 OS Platform: Darwin
 RID:         osx.10.13-x64
 Base Path:   /usr/local/share/dotnet/sdk/3.0.100/

Host (useful for support):
  Version: 3.0.0
  Commit:  7d57652f33

.NET Core SDKs installed:
  2.1.301 [/usr/local/share/dotnet/sdk]
  2.1.302 [/usr/local/share/dotnet/sdk]
  2.1.400 [/usr/local/share/dotnet/sdk]
  2.1.401 [/usr/local/share/dotnet/sdk]
  2.1.403 [/usr/local/share/dotnet/sdk]
  2.1.500 [/usr/local/share/dotnet/sdk]
  2.2.100-preview3-009430 [/usr/local/share/dotnet/sdk]
  2.2.101 [/usr/local/share/dotnet/sdk]
  2.2.102 [/usr/local/share/dotnet/sdk]
  2.2.103 [/usr/local/share/dotnet/sdk]
  2.2.105 [/usr/local/share/dotnet/sdk]
  2.2.106 [/usr/local/share/dotnet/sdk]
  2.2.203 [/usr/local/share/dotnet/sdk]
  2.2.300 [/usr/local/share/dotnet/sdk]
  3.0.100-alpha1-009708 [/usr/local/share/dotnet/sdk]
  3.0.100-preview-010184 [/usr/local/share/dotnet/sdk]
  3.0.100-preview3-010431 [/usr/local/share/dotnet/sdk]
  3.0.100-preview8-013656 [/usr/local/share/dotnet/sdk]
  3.0.100-preview9-014004 [/usr/local/share/dotnet/sdk]
  3.0.100 [/usr/local/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.6 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.0-preview3-35497 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 3.0.0-alpha1-10062 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.2 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.6 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.0-preview3-35497 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.1 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.5 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-alpha1-10062 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview-19075-0444 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview3-19153-02 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview8.19405.7 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview9.19424.4 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.6 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.0-preview3-27014-02 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.1 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.4 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview-27324-5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview1-27029-03 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview3-27503-5 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview9-19423-09 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]
```</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41281</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json deserializes all properties to null</Title>
    <Description>I have a class that looks like this

```
    public class ApartmentCreatedEvent
    {
        protected ApartmentCreatedEvent() { }
        public ApartmentCreatedEvent(string creatorId, string name, DateTimeOffset dateTime)
        {
            Name = name;
            CreatorId = creatorId;
            DateTime = dateTime;
        }

        public string CreatorId { get; }
        public DateTimeOffset DateTime { get; }
        public string Name { get; }
    }
```

I had to create a parameterless constructor because I was getting an exception that it couldn't deserialize without it

Running this code:

```
            var event  = new ApartmentCreatedEvent("creatorId", "name", DateTimeOffset.UtcNow);
            var ser = JsonSerializer.Serialize(event  );
            var des = JsonSerializer.Deserialize(ser, typeof(ApartmentCreatedEvent));
```
gives me back an object with all the properties set to default (null, and DateTimeOffset.MinValue)</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41280</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20191001.3
- **Date Produced**: 10/2/2019 12:57 AM
- **Commit**: 435c480cbbfb27815805af60ddb42cfffd7c32f3
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19501.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19501.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19501.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)



















</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41279</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable UWP pkg publishing to fix official builds</Title>
    <Description>Fixes regression introduced in https://github.com/dotnet/corefx/commit/49ba6ef9cb8120c87eae636fc41b79e07e88e707. We don't publish packages anymore in UWP therefore we need to disable the upload step.

@safern not sure if that's possible, would a directory exists check also work in the upload artifacts condition?

I will merge this after I validated that legs are en queued correctly to unblock failing official builds.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41278</IssueID>
    <RepoID>1</RepoID>
    <Title>Path.GetPathRoot should have NotNullIfNotNull("path")</Title>
    <Description>Path.GetPathRoot is currently [defined](https://github.com/dotnet/corefx/blob/d58a51f911efb3c98beca21b6cf08cc703424fdf/src/Common/src/CoreLib/System/IO/Path.Windows.cs#L214) as this: 
```csharp
public static string? GetPathRoot(string? path)
```
And the docs state: 

&gt; The resulting string is null if path is null

However, nullable reference types annotations on this method don't match the docs and make think the compiler/analyzer that it can return `null` under any conditions. So even if I check the path for `null` I can't use returned value without checking it for `null` as well or using `!` operator.

Thus, I believe this method should be annotated with 
```csharp
[return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("path")]
```</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41277</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace RS4 with Client19H1 in CI</Title>
    <Description>For a short time (https://github.com/dotnet/core-eng/issues/7464) we will not have multi-lang coverage in our CI but I prefer that over failing builds because of an underlying crypto issue in RS4: https://github.com/dotnet/corefx/pull/40761#issuecomment-527474695

cc @safern @bartonjs </Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41275</IssueID>
    <RepoID>1</RepoID>
    <Title>SocketException when sending on HttpClient after upgrading to core 2.2</Title>
    <Description>Hi,

We are in the process of upgrading from DotNetFramework 4.6.2 to DotNetCore 2.2. After upgrading a lot of our tests are failing when executing a send on a httpclient. It seems to be timing related as the same http requests are working fine if executed by themselves. Any help would be deeply appreciated.

Exception details:
```csharp
System.Net.Http.HttpRequestException : An error occurred while sending the request.
---- System.IO.IOException : Unable to read data from the transport connection: The I/O operation has been aborted because of either a thread exit or an application request.
-------- System.Net.Sockets.SocketException : The I/O operation has been aborted because of either a thread exit or an application request
   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.SendWithNtConnectionAuthAsync(HttpConnection connection, HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)
   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)
   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
   at System.Net.Http.HttpClient.FinishSendAsyncBuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
   at MyTest.Test.MyTest.RunTest(HttpClient httpClient) in C:\workinprogress\20190924 httpclienterror\MyTest\MyTest\MyTest.cs:line 37
   at MyTest.Test.MyTest.GIVEN_WithStaticHttpClient() in C:\workinprogress\20190924 httpclienterror\MyTest\MyTest\MyTest.cs:line 16
--- End of stack trace from previous location where exception was thrown ---
----- Inner Stack Trace -----
   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error)
   at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)
   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken)
----- Inner Stack Trace -----
```

We have created a sample to reproduce the error. It fails when sending the second http request:
```csharp
using System;
using System.Diagnostics;
using System.Net.Http;
using System.Threading.Tasks;
using Xunit;

namespace MyTest.Test
{
    public class MyTest
    {
        private static readonly HttpClient _httpClient = new HttpClient();

        [Fact]
        public async Task GIVEN_WithStaticHttpClient()
        {
            await RunTest(_httpClient);
        }

        [Fact]
        public async Task GIVEN_WithNewHttpClient()
        {
            using (var httpClient = new HttpClient())
            {
                await RunTest(httpClient);
            }
        }

        private async Task RunTest(HttpClient httpClient)
        {
            var serviceUri = new Uri("http://httpstat.us/200");

            var response = await httpClient.SendAsync(new HttpRequestMessage(HttpMethod.Post, serviceUri));
            response.EnsureSuccessStatusCode();

            DoSomeAction();

            response = await httpClient.SendAsync(new HttpRequestMessage(HttpMethod.Put, serviceUri) { Content = new StringContent("my message") });
            response.EnsureSuccessStatusCode();
        }

        private void DoSomeAction()
        {
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    CreateNoWindow = true,
                    FileName = "ping.exe",
                    UseShellExecute = false
                }
            };

            process.Start();

            process.WaitForExit();
            process.Close();
        }
    }
}

```

The csproj file for the project contains the following nuget packages:

```xml
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="16.3.0" /&gt;    
    &lt;PackageReference Include="xunit" Version="2.4.1" /&gt;
    &lt;PackageReference Include="xunit.runner.visualstudio" Version="2.4.1"&gt;
      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
    &lt;/PackageReference&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
```

</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41274</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove some unnecessary string concatenation from CertificatePal.AppendPrivateKeyInfo</Title>
    <Description>A few minor tweaks.
cc: @bartonjs</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41273</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Fix validity encoding for cert dates after 2049</Title>
    <Description>During the change from the reflection serializer to asn.xslt generation we lost
the metadata that said that X.509 Time GeneralizedTime values need to ignore
fractional seconds.

That means we're generating fractional seconds when the input DateTimeOffset
has them, which means we violate RFC in our generated certificates.

Port of #41269 to release/3.0.
Fixes #41248.</Description>
    <CreatedDate>24/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41272</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove person who left the company</Title>
    <Description>Co-owner of System.DirectoryServices.AccountManagement.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41271</IssueID>
    <RepoID>1</RepoID>
    <Title>Prevent Setting SmtpClient.UseDefaultCredentials clearing Credentials</Title>
    <Description>Prevent setting `SmtpClient.UseDefaultCredentials = false` from clearing out `SmtpClient.Credentials` if set before that as noted in issue #24514</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41270</IssueID>
    <RepoID>1</RepoID>
    <Title>Removing Microsoft.bcl* packages</Title>
    <Description>
    </Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41269</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix validity encoding for cert dates after 2049</Title>
    <Description>During the change from the reflection serializer to asn.xslt generation we lost
the metadata that said that X.509 Time GeneralizedTime values need to ignore
fractional seconds.

That means we're generating fractional seconds when the input DateTimeOffset
has them, which means we violate RFC in our generated certificates.

Introduced by #31960.
Addresses #41248 in master.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41268</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove dependencies on System.ComponentModel.TypeConverter.dll</Title>
    <Description>We have several assemblies, e.g. System.Data.Common.dll, System.Diagnostics.EventLog.dll, etc., which are pulled in by the default ASP.NET Core app templates (either directly or because of ASP.NET dependencies) and that in turn reference stuff from System.ComponentModel.TypeConverter.dll.  It has a gigantic closure with lots of stuff explicitly rooted, and is adding a huge amount of state to a trimmed app.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41266</IssueID>
    <RepoID>1</RepoID>
    <Title>Verify code covererage for deserialize read methods where `reader.BytesConsumed != utf8Json.Length`</Title>
    <Description>`System.Text.Json.JsonSerializer.ParseCore()` and  `System.Text.Json.JsonSerializer.Deserialize()` both have a check like this:
```cs
                if (reader.BytesConsumed != actualByteCount)
                {
                    ThrowHelper.ThrowJsonException_DeserializeDataRemaining(
                        actualByteCount, actualByteCount - reader.BytesConsumed);
                }
```

However that is not getting hit by any tests. In fact, it is likely that it is now dead code because the reader verifies all data is read when `isFinalBlock==true` is passed into the reader (as is the case for the two methods above).

We need to verify that the `if` statement is still valid or whether it should be removed.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41265</IssueID>
    <RepoID>1</RepoID>
    <Title>Add more Unicode validation tests</Title>
    <Description>Added some outerloop unit tests that parse the raw Unicode data files, then call various APIs on `char` and `Rune` passing every possible input. The control results (as parsed from the raw data files) are compared against the runtime's output for correctness.

This is largely in preparation for updating the runtime's stored Unicode table to version 12.1 (it's currently 11.0), including bringing forward invariant case mapping information.

There are no functional runtime changes in this PR.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41264</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Management.MangementScope Exception with Dotnet Core 3 Release</Title>
    <Description>I'm attempting to upgrade a project to Dotnet Core 3 which uses System.Management for WMI calls. When connecting to my MangementScope:

`var scope = new ManagementScope(@"\\computer\root\CIMV2", new ConnectionOptions());`

Program dies with the exception:

&gt; An unhandled exception has occurred while executing the request.
System.Runtime.InteropServices.MarshalDirectiveException: Cannot marshal 'parameter #3': Cannot marshal a string by-value with the [Out] attribute.
   at System.StubHelpers.StubHelpers.ThrowInteropParamException(Int32 resID, Int32 paramIdx)
   at System.Management.ManagementPath.GetWbemPath(IWbemPath wbemPath)
   at System.Management.ManagementScope.set_prvpath(ManagementPath value)
   at System.Management.ManagementScope..ctor(ManagementPath path, ConnectionOptions options)

I've seen the same Marshal exception on recent Core 3 preview posts that were supposedly fixed, but this issue seems to persist.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41263</IssueID>
    <RepoID>1</RepoID>
    <Title>Public static fields should require no suffix</Title>
    <Description>
    </Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41262</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpResponseMessage.TrailingHeaders blocks some headers</Title>
    <Description>HttpResponseMessage.TrailingHeaders re-used the HttpResponseHeaders collection that blocks some headers it thinks belong in HttpContentHeaders instead. With trailers you don't have that flexibility and this may block customer scenarios.

A header like `Content-MD5` is restricted.
- The header is received and stored in the collection.
- `response.TrailingHeaders.ToString()` does show the value.
- `response.TrailingHeaders.GetValues("Content-MD5");` throws:
```
System.InvalidOperationException: Misused header name. Make sure request headers are used with HttpRequestMessage, response headers with HttpResponseMessage, and content headers with HttpContent objects.
at System.Net.Http.Headers.HttpHeaders.GetHeaderDescriptor(String name)
at System.Net.Http.Headers.HttpHeaders.GetValues(String name)
at ResponseTrailers.Program.Main(String[] args) in C:\temp\ResponseTrailers\Program.cs:line 30
```
- `response.TrailingHeaders.TryGetValues("Content-MD5", out var values)` returns false.
- Enumeration is the only way to get the value:
```
foreach (var header in response.TrailingHeaders)
{
    Console.WriteLine($"Trailer {header.Key}: {string.Join(", ", header.Value)}");
}
```

I reviewed the content headers that would be blocked and didn’t find any that people are likely to use, but devs are unpredictable. 

Proposed change: HttpResponseMessage owns and creates the trailers collection. It could be changed to create it using a new internal constructor that specified different behavior. No public API changes would be required. Note there are plenty of headers that are prohibited in trailers that could be filtered by these rules instead of the content headers.
https://github.com/dotnet/corefx/blob/9161098ade5075a8c126b2d7eb98abbeadff2961/src/System.Net.Http/src/System/Net/Http/HttpResponseMessage.cs#L123-L126
https://github.com/dotnet/corefx/blob/9161098ade5075a8c126b2d7eb98abbeadff2961/src/System.Net.Http/src/System/Net/Http/Headers/HttpResponseHeaders.cs#L144-L145

The secondary issue is that HttpResponseHeaders has many properties that would not apply to trailers. That is a long term API wart, but not blocking.

.NET Core 3.0 based repro. Run Kestrel directly, not IIS Express.
[ResponseTrailers.zip](https://github.com/dotnet/corefx/files/3643612/ResponseTrailers.zip)
</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41261</IssueID>
    <RepoID>1</RepoID>
    <Title>Use slow path for CallInstruction returning enum value #40976</Title>
    <Description>#### Description
The System.Linq.Expressions interpreter treats the result of a call to method that returns an enum value as the underlying type rather than the enum type.
		
#### Customer Impact
Customer reported issue. Interpreting an Expression that calls a method returning an enum value can result in an `InvalidCastException`. See https://github.com/dotnet/corefx/issues/40968.

#### Regression?
Yes, a regression from 2.2.

#### Risk
Low. The fix is to revert an optimization added to the Expression interpreter in 3.0 for enum values.

Port of https://github.com/dotnet/corefx/pull/40976 and https://github.com/dotnet/corefx/pull/41218 to release/3.0.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41259</IssueID>
    <RepoID>1</RepoID>
    <Title>Using stable version for restore</Title>
    <Description>we just published the 3.0 ga release so no longer using a preview package


cc @ericstj @ViktorHofer @safern </Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41258</IssueID>
    <RepoID>1</RepoID>
    <Title>Build-tests target is failing for Linux-musl x64 leg</Title>
    <Description>Error
```
/__w/1/s/dir.traversal.targets(81,3): warning MSB4011: "/__w/1/s/Tools/Dumpling.targets" cannot be imported again. It was already imported at "/__w/1/s/Tools/tests.targets (558,3)". This is most likely a build authoring error. This subsequent import will be ignored. [/__w/1/s/src/tests.builds]
/__w/1/s/src/Microsoft.XmlSerializer.Generator/tests/Microsoft.XmlSerializer.Generator.Tests.csproj(59,5): error MSB3073: The command "/__w/1/s/bin/testhost/netcoreapp-Linux-Debug-x64/dotnet /__w/1/s/bin/AnyOS.AnyCPU.Debug/Microsoft.XmlSerializer.Generator.Tests/netcoreapp/dotnet-Microsoft.XmlSerializer.Generator.dll /__w/1/s/bin/AnyOS.AnyCPU.Debug/Microsoft.XmlSerializer.Generator.Tests/netcoreapp/Microsoft.XmlSerializer.Generator.Tests.dll --force --quiet" exited with code 134.
    1 Warning(s)
    1 Error(s)
```
https://dev.azure.com/dnceng/public/_build/results?buildId=352350&amp;view=logs
</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41260</IssueID>
    <RepoID>1</RepoID>
    <Title>WebClient - Connection: Keep-Alive ALWAYS present.</Title>
    <Description># Issue Title

WebClient is always sending 'Connection: Keep-Alive'

# General

I am having trouble with WebClient always getting timeout exception because the Connection header is always present in the request. 
</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41257</IssueID>
    <RepoID>1</RepoID>
    <Title>Message of UriFormatException does not include offending URI</Title>
    <Description>When reading an URI or even several URIs from configuration files as strings and instantiating them using new Uri(string), it would be helpful if the exception for invalid URIs (e.g. because of typos) would include the offending Uri (especially if the exception is in a logfile of a production system where debugging is not an easily available option). 

This would save the need to do a try-catch around every new Uri() and pretty-print the log message and allow safeguarding an entire initialization section with a more general try - catch(Exception) block without losing any information.

Example Code:

    static void UriFormatExceptionWithoutOffendingUri()
    {
      try
      {
        var uri1 = new Uri("http://www.valid.com");
        var uri2 = new Uri("foo//invalid");
        var uri3 = new Uri("https://www.secure.org");
      }
      catch (UriFormatException ex)
      {
        Console.WriteLine(ex.Message);
      }
    }

yields: "Invalid URI: The format of the URI could not be determined."

So we cannot easily determine which URI was invalid

desired: "Invalid URI: The format of the URI 'foo//invalid' could not be determined."

Would that be safe or do you think this would disclose too much information?</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41256</IssueID>
    <RepoID>1</RepoID>
    <Title>New interface implementing IDisposable exposing dispose state information </Title>
    <Description>Sometimes I could be convenient to know if IDisposable implementation is already disposed without exercising some try/catch about [ObjectDisposedException](https://docs.microsoft.com/en-us/dotnet/api/system.objectdisposedexception?view=netframework-4.8) or other/similar cases.

Instance:

    var request = (HttpWebRequest)WebRequest.Create("http://www.seznam.cz");
    
    using (var response = request.GetResponse())
    {
        using (var responseStream = response.GetResponseStream())
        {
            using (var streamReader = new StreamReader(responseStream))
            {
                responseStream.ReadByte();
                WriteLine("responseStream: " + responseStream.CanRead);
            }
    
            WriteLine("responseStream: " + responseStream.CanRead);
            responseStream.ReadByte();        
        }    
    }

`responseStream: True`
`responseStream: False`

`The request was aborted: The connection was closed unexpectedly.`
`  + System.Net.ConnectStream.Read(byte[], int, int)`
`  + System.IO.Stream.ReadByte()`

Instead of rely on exact implementation one could easily extract information needed from bool property.

    interface IDisposableExt : IDisposable { 
        bool AlreadyDisposed { get; }
    }

To **prevent braking change** this could be new interface implementing IDisposable.

**Implementation**
Yet nowadays developer is responsible for implementing IDisposable pattern properly. Specifically: call _GC.SuppressFinalize(this)_, release object resources only once, handle finalizer/consumer call case and further more responsibilities on this. Regard this pattern there already exists private field bool disposed.

`private bool disposed = false;`

Since that transforming such a private bool field to public bool property is little-effort change in responsibility (IDisposable pattern).

`bool AlreadyDisposed { get; }`</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41255</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190922.2
- **Date Produced**: 9/23/2019 1:07 AM
- **Commit**: c72abf4cd9025b4897ca43f3a7bf46e52725fbce
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19472.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19472.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19472.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41254</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve Vector&lt;uint&gt; and Vector&lt;ushort&gt; multiply</Title>
    <Description>I read on https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector-1?view=netcore-3.0 that Vector&lt;uint&gt; and Vector&lt;ushort&gt; multiplications do not map to intrinsics. Experimentation confirmed that.

However, they could simply map to `(v)pmulld` (when available) and `(v)pmullw`.

Current workaround:

        static Vector&lt;uint&gt; Multiply(Vector&lt;uint&gt; a, Vector&lt;uint&gt; b)
        {
            return Vector.AsVectorUInt32(Vector.AsVectorInt32(a) * Vector.AsVectorInt32(b));
        }

        static Vector&lt;ushort&gt; Multiply(Vector&lt;ushort&gt; a, Vector&lt;ushort&gt; b)
        {
            return Vector.AsVectorUInt16(Vector.AsVectorInt16(a) * Vector.AsVectorInt16(b));
        }

byte, sbyte, long and ulong could potentially be supported with multi-operation sequences, which is at least better than calling some scalar fallback, especially for the 8bit cases.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41253</IssueID>
    <RepoID>1</RepoID>
    <Title>The SSL connection could not be established, see inner exception. Authentication failed, see inner exception. The buffers supplied to a function was too small</Title>
    <Description>We have  .NET Core rest service hosted in service fabric on Azure. Every hour we have a scheduled task fetches data from a remote service. This fails every now and then with a SSL exception, from Application insights

&gt; The SSL connection could not be established, see inner exception. Authentication failed, see inner exception. The buffers supplied to a function was too small

Stack trace from application insights

&gt; System.Net.Http.HttpRequestException:
&gt;    at System.Net.Http.ConnectHelper+&lt;EstablishSslConnectionAsyncCore&gt;d__5.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Threading.Tasks.ValueTask`1.get_Result (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.HttpConnectionPool+&lt;CreateConnectionAsync&gt;d__44.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Threading.Tasks.ValueTask`1.get_Result (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.HttpConnectionPool+&lt;WaitForCreatedConnectionAsync&gt;d__49.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Threading.Tasks.ValueTask`1.get_Result (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.HttpConnectionPool+&lt;SendWithRetryAsync&gt;d__39.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.RedirectHandler+&lt;SendAsync&gt;d__4.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.DiagnosticsHandler+&lt;SendAsync&gt;d__2.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at Microsoft.Extensions.Http.Logging.LoggingHttpMessageHandler+&lt;SendAsync&gt;d__2.MoveNext (Microsoft.Extensions.Http, Version=2.2.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at Microsoft.Extensions.Http.Logging.LoggingScopeHttpMessageHandler+&lt;SendAsync&gt;d__2.MoveNext (Microsoft.Extensions.Http, Version=2.2.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1+ConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.HttpClient+&lt;FinishSendAsyncBuffered&gt;d__62.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.ExternalPart.PageroOnlineClient+&lt;ListFilesByAsync&gt;d__4.MoveNext (IC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core\ExternalPart\PageroOnlineClient.csIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 31)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.ExternalPart.PageroOnlineExternalPartAdapter+&lt;&gt;c__DisplayClass8_0+&lt;&lt;ListRemoteFilesAsync&gt;b__0&gt;d.MoveNext (IC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core\ExternalPart\PageroOnlineExternalPartAdapter.csIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 104)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Utils.Extensions.EnumerableExtensions+&lt;WhenAll&gt;d__4`1.MoveNext (IC.Eko.Utils, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Utils, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Utils\Extensions\EnumerableExtensions.csIC.Eko.Utils, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 53)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.ExternalPart.PageroOnlineExternalPartAdapter+&lt;ListRemoteFilesAsync&gt;d__8.MoveNext (IC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core\ExternalPart\PageroOnlineExternalPartAdapter.csIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 95)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.ExternalPart.PageroOnlineExternalPartAdapter+&lt;ListResponsesAsync&gt;d__6.MoveNext (IC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core\ExternalPart\PageroOnlineExternalPartAdapter.csIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 61)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.CommandHandlers.ExternalPart.FetchResponsesCommandHandler+&lt;Handle&gt;d__4.MoveNext (IC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core\CommandHandlers\ExternalPart\FetchResponsesCommandHandler.csIC.Eko.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 30)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at IC.Eko.Core.Cqs.Commands.CommandRunner+&lt;ExecuteCommand&gt;d__15.MoveNext (IC.Eko.Core.Cqs, Version=1.0.0.0, Culture=neutral, PublicKeyToken=nullIC.Eko.Core.Cqs, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: C:\git\projects\EKO\Eko\src\IC.Eko.Core.Cqs\Commands\CommandRunner.csIC.Eko.Core.Cqs, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null: 151)
&gt; Inner exception System.Security.Authentication.AuthenticationException handled at System.Net.Http.ConnectHelper+&lt;EstablishSslConnectionAsyncCore&gt;d__5.MoveNext:
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Security.SslState.StartSendAuthResetSignal (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.CheckCompletionBeforeNextReceive (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartSendBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.ProcessReceivedBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReadFrame (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReceiveBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.CheckCompletionBeforeNextReceive (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartSendBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.ProcessReceivedBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReadFrame (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReceiveBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.CheckCompletionBeforeNextReceive (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartSendBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.ProcessReceivedBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReadFrame (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReceiveBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.CheckCompletionBeforeNextReceive (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartSendBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.ProcessReceivedBlob (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.StartReadFrame (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.PartialFrameCallback (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Security.SslState.ThrowIfExceptional (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.InternalEndProcessAuthentication (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslState.EndProcessAuthentication (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslStream.EndAuthenticateAsClient (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Net.Security.SslStream+&lt;&gt;c.&lt;AuthenticateAsClientAsync&gt;b__47_1 (System.Net.Security, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt;    at System.Threading.Tasks.TaskFactory`1.FromAsyncCoreLogic (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)
&gt;    at System.Net.Http.ConnectHelper+&lt;EstablishSslConnectionAsyncCore&gt;d__5.MoveNext (System.Net.Http, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a)
&gt; Inner exception System.ComponentModel.Win32Exception handled at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw:

The code is nothing special, we use the `IHttpClientFactory` in conjuction with `services.AddHttpClient();` in `Startup.cs`</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41252</IssueID>
    <RepoID>1</RepoID>
    <Title>Added tests to cover all reachable branches when backed by JsonNode</Title>
    <Description>Solves [#41130](https://github.com/dotnet/corefx/issues/41130). Reachable branches covered.</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>27/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41251</IssueID>
    <RepoID>1</RepoID>
    <Title>Update dotnet-tools.json</Title>
    <Description>
    </Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41250</IssueID>
    <RepoID>1</RepoID>
    <Title>Socket: don't perform RST close on Dispose when user called Shutdown</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41189
Regressed in https://github.com/dotnet/corefx/pull/38804.

CC @halter73 @davidsh @wfurt @stephentoub @jkotalik</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41249</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Threading.Tasks.Parallel for nullability</Title>
    <Description>Contributes to https://github.com/dotnet/corefx/issues/40623</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41248</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Security.Cryptography.CryptographicException: Error occurred during a cryptographic operation when get end date from self signed certificate</Title>
    <Description># Issue Title

After update to .net core 3.0 (SDK 3.0.100-preview9-014004) we got a problem after generate self signed SSL-certificate.

# General

We generate self signed certificate with start date and end date. But after generate, call method **certificate.NotAfter** leads to throw exception 

```
System.Security.Cryptography.CryptographicException: Error occurred during a cryptographic operation.
  at Internal.Cryptography.Pal.OpenSslX509CertificateReader.ExtractValidityDateTime(IntPtr validityDatePtr)
  at Internal.Cryptography.Pal.OpenSslX509CertificateReader.get_NotAfter()
  at System.Security.Cryptography.X509Certificates.X509Certificate.GetNotAfter()
  at System.Security.Cryptography.X509Certificates.X509Certificate2.get_NotAfter().
```
When we used SDK 2.2 it worked correctly.

Generate certificate method:
```
		{
			var distinguishedName = new X500DistinguishedName($"CN={SslCertificate.DefaultCertName}");

			var keySizeBits = 2048;
			using (var rsa = RSA.Create(keySizeBits))
			{
				var request = new CertificateRequest(distinguishedName, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

				var certificateKeyUsageExtension = new X509KeyUsageExtension(X509KeyUsageFlags.DataEncipherment | X509KeyUsageFlags.KeyEncipherment , false);
				request.CertificateExtensions.Add(
					certificateKeyUsageExtension);

				
				var certificateServerValidationUsageExtension = new X509EnhancedKeyUsageExtension(
					new OidCollection { new Oid("1.3.6.1.5.5.7.3.1") }, false);
				request.CertificateExtensions.Add(
					certificateServerValidationUsageExtension);
				

				var startCertificateDate = DateTime.UtcNow.AddDays(-1);
				var endCertificateDate = DateTime.UtcNow.AddYears(50);
				var certificate = request.CreateSelfSigned(startCertificateDate, endCertificateDate);

				return certificate;
			}
```

After call _request.CreateSelfSigned(startCertificateDate, endCertificateDate)_ we got a certificate, from which it is impossible to get an end date. Method _certificate.NotAfter_ thrown exception.

The problem appears only on linux (Ubuntu 18.04). On windows it works correclty.

Can you help? How can we fix this problem?</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41247</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Net.Http.HttpRequestException</Title>
    <Description>version
.Net core 2.2 API

Docker File : FROM microsoft/dotnet:2.2-aspnetcore-runtime

dotnet publish xxxx_API.csproj -c Release

AWS ECS

Error:System.Net.Http.HttpRequestException: Too many open files in system —&gt; System.Net.Sockets.SocketException: Too many open files in system

想請問這是為什麼</Description>
    <CreatedDate>23/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41246</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190921.3
- **Date Produced**: 9/22/2019 1:59 AM
- **Commit**: 3fac26a68b0129375ffdffab989c2e576c401459
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19471.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19471.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19471.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>22/09/2019</CreatedDate>
    <ClosedDate>22/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41245</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190920.4
- **Date Produced**: 9/21/2019 12:55 AM
- **Commit**: 71c8b264f6dc8c32939cefbd15a8c8c3ffdf0a67
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19470.4
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19470.4
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19470.4

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>21/09/2019</CreatedDate>
    <ClosedDate>21/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41244</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json Deserialization issue</Title>
    <Description>I have a Json string starting like this:

````json
{"nameid":"1",
.............
"exp":1566506525
.............
}
````
the nameid is part of claims and is automatically serialized to string.

But my dto defines an integer:

````csharp
   [JsonPropertyName("nameid")]
        public int Id { get; set; }
............
  [JsonPropertyName("exp")]
        public int Expiration { get; set; }
````
When I Deserialize the Json in Blazor WebAssembly App I get this error:

WASM: Exception: The JSON value could not be converted to System.Int32. Path: $.nameid | LineNumber: 0 | BytePositionInLine: 13.

</Description>
    <CreatedDate>21/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41242</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] Type deriving from List&lt;T&gt; without parameterless constructor results in null ref</Title>
    <Description>```C#
class Program
{
    static void Main(string[] args)
    {
        var json = "[1, 2]";
        var x = JsonSerializer.Deserialize&lt;CustomList&lt;int&gt;&gt;(json);
    }
}

public class CustomList&lt;T&gt; : List&lt;T&gt;
{
    public CustomList(int x) { }
}
```

Stack trace:

```C#
Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at System.Text.Json.ReadStackFrame.CreateEnumerableValue(Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.HandleStartArray(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state)
   at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)
```

Reproduced using `Microsoft.NETCore.App 3.0.0-rc1-19456-20`

Adding a parameterless ctor works, but the exception message likely needs to say that a parameterless ctor needs to be declared.
</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41241</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Diagnostics.DiagnosticSource for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41240</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Reflection.DispatchProxy inconsistently fails for internal interfaces</Title>
    <Description>An undocumented limitation in `DispatchProxy.Create` is that it *sometimes* throws for various configurations of visibility. This seems to be a broader issue than the more specific #28403.

These configurations work:

1. public interface, public base class.
1. internal interface, internal base class, within the same assembly. But only when this is the *first* proxy ever generated.

These configurations *don't* work:

1. public interface, internal base class.
1. internal interface, internal base class, if another assembly has already provided an internal interface to generate a proxy for.

There were other odd configurations that similarly failed.

Since I've done this kind of feature before, I have a suspicion that the generated `ProxyBuilder` assembly includes an [`System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute`](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Reflection/SkipClrVisibilityChecks.cs#L159) for the assembly that defines the interface. 
The way I solved this is that each time I need to generate a proxy, [I evaluate all the assemblies that visibility checks must be skipped for](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Configuration/MetadataViewGenerator.cs#L114) and create a new dynamic assembly for each unique set that I get. So multiple proxies are supported, and we reuse dynamic assemblies where possible but when the set of dynamic assemblies exceed any previously discovered set we have to start a new assembly.

Adding more attributes to an existing dynamic assembly is ineffective because once you've loaded the first type from the assembly, the CLR caches these attributes and doesn't notice when new ones are added.</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41239</IssueID>
    <RepoID>1</RepoID>
    <Title>Implement FromOid and TryFromOid.</Title>
    <Description>Fixes #40558 </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41238</IssueID>
    <RepoID>1</RepoID>
    <Title>Serializer perf improvements</Title>
    <Description>Misc changes to gain ~7% on deserialize and ~3% on serialize for a simple, flat object (as in other recent PRs, the `MicroBenchmarks.Serializers.Json_FromString&lt;Location&gt;` and `MicroBenchmarks.Serializers.Json_ToString&lt;Location&gt;` were used.

There is also a gain for deserializing collections (~6%). There is no gain for serializing collections.

There is also a larger gain for deserializing small payloads which are under 85 bytes (255 / 3) since allocations are stack-based instead of pool-based.

Changes include:
- Avoid the byte[] alloc when deserializing strings (the buffer for transcoding string to byte[]). Now a pool or stack alloc is made.
- Removing several parameters due to exception helper changes. Added support to set an internal `AppendPathInformation` property to true which will cause the try\catch logic to add the path automatically. This avoids having to pass the reader and\or "stack state" to lower-level methods which may need to throw an exception that needs path information as part of its message.
- Remove a temporary struct assignment `WriteStackFrame current = state.Current` that caused a copy-by-value.
- Avoid verifying internal converters in release build for correctness (reading too much or too little).
- Improve the "IsProcessing" logic by using bit flags which helps when comparing more than one `ClassType`.
- Improve `SkipProperty()` by avoiding the direct comparison to the "missing property" singleton.
- Misc other one-line changes

**Deserialize Before**

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 2.554 us | 0.0091 us | 0.0081 us | 2.553 us | 2.540 us | 2.567 us |      0.4771 |           - |           - |              3056 B |
| SystemTextJson | 1.465 us | 0.0088 us | 0.0078 us | 1.464 us | 1.450 us | 1.477 us |      0.1053 |           - |           - |               680 B |

**Deserialize After**

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 2.565 us | 0.0151 us | 0.0134 us | 2.564 us | 2.541 us | 2.590 us |      0.4824 |           - |           - |              3056 B |
| SystemTextJson | 1.358 us | 0.0097 us | 0.0081 us | 1.357 us | 1.341 us | 1.375 us |      0.0701 |           - |           - |               448 B |

**Serialize Before**

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 1.438 us | 0.0106 us | 0.0099 us | 1.438 us | 1.414 us | 1.450 us |      0.2751 |           - |           - |              1736 B |
| SystemTextJson | 1.011 us | 0.0084 us | 0.0079 us | 1.007 us | 1.000 us | 1.024 us |      0.0891 |           - |           - |               584 B |

**Serialize After**

|         Method |       Mean |    Error |   StdDev |     Median |        Min |        Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |-----------:|---------:|---------:|-----------:|-----------:|-----------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 1,424.7 ns | 7.607 ns | 7.115 ns | 1,423.7 ns | 1,412.6 ns | 1,439.2 ns |      0.2746 |           - |           - |              1736 B |
| SystemTextJson |   970.9 ns | 7.285 ns | 6.458 ns |   968.5 ns |   964.4 ns |   982.3 ns |      0.0928 |           - |           - |               584 B</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41237</IssueID>
    <RepoID>1</RepoID>
    <Title>Move XLinq specific type description providers into its assembly</Title>
    <Description>Avoids cross-assembly private reflection.

@ericstj, does this cause any cyclic problems or anything like that?  I'm suspicious that it wasn't done this way in the first place.

cc: @krwq </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41236</IssueID>
    <RepoID>1</RepoID>
    <Title>Make Add/Remove UnsignedAttribute work with counter signers</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/41158

Extends #25449 which has added support for adding unsigned attributes to signers to also work with counter-signers which is a valid scenario for people wanting to add a timestamp to their counter-signatures.

FYI: @rrelyea @heng-liu @danmosemsft
cc: @vcsjones

Consider servicing for 3.1</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>21/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41235</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable better trimming of derived XmlReader/Writer-derived types</Title>
    <Description>XmlReader and XmlWriter have a bunch of internal derived types, which are created by the XmlReader/Writer.Create factory methods.  When settings are provided, almost any of these derived types could be created based on the data in the settings.  But when no settings are provided, there's only one answer as to which types are used.  In the XmlReader/Writer.Create overloads that don't take settings, we can avoid delegating to the more general factory and instead just construct the specific types we need; while this adds a small amount of duplication, it also means that if an app only uses the overloads that don't take settings, most of the derived types can be trimmed away by the linker during app publishing, saving ~100K.

(Granted, lots of uses of XmlReader/Writer.Create do need to pass settings, including the reader/writer used by XLINQ, which is used in a default MVC app, and as such in a default MVC app this change has negligable impact.  But it does help a basic console app that just reads and writes an XML file.)

cc: @krwq, @buyaa-n, @jkotas </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41234</IssueID>
    <RepoID>1</RepoID>
    <Title>Find a way to trim out ExcludeFromCodeCoverage attribute from published trimmed app</Title>
    <Description>Several assemblies that end up getting pulled into lots of apps (e.g. System.Linq) use `[ExcludeFromCodeCoverage]`.  There's generally no need for that in a published trimmed app, but it's sticking around and bringing with it System.Diagnostics.Tooling.dll.  While fairly small (5K) it's still another .dll that would be nice to remove.  This could be achieved in various ways, including:
- Stop using [ExcludeFromCodeCoverage] in these assemblies, which would impact all code coverage results
- `#if DEBUG` around such usage, which would then only impact code coverage release results
- Teach the linker used during app publishing to always strip this attribute

cc: @sbomer, @noahfalk </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41232</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190919.3
- **Date Produced**: 9/20/2019 1:58 AM
- **Commit**: 4da207dbb8c1d541ebf57a38bbd3506e65f427a0
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19469.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19469.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19469.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41231</IssueID>
    <RepoID>1</RepoID>
    <Title>[WIP] Re-enable functional http2 tests timing out in CI</Title>
    <Description>Investigates #39545. Do not merge.</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>09/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41230</IssueID>
    <RepoID>1</RepoID>
    <Title>CryptoNative_EvpDigestUpdate count as int32_t instead of size_t</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/41219

Also checked the other pal-headers in this cmake-project for any use of `size_t` in the signatures --&gt; didn't find any.

/cc: @bartonjs </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41229</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClientHandler functional test: replace remote server dependency</Title>
    <Description>Replaces remote server dependency for `HttpClientHandler_MaxResponseHeadersLength_Test.SetAfterUse_Throws` with LoopbackServer.

Fixes #41148</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41228</IssueID>
    <RepoID>1</RepoID>
    <Title>Diagnostic Activity Async issue</Title>
    <Description>Not sure if this is the right repo to report this but i'm experiencing an issue with `Activity`. This code works as i expect, in the child "scope" `Activity.Current` has a new `Id`:
```csharp
public async Task Execute()
{
    var activity = new Activity("Executing root").Start();
    Console.WriteLine($"Executing in root scope \t{Activity.Current.Id}");
    await Task.Delay(50);
    var childActivity = new Activity("Child scope");
    Console.WriteLine($"Executing in child scope \t{Activity.Current.Id}");
    await Task.Delay(50);
    childActivity.Stop();
    activity.Stop();
}
```
but when i move creation of child scope activity into another async method:
```csharp
public async Task Execute()
{
    var activity = new Activity("Executing root").Start();
    Console.WriteLine($"Executing in root scope \t{Activity.Current.Id}");
    await Task.Delay(50);
    var childActivity = await StartActivity("Child scope");
    Console.WriteLine($"Executing in child scope \t{Activity.Current.Id}");
    await Task.Delay(50);
    childActivity.Stop();
    activity.Stop();
}

private async Task&lt;Activity&gt; StartActivity(string activityName)
{
    await Task.Delay(50);
    return new Activity(activityName).Start();
}
```
..then both these console logs have the same `Activity.Current.Id`. 
Reading this [documentation](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md), i would assume that it would work in async contexts aswell?:
&gt;The current activity is exposed as static variable, Activity.Current, and flows with call context, including async calls, so that it is available in every Start/Stop event callback.

I experience the same behavior of package `System.Diagnostics.DiagnosticSource` both in version `4.5.1` and the latest pre-release `4.6.0-rc1.19456.4`.</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41227</IssueID>
    <RepoID>1</RepoID>
    <Title>add StartsWith Surrogates test cases</Title>
    <Description>
    </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41226</IssueID>
    <RepoID>1</RepoID>
    <Title>CryptographicException on .NET Core 3, Windows only "The specified RSA parameters are not valid; both Exponent and Modulus are required fields."</Title>
    <Description>I'm getting the following error when creating RSA from RSAParameters, but only on Windows for .NET Core 3.0. This works on .NET 4.7.2, .NET Core 2.1 (Windows and macOS), and .NET Core 3.0 (macOS).

```
System.Security.Cryptography.CryptographicException: The specified RSA parameters are not valid; both Exponent and Modulus are required fields.
   at System.Security.Cryptography.RSAImplementation.RSACng.ImportParameters(RSAParameters parameters)
   at System.Security.Cryptography.RSA.Create(RSAParameters parameters)
```

## Repro
```c#
using System;
using System.Security.Cryptography;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        var parameters = new RSAParameters
        {
            Modulus = new byte[] { 0, 198, 19, 173, 163, 198, 96, 251, 190, 35, 45, 77, 159, 113, 248, 230, 172, 43, 69, 139, 187, 192, 228, 253, 66, 48, 221, 32, 243, 161, 105, 84, 113, 54, 227, 201, 142, 233, 118, 27, 2, 23, 33, 36, 83, 137, 232, 116, 109, 112, 44, 249, 73, 223, 56, 32, 51, 228, 0, 47, 185, 95, 95, 242, 143, 218, 137, 130, 124, 189, 143, 118, 193, 59, 4, 156, 29, 222, 113, 221, 130, 153, 69, 7, 197, 81, 150, 94, 86, 209, 1, 31, 209, 49, 111, 62, 132, 105, 167, 170, 241, 79, 218, 202, 179, 67, 170, 145, 169, 36, 228, 99, 6, 39, 235, 166, 189, 17, 242, 167, 217, 192, 36, 120, 209, 176, 89, 240, 248, 34, 155, 25, 130, 64, 53, 85, 50, 20, 17, 248, 59, 69, 179, 149, 74, 22, 122, 162, 191, 150, 33, 138, 157, 129, 76, 16, 0, 220, 103, 77, 183, 21, 25, 101, 121, 50, 130, 190, 208, 19, 48, 153, 62, 229, 76, 39, 204, 64, 120, 72, 244, 197, 108, 197, 127, 29, 200, 248, 161, 69, 230, 249, 175, 1, 236, 45, 231, 31, 103, 189, 85, 79, 14, 123, 137, 70, 71, 40, 137, 217, 73, 211, 206, 173, 192, 214, 175, 204, 155, 229, 70, 31, 195, 238, 206, 116, 2, 50, 238, 15, 53, 60, 35, 32, 89, 126, 233, 219, 147, 240, 39, 71, 174, 202, 206, 220, 250, 156, 80, 132, 224, 169, 146, 169, 234, 184, 127 },
            Exponent = new byte[] { 1, 0, 1 },
            D = new byte[] { 76, 191, 255, 62, 64, 117, 255, 213, 178, 231, 176, 246, 33, 65, 98, 144, 63, 204, 24, 210, 205, 113, 109, 56, 162, 154, 108, 84, 58, 173, 7, 141, 62, 201, 144, 166, 17, 140, 51, 246, 225, 99, 116, 33, 242, 131, 225, 233, 45, 216, 31, 88, 34, 104, 43, 2, 48, 76, 106, 49, 151, 229, 35, 165, 221, 245, 254, 91, 187, 79, 197, 162, 37, 238, 41, 87, 225, 131, 153, 99, 43, 100, 118, 24, 92, 254, 184, 219, 70, 236, 250, 153, 34, 96, 138, 134, 224, 49, 153, 169, 27, 90, 25, 196, 208, 105, 93, 59, 127, 18, 7, 212, 176, 207, 60, 178, 114, 43, 230, 34, 23, 179, 138, 37, 38, 2, 19, 190, 67, 117, 14, 70, 163, 166, 15, 163, 36, 228, 191, 59, 16, 177, 247, 114, 183, 114, 242, 67, 60, 41, 28, 97, 228, 156, 128, 219, 97, 234, 78, 43, 8, 77, 190, 41, 29, 13, 242, 96, 71, 249, 29, 131, 152, 28, 45, 104, 215, 29, 2, 7, 89, 83, 193, 135, 107, 229, 4, 150, 153, 108, 42, 115, 151, 145, 64, 58, 68, 73, 138, 101, 87, 104, 173, 163, 143, 193, 163, 120, 4, 60, 82, 187, 245, 143, 150, 62, 255, 130, 17, 196, 131, 214, 102, 114, 244, 137, 209, 14, 8, 66, 88, 229, 72, 74, 13, 104, 32, 236, 119, 126, 138, 128, 5, 255, 166, 15, 104, 137, 25, 79, 91, 32, 192, 224, 139, 145 },
            P = new byte[] { 0, 234, 73, 179, 109, 136, 112, 92, 137, 136, 238, 24, 124, 25, 51, 139, 96, 207, 59, 247, 2, 88, 147, 38, 158, 192, 61, 57, 101, 141, 244, 172, 214, 250, 38, 140, 75, 0, 140, 111, 154, 178, 153, 50, 168, 118, 164, 152, 48, 174, 72, 7, 51, 63, 121, 84, 213, 139, 25, 83, 199, 229, 186, 246, 55, 57, 230, 161, 221, 166, 125, 114, 157, 64, 212, 24, 178, 26, 67, 13, 154, 142, 191, 253, 248, 183, 238, 225, 232, 205, 43, 44, 101, 204, 247, 177, 91, 223, 63, 155, 219, 209, 206, 219, 18, 72, 89, 197, 212, 186, 231, 89, 175, 84, 202, 20, 53, 133, 77, 38, 8, 50, 116, 56, 123, 94, 67, 78, 19 },
            Q = new byte[] { 0, 216, 110, 230, 24, 21, 240, 176, 181, 20, 62, 150, 117, 123, 72, 166, 206, 147, 14, 232, 207, 15, 66, 157, 140, 87, 242, 188, 204, 214, 88, 44, 186, 55, 53, 81, 143, 129, 141, 79, 104, 103, 136, 134, 178, 236, 223, 90, 208, 12, 80, 15, 181, 172, 161, 146, 159, 184, 46, 246, 177, 7, 234, 0, 238, 13, 136, 87, 112, 70, 63, 218, 129, 215, 93, 204, 243, 181, 37, 195, 136, 238, 49, 33, 190, 104, 98, 247, 7, 148, 120, 7, 56, 137, 135, 113, 141, 166, 39, 0, 143, 198, 225, 230, 206, 65, 142, 18, 76, 115, 18, 61, 216, 103, 176, 6, 57, 22, 92, 134, 88, 193, 120, 255, 152, 188, 176, 201, 101 },
            DP = new byte[] { 29, 65, 198, 222, 78, 195, 121, 74, 211, 134, 168, 24, 23, 45, 144, 162, 46, 62, 214, 193, 188, 61, 227, 252, 191, 20, 230, 46, 0, 100, 37, 145, 82, 251, 173, 89, 80, 96, 57, 47, 160, 77, 241, 61, 136, 83, 85, 141, 254, 181, 143, 240, 158, 100, 144, 107, 122, 75, 87, 99, 7, 21, 41, 218, 11, 168, 249, 93, 172, 132, 205, 227, 69, 77, 55, 40, 70, 143, 73, 11, 155, 247, 237, 199, 57, 112, 227, 85, 39, 9, 213, 41, 129, 71, 13, 38, 227, 226, 21, 156, 133, 190, 199, 44, 169, 76, 76, 160, 28, 22, 247, 228, 37, 58, 118, 251, 152, 1, 226, 85, 243, 182, 255, 182, 168, 54, 207, 113 },
            DQ = new byte[] { 106, 226, 81, 149, 129, 120, 76, 252, 16, 20, 92, 159, 134, 19, 185, 244, 248, 96, 251, 142, 14, 30, 58, 201, 237, 64, 254, 6, 54, 176, 114, 222, 63, 151, 128, 64, 219, 156, 218, 163, 87, 197, 239, 167, 123, 29, 78, 174, 193, 245, 227, 220, 55, 117, 207, 128, 59, 40, 78, 65, 221, 3, 174, 19, 225, 240, 252, 37, 129, 59, 213, 128, 27, 200, 194, 7, 116, 229, 66, 108, 100, 29, 53, 105, 224, 9, 71, 175, 161, 157, 169, 11, 61, 183, 250, 215, 22, 63, 218, 162, 38, 120, 183, 80, 18, 197, 195, 185, 167, 118, 81, 190, 134, 110, 66, 148, 124, 187, 146, 201, 80, 58, 158, 23, 98, 207, 247, 149 },
            InverseQ = new byte[] { 35, 3, 31, 227, 254, 71, 57, 5, 125, 39, 137, 220, 196, 105, 22, 167, 125, 36, 211, 150, 39, 113, 235, 171, 111, 121, 231, 48, 214, 37, 226, 39, 59, 124, 0, 23, 125, 34, 147, 31, 106, 74, 117, 50, 244, 188, 42, 101, 201, 216, 225, 198, 247, 248, 78, 97, 171, 1, 49, 6, 100, 209, 214, 92, 254, 147, 34, 192, 158, 200, 17, 63, 113, 197, 148, 235, 48, 214, 121, 91, 104, 171, 14, 152, 249, 46, 153, 64, 11, 230, 27, 117, 91, 82, 85, 144, 95, 66, 157, 184, 72, 3, 122, 161, 92, 154, 208, 163, 227, 248, 154, 207, 246, 252, 184, 121, 224, 95, 162, 233, 76, 195, 56, 111, 186, 76, 39, 119 },
        };

        try
        {
            var key = RSA.Create(parameters); // this throws on .NET Core 3.0, Windows only

            var encrypted = key.Encrypt(Encoding.ASCII.GetBytes("Hello"), RSAEncryptionPadding.Pkcs1);
            Console.WriteLine($"encrypted = {BitConverter.ToString(encrypted)}");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(ex.ToString());
        }
    }
}
```
```xml
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;netcoreapp2.1;netcoreapp3.0;net472&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
```

![image](https://user-images.githubusercontent.com/2696087/65304325-34608080-db35-11e9-8004-eec7088dc4a1.png)

### Info

Microsoft.NETCore.App 3.0.0-rc1-19456-20

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41225</IssueID>
    <RepoID>1</RepoID>
    <Title>Use PooledByteBufferWriter in Utf8JsonWriter</Title>
    <Description>Currently `Utf8JsonWriter` uses `ArrayBufferWriter&lt;byte&gt;` instead of `PooledByteBufferWriter`:
https://github.com/dotnet/corefx/blob/5bc2806f33090e78b38fafe4d5b46d5a0a4c1f08/src/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.cs#L46
Is there any reason behind it? 

Recently I did a benchmark on `System.Text.Json`, and I found that the async serialization method (writes to `Stream`) uses less memory than the synchronized method (writes to `Utf8JsonWriter` which writes to `Stream`). I believe the use of `ArrayBufferWriter&lt;byte&gt;` in `Utf8JsonWriter` is the reason why synchronized consumes more memory.

|                     Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|           System.Text.Json | 578.6 ns | 1.7358 ns | 1.6236 ns | 578.4 ns | 576.3 ns | 582.2 ns |      0.0975 |           - |           - |               616 B |
|     System.Text.Json_Async | 592.6 ns | 1.3711 ns | 1.2825 ns | 592.6 ns | 590.9 ns | 594.8 ns |      0.0471 |           - |           - |               304 B |

_Reference: [https://github.com/Martin1994/JsonJitSerializer/blob/7ad4ba036b8becc53d7beed8abaeb399a88437d7/README.md#json_tostream_loginviewmodel_](https://github.com/Martin1994/JsonJitSerializer/blob/7ad4ba036b8becc53d7beed8abaeb399a88437d7/README.md#json_tostream_loginviewmodel_)_

Since I build a serialization library on top of `Utf8JsonWriter`, my library, as well as all the third party libraries who make use of `Utf8JsonWriter`, will see the same thing that the async serialization method consumes less memory.</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>28/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41224</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve test coverage for Span-based globalization APIs</Title>
    <Description>
    </Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41223</IssueID>
    <RepoID>1</RepoID>
    <Title>Address SqlXml to CreateSqlReader dependency for assembly size</Title>
    <Description>System.Data.Common.dll contains the SqlXml type.  This type uses reflection to access the internal CreateSqlReader method in System.Private.Xml.dll:
https://github.com/dotnet/corefx/blob/5bc2806f33090e78b38fafe4d5b46d5a0a4c1f08/src/System.Data.Common/src/System/Data/SQLTypes/SqlXml.cs#L134
To ensure that this internal method (which has no other consumers) isn't trimmed away, System.Private.Xml lists this method in its ILLinkTrim.xml file:
https://github.com/dotnet/corefx/blob/5bc2806f33090e78b38fafe4d5b46d5a0a4c1f08/src/System.Private.Xml/src/ILLinkTrim.xml#L3-L6
which means that even if SqlXml isn't used by an app, this method and everything it depends on can't be trimmed away.  That ends up keeping alive ~300KB of code that's likely otherwise unused.  We should address this somehow, e.g. https://github.com/dotnet/corefx/issues/41201 (though this is a case of the cross-assembly private reflection mentioned there).</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41222</IssueID>
    <RepoID>1</RepoID>
    <Title>Set TreatWarningsAsErrors to false in native build for now</Title>
    <Description>Relates to: https://github.com/dotnet/corefx/issues/41077

Let's disable warnings as errors for native build completely, as the outer node is now marking it as an error, but the inner node as a warning, which thankfully doesn't stop the build, but it confuses people thinking the build actually did fail, when it didn't.

cc: @stephentoub @ericstj @ViktorHofer </Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41221</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: optimize HPACK decoding.</Title>
    <Description>Our HPACK decoder looks like it can be improved. We should write some benchmarks and see if any optimizations can be made.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41220</IssueID>
    <RepoID>1</RepoID>
    <Title>XmlSerializer.GenerateSerializer should not be in System.Private.Xml</Title>
    <Description>System.Private.Xml contains all of the code for generating an assembly as the core logic behind the sgen tool:
https://github.com/dotnet/corefx/tree/master/src/Microsoft.XmlSerializer.Generator
The vast majority of the functionality here isn't used by anything other than sgen, which calls XmlSerializer.GenerateSerializer via reflection, and is the only caller of that method.  This functionality should be removed from XmlSerializer in System.Private.Xml and moved into sgen.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41219</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect P/Invoke signature for CryptoNative_EvpDigestUpdate</Title>
    <Description>The `count` argument is defined as `int` in managed code and as `size_t` in native code:
https://github.com/dotnet/corefx/blob/6074cfc995d7968fcdbc7f707acff0c6284c6ae9/src/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.EVP.cs#L22-L23
https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/Native/Unix/System.Security.Cryptography.Native/pal_evp.h#L43</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41218</IssueID>
    <RepoID>1</RepoID>
    <Title>Additional enum tests for System.Linq.Expressions.Interpreter.CallInstruction</Title>
    <Description>Related to #40968</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41217</IssueID>
    <RepoID>1</RepoID>
    <Title>UWP Backport: QueryDirectoryFile requires 64 bit alignment to work on ARM32</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/33563 (requested UWP backport)

Originally addressed in 3.0: https://github.com/dotnet/corefx/pull/33713
And already backported for 2.2: https://github.com/dotnet/corefx/pull/33754

Cherry-picked from: a75f96a105aa6dd6242d84ae40333df9a1d44c1c

Original commit message:
&gt; QueryDirectoryFile requires 64 bit alignment to work on ARM32. Using Marshal.AllocHGlobal instead of byte[] will do that (and avoid the need to pin).

Please add the necessary labels/project/milestone.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41216</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190920.9
- **Date Produced**: 9/20/2019 9:08 PM
- **Commit**: 84778cd659cc0509e9ebf651c73f2341ae82df8c
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19470.9
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19470.9
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19470.9
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19470.9

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)







[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190923.5
- **Date Produced**: 9/24/2019 4:13 AM
- **Commit**: d7f6c5e944e500f44b8536aed8f6a05320f7729a
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19473.5
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19473.5
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19473.5

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)





[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190923.2
- **Date Produced**: 9/23/2019 8:40 PM
- **Commit**: 06c90ba9889b06c6f340e028bb8e11888e4784bf
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19473.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)





[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190923.4
- **Date Produced**: 9/23/2019 10:04 PM
- **Commit**: 485441f79ead7878af206a6af61a300e1458616a
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19473.4
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19473.4

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)





















</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41215</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Support sending frame padding</Title>
    <Description>Consider adding support for frame padding in HTTP2. [The RFC](https://httpwg.org/specs/rfc7540.html#padding) is vague on the benefits of this as TLS itself also supports padding.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41214</IssueID>
    <RepoID>1</RepoID>
    <Title>Diagnostics.Process on OSX should try harder to provide ProcessName</Title>
    <Description>It seems like the ProcessName should be more than an empty string. On OSX this is pretty egregious as the first couple 100 processes don't have a name. Providing the path to the executable could be a very reasonable fallback. (or perhaps `pbi_name` has this already?)

I know that proc id 0 is the exception to this rule, but still ProcessName should be useful.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41213</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Proxy over HTTP2</Title>
    <Description>Consider adding support for [CONNECT over HTTP2](https://httpwg.org/specs/rfc7540.html#CONNECT). The ability to multiplex streams could save precious latency.

Not sure if any proxy servers support HTTP2 yet.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41212</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Support stream priority/dependency</Title>
    <Description>Consider implementing [stream prioritization and dependencies](https://httpwg.org/specs/rfc7540.html#StreamPriority). This could be useful in bandwidth/latency-sensitive scenarios.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41211</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unused StringExtensions.cs from a couple projects</Title>
    <Description>
    </Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41210</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Support nullable values in dictionaries</Title>
    <Description>Ports #40991 to 3.1

## Description
Prior to this change, we were omitting the contents when serializing dictionaries with nullable values e.g. `Dictionary&lt;string, float?&gt;` (or throwing `NotSupportedError` for generic `IDictionary`).

This change fixes this issue.

## Customer Impact

Customers will now be able to serialize dictionaries with nullable values e.g. `Dictionary&lt;string, float?&gt;`,  `IDictionary&lt;string, DateTime?&gt;`.

Fixes https://github.com/dotnet/corefx/issues/40936 in 3.1.

## Regression?

No.

## Risk

Low. This PR does not modify already existing features, so the possibility of breaking functionality or introducing regressions is limited. Extensive test cases were added to ensure that this new future works correctly.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41209</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Support sending dynamic headers</Title>
    <Description>We should consider how we can support sending of dynamic headers in HTTP2.

A simple mechanism would be to special-case headers we know get sent very frequently and don't often change with HttpClient workloads: Host, Authority, Content-Type, possibly Accept, etc. -- this would be pretty low overhead and probably worth it.

A more advanced way would allow for all headers. Many APIs have some common headers used across all requests, so this would target them. Because dynamic headers can only be replaced in FIFO order, an efficient algorithm to choose what goes dynamic will need some thought. From what I can tell, node.js and http.sys both do the easiest option of simply sending every header as dynamic.

Another thought is if we can expose an API to let users do this themselves. The design of `HttpClient` doesn't lend itself to giving precise control over this, but I think we might be able to do something a bit broader here still. Ideally we would not add headers to the dynamic table which are one-off, and so something like flagging headers as "cache key/value", "cache key", "no cache" would be nice.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41208</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Support receiving dynamic headers</Title>
    <Description>We disabled receipt of dynamic headers for 3.0 by setting max dynamic table size = 0.

A number of bugs relating to this were fixed in 5.0, and we should consider re-enabling the feature.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41207</IssueID>
    <RepoID>1</RepoID>
    <Title>networking problem  .net core with Centos os</Title>
    <Description># Issue Title

Absolutely low performance on Centos operation systems

# General

We are using .net core &amp; Centos operation system.
We are doing load testing. We have bots, bots are developed on .net core 2.1 &amp; hosted on cetnos os. Bots open connection to another application on another machine and each bot has opened websocket connection to another application. We try to emulate real users. Bots send rest request to another application and receive results via web socket. 
When we run our load tool on centos 200 bots took 100% machine utilization.
When we run the same load tool on windows os 1000 bots took 40% machine utilization.
I suggest that it is problem with linux network stack &amp; . net core.
May be we need to do some tuning of our linux machine. 
Or you know what could be causing this?
Thanks, Ivan.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41202</IssueID>
    <RepoID>1</RepoID>
    <Title>Port: Fix icon entry selection (#41048)</Title>
    <Description>### Description
We weren't checking the color depth properly when choosing an icon entry to extract from an icon file. This change fixes the regression and adds a test to validate that we're picking the appropriate color-depth.

### Customer Impact
Icons will load the first icon of the correct size, which often will not be the right color depth. WinForms apps may see black &amp; white icons instead of the normal full color icon, for example. Customer reported in https://github.com/dotnet/winforms/issues/1825

### Regression?
Yes.

### Risk
Small, undoing a mistake in the affected line of code.

Fixes #41068</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41201</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider PreserveDependencyAttribute to help linker</Title>
    <Description>We currently use ILLinkTrim.xml files to express APIs, whether public or non-public, that should not be trimmed away by the linker, whether during the first trimming phase when we build the assemblies or the second optional trimming phase when an app is deployed with trimming.

However, these declarations are causing us to keep around a lot more state than is necessary, for two reasons:
1. The presence of such an .xml file is forcing the binary to be preserved, even if nothing from it ends up being used.
2. It doesn't provide the ability to say "only keep XYZ if ABC is used".

For example, in System.Data.Common, we have an ILLinkTrim.xml file that says the DataTableTypeConverter's .ctor() should be preserved.  That's because the DataView.Table property is annotated with a TypeConverterAttribute:
https://github.com/dotnet/corefx/blob/19b304f7815894b13cb61e87e1c9eac49a474c7e/src/System.Data.Common/src/System/Data/DataView.cs#L473
and the type converter infrastructure needs access to that ctor to instantiate it via reflection.  However, because that .ctor is mentioned in the .xml file, it'll never be trimmed away, even if DataView.Table itself isn't used.  And DataTableTypeConverter's ctor references DataTable, which in turn references a whole bunch of stuff.

The same goes for other assemblies, e.g. System.Text.Json, System.Private.DataContractSerialization, etc.

We should consider instead exposing and using the PreserveDependencyAttribute that the linker already has some support for (though coreclr and corefx are currently using too old a version), e.g.
```C#
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
    internal sealed class PreserveDependencyAttribute : Attribute
    {
        public PreserveDependencyAttribute(string? memberSignature)
        {
            MemberSignature = memberSignature;
        }

        public PreserveDependencyAttribute(string? memberSignature, string typeName)
        {
            MemberSignature = memberSignature;
            TypeName = typeName;
        }

        public PreserveDependencyAttribute(string? memberSignature, string typeName, string assemblyName)
        {
            MemberSignature = memberSignature;
            TypeName = typeName;
            AssemblyName = assemblyName;
        }

        public string? MemberSignature { get; set; }
        public string? TypeName { get; set; }
        public string? AssemblyName { get; set; }

        public string? Condition { get; set; }
    }
}
```

This, or something like it, has the ability to specify not just that something is needed, but why that thing is needed, in a way where if the reason for it needing to be there gets trimmed away, so too does the need.  It also has the benefit that the dependency is expressed in the code rather than in a separate asset.

cc: @sbomer, @jkotas, @marek-safar </Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41200</IssueID>
    <RepoID>1</RepoID>
    <Title>Regex Match Hangs forever</Title>
    <Description>During processing with one of our applications we ran into an issue with Regex Match method hanging forever with a specific regular expression and specific text. See attached code for details.
[BadRegex.zip](https://github.com/dotnet/corefx/files/3631645/BadRegex.zip)
</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41199</IssueID>
    <RepoID>1</RepoID>
    <Title>Compile to x86 can not run at x64 platform</Title>
    <Description>I have a library file which is writen by C language and compiled to x86.

In my C# project, I need call the C library by PInvoke, so I set the PlatformTarget property to x86 in .csproj file.

``` xml
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;netcoreapp3.0;net461&lt;/TargetFrameworks&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
    &lt;Prefer32Bit&gt;true&lt;/Prefer32Bit&gt;
    &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;
  &lt;/PropertyGroup&gt;
```
When I run the app at windows 7 x64:
1) for net461, it works fine
2) for netcoreapp3.0, it throws a System.BadImageFormatException.


</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41198</IssueID>
    <RepoID>1</RepoID>
    <Title>NullReferenceException in System.Text.Json.Deserialize&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt;</Title>
    <Description>System.Text.Json fail with a NullReferenceException trying to deserialized nested objects/arrays to IEnumerable&lt;IDictionary&lt;&gt;&gt; type.

This sample program will trigger this issues on .Net Core 3.0-rc1:

```
using System;
using System.Collections.Generic;
using System.Text.Json;

namespace CustomViewSplit
{
    class Program
    {
        static void Main(string[] args)
        {
            string workingJson = @"[
  {
    ""a"": ""A"",
    ""b"" :  ""B""
  }
]";

            string brokenJson = @"[
  {
    ""a"": ""A"",
    ""b"" :  {} 
  }
]";


            foreach (string json in new[] {workingJson, brokenJson})
            {
                byte[] bytes = System.Text.Encoding.UTF8.GetBytes(json);
                ReadOnlySpan&lt;byte&gt; readonlySpan = new ReadOnlySpan&lt;byte&gt;(bytes);

                // This will throw a NullReferenceException for brokenJson and alsoBroken
                var enumerable = JsonSerializer.Deserialize&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt;(readonlySpan);
            }
        }
    }
}
```
</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41197</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190918.2
- **Date Produced**: 9/18/2019 8:56 PM
- **Commit**: a28ee518026d2c5d477472f44d391cf9379fc7cb
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19468.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19468.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.GenAPI** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.GenFacades** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 5.0.0-beta.19468.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 5.0.0-beta.19468.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190918.6
- **Date Produced**: 9/18/2019 11:51 PM
- **Commit**: 30c4a25a9a675d632b6e7180e53a87e6fcacb909
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19468.6
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19468.6
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19468.6

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190918.14
- **Date Produced**: 9/19/2019 4:54 AM
- **Commit**: 19b304f7815894b13cb61e87e1c9eac49a474c7e
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19468.14
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19468.14

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190918.1
- **Date Produced**: 9/18/2019 12:50 PM
- **Commit**: 718c2c52e2855fe9001467192c5def98790a19cd
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19468.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41196</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add Dictionary.ToArray()</Title>
    <Description>I'd like to propose an API to the Dictionary class:

```cs
public class Dictionary&lt;TKey, TValue&gt; : IDictionary&lt;TKey, TValue&gt;, IDictionary, ...
{
    public KeyValuePair&lt;TKey, TValue&gt; ToArray();
}
```</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41195</IssueID>
    <RepoID>1</RepoID>
    <Title>Adds a new regex option - RegexOptions.AnyNewLine.</Title>
    <Description>Adds a new regex option - RegexOptions.AnyNewLine, which supports '\r' (old mac), '\n' (unix), and '\r\n' (windows) as line endings for the '$' (EOL) operator.

Fixes #28410</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41194</IssueID>
    <RepoID>1</RepoID>
    <Title>Test failure:System.Drawing.Tests.FontTests.FromLogFont_ValidLogFont_ReturnsExpected(fontStyle: Bold, weight: -2147483648, charSet: 0)</Title>
    <Description>Test `System.Drawing.Tests.FontTests.FromLogFont_ValidLogFont_ReturnsExpected(fontStyle: Bold, weight: -2147483648, charSet: 0)` has failed:

```
Error message
System.ArgumentException : Only TrueType fonts are supported. This is not a TrueType font.

Stack trace
   at System.Drawing.Font.FromLogFontInternal(LOGFONT&amp; logFont, IntPtr hdc) in /_/src/System.Drawing.Common/src/System/Drawing/Font.Windows.cs:line 268
   at System.Drawing.Font.FromLogFont(Object lf, IntPtr hdc) in /_/src/System.Drawing.Common/src/System/Drawing/Font.Windows.cs:line 326
   at System.Drawing.Font.FromLogFont(Object lf) in /_/src/System.Drawing.Common/src/System/Drawing/Font.Windows.cs:line 247
   at System.Drawing.Tests.FontTests.FromLogFont_ValidLogFont_ReturnsExpected(FontStyle fontStyle, Int32 weight, Byte charSet) in /_/src/System.Drawing.Common/tests/FontTests.cs:line 658
```

Build: -[20190918.39](https://dnceng.visualstudio.com/public/_build/results?buildId=359768
)(Master)

Details:
https://helix.dot.net/api/2019-06-17/jobs/d2810871-f05f-4b10-8aac-475b8fc1a1d9/workitems/System.Drawing.Common.Tests/console</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41193</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable Stop-&gt;Start on HttpListener</Title>
    <Description>Resolves #39552.

Enables a HttpListener to be restarted once it has been stopped.

Additionally, fixes some race conditions when accessing `DisconnectResults`.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41192</IssueID>
    <RepoID>1</RepoID>
    <Title>Can't reliably determine if connection was successful when using HttpClient</Title>
    <Description>If an exception is thrown from a call to HttpClient.SendAsync( ) there's no way to be certain that the connection itself failed, vs. e.g., a timeout before trying to read the response.
While there are certain SocketException SocketError values that can only happen if the DNS lookup or connection fails, if there is a) a failure negotiating the SSL handshake or b) a timeout trying to connect, there's no reliable way to programmatically distinguish this from other possible errors.
This is important in many real world applications where if there's any possibility that the remote server did receive all or part of the request, but a network or system failure occurred after this point, it's necessary to attempt to contact that server again to determine whether it did process the request.
If the HttpClient had a way of determine how many bytes had been successfully sent to the remote server before the exception occurred, that would solve it nicely too.

</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41191</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix trimming of System.Net.NetworkInformation</Title>
    <Description>Same as https://github.com/dotnet/corefx/pull/41180, but for NetworkInformation rather than Ping.</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41190</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix DeflateStream.CopyTo for concatenated payloads</Title>
    <Description>Support for concatenated payloads was added in 55f2293ddda3c972fcc2d94915b03bc8556e8c9b.

With this DeflateStream will continue to attempt to read after it
encounters a payload footer if it has more data left and that data
begins with the proper header format.

This caused a bug in CopyTo where it assumed that if the inflater
returned 0 bytes inflated it was done with that buffer.
This can happen in a couple cases:
1. The footer for a payload occurs on a buffer boundary, such that the
first call to Inflate for that buffer reads only the footer and returns
0 data. This was reported by a customer.
2. One of the concatenated payloads is 0 length.

Previously the CopyTo implementation would skip the remainder of the
buffer in this case, then proceed with a new buffer.  This new buffer
would start and an arbitrary offset in the compressed data, which likely
isn't a valid header, and an exception would be thrown:
```
System.IO.InvalidDataException : The archive entry was compressed using an unsupported compression method.
```

Fix this by continuing to copy so long as the we haven't run out of
data, regardless of wether or not the inflater happens to read a 0
length chunk.

Fixes https://github.com/dotnet/corefx/issues/40710</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>25/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41189</IssueID>
    <RepoID>1</RepoID>
    <Title>Possible Socket Regression in .NET Core 5.0 on Linux</Title>
    <Description>ASP.NET Core has tests where the client reads response data at an artificially slow rate, but above the configured minimum rate enforced by the Kestrel HTTP server. These tests started becoming flaky with the client observing a “Connection reset by peer” SocketExeption on Linux when we updated the AspNetCore repo to depend on .NET Core 5.0.

In these tests, Kestrel [calls Socket.Shutdown(SocketShutdown.Both) and then Socket.Dispose()](https://github.com/aspnet/AspNetCore/blob/2de6c732d1f410460a627cb75aca91ae2c741fd5/src/Servers/Kestrel/Transport.Sockets/src/Internal/SocketConnection.cs#L344-L351) immediately after the last Socket.SendAsync() Task completes. There isn’t any special LingerState or anything like that. I know the standard way to close a socket is to close the sending side, wait to receive a FIN (a 0-length read with a timeout), and then dispose the socket, but this is the logic we’ve had in the Socket transport since 2.0 and the libuv transport since 1.0 and these tests weren’t flaky before and still aren’t flaky on Windows or macOS.
 
The PR (https://github.com/aspnet/AspNetCore/pull/13532) where I clean up the flaky tests a couple of days after taking the .NET Core 5.0 dependency goes into more detail about the flaky tests. @jkotalik looked through changes made to Sockets after 3.0 that might explain this regression, and he found https://github.com/dotnet/corefx/pull/38804 which is a PR titled “Socket: improve cross-platform behavior on Dispose.” I agree that this PR looks pretty suspicious.
 
I tried creating a minimal repro for this issue without Kestrel or any testing infrastructure, but to this point I haven’t been successful in getting a repro. I thought that simply reading response data slowly from a Socket that was already shutdown and disposed by the peer would be sufficient, but apparently there’s something more to this regression than I realize. Here’s a gist with [my minimal repro attempt (that doesn’t repro yet)](https://gist.github.com/halter73/0efed97b495150a633c7b765e24c939a).

@tmds @stephentoub</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41188</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable nullable annotations for System.Drawing.Primitives</Title>
    <Description>Contributes to: #40623</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41187</IssueID>
    <RepoID>1</RepoID>
    <Title>Removing microsoft.private.corefx.uap</Title>
    <Description>
    </Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41186</IssueID>
    <RepoID>1</RepoID>
    <Title>Q: TaskStatus.Canceled for non-matching OperationCanceledException</Title>
    <Description>When I run:
```cs
        static void Main(string[] args)
        {
            Task fooTask = Foo();
            System.Console.WriteLine(fooTask.Status);
            Task tokenTask = Task.Run(() =&gt; throw new OperationCanceledException(), new CancellationTokenSource().Token);
            tokenTask.ContinueWith(t =&gt; System.Console.WriteLine(t.Status)).Wait();
        }

        static async Task Foo()
        {
            throw new OperationCanceledException();
        }
```
it outputs:
```
Canceled
Canceled
```
I expected the Tasks to be in the `Faulted` state because the `OperationCanceledException` isn't associated with the Task token.

Why are these Tasks `Canceled`?</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41185</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.ComponentModel.Primitives for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41184</IssueID>
    <RepoID>1</RepoID>
    <Title>removing the Micosoft.Private.Corefx.UAP package</Title>
    <Description>Fixes https://github.com/dotnet/corefx/pull/40823/files/f30f32497670355f5b3b130e909b0b859bfa7318#diff-db08ba04a756a4a6cb5a62e48e1c32f2</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41183</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove CurlHandler fallback from HttpClientHandler</Title>
    <Description>SocketsHttpHandler has progressed to the point where we shouldn't need the fallback behind HttpClientHandler, and having it significantly increases the size of System.Net.Http.dll on Unix, while also requiring System.Net.Http.Native.so/dylib, and impacting distribution with libcurl.  We should remove the fallback and all associated code, and if any additional and impactful gaps are discovered, fix them in SocketsHttpHandler.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41182</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove WinHttpHandler fallback from HttpClientHandler</Title>
    <Description>A developer can explicitly use WinHttpHandler by referencing the nuget package and constructing one.  The meant-to-be-temporary environment-variable-controlled fallback is not only additional code to be maintained and additional complexity on how the code is structured, it forces every consumer of System.Net.Http.dll on Windows to carry the WinHttpHandler code internal to System.Net.Http.dll, which increases the size of the binary by ~70K.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41180</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix trimming of System.Net.Ping</Title>
    <Description>It has an ILLinkTrim.xml file that was keeping a type around for testing, but that's apparently keeping the assembly from being trimmed in a published app.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41179</IssueID>
    <RepoID>1</RepoID>
    <Title>I can't use "dotnet ef database update --environment RELEASE"</Title>
    <Description>![image](https://user-images.githubusercontent.com/45932283/65171600-d9f9ee00-da68-11e9-9e23-f4a9f19a9955.png)

![image](https://user-images.githubusercontent.com/45932283/65171699-188fa880-da69-11e9-911a-f7d0922d2fb7.png)

what should I replace?</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>21/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41178</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Fix SqlParameter with xml schema construction</Title>
    <Description>Ports #41008 for release/3.1

## Description

Fixes a bug in SqlParameter XmlSchemaCollection APIs where setters were not validating initialized xmlSchemaCollection properly. The issue got merged in due to no test coverage on impacted APIs.

## Customer Impact

Below SqlParameter APIs are impacted:
- set_XmlSchemaCollectionDatabase
- set_XmlSchemaCollectionOwningSchema
- set_XmlSchemaCollectionName

## Regression

Yes. This PR fixes a regression reported in #41141 caused with PR #35549 in .NET Core SDK 3.0 Preview3.

## Risk

Small. The change-set is small and the code changes introduced in earlier PR #35363 is being revised here.

## Tests

Tests added to cover missing areas and will now be run as part of PR validations.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41177</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove DEBUG-only TraceSource/Switch usage from corefx</Title>
    <Description>A lot of TraceSource/Switch usage in corefx exists only to enable some optional DEBUG-only tracing and asserts, which haven't been used in a very long time (if ever in corefx), but some of it is keeping these types from being trimmed in a default MVC app (even if the call sites are conditional, many of the switches themselves are not).

cc: @krwq, @Anipik, @safern, @maryamariyan, @divega </Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41176</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json: DictionaryKeyPolicy not applied to keys that contain non primitive types</Title>
    <Description>Hello.

-Net Core 3 RC1

Apparently when serializing a dictionary if a key contains a non primitive type the DictionaryKeyPolicy won't be applied to the key, example below:

```C#
using System;
using System.Collections.Generic;
using System.Text.Json;

namespace JsonTest
{
    class SampleClass
    {
        public string SomePropety { get; set; } = "some prop"; 
    }

    class Program
    { 
        static void Main(string[] args)
        {

            var dict = new Dictionary&lt;string, object&gt;();

            dict["KeyString"] = "bar";
            dict["KeyDateTime"] = new DateTime(2019, 9, 18);
            dict["KeyInteger"] = 4234;
            dict["KeyDouble"] = 54.444;
            dict["KeyFloat"] = 231.34f;
            dict["KeyDecimal"] = 442.434343m;
            dict["KeyBool"] = true;
            
            dict["KeyList"] = new List&lt;int&gt;() {1, 2, 3}; 
            
            dict["KeyDict"] = new Dictionary&lt;string, object&gt;()
            {
                {"KeyString", "bar"},
                {"KeyDateTime", new DateTime(2019, 9, 18)},
                {"KeyDouble", 54.444},
                {"KeyFloat", 231.34f},
                {"KeyDecimal", 442.434343m},
                {"KeyBool", true}
            };

           dict["KeyClass"] = new SampleClass();

            var serialized = JsonSerializer.Serialize(dict, new JsonSerializerOptions()
            { 
                DictionaryKeyPolicy = JsonNamingPolicy.CamelCase, 
                WriteIndented = true
            }); 
        }
    }
}

```

```
{
  "keyString": "bar",
  "keyDateTime": "2019-09-18T00:00:00",
  "keyInteger": 4234,
  "keyDouble": 54.444,
  "keyFloat": 231.34,
  "keyDecimal": 442.434343,
  "keyBool": true,
  "KeyList": [
    1,
    2,
    3
  ],
  "KeyDict": {
    "keyString": "bar",
    "keyDateTime": "2019-09-18T00:00:00",
    "keyDouble": 54.444,
    "keyFloat": 231.34,
    "keyDecimal": 442.434343,
    "keyBool": true
  },
  "KeyClass": {
    "SomePropety": "some prop"
  }
}
```

Notice that "KeyList", "KeyDict" and "KeyClass" have not been camelCased. I guess this is not intended.

</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41175</IssueID>
    <RepoID>1</RepoID>
    <Title>Unit test process fails with "Access violation" under VS debugger</Title>
    <Description>If a unit test project (e.g. System.Text.RegularExpressions.Tests) is being run under VS 2019 debugger (it is started by pressing F5, NOT from Test Explorer), it starts executing, but after several seconds fails with "Access violation" exception. This happens even if the test process itself gets paused by debugger at some point. In the output window, the following error is logged:
"The program '[4820] dotnet.exe' has exited with code -1073741819 (0xc0000005) 'Access violation'."
@ViktorHofer </Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41174</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json and case - different behavior in serialization and deserialization</Title>
    <Description>If you have a class as such
```csharp
public class MyClass {
  public string MyProperty { get;set; }
}
```
and a controller as such
```csharp
public async Task&lt;MyClass&gt; MyController(...) {
   var myObj = await _db.GetSomeStuff();
   return myObj;
}
```
The object will be serialized as such
```javascript
{
  myProperty: 'Some value'
}
```
So, on a client somewhere you do
```csharp
MyClass myObj = System.Text.Json.JsonSerializer.Deserialize&lt;MyClass&gt;(jsonString);
```

It will not work, since the Deserialization method is case sensitive. This is in and off it self not a problem, but the two methods should agree on how to serialize and deserialize an object by default. In other words, if the default behavior of serialization is to change case, then the default behavior of deserialization should handle this.

I know the solution is to do 
```csharp
MyClass myObj = System.Text.Json.JsonSerializer.Deserialize&lt;MyClass&gt;(jsonString, new JsonSerializerOptions {
    PropertyNameCaseInsensitive = true,
    });
```

but the default behavior of the two operations should be compatible. Currently they are not.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41173</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix the filename used by the VerifyCrlCache test</Title>
    <Description>The VerifyCrlCache test, which is a manual test, is looking for the old cache key.
This change updates it to the new cache key, and makes the test pass again.

The cache key changed in #39430.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41172</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Reflection.MetadataLoadContext performance</Title>
    <Description>I have a benchmark here: https://github.com/jonathanpeppers/Benchmarks/blob/7db49fb3d272c5b07deda166dd4f5a5112258bbe/Benchmarks/Cecil.cs#L90-L111

And I am getting "not so great" results for `SR.MetadataLoadContext`:

```
// * Summary *

BenchmarkDotNet=v0.11.3, OS=Windows 10.0.18362
Intel Core i9-9900K CPU 3.60GHz, 1 CPU, 16 logical and 8 physical cores
  [Host]     : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0
  DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0


                                Method |        Mean |      Error |     StdDev |      Median | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
-------------------------------------- |------------:|-----------:|-----------:|------------:|------------:|------------:|------------:|--------------------:|
            System.Reflection.Metadata |    32.84 ms |  0.1200 ms |  0.1123 ms |    32.85 ms |   3000.0000 |     62.5000 |           - |            15.12 MB |
                            Mono.Cecil |   351.81 ms |  7.1738 ms | 21.1522 ms |   339.38 ms |  16000.0000 |  12000.0000 |   4000.0000 |           103.57 MB |
 System.Reflection.MetadataLoadContext | 2,058.91 ms | 19.9863 ms | 18.6952 ms | 2,051.50 ms |  97000.0000 |  90000.0000 |   6000.0000 |           544.84 MB |
```

The performance compared to using raw SRM or Mono.Cecil is drastically worse.

I expected it to be somewhere in the middle of using SRM and Mono.Cecil. Is there something I'm doing here that would explain the poor performance?

Thanks!</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41171</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: add function to flush PE caches</Title>
    <Description>## Rationale and Usage

The idea of this API is to allow flushing of PE caches at request, which will allow to reduce memory consumption of the process. 

```cs
Type type = typeof(RuntimeHelpers);
MethodInfo method = type.GetMethod("FlushPECaches");
if (method != null)
  method.Invoke(null, new object[]{});
```

After this call Private_Clean and Shared_Clean of the process are reduced, as well as PSS and RSS.

## Proposed API
```cs
namespace System.Runtime.CompilerServices
{
    public static partial class RuntimeHelpers
    {
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        public static extern void FlushPECaches();
    }
}
```

## Details
- Internally, FlushPECaches tries to mark all readonly pages of PE images (this considers relocations too) as not needed so that they can be freed. This is done using `madvise` with `MADV_DONTNEED`.
- both dlls and ni.dlls are considered

## Pull Request

PR with proposed change is available at https://github.com/dotnet/coreclr/pull/26507

cc @alpencolt </Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41203</IssueID>
    <RepoID>1</RepoID>
    <Title>NetworkChange.NetworkAddressChanged bug</Title>
    <Description># Issue Title

NetworkAddressChanged calls a callback just once.

# General

I wrote a simple program to test how NetworkChange.NetworkAddressChanged and got some really weird results: if I subscribe this event, it's being called just once, but if I add and remove a subscribtion to an empty function, it starts working just fine (one call for plugging ethernet cable out and two for plugging in).

It works okay in .Net framework.

I've tried changing event causes, for example, changing my computer's ip on DHCP server and ipconfig /renew. Target platform is &lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;.
OS: Windows 10 pro

Code to reproduce the issue:


```
class Program
{
    static void Main(string[] args)
    {
        //Subscribing event
        NetworkChange.NetworkAddressChanged += OnAddressChanged;
        //just a loop
        while (true)
        {
            Thread.Sleep(1000);
        }
    }
    //Callback
    static void OnAddressChanged(object o, EventArgs e)
    {
        Console.WriteLine(e.ToString());

        foreach (NetworkInterface n in NetworkInterface.GetAllNetworkInterfaces())
        {
            Console.WriteLine("   {0} is {1}", n.Name, n.OperationalStatus);
        }
        //Works if uncomment two lines below
        //NetworkChange.NetworkAddressChanged += DuctTape;
        //NetworkChange.NetworkAddressChanged -= DuctTape;
    }
    //Empty function
    static void DuctTape(object sender, EventArgs e)
    {
        ;
    }
}
```</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41204</IssueID>
    <RepoID>1</RepoID>
    <Title>Decimal GetHashCode() not always equal for different number of tailing 0</Title>
    <Description>&gt; var a = 1000.250000000000000000m;
&gt; var b = 1000.25000000000000000000m;
&gt; a == b
true
&gt; a.GetHashCode() == b.GetHashCode()
false
&gt; a.GetHashCode()
-1083130353
&gt; b.GetHashCode()
1083130368

Reproduced on .NET Core 2.2 and Windows 10

</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>24/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41170</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190917.8
- **Date Produced**: 9/18/2019 4:19 AM
- **Commit**: 708eb333f08df7e339a3989765a068d65a1232bf
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19467.8
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19467.8
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19467.8

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190917.6
- **Date Produced**: 9/18/2019 3:17 AM
- **Commit**: 4ca1feeeb484e8a7089ce8a9d377703ad5b8a53e
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19467.6
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19467.6

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190917.1
- **Date Produced**: 9/17/2019 12:42 PM
- **Commit**: 2098c0b37fcffe4430d1e70de035f5c867e5511e
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19467.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41169</IssueID>
    <RepoID>1</RepoID>
    <Title>improve span.StartsWith(span) test coverage</Title>
    <Description>I just wanted to make sure that `span.StartsWith(span)` has the same test coverage as `string.StartsWith(string)`</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41168</IssueID>
    <RepoID>1</RepoID>
    <Title>Sort fields when Serialize an object to string</Title>
    <Description>Would be great to add an sort option to `Serialize` method

default
```
JsonSerializer.Serialize(someObj)
```

```json
{
    "a": "a",
    "c": "c",
    "b": "b"
}
```

to asc

```
JsonSerializer.Serialize(someObj, 1)
```

```json
{
    "a": "a",
    "b": "b",
    "c": "c"
}
```</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41167</IssueID>
    <RepoID>1</RepoID>
    <Title>JSON DateTime Deserialize failure when Timezone Offset does not contain colon</Title>
    <Description>I only recently observed a regression failure between `3.0.100-preview7` and `3.0.100-preview8` which persist into preview9 and RC1.

When parsing a valid ISO8601 DateTime string, but with the colon left out of the Timezone Offset, I receive `System.FormatException: The JSON value is not in a supported DateTime format` when using preview8 or later. Preview7 behaves as expected.

A simple sample:
```cs
using System;
class Program
{
  static void Main(string[] args)
  {
    var dtValid = "2019-09-18T01:01:01.000+02:00";
    var dtInvalid = "2019-09-18T01:01:01.100+0200";

    // No Problem
    TestObj success = System.Text.Json.JsonSerializer.Deserialize&lt;TestObj&gt;($"{{\"DtVal\":\"{dtValid}\"}}");
    // System.FormatException: The JSON value is not in a supported DateTime format.
    TestObj failed = System.Text.Json.JsonSerializer.Deserialize&lt;TestObj&gt;($"{{\"DtVal\":\"{dtInvalid}\"}}");
  }
}

public class TestObj
{
  public DateTime DtVal { get; set; }
}
```</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41166</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: Add Encoding/Decoding APIs for new System.Buffer types</Title>
    <Description>Today our encoding APIs support `Span&lt;byte&gt;`/`Span&lt;char&gt;`/`char[]`/`byte[]` and the Encoder/Decoder API, I'd like to propose some higher level APIs that support `ReadOnlySequence&lt;byte/char&gt;` and `IBufferWriter&lt;byte/char&gt;`:

```C#
namespace System.Text
{
    public static class EncodingExtensions
    {
        public static int GetBytes(this Encoding encoding, ReadOnlySpan&lt;char&gt; chars, IBufferWriter&lt;byte&gt; writer);
        public static long GetBytes(this Encoding encoding, in ReadOnlySequence&lt;char&gt; chars, IBufferWriter&lt;byte&gt; writer);
        public static int GetBytes(this Encoding encoding, in ReadOnlySequence&lt;char&gt; chars, Span&lt;byte&gt; bytes);
        public static byte[] GetBytes(this Encoding encoding, in ReadOnlySequence&lt;char&gt; bytes);

        public static int GetChars(this Encoding encoding, ReadOnlySpan&lt;byte&gt; bytes, IBufferWriter&lt;char&gt; writer);
        public static long GetChars(this Encoding encoding, in ReadOnlySequence&lt;byte&gt; bytes, IBufferWriter&lt;char&gt; writer);
        public static int GetChars(this Encoding encoding, in ReadOnlySequence&lt;byte&gt; bytes, Span&lt;char&gt; chars);
        public static string GetString(this Encoding encoding, in ReadOnlySequence&lt;byte&gt; bytes);
    }
}
```

These extensions would likely live in the same assembly as these abstractions since encoding couldn't directly take a dependency on those types (unless we push them lower in the stack).

cc @GrabYourPitchforks </Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41165</IssueID>
    <RepoID>1</RepoID>
    <Title>Use HashCode instead of HashHelpers in netstandard libs</Title>
    <Description>Three remaining libraries were using HashHelpers.cs.  Move them to netstandard2.1, change to use HashCode, and delete HashHelpers.cs.</Description>
    <CreatedDate>18/09/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41164</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190927.1
- **Date Produced**: 9/27/2019 9:25 AM
- **Commit**: d289ccc48f1a4d62cd37be17a35d6c37371b7226
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19477.1
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19477.1
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19477.1

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)





</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41163</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove some ActiveIssueAttributes</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/18832

While looking at some old issues saw this one and it seems the configurations in the tests are now correct so we can now close that issue.

cc: @danmosemsft @ViktorHofer </Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41162</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing tag to XML comments</Title>
    <Description>
    </Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41161</IssueID>
    <RepoID>1</RepoID>
    <Title>Nullability annotations for System.Console</Title>
    <Description>Contributes to: #40623

- [x] Annotate files included on unix configuration for System.Console

cc: @safern @buyaa-n </Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41160</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.ComponentModel for nullable</Title>
    <Description>Contributes to #40623
Very small PR
cc: @dotnet/nullablefc</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41159</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: GRPC greeter service failing with 'Invalid Http/2 connection preface' error.</Title>
    <Description>I’ve downloaded the attached sample code and trying to run the Greeter service and client on my machine. But it fails with 'Invalid Http/2 connection preface' error. 
Also attaching the email thread with grpc team regarding this issue. 
[GreeterServiceError.zip](https://github.com/dotnet/corefx/files/3623228/GreeterServiceError.zip)
[sample.zip](https://github.com/dotnet/corefx/files/3623226/sample.zip)
[HttpClientTrace.zip](https://github.com/dotnet/corefx/files/3623215/HttpClientTrace.zip)
</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41158</IssueID>
    <RepoID>1</RepoID>
    <Title>CMS should support attributes for counter-signers</Title>
    <Description>https://github.com/dotnet/corefx/issues/25449 has added support for adding unsigned attributes to signers. It has been noted though this feature should also work for counter-signers as user might want to add a timestamp to the counter signature. There are some questions which need to be investigated first:
- unsigned attributes are also used for storing counter-signatures - currently counter signing counter signature is not supported - is this something we also need to directly support? (yes?)
  - should counter-counter signature sign original content or content stored by the SignerInfo? (original?)
- signed attributes are technically speaking allowed in the counter SignerInfo - I cannot think on how this would reasonably work at the moment though so presumably not support it?

cc: @bartonjs @heng-liu </Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>21/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41157</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190916.1
- **Date Produced**: 9/16/2019 12:42 PM
- **Commit**: acafb789d98dca5940e79dd3c56b9e20399116c4
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19466.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41156</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json ExpandoObject not supported</Title>
    <Description>When i try to return ExpandoObject as a return, looks like its not supported yet

`
ExpandoObject e = new ExpandoObject();
            ((IDictionary&lt;string, object&gt;)e).Add("key", "value");

            var results = System.Text.Json.JsonSerializer.Serialize(e);`

Unable to cast object of type '\&lt;GetExpandoEnumerator\&gt;d__51' to type 'System.Collections.IDictionaryEnumerator'.

planned for version 3?</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>18/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41155</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unused files from System.Net.Http</Title>
    <Description>
    </Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41154</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190916.3
- **Date Produced**: 9/17/2019 1:17 AM
- **Commit**: f5437ac095272f1ab5e8ca79960add974fa96f2d
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19466.3
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19466.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19466.3

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41153</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190916.2
- **Date Produced**: 9/16/2019 4:19 PM
- **Commit**: 9042fe6c81aa3b47f58ccd94ff02e42f9f7a4e46
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19466.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19466.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19466.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190916.8
- **Date Produced**: 9/17/2019 7:53 AM
- **Commit**: 4aea703673e942756c02b222e6b5babaf8612a25
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19466.8
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19466.8

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41152</IssueID>
    <RepoID>1</RepoID>
    <Title>support named shared memory on unixes</Title>
    <Description>I know that shared memory is not supported on unix, as in, the family of MemoryMappedFile.CreateNew methods.
I saw the comment saying why they are not supported.
However, what about posix shared memory? shm_open and friends. Not sure about other oses, but definitely supported on linux.
The only problem may be the unlinking...</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41205</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Security.SecurityElement.FromString()</Title>
    <Description>.NET Core 2.1
`var v = SecurityElement.FromString("&lt;SignatureLength&gt;5&lt;/SignatureLength&gt;");
v== null; Why?`
.NET Framework 4 working exactly</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41181</IssueID>
    <RepoID>1</RepoID>
    <Title>Segmentation fault when using globalization on alpine 3.9</Title>
    <Description>## Steps to reproduce the issue
1. Install icu-libs
2. Set the required environment variables to enable globalization:
```
ENV DOTNET_SYSTEM_GLOBALIZATION_INVARIANT false
ENV LC_ALL en_US.UTF-8
ENV LANG en_US.UTF-8
```
3. Run the application that uses globalization

## Expected behavior
Application runs

## Actual behavior
Application crashes on a segmentation fault. With gdb we can see that this occurs when calling the icu libraries:

```
Thread 13 "dotnet" received signal SIGSEGV, Segmentation fault.
[Switching to LWP 28]
0x00007fd3f9e66e2f in ucol_getAttribute_62 () from /usr/lib/libicui18n.so.62
(gdb) bt
#0  0x00007fd3f9e66e2f in ucol_getAttribute_62 () from /usr/lib/libicui18n.so.62
dotnet/dotnet-docker#1  0x00007fd3f9e85dea in usearch_openFromCollator_62 () from /usr/lib/libicui18n.so.62
dotnet/dotnet-docker#2  0x00007fd3fbac4912 in GlobalizationNative_StartsWith ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.2.6/System.Globalization.Native.so
dotnet/dotnet-docker#3  0x00007fd383c27861 in ?? ()
dotnet/dotnet-docker#4  0x00007fd3f86a6400 in ?? ()
dotnet/dotnet-docker#5  0x0000000001b709c5 in ?? ()
dotnet/dotnet-docker#6  0x00007fd3fd9aa428 in vtable for InlinedCallFrame ()
   from /usr/share/dotnet/shared/Microsoft.NETCore.App/2.2.6/libcoreclr.so
```

## Additional information (e.g. issue happens only occasionally)
affected images:
* mcr.microsoft.com/dotnet/core/sdk:2.2.401-alpine3.9
* mcr.microsoft.com/dotnet/core/runtime:2.2.6-alpine3.9
icu-libs-62.1-r0 x86_64 {icu} (MIT ICU Unicode-TOU)

## Output of `docker version`

```
Client: Docker Engine - Community
 Version:           19.03.2
 API version:       1.40
 Go version:        go1.12.8
 Git commit:        6a30dfc
 Built:             Thu Aug 29 05:26:49 2019
 OS/Arch:           windows/amd64
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          19.03.2
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.8
  Git commit:       6a30dfc
  Built:            Thu Aug 29 05:32:21 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.2.6
  GitCommit:        894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc:
  Version:          1.0.0-rc8
  GitCommit:        425e105d5a03fabd737a126ad93d62a9eeede87f
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
```

## Output of `docker info`

```
Client:
 Debug Mode: false
 Plugins:
  buildx: Build with BuildKit (Docker Inc., v0.3.0-5-g5b97415-tp-docker)
  app: Docker Application (Docker Inc., v0.8.0)

Server:
 Containers: 47
  Running: 41
  Paused: 0
  Stopped: 6
 Images: 103
 Server Version: 19.03.2
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fb
 runc version: 425e105d5a03fabd737a126ad93d62a9eeede87f
 init version: fec3683
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 4.9.184-linuxkit
 Operating System: Docker Desktop
 OSType: linux
 Architecture: x86_64
 CPUs: 4
 Total Memory: 7.769GiB
 Name: docker-desktop
 ID: AEEY:DL2R:ZGEN:R26F:Z4JG:NCCD:6JN2:WI6X:DQ37:WKJV:N24U:LCND
 Docker Root Dir: /var/lib/docker
 Debug Mode: true
  File Descriptors: 190
  Goroutines: 184
  System Time: 2019-09-17T09:17:48.4245683Z
  EventsListeners: 2
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Live Restore Enabled: false
 Product License: Community Engine
```
</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41151</IssueID>
    <RepoID>1</RepoID>
    <Title>SerialPort error on Virtual Serial Port for USB</Title>
    <Description>I'm trying to access a Virtual Serial Port for USB with `System.IO.Ports.SerialPort` and I get the error `The given port name (COM5) does not resolve to a valid serial` when I try to open the port. Here is the code, it works with physical serial ports:
````cs
using (var serialPort = new System.IO.Ports.SerialPort("COM5", 9600))
{
    try
    {
        serialPort.Open(); // ERROR: The given port name (COM5) does not resolve to a valid serial port.
        serialPort.WriteLine("SerialPort Write Test");
        serialPort.Close();
    }
    catch (Exception exception)
    {
        Console.WriteLine(exception);
    }
}
````

I did several tests with `.NET 4.7`, `.NET Core 3.0-RC1`, the `4.6.0-rc1` of nuget `System.IO.Ports`, UWP application with `Windows.Devices.SerialCommunication.SerialDevice`. Always the same error.

The Virtual Serial Port works well with other programs, such as [Termite by Compuphase](https://www.compuphase.com/software_termite.htm) or [Serial Port Terminal by Eltima](https://www.virtual-serial-port.org/products/serial-port-terminal/).

I have also tried with an alternative .NET library [SerialPortStream](https://github.com/jcurl/SerialPortStream) and the access to the COM Port works fine.

Looking at the [code](https://github.com/dotnet/corefx/blob/4aea703673e942756c02b222e6b5babaf8612a25/src/System.IO.Ports/src/System/IO/Ports/SerialStream.Windows.cs#L584), I see that if the `fileType` is different from `FILE_TYPE_CHAR` and `FILE_TYPE_UNKNOWN`, the error is reported. The problem is that my Virtual Service Port returns `FILE_TYPE_DISK`. Is there a reason to refuse `FILE_TYPE_DISK`? Is it possible to accept it or make it configurable?</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41206</IssueID>
    <RepoID>1</RepoID>
    <Title>Marshaling wchar_t on Linux uses wrong size</Title>
    <Description># General

Tested on .NET Core 3.0.100-preview9-014004 on Arch Linux.

The following code should print out `4` on this system, but instead outputs `2`.
Printing `sizeof(wchar_t)` from a C program gives `4`.

Discovered when trying to interop with a C library that has a struct with `wchar_t[5]` inside.

```cs
using System;
using System.Runtime.InteropServices;

namespace dotnet_core_wchar_t_size
{
    class Program
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct test
        {
            public char c;
        }

        static void Main(string[] args)
        {
            Console.WriteLine(Marshal.SizeOf(typeof(test)));
        }
    }
}
```</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41150</IssueID>
    <RepoID>1</RepoID>
    <Title>Test Failure: System.Diagnostics.Tests.EventLogWriteEntryTests.WriteEntryWithType(sourceFlag: True)</Title>
    <Description>Test `System.Diagnostics.Tests.EventLogWriteEntryTests.WriteEntryWithType(sourceFlag: True)` has failed.
```
System.Diagnostics.Tests.EventLogWriteEntryTests.WriteEntryWithType(sourceFlag: True) [FAIL]
      System.AggregateException : One or more errors occurred. (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.) (A device attached to the system is not functioning.)
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      ---- System.ComponentModel.Win32Exception : A device attached to the system is not functioning.
      Stack Trace:
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(45,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(30,0): at System.Diagnostics.Tests.Helpers.Retry[T](Func`1 func)
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.Retry(Action func)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.WriteEntryWithType(Boolean sourceFlag)
        ----- Inner Stack Trace #1 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #2 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #3 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #4 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #5 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #6 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #7 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #8 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #9 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
        ----- Inner Stack Trace #10 (System.ComponentModel.Win32Exception) -----
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLogInternal.cs(479,0): at System.Diagnostics.EventLogInternal.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(226,0): at System.Diagnostics.EventLog.Clear()
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(402,0): at System.Diagnostics.EventLog.Delete(String logName, String machineName)
        /_/src/System.Diagnostics.EventLog/src/System/Diagnostics/EventLog.cs(366,0): at System.Diagnostics.EventLog.Delete(String logName)
        /_/src/System.Diagnostics.EventLog/tests/EventLogTests/EventLogWriteEntryTests.cs(181,0): at System.Diagnostics.Tests.EventLogWriteEntryTests.&lt;&gt;c__DisplayClass9_0.&lt;WriteEntryWithType&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(23,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass6_0.&lt;Retry&gt;b__0()
        /_/src/System.Diagnostics.EventLog/tests/Helpers.cs(32,0): at System.Diagnostics.Tests.Helpers.&lt;&gt;c__DisplayClass7_0`1.&lt;Retry&gt;b__0()
        /_/src/Common/tests/CoreFx.Private.TestUtilities/System/RetryHelper.cs(37,0): at System.RetryHelper.Execute(Action test, Int32 maxAttempts, Func`2 backoffFunc)
    System.Diagnostics.Tests.EventLogConfigurationTests.SetProperties_SaveChanges_NotAdmin_Throws [SKIP]
      Condition(s) not met: "NotElevatedAndSupportsEventLogs"
  Finished:    System.Diagnostics.EventLog.Tests
=== TEST EXECUTION SUMMARY ===
   System.Diagnostics.EventLog.Tests  Total: 140, Errors: 0, Failed: 1, Skipped: 1, Time: 89.388s
----- end Tue 09/17/2019  6:16:02.55 ----- exit code 1 ----------------------------------------------------------
```

Build: -[20190916.34](https://dnceng.visualstudio.com/public/_build/results?buildId=357148)(Master)

Details:
https://helix.dot.net/api/2019-06-17/jobs/96638b0b-a37a-46c3-b5f3-ba6a9807b04e/workitems/System.Diagnostics.EventLog.Tests/console</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41149</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix a typo</Title>
    <Description>This is here for me to monitor a totally code-change-free PR to ensure Helix is doing OK.</Description>
    <CreatedDate>17/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41148</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Net.Http.Functional.Tests.PlatformHandler_HttpClientHandler_MaxResponseHeadersLength_Test.SetAfterUse_Throws failed in the release 3.0 branch</Title>
    <Description>```
      Condition(s) not met: "IsUap"
    System.Net.Http.Functional.Tests.PlatformHandler_HttpClientHandler_MaxResponseHeadersLength_Test.SetAfterUse_Throws [FAIL]
      System.Threading.Tasks.TaskCanceledException : A task was canceled.
      Stack Trace:
        /_/src/System.Net.Http/src/System/Net/Http/HttpClient.cs(553,0): at System.Net.Http.HttpClient.FinishSendAsyncUnbuffered(Task`1 sendTask, HttpRequestMessage request, CancellationTokenSource cts, Boolean disposeCts)
        /_/src/System.Net.Http/src/System/Net/Http/HttpClient.cs(294,0): at System.Net.Http.HttpClient.FinishGetStreamAsync(Task`1 getTask)
        /_/src/System.Net.Http/tests/FunctionalTests/HttpClientHandlerTest.MaxResponseHeadersLength.cs(54,0): at System.Net.Http.Functional.Tests.HttpClientHandler_MaxResponseHeadersLength_Test.SetAfterUse_Throws()
        --- End of stack trace from previous location where exception was thrown ---
  Finished:    System.Net.Http.Functional.Tests
```

https://dev.azure.com/dnceng/public/_build/results?buildId=353186&amp;view=ms.vss-test-web.build-test-results-tab

</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41147</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing dummy fields to reference assemblies</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/40909

Updated with a locally built version of: https://github.com/dotnet/arcade/pull/3912

cc: @ahsonkhan @ericstj @jkotas @stephentoub @terrajobst </Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41146</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @tarekgh @stephentoub</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41145</IssueID>
    <RepoID>1</RepoID>
    <Title>Encoding.Convert with IBM285 incorrect</Title>
    <Description>Hello

It looks like `Encoding#Convert` is returning the incorrect ASCII when using `IBM285`.

```csharp
string myvar = "C88593939640A6969993845B";
byte[] raw = new byte[myvar.Length / 2];
for (int x = 0; x &lt; raw.Length; x++)
  raw[x] = Convert.ToByte(myvar.Substring(x * 2, 2), 16);

string output = Encoding.ASCII.GetString(Encoding.Convert(Encoding.GetEncoding("IBM285"), Encoding.ASCII, raw)));
```

if I decode EBCDIC `C88593939640A6969993845B`

* Using `IBM037`: `Hello world$` - correct
* Using `IBM285`: `Hello world?` - incorrect, result should be `Hello world£`

@NattyNarwhal can confirm this issue and may have more to say on the issue.

Liam</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41143</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove use of RuntimeReflectionExtensions from Microsoft.CSharp</Title>
    <Description>The wrappers aren't adding any benefit and are causing us to pull in the extensions type unnecessarily (and doing unnecessary null checks); just call the underlying methods directly.

cc: @cston, @jkotas</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41142</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove use of non-generic Queue/Stack in System.Private.Xml</Title>
    <Description>This is the only reason these types are brought into a trimmed default MVC app.

cc: @krwq, @jkotas</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41369</IssueID>
    <RepoID>1</RepoID>
    <Title>MEF on .NET Core 2.1 fails to load plugins from folder , but works well with .NET Framework 4.6.1</Title>
    <Description># Issue Title
I have 2 plugin class libraries which reference different version of the Newtonsoft.Json package. Console EXE on .NET Fwk has no problems in loading both of the plugins and invoking the 2 different versions of Newtonsoft.Json simultaneously.

However, console EXE on .NET Core 2.1 will fail on the second plugin. It is almost as though .NET Core is unable to load 2 different versions of the same assembly.

My initial view is that this is less to do with Managed Extensibility Framework . The root cause most probably lies with how .NET Core is designed to load multiple versions of referenced assemblies. In this case the referenced assembly is NewtonSoft. 

- Is this a problem with Newtonsoft?  Unlikely, I am able to reproduce the same problem with the package Polly. **Update** -  see further below. I could repro the same problem using **Polly** .
- Are there some additional steps to be taken care of when using .NET Core, e.g. Manually forcing the assembly resolution using Resolving event of AssemblyLoadContext .
- Or something else? **Update** -  I ditched MEF and tried the old fashioned **Assembly.LoadFrom**. I could repro the same behaviour with .NET Core. See further below. Possible indication that .NET Core has a different behavior.  

# General
I have two .NET Standard 20 class libraries (**PluginNewtonsoftv12**) and  (**PluginNewtonsoftv9**) which implement an interface defined in the class library project **Contracts**.

I have two EXE projects - **ConsoleAppNetCore** and **ConsoleAppNETFramework** which use the **DirectoryCatalog** of **Managed Extensibility Framework** to discover and load the plugins.

The output of the projects **PluginNewtonsoftv9** and **PluginNewtonsoftv12** are copied to a plugins folder using a post build step. This is the **out** folder in the project **PluginsDeliveryFolder**.  Both the plugin projects have the attribute **CopyLocalLockFileAssemblies** to ensure that all dependent assemblies get copied over to their respective folders.

What is important that EXE should have no compile time knowledge of the plugin library except for the contractual interfaces.

**Solution structure**

- ConsoleAppNETFramework (EXE, fwk 461)
- ConsoleAppNetCore (EXE, Core 2.1)
- PluginsDeliveryFolder (Dummy class library)
- PluginNewtonsoftv12 (.NET Standard 20)
- PluginNewtonsoftv9 (.NET Standard 20)
- Contracts (.NET Standard 20)

**Steps to reproduce - Framework** 

1. Do a build all.
2. Ensure that the plugins DLLs are copied over to **PluginsDeliveryFolder**
3. Run the project **ConsoleAppNETFramework**.
4. Specify the path to the folder where all the plugins are copied over
4. Specify the MEF meta-data of the plugin to load. newtonv9 and then newtonv12
5. Try the reverse sequence. newtonv12 and then newtonv9
6. Both should work

--------------
**Steps to reproduce - NET Core**
1. Do a build all.
2. Ensure that the plugins DLLs are copied over to **PluginsDeliveryFolder**
3. Run the project **ConsoleAppNetCore**.
4. Specify the path to the folder where all the plugins are copied over
5. Select **newtonv9**  and then **newtonv12**. The plugin **newtonv9** works fine, but **newtonv12** fails because it is unable to load version 12 of Newtonsoft
6. Select **newtonv12** and then **newtonv9**. Both the plugins work fine.

--------------
**Screen capture of failure when using .NET Core**


&gt; ![NetCore_V9_before_V12](https://user-images.githubusercontent.com/20245330/64969617-2b08b700-d89c-11e9-97bb-8a52da19eb0b.PNG)
 
**Exception message when using .NET Core**

&gt; System.IO.FileLoadException: Could not load file or assembly 'Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed'. Could not find or load a specific file. (Exception from HRESULT: 0x80131621)
&gt; File name: 'Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed' ---&gt; System.IO.FileLoadException: Could not load file or assembly 'Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed'.
&gt;    at System.Runtime.Loader.AssemblyLoadContext.LoadFromPath(IntPtr ptrNativeAssemblyLoadContext, String ilPath, String niPath, ObjectHandleOnStack retAssembly)
&gt;    at System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(String assemblyPath)
&gt;    at System.Reflection.Assembly.LoadFrom(String assemblyFile)
&gt;    at System.Reflection.Assembly.LoadFromResolveHandler(Object sender, ResolveEventArgs args)
&gt;    at System.AppDomain.InvokeResolveEvent(ResolveEventHandler eventHandler, RuntimeAssembly assembly, String name)
&gt;    at PluginNewtonsoftV12.Class1.DoWork()
&gt;    at ConsoleAppNETCore.Program.Main(String[] args) in 
&gt; 

--------------
**Screen capture of success when using .NET Framework**
![NetFwk](https://user-images.githubusercontent.com/20245330/64969977-d1ed5300-d89c-11e9-8a35-0601543c0d8d.PNG)


**Source code**
https://github.com/sdg002/MEFFwkCoreComparison

**Summary**
,NET Framework works as expected. It is able to load the 2 versions of Newtonsoft side by side. However, .NET Core is unable to cope with the 2 versions side by side. Is this a limitation of .NET Core?
</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41140</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher with a filter set to a specific file does not work on Ubuntu</Title>
    <Description>This code is expect to raise Changed event when file text.txt is changed:

                FileSystemWatcher watcher = new FileSystemWatcher("/usr/share", "text.txt");
                watcher.Changed += Watcher_Changed;
                watcher.NotifyFilter = NotifyFilters.LastWrite;
                watcher.EnableRaisingEvents = true;

It works OK in Windows, but in Ubuntu the event Changed is never raised. When the second parameter (filter) in FileSystemWatcher constructor is omitted and file "text.txt" is modified, then the Changed event is raised, but the FileSystemEventArgs.Name is different from "text.txt" (it was ".goutputstrem=ZJ8U7Z" in my case).</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41138</IssueID>
    <RepoID>1</RepoID>
    <Title>Updated VS code debugging instructions</Title>
    <Description>Updated Unix instructions for VS Code debugging:
- to reflect the actual directory structure of the repo. 
- to include required dotnet arguments to run the tests.

Fixes #41085</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41137</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190915.2
- **Date Produced**: 9/16/2019 12:41 AM
- **Commit**: f0ba9d3435e260d89c44c73afd14dc12301d72ef
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19465.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19465.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19465.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41136</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190915.2
- **Date Produced**: 9/16/2019 4:10 AM
- **Commit**: 9042fe6c81aa3b47f58ccd94ff02e42f9f7a4e46
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19465.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19465.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19465.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190915.2
- **Date Produced**: 9/15/2019 6:42 PM
- **Commit**: e8efb815275c8323fedc950ca3596474fa5e23c3
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19465.2
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19465.2

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190915.1
- **Date Produced**: 9/15/2019 12:36 PM
- **Commit**: d9f55361e33f6f8fa5002f4ad6c9bafe12b5f6aa
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19465.1

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41134</IssueID>
    <RepoID>1</RepoID>
    <Title>Throw better exception on WSL 1 where /proc/net file cannot be read</Title>
    <Description>On WSL 1, the files in `/proc/net/` directory are either empty or missing completely.
In such case, throw better exceptions (`PlatformNotSupportedException` when file is missing and `NetworkInformationException` when file is empty) instead of `FileNotFoundException` or `OverflowException`.

Note that on WSL 2 the files are present and not empty.

Fixes  #30909</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41133</IssueID>
    <RepoID>1</RepoID>
    <Title>Where is the system.printing namespace and how do we access it in VS2019?</Title>
    <Description>This link would suggest System.Printing is available.

https://docs.microsoft.com/en-us/dotnet/api/system.printing?view=netcore-3.0

I have .NET Core 3.0 Preview 9 installed with VS 2019 but i cant seem to reference this Assembly / Namespace. I cant find anything in Nuget nor anything about printing assemblies in general. The api seems well documented on MS Docs where to find is a mystery.</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>19/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41132</IssueID>
    <RepoID>1</RepoID>
    <Title>Implement support for getting Base64 bytes from JsonElement that's backed by a JsonNode</Title>
    <Description>Along with implementing support for Base64, add tests as well.

```C#
string base64String = "ABA=";
using (JsonDocument doc = JsonDocument.Parse($"{{\"data\":\"{base64String}\"}}"))
{
    JsonElement root = doc.RootElement;
    JsonElement data = root.GetProperty("data");
    byte[] base64Bytes = data.GetBytesFromBase64(); // {0, 16}
    Console.WriteLine(base64Bytes.Length); // Returns 2
    Console.WriteLine(base64String == Convert.ToBase64String(base64Bytes)); // Returns true

    JsonElement roundtripViaNode = JsonNode.DeepCopy(root).AsJsonElement();
    data = roundtripViaNode.GetProperty("data");
    // Throws System.NotSupportedException: 'Specified method is not supported.'
    base64Bytes = data.GetBytesFromBase64();
    Console.WriteLine(base64Bytes.Length);
    Console.WriteLine(base64String == Convert.ToBase64String(base64Bytes));
}
```

https://github.com/dotnet/corefx/blob/e8efb815275c8323fedc950ca3596474fa5e23c3/src/System.Text.Json/src/System/Text/Json/Document/JsonElement.cs#L487-L504

![image](https://user-images.githubusercontent.com/6527137/64934371-35c13e80-d7ff-11e9-9acd-a32c027bc4a8.png)

cc @kasiabulat </Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41131</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: ExecutionContext.Run&lt;TContext&gt; overloads</Title>
    <Description>Today to run code on a specific `ExecutionContext`, there's a non-generic Run method that takes a `ContextCallback` and object state. We should add a generic overload to boxing can be avoided (for e.g. when passing a ValueTuple):

```C#
namespace System.Threading
{
    public sealed class ExecutionContext
    {
        // New
        public static void Run&lt;TState&gt;(ExecutionContext context, ContextCallback&lt;TState&gt; callback, ref TState state);

        // Existing
        public static void Run(ExecutionContext executionContext, ContextCallback callback, object? state);
        ...
    }

    // New (it exists but as internal)
    public delegate void ContextCallback&lt;TState&gt;(ref TState state);

    // Existing
    public delegate void ContextCallback(object? state);
}
```</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41130</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve test coverage for JsonElement (when backed by JsonNode) for edge cases around enumeration</Title>
    <Description>We can improve test coverage of certain branches within `JsonElement` (when it's backed by `JsonNode`):

Metric | Value
-- | --
Covered lines: | 629
Uncovered lines: | 13
Coverable lines: | 642
Total lines: | 2096
Line coverage: | 97.9% (629 of 642)
Covered branches: | 213
Total branches: | 225
Branch coverage: | 94.6% (213 of 225)

Edge cases while enumerating JSON objects and JSON arrays. It's possible these branches are unreachable:
https://github.com/dotnet/corefx/blob/e8efb815275c8323fedc950ca3596474fa5e23c3/src/System.Text.Json/src/System/Text/Json/Document/JsonElement.ArrayEnumerator.cs#L51-L59
![image](https://user-images.githubusercontent.com/6527137/64934182-e2022580-d7fd-11e9-89ff-6dccf200171a.png)

https://github.com/dotnet/corefx/blob/e8efb815275c8323fedc950ca3596474fa5e23c3/src/System.Text.Json/src/System/Text/Json/Document/JsonElement.ObjectEnumerator.cs#L47-L55
![image](https://user-images.githubusercontent.com/6527137/64934206-0cec7980-d7fe-11e9-99fc-f948ce8e6674.png)

These tests won't fail on .NET Core (and they are likely already covered by tests that run on netfx, but it would be good to verify).
https://github.com/dotnet/corefx/blob/e8efb815275c8323fedc950ca3596474fa5e23c3/src/System.Text.Json/src/System/Text/Json/Document/JsonElement.cs#L1097-L1105
![image](https://user-images.githubusercontent.com/6527137/64934195-f6462280-d7fd-11e9-846c-4f8b1cf9dffa.png)

https://github.com/dotnet/corefx/blob/e8efb815275c8323fedc950ca3596474fa5e23c3/src/System.Text.Json/src/System/Text/Json/Document/JsonElement.cs#L1176-L1184
![image](https://user-images.githubusercontent.com/6527137/64934199-fc3c0380-d7fd-11e9-9a55-eec350582b92.png)

cc @kasiabulat </Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41129</IssueID>
    <RepoID>1</RepoID>
    <Title>Add performance tests for JsonNode and related types</Title>
    <Description>We should add performance tests to https://github.com/dotnet/performance and compare scenarios against Newtonsoft.Json.

This includes scenarios such as :
- JsonNode.Parse (versus JsonDocument.Parse)
- JsonNode.DeepCopy
- Create JsonElement, modify some properties, and then convert back to JsonElement.
- Enumerate all the nodes/tokens from a JsonNode (versus JsonDocument/JsonElement).

cc @kasiabulat, @joperezr </Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41128</IssueID>
    <RepoID>1</RepoID>
    <Title>Rename JsonNode and related types to JNode, move them to S.T.Json.Linq namespace, and address partial usability feedback</Title>
    <Description>Forked from https://github.com/dotnet/corefx/pull/41030 (and hence depends on it).

**Changes:**
- Move JsonNode and related types to S.T.Json.Linq namespace.
- Rename JsonNode and related types to JNode, JObject, etc.
- Add JObject.Parse and JArray.Parse.
- Override JNode.ToString to return the JSON string representation.
- Modify some of the xml comments to improve JNode discoverability.
- Rename GetNode to GetOriginatingNode to make it less inviting.
- Add instance method JsonElement.ToJNode which does the deep copy.
- Move the JArray and JObject enumerators as nested types.

Should we wait for this PR to get merged until after https://github.com/dotnet/corefx/pull/41041?

This PR isn't ready to be merged until more tests are added but a review would help.
Very few changes are made to the implementation details. It's probably easiest to review this one commit at a time.

cc @kasiabulat, @terrajobst, @bartonjs, @joperezr 
</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41296</IssueID>
    <RepoID>1</RepoID>
    <Title>Why is `MemberExpression.Member` ownership not resolved the same way reflection does?</Title>
    <Description>Consider the following code:

```cs
using System;
using System.Linq.Expressions;

public class Program
{
	public static void Main()
	{
		var propFromReflection = typeof(Bar).GetProperty("Property");

		Expression&lt;Func&lt;Bar, int&gt;&gt; expression = bar =&gt; bar.Property;
		var memberExpr = expression.Body as MemberExpression;

		var propFromExpression = memberExpr.Member;

		Console.WriteLine("Reflection says " + propFromReflection.DeclaringType.Name);
		Console.WriteLine("Expression says " + propFromExpression.DeclaringType.Name);
	}
}

public abstract class Foo
{
	public abstract int Property { get; set; }
}

public class Bar : Foo
{
	public override int Property { get; set; }
}
```

The output in console will state that

&gt; Reflection says Bar
&gt; Expression says Foo

Why are they different? How come the Expression engine won't get the exact `MemberInfo` instance used within the lambda expression? Technically it has everything it needs to do so, doesn't it?</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41127</IssueID>
    <RepoID>1</RepoID>
    <Title>API proposal: Char.Empty</Title>
    <Description>This probably gets denied like all my suggestions but however I would like to propose Char.Empty which does nothing else than String.Empty by returning a char instead of a string.

```
namespace System
{
    public struct Char : IComparable, IConvertible, IComparable&lt;Char&gt;, IEquatable&lt;Char&gt;
    {
        public static readonly Char Empty;
    }
}
```

Most common scenario would be:
```
void DoStuff(string s) {
	s = s.Replace('a', char.Empty);
}
```

There will be reasons against this API and I could ask why the same reasons wouldn't apply to string.Empty which got approved but anyways. Another scenario most devs would have asked "Why doesn't something like this exist?" and here is my question to the official .NET team, can this be added?</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41126</IssueID>
    <RepoID>1</RepoID>
    <Title>Add file move overrite test for linux</Title>
    <Description>Fix #41009

1. Add tests for checking if source file is deleted when overwrite is set to true while calling File.Move</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41125</IssueID>
    <RepoID>1</RepoID>
    <Title>TPL Dataflow TransformManyBlock support for IAsyncEnumerable</Title>
    <Description>Currently TransformManyBlock is expected to output an IEnumerable&lt;K&gt;, it would be useful to also have support for an IAsyncEnumerable&lt;K&gt; output

Additional question; why is TPL dataflow in this repository? Seems like an obvious candidate to split into its own repo</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41124</IssueID>
    <RepoID>1</RepoID>
    <Title>Add Culture Cloning Test</Title>
    <Description>This test to validate the calendar instances inside the culture after colning.</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41123</IssueID>
    <RepoID>1</RepoID>
    <Title>Update dogfooding.md to include other blob feeds required for dogfooding</Title>
    <Description>Although the required feeds are written in the dotnet/core-sdk repo, I missed the note and went with the feeds written in the dogfooding documentation in corefx, which resulted in build failures due to failures restoring packages that are distributed from ASP.NET feeds.

It would be nice if we can have the feeds updated here as well.</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41122</IssueID>
    <RepoID>1</RepoID>
    <Title>Read values from /proc/[pid]/status</Title>
    <Description>Add support for:

- Process.PeakWorkingSet64
- Process.PrivateMemorySize64
- Process.PagedMemorySize64
- Process.PagedSystemMemorySize64
- Process.PeakVirtualMemorySize64

Improve:

- Process.VirtualMemorySize64
- Process.WorkingSet64

Also fixes #23449 and #36086

UPDATE: Fixes/Additions/ Supports have only been added on Linux. OSX is still unsupported.</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41121</IssueID>
    <RepoID>1</RepoID>
    <Title>Return values from /proc/[pid]/status</Title>
    <Description>

Add support for:

- Process.PeakWorkingSet64
- Process.PrivateMemorySize64
- Process.PagedMemorySize64
- Process.PagedSystemMemorySize64
- Process.PeakVirtualMemorySize64

Improve:

- Process.VirtualMemorySize64
- Process.WorkingSet64</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41120</IssueID>
    <RepoID>1</RepoID>
    <Title>Return values from /proc/[pid]/status</Title>
    <Description>

Add support for:
- Process.PeakWorkingSet64
- Process.PrivateMemorySize64
- Process.PagedMemorySize64
- Process.PagedSystemMemorySize64
- Process.PeakVirtualMemorySize64

Improve:
- Process.VirtualMemorySize64
- Process.WorkingSet64</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41119</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190914.2
- **Date Produced**: 9/15/2019 1:39 AM
- **Commit**: c7071577a4d95596cf84b313e87a8c5b47f2d493
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19464.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19464.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19464.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41118</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190914.2
- **Date Produced**: 9/15/2019 4:11 AM
- **Commit**: 9042fe6c81aa3b47f58ccd94ff02e42f9f7a4e46
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19464.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19464.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19464.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190914.4
- **Date Produced**: 9/15/2019 5:48 AM
- **Commit**: cbcc2a5e6f8be1e43b16874ed358c18c5d6bcd5b
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19464.4
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19464.4

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190914.2
- **Date Produced**: 9/14/2019 12:48 PM
- **Commit**: caa50e8757cbb68931e67a75a8fbf48a38366caa
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19464.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41117</IssueID>
    <RepoID>1</RepoID>
    <Title>Add TaskCompletionSource.SetCanceled(CancellationToken)</Title>
    <Description>`TaskCompletionSource` currently has three methods to set it to canceled. `void SetCanceled()` which throws if the source is already completed, `bool TrySetCanceled()` which just returns false if the source is already cancelled, and `bool TrySetCanceled(CancellationToken)` which is like `TrySetCanceled` but also allows linking in a `CancellationToken`.

Can we also add `void SetCanceled(CancellationToken)` to use in cases where you want to make it clear that this should set the canceled state but you also want to link a `CancellationToken` in.
This is doable by writing your own that just throws if `TrySetCanceled` returns false but this can't easily get the `TaskT_TransitionToFinal_AlreadyCompleted` resource string to match the error message thrown by corefx. It also leads to people just writing `TrySetCanceled` and ignoring the result, which leads to less clear code and potentially hides bugs, or alternatively they write `SetCanceled` and throw away the token information (Me trying to fix one case of this in FSharp.Core is what lead to me raising this issue).

```C#
public class TaskCompletionSource&lt;TResult&gt;
{
    ...
    public void SetCanceled(CancellationToken cancellationToken);
    ...
}
```</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41139</IssueID>
    <RepoID>1</RepoID>
    <Title>.NET Core 3.0-preview9-014004 :: System.Text.Json.JsonException</Title>
    <Description># Issue Title
System.Text.Json.JsonException: A possible object cycle was detected which is not supported.

# Description
The exception is raised when trying to serialize an Exception in:
 - UseExceptionHandler()
 - MiddleWare loaded by UseMiddleware()

I have not tried the serialization in other contexts.
Replacing the serialization call by another serializer (ex: Newtonsoft.Json) works properly.

# Versions
.Net Core 3.0.100-preview9-014004

# Code
`var result = JsonSerializer.Serialize&lt;Exception&gt;(exception, new JsonSerializerOptions { WriteIndented = true });`

# Exception detail
Exception thrown: 'System.Text.Json.JsonException' in System.Text.Json.dll
Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware: Error: An exception was thrown attempting to execute the error handler.

System.Text.Json.JsonException: A possible object cycle was detected which is not supported. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 0.
   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_SerializerCycleDetected(Int32 maxDepth)
   at System.Text.Json.JsonSerializer.Write(Utf8JsonWriter writer, Int32 originalWriterDepth, Int32 flushThreshold, JsonSerializerOptions options, WriteStack&amp; state)
   at System.Text.Json.JsonSerializer.WriteCore(Utf8JsonWriter writer, PooledByteBufferWriter output, Object value, Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.WriteCore(PooledByteBufferWriter output, Object value, Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.WriteCoreString(Object value, Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)
   at NETCore3APITemplate.API.Startup.&lt;&gt;c__DisplayClass12_0.&lt;&lt;Configure&gt;b__3&gt;d.MoveNext() in D:\Sources\JMI\Git\ALMTools-Templates-DotNetCore-Simple\Sources\WorkingSolution\NETCore3APITemplate\NETCore3APITemplate\NETCore3APITemplate.API\Startup.cs:line 147
--- End of stack trace from previous location where exception was thrown ---
   at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware.HandleException(HttpContext context, ExceptionDispatchInfo edi)
Microsoft.AspNetCore.Server.IIS.Core.IISHttpServer: Error: Connection ID "18230571301796315147", Request ID "8000000f-0002-fd00-b63f-84710c7967bb": An unhandled exception was thrown by the application.

# Packages references
    &lt;PackageReference Include="AutoMapper" Version="9.0.0" /&gt;
    &lt;PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="7.0.0" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Mvc.ApiExplorer" Version="2.2.0" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Mvc.Versioning" Version="4.0.0-preview8.19405.7" /&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Mvc.Versioning.ApiExplorer" Version="4.0.0-preview8.19405.7" /&gt;
    &lt;PackageReference Include="Microsoft.Extensions.PlatformAbstractions" Version="1.1.0" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore" Version="5.0.0-rc2" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore.Swagger" Version="5.0.0-rc2" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore.SwaggerGen" Version="5.0.0-rc2" /&gt;
    &lt;PackageReference Include="Swashbuckle.AspNetCore.SwaggerUi" Version="5.0.0-rc2" /&gt;

Hope it helps.

Bests</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41115</IssueID>
    <RepoID>1</RepoID>
    <Title>C#如何使用Microsoft.AspNetCore.SignalR.Client连接Hub</Title>
    <Description>严重性	代码	说明	项目	文件	行	禁止显示状态
错误	CS1061	'“HubConnectionBuilder”未包含“WithUrl”的定义，并且找不到可接受第一个“HubConnectionBuilder”类型参数的可访问扩展方法“WithUrl”(是否缺少 using 指令或程序集引用?)	WindowsFormsApp1	C:\Users\XWJ\source\repos\WindowsFormsApp1\WindowsFormsApp1\Form1.cs	23	活动的
</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41114</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @stephentoub</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41113</IssueID>
    <RepoID>1</RepoID>
    <Title>StringBuilder Perf Issue In .NET Core</Title>
    <Description>I have found in my benchmark tests, that the performance of StringBuilder in .NET Core 2.2 and 3 is less performant than in .NET 4.8.

If string.Concat() uses StringBuilder, that is less performant too.

Results below:
![image](https://user-images.githubusercontent.com/15676130/64915134-e1419480-d714-11e9-8cf0-104a09efa963.png)

Benchmark project located here: https://github.com/RealDotNetDave/dotNetTips.Benchmark.App</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41112</IssueID>
    <RepoID>1</RepoID>
    <Title>String.Equals() and == Perf Issue in .NET Core</Title>
    <Description>I have found a perf issue when comparing strings with Equals() and == in .NET Core. When compared to .NET 4.8, Core 2.2 is less performant and Core 3 is even slightly less performant than 2.2.

![image](https://user-images.githubusercontent.com/15676130/64915097-33ce8100-d714-11e9-9d2f-b73eeb4f05e1.png)

Examples:
```
testWord1.Equals(this.testWord2)
testWord1 == testWord2
```

Benchmark project located here: https://github.com/RealDotNetDave/dotNetTips.Benchmark.App
</Description>
    <CreatedDate>15/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41111</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Net.Requests dependency from System.Private.Xml</Title>
    <Description>Anything that uses System.Xml ends up implicitly referencing this System.Net.Requests.dll, which in a trimmed default MVC app is 97K (plus, System.Net.Requests.dll in turn references a whole bunch of stuff that's otherwise unused).  The only thing it's used for is as part of XmlResolver to download the specified url.  We can instead remove the usage of WebRequest.Create and replace it with usage of HttpClient, which is already brought in because System.Net.Requests uses it to implement HttpWebRequest.

@krwq, @buyaa-n, there are two breaking changes here (which is also why I've temporarily marked this as no-merge, until we can discuss it appropriately):
- Previously you could have specified a url with a scheme other than file, http, or https, and it may have worked.  To my knowledge the only other scheme that had built-in support was ftp, but you could also use WebRequest.RegisterPrefix to register a custom scheme handler, and then it seems that this XmlDownloadManager would have been able to use it.  How important is it to keep this functionality?  Have you ever seen or heard of someone using it with XmlResolver?
- Because we're now using HttpClient instead of HttpWebRequest, download failures that would have previously thrown WebException will now throw HttpRequestException.  How do we feel about that?  If you think it'll be impactful, we could push System.Net.WebException down to a lower-assembly, like System.Net.Primitives, but that'd be a bit unfortunate.

cc: @jkotas, @davidsh, @danmosemsft </Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41110</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove System.Net.Http dependency on System.Text.RegularExpressions</Title>
    <Description>This dependency is the only reason we end up with a 105K System.Text.RegularExpressions.dll as part of a trimmed new MVC app.  Regex is used in the case where on Windows a bypass list is provided, in which case each item in the list is changed into a regex, which is then evaluated against each url provided to SocketsHttpHandler.  But the patterns usable are simple: the only special character recognized is an asterisk, which can map to zero or more of any character.  So, we can instead employ a simple processor for such patterns, which then eliminates the need to reference System.Text.RegularExpressions.dll from System.Net.Http.dll.  It also happens to be faster.

cc: @ViktorHofer, @jkotas, @wfurt </Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41109</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable NoCallback_RevokedCertificate_NoRevocationChecking_Succeeds</Title>
    <Description>The remote server "revoked.badssl.com" has a certificate which is not only revoked but also
now untrusted since it has expired.

Disabling test for now

Contributes to #41108</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41108</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient NoCallback_RevokedCertificate_NoRevocationChecking_Succeeds failing</Title>
    <Description>The remote server "revoked.badssl.com" has a certificate which is not only revoked but also now untrusted since it has expired.

![image](https://user-images.githubusercontent.com/7684835/64910388-bfbbbb00-d6ca-11e9-8654-127a101558e0.png)

Will disable the test for now.</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41107</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer.Deserialize&lt;T&gt; can't work out my array of dictionaries</Title>
    <Description>My class is designed to get the items from an Amazon DynamoDB query so that they can be converted to T with a class that implements IEnumerable&lt;T&gt;

```csharp
    public class DynamoQueryResult&lt;T&gt; where T : class, new()
    {
        public int Count;
        public Dictionary&lt;string, DynamoValue&gt;[] Items;
    }
```

Newtonsoft can deserialize into this class with no difficulty at all, but JsonSerializer.Deserialize just leaves the array null.

Example json:

```json
{
  "ConsumedCapacity": {
    "CapacityUnits": 1,
    "TableName": "Reply"
  },
  "Count": 2,
  "Items": [
    {
      "ReplyDateTime": {"S": "2015-02-18T20:27:36.165Z"},
      "PostedBy": {"S": "User A"},
      "Id": {"S": "Amazon DynamoDB#DynamoDB Thread 1"}
    },
    {
      "ReplyDateTime": {"S": "2015-02-25T20:27:36.165Z"},
      "PostedBy": {"S": "User B"},
      "Id": {"S": "Amazon DynamoDB#DynamoDB Thread 1"}
    }
  ],
  "ScannedCount": 2
}
```

Don't blame me for the insane JSON, blame Amazon. This example is lifted directly out of their DynamoDB documentation (and therefore forms part of my unit tests)

Changing from ```Dictionary&lt;string, DynamoValue&gt;[]``` to ```ExpandoObject[]``` also didn't help, and now I feel dirty.</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41106</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190913.6
- **Date Produced**: 9/13/2019 4:20 PM
- **Commit**: 9042fe6c81aa3b47f58ccd94ff02e42f9f7a4e46
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19463.6
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19463.6
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19463.6

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190913.7
- **Date Produced**: 9/14/2019 3:54 AM
- **Commit**: f07730eedb1f7e2cb5e178d988bc2255f7ce7021
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19463.7
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19463.7

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190913.2
- **Date Produced**: 9/13/2019 12:49 PM
- **Commit**: 359e090799a32d167a51390cf3f4ce3ad875f227
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19463.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41105</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer.Deserialize&lt;T&gt; cannot deserialize into custom IEnumerable</Title>
    <Description>My class is designed to get the items from an Amazon DynamoDB query and convert them to T through the magic of the Enumerator:

```csharp
    public class DynamoQueryResult&lt;T&gt; : IEnumerable&lt;T&gt; where T : class, new()
    {
        public int Count;
        public Dictionary&lt;string, DynamoValue&gt;[] Items;
        public IEnumerator&lt;T&gt; GetEnumerator()
        {
            return new DynamoQueryResultEnumerator&lt;T&gt;(this);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new DynamoQueryResultEnumerator&lt;T&gt;(this);
        }
    }
```

Json Deserializers detect IEnumerable and expect the JSON at that level to therefore be a set (where this class represents a complex object containing both set metadata and set members). I can override that behaviour with Newtonsoft by adding the [JsonObject] attribute to the object and it does the job perfectly - and Newtonsoft's exception message gives a load of help which leads to this. I can't find a way to do the same for System.Text.Json. Also, really descriptive exception messages that guide the developer are one of my favourite things to create and see.

(Changing to an IReadOnlyCollection&lt;T&gt; doesn't help, but ReadOnly IEnumerables could be a way to 'hint' that they're not meant to be deserialized into?)

1. I know there is a big library of junk for dealing with Amazon stuff. That is not the answer I'm looking for - it's likely to just add delay and potentially more questions. This is a working _example_ of where this falls over.
2. In the immediate term, I'm likely to just create a customised collection to replace the array of dictionaries, but it would be cool if I could just convince the deserializer to fill the object.</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41104</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190913.2
- **Date Produced**: 9/14/2019 12:52 AM
- **Commit**: bce868f1ce96200f727784f1b855afb8a69513a3
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19463.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19463.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19463.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41103</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190913.3
- **Date Produced**: 9/13/2019 11:47 PM
- **Commit**: 7b731032220c21a3ed0021c72757b1f3122579b2
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19463.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19463.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19463.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19463.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19463.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19463.3

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41102</IssueID>
    <RepoID>1</RepoID>
    <Title>NotSupportedException when Deserializing object that has default values for constructor parameters</Title>
    <Description>The following code throws exception. 

```csharp
static void Main(string[] args)
{
    var obj = new Response(true, "Hi") { ResponseCode = 100 };
    var json = System.Text.Json.JsonSerializer.Serialize(obj);

    // System.NotSupportedException: 'Deserialization of reference types without parameterless constructor is not supported.
    var response = System.Text.Json.JsonSerializer.Deserialize&lt;Response&gt;(json);

    Console.WriteLine(response.Message);
}

public class Response
{
    public bool IsSuccess { get; set; }

    public string Message { get; set; }

    public int ResponseCode { get; set; }

    public Response(bool isSuccess = false, string message = "")
    {
        IsSuccess = isSuccess;
        Message = message;
    }
}
```

Response class is considered not having a parameterless constructor, but actually it does use default values for parameters, that can be used just like a parameterless constructor, like this:

```csharp
var test = new Response();
```

Could the new JSON API check if the constructor parameters have default values before consider it not paremeterless?

Related Issues: 
https://github.com/dotnet/corefx/issues/37537

PR:
https://github.com/dotnet/corefx/pull/38061</Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41101</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove unnecessary passing of RegexOptions.None to Regex ctor</Title>
    <Description>Doing so has no benefit and inhibits the benefits of the changes in https://github.com/dotnet/corefx/pull/41075.

cc: @krwq, @ViktorHofer </Description>
    <CreatedDate>14/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41144</IssueID>
    <RepoID>1</RepoID>
    <Title>BUG: Json.NET converter for IPAddress does not work in .NET Core 3.0 specifically</Title>
    <Description>Using Json.NET converters within the .NET Core 3.0 runtime fails. However in .NET Core 2.2 or .NET Framework 4.8 it works fine.

It seems like some "Type" is not coming through correctly.

.NET Core versions are both using the same .NET Standard 2.0 Json.NET lib.
This makes me think its a .NET runtime issue of some kind or another but I can't be sure.

**Download this example project that you can reproduce the issue with.**
https://vrstudios-my.sharepoint.com/:u:/p/andrew_witte/ETIlqlXTlu1Moiz2Q2MYsAUBIje5Z96Zij7xGPL3wAO6wA?e=sz1oDH

Win10 x64 1904
OS Build: 18362.356
Visual Studio 2019 16.3.0 Preview 3.0
.NET Core 3.0.100-preview9-014004
.NET Core 2.2.104

Here are all my available .NET Core versions installed.
```
1.0.0-preview1-002702
1.0.0-preview2-003121
1.0.0-preview2-003131
1.0.1
1.0.2
1.0.3
1.0.4
1.1.0
2.0.2
2.0.3
2.1.100
2.1.101
2.1.102
2.1.103
2.1.104
2.1.2
2.1.200
2.1.201
2.1.202
2.1.4
2.1.400
2.1.401
2.1.402
2.1.403
2.1.500
2.1.502
2.1.503
2.1.504
2.1.505
2.1.507
2.1.508
2.1.509
2.1.602
2.1.604
2.1.700
2.1.700-preview-009618
2.1.701
2.1.800
2.1.800-preview-009677
2.1.800-preview-009696
2.1.801
2.1.802
2.2.101
2.2.103
2.2.104
3.0.100-preview9-014004
```

VS info
```
Microsoft Visual Studio Community 2019 Preview
Version 16.3.0 Preview 3.0
VisualStudio.16.Preview/16.3.0-pre.3.0+29230.61
Microsoft .NET Framework
Version 4.8.03752

Installed Version: Community

Visual C++ 2019   00435-60000-00000-AA947
Microsoft Visual C++ 2019

Application Insights Tools for Visual Studio Package   9.1.00815.1
Application Insights Tools for Visual Studio

ASP.NET and Web Tools 2019   16.3.277.18560
ASP.NET and Web Tools 2019

ASP.NET Core Blazor Language Services   16.0.19227.01

ASP.NET Web Frameworks and Tools 2019   16.3.277.18560
For additional information, visit https://www.asp.net/

Azure App Service Tools v3.0.0   16.3.277.18560
Azure App Service Tools v3.0.0

Azure Functions and Web Jobs Tools   16.3.277.18560
Azure Functions and Web Jobs Tools

C# Tools   3.3.1-beta3-19430-03+fa8e2c9b566e4471a3509fc63d7baca0a2a6d30b
C# components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.

Common Azure Tools   1.10
Provides common services for use by Azure Mobile Services and Microsoft Azure Tools.

ConvertToDevExtremeCommand Extension   1.0
ConvertToDevExtremeCommand Visual Studio Extension Detailed Info

IntelliCode Extension   1.0
IntelliCode Visual Studio Extension Detailed Info

Microsoft Azure Tools   2.9
Microsoft Azure Tools for Microsoft Visual Studio 0x10 - v2.9.20816.1

Microsoft Continuous Delivery Tools for Visual Studio   0.4
Simplifying the configuration of Azure DevOps pipelines from within the Visual Studio IDE.

Microsoft JVM Debugger   1.0
Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines

Microsoft Library Manager   2.0.83+gbc8a4b23ec
Install client-side libraries easily to any web project

Microsoft MI-Based Debugger   1.0
Provides support for connecting Visual Studio to MI compatible debuggers

Microsoft Visual C++ Wizards   1.0
Microsoft Visual C++ Wizards

Microsoft Visual Studio Tools for Containers   1.1
Develop, run, validate your ASP.NET Core applications in the target environment. F5 your application directly into a container with debugging, or CTRL + F5 to edit &amp; refresh your app without having to rebuild the container.

Microsoft Visual Studio VC Package   1.0
Microsoft Visual Studio VC Package

NuGet Package Manager   5.3.0
NuGet Package Manager in Visual Studio. For more information about NuGet, visit https://docs.nuget.org/

ProjectServicesPackage Extension   1.0
ProjectServicesPackage Visual Studio Extension Detailed Info

SQL Server Data Tools   16.0.61908.27190
Microsoft SQL Server Data Tools

Test Adapter for Boost.Test   1.0
Enables Visual Studio's testing tools with unit tests written for Boost.Test.  The use terms and Third Party Notices are available in the extension installation directory.

Test Adapter for Google Test   1.0
Enables Visual Studio's testing tools with unit tests written for Google Test.  The use terms and Third Party Notices are available in the extension installation directory.

TypeScript Tools   16.0.10821.2002
TypeScript Tools for Microsoft Visual Studio

Visual Basic Tools   3.3.1-beta3-19430-03+fa8e2c9b566e4471a3509fc63d7baca0a2a6d30b
Visual Basic components used in the IDE. Depending on your project type and settings, a different version of the compiler may be used.

Visual F# Tools 10.4 for F# 4.6   16.3.0-beta.19421.2+9f51ac5290b1dfc5dc434841d61b2ac31997ea8c
Microsoft Visual F# Tools 10.4 for F# 4.6

Visual Studio Code Debug Adapter Host Package   1.0
Interop layer for hosting Visual Studio Code debug adapters in Visual Studio

Visual Studio Tools for CMake   1.0
Visual Studio Tools for CMake

Visual Studio Tools for CMake   1.0
Visual Studio Tools for CMake

Visual Studio Tools for Containers   1.0
Visual Studio Tools for Containers
```</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41100</IssueID>
    <RepoID>1</RepoID>
    <Title>Why not write more than 1 byte to the buffer and that way reduce the number of calls to Next/InternalSample in System.Random.NextBytes?</Title>
    <Description>I noticed in another issue that the implementation of NextBytes should not be changed (https://github.com/dotnet/corefx/issues/22356#issuecomment-325815511) and I don't know how good the distribution would be.
But it seem like the number of calls to Next/InternalSample could be reduced by 4 (best case), if using all 4 bytes in the int returned by Next/InternalSample. Would there be arguments against that?

https://github.com/dotnet/corefx/blob/d58a51f911efb3c98beca21b6cf08cc703424fdf/src/Common/src/CoreLib/System/Random.cs#L253-L259
https://github.com/dotnet/corefx/blob/d58a51f911efb3c98beca21b6cf08cc703424fdf/src/Common/src/CoreLib/System/Random.cs#L244-L251</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41099</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSecurity/DirectorySecurity should support long paths</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/29275

Original PR branch got in a weird state so I am submitting again: https://github.com/dotnet/corefx/pull/40921

FileSecurity fails to read permissions from file that have a path length exceeding 259 characters. I discovered that `DirectorySecurity` has the same issue.

Changes in this PR:

- Removed unused `fullPath` string that was being created inside the `FileSecurity` and `DirectorySecurity` constructors that receive a `fileName` string.

- Parent class `NativeObjectSecurity` in `System.Security.AccessControl` throws unhandled `ERROR_PATH_NOT_FOUND` if the file does not exist. Which is weird because we already handle `ERROR_FILE_NOT_FOUND`. SO I added this error to this other existing `else`, so that we keep throwing the same exception.

- Added unit tests for the `FileSecurity` and `DirectorySecurity` constructors that accept a long filename string.

- The `FileSecurity` class had an internal constructor with an unused parameter `fullPath` and a warning about that unused parameter. Removed unused parameter along with the unnecessary warning comment. Made sure to update the only internal usage of that constructor so it uses the new signature.

- `FileSecurity` and `DirectorySecurity` seem to only be available for Windows, but the documentation is not clear about this restriction. I can add a comment indicating that these classes are exclusive for Windows.

- Renamed internal `FileSystemSecurity` constructor's parameter `name` to `fileName` for clarity.
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41098</IssueID>
    <RepoID>1</RepoID>
    <Title>Serialization performance improvements</Title>
    <Description>Serialization improvements from 15%-28% on existing benchmarks (for simple objects).

Changes in order of most impact to lesser impact:
- Use `[AggressiveInlining]` when processing property values. Required some misc refactoring so that the methods inlined are only called once (instead of twice).
- Using an array instead of Dictionay enumerator to obtain properties to serialize.
- Changing a property to a field (struct for `JsonEncodedTest`) to avoid a copy on read.
- Removing unused return values and misc cleanup.

**WriteJson benchmarks**

| Faster                                                                           | base/diff | Base Median (ns) | Diff Median (ns) | Modality|
|----------------------------------------------------------------------------------|----------:|-----------------:|-----------------:|--------:| 
| System.Text.Json.Serialization.Tests.WriteJson&lt;Location&gt;.SerializeToUtf8Bytes    |      1.41 |          1328.46 |           944.13 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;LoginViewModel&gt;.SerializeToString |      1.40 |           592.57 |           422.00 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;LoginViewModel&gt;.SerializeToUtf8By |      1.40 |           547.15 |           389.85 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;Location&gt;.SerializeToString       |      1.36 |          1372.30 |          1006.11 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;LoginViewModel&gt;.SerializeToStream |      1.36 |           653.96 |           480.28 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;Location&gt;.SerializeToStream       |      1.35 |          1435.65 |          1061.99 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;IndexViewModel&gt;.SerializeToUtf8By |      1.29 |         35629.31 |         27513.08 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;IndexViewModel&gt;.SerializeToStream |      1.27 |         34489.63 |         27073.81 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;IndexViewModel&gt;.SerializeToString |      1.26 |         36860.43 |         29178.57 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;MyEventsListerViewModel&gt;.Serializ |      1.20 |        614502.43 |        513175.55 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;MyEventsListerViewModel&gt;.Serializ |      1.19 |        618552.11 |        518655.83 |         |
| System.Text.Json.Serialization.Tests.WriteJson&lt;MyEventsListerViewModel&gt;.Serializ |      1.19 |        663942.62 |        559237.31 |         |


**Comparisons to Json.NET**

MyEventsListerViewModel Before

|         Method |     Mean |    Error |   StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|---------:|---------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 782.3 us | 2.066 us | 1.933 us | 781.6 us | 779.2 us | 785.3 us |     94.6372 |     47.3186 |     47.3186 |           565.39 KB |
| SystemTextJson | 664.6 us | 4.227 us | 3.954 us | 664.6 us | 658.5 us | 673.5 us |     45.0928 |     45.0928 |     45.0928 |           381.33 KB |

MyEventsListerViewModel After

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 787.8 us |  2.807 us |  2.488 us | 786.9 us | 784.9 us | 793.4 us |     94.9367 |     47.4684 |     47.4684 |           564.91 KB |
| SystemTextJson | 574.4 us | 13.518 us | 15.567 us | 568.1 us | 558.8 us | 608.1 us |     45.9770 |     45.9770 |     45.9770 |           380.87 KB |

IndexViewModel Before

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 40.50 us | 0.1701 us | 0.1591 us | 40.48 us | 40.26 us | 40.84 us |      9.6556 |      1.6093 |           - |            59.33 KB |
| SystemTextJson | 36.95 us | 0.1801 us | 0.1597 us | 36.90 us | 36.72 us | 37.32 us |      3.9677 |      0.2939 |           - |            25.13 KB |

IndexViewModel After

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 40.03 us | 0.1336 us | 0.1249 us | 40.00 us | 39.88 us | 40.27 us |      9.5602 |      1.5934 |           - |            59.33 KB |
| SystemTextJson | 27.48 us | 0.1451 us | 0.1211 us | 27.46 us | 27.34 us | 27.79 us |      3.9739 |      0.3312 |           - |            25.01 KB |

Location Before

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 1.439 us | 0.0032 us | 0.0028 us | 1.439 us | 1.434 us | 1.443 us |      0.2758 |           - |           - |              1736 B |
| SystemTextJson | 1.370 us | 0.0038 us | 0.0034 us | 1.370 us | 1.366 us | 1.375 us |      0.0930 |           - |           - |               584 B |

Location After

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 1.429 us | 0.0077 us | 0.0069 us | 1.427 us | 1.422 us | 1.445 us |      0.2724 |           - |           - |              1736 B |
| SystemTextJson | 1.007 us | 0.0029 us | 0.0026 us | 1.006 us | 1.002 us | 1.011 us |      0.0924 |           - |           - |               584 B |

LoginViewModel Before

|         Method |     Mean |    Error |   StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|---------:|---------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 696.4 ns | 3.961 ns | 3.511 ns | 695.3 ns | 692.5 ns | 703.4 ns |      0.2375 |           - |           - |              1504 B |
| SystemTextJson | 599.8 ns | 1.602 ns | 1.420 ns | 599.6 ns | 597.6 ns | 603.2 ns |      0.0527 |           - |           - |               344 B |

LoginViewModel After

|         Method |     Mean |    Error |   StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|---------:|---------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 665.9 ns | 3.070 ns | 2.722 ns | 665.3 ns | 661.1 ns | 670.1 ns |      0.2391 |           - |           - |              1504 B |
| SystemTextJson | 434.6 ns | 1.487 ns | 1.318 ns | 434.6 ns | 432.6 ns | 436.6 ns |      0.0539 |           - |           - |               344 B |
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41097</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonSerializer.Deserialize results in a null ref when attempting to deserialize open generic Nullable&lt;&gt;</Title>
    <Description>Not a useful scenario by any means, but the exception message could be better:

```C#
var type = typeof(Nullable&lt;&gt;);
JsonSerializer.Deserialize("1", type);

Unhandled exception. System.ArgumentNullException: Value cannot be null. (Parameter 'key')
   at System.Collections.Concurrent.ConcurrentDictionary`2.ThrowKeyNullException()
   at System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(TKey key, TValue&amp; value)
   at System.Text.Json.JsonSerializerOptions.GetConverter(Type typeToConvert)
   at System.Text.Json.JsonClassInfo.GetClassType(Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonClassInfo..ctor(Type type, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializerOptions.GetOrAddClass(Type classType)
   at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader)
   at System.Text.Json.JsonSerializer.ParseCore(String json, Type returnType, JsonSerializerOptions options)
   at System.Text.Json.JsonSerializer.Deserialize(String json, Type returnType, JsonSerializerOptions options)
```</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41096</IssueID>
    <RepoID>1</RepoID>
    <Title>Allows JsonStringEnumConverter.CreateConverter to specify a default enum value</Title>
    <Description>that allows parsing unrecognized strings/numbers into a specified default enum value. Currently if unrecognized strings/numbers are encountered an exception is thrown.</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41095</IssueID>
    <RepoID>1</RepoID>
    <Title>SerialStream does not support cancellation on Windows</Title>
    <Description>Current Windows implementation does not respect cancellation but Unix implementation does.

We should consider doing similar effort for Windows.

cc: @dquist
Created per: https://github.com/dotnet/corefx/issues/25154#issuecomment-531217979

Marking as 5.0 to consider. Note that netfx also does not support cancellation there.</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41093</IssueID>
    <RepoID>1</RepoID>
    <Title>[Url] attribute allows spaces</Title>
    <Description>_From @MythreyaK on Friday, September 13, 2019 10:01:50 AM_

### Describe the bug
The [Url] attribute accepts URLs of the form `http://www.exam ple.com` and &lt;br/&gt; `http://example.com/foo bar`. From what I've read around, a URL shouldn't contain a literal space. Is this the expected behavior?

### To Reproduce
Steps to reproduce the behavior:
1. Using this version of ASP.NET Core '2.2.0' (from what I've seen in my solution 😅)
2. Use the `[Url]` attribute *
3. Try storing URLs such as `http://example.com/foo bar` or `http://www.exam ple.com`
4. Fail to see a validation error 

&lt;sub&gt;* I'm currently using this is a personal project [here](github.com/MythreyaK/URL-Shortener) . I'm still learning, so please be gentle, do leave feedback, Thanks! 😁 &lt;/sub&gt;

### Expected behavior
A validation error should be raised since a URL cannot contain a _literal_ space.  

### Additional context
&lt;details&gt;
&lt;summary&gt; &lt;code&gt;dotnet --info&lt;/code&gt; output (click to expand)&lt;/summary&gt;

```
.NET Core SDK (reflecting any global.json):
 Version:   2.2.402
 Commit:    c7f2f96116

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.2.402\

Host (useful for support):
  Version: 2.2.7
  Commit:  b1e29ae826

.NET Core SDKs installed:
  2.1.700 [C:\Program Files\dotnet\sdk]
  2.1.801 [C:\Program Files\dotnet\sdk]
  2.1.802 [C:\Program Files\dotnet\sdk]
  2.2.300 [C:\Program Files\dotnet\sdk]
  2.2.401 [C:\Program Files\dotnet\sdk]
  2.2.402 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.13 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```
&lt;/details&gt;

&lt;hr/&gt;

- Content: [Model validation in ASP.NET Core MVC](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-2.2#feedback)
- Content Source: [aspnetcore/mvc/models/validation.md](https://github.com/aspnet/AspNetCore.Docs/blob/master/aspnetcore/mvc/models/validation.md)
- Same issue was raised on the `.NET Core` docs page [here](https://github.com/aspnet/AspNetCore.Docs/issues/14283#issue-492998460)

_Copied from original issue: aspnet/AspNetCore#13946_</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41092</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Collections.Specialized for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41091</IssueID>
    <RepoID>1</RepoID>
    <Title>Reading HttpResponseMessage.Content.Headers.ContentLength allocates ContentLength memory even with HEAD request</Title>
    <Description>This is dotnet core 2.2, using the default IHttpClientFactory. Making a HEAD request to check size of  a file to download. Accessing the Content.Headers.ContentLength property of the HttpResponseMessage causes memory to be allocated equal to the value of ContentLength.
![MemoryAllocation](https://user-images.githubusercontent.com/37562625/64879079-59736180-d612-11e9-82a1-56142915f0f0.jpg)
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41090</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190912.26
- **Date Produced**: 9/13/2019 3:51 AM
- **Commit**: 580567cedf08cbb182a2d8e93fd10e1029e30106
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19462.26
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19462.26
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19462.26

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190912.15
- **Date Produced**: 9/13/2019 5:08 AM
- **Commit**: 31a5bba0e79a5ae875f691d70ec3b9789691136d
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19462.15
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19462.15

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190912.3
- **Date Produced**: 9/12/2019 1:02 PM
- **Commit**: 41409cc00210db660d38ad5098f45479e1526387
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19462.3

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41089</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190912.7
- **Date Produced**: 9/13/2019 2:19 AM
- **Commit**: 9c8ba7773e506db05016f1c278a7a1ea27816dbf
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19462.7
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19462.7
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19462.7

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41088</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190912.5
- **Date Produced**: 9/13/2019 5:59 AM
- **Commit**: 6003ee189f456c92a18b097f226d4927309def27
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19462.5
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19462.5
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19462.5
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19462.5
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19462.5
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19462.5

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41087</IssueID>
    <RepoID>1</RepoID>
    <Title>SmtpClientTest.TestZeroTimeout: FailFast to get CI coredump</Title>
    <Description>To help debug https://github.com/dotnet/corefx/issues/40711

CC @ViktorHofer @stephentoub @wfurt 
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41085</IssueID>
    <RepoID>1</RepoID>
    <Title>VS Code Debugging Instructions</Title>
    <Description>I used [these instructions](https://github.com/dotnet/corefx/blob/master/Documentation/debugging/unix-instructions.md) to set up VS Code for debugging corefx. However, the `dotnet` in the program path: `corefx/bin/testhost/netcoreapp-Linux-{Configuration}-{Architecture}` (adjusted to include `artifacts` as is current directory structure) failed for me with:
```
The specified framework 'Microsoft.NETCore.App', version '2.1.0' was not found.
  - The following frameworks were found:
      5.0.0 at [/home/manicka/corefx/artifacts/bin/testhost/netcoreapp-Linux-Debug-x64/shared/Microsoft.NETCore.App]
```

The 5.0.0 is a version of dotnet residing in `artifacts/bin/testhost/`, the 2.1.0 is in xunit console configuration in the test bin directory (`artifacts/bin/System.Net.NetworkInformation.Functional.Tests/netcoreapp-Debug/xunit.console.runtimeconfig.json`).

I got it eventually running with using `dotnet` from `.dotnet/dotnet` directory and changing the xunit configuration to reflect its version.

And I'm using Visual Studio Code with WSL2.

I'm not sure if what I'm doing is right. If I'm not, please tell me how to do it right.
I'll gladly update the documentation once it's clear what's the right set up.

Pinging: @ViktorHofer, @wtgodbe you're the last people editing this part of the doc.</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41084</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190912.8
- **Date Produced**: 9/13/2019 3:55 AM
- **Commit**: 012b987f4d2c5af26f1e76c81a75e938e5b219f8
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19462.8
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19462.8
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19462.8

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41083</IssueID>
    <RepoID>1</RepoID>
    <Title>improve portability of GetAsync_InvalidUrl_ExpectedExceptionThrown test</Title>
    <Description>GetAsync_InvalidUrl_ExpectedExceptionThrown test uses guid to construct invalid name. In my case, my ISP would happily resolve that name and it would redirect me to server serving adds.

```
macik2:FunctionalTests furt$ curl -v http://_9c036a244c4e4c47a3f86e0e35065793/
*   Trying 198.105.244.23...
* TCP_NODELAY set
* Connected to _9c036a244c4e4c47a3f86e0e35065793 (198.105.244.23) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; Host: _9c036a244c4e4c47a3f86e0e35065793
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 301 Moved Permanently
&lt; Server: nginx
&lt; Date: Fri, 13 Sep 2019 05:25:30 GMT
&lt; Content-Type: text/html

```

while this is not problem with CI, it forced me to manually disable this test if I want to get clean pass. 

We already have passinfg tests with invalid name so I rte-factor them a little bit and I updated GetAsync_InvalidUrl_ExpectedExceptionThrown to use same name instead of generated guid. </Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41082</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190912.6
- **Date Produced**: 9/12/2019 11:29 PM
- **Commit**: 726eeb87abf82df81528db8ecba0502aa46a4691
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19462.6
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19462.6
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19462.6

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41081</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190912.5
- **Date Produced**: 9/12/2019 11:19 PM
- **Commit**: 922429db0144dd6f3b4324805464dae82857512a
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19462.5
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19462.5
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19462.5

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41080</IssueID>
    <RepoID>1</RepoID>
    <Title>FileSystemWatcher Deleted event not firing when moving multiple files outside the watched folder on macOS 10.13</Title>
    <Description>This was opened in Mono and bringing it upstream.

_From @jesh182 on Tue, 10 Sep 2019 15:01:54 GMT_

&lt;!-- 🚨 STOP 🚨 𝗦𝗧𝗢𝗣 🚨 𝑺𝑻𝑶𝑷 🚨 --&gt;

&lt;!--
Please fill in the *entire* template below.
The template is designed to avoid unnecessary delays to confirm and fix reported issues. Issues with missing information generally end up with a `need-info` label and take significantly more time to fix. Please help us help you!
For more information see https://github.com/xamarin/xamarin-macios/wiki/Submitting-Bugs-&amp;-Suggestions
For support requests use https://www.xamarin.com/support
--&gt;
### Steps to Reproduce

1.  Add 3 files to the watched folder (The folder is "SomeFolder" inside user's home folder /Users/username/SomeFolder).
2.  Move the 3 files out of the watched folder at the same time (Move to trash also do the same).

### Expected Behavior
- Deleted event should be fired for each moved file.

Console:
Deleted FirstFile.jpg
Deleted SecondFile.jpg
Deleted ThirdFile.jpg
### Actual Behavior
- Renamed event gets fired, with one file (random of the 3 files inside the folder) as OldName and another file (random of the 3 files inside the folder) as Name.
- Deleted event gets fired, with the last file (the one that was not included by the renamed event)

Console:
Renamed from: FirstFile.jpg to: SecondFile.jpg
Deleted ThirdFile.jpg
### Environment

&lt;!--
1.
Visual Studio: Help &gt; About Microsoft Visual Studio &gt; Copy Info [button]
Visual Studio for Mac: Visual Studio &gt; About Visual Studio &gt; Show Details &gt; Copy Information [button]
2. Paste into the code block below (between ```)
--&gt;

```
=== Visual Studio Community 2019 for Mac ===

Version 8.2.3 (build 16)
Installation UUID: 4dc24200-d747-41ce-9ca4-dece69112cf5
	GTK+ 2.24.23 (Raleigh theme)
	Xamarin.Mac 5.14.0.85 (d16-2-fix-mac-updates / 86973979)

	Package version: 600000319

=== Mono Framework MDK ===

Runtime:
	Mono 6.0.0.319 (2019-02/52203786470) (64-bit)
	Package version: 600000319

=== NuGet ===

Version: 5.1.0.6013

=== .NET Core ===

Runtime: /usr/local/share/dotnet/dotnet
Runtime Version: 2.1.12
SDK: /usr/local/share/dotnet/sdk/2.1.701/Sdks
SDK Version: 2.1.701
MSBuild SDKs: /Library/Frameworks/Mono.framework/Versions/6.0.0/lib/mono/msbuild/Current/bin/Sdks

=== Xamarin.Profiler ===

Version: 1.6.11
Location: /Applications/Xamarin Profiler.app/Contents/MacOS/Xamarin Profiler

=== Updater ===

Version: 11

=== Xamarin.Android ===

Not Installed

=== Microsoft Mobile OpenJDK ===

Java SDK: Not Found

Android Designer EPL code available here:
https://github.com/xamarin/AndroidDesigner.EPL

=== Android Device Manager ===

Version: 1.2.0.60
Hash: 686c817
Branch: remotes/origin/d16-2
Build date: 2019-08-07 15:49:58 UTC

=== Xamarin Designer ===

Version: 16.2.0.379
Hash: 3f0652957
Branch: remotes/origin/d16-2
Build date: 2019-08-01 17:32:50 UTC

=== Apple Developer Tools ===

Xcode 10.0 (14320.25)
Build 10A255

=== Xamarin.Mac ===

Version: 5.14.0.114 (Visual Studio Community)
Hash: c6691164
Branch: d16-2
Build date: 2019-07-29 15:54:06-0400

=== Xamarin.iOS ===

Xamarin.iOS not installed.
Can't find mtouch or the Version file at /Library/Frameworks/Xamarin.iOS.framework/Versions/Current.

=== Xamarin Inspector ===

Version: 1.4.3
Hash: db27525
Branch: 1.4-release
Build date: Mon, 09 Jul 2018 21:20:18 GMT
Client compatibility: 1

=== Build Information ===

Release ID: 802030016
Git revision: f438e4b3ac81dbc614da2f2d9ac3c70ea2e5c350
Build date: 2019-08-09 09:07:01+00
Build branch: release-8.2
Xamarin extensions: 67f026710e882e318fb0c90077b429be3dc0e688

=== Operating System ===

Mac OS X 10.13.6
Darwin 17.7.0 Darwin Kernel Version 17.7.0
    Sun Jun  2 20:31:42 PDT 2019
    root:xnu-4570.71.46~1/RELEASE_X86_64 x86_64
```

### Build Logs

&lt;!--
1. Place cursor below this comment block.
2. Attach build log or link to gist (https://gist.github.com/) of the log.
3. Logs can be found in the Build Output tab of the Errors pad in Visual Studio
To get full build logs, set the log verbosity to diagnostic at the following locations:
- On Visual Studio for Mac: Preferences &gt; Projects &gt; Build
- On Visual Studio for Windows: Tools &gt; Options &gt; Projects and Solutions &gt; Build and Run
On Visual Studio for Windows you also want to add `-v -v -v -v` to the mtouch additional arguments by right-clicking the project in the solution explorer and selecting `Properties`.
--&gt;
[FSWatcherBuildLog.txt](https://github.com/xamarin/xamarin-macios/files/3596290/FSWatcherBuildLog.txt)

### Example Project (If Possible)

&lt;!--
1. Place cursor below this comment block.
2. Drag and drop the compressed project or files needed to reproduce.
--&gt;
[FSWatcherMac.zip](https://github.com/xamarin/xamarin-macios/files/3596302/FSWatcherMac.zip)

&lt;!--
Switch to the "Preview" tab to ensure your issue renders correctly.
--&gt;


_Copied from original issue https://github.com/mono/mono/issues/16778_</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41079</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @mmitche
* @dotnet-maestro[bot]
* @ViktorHofer
* @Anipik
* @ahsonkhan
* @stephentoub
* @msftbot[bot]
* @danmosemsft
* @safern

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41078</IssueID>
    <RepoID>1</RepoID>
    <Title>improve socket timout tests</Title>
    <Description>This is attempt to improve stability of socket timeout tests as well as product improvement to make send timeouts more accurate. 

This removes most of #24844. When I was testing timeout tests, I noticed that for the blocking socket, actual timeouts are consistently about 2x of the value. For timeout 2s it would timeout in ~4s and for 5s timeout it would timeout in 10s and so on including very long timeouts.
Increasing test timeout in #24844 only hides that behavior. 

In case of Unix implementation we set socket timeout and we rely on OS to keep trying for given value. However when we fill up socket buffer OS keeps trying for given time. Then we see we wrote some bytes and we loop and we try to write more incurring set timeout once more. In general case this can go on for time far beyond configured value if we keep dribbling data out.

I added simple check to break from retry loop if we hit timeout value. With that, I changed expected time range back to more strict values.   

#23767 also has example where duration is negative. I think that can be because wall time was adjusted. I switched test to use monolithic TickCount64 to avoid issues with floating time. 

I also excluded timeout tests from parallel run to make execution more predictable as time is very important here. 

I also removed OuterLooop from two GetAndSet tests as there really should be no delay or external dependency. 
</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41077</IssueID>
    <RepoID>1</RepoID>
    <Title>Corefx native build produces a warning on latest VS Preview (16.4.0 Preview 1.0 29311.250)</Title>
    <Description>```
C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\MSBuild\Microsoft\VC\v160\Microsoft.CppCommon.targets(230,5): error MSB8065: Custom build for item "D:\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug-x64\CMakeFiles\8c5af364b615efc1be57a6c3114709e4\INSTA
LL_force.rule" succeeded, but specified output "d:\corefx\artifacts\obj\native\netcoreapp-windows_nt-debug-x64\cmakefiles\install_force" has not been created. This may cause incremental build to work incorrectly. [D:\corefx\artifacts\obj\native\netcoreapp-Windows_NT-Debug
-x64\install.vcxproj] [D:\corefx\src\Native\build-native.proj]
```

The build shows as failed even though it didn't really fail because the native step produced a warning so it keeps going. (We might need to propagate the TreatWarningsAsErrors to the native build command), but that is not the real issue there.

cc: @ViktorHofer @ericstj 

FYI: @carlossanlop </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41076</IssueID>
    <RepoID>1</RepoID>
    <Title>Stabilize package versions</Title>
    <Description>
    </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41075</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable Regex compiler to be trimmed</Title>
    <Description>Today an app that just does:
```C#
Console.WriteLine(Regex.IsMatch("12345", "0*[1-9][0-9]*"));
```
and is trimmed will end up publishing a 105K System.Text.RegularExpression.dll, including the regex compiler for when the RegexOptions.Compiled is used.  We can refactor the constructors such that the compiler only ends up getting rooted when one of the ctors that takes options is used.  After this PR, if you don't pass RegexOptions, the 105K drops to 85K.

cc: @ViktorHofer, @jkotas (@danmosemsft, just an example of what we talked about today)</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41074</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190912.5
- **Date Produced**: 9/12/2019 9:42 PM
- **Commit**: a5b5f2e1e369972c8ff1e2183979fab6099f52ef
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41073</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190912.5
- **Date Produced**: 9/12/2019 9:42 PM
- **Commit**: a5b5f2e1e369972c8ff1e2183979fab6099f52ef
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41072</IssueID>
    <RepoID>1</RepoID>
    <Title>Cleaning up packageIndex.json file to just have live building versions.</Title>
    <Description>Currently we record a bunch of stuff in our packageIndex.json file like

- Baseline Versions
- stable Package Version
- assembly-package relationship
- Inbox information

Currently we store all the stable versions and also specify the assembly version associated with that stable version.

The target here is to remove as much stuff possible and generate all this stuff at runtime.
This will help in maintaining the package and assembly versions.

cc @ericstj @ViktorHofer @danmosemsft </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41071</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr,corert</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr,corert


**Please REBASE this PR when merging**

 cc @NextTurn</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41070</IssueID>
    <RepoID>1</RepoID>
    <Title>Support nullable structs in JsonSerializer</Title>
    <Description>Given 

```C#
public class ClassWithNullablePerson
{
    public Person? Person { get; set; } = new Person();
}

public struct Person
{
    public string FirstName { get; set; }
    public int? Age { get; set; }
    public DateTime? Birthday { get; set; }
}
```

Serialization
```C#
string serialized = JsonSerializer.Serialize(new ClassWithNullablePerson());
Console.WriteLine(serialized)
// {"Person":{"HasValue":true,"Value":{"FirstName":null,"Age":null,"Birthday":null}}} (Actual)
// {"Person":{"FirstName":null,"Age":null,"Birthday":null}} (Expected)
```

Deserialization (Debug)
```C#
var person = JsonSerializer.Deserialize&lt;ClassWithNullablePerson&gt;(@"{""Person"":{""FirstName"":""Layo"",""Age"":22,""Birthday"":""1995-04-16""}}");
```

```
Process terminated. Assertion failed.
     at System.Text.Json.JsonSerializer.HandlePropertyName(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; state) in D:\repos\corefx\src\System.Text.Json\src\System\Text\Json
  \Serialization\JsonSerializer.Read.HandlePropertyName.cs:line 23
     at System.Text.Json.JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader&amp; reader, ReadStack&amp; readStack) in D:\repos\corefx\src\System.Text.Json\src\System\Text\Json\Seria
  lization\JsonSerializer.Read.cs:line 54
     at System.Text.Json.JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader&amp; reader) in D:\repos\corefx\src\System.Text.Json\src\System\Text\Json\Serializat
  ion\JsonSerializer.Read.Helpers.cs:line 17
```

In Release, deserialization returns an instance with null fields for the nested `Person` struct.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41069</IssueID>
    <RepoID>1</RepoID>
    <Title>Synchronize Http/2 HPack implementation between CoreFx and ASP.NET Core</Title>
    <Description>Part of https://github.com/aspnet/AspNetCore/issues/13900. Corresponding PR; https://github.com/aspnet/AspNetCore/pull/13931

This PR synchronizes the HTTP/2 HPack implementation between Kestrel and CoreFx. Eventually, we will find a mechanism for sharing this code, but this is a necessary step in creating a shared source. The only remaining differences between aspnetcore and corefx are exceptions and namespaces.

This PR changes the following functionality:
- Introduces an interface IHttpHeadersHandler, which is used to add headers to the Http2Stream. This is what we did in Kestrel; if people prefer a delegate, we can revert back.
- Renames StartDecode/Decode to BeginTryDecode/TryDecode
- The HPackEncoder between Kestrel and HttpClient are fundamentally different. I just merged the two classes together for now.

Open questions:
- The HPackDecoder in HttpClient supports resizing of _headerNameOctets, _headerValueOctets, etc. I think it's a good optimization, but I believe I didn't handle the merge correctly. I'll look into fixing that.
</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41068</IssueID>
    <RepoID>1</RepoID>
    <Title>Icon entry selection from file/stream does not consider color depth</Title>
    <Description>Originally reported in https://github.com/dotnet/winforms/issues/1825. #41048 fixes this, the change will need to be ported into 3.0.x.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41067</IssueID>
    <RepoID>1</RepoID>
    <Title>Making debugging of packageTesting easier.</Title>
    <Description>Instead of always manually passing the LocalPackagesPath this will pass the default path where generally local built packages are kept.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41066</IssueID>
    <RepoID>1</RepoID>
    <Title>Possible overflow in Partitioner #40201</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/40201</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41065</IssueID>
    <RepoID>1</RepoID>
    <Title>Update branding for Microsoft.Netcore.Platforms 2.1.6</Title>
    <Description>
    </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41063</IssueID>
    <RepoID>1</RepoID>
    <Title>Update branding for Microsoft.Netcore.Platforms 2.2.4</Title>
    <Description>
    </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41062</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190912.2
- **Date Produced**: 9/12/2019 2:56 PM
- **Commit**: 09023baddeb2e951d151015a0892e79520132135
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19462.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19462.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19462.2

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41061</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove allocations from Dns.*</Title>
    <Description>This started as an effort to reduce the size of `System.Net.NameResolution.dll` when publishing a trimmed app.  It's not that big to begin with, but it's carrying around a copy of all of the `IAsyncResult` helper types, because the `Get*Async` methods are currently wrappers for the `Begin/End*` methods.

This PR inverts that, wrapping the `Begin/End*` methods instead around the `Get*Async` methods, using the same `TaskToApm` helper we use in other places in corefx for the same purpose.  This makes the `Get*Async` methods faster and lighter weight, but it does increase the number/amount of allocation in the `Begin/End*` APIs.  Since these are considered legacy, I normally would consider that a good trade, however we still use these `Begin/End` methods in a few places in `System.Net.Sockets.dll` (which should be fixed later), and I didn't want to regress those use cases.

So, this also then trims some additional fat, which helps the `Get*Async` cases even further, and gets the `Begin/End*` to be even better than before the change.  This includes not allocating an `IPHostEntry` when we're just going to unwrap it and return its addresses, computing the exact `IPAddress[]` size we need rather than using a `List&lt;&gt;` to grow it and `ToArray` to create the actual array, avoiding creating the `HostName` if we don't need it, avoiding an unnecessary `SafeHandle` allocation, and avoiding a closure allocation in the `TaskToApm` helpers.

As part of this, I also noticed that we had some bugs in how some of our interop structures on Windows were defined.  In particular, fields that in the native types were size_t were defined as int rather than IntPtr in the managed code (this appears to be carry-over from when the types were only used with the 32-bit variants).  It appears we've been saved from corruption by padding, but I fixed it, regardless.

And as long as I was changing pretty much everything else, where I was touching code I also cleaned up some legacy style stuff.

**Size:**
In an app published as trimmed that just uses HttpClient to download a page, prior to this change, System.Net.NameResolution.dll was 30K; after this change it's 24K.

**Perf:**

|                           Method |                 Toolchain |          Mean |        Error | Allocated |
|--------------------------------- |-------------------------- |--------------:|-------------:|----------:|
|                GetHostEntry_Name | New | 140,461.01 ns | 1,506.485 ns |     200 B |
|                GetHostEntry_Name |  Old | 140,554.96 ns |   234.500 ns |     328 B |
|                                  |                           |               |              |           |
|            GetHostAddresses_Name | New | 139,344.50 ns |   470.858 ns |     120 B |
|            GetHostAddresses_Name |  Old | 144,846.26 ns | 2,773.511 ns |     328 B |
|                                  |                           |               |              |           |
|         GetHostAddresses_Address | New |      66.67 ns |     0.355 ns |      72 B |
|         GetHostAddresses_Address |  Old |      69.09 ns |     0.082 ns |      72 B |
|                                  |                           |               |              |           |
|           GetHostEntryAsync_Name | New | 202,342.23 ns | 1,192.177 ns |     394 B |
|           GetHostEntryAsync_Name |  Old | 205,828.40 ns | 1,580.557 ns |     736 B |
|                                  |                           |               |              |           |
|       GetHostAddressesAsync_Name | New | 201,192.37 ns |   392.106 ns |     312 B |
|       GetHostAddressesAsync_Name |  Old | 206,888.85 ns | 1,571.552 ns |     736 B |
|                                  |                           |               |              |           |
|    GetHostAddressesAsync_Address | New |      74.95 ns |     0.240 ns |     144 B |
|    GetHostAddressesAsync_Address |  Old |     255.51 ns |     0.659 ns |     448 B |
|                                  |                           |               |              |           |
|        BeginEndGetHostEntry_Name | New | 202,922.99 ns | 1,825.023 ns |     472 B |
|        BeginEndGetHostEntry_Name |  Old | 205,842.96 ns | 1,115.982 ns |     496 B |
|                                  |                           |               |              |           |
|    BeginEndGetHostAddresses_Name | New | 202,684.50 ns |   510.180 ns |     392 B |
|    BeginEndGetHostAddresses_Name |  Old | 208,066.47 ns | 2,733.112 ns |     498 B |
|                                  |                           |               |              |           |
| BeginEndGetHostAddresses_Address | New |     117.19 ns |     0.543 ns |     176 B |
| BeginEndGetHostAddresses_Address |  Old |     216.04 ns |     1.604 ns |     272 B |


```C#
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using System.Net;
using System.Threading;
using System.Threading.Tasks;

[MemoryDiagnoser]
public class Program
{
    public static void Main(string[] args) =&gt; BenchmarkSwitcher.FromTypes(new[] { typeof(Program) }).Run(args);
    
    private ManualResetEventSlim _mre = new ManualResetEventSlim();

    [Benchmark] public IPHostEntry GetHostEntry_Name() =&gt; Dns.GetHostEntry("bing.com");

    [Benchmark] public IPAddress[] GetHostAddresses_Name() =&gt; Dns.GetHostAddresses("bing.com");
    [Benchmark] public IPAddress[] GetHostAddresses_Address() =&gt; Dns.GetHostAddresses("13.107.21.200");

    [Benchmark] public Task GetHostEntryAsync_Name() =&gt; Dns.GetHostEntryAsync("bing.com");

    [Benchmark] public Task GetHostAddressesAsync_Name() =&gt; Dns.GetHostAddressesAsync("bing.com");
    [Benchmark] public Task GetHostAddressesAsync_Address() =&gt; Dns.GetHostAddressesAsync("13.107.21.200");

    [Benchmark]
    public void BeginEndGetHostEntry_Name()
    {
        _mre.Reset();
        Dns.BeginGetHostEntry("bing.com", iar =&gt;
        {
            Dns.EndGetHostEntry(iar);
            ((ManualResetEventSlim)iar.AsyncState).Set();
        }, _mre);
        _mre.Wait();
    }

    [Benchmark]
    public void BeginEndGetHostAddresses_Name()
    {
        _mre.Reset();
        Dns.BeginGetHostAddresses("bing.com", iar =&gt;
        {
            Dns.EndGetHostAddresses(iar);
            ((ManualResetEventSlim)iar.AsyncState).Set();
        }, _mre);
        _mre.Wait();
    }

    [Benchmark]
    public void BeginEndGetHostAddresses_Address()
    {
        _mre.Reset();
        Dns.BeginGetHostAddresses("13.107.21.200", iar =&gt;
        {
            Dns.EndGetHostAddresses(iar);
            ((ManualResetEventSlim)iar.AsyncState).Set();
        }, _mre);
        _mre.Wait();
    }
}
```
</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41060</IssueID>
    <RepoID>1</RepoID>
    <Title>oob 4.6.0-preview packages don't work with nuget 3.5 (VS 2015)</Title>
    <Description>Tried 
- System.Diagnostics.DiagnosticSource  4.6.0-preview*
- System.Runtime.CompilerServices.Unsafe  4.6.0-preview*
- System.Text.Json 4.6.0-preview*

All packages descriptions mention they work with 3.4+ `When using NuGet 3.x this package requires at least version 3.4.`

Is this expected behavior: 

1.  Visual Studio does not list or find versions after 4.5.* (with prerelease enabled). nuget.exe does not list them

```
PS C:\Users\lmolkova.EUROPE\Downloads\nuget35&gt; ..\nuget35\nuget.exe list System.Text.Json -Prerelease
System.Text.Json.Mobile 2.0.0.6
XLabs.Serialization.SystemTextJson 2.0.5783-pre01
```


2.  Installing oob packages with nuget.exe or package manager console explicitly works fine

```
PS C:\Users\lmolkova.EUROPE\Downloads\nuget35&gt; ..\nuget35\nuget.exe install System.Text.Json -Version 4.6.0-preview9.19421.4
Feeds used:
  C:\Users\lmolkova.EUROPE\.nuget\packages\
  https://www.nuget.org/api/v2/
  https://www.myget.org/F/applicationinsights/api/v3/index.json
  https://api.nuget.org/v3/index.json



Attempting to gather dependency information for package 'System.Text.Json.4.6.0-preview9.19421.4' with respect to project 'C:\Users\lmolkova.EUROPE\Downloads\nuget35', targeting 'Any,Version=v0.0'
Gathering dependency information took 2.34 sec
Attempting to resolve dependencies for package 'System.Text.Json.4.6.0-preview9.19421.4' with DependencyBehavior 'Lowest'
Resolving dependency information took 0 ms
Resolving actions to install package 'System.Text.Json.4.6.0-preview9.19421.4'
Resolved actions to install package 'System.Text.Json.4.6.0-preview9.19421.4'
Retrieving package 'Microsoft.Bcl.AsyncInterfaces 1.0.0-preview9.19421.4' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Buffers 4.5.0' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Numerics.Vectors 4.5.0' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.ValueTuple 4.5.0' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Threading.Tasks.Extensions 4.5.2' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Memory 4.5.3' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Runtime.CompilerServices.Unsafe 4.6.0-preview9.19421.4' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Text.Encodings.Web 4.6.0-preview9.19421.4' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Retrieving package 'System.Text.Json 4.6.0-preview9.19421.4' from 'C:\Users\lmolkova.EUROPE\.nuget\packages\'.
Adding package 'System.Buffers.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Buffers.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Buffers 4.5.0' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Numerics.Vectors.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Numerics.Vectors.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Numerics.Vectors 4.5.0' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Runtime.CompilerServices.Unsafe.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Runtime.CompilerServices.Unsafe.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Runtime.CompilerServices.Unsafe 4.6.0-preview9.19421.4' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Memory.4.5.3' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Memory.4.5.3' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Memory 4.5.3' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Text.Encodings.Web.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Text.Encodings.Web.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Text.Encodings.Web 4.6.0-preview9.19421.4' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Threading.Tasks.Extensions.4.5.2' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Threading.Tasks.Extensions.4.5.2' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Threading.Tasks.Extensions 4.5.2' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'Microsoft.Bcl.AsyncInterfaces.1.0.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'Microsoft.Bcl.AsyncInterfaces.1.0.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'Microsoft.Bcl.AsyncInterfaces 1.0.0-preview9.19421.4' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.ValueTuple.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.ValueTuple.4.5.0' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.ValueTuple 4.5.0' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
Adding package 'System.Text.Json.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Added package 'System.Text.Json.4.6.0-preview9.19421.4' to folder 'C:\Users\lmolkova.EUROPE\Downloads\nuget35'
Successfully installed 'System.Text.Json 4.6.0-preview9.19421.4' to C:\Users\lmolkova.EUROPE\Downloads\nuget35
```

3. Installing packages that *depend* on oob package results in error


```
PS C:\Users\lmolkova.EUROPE\Downloads\nuget35&gt; .\nuget install Microsoft.ApplicationInsights -Version 2.11.0-beta2  -NoCache                                                                  Feeds used:
  https://www.nuget.org/api/v2/
  https://www.myget.org/F/applicationinsights/api/v3/index.json
  https://api.nuget.org/v3/index.json



Attempting to gather dependency information for package 'Microsoft.ApplicationInsights.2.11.0-beta2' with respect to project 'C:\Users\lmolkova.EUROPE\Downloads\nuget35', targeting 'Any,Version=v0.0'
Gathering dependency information took 5.68 sec
Attempting to resolve dependencies for package 'Microsoft.ApplicationInsights.2.11.0-beta2' with DependencyBehavior 'Lowest'
Unable to find a version of 'System.Diagnostics.DiagnosticSource' that is compatible with 'Microsoft.ApplicationInsights 2.11.0-beta2 constraint: System.Diagnostics.DiagnosticSource (&gt;= 4.6.0-preview7.19362.9)'.
```</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41059</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Security.Cryptography.Rsa.Tests.SignVerify_Span.UseAfterDispose test fails in CI</Title>
    <Description>https://dev.azure.com/dnceng/public/_build/results?buildId=348054&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=10446342&amp;resultId=162253&amp;paneView=attachments

Configuration: netcoreapp-Windows_NT-Debug-x64-Windows.10.Amd64.ClientRS4.ES.Open

Helix log: https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-corefx-refs-pull-40900-merge-5ba908466b9b428b92/System.Security.Cryptography.Algorithms.Tests/console.07b8bd9b.log?sv=2018-03-28&amp;sr=c&amp;sig=tmxYfMiRfpnbw4vePIZ1H8JZKD%2BYOap9peAkPqaofII%3D&amp;se=2019-09-20T19%3A59%3A51Z&amp;sp=rl

```
System.Security.Cryptography.Rsa.Tests.SignVerify_Span.UseAfterDispose(importKey: False) [FAIL]
      Internal.Cryptography.CryptoThrowHelper+WindowsCryptographicException : Unknown error (0xc0000001)
      Stack Trace:
        /_/src/Common/src/Internal/Cryptography/CngCommon.SignVerify.cs(50,0): at Internal.Cryptography.CngCommon.TrySignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1 hash, Span`1 signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, Int32&amp; bytesWritten)
        /_/src/Common/src/System/Security/Cryptography/RSACng.SignVerify.cs(126,0): at System.Security.Cryptography.RSAImplementation.RSACng.TrySignHash(ReadOnlySpan`1 hash, Span`1 destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32&amp; bytesWritten)
        /_/src/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RSA.cs(202,0): at System.Security.Cryptography.RSA.TrySignData(ReadOnlySpan`1 data, Span`1 destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32&amp; bytesWritten)
        /_/src/Common/tests/System/Security/Cryptography/AlgorithmImplementations/RSA/SignVerify.netcoreapp.cs(10,0): at System.Security.Cryptography.Rsa.Tests.SignVerify_Span.&lt;&gt;c__DisplayClass0_0.&lt;SignData&gt;b__0(Byte[] dest)
        /_/src/Common/tests/System/Security/Cryptography/AlgorithmImplementations/RSA/SignVerify.netcoreapp.cs(26,0): at System.Security.Cryptography.Rsa.Tests.SignVerify_Span.TryWithOutputArray(Func`2 func)
        /_/src/Common/tests/System/Security/Cryptography/AlgorithmImplementations/RSA/SignVerify.netcoreapp.cs(10,0): at System.Security.Cryptography.Rsa.Tests.SignVerify_Span.SignData(RSA rsa, Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding)
        /_/src/Common/tests/System/Security/Cryptography/AlgorithmImplementations/RSA/SignVerify.cs(89,0): at System.Security.Cryptography.Rsa.Tests.SignVerify.UseAfterDispose(Boolean importKey)
```

cc @bartonjs </Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41058</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr,corert</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr,corert


**Please REBASE this PR when merging**

 cc @marek-safar @jkotas @sywhang</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41057</IssueID>
    <RepoID>1</RepoID>
    <Title>[doubt] what is Nullable&lt;object&gt; in corefx source?</Title>
    <Description>I know that` Nullable&lt;T&gt;` has a [constraint that ensures that T must be struct](https://docs.microsoft.com/pt-br/dotnet/api/system.nullable-1?view=netframework-4.8), however looking `Enumerable.Cast` method, I found a [variable with type `Nullable&lt;object&gt;`](https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Cast.cs#L24) and I cant understand that.

can someone explain me please?</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41056</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190912.4
- **Date Produced**: 9/12/2019 1:42 PM
- **Commit**: 9dda25e8818255879640d0a8b63c5de8fb724820
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19462.4

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41055</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190911.47
- **Date Produced**: 9/12/2019 7:26 AM
- **Commit**: 7e6ca511536653f9391bf6d0a9eb669b4562089c
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19461.47
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19461.47
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19461.47

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190911.10
- **Date Produced**: 9/11/2019 11:00 PM
- **Commit**: e32d9a2664a59eccbcbe5a4044cffbdd96538b5b
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19461.10
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19461.10

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190911.2
- **Date Produced**: 9/11/2019 12:52 PM
- **Commit**: 06187696871938455550e00060121499bad3caac
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19461.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41054</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190912.2
- **Date Produced**: 9/12/2019 1:01 PM
- **Commit**: 018d3e7e9b580d64e597757ef2d6e91da16ae26e
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19462.2

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41053</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)
## From https://github.com/dotnet/arcade
- **Build**: 20190911.7
- **Date Produced**: 9/12/2019 6:45 AM
- **Commit**: 8eb29ba860a3cfcfe68f9a8256caa7efc1f1aaba
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19461.7
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19461.7
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19461.7
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19461.7

[marker]: &lt;&gt; (End:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41052</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 3 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190911.7
- **Date Produced**: 9/12/2019 6:45 AM
- **Commit**: 8eb29ba860a3cfcfe68f9a8256caa7efc1f1aaba
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19461.7
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19461.7
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19461.7
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19461.7

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)
## From https://dev.azure.com/dnceng/internal/_git/dotnet-optimization
- **Build**: 20190912.1
- **Date Produced**: 9/12/2019 11:02 AM
- **Commit**: 48fd58c24cddbc6c0b0de1c00204aae1170f4864
- **Branch**: refs/heads/master
- **Updates**:
  - **optimization.windows_nt-x64.IBC.CoreFx** -&gt; 99.99.99-master-20190912.1

[marker]: &lt;&gt; (End:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190912.4
- **Date Produced**: 9/12/2019 1:42 PM
- **Commit**: 9dda25e8818255879640d0a8b63c5de8fb724820
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19462.4

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)



</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41051</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190911.7
- **Date Produced**: 9/12/2019 6:45 AM
- **Commit**: 8eb29ba860a3cfcfe68f9a8256caa7efc1f1aaba
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19461.7
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19461.7
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19461.7
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19461.7
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19461.7
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19461.7

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41050</IssueID>
    <RepoID>1</RepoID>
    <Title>Build.sh in WSL 1 Fails with 'csc.dll exited with code 139'</Title>
    <Description>Env: WSL 1, Ubuntu 18.04, with prerequisites listed in [here](https://github.com/dotnet/corefx/blob/c4c1985531cc1f25c805bbc4801b85c98e0dfee0/Documentation/building/unix-instructions.md).
Build fails with:
```
/home/manicka/.nuget/packages/microsoft.net.compilers.toolset/3.3.0-beta2-19367-02/tasks/netcoreapp2.1/Microsoft.CSharp.Core.targets(58,5): 
  error MSB6006: "csc.dll" exited with code 139.
  [/mnt/d/UbuntuShare/corefx/src/System.Reflection.MetadataLoadContext/src/System.Reflection.MetadataLoadContext.csproj]
```

It's always System.Reflection.MetadataLoadContext library.
The build works in WSL 2. However that requires Insider Preview of Win.

@davidsh Encountered the same problem.
Might be related to [Roslyn#23846](https://github.com/dotnet/roslyn/issues/23846).

To reproduce run:
```
./build.sh
```
in WSL.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41049</IssueID>
    <RepoID>1</RepoID>
    <Title>AsyncLocal&lt;T&gt; value is changed unexpectedly to the old value when EntityFrameworkCore and SqlClient DiagnosticsListener used</Title>
    <Description>We are using Jaeger to track app performance and recently encountered in a problem tracking requests:

```
Span has already been finished; will not be reported again. Operation: sqlClient SELECT Trace Id: 3378cd4b82959a046319f2eb1904476b Span Id: 851107e900911a68
```

It occurred when we updated library opentracing-contrib/csharp-netcore from 0.5.0 to 0.6.0 where support for SqlClient DiagnosticsListener was added.

There is [an issue](https://github.com/opentracing-contrib/csharp-netcore/issues/44) in those library, but as it reproduced without it in a simple console app, it's not their fault, I guess. There is [similar issue](https://github.com/dotnet/corefx/issues/32695) in this repo also. 

DiagnosticsListener is used to inspect specific commands. In order to report span in correct order, jaeger library uses [AsyncLocalScopeManager](https://github.com/opentracing/opentracing-csharp/blob/master/src/OpenTracing/Util/AsyncLocalScopeManager.cs#L34), which uses AsyncLocal&lt;T&gt; to track active scope. When specific command goes to DiagnosticsListener, this active scope in AsyncLocal&lt;T&gt; is changed.  But apparently it can be restored to previous state. Commands reported in the following order:

```
.. "Microsoft.EntityFrameworkCore.Database.Command.CommandExecuting" -&gt; Active now EFCore
....  "System.Data.SqlClient.WriteCommandBefore" -&gt; Active now SqlClient. Remember EFCore as previously active.
....  "System.Data.SqlClient.WriteCommandAfter"-&gt; Dispose active, which is SqlClient. Restore active to EFCore.
.. "Microsoft.EntityFrameworkCore.Database.Command.CommandExecuted" -&gt; Dispose active, which should be EFCore. But it is - SqlClient! We get disposed SqlClient Scope twice. It's a problem.
```

When the last command is reported, AsyncLocal&lt;T&gt; sees that "System.Data.SqlClient.WriteCommandBefore" command is active now and gets called Dispose() second time, but "Microsoft.EntityFrameworkCore.Database.Command.CommandExecuting" is expected.

I have created simple repro. In order to see the bug:

```
git clone https://github.com/stukselbax/AsyncLocalProblem
cd AsyncLocalProblem
devenv .
```

_SQLEXPRESS is required_. Build solution, select AsyncLocalProblem as startup project, F5. Inspect red message 

```
System.Data.SqlClient.WriteCommandBefore was already disposed!!
```

Set SpanHasAlreadyFinished as startup project , F5. Inspect warning message

```
warn: Jaeger.Tracer[0]
      Span has already been finished; will not be reported again. Operation: sqlClient SELECT Trace Id: af69374e58cb1fe1 Span Id: ab16fb209a1877a4
```

You can play with AsyncLocal&lt;T&gt;, for example, in order to get change notification.

Because I don't know where problem is (SqlClient, AsyncLocal, EntityFrameworkCore, ...) I report issue here.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41048</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix icon entry selection</Title>
    <Description>We weren't checking the color depth properly when chosing an icon entry to extract from an icon file.

Fix, and add a test.

This is a regression I introduced in 3.0. It will need to work it's way into 3.0.</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41047</IssueID>
    <RepoID>1</RepoID>
    <Title>When use the when keyword in a catch expression the app crashes instead of do what the document says</Title>
    <Description>## Issue

The document [Using User-Filtered Exception Handlers](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/using-user-filtered-exception-handlers) says:

&gt; The expression of the user-filtered clause is not restricted in any way. If an exception occurs during execution of the user-filtered expression, that exception is discarded and the filter expression is considered to have evaluated to false. In this case, the common language runtime continues the search for a handler for the current exception.

When there is an exception occurred in the when expression the exception will be ignored and the expression will return false.

This works in .NET Core and also works in .NET Framework in old-style project. But the app will **crash** when building a .NET Framework app using sdk-style project.

Maybe it's a bug in the sdk-style project.

## Demo

See such a demo below:

```csharp
try
{
    try
    {
        Console.WriteLine("Try");
        throw new FileNotFoundException();
    }
    catch (FileNotFoundException ex) when (ex.FileName.EndsWith(".png"))
    {
        Console.WriteLine("Catch 1");
    }
    catch (FileNotFoundException)
    {
        Console.WriteLine("Catch 2");
    }
}
catch (Exception)
{
    Console.WriteLine("Catch 3");
}
Console.WriteLine("End");
```

This is the output of .NET Core 3.0 and everything works fine:

![image](https://user-images.githubusercontent.com/9959623/64590498-437b5c00-d3da-11e9-895b-5494c5eee268.png)

But this is the output of .NET Framework 4.8 and we can notice that the app crashes:

![image](https://user-images.githubusercontent.com/9959623/64590536-5b52e000-d3da-11e9-9df9-b61aa020a5d1.png)

---

The original issue is here:

- [When use the when keyword in a catch expression the app crashes instead of do what the document says · Issue #14338 · dotnet/docs](https://github.com/dotnet/docs/issues/14338)

The document is here:

- [Using User-Filtered Exception Handlers | Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/using-user-filtered-exception-handlers)</Description>
    <CreatedDate>12/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41046</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190911.6
- **Date Produced**: 9/11/2019 7:38 PM
- **Commit**: bf167aa90950e0c2493536433668267f2a45fc26
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19461.6
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19461.6
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19461.6

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41045</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190911.5
- **Date Produced**: 9/11/2019 6:33 PM
- **Commit**: a48684fbf7970e6b1c1ceedf008c4d0309109f56
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19461.5
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19461.5
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19461.5

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41044</IssueID>
    <RepoID>1</RepoID>
    <Title>Create standard Dictionary class that doesn't throw a KeyNotFoundException</Title>
    <Description>_From @AdamHess on Wednesday, September 11, 2019 6:40:32 PM_

### Is your feature request related to a problem? Please describe.

Dictionaries make a missing element an "KeyNotFoundException" event when in reality is quite common place and can be better managed by a null check when an item in the dictionary. 

This leads to clunky code like 

```
if (dict.TryGetValue(key, out var value))
{
  //do work here
}
```

### Describe the solution you'd like

A standard Dictionary-like class that does not throw KeyNotFoundExeption when key is missing, just returns null. 

### Additional context

This increases the level of complexity for newcomers to the language or coming from another language where the expected behavior when a dictionary is missing a key to return null. 

Additionally, in MANY cases it completely eliminates the  `[ ]` operator being used at all. 

Often developers have to create a custom implementation for accessing dictionaries such can be found here: 

https://stackoverflow.com/questions/14150508/how-to-get-null-instead-of-the-keynotfoundexception-accessing-dictionary-value-b

leading to managing a utility project and duplicate code in the .net ecosystem


_Copied from original issue: aspnet/AspNetCore#13905_</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41042</IssueID>
    <RepoID>1</RepoID>
    <Title>Add example of strong API proposal</Title>
    <Description>Found an example of a very thorough API proposal that we should link in the documentation.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41041</IssueID>
    <RepoID>1</RepoID>
    <Title>JSON DOM refactor</Title>
    <Description>I addressed most review comments from https://github.com/dotnet/corefx/pull/40673. I am left with changing throwing exceptions to using throwing exception helpers.

addresses: #39922
cc: @bartonjs @ahsonkhan @ericstj @joperezr @terrajobst @JamesNK @stephentoub </Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41064</IssueID>
    <RepoID>1</RepoID>
    <Title>Create standard Dictionary class that doesn't throw a KeyNotFoundException</Title>
    <Description>### Feature Request

Dictionaries make a missing element an "KeyNotFoundException" event when in reality is quite common place and can be better managed by a null check when an item in the dictionary. 

This leads to clunky code like 

```
if (dict.TryGetValue(key, out var value))
{
  //do work here
}
```

### Solution 

A standard Dictionary-like class that does not throw KeyNotFoundExeption when key is missing, just returns null when using the `[]` operator. 

### Additional context

This increases the level of complexity for newcomers to the language or coming from another language where the expected behavior when a dictionary is missing a key to return null. 

Additionally, in MANY cases it completely eliminates the  `[ ]` operator being used at all. 

Often developers have to create a custom implementation for accessing dictionaries such can be found here: 

https://stackoverflow.com/questions/14150508/how-to-get-null-instead-of-the-keynotfoundexception-accessing-dictionary-value-b

leading to managing a utility project and duplicate code in the .net ecosystem
</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41040</IssueID>
    <RepoID>1</RepoID>
    <Title>Setting version suffix as non empty for building release package versions</Title>
    <Description>Currently we are getting this error while building packages in release mode
```
##[error].packages\microsoft.dotnet.build.tasks.packaging\1.0.0-beta.19456.3\build\Packaging.targets(828,5): error : (NETCORE_ENGINEERING_TELEMETRY=Build) No VersionSuffix was set. Ensure it is set before targets in packaging are ran.
```

Corefx does not depend on version suffix property to check if any of the dependencies are stable or not. We use packageIndex.Json file for that check.
We always require version suffix to be not null.
</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41039</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider merging System.Net.Primitives and System.Net.Sockets</Title>
    <Description>I think Primitives and Sockets are good candidates to merge back into a single assembly.

This would allow us to make some optimizations that are currently impossible because we lack access to internals between the assemblies. One such example is anything on `Socket` that takes an `IPEndPoint` argument.

Related:
* #40933 
* #39317 
* #40156 </Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41038</IssueID>
    <RepoID>1</RepoID>
    <Title>Update to test on Alpine 3.10 for 2.x</Title>
    <Description>Now that Alpine 3.10 has been released, testing should be updated to include that version. Also, be sure to check that the CI build is using 3.10 as well.  This is specific to 2.x servicing.

Related to https://github.com/dotnet/corefx/issues/38027</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41037</IssueID>
    <RepoID>1</RepoID>
    <Title>Update to test on Alpine 3.10</Title>
    <Description>Now that Alpine 3.10 has been released, testing should be updated to include that version. Also, be sure to check that the CI build is using 3.10 as well.

Related to https://github.com/dotnet/corefx/issues/37646</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41036</IssueID>
    <RepoID>1</RepoID>
    <Title>Annotate System.Collections.NonGeneric for nullable</Title>
    <Description>Contributes to #40623
cc: @dotnet/nullablefc</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41035</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190911.3
- **Date Produced**: 9/11/2019 3:24 PM
- **Commit**: 8287d6bfa9210da2f5ea8a69d6b8ebb318fb8b4f
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19461.3
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19461.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19461.3

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41034</IssueID>
    <RepoID>1</RepoID>
    <Title>Support non-generic IDictionary derived types for JSON serialization</Title>
    <Description>e.g. HashTable and SortedList. These throw not supported exception now.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>19/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41033</IssueID>
    <RepoID>1</RepoID>
    <Title>Buffer not send using the Ping class</Title>
    <Description>Using the Ping class Send method is the buffer not included in the call. This is found to be when it uses the built in ping command. 

The -p option is not populated in the method https://github.com/dotnet/corefx/blob/ecad65740b41b1502188ac6b412ade53fb54ba3e/src/Common/src/System/Net/NetworkInformation/UnixCommandLinePing.cs#L73

That function is called from this method:

https://github.com/dotnet/corefx/blob/d3911035f2ba3eb5c44310342cc1d654e42aa316/src/System.Net.Ping/src/System/Net/NetworkInformation/Ping.Unix.cs#L256

Which again is called from this method:

https://github.com/dotnet/corefx/blob/d3911035f2ba3eb5c44310342cc1d654e42aa316/src/System.Net.Ping/src/System/Net/NetworkInformation/Ping.Unix.cs#L279





</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41032</IssueID>
    <RepoID>1</RepoID>
    <Title>Port to 3.1 - Use ThrowHelper in Utf8JsonReader.GetGuid so that the deserializer can catch the exception and re-throw JsonException</Title>
    <Description>The PR is checked in to https://github.com/dotnet/corefx/pull/40938. As per offline discussion, the plan was to port this to 3.1.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41031</IssueID>
    <RepoID>1</RepoID>
    <Title>TimeSpan property not bound</Title>
    <Description>_From @thanuja89 on Tuesday, September 10, 2019 6:09:05 AM_


We recently tried migrating to .NET Core preview 9.

We had a TimeSpan property in the model that we used in an Web Api Controller POST method. When we ran our integration tests, we noticed that the model would not be bound, but if we commented out the property, it works. 

### Expected behavior
The model to be bound successfully

### Additional context
We use Microsoft.AspNet.WebApi.Client 5.2.7 on integration tests project and for POST requests, we use the PostAsJsonAsync extension method.

output of `dotnet --info`

.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview9-014004
 Commit:    8e7ef240a5

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17763
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100-preview9-014004\

Host (useful for support):
  Version: 3.0.0-preview9-19423-09
  Commit:  2be172345a

.NET Core SDKs installed:
  2.1.701 [C:\Program Files\dotnet\sdk]
  2.1.801 [C:\Program Files\dotnet\sdk]
  2.2.301 [C:\Program Files\dotnet\sdk]
  2.2.401 [C:\Program Files\dotnet\sdk]
  3.0.100-preview9-014004 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview9.19424.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download


_Copied from original issue: aspnet/AspNetCore#13844_</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41030</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonNode options</Title>
    <Description>I changed `JsonNode.Parse` to use `JsonNodeOptions` instead of `JsonDocumentOptions`.
cc: @ahsonkhan @terrajobst </Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41029</IssueID>
    <RepoID>1</RepoID>
    <Title>Build.cmd/Build.sh Help OS List</Title>
    <Description>Build.cmd/Build.sh help lists only 2 possible options for OS: ` Windows_NT` and `Unix`. [This page](https://github.com/dotnet/corefx/blob/de38804d52f6b65f0f290b81383f01e6943a6d8f/Documentation/project-docs/developer-guide.md) lists: `Windows_NT`, `Unix`, `Linux`, or `OSX`. And in [Directory.Build.props](https://github.com/dotnet/corefx/blob/master/Directory.Build.props) can also be found `NetBSD` and `FreeBSD`.

What is the actual list of supported OSes? Could the help be of build scripts be updated to reflect that?</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41028</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190911.2
- **Date Produced**: 9/11/2019 10:00 AM
- **Commit**: d5db56c8f21f7a7a2083197925f44b8992005d32
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19461.2
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19461.2
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19461.2

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190910.21
- **Date Produced**: 9/11/2019 4:14 AM
- **Commit**: ee9995f31b684a0c6e5488eceb2500bf0057da89
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19460.21
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19460.21

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41027</IssueID>
    <RepoID>1</RepoID>
    <Title>Build of Tests for OS Linux on Win Fails</Title>
    <Description>Build of the tests for Linux OS fails with:
```
D:\Repositories\corefx\src\Microsoft.XmlSerializer.Generator\tests\Microsoft.XmlSerializer.Generator.Tests.csproj(44,5): error MSB3073: 
  The command 
    "set DOTNET_MULTILEVEL_LOOKUP=0 &amp; 
    "D:\Repositories\corefx\artifacts\bin\testhost\netcoreapp-Linux-Debug-x64\dotnet.exe" 
    --fx-version 5.0.0 
    D:\Repositories\corefx\artifacts\bin\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Debug\dotnet-Microsoft.XmlSerializer.Generator.dll 
    D:\Repositories\corefx\artifacts\bin\Microsoft.XmlSerializer.Generator.Tests\netcoreapp-Debug\Microsoft.XmlSerializer.Generator.Tests.dll 
    --force 
    --quiet"
  exited with code 9009.
```

To reproduce run:
```
build.cmd -buildtests -os Linux
```
from Windows command line.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41026</IssueID>
    <RepoID>1</RepoID>
    <Title>Build for OS Unix on Win Fails</Title>
    <Description>Build of the repo for Unix OS fails with:
```
ODBC32' does not exist in the namespace 'System.Data.Odbc' 
(are you missing an assembly reference?) 
[D:\Repositories\corefx\src\shims\manual\System.Data.csproj]
```

To reproduce run:
```
build.cmd -os Unix
```
from Windows command line.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41025</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190911.3
- **Date Produced**: 9/11/2019 12:52 PM
- **Commit**: 7ef139311a96053c06da1ad91feb1badc8ba74e3
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19461.3

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41024</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)
## From https://github.com/dotnet/arcade
- **Build**: 20190910.3
- **Date Produced**: 9/10/2019 6:11 PM
- **Commit**: 0f5cfb20a355c27bc84cedd049c946b44a7fc1da
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19460.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19460.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19460.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19460.3

[marker]: &lt;&gt; (End:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41023</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190911.7
- **Date Produced**: 9/12/2019 12:41 AM
- **Commit**: 17a53cb063b5e63fc1cc832ec36cf8a520111124
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19461.7
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19461.7
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19461.7

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)



</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41022</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 3 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:79f1e123-800e-410f-94d7-08d690bc143a)
## From https://github.com/dotnet/core-setup
- **Build**: 20190910.02
- **Date Produced**: 9/10/2019 12:10 PM
- **Commit**: 4421cfb105df112492038e5c5a70c24bce48e72f
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 3.0.0-rc2-19460-02
  - **Microsoft.NETCore.DotNetHost** -&gt; 3.0.0-rc2-19460-02
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 3.0.0-rc2-19460-02

[marker]: &lt;&gt; (End:79f1e123-800e-410f-94d7-08d690bc143a)

[marker]: &lt;&gt; (Begin:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)
## From https://dev.azure.com/dnceng/internal/_git/dotnet-optimization
- **Build**: 20190911.1
- **Date Produced**: 9/11/2019 11:03 AM
- **Commit**: 48fd58c24cddbc6c0b0de1c00204aae1170f4864
- **Branch**: refs/heads/master
- **Updates**:
  - **optimization.windows_nt-x64.IBC.CoreFx** -&gt; 99.99.99-master-20190911.1

[marker]: &lt;&gt; (End:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190911.3
- **Date Produced**: 9/11/2019 12:52 PM
- **Commit**: 7ef139311a96053c06da1ad91feb1badc8ba74e3
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19461.3

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41021</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190910.3
- **Date Produced**: 9/10/2019 6:11 PM
- **Commit**: 0f5cfb20a355c27bc84cedd049c946b44a7fc1da
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19460.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19460.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19460.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19460.3

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41019</IssueID>
    <RepoID>1</RepoID>
    <Title>CVE-2017-0249 Elevation of Privilege issue</Title>
    <Description>we have developed our application on asp.net core 1.1 version with VS2015.

We are facing Elevation of Privilege issue for System.Net.Security 4.3.0 in my application while deploying build using Jenkins. So I have created a direct dependency for System.Net.Security by changing its version to 4.3.1 from 4.3.0 in project.json file as below,

  "netcoreapp1.1": {
      "dependencies": {
        "Microsoft.NETCore.App": {
          "type": "platform",
          "version": "1.1.0"
        },
        "System.Net.Security": "4.3.1"
      }
    }

But I am still facing Elevation of Privilege issue with new warning messages for runtime/win/unix 
paths of System.Net.Security.

What I see is in  project.lock.json is that version 4.3.1 is not getting reflected after adding direct dependency in project.json as seen below,

"System.Net.Security/4.3.1": {
        "type": "package",
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0",
          "Microsoft.Win32.Primitives": "4.3.0",
          "System.Collections": "4.3.0",
          "System.Collections.Concurrent": "4.3.0",
          "System.Diagnostics.Tracing": "4.3.0",
          "System.Globalization": "4.3.0",
          "System.Globalization.Extensions": "4.3.0",
          "System.IO": "4.3.0",
          "System.Net.Primitives": "4.3.0",
          "System.Resources.ResourceManager": "4.3.0",
          "System.Runtime": "4.3.0",
          "System.Runtime.Extensions": "4.3.0",
          "System.Runtime.Handles": "4.3.0",
          "System.Runtime.InteropServices": "4.3.0",
          "System.Security.Claims": "4.3.0",
          "System.Security.Cryptography.Algorithms": "4.3.0",
          "System.Security.Cryptography.Encoding": "4.3.0",
          "System.Security.Cryptography.OpenSsl": "4.3.0",
          "System.Security.Cryptography.Primitives": "4.3.0",
          "System.Security.Cryptography.X509Certificates": "4.3.0",
          "System.Security.Principal": "4.3.0",
          "System.Text.Encoding": "4.3.0",
          "System.Threading": "4.3.0",
          "System.Threading.Tasks": "4.3.0",
          "System.Threading.ThreadPool": "4.3.0",
          "runtime.native.System": "4.3.0",
          "runtime.native.System.Net.Security": "4.3.0",
          "runtime.native.System.Security.Cryptography.OpenSsl": "4.3.0"
        },
        "compile": {
          "ref/netstandard1.3/System.Net.Security.dll": {}
        },
        "runtimeTargets": {
          "runtimes/unix/lib/netstandard1.6/System.Net.Security.dll": {
            "assetType": "runtime",
            "rid": "unix"
          },
          "runtimes/win/lib/netstandard1.3/System.Net.Security.dll": {
            "assetType": "runtime",
            "rid": "win"
          }
        }
      }

Please let me know if I need to make any additional changes apart of adding direct dependency.

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41018</IssueID>
    <RepoID>1</RepoID>
    <Title>add links to the new Profiling docs</Title>
    <Description>
    </Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41017</IssueID>
    <RepoID>1</RepoID>
    <Title>add IsPrefix test cases for Platforms differences</Title>
    <Description>while working on the StartsWith performance improvements for Linux I've found these two differences that I believe are worth tracking
</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41016</IssueID>
    <RepoID>1</RepoID>
    <Title>add few StartsWith edge case test cases</Title>
    <Description>This is a follow up of https://github.com/dotnet/coreclr/pull/26621#issuecomment-530014987</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41015</IssueID>
    <RepoID>1</RepoID>
    <Title>ZipArchiveEntry.Name is wrong when FullName contains colon</Title>
    <Description>I've created a ZipArchive using .Net Core, I'm facing issue when I try to unzip the file. The problem is caused by ZipArchiveEntry which has colon in its name. I agree that Windows file names can't contain colon, but its perfectly legal in other systems. When I iterate through the entries in the ZipArchive, the ZipArchiveEntry displays a wrong file name. Please refer attached screenshot, you can see that the FullName and Name show different file altogether.

![ZipArchiveEntryError](https://user-images.githubusercontent.com/11273401/64674740-1b016980-d48f-11e9-98ed-51741bd2279a.png)

Please suggest a solution/fix for this.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41014</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190910.11
- **Date Produced**: 9/11/2019 2:27 AM
- **Commit**: ed98374f402d405fc08c52da8bd7e43e9b39a738
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19460.11
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19460.11
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19460.11

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41013</IssueID>
    <RepoID>1</RepoID>
    <Title>close _eventStream when stopping watcher</Title>
    <Description>When even stream is created it needs to be properly cleaned up in order to close associated file handles and associated resources. 
https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html

We need to call  FSEventStreamInvalidate and FSEventStreamRelease. Conveniently, it seems like this is all encapsulated in SafeEventStreamHandle's ReleaseHandle. 

I run repro code from #40888 in loop and I did not see any descriptor leak. (The leak was pretty obvious without the fix) 
I may spent more time tomorrow thinking if there is some good way how to add test but it may be tricky to verify OS resources. 

fixes #40888 
</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41012</IssueID>
    <RepoID>1</RepoID>
    <Title>Given examples and made points explicit</Title>
    <Description>Made certain points explicit by giving examples or specifying acronyms in brackets where the words they stand for, appear for first time.</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41011</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190910.8
- **Date Produced**: 9/10/2019 11:04 PM
- **Commit**: 771d6e8742c993a02782261516d2391c60fcf58b
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19460.8
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19460.8
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19460.8

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41010</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2. I'm a robot and am configured to help you automatically keep release/2.2 up to date, so I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @stephentoub

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/2.1
git pull --ff-only
git checkout release/2.2
git pull --ff-only
git merge --no-ff release/2.1

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/2.1-to-release/2.2'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41009</IssueID>
    <RepoID>1</RepoID>
    <Title>File.Move does not always delete source when overwrite is set to true</Title>
    <Description>### Affected versions

- since 3.0.0-preview (based on PR merges) on linux

### Issue Description

An overwrite parameter was introduced to File.Move. 
If File.Move is called with overwrite=true, and the target file does not exist, and the file is being moved across filesystem boundaries. Then, erroneously, the source file is not deleted.

This is caused by a missing DeleteFile call following [this CopyFile call](https://github.com/dotnet/corefx/blob/0c4c234a918254d569ffb0f6a607f98193608646/src/System.IO.FileSystem/src/System/IO/FileSystem.Unix.cs#L173).

There is the possibility that other cross-filesystem scenarios are also failing. If there is an integration test environment capable of testing them; then additional tests should be added there.
I'm not directly affected by this problem, I noticed it while inspecting https://github.com/dotnet/corefx/pull/40611.

### Reproduction steps

Tested with the dotnet/core/runtime:3.0 docker image using a simple mounted volume to simulate a additional filesystem.
For example:
`/app/TestRepro.dll` (compiled test app)
`/app/test.txt` (testfile)
`/app/temp` (mounted volume)

TestRepro.dll simply executes `File.Move("test.txt", "temp/test.txt", true)`. Upon completion both `/app/test.txt` and `/app/temp/test.txt` exist.

Introduced in #33054</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41008</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix SqlParameter with xml schema construction</Title>
    <Description>Fixes issue #41141 which is a bug in the corefx version not ported to Microsoft.Data.SqlClient yet and adds tests to verify the corrected and default behaviour of xml properties on `SqParameter`. The tests will run under CI.

This bug prevents the use of `TableAdapter`s with autogenerated update commands 

/cc reporter HSchwichtenberg, owners @david-engel, @Gary-Zh,  @cheenamalhotra and tracking @ErikEJ</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41007</IssueID>
    <RepoID>1</RepoID>
    <Title>Find zip file end of central directory backwards up to max possible size</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/34892 and https://github.com/dotnet/corefx/issues/37394

### Issue

Huge files without an end of central directory take a long time to throw because we seek to the end then search backwards for the EOCD signature all the way to the end.

### Fix

I addressed the problem by ensuring we only search for the signature within the maximum possible number of bytes where it can be found.

I applied the same principle to the Zip64 End of Central Directory Locator search, which happened to do be doing a similar search.

I also moved the code that tries to find the Zip64 EOCD to its own function, to make the code look cleaner.

### Pending

- The file for the unit test I currently tested is huge, so I have to upload it to corefx-testdata first, but when I ran it locally, the 549 MB file provided in #34892 took ~100 milliseconds to throw after not finding the EOCD signature.
- Add at least two more zip files, or make sure we already have UTs that test:
    - A huge, malformed zip file with bytes truncated at the end.
    - An empty zip file.


CC @riverar @kburgoyne</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>30/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41006</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190910.4
- **Date Produced**: 9/10/2019 7:41 PM
- **Commit**: c0919bc7c73332a59acdc1fd934327a4af5da004
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19460.4
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19460.4
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19460.4

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41005</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: BitArray.CopyTo(int value) / BitArray.From(int value)</Title>
    <Description>At the moment there is no way to create a System.Collections.BitArray from a single integer and no way to return the bits to a single integer. I don't know the exactly reason why the API is missing but considering its possible to achieve with a 1 length integer array it wouldn't be too difficult to add such an API.

```
namespace System.Collections
{
    public sealed class  BitArray : ICollection, IEnumerable, ICloneable
    {
        //Fyi: I would have considered BitArray(int value) instead but it's conflicting with BitArray(int length)
        public static From(int value);
        public void CopyTo(int value);
   }
}
```

Example::
```
static void ChangeBit(ref int value,  int position, bool newBit)
{
    var bits = BitArray.From(value);
    bits[position] = newBit;
    bits.CopyTo(value);
}
static int ReplaceBitRange(int existingInteger, int newInteger, int position, int length)
{
    var oldBits = BitArray.From(existingInteger);
    var newBits = BitArray.From(newInteger);
    var counter = 0;
    for (int i = position; i &lt; position + length; i++)
    {
        oldBits[i] = newBits[counter++];
    }
    int result;
    oldBits.CopyTo(result);
    return result;
}
```
Without these APIs we would have to create arrays when initializing the bit array and when returning, which adds more performance cost in scenarios where it matters. While changing bits directly from and to an integer is better.

If getting approved perhaps this can be considered to be not only for integer but also for byte.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41004</IssueID>
    <RepoID>1</RepoID>
    <Title>Update CoreFx to servicing-28008-01 (release/uwp6.2)</Title>
    <Description>/cc @dotnet/maestro-reviewers-core</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41003</IssueID>
    <RepoID>1</RepoID>
    <Title>Update CoreClr, CoreFx, CoreSetup to servicing-28008-01, servicing-28008-01, stable, respectively (release/2.1)</Title>
    <Description>/cc @dotnet/maestro-reviewers-core</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41002</IssueID>
    <RepoID>1</RepoID>
    <Title>Proposal: Add mechanism to handle circular references when serializing</Title>
    <Description># Rationale and Usage

Currently there is no mechanism to prevent infinite looping when an object that contains a circular reference is serialized using `JsonSerializer.Serialize`. 
You can find more information about how this works in Json.Net reading this [gist](https://gist.github.com/Jozkee/e96cfde875b4773086fadf3aa1017a10).

Issues related:
* https://github.com/dotnet/corefx/issues/38579
* https://github.com/dotnet/corefx/issues/37786
* https://github.com/dotnet/corefx/issues/40045

Take this for example:

Given the following class:
```cs
class Employee { 
    string Name { get; set; }
    Employee Manager { get; set; }
    List&lt;Employee&gt; Subordinates { get; set; }
}
```
And having the following code:
```cs
var Angela = new Employee();
var Bob = new Employee();

Angela.Subordinates  new List&lt;Employee&gt; { Bob };
Bob.Manager = Angela;

string json = JsonSerializer.Serialize(Angela);
```

You will find that the above code throws by not being able to keep up when MaxDepth is reached:
https://github.com/dotnet/corefx/blob/50e8db3cabbfb6ad0fc0702b3db25491a95c72a5/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Write.cs#L61-L64

This is the only thing we have before hitting an stack overflow. 

# Proposed API
```cs
namespace System.Text.Json
{
  public enum ReferenceHandling
  {
      Error = 0,
      Ignore = 1,
      Preserve = 2,
  }

  public sealed partial class JsonSerializerOptions
  {
      ReferenceHandling ReferenceHandling { get { throw null; } set { } }
  }
}

namespace System.Text.Json.Serialization
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, AllowMultiple = false)]
  public sealed class JsonReferenceHandlingAttribute : JsonAttribute
  {
      public JsonReferenceHandlingAttribute(ReferenceHandling handling)
      {
          Handling = handling;
      }
      public ReferenceHandling Handling { get; }
  }
}
```

# Examples
Using the previous `Employee` class and serializing Angela with `ReferenceHandling.Ignore` option:
```cs
var Angela = new Employee { Name = "Angela" };
var Bob = new Employee { Name = "Bob" };

Angela.Subordinates  new List&lt;Employee&gt; { Bob };
Bob.Manager = Angela;

var options = new JsonSerializerOptions { 
    ReferenceHandling = ReferenceHandling.Ignore 
};

string json = JsonSerializer.Serialize(Angela, options);
Console.WriteLine(json);
```
Here's the output:
```js
{
  "Name": "Angela",
  "Subordinates": [
    {
      "Name": "Bob"
    }
  ]
}
```

You can also deal with the loop using `ReferenceHandling.Preserve` option:
```cs
var Angela = new Employee { Name = "Angela" };
var Bob = new Employee { Name = "Bob" };

Angela.Subordinates  new List&lt;Employee&gt; { Bob };
Bob.Manager = Angela;

var options = new JsonSerializerOptions { 
    ReferenceHandling = ReferenceHandling.Preserve 
};

string json = JsonSerializer.Serialize(Angela, options);
Console.WriteLine(json);
```

And here's the output:
```js
{
  "$id": "1"
  "Name": "Angela",
  "Subordinates": {
    "$id": "2",
    "$values": [
      {
        "$id": "3"
        "Name": "Bob",
        "Manager": {
            "$ref": "1"
        }
      }
    ]
  }
}
```
Note how it also replaces arrays for objects in order to add `$id` property.

Another option would be to add `ReferenceHandling.Preserve` attribute on top of the property:
```cs
private class Employee
{
    public string Name { get; set; }

    [JsonReferenceHandling(ReferenceHandling.Preserve)]
    public Employee Manager { get; set; }

    public List&lt;Employee&gt; Subordinates { get; set; }
}

var Angela = new Employee { Name = "Angela" };
var Bob = new Employee { Name = "Bob" };

Angela.Subordinates  new List&lt;Employee&gt; { Bob };
Bob.Manager = Angela;

var options = new JsonSerializerOptions { 
    //Even though you are setting Ignore option, Manager will use Preserve
    ReferenceHandling = ReferenceHandling.Ignore 
};

string json = JsonSerializer.Serialize(Angela, options);
Console.WriteLine(json);
```
Output:
```js
{
  "Name": "Angela",
  "Subordinates": [
    {
      "Name": "Bob",
      "Manager": {
        "$id": "1",
        "Name": "Angela",
        "Subordinates": [
          {
            "Name": "Bob",
            "Manager": {
              "$ref": "1"
            }
          }
        ]
      }
    }
  ]
}
```
Notice it goes this deep because we are just preserving `Manager` property.

# Details
* Default option is Error.
* This API is currently available on Json.Net therefore most of the behavior will be similar to it.
* `ReferenceLoopHandling` and `PreserveReferenceHandling` options are being merged into the proposed enum `ReferenceHandling`.
* `ReferenceLoopHandling.Serialize` option will not be ported/included.
* `PreserveReferenceHandling.Object` and `Array` options will not be ported/included, just `All`.
* We will keep the same schema of metadata properties appended to the complex types in order to offer campatibility with Json.Net. 
* In order to be able to deserialize back a Json string serialized using `ReferenceHandling.Preserve` option, we will need to extend `JsonSerializer.Deserialize` so it can read the metadata tags (`$id` and `$ref`).
* I am adding the perserve mechanism within a property or class attribute as well as an option in `JsonSerializerOptions`, thing that is not on Json.Net.
* You can find more information about how this works in Json.Net reading the following gist: https://gist.github.com/Jozkee/e96cfde875b4773086fadf3aa1017a10

# Open Questions
* Do these APIs should exist in the namespaces that I suggested?
* The merge of both Json.Net options means losing the [granularity](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_PreserveReferencesHandling.htm) of `PreserveReferenceHandling`, this is just my opinion but I don't see why someone would opt-in for apply this to only object OR only arrays, so I think it is a cheap trade-off of merging both options.
* The merge also forces that we include `PreserveReferenceHandling` in the attribute level, thing that does not exist in Json.Net.
* Since a property with `JsonConverter` is forced to have a `ClassType` of `Value` or `Unknown`, you cannot combine it with `JsonReferenceHandling` which is only meant for complex types `Object` and `Array`. I think we can adjust code so it can correctly handle converted values but consider this for the trade-off.
* We were discussing to keep current validation so users can opt-in for not use this option if they want to keep performance. Is it ok to remove [current validation](https://github.com/dotnet/corefx/blob/50e8db3cabbfb6ad0fc0702b3db25491a95c72a5/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Write.cs#L61-L64) if the implementation involves some dictionary/set that provides O(1) runtime and does not impact performance?
* Also consider these scenarios:
  * This person is asking for a feature that disables `PreserveRefHandling` feature in the reader, should we include that?: https://stackoverflow.com/questions/22299390/can-not-deserialize-json-containing-ref-keys</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41001</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190910.5
- **Date Produced**: 9/10/2019 9:43 PM
- **Commit**: d46dbc2c643e57b0d6a49b6c7bd3739fcd0c7e8c
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19460.5

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41000</IssueID>
    <RepoID>1</RepoID>
    <Title>Syncing the folders</Title>
    <Description>This must have resulted in not properly handling the merge conflicts.

I verified this is not missing in release/3.0 branch</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40999</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190910.10
- **Date Produced**: 9/11/2019 1:59 AM
- **Commit**: f8dec385662c409194572934b40f01242da75dd4
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19460.10
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19460.10
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19460.10

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)





</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40998</IssueID>
    <RepoID>1</RepoID>
    <Title>Improve deserialization perf with changes to property name lookup</Title>
    <Description>Significant end-to-end deserialization perf gains:
- ~11-17% on normal simple objects (no collections or child objects).
- ~40% on missing properties (when a JSON property is not found on the POCO)
- ~40% on case-insensitive properties (when a JSON property only matches because case-insensitive is enabled) 

**Basic changes (for about 1/3 of the gains)**
- In `TryIsPropertyRefEqual()`, add `[AggressiveInlining]`.
- In `GetKey()`, minimize `if` comparisons.
- In `GetKey()`, optimize for property names &gt;= 8 bytes.
- Also not impacting perf in this specific case: expanded the key from 6 to 7 bytes; avoids calling `SequenceEqual` when property name is 7 bytes and otherwise reduces collisions for other scenarios.

**Basic changes (for about 2/3 of the gains)**
- Apply `[AggressiveInlining]` to `GetProperty()`, `HandlePropertyName()` and `HandleValue()`.

**Benchmarks**

Running the ReadJson&lt;&gt; benchmarks showed results in the 11-17% range where % = (original-current) / original. One anomaly is the first one with a much higher% -- that was due to high Error.

| Faster                                                                           | base/diff | Base Median (ns) | Diff Median (ns) | Modality|
| -------------------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| -------- |
| System.Text.Json.Serialization.Tests.ReadJson&lt;LoginViewModel&gt;.DeserializeFromStr |      1.56 |           852.92 |           548.18 | bimodal |
| System.Text.Json.Serialization.Tests.ReadJson&lt;Location&gt;.DeserializeFromUtf8Bytes |      1.21 |          1624.47 |          1341.85 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;LoginViewModel&gt;.DeserializeFromUtf |      1.21 |           593.28 |           491.52 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;MyEventsListerViewModel&gt;.Deseriali |      1.18 |        462955.27 |        393372.96 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;Location&gt;.DeserializeFromString    |      1.17 |          1722.79 |          1466.58 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;MyEventsListerViewModel&gt;.Deseriali |      1.14 |        470687.99 |        412734.27 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;IndexViewModel&gt;.DeserializeFromStr |      1.14 |         42914.59 |         37686.85 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;IndexViewModel&gt;.DeserializeFromUtf |      1.13 |         41069.02 |         36241.96 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;Location&gt;.DeserializeFromStream    |      1.13 |          1915.02 |          1694.84 |         |
| System.Text.Json.Serialization.Tests.ReadJson&lt;IndexViewModel&gt;.DeserializeFromStr |      1.13 |         43991.16 |         38970.73 |         |

**Perf impact for missing JSON properties**
Previously we didn't cache misses.

The test [POCO ](https://github.com/dotnet/performance/blob/3d4bb67fcff40596f3deb1eea6095b12aa4fe90f/src/benchmarks/micro/Serializers/DataGenerator.cs#L216-L227) used for missing properties and case-insensitive is a simple, flat object with 9 primitive properties (`string` and `int`). Having more properties increases the % gain while fewer properties decreases it (due to general overhead).

BEFORE (missing properties)

|         Method |       Mean |      Error |    StdDev |    Median |        Min |        Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |-----------:|-----------:|----------:|----------:|-----------:|-----------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 2,391.7 ns | 31.698 ns | 29.650 ns | 2,374.2 ns | 2,368.3 ns | 2,456.8 ns |      0.5126 |           - |           - |              3240 B |
| SystemTextJson | 1,575.4 ns |  8.670 ns |  7.686 ns | 1,574.4 ns | 1,563.7 ns | 1,589.4 ns |      0.0878 |           - |           - |               552 B |

AFTER (missing properties)

|         Method |       Mean |     Error |    StdDev |     Median |        Min |        Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |-----------:|----------:|----------:|-----------:|-----------:|-----------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 2,241.0 ns | 12.956 ns | 11.485 ns | 2,242.9 ns | 2,216.2 ns | 2,256.6 ns |      0.5096 |           - |           - |              3240 B |
| SystemTextJson |   946.3 ns |  8.291 ns |  7.755 ns |   942.8 ns |   936.5 ns |   960.2 ns |      0.0337 |           - |           - |               224 B |```

**Case-insensitive properties**
There was an issue here regarding the cache not adding the correct case-insensitive key.

BEFORE (with two sets of incoming JSON of different casing to trigger extra cache entries)

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 3.192 us | 0.0149 us | 0.0132 us | 3.190 us | 3.172 us | 3.223 us |      0.5331 |           - |           - |             3.32 KB |
| SystemTextJson | 4.441 us | 0.0131 us | 0.0116 us | 4.439 us | 4.421 us | 4.460 us |      0.2314 |           - |           - |             1.47 KB |

AFTER (with two sets of incoming JSON of different casing to trigger extra cache entries)

|         Method |     Mean |     Error |    StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |---------:|----------:|----------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 3.224 us | 0.0359 us | 0.0336 us | 3.229 us | 3.159 us | 3.271 us |      0.5387 |           - |           - |             3.32 KB |
| SystemTextJson | 2.787 us | 0.0244 us | 0.0228 us | 2.782 us | 2.755 us | 2.828 us |      0.2101 |           - |           - |              1.3 KB

BEFORE (with only case insensitive JSON)

|         Method |      Mean |     Error |    StdDev |    Median |       Min |       Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |----------:|----------:|----------:|----------:|----------:|----------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 18.315 us | 4.1845 us | 4.8189 us | 17.100 us | 13.100 us | 30.800 us |           - |           - |           - |             3.32 KB |
| SystemTextJson |  5.318 us | 0.5276 us | 0.6076 us |  5.085 us |  4.631 us |  6.696 us |      0.2314 |           - |           - |             1.47 KB |

AFTER (with only case insensitive JSON)

|         Method |      Mean |     Error |    StdDev |    Median |       Min |       Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|--------------- |----------:|----------:|----------:|----------:|----------:|----------:|------------:|------------:|------------:|--------------------:|
|       JSON.NET | 14.205 us | 0.8944 us | 0.9941 us | 14.000 us | 12.900 us | 16.500 us |           - |           - |           - |             3.32 KB |
| SystemTextJson |  2.880 us | 0.0364 us | 0.0323 us |  2.871 us |  2.844 us |  2.961 us |      0.2019 |           - |           - |              1.3 KB |</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40997</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Avoid MemoryMarshal.Cast when transcoding from UTF-16 to UTF-8 while escaping in Utf8JsonWriter.</Title>
    <Description>Port of https://github.com/dotnet/corefx/pull/40996 to fix https://github.com/dotnet/corefx/issues/40979

## Description

Instead of using `MemoryMarshal` to re-interpret cast a span of UTF-16 chars to bytes (to pass them to APIs expecting UTF-8 data), call the JavascriptEncoder API that expects UTF-16 chars instead. Casting char to byte doesn't transode it from UTF-16 to UTF-8 which was the previous intention. Doing so results in certain invariants in the code to break since the resulting index that points to the first character to escape would be incorrect (or even out of the bounds of the original span), which results in a negative value being passed in to stackalloc (and hence a stackoverflow). The issue is in the code-path where a custom encoder is passed in (and wouldn't happen by default).

## Customer Impact

The bug was customer-reported where the user observed a stackoverflow in an ASP.NET WebAPI (which uses a custom encoder) when trying to serialize a string that contained non-ascii characters (for example chinese caracters). Generally, any use of the `JsonSerializer` or `Utf8JsonWriter` where a custom encoder is involved for writing .NET strings as JSON is affected. It is imperative that the escaping behavior of the serializer is functionally correct.

## Regression?

Introduced in .NET Core 3.0 - preview 8

## Risk

The risk of this change is around the escaping behavior changing when the user passes in a custom escaper. Be default, the JSON stack uses the default escaper which isn't affected by this change. However, the ASP.NET defaults to a custom escaper so end-users are more likely to be affected by this escaping behavior and fix. There is no easy workaround for the user since passing in a custom/default encoder wouldn't always work either.

## Tests run / added

* Regression test for the serializer was added along with targeted tests of the writer itself (which the serializer uses under the covers).
* Verified end-to-end in an ASP.NET Web API app that writing non-ascii strings with the custom escaper works as expected.

cc @steveharter, @GrabYourPitchforks, @pranavkm, @ericstj  </Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40996</IssueID>
    <RepoID>1</RepoID>
    <Title>Avoid MemoryMarshal.Cast when transcoding from UTF-16 to UTF-8 while escaping in Utf8JsonWriter.</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/40979 in master.

This is meant to be a targeted fix to be ported to 3.0.

cc @steveharter, @GrabYourPitchforks, @pranavkm, @ericstj  </Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40995</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpClient adding a header changes the case of the header name</Title>
    <Description>For example: httpClient.DefaultRequestHeaders.Add("X-Request-Id", "test");
This adds a header with the last character upper-cased: X-Request-ID

Cause: When adding a header, the code is searching for any HttpKnownHeaderNames case-insensitive;  if it finds one, it then replaces the value with the one from HttpKnownHeaderNames.

This is problematic for anyone already using one of these headers with a different case (and is high-risk for creating hidden bugs).</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40994</IssueID>
    <RepoID>1</RepoID>
    <Title>JsonDocument documenation fix</Title>
    <Description>cc: @terrajobst @ahsonkhan </Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40993</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Uri handles certain character sequences starting with '%' inconsistently</Title>
    <Description>It's a follow up to #24439.

```
&gt;dotnet --version
3.0.100-preview9-014004
```

Repro steps:
1. `dotnet new console`
2. Paste the following code:
```C#
using System;

namespace uri_from_path_net3_test
{
    class Program
    {
        static void Main(string[] args)
        {
            var localPath = @"e:\%41foo%20bar%25.baz";
            var uri = new Uri(localPath);
            Console.WriteLine("{0}", uri.AbsoluteUri);
            Console.WriteLine("Original path: {0}", localPath);
            Console.WriteLine("Path from Uri: {0}", uri.LocalPath);
        }
    }
}
```
3. `dotnet run`

The output is:
```
file:///e:/Afoo%20bar%2525.baz
Original path: e:\%41foo%20bar%25.baz
Path from Uri: e:\Afoo bar%25.baz
```

There is no change in behavior since the previous issue. `System.Uri` still handles '%' characters in input string arbitrarily. Notice that in the first line of the output `%41`, `%20` and `%25` of the input string were processed in three different ways.

Ultimately, I expect to be able to recover the local paths from Uri form, i.e. the following code:
```
            var localPath = @"e:\%41foo%20bar%25.baz";
            var uri = new Uri(localPath);
            var anotherUri = new Uri(uri.AbsoluteUri);
            Console.WriteLine("Original path: {0}", localPath);
            Console.WriteLine("Path from Uri: {0}", anotherUri.LocalPath);
```
should produce same paths in both lines.
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40992</IssueID>
    <RepoID>1</RepoID>
    <Title>Update CoreClr, CoreFx, CoreSetup to servicing-28008-02, servicing-28008-03, stable, respectively (release/2.2)</Title>
    <Description>/cc @dotnet/maestro-reviewers-core</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40991</IssueID>
    <RepoID>1</RepoID>
    <Title>Support nullable values in dictionaries</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/40936.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40990</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @obligaron</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40989</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190910.4
- **Date Produced**: 9/10/2019 8:06 PM
- **Commit**: ad49bfe43c7d8e2931d0bde6fb8e894f6332c364
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19460.4

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40988</IssueID>
    <RepoID>1</RepoID>
    <Title>Consider creating an IndexSet Type</Title>
    <Description>Now that C# 8 has [Ranges](https://docs.microsoft.com/en-us/dotnet/api/system.range?view=netstandard-2.1), perhaps it is time to consider adding an "IndexSet" type. An IndexSet is a sorted collection of unique, unsigned, non-contiguous integers, generally represented as Ranges. For ex: The following IndexSet contains 260 integers in 3 Ranges.
`IndexSet anIndexSet = {  [0..100], [150..300], [1000..1010]  }`

This is potentially useful in a number of applications. For ex: Http response codes in the 2xx range are usually a success of some kind. A call such as `HttpResponseSuccessIndexSet.Contains(210)` is trivial to do with an IndexSet. An IndexSet can also be used to store indices into other data structures. Other examples would be to return a set of Ranges from a 1D/2D matrix, return a set of rows from a table, Ranges of enum values etc. 

**Rationale**
Compared to storing entire sets of integers in a dictionary, an IndexSet:
	1. Uses less memory
	2. Can efficiently answer questions about intersections and membership
	3. Can efficiently return an index that is greater/equal/lesser than a specified index
	4. Always has the same ordering(sorted) =&gt; supports iteration over the indices potentially applying delegates 
	
Note: An IndexSet is NOT efficient when storing arbitrary integers because each index will be stored as a Range
Note: An IndexSet also stores only 1 instance of an index

**An API Sketch**
```C# &lt;code&gt;
public class ReadOnlyIndexSet : IEnumerable&lt;Range&gt;
    {
        public ReadOnlyIndexSet(Range range) { }

        public ReadOnlyIndexSet(ReadOnlyIndexSet indexSet) { }

        /// &lt;summary&gt;
        /// Returns the number of integers in the current ReadOnlyIndexSet
        /// &lt;/summary&gt;
        public int Count() =&gt; throw new NotImplementedException();

        /// &lt;summary&gt;
        /// Returns the number of integers in the given range
        /// &lt;/summary&gt;
        /// &lt;param name="range"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public int Count(Range range) =&gt; throw new NotImplementedException();

        public Range this[int index]
        {
            get;
        }

        public bool Contains(int value);

        /// &lt;summary&gt;
        /// Returns true if this ReadOnlyIndexSet contains all the integers in other
        /// &lt;/summary&gt;
        /// &lt;param name="other"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool Contains(ReadOnlyIndexSet other) =&gt; throw new NotImplementedException();

        public bool Contains(Range other) =&gt; throw new NotImplementedException();

        /// &lt;summary&gt;
        /// Returns true if this ReadOnlyIndexSet intersects any of the integers in other
        /// &lt;/summary&gt;
        /// &lt;param name="other"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool Intersects(ReadOnlyIndexSet other) =&gt; throw new NotImplementedException();

        public bool Intersects(Range other) =&gt; throw new NotImplementedException();

        public int Start { get; }
        public int End { get; }

        public int IndexLessThanOrEqualTo(int value);
        public int IndexGreaterThanOrEqualTo(int value);
        public int IndexLessThan(int value);
        public int IndexGreaterThan(int value);

     }

    public class IndexSet : ReadOnlyIndexSet
    {
        public IndexSet(Range range) : base(range) { }

        public void Add(int index);

        public void Add(ReadOnlyIndexSet indexSet);

        public void Add(Range range);

        public void Remove(int index);

        public void Remove(ReadOnlyIndexSet indexSet);

        public void Remove(Range range);

        public void RemoveAll();
    }
```

Example:

```C# &lt;code&gt;
 List&lt;string&gt; cities = new List&lt;string&gt;() { "New York", "Vancouver", "Seattle", "Frankfurt", "Paris", "Chicago", "Vienna" };

            IndexSet americanCities = new IndexSet(new Range(0, 2));
            americanCities.Add(5);

            // Queries
            americanCities.Contains(1..2); // Will return true
            americanCities.Contains(2..5); // Will return false
            americanCities.Intersects(2..5); // Will return true
            americanCities.IndexGreaterThan(2); // Will return 5
```


I've tried to keep the number of APIs minimal. For ex: APIs around enumeration of the underlying indices can be added, but I figured they are easy enough to achieve with the currently proposed APIs.


Tagging @safern since he owns Systems.Collections.Specialized and this feels like a good fit. Looking forward to hearing the community's thoughts around this.

**Discussion**
1. What's the advantage of an IndexSet over SortedSet&lt;Range&gt;?
Memory essentially. As the number of indexes(stored as Ranges) increases, an IndexSet uses lesser memory compared to a SortedSet. An IndexSet is more specialized than a SortedSet/HashSet/Set of Range because any modifications work on the underlying ranges. Hopefully, the following examples make it clear:
`IndexSet myIndexSet = new IndexSet() { [1..4], [6..8] };
myIndexSet.Add(5); // myIndexSet will now hold {[1..8]}
myIndexSet.Add([5..9]); // myIndexSet will hold {[1..9]}`
If I instead used a Set&lt;Range&gt;, for the same ops, depending on the Set comparator, I might end up with:
`Set&lt;Range&gt; myset = new Set&lt;Range&gt;() { [1..4], [6..8] };
myset.Add(5); // myset will now hold {[1..4], [5], [6..8]}
myset.Add([5..9]); //myset will hold {[1..4], [5], [5..9], [6..8]}?`
Removing an index from an IndexSet makes the difference more apparent:
`IndexSet myIndexSet = new IndexSet() { [1..4], [6..8] };
myIndexSet.Remove(2); // myIndexSet will now hold {[1], [3..4], [6..8]}`
With a Set&lt;Range&gt;, to remove from the middle of a Range, I'd have to first remove the range containing 2 i.e. [1..4] from the set, split it into [1] and [3..4], and then re-add them to the Set.


 
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40987</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/2.1' =&gt; 'release/2.2'</Title>
    <Description>I detected changes in the release/2.1 branch which have not been merged yet to release/2.2. I'm a robot and am configured to help you automatically keep release/2.2 up to date, so I've opened this PR.

This PR merges commits made on release/2.1 by the following committers:

* @dotnet-bot

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/2.1
git pull --ff-only
git checkout release/2.2
git pull --ff-only
git merge --no-ff release/2.1

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/2.1-to-release/2.2'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/2.1-to-release/2.2 release/2.2
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/2.1-to-release/2.2
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/2.1-to-release/2.2
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40986</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/arcade dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190910.3
- **Date Produced**: 9/10/2019 6:11 PM
- **Commit**: 0f5cfb20a355c27bc84cedd049c946b44a7fc1da
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19460.3
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19460.3
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19460.3
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19460.3
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19460.3
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19460.3

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190910.5
- **Date Produced**: 9/10/2019 9:43 PM
- **Commit**: d46dbc2c643e57b0d6a49b6c7bd3739fcd0c7e8c
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19460.5

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)



</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40985</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @tarekgh</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40984</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190910.2
- **Date Produced**: 9/10/2019 4:11 PM
- **Commit**: 70ee2a2175f7976daed4fc0a2c2f02aaf08dd2c4
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19460.2
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19460.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19460.2

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40983</IssueID>
    <RepoID>1</RepoID>
    <Title>Delete unused ItemGroup</Title>
    <Description>Moved to CoreLib</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40982</IssueID>
    <RepoID>1</RepoID>
    <Title>Rename System.Linq.Expressions/src/*.Generated.cs files</Title>
    <Description>There are several files in System.Linq.Expressions/src named *.Generated.cs that are (no longer?) generated. The files should be renamed.

System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs
System\Linq\Expressions\Compiler\LambdaCompiler.Generated.cs
System\Linq\Expressions\Compiler\StackSpiller.Generated.cs
System\Linq\Expressions\Interpreter\CallInstruction.Generated.cs
System\Linq\Expressions\Interpreter\LightLambda.Generated.cs</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40981</IssueID>
    <RepoID>1</RepoID>
    <Title>Microsoft Security Advisory CVE-2019-1301: Denial of Service Vulnerability in .NET Core</Title>
    <Description># Microsoft Security Advisory CVE-2019-1301: Denial of Service Vulnerability in .NET Core

## &lt;a name="executive-summary"&gt;&lt;/a&gt;Executive summary

Microsoft is releasing this security advisory to provide information about a vulnerability in .NET Core. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.

Microsoft is aware of a denial of service vulnerability when .NET Core improperly handles web requests. An attacker who successfully exploited this vulnerability could cause a denial of service against a .NET Core web application. The vulnerability can be exploited remotely, without authentication.

The update addresses the vulnerability by correcting how the .NET Core web application handles web requests.

## Announcement

The original announcement for this issue can be found at https://github.com/dotnet/announcements/issues/121

## &lt;a name="mitigation-factors"&gt;&lt;/a&gt;Mitigation factors

None

## &lt;a name="affected-software"&gt;&lt;/a&gt;Affected software

Any .NET Core based application running on .NET Core 2.1.0-2.1.12, or .NET Core 2.2.0-2.2.6


### &lt;a name="how-affected"&gt;&lt;/a&gt;How do I know if I am affected?

You can list the versions you have installed by running the `dotnet --info` command. You will see output like the following;

```
.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview3-010431
 Commit:    d72abce213

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100-preview3-010431\

Host (useful for support):
  Version: 3.0.0-preview3-27503-5
  Commit:  3844df9537

.NET Core SDKs installed:
  2.1.604 [C:\Program Files\dotnet\sdk]
  2.2.202 [C:\Program Files\dotnet\sdk]
  3.0.100-preview3-010431 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]\
  Microsoft.AspNetCore.All 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview3-19153-02 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.11 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview3-27503-5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0-preview3-27504-2 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

If you have a version of .NET Core less than 2.1.13 or less than 2.2.7, you're vulnerable.

### &lt;a name="how-fix"&gt;&lt;/a&gt;How do I fix the issue?

To fix the issue please install the latest version of .NET Core. If you have multiple versions of .NET Core installed you will need to install multiple runtimes, or SDKs depending on what you have installed.

* For machines running .NET Core 2.1, you should download Runtime 2.1.13 or SDK 2.1.509 for Visual Studio 2017 or SDK 2.1.606 for Visual Studio 2019 (v16.0) or SDK 2.1.802 for Visual Studio 2019 (v16.2) from https://dotnet.microsoft.com/download/dotnet-core/2.1.
* For machines running .NET Core 2.2, you should download Runtime 2.2.7 or SDK 2.2.109 for Visual Studio 2017 or SDK 2.2.206 for Visual Studio 2019 (v16.0) or SDK 2.2.402 for Visual Studio 2019 (v16.2) from https://dotnet.microsoft.com/download/dotnet-core/2.2.

If you have both 2.1 and 2.2, you need to install updates for both versions.

Once you have installed the updated runtime or SDK, restart your apps for the update to take effect.

If you have [pinned your application](https://docs.microsoft.com/dotnet/core/versions/selection) to a specific version of the runtime, you must update your app, recompile and redeploy it for the update to take effect.

# Other Information

### Reporting Security Issues

If you have found a potential security issue in .NET Core, please email details to secure@microsoft.com. Reports may qualify for the .NET Core Bug Bounty. Details of the .NET Core Bug Bounty including terms and conditions are at [https://aka.ms/corebounty](https://aka.ms/corebounty).

### Support

You can ask questions about this issue on GitHub in the .NET Core or ASP.NET Core organizations. These are located at https://github.com/dotnet/ and https://github.com/aspnet/, respectively. The Announcements repo for each product (https://github.com/dotnet/Announcements and https://github.com/aspnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the discussion issue.

### Disclaimer

The information provided in this advisory is provided "as is" without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.

### Acknowledgments

Paul Ryman of VMware Sydney Engineering Team

### External Links

[CVE-2019-1301](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-1301)

### Revisions

V1.0 (September 10, 2019): Advisory published.
V1.1 (September 10, 2019): Fix version numbers

_Version 1.1_

_Last Updated 2019-09-10_
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40980</IssueID>
    <RepoID>1</RepoID>
    <Title>Re-enable macOS 10.13 in CI</Title>
    <Description>https://github.com/dotnet/core-eng/issues/7758#issuecomment-529709901</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40979</IssueID>
    <RepoID>1</RepoID>
    <Title>[System.Text.Json] UnsafeRelaxedJsonEscaping can result in StackOverflowException</Title>
    <Description>```C#
var test = new { Name = "测试11" };
Console.WriteLine(JsonSerializer.Serialize(test, new JsonSerializerOptions { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping, PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));
```

Here's what's causing the StackOverflow:

![image](https://user-images.githubusercontent.com/174281/64631901-ef0db780-d3ac-11e9-9bca-563841083e8a.png)

---------------------------------------------------
Original text:

_From @Zonciu on Tuesday, September 10, 2019 2:16:16 PM_

### Describe the bug
WebApi returning specific content cause stack overflow

### To Reproduce
#### Reproduction project
[WebApplication.zip](https://github.com/aspnet/AspNetCore/files/3596081/WebApplication.zip)

Steps to reproduce the behavior:
1. Using this version of NET Core 3.0 Preview 9
2. dotnet new webapi
3. Add controller methods:
```
    public class Test
    {
        public string Name { get; set; }
    }

    [ApiController]
    [Route("test")]
    public class TestController : ControllerBase
    {
        [HttpGet("1")]
        public Test Get([FromServices] ILogger&lt;Test&gt; logger)
        {
            logger.LogInformation("Get test 2");
            return new Test {Name = "测试"};
        }

        [HttpGet("2")]
        public Test Get2([FromServices] ILogger&lt;Test&gt; logger)
        {
            logger.LogInformation("Get test 2");
            return new Test {Name = "测试11"};
        }
    }
```
4. Access `/test/1` is ok, but `/test/2` causing stack overflow and crashed.


### Expected behavior
Access `/test/2`, return `{"name":"测试1"}`

### Screenshots
/test/1
![image](https://user-images.githubusercontent.com/10374056/64621218-e0101f00-d417-11e9-9fce-86ad3da7e051.png)


/test/2
![image](https://user-images.githubusercontent.com/10374056/64621165-cbcc2200-d417-11e9-9261-f6861d1708dd.png)


### Additional context
dotnet --info output
```
.NET Core SDK（反映任何 global.json）:
 Version:   3.0.100-preview9-014004
 Commit:    8e7ef240a5

运行时环境:
 OS Name:     Windows
 OS Version:  10.0.17763
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100-preview9-014004\

Host (useful for support):
  Version: 3.0.0-preview9-19423-09
  Commit:  2be172345a

.NET Core SDKs installed:
  2.1.801 [C:\Program Files\dotnet\sdk]
  3.0.100-preview9-014004 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview9.19424.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
```


_Copied from original issue: aspnet/AspNetCore#13856_</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40977</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Add test for IComponent typeconverter register in TypeDescriptor</Title>
    <Description>Port: #40959

Test change only. @danmosemsft yesterday approved to merge offline.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40976</IssueID>
    <RepoID>1</RepoID>
    <Title>Use slow path for CallInstruction returning enum value</Title>
    <Description>Fixes #40968

Reverts part of the change made in #28792.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40974</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix namespace typo in Tasks test</Title>
    <Description>Fixes #40973</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40973</IssueID>
    <RepoID>1</RepoID>
    <Title>Namespace name typo - Sytem.Threading.Tasks.Tests</Title>
    <Description>https://github.com/dotnet/corefx/blob/7ae1a252d7e68c5513d2658de7a401c37e9b0504/src/System.Threading.Tasks.Parallel/tests/RespectParentCancellationTest.cs#L22</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40972</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190909.39
- **Date Produced**: 9/10/2019 7:14 AM
- **Commit**: 9090711c8aba450144a57008fa6e0bad0e601313
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19459.39
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19459.39
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19459.39

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190909.14
- **Date Produced**: 9/10/2019 8:08 AM
- **Commit**: ca890ed4eceb71c0a78d63e8e030497a1b613b80
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19459.14
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19459.14

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190909.2
- **Date Produced**: 9/9/2019 1:06 PM
- **Commit**: 677c0a79f2afbd99712ddcdaf333163bc4f91235
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19459.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40971</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)
## From https://github.com/dotnet/arcade
- **Build**: 20190909.10
- **Date Produced**: 9/10/2019 12:07 AM
- **Commit**: f5ccfdcbd828383d39cf583086ef42d72ca5b320
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19459.10
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19459.10
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19459.10
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19459.10

[marker]: &lt;&gt; (End:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40970</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190909.9
- **Date Produced**: 9/10/2019 12:38 AM
- **Commit**: 3b177c44a3005cd5733ec4f94b6c1408abbc4290
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19459.9
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19459.9
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19459.9

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40978</IssueID>
    <RepoID>1</RepoID>
    <Title>WPF project with AutoGenerateBindingRedirects enabled produces MSB3277</Title>
    <Description>WPF project with `AutoGenerateBindingRedirects` enabled produces a MSB3277 warning, which is a similar issue to https://github.com/dotnet/corefx/issues/40012#issuecomment-522209519:

&gt; C:\Program Files\dotnet\sdk\3.0.100-preview9-013908\Microsoft.Common.CurrentVersion.targets(2106,5): warning MSB3277: Found conflicts between different versions of "System.IO.Pipes.AccessControl" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.

I started to get this MSB3277 warning after migrating my WPF project from 3.0 preview 7 to 3.0 preview 9.

## Workaround
Disable `AutoGenerateBindingRedirects` when targeting netcoreapp. Normally you do not need it on .NET Core.

## Steps to reproduce
`dotnet build` the following project: [WpfApp.zip](https://github.com/dotnet/core-setup/files/3595468/WpfApp.zip)

or

```
dotnet new global.json --sdk-version "3.0.100-preview9-014004"
dotnet new wpf -f netcoreapp3.0 --name WpfApp --output .
* Add &lt;AutoGenerateBindingRedirects&gt;true&lt;/AutoGenerateBindingRedirects&gt; to WpfApp.csproj *
dotnet build
```

## Expected  behavior
No warning.

## Actual behavior
Build generates an MSB3277 warning.

```
.NET Core 向け Microsoft (R) Build Engine バージョン 16.3.0-preview-19426-01+faf5e5d75
Copyright (C) Microsoft Corporation.All rights reserved.

  C:\tmp\a\WpfApp.csproj の復元が 14.68 ms で完了しました。
  You are using a preview version of .NET Core. See: https://aka.ms/dotnet-core-preview
C:\Program Files\dotnet\sdk\3.0.100-preview9-014004\Microsoft.Common.CurrentVersion.targets(2106,5): warning MSB3277: "System.IO.Pipes.AccessControl" の異なるバージョン間で、解決できない競合が見つかりました。これらの参照上の競合は、ログの詳細度が詳細に設定されている場合にビルド ログにリストされます。 [C:\tmp\a\WpfApp.csproj]
  WpfApp -&gt; C:\tmp\a\bin\Debug\netcoreapp3.0\WpfApp.dll

ビルドに成功しました。
```

## Environment data
- .NET Core SDK 3.0.100-preview9-014004
- Windows 10 Pro 1903 (18362.295)

## Notes
- The detailed-level log states that `C:\Program Files\dotnet\packs\Microsoft.WindowsDesktop.App.Ref\3.0.0-preview9-19423-09\ref\netcoreapp3.0\System.IO.Pipes.AccessControl.dll` is 4.0.3.0 while `C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\3.0.0-preview9-19423-09\ref\netcoreapp3.0\System.Core.dll` references 4.0.4.0.
    &gt; "System.IO.Pipes.AccessControl, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" と "System.IO.Pipes.AccessControl, Version=4.0.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" の間で競合が発生しました。
    &gt; ...
- `System.IO.Pipes.AccessControl, Version=4.0.3.0` is the one published at https://www.nuget.org/packages/System.IO.Pipes.AccessControl/4.5.1.
- `System.IO.Pipes.AccessControl, Version=4.0.4.0` is not publicly published as a NuGet package.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40969</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190909.10
- **Date Produced**: 9/10/2019 12:07 AM
- **Commit**: f5ccfdcbd828383d39cf583086ef42d72ca5b320
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19459.10
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19459.10
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19459.10
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19459.10

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40968</IssueID>
    <RepoID>1</RepoID>
    <Title>Interpreting Expression results in InvalidCastException on 3.0 but not 2.2</Title>
    <Description>Consider the following code:

```c#
using System;
using System.Linq.Expressions;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    class Program
    {
        static DayOfWeek Cast(int i) =&gt; (DayOfWeek) i;

        static void Main(string[] args)
        {
            Expression&lt;Func&lt;DayOfWeek[]&gt;&gt; expr = () =&gt; new[] {Cast(1)};

            Console.WriteLine(RuntimeInformation.FrameworkDescription);
            Console.WriteLine("preferInterpretation=false:" + expr.Compile(false)()[0]);
            Console.WriteLine("preferInterpretation=true:" + expr.Compile(true)()[0]);
        }
    }
}
```

On 2.2, the output is as follows:

```
.NET Core 4.6.27817.03
preferInterpretation=false:Monday
preferInterpretation=true:Monday
```

On 3.0 however, the second evaluation of the Expression (with preferInterpretation=true) results in an exception being thrown:

```
.NET Core 3.0.0-preview9-19423-09
preferInterpretation=false:Monday
Unhandled exception. System.InvalidCastException: Object cannot be stored in an array of this type.
   at System.Array.InternalSetValue(Void* target, Object value)
   at System.Array.SetValue(Object value, Int32 index)
   at System.Linq.Expressions.Interpreter.NewArrayInitInstruction.Run(InterpretedFrame frame)
   at System.Linq.Expressions.Interpreter.Interpreter.Run(InterpretedFrame frame)
   at System.Linq.Expressions.Interpreter.LightLambda.Run(Object[] arguments)
   at Thunk(Func`2 )
   at ConsoleApp1.Program.Main(String[] args) in C:\git\ConsoleApp1\ConsoleApp1\Program.cs:line 17
```

Can this regression be resolved in the final version of 3.0?
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40967</IssueID>
    <RepoID>1</RepoID>
    <Title>Add .Net Framework TFM to System.Reflection.MetadataLoadContext</Title>
    <Description>Please add a net4* target such as (net46 or net461 ?) to System.Reflection.MetadataLoadContext as recommended by your own [Open-source library guidance
](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting).

I want to consume it in a msbuild (distributed via nuget) task which should run on VS2015+ and I really do not want to have to ship the extra netstandard support assemblies.
They have given me problem before and I really cannot change target framework or which version of netstandard assemblies msbuild is bundled with.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40966</IssueID>
    <RepoID>1</RepoID>
    <Title>What is the [__DynamicallyInvokable]?</Title>
    <Description>as title.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41116</IssueID>
    <RepoID>1</RepoID>
    <Title>HttpContext.Session.GetString Not Working on Linux</Title>
    <Description>I have an Asp.net Core application version 2 (I have yet to upgrade it to version 2.2and beyond)

The following code generates a Captcha image:
```
public FileStreamResult GetCaptchaImage()
        {
            int width = 200;
            int height = 60;

            string captchaCode = Captcha.GenerateCaptchaCode();
            
            var result = Captcha.GenerateCaptchaImage(width, height, captchaCode);

            HttpContext.Session.SetString("CaptchaCode", result.CaptchaCode);

            Stream s = new MemoryStream(result.CaptchaByteData);

            return new FileStreamResult(s, "image/png");
        }
```
When I test the Captcha code is correct with code like this:
```
if (viewModel.CaptchaCode != HttpContext.Session.GetString("CaptchaCode"))
{
}
```
It works fine on my local windows PC and on Azure but not on a Ubuntu VPS.
On the Ubuntu VPS it always comes back as null.

I build the project on a Windows PC using the following commands:
```
dotnet restore -r ubuntu.16.04-x64
dotnet build -r ubuntu.16.04-x64
dotnet publish -f netcoreapp2.0 -c Release -r ubuntu.16.04-x64
```
And then  publish to Linux.

Any ideas how I can fix this?</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>15/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40965</IssueID>
    <RepoID>1</RepoID>
    <Title>.NET Core 3.0 Prev9 Intellisense nupkg version bump</Title>
    <Description>This change updates the IntelliSense nuget version to one that includes additional documentation that was merged today (English only).
This is an infrastructure change, no product code involved.
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40964</IssueID>
    <RepoID>1</RepoID>
    <Title>Permission denied in Interop.Sys.ForkAndExecProcess (Linux)</Title>
    <Description>Out of the blue I suddenly can't call the program `virsh` from my .Core console app in Linux using `Process.Start` (been running fine for the last year, not aware of any system changes, e.g. didn't run any updates)

I get the following error:

     Permission denied
     at Interop.Sys.ForkAndExecProcess(String filename, String[] argv, String[] envp, String cwd, Boolean redirectStdin, Boolean redirectStdout, Boolean redirectStderr, Boolean setUser, UInt32 userId, UInt32 groupId, Int32&amp; lpChildPid, Int32&amp; stdinFd, Int32&amp; stdoutFd, Int32&amp; stderrFd, Boolean shouldThrow)
     at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)
     at System.Diagnostics.Process.Start()
     at wconfig.Menus.MAIN.Test(Object&amp; Obj)

 - I run my .Net Core app as root
 - I can run `virsh` fine from shell (also using root)
 - I can run `virsh` fine with `Process.Start` if I inwrap it in `bash -c` in my  Process.Start code
 - I can run other commands in my .Net Core app fine, I only see the problem with virsh (for now)
 - Can fine call `virsh` for a bash .sh script 

.Net Core code example:

    Dim PI As New ProcessStartInfo
    PI.RedirectStandardOutput = False
    PI.FileName = "virsh"
    PI.Arguments = "list --all"
    Using proc As New Process
      proc.StartInfo = PI
      proc.Start()
    End Using

Using dotnet runtime 2.2.3
Debian Buster (10)

Unfortunately I don't have deep knowledge of `virsh`. But I assume it's interacting with KVM,QEMU and libvirtd (Virtualization daemon) where some more advance permission "things" are in play?
But on the other hand if I can call `virsh` from shell as root, I expect I should be able to do that from net core when starting the app from the root user. Something funny is going on :-P

I'm pretty sure it will work fine on another server with the same versions of virsh, dotnet runtime and Linux version. But it seem it can "break" any time.
I understand the problem can be related to my Linux or virsh configuration and not dotnet. But on the other hand, I only see the problem in dotnet Process.Start.

Perhaps anyone in here have a clue or can point me in a direction to track down the problem?</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40963</IssueID>
    <RepoID>1</RepoID>
    <Title>.NET Core 3.0 Prev9 IntelliSense nupkg version bump</Title>
    <Description>@ahsonkhan @safern @ViktorHofer 
Bumping the IntelliSense package version to the the Prev9 nupkg.</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40962</IssueID>
    <RepoID>1</RepoID>
    <Title>Review System.Buffers.SequenceReader&lt;T&gt; proposals</Title>
    <Description>This is a meta issue for #40871, #40870, #40845, #40843, and #37156 which add new APIs to [`SequenceReader&lt;T&gt;`](https://apisof.net/catalog/System.Buffers.SequenceReader%3CT%3E). This captures the overall change for the review. Detailed discussions are in the linked issues.

Proposed new surface area:

``` C#
namespace System.Buffers
{
    public ref struct SequenceReader&lt;T&gt;
    {
        // Optimized API to position the reader at the end of the sequence (much faster than what users can write)
        public void AdvanceToEnd();

        // Pairs with existing Span&lt;T&gt; UnreadSpan;
        public ReadOnlySequence&lt;T&gt; UnreadSequence { get; }

        // Peeking out T, while skipping. This is more performant than users can write (avoids rewinding).
        public bool TryPeek(int skip, out T value);

        // Overloads for TryRead that allow reading out a given count rather than to some delimiter (as with existing
        // API span out will slice if it can or allocate and copy if it has to).
        bool TryRead(int count, out ReadOnlySpan&lt;T&gt; value);
        bool TryRead(int count, out ReadOnlySequence&lt;T&gt; value);

        // Equivalent "Peek" versions. They need a skip as peeking doesn't advance the reader and rewinding is super expensive.
        public bool TryPeek(int count, out ReadOnlySpan&lt;T&gt; value);
        public bool TryPeek(int skip, int count, out ReadOnlySpan&lt;T&gt; value);
        public bool TryPeek(int count, out ReadOnlySequence&lt;T&gt; value);
        public bool TryPeek(int skip, int count, out ReadOnlySequence&lt;T&gt; value);
 
        // Pairs with existing TryCopyTo(Span&lt;T&gt; destination), which does not advance the reader (neither does this)
        public bool TryCopyTo(int skip, Span&lt;T&gt; destination);

        // Also proposed, but having this can lead to writing slow code.
        public bool SetPosition(SequencePosition position);
   }
}
```
</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40961</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @stephentoub @TylerBrinkley</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40960</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190909.7
- **Date Produced**: 9/9/2019 8:58 PM
- **Commit**: d13d1b61de8a28e0d5509273a6ec3de35b1dd258
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19459.7
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19459.7
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19459.7

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>10/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40959</IssueID>
    <RepoID>1</RepoID>
    <Title>Add test for IComponent typeconverter register in TypeDescriptor</Title>
    <Description>In: #40837 we added `ComponentConverter` as `IComponent`'s converter, however we missed to add a  test entry for the `TypeDescriptor`.

cc: @danmosemsft @RussKie @ericstj </Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40958</IssueID>
    <RepoID>1</RepoID>
    <Title>make sure BindDuringTcpWait_Succeeds does not run with other tests</Title>
    <Description>I check run log and the test runs at the end as @bradwilson described. This should avoid conflicts with other tests. 

Right now it is only one test but I put CollectionDefinition to HelperBase so it is easy to add more as we find mode cases like this.  

```      
      System.Net.Sockets.Tests.NoParallelTests.BindDuringTcpWait_Succeeds [STARTING]
      System.Net.Sockets.Tests.NoParallelTests.BindDuringTcpWait_Succeeds [FINISHED] Time: 0.0012822s
    Finished:    System.Net.Sockets.Tests
  === TEST EXECUTION SUMMARY ===
     System.Net.Sockets.Tests  Total: 920, Errors: 0, Failed: 0, Skipped: 7, Time: 6.013s
```

fixes  #40475
</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40957</IssueID>
    <RepoID>1</RepoID>
    <Title>Guard against attempting to creating out-of-range spans in macOS File…</Title>
    <Description>…systemWatcher

Fixes https://github.com/dotnet/corefx/issues/40054</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40956</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:66928e2e-bd95-4f7e-280f-08d690bc5860)
## From https://github.com/dotnet/coreclr
- **Build**: 20190909.3
- **Date Produced**: 9/9/2019 5:56 PM
- **Commit**: 1533d6a5db52179c23a552878cd227fb2e7448bf
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.0.0-rc2.19459.3
  - **Microsoft.NETCore.ILAsm** -&gt; 3.0.0-rc2.19459.3
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.0.0-rc2.19459.3

[marker]: &lt;&gt; (End:66928e2e-bd95-4f7e-280f-08d690bc5860)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40954</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:dbb830b1-8f81-460f-dd40-08d72a4caef5)
## From https://github.com/dotnet/coreclr
- **Build**: 20190909.4
- **Date Produced**: 9/9/2019 5:55 PM
- **Commit**: 242b290169bf0af7f2b1f51273adbec17a180130
- **Branch**: refs/heads/release/3.1
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 3.1.0-preview1.19459.4
  - **Microsoft.NETCore.ILAsm** -&gt; 3.1.0-preview1.19459.4
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 3.1.0-preview1.19459.4

[marker]: &lt;&gt; (End:dbb830b1-8f81-460f-dd40-08d72a4caef5)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40953</IssueID>
    <RepoID>1</RepoID>
    <Title>Bug in CultureInfo.Clone() causes .Calendar and .DateTimeFormat.Calendar to diverge</Title>
    <Description>Courtesy of excellent sleuthing by @lpatalas:

Accessing a `CultureInfo` instance's `.DateTimeFormat` property before it is cloned with `.Clone()` unexpectedly causes the clone's `.Calendar` and `.DateTimeFormat.Calendar` properties to reference _different_ objects; from https://github.com/PowerShell/PowerShell/issues/10438#issuecomment-529628273:

&gt; If I would have to guess it's caused by this line: https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Globalization/CultureInfo.cs#L1015. The `_calendar` field is `null` so it's not cloned until it's accessed for the first time. After that it's set and each subsequent `Clone()` call will create new Calendar instance.

Code to reproduce:

```csharp
using System;
using System.Globalization;

public static class Program
{
    public static void Main()
    {
      var orig = CultureInfo.InvariantCulture;
      
      for (var i=0; i&lt;2; ++i) {

        var clone = (CultureInfo)orig.Clone();
        clone.Calendar.TwoDigitYearMax = 2020;

        Console.WriteLine($"Clone {i}: Do .Calendar and .DateTimeFormat.Calendar referrence the same object? {object.ReferenceEquals(clone.Calendar, clone.DateTimeFormat.Calendar)}");
        Console.WriteLine($"Clone {i}: .Calendar.TwoDigitYearMax vs. .DateTimeFormat.Calendar.TwoDigitYearMax: {clone.Calendar.TwoDigitYearMax} vs. {clone.DateTimeFormat.Calendar.TwoDigitYearMax}");

        // Trigger the bug: after this property access,
        // cloning `orig` again makes the clones' .Calendar and .
        // DateTimeFormat.Calendar references *differ*.
        var dummy = orig.DateTimeFormat;
      }

    }
}
```

Expected:

```none
Clone 0: Do .Calendar and .DateTimeFormat.Calendar referrence the same object? True
Clone 0: .Calendar.TwoDigitYearMax vs. .DateTimeFormat.Calendar.TwoDigitYearMax: 2020 vs. 2020
Clone 1: Do .Calendar and .DateTimeFormat.Calendar referrence the same object? True
Clone 1: .Calendar.TwoDigitYearMax vs. .DateTimeFormat.Calendar.TwoDigitYearMax: 2020 vs. 2020
```

Actual (the 2nd iteration exhibits the bug): 

```none
Clone 0: Do .Calendar and .DateTimeFormat.Calendar referrence the same object? True
Clone 0: .Calendar.TwoDigitYearMax vs. .DateTimeFormat.Calendar.TwoDigitYearMax: 2020 vs. 2020
Clone 1: Do .Calendar and .DateTimeFormat.Calendar referrence the same object? False
Clone 1: .Calendar.TwoDigitYearMax vs. .DateTimeFormat.Calendar.TwoDigitYearMax: 2020 vs. 2029
```</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40952</IssueID>
    <RepoID>1</RepoID>
    <Title>Race in Socket.BeginSendTo</Title>
    <Description>There is a race in `Socket` when `BeginSendTo` is used on an unbound socket. You can see code for setting `_rightEndPoint`:

https://github.com/dotnet/corefx/blob/da1f8120aeec867bbd81829358ed348d323b1d14/src/System.Net.Sockets/src/System/Net/Sockets/Socket.cs#L2700-L2737

`SocketTaskExtensions.SendToAsync` wraps this and so is also affected.

`_rightEndPoint` is also used in `BeginReceiveFrom` in a way that could cause a parameter check to be "skipped" if `BeginSendTo` resets it to null.</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40951</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190909.4
- **Date Produced**: 9/9/2019 6:54 PM
- **Commit**: d11814a7310c574c171f17d9b5d26b4b0406878b
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19459.4

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

[marker]: &lt;&gt; (Begin:79f1e123-800e-410f-94d7-08d690bc143a)
## From https://github.com/dotnet/core-setup
- **Build**: 20190909.40
- **Date Produced**: 9/10/2019 8:06 AM
- **Commit**: ade240a7f970e5187e4e0ea47581681df085d44b
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 3.0.0-rc2-19459-40
  - **Microsoft.NETCore.DotNetHost** -&gt; 3.0.0-rc2-19459-40
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 3.0.0-rc2-19459-40

[marker]: &lt;&gt; (End:79f1e123-800e-410f-94d7-08d690bc143a)

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190909.10
- **Date Produced**: 9/10/2019 12:07 AM
- **Commit**: f5ccfdcbd828383d39cf583086ef42d72ca5b320
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19459.10
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19459.10
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19459.10
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19459.10
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19459.10
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19459.10

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)
## From https://dev.azure.com/dnceng/internal/_git/dotnet-optimization
- **Build**: 20190910.1
- **Date Produced**: 9/10/2019 11:30 AM
- **Commit**: 48fd58c24cddbc6c0b0de1c00204aae1170f4864
- **Branch**: refs/heads/master
- **Updates**:
  - **optimization.windows_nt-x64.IBC.CoreFx** -&gt; 99.99.99-master-20190910.1

[marker]: &lt;&gt; (End:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40950</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190909.4
- **Date Produced**: 9/9/2019 6:54 PM
- **Commit**: d11814a7310c574c171f17d9b5d26b4b0406878b
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19459.4

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40949</IssueID>
    <RepoID>1</RepoID>
    <Title>Cannot serialize F# dictionary</Title>
    <Description>``` F#
let parameters = dict &lt;| seq { ("Secret", "secret") }
let contentJson = JsonSerializer.Serialize parameters
```

Throws `NotSupportedException` https://github.com/dotnet/corefx/blob/da1f8120aeec867bbd81829358ed348d323b1d14/src/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Write.HandleDictionary.cs#L144

Why can it happen if parameters variable is of type `IDictionary&lt;string,string&gt;`?</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40948</IssueID>
    <RepoID>1</RepoID>
    <Title>AttributeArray_SetGetAttributesAndModify_DoesCopy failed in CI</Title>
    <Description>https://dev.azure.com/dnceng/public/_build/results?buildId=345574&amp;view=ms.vss-test-web.build-test-results-tab&amp;runId=10345416&amp;resultId=120899&amp;paneView=attachments
```
    System.ComponentModel.Tests.MemberDescriptorTests.AttributeArray_SetGetAttributesAndModify_DoesCopy [FAIL]
      Assert.Same() Failure
      Expected: MockAttribute1 { TypeId = typeof(System.ComponentModel.Tests.MemberDescriptorTests+MockAttribute1) }
      Actual:   MockAttribute2 { TypeId = typeof(System.ComponentModel.Tests.MemberDescriptorTests+MockAttribute2) }
      Stack Trace:
        /_/src/System.ComponentModel.TypeConverter/tests/MemberDescriptorTests.cs(322,0): at System.ComponentModel.Tests.MemberDescriptorTests.AttributeArray_SetGetAttributesAndModify_DoesCopy()
```
https://github.com/dotnet/corefx/blob/f610925aee0ee4ad0586f677815dd0601209560f/src/System.ComponentModel.TypeConverter/tests/MemberDescriptorTests.cs#L310-L323</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40946</IssueID>
    <RepoID>1</RepoID>
    <Title>Mark System.Data.SqlClient as archived component</Title>
    <Description>
    </Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40945</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @stephentoub</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40944</IssueID>
    <RepoID>1</RepoID>
    <Title>Allow more of ConsolePal to be linked away</Title>
    <Description>If an app just uses Console.Write*, it's currently still pulling in support for stdin and stderr, because of the GetUseFileAPIs choke point.</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40943</IssueID>
    <RepoID>1</RepoID>
    <Title>fix of a minor typo in System.Threading.Channels.ChannelReader docs</Title>
    <Description>
    </Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40942</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190908.15
- **Date Produced**: 9/9/2019 8:25 AM
- **Commit**: 7a24cba982af080eeb957380be1464e446643a39
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19458.15
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19458.15
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19458.15

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190908.6
- **Date Produced**: 9/9/2019 4:54 AM
- **Commit**: cc51975a897cb803f1ad76b6b93b2ebd4581bca4
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19458.6
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19458.6

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190908.2
- **Date Produced**: 9/8/2019 12:54 PM
- **Commit**: 36a17c16c16bd7520659913382fba2b79159cb8b
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19458.2

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40941</IssueID>
    <RepoID>1</RepoID>
    <Title>Add generic overloads for Delegate.CreateDelegate</Title>
    <Description>Currently usages of `Delegate.CreateDelegate` tend to be along these lines:

`(Func&lt;object&gt;)Delegate.CreateDelegate(typeof(FuncObject), methodInfo)`

For complicated delegates, this can be quite annoying and error prone.

it would be relatively simple to add generic overloads

```csharp
T CreateDelegate&lt;T&gt;(MethodInfo methodInfo) where T : Delegate
{
    return (T)CreateDelegate(typeof(T), methodInfo);
}
```
and it would make the API much nicer to use.

#### API suggestion

The API is simple. We provide a matching generic overload for every existing overload of Delegate.CreateDelegate, which takes a generic type parameter instead of its first parameter, and returns an instance of the type parameter.

 The implementation for them all is trivial.</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40940</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:79f1e123-800e-410f-94d7-08d690bc143a)
## From https://github.com/dotnet/core-setup
- **Build**: 20190908.11
- **Date Produced**: 9/8/2019 9:25 PM
- **Commit**: 0861098706ac9854dfe5e8b8a2c95bdd07094ef6
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 3.0.0-rc2-19458-11
  - **Microsoft.NETCore.DotNetHost** -&gt; 3.0.0-rc2-19458-11
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 3.0.0-rc2-19458-11

[marker]: &lt;&gt; (End:79f1e123-800e-410f-94d7-08d690bc143a)

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190908.2
- **Date Produced**: 9/8/2019 11:40 PM
- **Commit**: 29ee79a10c58dd6863a46157e374521cac610ad8
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19458.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19458.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19458.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19458.2

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)
## From https://dev.azure.com/dnceng/internal/_git/dotnet-optimization
- **Build**: 20190909.1
- **Date Produced**: 9/9/2019 11:22 AM
- **Commit**: 48fd58c24cddbc6c0b0de1c00204aae1170f4864
- **Branch**: refs/heads/master
- **Updates**:
  - **optimization.windows_nt-x64.IBC.CoreFx** -&gt; 99.99.99-master-20190909.1

[marker]: &lt;&gt; (End:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190909.3
- **Date Produced**: 9/9/2019 1:06 PM
- **Commit**: 7d495a23d400eb6e25779553b97e1dccf1ec6fab
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19459.3

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40939</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190908.2
- **Date Produced**: 9/8/2019 11:40 PM
- **Commit**: 29ee79a10c58dd6863a46157e374521cac610ad8
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19458.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19458.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19458.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19458.2

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40955</IssueID>
    <RepoID>1</RepoID>
    <Title>DotNetCore 2.2.6 is slow on connecting and publish messages to AWS AMQ</Title>
    <Description>DotNetCore 2.2.6 on linux takes a long time to make connections and publish messages to AWS AMQ

# General
We run dotnetcore in containers on our OpenShift cluster. Most recently they failed on all environments because they can no longer connect to AWS AMQ. It feels like it's running against a timeout of something. This issue *only* occurs when running dotnetcore on linux.

My linux guest system is an ubuntu 18.04 ( see `dotnet --info` below ). It also occurs on RHEL 7 containers

I eliminated the network as culprit:
- I can connect from my windows machine, but it takes a long time from my linux guest OS in the same machine.
- My linux guest OS can connect and post messages to AWS AMQ from a java program ( fast ).
- I asked our network guy to allow outgoing network traffic from my machine to that specific instance.
- I used wireshark to monitor the network traffic from my PC to see if it connected somewhere else ( which it didn't ).

I eliminated AWS AMQ as the culprit:
- The AWS logs show no sign of something wrong
- The same queue works in a java
- We set up a different queue from scratch and the issue still occurs.

Wireshark shows pauses of ~20seconds at certain intervals. It is consistently around 20seconds, so it does feel like a timeout of some sort...
Wireshark shows dotnetcore connecting with TLS 1.0 connection in both windows &amp; linux using the same cipher suite ( TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA ).
When executing the same code on windows it can connect just fine. When trying to connect to the AWS AMQ in java it is able to connect fine as well.

The only remaining "culprit" I can think of is something going wrong in the dotnetcore runtime itself unless I am missing something.

Below you have a C# code sample ( taken from the amazon documentation ).
Building and running on windows - it works perfect.
Build and running on Linux - It takes forever to connect and post messages ( &gt; 50s ).


Note: I just noticed there is a slight version difference between my linux &amp; windows regarding dotnetcore. I will update it and try that as well and add it as output.

# System Information
Host System: Windows 10
Guest System: Linux 18.04
  &gt; Dotnet SDK was installed through https://dotnet.microsoft.com/download/linux-package-manager/ubuntu18-04/sdk-current

# AWS AMQ Information
Instance Type: mq.t2.micro
Deployment mode: single-instance broker
Broker Engine: ActiveMQ
Broker engine version: 5.15.9

# Build command
``
dotnet build --force -c Release
dotnet publish -c Release -o ../publish/exploded
``

# Run command

``
dotnet AWSMQSend.dll $@
``

# Application output on linux: ( notice gaps in timestamps )

```
9/9/19 11:54:56 AM :: Creating Factory
9/9/19 11:54:56 AM :: Factory Created
9/9/19 11:54:56 AM :: Connection...
9/9/19 11:54:56 AM :: Done
9/9/19 11:54:56 AM :: Creating Session.....
9/9/19 11:55:27 AM :: Done
9/9/19 11:55:27 AM :: Using destination: queue://queue_filip
9/9/19 11:55:57 AM :: Start the connection so that messages will be processed
9/9/19 11:55:57 AM :: Sending message....
9/9/19 11:56:17 AM :: Received message with ID:   ID:fluxbox-34467-637033634349736262-1:0:1:1:1
9/9/19 11:56:17 AM :: Received message with text: Hello World!
```

# Application output on windows:
```
9-9-2019 12:01:39 :: Creating Factory
9-9-2019 12:01:39 :: Factory Created
9-9-2019 12:01:39 :: Connection...
9-9-2019 12:01:40 :: Done
9-9-2019 12:01:40 :: Creating Session.....
9-9-2019 12:01:40 :: Done
9-9-2019 12:01:40 :: Using destination: queue://queue_filip
9-9-2019 12:01:40 :: Start the connection so that messages will be processed
9-9-2019 12:01:40 :: Sending message....
9-9-2019 12:01:40 :: Received message with ID:   ID:BEZAV1CL13911-53543-637036270142492136-1:0:1:1:1
9-9-2019 12:01:40 :: Received message with text: Hello World!
```

# Application Code C# code
```
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using Apache.NMS;
using Apache.NMS.Util;

namespace Apache.NMS.ActiveMQ.Test
{
public class Program
{
    public static void Main(string[] args)
    {
        string host = "&lt;your-host&gt;.mq.eu-central-1.amazonaws.com";
        string port = "61617";
        string userName = "&lt;queue-username&gt;";
        string password = "&lt;queue-password&gt;";

        Uri connecturi = new Uri("activemq:ssl://" + host + ":" + port);

        Console.WriteLine( DateTime.Now + " :: Creating Factory" );

        // NOTE: ensure the nmsprovider-activemq.config file exists in the executable folder.
        IConnectionFactory factory = new NMSConnectionFactory(connecturi);

        Console.WriteLine( DateTime.Now + " :: Factory Created" );

		Console.WriteLine( DateTime.Now + " :: Connection...");
		IConnection connection = factory.CreateConnection( userName, password);
		Console.WriteLine( DateTime.Now + " :: Done");
		Console.WriteLine( DateTime.Now + " :: Creating Session.....");
		//The line below takes 20 seconds to complete!
		ISession session = connection.CreateSession( AcknowledgementMode.AutoAcknowledge );
		Console.WriteLine( DateTime.Now + " :: Done");

		IDestination destination = SessionUtil.GetDestination(session, "queue://queue_filip");
		Console.WriteLine( DateTime.Now + " :: Using destination: " + destination);

		// Create a consumer and producer
		using(IMessageConsumer consumer = session.CreateConsumer(destination))
		using(IMessageProducer producer = session.CreateProducer(destination))
		{
			// Start the connection so that messages will be processed.
			Console.WriteLine( DateTime.Now + " :: Start the connection so that messages will be processed" );
			connection.Start();
			producer.DeliveryMode = MsgDeliveryMode.Persistent;
				
			// Send a message
			ITextMessage request = session.CreateTextMessage("Hello World!");
			request.NMSCorrelationID = "abc";
			request.Properties["NMSXGroupID"] = "cheese";
			request.Properties["myHeader"] = "Cheddar";

			Console.WriteLine( DateTime.Now + " :: Sending message...." );

			producer.Send(request);

			// Consume a message
			ITextMessage message = consumer.Receive() as ITextMessage;
			if(message == null)
			{
				Console.WriteLine( DateTime.Now + " :: No message received!");
			}
			else
			{
				Console.WriteLine( DateTime.Now + " :: Received message with ID:   " + message.NMSMessageId);
				Console.WriteLine( DateTime.Now + " :: Received message with text: " + message.Text);
			}
		}
    }
}
}
```
# dotnet --info [Linux]
```
$ dotnet --info

.NET Core SDK (reflecting any global.json):
 Version:   2.2.401
 Commit:    729b316c13

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  18.04
 OS Platform: Linux
 RID:         ubuntu.18.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.2.401/

Host (useful for support):
  Version: 2.2.6
  Commit:  7dac9b1b51

.NET Core SDKs installed:
  2.2.401 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.2.6 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.2.6 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.2.6 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

# dotnet --info [Windows]
```
$ dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.2.104
 Commit:    73f036d4ac

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.16299
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.2.104\

Host (useful for support):
  Version: 2.2.2
  Commit:  a4fd7b2c84

.NET Core SDKs installed:
  2.2.104 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download
```

# Updates
Update: Execution on linux is fast against a local AMQ docker container, without SSL:

```
9/9/19 2:00:18 PM :: Creating Factory
9/9/19 2:00:18 PM :: Factory Created
9/9/19 2:00:18 PM :: Connection...
9/9/19 2:00:19 PM :: Done
9/9/19 2:00:19 PM :: Creating Session.....
9/9/19 2:00:19 PM :: Done
9/9/19 2:00:19 PM :: Using destination: queue://queue_filip
9/9/19 2:00:19 PM :: Start the connection so that messages will be processed
9/9/19 2:00:19 PM :: Sending message....
9/9/19 2:00:19 PM :: Received message with ID:   ID:fluxbox-44221-637036344189323303-1:0:1:1:1
9/9/19 2:00:19 PM :: Received message with text: Hello World!
```

Edit: Spelling</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>23/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40938</IssueID>
    <RepoID>1</RepoID>
    <Title>Use ThrowHelper in Utf8JsonReader.GetGuid so that the deserializer can catch the exception and re-throw JsonException.</Title>
    <Description>Because we weren't using the ThrowHelper, we weren't setting the source of the exception to `"System.Text.Json.Rethrowable"` so that the Deserializer could catch it and re-throw it as JsonException.

Fixes https://github.com/aspnet/AspNetCore/issues/13811

cc @layomia, @pranavkm, @steveharter </Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40937</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/corert</Title>
    <Description>This PR contains mirrored changes from dotnet/corert


**Please REBASE this PR when merging**

 cc @MichalStrehovsky</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40936</IssueID>
    <RepoID>1</RepoID>
    <Title>System.Text.Json: Serializing IDictionary with nullable value type throws "Specified method is not supported."</Title>
    <Description>Repro:
```
IDictionary&lt;string, float?&gt; dict = new Dictionary&lt;string, float?&gt;
{
	{"Y2016", 42.0f}
};

JsonSerializer.Serialize(new
{
	Foo = dict
});
```

Throws:
```
NotSupportedException: Specified method is not supported.

    System.Text.Json.JsonSerializer.WriteDictionary&lt;TProperty&gt;(JsonConverter&lt;TProperty&gt; converter, JsonSerializerOptions options, ref WriteStackFrame current, Utf8JsonWriter writer)
    System.Text.Json.JsonPropertyInfoNotNullable&lt;TClass, TDeclaredProperty, TRuntimeProperty, TConverter&gt;.OnWriteDictionary(ref WriteStackFrame current, Utf8JsonWriter writer)
    System.Text.Json.JsonPropertyInfo.WriteDictionary(ref WriteStack state, Utf8JsonWriter writer)
    System.Text.Json.JsonSerializer.HandleDictionary(JsonClassInfo elementClassInfo, JsonSerializerOptions options, Utf8JsonWriter writer, ref WriteStack state)
    System.Text.Json.JsonSerializer.HandleObject(JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options, Utf8JsonWriter writer, ref WriteStack state)
    System.Text.Json.JsonSerializer.WriteObject(JsonSerializerOptions options, Utf8JsonWriter writer, ref WriteStack state)
    System.Text.Json.JsonSerializer.Write(Utf8JsonWriter writer, int originalWriterDepth, int flushThreshold, JsonSerializerOptions options, ref WriteStack state)
    System.Text.Json.JsonSerializer.WriteCore(Utf8JsonWriter writer, PooledByteBufferWriter output, object value, Type type, JsonSerializerOptions options)
    System.Text.Json.JsonSerializer.WriteCore(PooledByteBufferWriter output, object value, Type type, JsonSerializerOptions options)
    System.Text.Json.JsonSerializer.WriteCoreString(object value, Type type, JsonSerializerOptions options)
    System.Text.Json.JsonSerializer.Serialize&lt;TValue&gt;(TValue value, JsonSerializerOptions options)

```

Using `Dictionary` instead of `IDictionary` fixes it.</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>20/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40935</IssueID>
    <RepoID>1</RepoID>
    <Title>Replace HashHelpers.Combine with HashCode.Combine in netcoreapp projects</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/25986</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40933</IssueID>
    <RepoID>1</RepoID>
    <Title>Proposal: Zero allocation connectionless sockets</Title>
    <Description>This proposal eliminates allocations for connectionless use of `Socket`. It augments the `SocketAddress` class to allow reuse across operations, becoming a high-perf alternative to `EndPoint`.

# Rationale and Usage

APIs which need to translate between `IPEndPoint` and native `sockaddr` structures are performing a large amount of defensive copying and layering workarounds.

This affects UDP performance and contributes to excessive GC. A simple example is:

```c#
Socket socket = ...;
byte[] buffer = ...;
var remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);

socket.ReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref remoteEndPoint);
socket.SendTo(buffer, 0, buffer.Length, SocketFlags.None, remoteEndPoint);
```

These two calls allocate 12 times:
* 3x `IPEndPoint`
* 3x `IPAddress`
* 3x `SocketAddress`
* 3x `byte[]` ...6x if IPv6

See also: #39317 

New usage has 0 allocations:

```c#
Socket socket = ...;
byte[] buffer = ...;
var remoteAddress = new SocketAddress(AddressFamily.InterNetwork);

socket.ReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, remoteAddress);
socket.SendTo(buffer, 0, buffer.Length, SocketFlags.None, remoteAddress);
```

# Proposed API

```c#
class Socket
{
	public int ReceiveFrom(Span&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress);
	public int SendTo(ReadOnlySpan&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress);
}

class SocketTaskExtensions
{
	public static ValueTask&lt;int&gt; ReceiveFromAsync(this Socket socket, Memory&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress);
	public static ValueTask&lt;int&gt; SendToAsync(this Socket socket, ReadOnlyMemory&lt;byte&gt; buffer, SocketFlags socketFlags, SocketAddress socketAddress);
}

class SocketAsyncEventArgs
{
	// Only one of RemoteEndPoint or RemoteAddress must be specified.
	public SocketAddress RemoteAddress { get; set; }
}

class SocketAddress
{
	// If we can merge System.Net.Primitives and System.Net.Sockets, these two methods are unnecessary. That would be ideal.
	public static void GetBuffer(SocketAddress address, out byte[] buffer);
	public static void SetSockaddrSize(SocketAddress address, int size);
}

class EndPoint
{
	public virtual void SerializeTo(SocketAddress socketAddress); // Already has "SocketAddress Serialize()"; default would be to call that and copy.
}
```

# Details

* It is intended that UDP servers will use `SocketAddress` as a dictionary key to lookup client state, to avoid first converting to `EndPoint`.
   * It is assumed that users will only rarely care to actually get the IP/port/etc. from the `SocketAddress`. This duty continues to be delegated to `EndPoint`.
   * If users ever want to deserialize a `SocketAddress` into an `EndPoint`, they can already use `EndPoint.Create`.
   * Need to ensure only the actual sockaddr structure is compared/hashed, not the entire byte buffer.
* `SocketAddress` is currently duplicated in System.Net.Primitives and System.Net.Sockets to avoid exposing its internal buffer. This change will allow avoiding duplication.
* This relies on users not using a `SocketAddress` until the I/O is finished.
   * This is a bit safer with `EndPoint` as we can take defensive copies before methods return.
* We can currently do some optimizations to avoid all allocations for `SendTo` and `SendToAsync` IPv4/IPv6 with some special casing, so this API would primarily be to optimize `ReceiveFrom` variants as well as (less important) allowing non-IPv4/IPv6 protocols to benefit. Still, if we were to add an API for `ReceiveFrom` we would probably want an API on `SendTo` for symmetry.

# Open Questions

* We've put some effort into not doing something like this before. It would be great to understand why. Currently:
	* We duplicate the `SocketAddress` class in multiple assemblies to avoid exposing its buffer, and have a step to marshal (byte-by-byte) between the two implementations.
	* Tons of APIs take `EndPoint`, it's a nice abstraction that we wanted here despite performance implications.
* It isn't immediately obvious from the API surface that `socketAddress` is written to by `ReceiveFrom`. Is there a better way we can indicate this?
* The two new methods on `SocketAddress` exist purely because System.Net.Sockets needs access to internals in System.Net.Primitives. Any thoughts on how to avoid exposing these "pubternal" bits?
   * One option is to merge System.Net.Primitives and System.Net.Sockets; I don't see harm in this but that is a much larger discussion :)
* If we merge the Primitives and Sockets assemblies, we can get rid of some of the allocations for `ReceiveFrom` without making any API changes. It's not a perfect solution but might be good enough.

# Related Issues

There are two additional issues to update our APIs with `ValueTask`/`Span`/`Memory` that this will need to be consistent with:
* Update `Socket` class #35861 
* Update `UdpClient` class #28131 </Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40934</IssueID>
    <RepoID>1</RepoID>
    <Title>CookieContainer do not handle session cookies (when Expires is not specified)</Title>
    <Description># CookieContainer do not handle session cookies (when Expires is not specified)


According to this page: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie

&gt; The maximum lifetime of the cookie as an HTTP-date timestamp. If not specified, the cookie will have the lifetime of a session cookie. A session is finished when the client is shut down meaning that session cookies will get removed at that point.

Yet, in this case when the Expires is not specified in this Set-Cookie header:
`Set-Cookie: name=value; path=/store; httponly`
The CookieContainer set the Expires property to "1/1/0001 12:00:00 AM"
Which is expired and the cookie is not used in the following requests.
</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40932</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190907.17
- **Date Produced**: 9/8/2019 6:16 AM
- **Commit**: 5e4273b1e9c94ed3c0b80a0cf56fb22be678cad0
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19457.17
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19457.17
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19457.17

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190907.6
- **Date Produced**: 9/7/2019 5:26 PM
- **Commit**: 59c6b1ab96aa2e99ed6ecb33a8bcf9283ce1ea27
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19457.6
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19457.6

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190907.4
- **Date Produced**: 9/7/2019 1:07 PM
- **Commit**: f1f9f8dbf9ec3009ffa96597571ade9ef71dab1e
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19457.4

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40931</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190909.3
- **Date Produced**: 9/9/2019 1:06 PM
- **Commit**: 7d495a23d400eb6e25779553b97e1dccf1ec6fab
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19459.3

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)



</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40930</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190908.1
- **Date Produced**: 9/8/2019 12:37 PM
- **Commit**: 456afea9fbe721e57986a21eb3b4bb1c9c7e4c56
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19458.1
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19458.1
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19458.1

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)



</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40929</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 4 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:79f1e123-800e-410f-94d7-08d690bc143a)
## From https://github.com/dotnet/core-setup
- **Build**: 20190907.15
- **Date Produced**: 9/7/2019 11:17 PM
- **Commit**: 5a84722fb939785e84af6aa4b401d1ec697e06a8
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 3.0.0-rc2-19457-15
  - **Microsoft.NETCore.DotNetHost** -&gt; 3.0.0-rc2-19457-15
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 3.0.0-rc2-19457-15

[marker]: &lt;&gt; (End:79f1e123-800e-410f-94d7-08d690bc143a)

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190907.1
- **Date Produced**: 9/7/2019 12:52 PM
- **Commit**: c27945fc559ee636139d9f460db71242b16483e6
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19457.1
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19457.1
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19457.1
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19457.1

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)
## From https://dev.azure.com/dnceng/internal/_git/dotnet-optimization
- **Build**: 20190908.1
- **Date Produced**: 9/8/2019 11:07 AM
- **Commit**: 48fd58c24cddbc6c0b0de1c00204aae1170f4864
- **Branch**: refs/heads/master
- **Updates**:
  - **optimization.windows_nt-x64.IBC.CoreFx** -&gt; 99.99.99-master-20190908.1

[marker]: &lt;&gt; (End:fc000152-53a0-4a98-0b3e-08d6bc6f2d11)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190908.3
- **Date Produced**: 9/8/2019 12:55 PM
- **Commit**: 4fc22299618f74eeab6092c0d5f7c0d650437904
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19458.3

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40928</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190907.1
- **Date Produced**: 9/7/2019 12:52 PM
- **Commit**: c27945fc559ee636139d9f460db71242b16483e6
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19457.1
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19457.1
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19457.1
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19457.1
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19457.1
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19457.1

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40927</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable OSX.1013.Amd64.Open in CI</Title>
    <Description>https://github.com/dotnet/core-eng/issues/7758

cc @MattGal</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40926</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove ProjectGUIDs from project files and Project and Name attributes from P2Ps</Title>
    <Description>https://github.com/dotnet/project-system/issues/232

ProjectGUIDs and Name arguments aren't necessary anymore and can be removed. There was one Name attribute that didn't match the project file name but I doubt that should cause issues as the name isn't used directly.

Regexes used
```
[^\S\r\n]*&lt;ProjectGuid&gt;{.+}&lt;/ProjectGuid&gt;\s*

```

```
&lt;Project&gt;{.+}&lt;/Project&gt;
```

```
&lt;Name&gt;.+&lt;/Name&gt;
```

cc @safern @ericstj</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40925</IssueID>
    <RepoID>1</RepoID>
    <Title>EventLog access is not supported on this platform (Linux)</Title>
    <Description># EventLog access is not supported on this platform (Linux)

System.PlatformNotSupportedException: EventLog access is not supported on this platform. An exception is thrown on linux platform(CentOS 7) when trying to read the remote windows host events. The same piece of code is working fine on Windows platform.

# General
`string queryString = "*[System/Level=2]"; // XPATH Query
                                                      //SecureString pw = new SecureString();//GetSecurePassword();
                                                      //SecureString theSecureString = new NetworkCredential("", "password").SecurePassword;
            string password = "PASSWORD";
            SecureString sec_pass = new SecureString();
            Array.ForEach(password.ToArray(), sec_pass.AppendChar);



            EventLogSession session = new EventLogSession(
             "IP_ADDRESS",                // Remote Computer hostname
			 "DOMAIN",                 // Domain
			 "USERNAME",                // Username
			 sec_pass,
             SessionAuthentication.Default);
            // Query the Application log on the remote computer.
            EventLogQuery query = new EventLogQuery("Application", PathType.LogName, queryString);
            query.Session = session;

            try
            {
                EventLogReader logReader = new EventLogReader(query);

                // Display event info
                //DisplayEventAndLogInformation(logReader);

                EventRecord eventInstance = logReader.ReadEvent();
                Console.WriteLine(eventInstance.ToXml());
            }
            catch (EventLogException e)
            {
                Console.WriteLine("Could not query the remote computer! " + e.Message);
                return;
            }`
.csproj file for the same
\&lt;Project Sdk="Microsoft.NET.Sdk"\&gt;

  \&lt;PropertyGroup\&gt;
    \&lt;OutputType\&gt;Exe\&lt;/OutputType\&gt;
    \&lt;TargetFramework\&gt;netcoreapp3.0\&lt;/TargetFramework\&gt;
  \&lt;/PropertyGroup\&gt;
  \&lt;ItemGroup\&gt;
    \&lt;PackageReference Include="System.Diagnostics.EventLog" Version="4.6.0-preview9.19421.4" /\&gt;
  \&lt;/ItemGroup\&gt;

\&lt;/Project\&gt;</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>10/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40924</IssueID>
    <RepoID>1</RepoID>
    <Title>Enable TargetFrameworkName attribute</Title>
    <Description>Remove the opt-out of the TargetFrameworkName attribute generation and
fix the existing test to actually test the custom attribute being set
and read correctly by the AppContext class.

Fixes #26456
Fixes #26457

See previous attempt https://github.com/dotnet/corefx/pull/32680 for discussion.</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>13/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40923</IssueID>
    <RepoID>1</RepoID>
    <Title>Mirror changes from dotnet/coreclr</Title>
    <Description>This PR contains mirrored changes from dotnet/coreclr


**Please REBASE this PR when merging**

 cc @stephentoub</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40922</IssueID>
    <RepoID>1</RepoID>
    <Title>IgnoreNullValues does not work with non-nullable value types</Title>
    <Description>Setting JsonSerializerOptions property of IgnoreNullValues to true does not work. 

When attempting to deserialize a DateTime value that is null in the json string it throws the exception below. I thought setting the option to IgnoreNullValues should ignore the property, no?

converted to System.DateTime. Path: $.value[0].deletedDateTime 
InvalidOperationException: Cannot get the value of a token type 'Null' as a string.

Thanks
Youcef</Description>
    <CreatedDate>08/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40921</IssueID>
    <RepoID>1</RepoID>
    <Title>Use PathInternal.EnsureExtendedPrefix in FileSystemSecurity constructors</Title>
    <Description>Fixes https://github.com/dotnet/corefx/issues/29275

FileSecurity fails to read permissions from file that have a path length exceeding 259 characters. I discovered that DirectorySecurity has the same issue.

@JeremyKuhne please help me review this change, the unit tests are currently not passing due to a failure in the step of creating the file or the directory with the long path. See comments in unit test.

Changes in this PR:


- Removed unused `fullPath` string that was being created inside the `FileSecurity` and `DirectorySecurity` constructors that receive a `fileName` string. From now on, their shared parent constructor `FileSystemSecurity` will transform the received filename into a prefixed full path if needed.

- Parent class `NativeObjectSecurity` in `System.Security.AccessControl` throws unhandled `ERROR_PATH_NOT_FOUND` if the file does not exist. Which is weird because we already handle `ERROR_FILE_NOT_FOUND`. SO I added this error to this other existing `else`, so that we keep throwing the same exception.

- Added unit tests for the `FileSecurity` and `DirectorySecurity` constructors that accept a filename string, to ensure a long path doesn't cause trouble.

- The `FileSecurity` class had an internal constructor with an unused parameter `fullPath` and a warning about that unused parameter. Removed unused parameter along with the unnecessary warning comment. Made sure to update the only internal usage of that constructor so it uses the new signature.

- `FileSecurity` and `DirectorySecurity` seem to only be available for Windows, but the documentation is not clear about this restriction. If you agree, @JeremyKuhne, I can add a comment indicating that these classes are exclusive for Windows.

- Renamed internal `FileSystemSecurity` constructor's parameter `name` to `fileName` for clarity.

- Sorted/grouped the csproj includes. Dependencies added:
    - `PathInternal.EnsureExtendedPrefixIfNeeded` -&gt; included reference to `PathInternal.Windows.cs`
    - `PathInternal.Windows.cs` requires `ValueStringBuilder` -&gt; included reference to `ValueStringBuilder.cs`
    - `ValueStringBuilder` requires `ArrayPool` -&gt; included reference to `System.Buffers`</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40920</IssueID>
    <RepoID>1</RepoID>
    <Title>API Proposal: NetworkInterface.Enable() / NetworkInterface.Disable()</Title>
    <Description>At the moment is not possible to toggle a System.Net.NetworkInformation.NetworkInterface state without either using WMI, which does not work all the time or to run cmd/netsh process. It would be much easier and cleaner if there is a C# API for it.

```c#
public abstract class NetworkInterface
{
    /// &lt;summary&gt;
    /// Enables the interface
    /// &lt;/summary&gt;
    void Enable();

    /// &lt;summary&gt;
    /// Disables the interface
    /// &lt;/summary&gt;
    void Disable();
}
```

Usage example:
```c#
void DisableNetwork() 
{
	foreach (var networkInterface in NetworkInterface.GetAllNetworkInterfaces()) 
	{
		networkInterface.Disable();
	}
}
void EnableNetwork() 
{
	foreach (var networkInterface in NetworkInterface.GetAllNetworkInterfaces()) 
	{
		networkInterface.Enable();
	}
}
```</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40919</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190907.5
- **Date Produced**: 9/7/2019 12:57 PM
- **Commit**: 52169813e6822685a9c51d9508de281ea4831052
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19457.5

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)

</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40918</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/core-setup dotnet/corefx dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:08549e3e-8f8e-4201-dc38-08d6815d521b)
## From https://github.com/dotnet/core-setup
- **Build**: 20190906.31
- **Date Produced**: 9/7/2019 5:47 AM
- **Commit**: 16b82c65565db5621891530e71c0272536927246
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 5.0.0-alpha1.19456.31
  - **Microsoft.NETCore.DotNetHost** -&gt; 5.0.0-alpha1.19456.31
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 5.0.0-alpha1.19456.31

[marker]: &lt;&gt; (End:08549e3e-8f8e-4201-dc38-08d6815d521b)

[marker]: &lt;&gt; (Begin:368e60b9-57f7-48bd-020d-08d6874ba0bd)
## From https://github.com/dotnet/corefx
- **Build**: 20190906.21
- **Date Produced**: 9/7/2019 4:24 AM
- **Commit**: 9e8d47c6e548dcacd71cb83133bbf49f74be90ac
- **Branch**: refs/heads/master
- **Updates**:
  - **runtime.native.System.IO.Ports** -&gt; 5.0.0-alpha1.19456.21
  - **Microsoft.NETCore.Platforms** -&gt; 5.0.0-alpha1.19456.21

[marker]: &lt;&gt; (End:368e60b9-57f7-48bd-020d-08d6874ba0bd)

[marker]: &lt;&gt; (Begin:a2867060-7cad-40ad-7917-08d6937ac7c4)
## From https://github.com/dotnet/standard
- **Build**: 20190906.5
- **Date Produced**: 9/7/2019 12:23 AM
- **Commit**: 54b9828661b76b9447acc90f60096e25c7322b2d
- **Branch**: refs/heads/master
- **Updates**:
  - **NETStandard.Library** -&gt; 2.2.0-prerelease.19456.5

[marker]: &lt;&gt; (End:a2867060-7cad-40ad-7917-08d6937ac7c4)

</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40917</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)
## From https://github.com/dotnet/arcade
- **Build**: 20190908.2
- **Date Produced**: 9/8/2019 11:40 PM
- **Commit**: 29ee79a10c58dd6863a46157e374521cac610ad8
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19458.2
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19458.2
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19458.2
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19458.2
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19458.2
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19458.2

[marker]: &lt;&gt; (End:8e91fa34-ea12-4ebd-d4c2-08d7315d8bc7)





</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40916</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/coreclr</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be1e858a-d56c-4174-7dc0-08d6ba16a224)
## From https://github.com/dotnet/coreclr
- **Build**: 20190906.2
- **Date Produced**: 9/7/2019 12:42 AM
- **Commit**: bd8e35e41e6a6e626c4fc623845ec40b7704d109
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.NET.Sdk.IL** -&gt; 5.0.0-alpha1.19456.2
  - **Microsoft.NETCore.ILAsm** -&gt; 5.0.0-alpha1.19456.2
  - **Microsoft.NETCore.Runtime.CoreCLR** -&gt; 5.0.0-alpha1.19456.2

[marker]: &lt;&gt; (End:be1e858a-d56c-4174-7dc0-08d6ba16a224)

</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40915</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from 3 repositories</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:79f1e123-800e-410f-94d7-08d690bc143a)
## From https://github.com/dotnet/core-setup
- **Build**: 20190907.02
- **Date Produced**: 9/7/2019 10:36 AM
- **Commit**: 30d96585d3fd3d6692bab14c6baeebe87a06afa5
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **Microsoft.NETCore.App** -&gt; 3.0.0-rc2-19457-02
  - **Microsoft.NETCore.DotNetHost** -&gt; 3.0.0-rc2-19457-02
  - **Microsoft.NETCore.DotNetHostPolicy** -&gt; 3.0.0-rc2-19457-02

[marker]: &lt;&gt; (End:79f1e123-800e-410f-94d7-08d690bc143a)

[marker]: &lt;&gt; (Begin:a5bda823-89f1-4ce6-0d43-08d6910cd73b)
## From https://github.com/dotnet/arcade
- **Build**: 20190906.10
- **Date Produced**: 9/6/2019 9:27 PM
- **Commit**: 2d393243ba4a0c95c2c18aa266df6e0f43ffe22d
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19456.10
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19456.10
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19456.10
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19456.10

[marker]: &lt;&gt; (End:a5bda823-89f1-4ce6-0d43-08d6910cd73b)

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190907.5
- **Date Produced**: 9/7/2019 12:57 PM
- **Commit**: 52169813e6822685a9c51d9508de281ea4831052
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19457.5

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)

</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40914</IssueID>
    <RepoID>1</RepoID>
    <Title>[master] Update dependencies from dotnet/arcade</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c297d885-0692-40f8-6b97-08d61f281b4c)
## From https://github.com/dotnet/arcade
- **Build**: 20190906.10
- **Date Produced**: 9/6/2019 9:27 PM
- **Commit**: 2d393243ba4a0c95c2c18aa266df6e0f43ffe22d
- **Branch**: refs/heads/master
- **Updates**:
  - **Microsoft.DotNet.XUnitExtensions** -&gt; 2.4.1-beta.19456.10
  - **Microsoft.DotNet.XUnitConsoleRunner** -&gt; 2.5.1-beta.19456.10
  - **Microsoft.DotNet.VersionTools.Tasks** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.ApiCompat** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Arcade.Sdk** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Configuration** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Feed** -&gt; 2.2.0-beta.19456.10
  - **Microsoft.DotNet.Build.Tasks.Packaging** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.CodeAnalysis** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.CoreFxTesting** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.GenAPI** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.GenFacades** -&gt; 1.0.0-beta.19456.10
  - **Microsoft.DotNet.Helix.Sdk** -&gt; 2.0.0-beta.19456.10
  - **Microsoft.DotNet.RemoteExecutor** -&gt; 1.0.0-beta.19456.10

[marker]: &lt;&gt; (End:c297d885-0692-40f8-6b97-08d61f281b4c)

</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40913</IssueID>
    <RepoID>1</RepoID>
    <Title>Increase helix timeout on Windows clients</Title>
    <Description>Depending on the ARM64 windows queue utilization, clients sometimes take longer than the current timeout. Increasing temporarily until the queue has more machines.

Following Matt's recommendation: https://github.com/dotnet/core-eng/issues/7756#issuecomment-528923195</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>08/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40912</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.1] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:0098719e-62fd-45c8-cd5b-08d72a4d12e0)
## From https://github.com/dotnet/standard
- **Build**: 20190907.1
- **Date Produced**: 9/7/2019 7:45 AM
- **Commit**: a0264c3457fed3dc4ea8ed94da2bafa50f46d095
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19457.1

[marker]: &lt;&gt; (End:0098719e-62fd-45c8-cd5b-08d72a4d12e0)



</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40911</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Update dependencies from dotnet/standard</Title>
    <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:c090f591-8433-4a8c-54c8-08d6c734018a)
## From https://github.com/dotnet/standard
- **Build**: 20190907.1
- **Date Produced**: 9/7/2019 7:45 AM
- **Commit**: a0264c3457fed3dc4ea8ed94da2bafa50f46d095
- **Branch**: refs/heads/release/3.0
- **Updates**:
  - **NETStandard.Library** -&gt; 2.1.0-prerelease.19457.1

[marker]: &lt;&gt; (End:c090f591-8433-4a8c-54c8-08d6c734018a)



</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40910</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing dummy primitive to ReadOnlySequence&lt;T&gt;.Enumerator</Title>
    <Description>cc: @ahsonkhan @stephentoub @terrajobst @ericstj </Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40909</IssueID>
    <RepoID>1</RepoID>
    <Title>Do a sanity check of our ref assemblies to see if any struct is missing a dummy field</Title>
    <Description>Based on the following discussion: https://github.com/dotnet/standard/pull/1500#discussion_r321741920

We should do a sanity check to find out if we're missing any dummy field from any significant structs in our ref assemblies.

cc: @stephentoub @ahsonkhan @ericstj </Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>17/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40908</IssueID>
    <RepoID>1</RepoID>
    <Title>[release/3.0] Disable ToolboxBitmatAttribute test in netfx (#40901)</Title>
    <Description>Fixes: https://github.com/dotnet/corefx/issues/40877

TEST Only change.

cc: @ViktorHofer </Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40907</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove Redundant dependency of microsoft.netcoreapp.platforms </Title>
    <Description>
    </Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40906</IssueID>
    <RepoID>1</RepoID>
    <Title>Remove Redundant dependency of microsoft.netcoreapp.platforms</Title>
    <Description>
    </Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>07/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40904</IssueID>
    <RepoID>1</RepoID>
    <Title>HTTP2: Canceling token given to HttpClient.SendAsync does not send RST_STREAM</Title>
    <Description>Found by a customer: https://twitter.com/stevejgordon/status/1169995743568048129

This is a high impact bug. A user will cancel a streaming gRPC call on the client, but the server will never be notified. If the server is checking `CancellationToken.IsCancellationRequested` then it will hang open forever.

This is a regression of https://github.com/dotnet/corefx/issues/38391

Related: https://github.com/dotnet/corefx/issues/39049

---

Repro:
1. `git clone https://github.com/JamesNK/grpc-dotnet.git`
2. `git checkout jamesnk/duplex-cancellation-regression`
3. `dotnet test test\FunctionalTests --filter Name~ServerStreaming_CancellationOnClient_SentToServer`

Logic in the test is something like:
1. Client makes a server streaming call to the server. This means the client is sending one message in the request's HttpContent, which then completes.
2. Server streams multiple messages to the client
3. Client triggers the cancellation token given to gRPC client. HttpClient.SendAsync token is canceled
4. The HttpClient should be sending RST_STREAM to the server, and the server should report the call is canceled. This isn't happening so the server will stream messages forever.

Wireshark log: [cancellation-regression.zip](https://github.com/dotnet/corefx/files/3585848/cancellation-regression.zip)

</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>06/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40903</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable SDL validation</Title>
    <Description>SDL validation is too expensive to run on a per-build basis. Disable for now</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>06/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40902</IssueID>
    <RepoID>1</RepoID>
    <Title>Update StringComparerTests.cs</Title>
    <Description>Added test to check that `StringComparer.Create` overload throws `ArgumentNullException` when a `null` culture is provided.

Relates to https://github.com/dotnet/coreclr/pull/26570</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40901</IssueID>
    <RepoID>1</RepoID>
    <Title>Disable ToolboxBitmatAttribute test in netfx</Title>
    <Description>contributes to: https://github.com/dotnet/corefx/issues/40877

cc: @ViktorHofer </Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>06/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40900</IssueID>
    <RepoID>1</RepoID>
    <Title>[automated] Merge branch 'release/3.0' =&gt; 'release/3.1'</Title>
    <Description>I detected changes in the release/3.0 branch which have not been merged yet to release/3.1. I'm a robot and am configured to help you automatically keep release/3.1 up to date, so I've opened this PR.

This PR merges commits made on release/3.0 by the following committers:

* @stephentoub
* @joperezr
* @dotnet-maestro[bot]
* @Anipik
* @danmosemsft
* @mmitche

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``` sh
git fetch
git checkout release/3.0
git pull --ff-only
git checkout release/3.1
git pull --ff-only
git merge --no-ff release/3.0

# If there are merge conflicts, resolve them and then run git merge --continue to complete the merge
# Pushing the changes to the PR branch will re-trigger PR validation.
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
&lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;


After PR checks are complete push the branch
```
git push
```

## Instructions for resolving conflicts

:warning: If there are merge conflicts, you will need to resolve them manually before merging. You can do this [using GitHub][resolve-github] or using the [command line][resolve-cli].

[resolve-github]: https://help.github.com/articles/resolving-a-merge-conflict-on-github/
[resolve-cli]: https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/

## Instructions for updating this pull request

Contributors to this repo have permission update this pull request by pushing to the branch 'merge/release/3.0-to-release/3.1'. This can be done to resolve conflicts or make other changes to this pull request before it is merged.

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull https://github.com/dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push https://github.com/dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;details&gt;
    &lt;summary&gt;or if you are using SSH&lt;/summary&gt;

```
git checkout -b merge/release/3.0-to-release/3.1 release/3.1
git pull git@github.com:dotnet-maestro-bot/corefx merge/release/3.0-to-release/3.1
(make changes)
git commit -m "Updated PR with my changes"
git push git@github.com:dotnet-maestro-bot/corefx HEAD:merge/release/3.0-to-release/3.1
```

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40899</IssueID>
    <RepoID>1</RepoID>
    <Title>Message_ShouldFormatCountOfRootCausesUsingTheCurrentCulture test failed in CI on UAP</Title>
    <Description>```
C:\dotnetbuild\work\c71fee18-1413-44e3-abc2-d15744bffa90\Work\5e9317f6-b4e2-44b9-9be7-60b734371f6b\Exec&gt;XUnitRunnerUap System.ComponentModel.Composition.Tests.dll -xml "C:\Users\runner\AppData\Local\Packages\5cd54353-3ed7-4a6e-a72f-db349f28867c_v52bfwc2c21ha\LocalState\System.ComponentModel.Composition.Tests.xml" -nologo -nocolor -notrait category=nonuaptests -notrait category=nonwindowstests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing  
  Discovering: System.ComponentModel.Composition.Tests (method display = ClassAndMethod, method display options = None)
  Discovered:  System.ComponentModel.Composition.Tests (found 1500 of 1630 test cases)
  Starting:    System.ComponentModel.Composition.Tests (parallel test collections = on, max threads = 2)
Unhandled exception. Xunit.Sdk.TrueException: Assert.True() Failure
Expected: True
Actual:   False
   at Xunit.Assert.True(Nullable`1 condition, String userMessage) in C:\Dev\xunit\xunit\src\xunit.assert\Asserts\BooleanAsserts.cs:line 96
   at Xunit.Assert.True(Boolean condition) in C:\Dev\xunit\xunit\src\xunit.assert\Asserts\BooleanAsserts.cs:line 63
   at System.ComponentModel.Composition.CompositionExceptionTests.AssertMessage(CompositionException exception, Int32 rootCauseCount, CultureInfo culture) in /_/src/System.ComponentModel.Composition/tests/System/ComponentModel/Composition/CompositionExceptionTests.cs:line 420
   at System.ComponentModel.Composition.CompositionExceptionTests.&lt;Message_ShouldFormatCountOfRootCausesUsingTheCurrentCulture&gt;b__31_0() in /_/src/System.ComponentModel.Composition/tests/System/ComponentModel/Composition/CompositionExceptionTests.cs:line 383
--- End of stack trace from previous location where exception was thrown ---
   at Xunit.ConsoleClient.RemoteExecutor.Execute(String[] args)
   at Xunit.ConsoleClient.ConsoleRunner.EntryPoint(String[] args)
   at Xunit.ConsoleClient.Program.Main(String[] args)
    System.ComponentModel.Composition.CompositionExceptionTests.Message_ShouldFormatCountOfRootCausesUsingTheCurrentCulture [FAIL]
      Microsoft.DotNet.RemoteExecutor.RemoteExecutionException : Remote process failed with an unhandled exception.
      Stack Trace:
        
        Child exception:
          Xunit.Sdk.TrueException: Assert.True() Failure
        Expected: True
        Actual:   False
        /_/src/System.ComponentModel.Composition/tests/System/ComponentModel/Composition/CompositionExceptionTests.cs(420,0): at System.ComponentModel.Composition.CompositionExceptionTests.AssertMessage(CompositionException exception, Int32 rootCauseCount, CultureInfo culture)
        /_/src/System.ComponentModel.Composition/tests/System/ComponentModel/Composition/CompositionExceptionTests.cs(383,0): at System.ComponentModel.Composition.CompositionExceptionTests.&lt;Message_ShouldFormatCountOfRootCausesUsingTheCurrentCulture&gt;b__31_0()
        
        Child process:
          System.ComponentModel.Composition.Tests, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51 System.ComponentModel.Composition.CompositionExceptionTests Int32 &lt;Message_ShouldFormatCountOfRootCausesUsingTheCurrentCulture&gt;b__31_0()
        
        
  Finished:    System.ComponentModel.Composition.Tests
```</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40898</IssueID>
    <RepoID>1</RepoID>
    <Title>Normalizing casing for property names in JsonException.Path helps deserialization performance</Title>
    <Description>Creating this issue to discuss feasibility of getting this into 5.0. cc @pranavkm @ahsonkhan @rynowak 

If we remove support for using the literal JSON value for `JsonException.Path` we can get a ~5% end-to-end performance improvement during deserialization when using `options.CaseInsensitivePropertyNames=true` (which is the default for ASP.NET). Allocations are also reduced by ~30% (depends on property name lengths).

_UPDATE: recent measurements for a very simple case show up to 30% improvement, not 5%. Todo: need to quantify this here._

This means that when case insensitivity is on, the value of the `JsonException.Path` property may not exactly match the property name **casing** in the JSON (the value is always correct; just the casing can be off).

There are three ways the JSON property name is specified:
1) The object's CLR property reflected name (default case).
2) The value from `[JsonPropertyName]` attribute applied to a property.
3) The naming policy from `options.PropertyNamingPolicy` such as camel-casing.

So currently if there exists JSON like `{"myProp:1"}` against a property named `MyProp` (either through case 1, 2 or 3 above) then when case-insensitivity is on the `JsonException.Path` will be `"$.myProp"`.

However, using the raw JSON value comes at a cost for case insensitivity. Instead if we just use the value obtained from case 1, 2 or 3 (and not the actual JSON) then we get the perf improvement -- e.g. path would be `"$.MyProp"` instead of  `{"myProp:1"}` (again this would only occur when case insensitivity is on and does not match the actual property name).

```
Current:
|                   Method |     Mean |    Error |   StdDev |   Median |      Min |      Max | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |
|------------------------- |---------:|---------:|---------:|---------:|---------:|---------:|------------:|------------:|------------:|--------------------:|
|    DeserializeFromString | 662.8 ns | 3.631 ns | 3.218 ns | 662.8 ns | 658.7 ns | 670.2 ns |      0.0611 |           - |           - |               384 B |
| DeserializeFromUtf8Bytes | 614.0 ns | 2.882 ns | 2.696 ns | 614.6 ns | 609.1 ns | 618.9 ns |      0.0420 |           - |           - |               272 B |
|    DeserializeFromStream | 915.3 ns | 3.769 ns | 3.341 ns | 916.6 ns | 908.8 ns | 918.4 ns |      0.0513 |           - |           - |               344 B |

After:
|    DeserializeFromString | 637.5 ns | 3.702 ns | 3.463 ns | 636.6 ns | 632.2 ns | 643.7 ns |      0.0436 |           - |           - |               280 B |
| DeserializeFromUtf8Bytes | 586.1 ns | 4.028 ns | 3.768 ns | 585.3 ns | 579.7 ns | 592.6 ns |      0.0259 |           - |           - |               168 B |
|    DeserializeFromStream | 913.7 ns | 4.604 ns | 4.307 ns | 912.7 ns | 907.1 ns | 921.5 ns |      0.0369 |           - |           - |               240 B |
```</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40897</IssueID>
    <RepoID>1</RepoID>
    <Title>Make NameValueCollection.HasKeys() method virtual and override it in WebHeaderCollection</Title>
    <Description>This suggestion is order to provide a fix for #33628. 

**AllKeys** and **Keys** are overridden in WebHeaderCollection, but we are unable to change behavior of related **HasKeys()** method. This causes inconsistency described in aforementioned bug report.

**InternalHasKeys()**, as it's currently defined, seems to be redundant as well.

### Current
```cs
public class NameValueCollection : NameObjectCollectionBase
{
    public bool HasKeys();
    internal virtual bool InternalHasKeys();
}
public class WebHeaderCollection : NameValueCollection, ISerializable
{
}
```
### Proposed
```cs
public class NameValueCollection : NameObjectCollectionBase
{
    public virtual bool HasKeys();
}
public class WebHeaderCollection : NameValueCollection, ISerializable
{
    public override bool HasKeys();
}
```</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>12/09/2019</ClosedDate>
  </Issue>
</Issues>