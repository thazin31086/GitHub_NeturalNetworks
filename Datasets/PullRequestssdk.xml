<PullRequests>

  <PullRequest>
    <IssueID>13275</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Adding DOTNET_NOLOGO flag for first run experience</Title>
    <Description>Fixes dotnet/sdk#3828</Description>
    <CreatedDate>09/03/2020</CreatedDate>
    <ClosedDate>10/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>13275</PullRequestID>
        <IssueID>6609</IssueID>
        <Title>dotnet publish does not include wwwroot folder if it does not exist before the process starts</Title>
        <Description>## Steps to reproduce

`dotnet publish`
## Expected  behavior

A package is created that includes the `wwwroot` contents.
## Actual behavior

As the `wwwroot` is created as part of the `prepublish` script, the process seems to skip over this folder completely. If I create the `wwwroot` folder on the filesystem with no files in it, then run `dotnet publish`, it does publish the folder. This is a problem for our CI systems.
## Environment data

`dotnet --info` output:
.NET Command Line Tools (1.0.0-preview2-003121)

Product Information:
 Version:            1.0.0-preview2-003121
 Commit SHA-1 hash:  1e9d529bc5

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.10586
 OS Platform: Windows
 RID:         win10-x64
</Description>
        <CreatedDate>11/07/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>13123</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>flcdrg</FixedByID>
    <Title>Add switch to enable searching global path for existing SDK version</Title>
    <Description>Implements #11058</Description>
    <CreatedDate>26/11/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>13123</PullRequestID>
        <IssueID>10192</IssueID>
        <Title>dotnet-install.ps1 installs locally even when same version is already installed globally</Title>
        <Description>## Steps to reproduce

1. On a machine that already has 2.2.101 SDK installed
2. `.\dotnet-install.ps1 -Version 2.2.101`

## Expected behavior

Do nothing. 

Maybe provide a `-Force` parameter so that only when that is given, do you still install the version

## Actual behavior

Version is installed into `c:\users\USERNAME\AppData\Local\Microsoft\dotnet`, even if it was already installed in `C:\Program Files\dotnet\sdk`

## Environment data
`dotnet --info` output:

``




</Description>
        <CreatedDate>03/04/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Install-Script</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12512</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>singhsarab</FixedByID>
    <Title>Converging test and vstest verb</Title>
    <Description>Adding the code to make sure we are able to run dll/exe using the dotnet test command.
Convert the given args to vstest parsable args and invoke vstest.

Fixes: microsoft/vstest#1453

![image](https://user-images.githubusercontent.com/18569990/64772127-b6690c00-d56d-11e9-84ed-bec4a78dd743.png)
</Description>
    <CreatedDate>06/09/2019</CreatedDate>
    <ClosedDate>14/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>12512</PullRequestID>
        <IssueID>5131</IssueID>
        <Title>Integration of xunit tests (xprojs) with visual studio online (TFS)</Title>
        <Description>Hi Team,
I don't see option to configure xunit unit tests for MVC 6 projects (xproj extension) in visual studio online.
I also couldn't find any relevant article explaining the same.
Can you please help me configure unit tests in vso?

![image](https://cloud.githubusercontent.com/assets/8371740/13105837/1d470918-d58b-11e5-93ab-16162159d04b.png)
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12497</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Add missing host options to dotnet help.</Title>
    <Description>This commit adds help text for the `--depsfile` and `--runtimeconfig` host
options to `dotnet help` and `dotnet --help`.

Fixes #12444.
</Description>
    <CreatedDate>05/09/2019</CreatedDate>
    <ClosedDate>05/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>12497</PullRequestID>
        <IssueID>10461</IssueID>
        <Title>--depsfile and --runtimeconfig runtime options missing from dotnet --help</Title>
        <Description>## Steps to reproduce
dotnet --help

## Expected  behavior
It would list those two options (`--depsfile` and `--runtimeconfig`) under runtime-options.

## Actual behavior
Those options are not listed.

## Environment data
`dotnet --info` output:

.NET Core SDK (reflecting any global.json):
 Version:   3.0.100-preview9-014004
 Commit:    8e7ef240a5

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.18362
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\3.0.100-preview9-014004\

Host (useful for support):
  Version: 3.0.0-preview9-19423-09
  Commit:  2be172345a

.NET Core SDKs installed:
  2.1.801 [C:\Program Files\dotnet\sdk]
  2.2.401 [C:\Program Files\dotnet\sdk]
  3.0.100-preview5-011568 [C:\Program Files\dotnet\sdk]
  3.0.100-preview9-014004 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview5-19227-01 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 3.0.0-preview9.19424.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.12 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview5-27626-15 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.0.0-preview5-27626-15 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
  Microsoft.WindowsDesktop.App 3.0.0-preview9-19423-09 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

To install additional .NET Core runtimes or SDKs:
  https://aka.ms/dotnet-download



</Description>
        <CreatedDate>31/08/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12494</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>singhsarab</FixedByID>
    <Title>Converging test and vstest verb</Title>
    <Description>Adding the code to make sure we are able to run dll/exe using the dotnet test command.
Convert the given args to vstest parsable args and invoke vstest.

Fixes: microsoft/vstest#1453</Description>
    <CreatedDate>05/09/2019</CreatedDate>
    <ClosedDate>06/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>12494</PullRequestID>
        <IssueID>5131</IssueID>
        <Title>Integration of xunit tests (xprojs) with visual studio online (TFS)</Title>
        <Description>Hi Team,
I don't see option to configure xunit unit tests for MVC 6 projects (xproj extension) in visual studio online.
I also couldn't find any relevant article explaining the same.
Can you please help me configure unit tests in vso?

![image](https://cloud.githubusercontent.com/assets/8371740/13105837/1d470918-d58b-11e5-93ab-16162159d04b.png)
</Description>
        <CreatedDate>17/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12301</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>vitek-karas</FixedByID>
    <Title>Remove link to non-existing document</Title>
    <Description>Spotted in #12299 </Description>
    <CreatedDate>20/08/2019</CreatedDate>
    <ClosedDate>20/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>12301</PullRequestID>
        <IssueID>10442</IssueID>
        <Title>corehost spec deleted but still referenced</Title>
        <Description>## Steps to reproduce

1. Go to https://github.com/dotnet/cli/blob/master/Documentation/README.md
2. Look in **Specifications** section
3. Click on the **Corehost specification** entry

## Expected  behavior

Either: the Corehost specification should load, or: there should be no **Corehost specification** entry in that list.

## Actual behavior

GitHub's 404 page shows because that document does not exist.

## Environment data
This is a documentation issue in this repo, so there is no environment per se. The problem is visible currently on `master`, and at the tag `v3.0.100-preview8.19406.4`

## Notes

The `corehost.md` file was deleted by https://github.com/dotnet/core-setup/pull/5156 (and although there are two commits in there, one deleting this, and one affecting another file, GitHub shows the overall effect of the PR to be only deleting this file).

@vitek-karas noted that the contents of the document were no longer accurate, so I guess removing the reference from the readme is the right thing to do? But this does raise the question: where is the relevant information now documented? This file used to document the Assembly Resolution process. (I was looking for detail on this when I discovered that this file had been deleted.) There seem to be significant differences between .NET Fx and Core here, and it's not clear that the docs in, say, https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.loadfrom?view=netcore-3.0 actually apply in .NET Core.

(In particular, that says that the load-from context "allows dependencies on that path to be found and loaded because the path information is maintained by the context". As far as I can tell, using `Assembly.LoadFrom` in .NET Core 3.0 to load a DLL from somewhere other than the app folder does not enable dependencies to be picked up from that same folder. I think you need to use an `AssemblyLoadContext`, and that there's no reliable way to do this in .NET Standard 2.0 that will work on both .NET Core and .NET Framework, but I've not managed to find definitive documentation for exactly how .NET Core's assembly resolution process is different from .NET Framework's.)</Description>
        <CreatedDate>20/08/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>12149</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Cosebdd</FixedByID>
    <Title>Solution items are now considered when removing empty folders</Title>
    <Description>Solution items are now considered when removing empty folders. A test added to check whether the logic is maintained. Fixes #10669

https://github.com/dotnet/cli/issues/10669
</Description>
    <CreatedDate>06/08/2019</CreatedDate>
    <ClosedDate>07/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>12149</PullRequestID>
        <IssueID>10080</IssueID>
        <Title>dotnet sln remove puts all nested not empty solution folders into root folder</Title>
        <Description>## Steps to reproduce
1. Create blank solution
2. Create solution folders and any file like this: \NewFolder1\NewFolder2\text.txt
3. Create any project inside the solution
4. Remove project using the "dotnet sln remove" command

## Expected  behavior
File is located in the \NewFolder1\NewFolder2 folder

## Actual behavior
File is located in the \NewFolder2 folder

## Environment data
`dotnet --info` output:
.NET Core SDK (reflecting any global.json):
 Version:   2.1.500
 Commit:    b68b931422

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.500\

Host (useful for support):
  Version: 2.1.6
  Commit:  3f4f8eebd8

.NET Core SDKs installed:
  2.1.202 [C:\Program Files\dotnet\sdk]
  2.1.302 [C:\Program Files\dotnet\sdk]
  2.1.400 [C:\Program Files\dotnet\sdk]
  2.1.402 [C:\Program Files\dotnet\sdk]
  2.1.403 [C:\Program Files\dotnet\sdk]
  2.1.500 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.0.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.6 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
</Description>
        <CreatedDate>29/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>good first issue</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11287</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsychin</FixedByID>
    <Title>Update warning message for dotnet tool update and uninstall</Title>
    <Description>Fixes #9650
Changed warning message when tool is not found to include more information about package Ids and tool names.</Description>
    <CreatedDate>05/05/2019</CreatedDate>
    <ClosedDate>06/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11287</PullRequestID>
        <IssueID>9587</IssueID>
        <Title>Change warning message on `dotnet tool update` and `dotnet tool uninstall`</Title>
        <Description>## Steps to reproduce

``

Please offer feedback on the wording of this message. 

## Environment data
`dotnet --info` output:

.NET Core SDK (reflecting any global.json):
 Version:   2.1.301
 Commit:    59524873d6

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.13
 OS Platform: Darwin
 RID:         osx.10.13-x64
 Base Path:   /usr/local/share/dotnet/sdk/2.1.301/

Host (useful for support):
  Version: 2.1.1
  Commit:  6985b9f684





</Description>
        <CreatedDate>12/07/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>good first issue</Label>
          <Label>help wanted</Label>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11286</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brettfo</FixedByID>
    <Title>[release/2.2.3xx] update F# for LOC changes</Title>
    <Description>LOC changes from Microsoft/visualfsharp#6676.  Waiting on [VS insertion](https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/179427?_a=overview).</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>07/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11286</PullRequestID>
        <IssueID>6676</IssueID>
        <Title>Updating MSBuild to 15.3.0-preview-000246-05 to match VS.</Title>
        <Description>@dotnet/dotnet-cli</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>24/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11285</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brettfo</FixedByID>
    <Title>[release/2.1.7xx] update F# for LOC changes</Title>
    <Description>LOC changes from Microsoft/visualfsharp#6676.  Waiting on [VS insertion](https://dev.azure.com/devdiv/DevDiv/_git/VS/pullrequest/179427?_a=overview).</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>07/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11285</PullRequestID>
        <IssueID>6676</IssueID>
        <Title>Updating MSBuild to 15.3.0-preview-000246-05 to match VS.</Title>
        <Description>@dotnet/dotnet-cli</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>24/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11233</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>vitek-karas</FixedByID>
    <Title>Add --roll-forward command line usage</Title>
    <Description>The new roll forward feature introduces a new command line option `--roll-forward`. It's implemented by the host, but the command line help is sometimes shown from the code in CLI repo.

The feature is added in dotnet/core-setup#5891

This change modifies the command line help to show `--roll-forward`.
It also removes the `--roll-forward-on-no-candidate-fx`. This setting is still supported, but the intent is to obsolete it. The new `--roll-forward` fully replaces it.

Fixes #11213 </Description>
    <CreatedDate>23/04/2019</CreatedDate>
    <ClosedDate>23/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11233</PullRequestID>
        <IssueID>5891</IssueID>
        <Title>Don't try to uplift when we find a * version in a dependency.</Title>
        <Description>Fixes https://github.com/dotnet/cli/issues/5890

@piotrpMSFT @jgoshi @jonsequitur </Description>
        <CreatedDate>02/03/2017</CreatedDate>
        <ClosedDate>23/03/2017</ClosedDate>
        <Labels>
          <Label>Pending Shiproom Approval</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11233</PullRequestID>
        <IssueID>10232</IssueID>
        <Title>Add command line usage help for the new --roll-forward option</Title>
        <Description>The new roll forward feature introduces a new command line option `--roll-forward`. It's implemented by the host, but the command line help is sometimes shown from the code in CLI repo.

The feature is added in dotnet/core-setup#5891


</Description>
        <CreatedDate>19/04/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Area: CommandLine</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11187</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Revert "Update FSharp compiler to 10.4.3" (2.1.7xx)</Title>
    <Description>Reverts dotnet/cli#11181

The F# change was not approved to go into VS so must be reverted from CLI</Description>
    <CreatedDate>17/04/2019</CreatedDate>
    <ClosedDate>17/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11187</PullRequestID>
        <IssueID>11181</IssueID>
        <Title>Update FSharp compiler to 10.4.3</Title>
        <Description>Update FSharp compiler to 10.4.3</Description>
        <CreatedDate>17/04/2019</CreatedDate>
        <ClosedDate>17/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11186</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Revert "Update FSharp Compiler to 10.4.3" (2.2.3xx)</Title>
    <Description>Reverts dotnet/cli#11182

The F# change was not approved into VS, so removing it from CLI</Description>
    <CreatedDate>17/04/2019</CreatedDate>
    <ClosedDate>17/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>11186</PullRequestID>
        <IssueID>11182</IssueID>
        <Title>Update FSharp Compiler to 10.4.3</Title>
        <CreatedDate>17/04/2019</CreatedDate>
        <ClosedDate>17/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10758</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update aspnet, aspnet, coresetup to rtm-35537, rtm-35537, 2.1.0, respectively (release/2.2.1xx)</Title>
    <Description>Dependency updates from #10756, plus updating latest patch versions.</Description>
    <CreatedDate>12/02/2019</CreatedDate>
    <ClosedDate>12/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10758</PullRequestID>
        <IssueID>10756</IssueID>
        <Title>Update aspnet, aspnet, coresetup to rtm-35537, rtm-35537, 2.1.0, respectively (release/2.2.1xx)</Title>
        <Description>/cc @dotnet/dotnet-cli</Description>
        <CreatedDate>12/02/2019</CreatedDate>
        <ClosedDate>12/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10733</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix typo: s/Interective/Interactive/</Title>
    <Description>NOTE: I will backport this to release/2.1.6xx along with the corresponding loc handback

Fix #10728 
</Description>
    <CreatedDate>08/02/2019</CreatedDate>
    <ClosedDate>09/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10733</PullRequestID>
        <IssueID>10102</IssueID>
        <Title>fsi help is misspelled</Title>
        <Description>## Steps to reproduce

`dotnet --help`

## Expected  behavior

fsi help is spelled correctly

## Actual behavior

fsi help is misspelled


``

s/Interective/Interactive/

@KevinRansom 


</Description>
        <CreatedDate>07/02/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10729</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Remove skip first run flag</Title>
    <Description>fix #10364

Replace one big flag with DOTNET_ADD_GLOBAL_TOOLS_TO_PATH and DOTNET_USE_SHORT_FIRST_RUN_MESSAGE</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>27/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10729</PullRequestID>
        <IssueID>9945</IssueID>
        <Title>Remove flag `DOTNET_SKIP_FIRST_TIME_EXPERIENCE`</Title>
        <Description>Since LZMA cache expansion is no longer needed. The only thing `DOTNET_SKIP_FIRST_TIME_EXPERIENCE` controls is aspnet certification. But aspnet certification also has a separate flag `DOTNET_GENERATE_ASPNET_CERTIFICATE`.</Description>
        <CreatedDate>19/11/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10720</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Implement child process reaping. </Title>
    <Description>This PR implements child process reaping in the event of termination
of a CLI command.

On Windows, the child process is added to a job object that is set to
terminate the child (and its tree) upon the termination of the parent
dotnet process.  On Windows 7 and Server 2008, the dotnet process cannot
already be associated with a job object for the reaping to occur.  On
later Windows versions, a nested job will be created so the reaping will
still occur.  After the child process exits, the job object is closed
without terminating the remaining processes in the job; this allows for
the child process to spawn additional processes that outlive the child.

On POSIX operating systems, a SIGTERM is intercepted and forwarded on to
the child process only. Like the SIGINT forwarding, it is up to the
child process to decide what to do with the SIGTERM signal (the default
is to abort).

Additionally, this fix further expands upon the previous fix to `dotnet
run` to properly handle SIGINT so that all child processes now benefit
from the fixed behavior.  This means MSBuild-forwarding commands like
`dotnet build` now behave as if MSBuild were directly being executed with
respect to Ctrl-C handling.

Fixes #7426.</Description>
    <CreatedDate>07/02/2019</CreatedDate>
    <ClosedDate>08/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10720</PullRequestID>
        <IssueID>8610</IssueID>
        <Title>terminating `dotnet run` doesn't terminate child</Title>
        <Description>## Steps to reproduce

``





</Description>
        <CreatedDate>12/08/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10712</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Localize MSBuild SDK resolver</Title>
    <Description>Fix #9553</Description>
    <CreatedDate>05/02/2019</CreatedDate>
    <ClosedDate>06/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10712</PullRequestID>
        <IssueID>9538</IssueID>
        <Title>MSBuild SDK resolver error messages are not localized</Title>
        <Description>
        </Description>
        <CreatedDate>25/06/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Resolver</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10654</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mayankbansal018</FixedByID>
    <Title>TestPlatform insertion 16.0-preview-20190124-02</Title>
    <Description>Testplatform insertion Rel Notes: https://github.com/Microsoft/vstest-docs/blob/master/docs/releases.md#1600-preview-20190124-02</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>25/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10654</PullRequestID>
        <IssueID>5218</IssueID>
        <Title>Could not load file or assembly 'dotnet.EXE.dll'</Title>
        <Description>I downloaded net cli binaries and executed dotnet restore within folder which contains asp.net core project. Some packages were restored and several errors about incompativlity were displayed.
Then I tried execute dotnet new within empty directory and got error
`Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'dotnet.EXE.dll' or one of its dependencies.`
I tried to uninstall and reinstall (and also repair) but error still occurs.

version 1.0.0.001540
</Description>
        <CreatedDate>26/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10651</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Add --interactive to dotnet add reference</Title>
    <Description>part of #10529 </Description>
    <CreatedDate>23/01/2019</CreatedDate>
    <ClosedDate>31/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10651</PullRequestID>
        <IssueID>10026</IssueID>
        <Title>--interactive on most of the commands</Title>
        <Description>1. If a project require --interactive to auth, it cannot restore without `--interactive` and many command require restore to function

2. Custom MSBuild SDK also require `--interactive` if it is from a private feed.

That results most of the CLI command need `--interactive` option

- [x] add package 
- [x] add reference    -- Microsoft.Build.Evaluation  (in pr)
- [x] build 
- [x] clean
- [x] list package     -- need nuget change https://github.com/NuGet/Home/issues/7727
- [x] list reference    -- Microsoft.Build.Evaluation, but work without auth 
- [ ] new               https://github.com/dotnet/templating/issues/1747 
- [x] pack             
- [x] publish           
- [x] remove  package -- need nuget change https://github.com/NuGet/Home/issues/7727
- [x] remove  reference  -- Microsoft.Build.Evaluation, but work without auth 
- [x] restore           
- [x] run               Quiet (in PR)
- [x] test              Quiet (in PR)
- [x] tool</Description>
        <CreatedDate>01/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10650</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Add --interactive to dotnet run and test</Title>
    <Description>These 2 verb have verbosity set to quiet. And we need to change it to minimal during --interface
to show the nuget plugin guide

part of #10529 </Description>
    <CreatedDate>23/01/2019</CreatedDate>
    <ClosedDate>31/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10650</PullRequestID>
        <IssueID>10026</IssueID>
        <Title>--interactive on most of the commands</Title>
        <Description>1. If a project require --interactive to auth, it cannot restore without `--interactive` and many command require restore to function

2. Custom MSBuild SDK also require `--interactive` if it is from a private feed.

That results most of the CLI command need `--interactive` option

- [x] add package 
- [x] add reference    -- Microsoft.Build.Evaluation  (in pr)
- [x] build 
- [x] clean
- [x] list package     -- need nuget change https://github.com/NuGet/Home/issues/7727
- [x] list reference    -- Microsoft.Build.Evaluation, but work without auth 
- [ ] new               https://github.com/dotnet/templating/issues/1747 
- [x] pack             
- [x] publish           
- [x] remove  package -- need nuget change https://github.com/NuGet/Home/issues/7727
- [x] remove  reference  -- Microsoft.Build.Evaluation, but work without auth 
- [x] restore           
- [x] run               Quiet (in PR)
- [x] test              Quiet (in PR)
- [x] tool</Description>
        <CreatedDate>01/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10646</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mklement0</FixedByID>
    <Title>WIP: Makes dotnet-install.ps1 x-platform</Title>
    <Description>Adds cross-edition and cross-platform support to the script, addresses #8278.</Description>
    <CreatedDate>22/01/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10646</PullRequestID>
        <IssueID>8963</IssueID>
        <Title>dotnet-install.ps1 should be supported on unix</Title>
        <Description>## Steps to reproduce
Run https://dot.net/v1/dotnet-install.ps1 script on pwsh on linux or macOS

## Expected  behavior
Script should work

## Actual behavior
``

## Environment data
`dotnet --info` output:

n/a


I should admit that use case is pretty narrow, but it could be useful for cross-platform projects that are already utilized PowerShell.
</Description>
        <CreatedDate>21/12/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Install-Script</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10620</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>sdmaclea</FixedByID>
    <Title>Update FXVersion to use SemVer 2.0.0</Title>
    <Description>Update FXVersion to use SemVer 2.0.0
Extend and fix tests

Fixes #10608</Description>
    <CreatedDate>16/01/2019</CreatedDate>
    <ClosedDate>21/03/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10620</PullRequestID>
        <IssueID>10054</IssueID>
        <Title>Support SemVer2.0.0 for SDK resolution</Title>
        <Description>Arcade has started the transition to using SemVer2.0.0 versions.

Current SDK resolution does not yet support SemVer2.0.0

https://github.com/dotnet/cli/blob/f38d1472d05573158f52ec30f5163fe0316ede7b/src/Microsoft.DotNet.MSBuildSdkResolver/FXVersion.cs#L6-L9

See also dotnet/core-setup#4952 &amp; dotnet/core-setup#4953</Description>
        <CreatedDate>15/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10520</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>johnbeisner</FixedByID>
    <Title>Repair the Absolutepath; part 2</Title>
    <Description>Addresses: #10293

PR: https://github.com/dotnet/cli/pull/10512 was not complete
 
Change:
Do not cast 'Source' to a variable type - allow usage to do the typing; variable name is now: "Source" not: "Uri".

@jerickmsft
</Description>
    <CreatedDate>28/12/2018</CreatedDate>
    <ClosedDate>28/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10520</PullRequestID>
        <IssueID>9914</IssueID>
        <Title>dotnet-install.ps1 doesn't work with relative path when installing from file system</Title>
        <Description>## Steps to reproduce
1. Download .NET Core Runtime binaries.
2. Put the binaries into ./Runtime/&lt;version&gt; directory
3. Try to install using dotnet-install.ps1:
`.\dotnet-install.ps1 -Runtime dotnet -NoCdn -UncachedFeed "./" -Version &lt;version&gt;`

## Expected  behavior
The .NET Core Runtime shoud be installed correctly from the prefetched binaries if the value for `-UncachedFeed` argument is a relative path (as it does work for absolute paths).

## Actual behavior
It doesn't work.

The output:
``

## Suggestions
The reason for this behavior is the line 473:
`Copy-Item $Uri.AbsolutePath $OutPath`
The value of `$Uri.AbsolutePath` is `null` for relative paths.





</Description>
        <CreatedDate>07/11/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10491</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>vitek-karas</FixedByID>
    <Title>Improve --roll-forward-on-no-candidate-fx usage text.</Title>
    <Description>Make it explicit that the --roll-forward-on-no-candidate-fx options requires a value. Modify the description since the argument sets the behavior (it doesn't just enable it, it can also disable and so on).

Related to dotnet/core-setup#4873</Description>
    <CreatedDate>18/12/2018</CreatedDate>
    <ClosedDate>28/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10491</PullRequestID>
        <IssueID>4873</IssueID>
        <Title>Update branding string to 1.0.3</Title>
        <Description>Update branding string to 1.0.3

/cc @leecow </Description>
        <CreatedDate>30/11/2016</CreatedDate>
        <ClosedDate>30/11/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10488</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>flcdrg</FixedByID>
    <Title>dotnet-install.ps1 - Only modify PATH if necessary</Title>
    <Description>Implements #10487

</Description>
    <CreatedDate>18/12/2018</CreatedDate>
    <ClosedDate>28/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10488</PullRequestID>
        <IssueID>10005</IssueID>
        <Title>dotnet-install.ps1 always modifies PATH</Title>
        <Description>## Steps to reproduce

Run dotnet-install.ps1 more than once

## Expected  behavior

Only one instance of "C:\Users\David\AppData\Local\Microsoft\dotnet" exists in PATH

## Actual behavior

PATH contains multiple references to the same directory







</Description>
        <CreatedDate>18/12/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10449</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Update roslyn</Title>
    <Description>Matching dotnet/toolset#53 for 2.1.6xx
</Description>
    <CreatedDate>07/12/2018</CreatedDate>
    <ClosedDate>07/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10449</PullRequestID>
        <IssueID>4322</IssueID>
        <Title>Infer RID from running OS/Platform</Title>
        <Description>We should infer the default RID based on the running OS/bitness. This affects restore and publish
</Description>
        <CreatedDate>16/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10410</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jkotas</FixedByID>
    <Title>Replace private System.AppDomain reflection with a regular call</Title>
    <Description>Fixes #10399
</Description>
    <CreatedDate>29/11/2018</CreatedDate>
    <ClosedDate>29/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>10410</PullRequestID>
        <IssueID>9960</IssueID>
        <Title>dotnet new console failing with System.ArgumentNullException using a custom coreclr</Title>
        <Description>## Steps to reproduce

1. Use dotnet-install.ps1 to pull down the latest concurrent dotnet
2. Pull down dotnet/coreclr
3. build.cmd release x64 skiptests
4. Copy coreclr.dll, clrjit.dll, mscordaccore.dll, mscordbi.dll, sos.dll, sos.NETCore.dll, clretwrc.dll, System.Private.CoreLib.dll, mscorrc.debug.dll and mscorrc.dll into the shared framework of the dotnet install you got in step 1.
5. run dotnet.exe new console

## Expected  behavior

dotnet creates a hello world cs file and csproj

## Actual behavior
Dotnet fails with the following output:

``

This failing both for one of our perf scenarios and for our PGO and IBC data collection jobs, and has been failing since Nov 24, 2018 7:00 AM</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9475</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>AndyGerlicher</FixedByID>
    <Title>MSBuild 15.8.101</Title>
    <Description>This would be in favor of #9468, but I left the old one open since it seemed to have issues that I'm not clear of the cause yet.

This insertion contains https://github.com/Microsoft/msbuild/pull/3376 which revs the version of `System.Collections.Immutable` and `System.Reflection.Metadata` to `1.5.0` and `1.6.0`. This is part of a large coordinated change for all of VS.</Description>
    <CreatedDate>13/06/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9475</PullRequestID>
        <IssueID>9468</IssueID>
        <Title>MSBuild 15.8.98</Title>
        <CreatedDate>12/06/2018</CreatedDate>
        <ClosedDate>19/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9460</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Implement `mode` option for `dotnet publish`.</Title>
    <Description>This PR implements a `mode` option that can control how an application is
published with the `dotnet publish` command.

There are three supported modes:

* `self-contained`: publishes a self-contained application (same as
--self-contained).
* `fx-dependent`: publishes a framework-dependent application (with an
application host when a runtime is specified).
* `fx-dependent-no-exe`: publishes a framework-dependent application without an
application host.

The default when publishing without a runtime specified is
`fx-dependent-no-exe`.

The default when publishing with a runtime specified is `self-contained`.

`fx-dependent` requires netcoreapp2.1 or later when a runtime is specified.

The `--self-contained` option is still supported, but is now hidden so that
users will be encouraged to move to the `--mode` option.

Fixes #6237.</Description>
    <CreatedDate>11/06/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9460</PullRequestID>
        <IssueID>8065</IssueID>
        <Title>dotnet new console, publish, makes a dll not an exe</Title>
        <Description>``

Shouldn't I have a console .exe? How do I run this dll?</Description>
        <CreatedDate>04/04/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9424</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>singhsarab</FixedByID>
    <Title>Testplatform 15.8.0-preview-20180605-02</Title>
    <Description>Inserting Testplatform 15.8.0-preview-20180605-02 package in dotnet cli

This has already been inserted in VS [15.8.0-preview-20180605-02 Insertion PR](https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/126257?_a=overview)
Here are the [Release Notes](https://github.com/Microsoft/vstest-docs/blob/master/docs/releases.md#1580-preview-20180605-02)

Please push these changes at the earliest.
</Description>
    <CreatedDate>06/06/2018</CreatedDate>
    <ClosedDate>06/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9424</PullRequestID>
        <IssueID>5204</IssueID>
        <Title>NO_PUBLICKEY B02C46DF417A0893</Title>
        <Description>sudo apt-key adv --keyserver apt-mo.trafficmanager.net --recv-keys 417A0893

gpgkeys: HTTP fetch error 7: couldn't connect: eof
gpg: no valid OpenPGP data found
gpg: Total number processed: 0

Is this changed and so the installation instructions not updated?
</Description>
        <CreatedDate>25/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9399</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>MSBuild 15.8.78 (4xx)</Title>
    <Description>MSBuild 15.8.78

PR #9279 accidentally clobbered a fix for Microsoft/msbuild#3346 pulled in with #3317.

This version of MSBuild is in VS d15.8stg now.

@livarcocc : @YunWeiaa found this failed on master, but it should be failing on 4xx, too. Do you want the change merged to both (here to 4xx, #9398 to master) or just let codeflow take it from here to master?</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>04/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9399</PullRequestID>
        <IssueID>9279</IssueID>
        <Title>MSBuild 15.8.61</Title>
        <Description>This change removes our NuGet resolver in favor of an xml file manifest (in `Microsoft.Build.Runtime`) pointing to `Microsoft.Build.NuGetSdkResolver.dll` (next to `MSBuild.dll`) which is included with NuGet now. Removes the only direct compile-time dependency MSBuild had on NuGet.</Description>
        <CreatedDate>15/05/2018</CreatedDate>
        <ClosedDate>22/05/2018</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9399</PullRequestID>
        <IssueID>3346</IssueID>
        <Title>fixes #2408 stop using corehost to activate projectdependencycommands</Title>
        <Description>cc @schellap @eerhardt 

fixes #2408 
</Description>
        <CreatedDate>02/06/2016</CreatedDate>
        <ClosedDate>02/06/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9399</PullRequestID>
        <IssueID>6291</IssueID>
        <Title>OSX installer pkg for preview2-00291 SDK is corrupted</Title>
        <Description>## Steps to reproduce

Download https://dotnetcli.blob.core.windows.net/dotnet/preview/Installers/Latest/dotnet-dev-osx-x64.latest.pkg and install. Follow the installation steps to the end.
## Expected  behavior

The .NET CLI SDK bits are installed.
## Actual behavior

Error: "Installation failed. The installer can't locate the data it needs to install the software"
Note the pkg is only 8.8mb
## Environment data

OSX El Capitan 10.11.4
</Description>
        <CreatedDate>01/06/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9399</PullRequestID>
        <IssueID>9398</IssueID>
        <Title>MSBuild 15.8.78</Title>
        <Description>MSBuild 15.8.78

PR #9279 accidentally clobbered a fix for Microsoft/msbuild#3346 pulled in with #3317.

This version of MSBuild is in VS d15.8stg now.</Description>
        <CreatedDate>01/06/2018</CreatedDate>
        <ClosedDate>04/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9398</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>MSBuild 15.8.78</Title>
    <Description>MSBuild 15.8.78

PR #9279 accidentally clobbered a fix for Microsoft/msbuild#3346 pulled in with #3317.

This version of MSBuild is in VS d15.8stg now.</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>04/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9398</PullRequestID>
        <IssueID>9279</IssueID>
        <Title>MSBuild 15.8.61</Title>
        <Description>This change removes our NuGet resolver in favor of an xml file manifest (in `Microsoft.Build.Runtime`) pointing to `Microsoft.Build.NuGetSdkResolver.dll` (next to `MSBuild.dll`) which is included with NuGet now. Removes the only direct compile-time dependency MSBuild had on NuGet.</Description>
        <CreatedDate>15/05/2018</CreatedDate>
        <ClosedDate>22/05/2018</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9398</PullRequestID>
        <IssueID>3346</IssueID>
        <Title>fixes #2408 stop using corehost to activate projectdependencycommands</Title>
        <Description>cc @schellap @eerhardt 

fixes #2408 
</Description>
        <CreatedDate>02/06/2016</CreatedDate>
        <ClosedDate>02/06/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9398</PullRequestID>
        <IssueID>6291</IssueID>
        <Title>OSX installer pkg for preview2-00291 SDK is corrupted</Title>
        <Description>## Steps to reproduce

Download https://dotnetcli.blob.core.windows.net/dotnet/preview/Installers/Latest/dotnet-dev-osx-x64.latest.pkg and install. Follow the installation steps to the end.
## Expected  behavior

The .NET CLI SDK bits are installed.
## Actual behavior

Error: "Installation failed. The installer can't locate the data it needs to install the software"
Note the pkg is only 8.8mb
## Environment data

OSX El Capitan 10.11.4
</Description>
        <CreatedDate>01/06/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9394</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Revert "Fix MSBuild invocation to quote property option values."</Title>
    <Description>This reverts commit f9b939fe8996210666f4740d16e997081023bb23.

That fix caused a regression that prevented a single `/property` option to
define multiple properties using the `/property:First=foo;Second=bar` syntax.

Users that want literal semicolons in the property values should use escaped
quotes around the property value, e.g. `/property:Prop='"foo;bar;baz"'`.

Fixes #9369.</Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9394</PullRequestID>
        <IssueID>9435</IssueID>
        <Title>Breaking change to passing multiple properties as /p:P1=V1;P2=V2</Title>
        <Description>I believe this was changed by https://github.com/dotnet/cli/pull/9153

## Steps to reproduce

1. Create test.proj with the following content
``






</Description>
        <CreatedDate>30/05/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9163</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>natemcmaster</FixedByID>
    <Title>Include aspnetcore in the linux-arm build,</Title>
    <Description>Resolves #9162 

Include aspnetcore in linux-arm, but not linux-arm64 or windows ARM builds.</Description>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>30/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9163</PullRequestID>
        <IssueID>9329</IssueID>
        <Title>dotnet-sdk for linux-arm is missing ASP.NET Core</Title>
        <Description>In RC1, we introduced a linux-arm build of ASP.NET Core, but I failed to update the CLI to bundle this. The latest RC1 builds of the CLI are missing the aspnetcore shared framework altogether. If possible, we should get this runtime bundled for RTM.




</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Blocking-RTM</Label>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9160</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix Razor server shutdown on Windows.</Title>
    <Description>On Windows, the Razor server correctly creates the pid file with
`FileAccess.Write` and `FileOptions.DeleteOnClose`.  This requires a share mode
of `FileShare.Write | FileShare.Delete` to open.  However, the
`dotnet build-server shutdown` command was opening the file with
`FileShare.Read`.  As a result, an `IOException` was being thrown and was not
handled.

This change first opens the file with the appropriate share access and also
properly handles a failure to access or read the contents of the pid file.

Additionally, an integration test was added to test that Razor server shutdown
works as expected.

Fixes #9158.
</Description>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>30/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9160</PullRequestID>
        <IssueID>9328</IssueID>
        <Title>Build-server shutdown doesn't get credentials to delete Razor PID file</Title>
        <Description>## Steps to reproduce
Install latest RC CLI build
In powershell or cmd prompt, run the following:
dotnet new razor
dotnet build
dotnet build-server shutdown

## Expected  behavior
The Razor build server is shutdown and the PID file is deleted

## Actual behavior
Exception is thrown:

PS C:\Users\v-masche\servertests\test3&gt; dotnet build-server shutdown
Shutting down MSBuild server...
Shutting down VB/C# compiler server...
System.IO.IOException: The process cannot access the file 'C:\Users\v-masche\.dotnet\pids\build\rzc-8784' because it is being used by another process.
   at System.IO.FileStream.ValidateFileHandle(SafeFileHandle fileHandle)
   at System.IO.FileStream.CreateFileOpenHandle(FileMode mode, FileShare share, FileOptions options)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share)
   at System.IO.File.OpenRead(String path)
   at Microsoft.Extensions.EnvironmentAbstractions.FileWrapper.OpenRead(String path)
   at Microsoft.DotNet.BuildServer.RazorPidFile.Read(FilePath path, IFileSystem fileSystem)
   at Microsoft.DotNet.BuildServer.BuildServerProvider.EnumerateBuildServers(ServerEnumerationFlags flags)+MoveNext()
   at Microsoft.DotNet.Tools.BuildServer.Shutdown.BuildServerShutdownCommand.StartShutdown()
   at Microsoft.DotNet.Tools.BuildServer.Shutdown.BuildServerShutdownCommand.Execute()
   at Microsoft.DotNet.Cli.DotNetTopLevelCommandBase.RunCommand(String[] args)
   at Microsoft.DotNet.Tools.BuildServer.BuildServerCommand.Run(String[] args)
   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, ITelemetry telemetryClient)
   at Microsoft.DotNet.Cli.Program.Main(String[] args)

## Environment data
`dotnet --info` output:
PS C:\Users\v-masche&gt; dotnet --info
.NET Core SDK (reflecting any global.json):
 Version:   2.1.300-rc1-008669
 Commit:    4db4d9b568

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.16299
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.1.300-rc1-008669\

Host (useful for support):
  Version: 2.1.0-rc1-26425-06
  Commit:  b50a96ee38

.NET Core SDKs installed:
  2.1.300-rc1-008669 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.0-rc1-30676 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.0-rc1-30676 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.0-rc1-26425-06 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]






</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Blocking-RTM</Label>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9153</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix MSBuild invocation to quote property option values.</Title>
    <Description>This PR ensures that any `/property` option's value is surrounded by quotes
to allow MSBuild to properly interpret special characters like semicolons.

Users familiar with MSBuild expect `/property:Name="Value"` to handle
semicolons. However, since `dotnet msbuild` parses the command line first, the
quotes get processed by its command line parser.  This results in
`/property:Name=Value` being passed to MSBuild, which will not parse a "Value"
containing a semicolon correctly.

Since it is safe to always quote the property value for this option, this fix
simply ensures that the value is surrounded by quotes.

This fixes the issue for all commands that forward arguments to MSBuild.

Fixes #7791.</Description>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>27/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9153</PullRequestID>
        <IssueID>8792</IssueID>
        <Title>[build] Passing a property (/property) with multiple values to msbuild isn't working</Title>
        <Description>I need to pass values for [`NoWarn` option](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/nowarn-compiler-option) to C# compiler. Previously with msbuild it was being passed as property:
``




</Description>
        <CreatedDate>09/10/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Parser</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9148</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>AndyGerlicher</FixedByID>
    <Title>MSBuild 15.7.177 (3xx)</Title>
    <Description>This supersedes #9141

Keeping up to date with prodcon.

This isn't critical, but after RTM we'll need to make a commit like this to prep for servicing. See Microsoft/msbuild#3228 for details.</Description>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>03/05/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9148</PullRequestID>
        <IssueID>9141</IssueID>
        <Title>MSBuild 15.7.172 (3xx)</Title>
        <Description>Keeping up to date with prodcon.

This isn't critical, but after RTM we'll need to make a commit like this to prep for servicing. See Microsoft/msbuild#3228 for details.</Description>
        <CreatedDate>25/04/2018</CreatedDate>
        <ClosedDate>26/04/2018</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9148</PullRequestID>
        <IssueID>3228</IssueID>
        <Title>Set DOTNET_CLI_TELEMETRY_PROFILE for CLI Repo builds</Title>
        <Description>Sets the DOTNET_CLI_TELEMETRY_PROFILE to `https://github.com/dotnet/cli;&lt;commit hash&gt;`

This environment variable opts-in the CLI builds to identify themselves in telemetry data. We will now be able to distinguish CLI build-generated telemetry from other telemetry. CLI builds will be identified by the presence of `https://github.com/dotnet/cli`. The commit hash will help us understand how the CLI builds evolved over time.

/cc @livarcocc @brthor @jeffschwMSFT @LakshanF @blackdwarf 
</Description>
        <CreatedDate>25/05/2016</CreatedDate>
        <ClosedDate>25/05/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9147</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>AndyGerlicher</FixedByID>
    <Title>MSBuild 15.7.177 (2xx)</Title>
    <Description>This is based on top of #9133 because that's the version of NuGet we have a compile-time reference to and which will ship with Preview 6. I think it caused an issue last time the assembly version changed.

Internal PR: https://devdiv.visualstudio.com/DevDiv/MSBuild/_git/VS/pullrequest/119072</Description>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>26/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9147</PullRequestID>
        <IssueID>9133</IssueID>
        <Title>Insert NuGet Build 4.7.0-rtm.5148 into cli</Title>
        <Description>Insert NuGet Build 4.7.0-rtm.5148 into cli release/2.1.2xx branch</Description>
        <CreatedDate>24/04/2018</CreatedDate>
        <ClosedDate>26/04/2018</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9141</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>MSBuild 15.7.172 (3xx)</Title>
    <Description>Keeping up to date with prodcon.

This isn't critical, but after RTM we'll need to make a commit like this to prep for servicing. See Microsoft/msbuild#3228 for details.</Description>
    <CreatedDate>25/04/2018</CreatedDate>
    <ClosedDate>26/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9141</PullRequestID>
        <IssueID>3228</IssueID>
        <Title>Set DOTNET_CLI_TELEMETRY_PROFILE for CLI Repo builds</Title>
        <Description>Sets the DOTNET_CLI_TELEMETRY_PROFILE to `https://github.com/dotnet/cli;&lt;commit hash&gt;`

This environment variable opts-in the CLI builds to identify themselves in telemetry data. We will now be able to distinguish CLI build-generated telemetry from other telemetry. CLI builds will be identified by the presence of `https://github.com/dotnet/cli`. The commit hash will help us understand how the CLI builds evolved over time.

/cc @livarcocc @brthor @jeffschwMSFT @LakshanF @blackdwarf 
</Description>
        <CreatedDate>25/05/2016</CreatedDate>
        <ClosedDate>25/05/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9137</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix --source-feed option for tool install and update commands.</Title>
    <Description>Commit 9cc2b7c regressed the `--source-feed`
option so that it no longer accepted relative paths.  Because the option is now
saved to the temp project file, any relative paths specified by the
`--source-feed` option were made relative to the temp project path and not from
the current working directory of where dotnet was run.

The fix is to use `Path.GetFullPath` of the `--source-feed` option, provided
the option specified was not an absolute URI.

Fixes #9132.</Description>
    <CreatedDate>25/04/2018</CreatedDate>
    <ClosedDate>30/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9137</PullRequestID>
        <IssueID>9315</IssueID>
        <Title>dotnet tool install --source-feed isn't relative</Title>
        <Description>## Steps to reproduce

``


## Expected  behavior

I was expecting the NuGet source to realize I wanted it to use: `C:\git\PowerShell\src\powershell-win-core\nupkg`

It uses: `'C:\Users\rlander\AppData\Local\Temp\xrucfdsj.yyf\nupkg`

Fully-qualified path works. I expect to be able to use relative paths.

## Environment data
dotnet --version
2.1.300-preview2-008530






</Description>
        <CreatedDate>24/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Blocking-RTM</Label>
          <Label>In PR</Label>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9099</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Implement Razor server discovery by pid file.</Title>
    <Description>Previously, Razor server discovery for the `build-server shutdown` command was
implemented by invoking MSBuild on a project file in the current directory to
evaluate the path to the Razor server dll.  This was problematic since it would
only discover a single running Razor server instance and required that the user
run the `build-server shutdown` command from a specific location.

Razor's server now writes a "pid file" to a well-known location
(`~/.dotnet/pids/build`) which the command can now enumerate to discover, and
shutdown, the running Razor servers.

This commit changes the Razor server discovery to use the pid files and removes
the requirement that users need to run the command in specific directories to
work.

Fixes #9084.
</Description>
    <CreatedDate>19/04/2018</CreatedDate>
    <ClosedDate>20/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9099</PullRequestID>
        <IssueID>9290</IssueID>
        <Title>Razor build server shutdown should use pid files to discover running servers.</Title>
        <Description>See https://github.com/aspnet/Razor/issues/2248 which is implementing support for writing a pid file `dotnet` can use to discover running Razor build servers.

## Steps to reproduce
1. `dotnet buildserver shutdown`

## Expected  behavior

Expected running Razor servers to shut down.  `dotnet` should use the pid file created by the Razor server to issue a shut down command, without relying on a Razor project file being present in the current directory.

## Actual behavior

`dotnet` prints a message saying Razor build server shut down was skipped because a Razor project could not be found in the current directory.

## Environment data
``





</Description>
        <CreatedDate>17/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9090</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>pick up nuget loc</Title>
    <Description>Works well. Fix #8471
![capture1](https://user-images.githubusercontent.com/6993335/38908650-1d2ff48a-4276-11e8-86f4-fdb259746419.PNG)
![capture2](https://user-images.githubusercontent.com/6993335/38908649-1d1f3ef6-4276-11e8-8493-255a664ba943.PNG)
</Description>
    <CreatedDate>18/04/2018</CreatedDate>
    <ClosedDate>18/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9090</PullRequestID>
        <IssueID>9031</IssueID>
        <Title>Message from NuGet is not localized</Title>
        <Description>“Restoring Packages for” 
“Generating msbuild file” 
“Restore completed in xxx.xx ms for” </Description>
        <CreatedDate>25/01/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9089</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Rename buildserver command.</Title>
    <Description>This commit renames the `buildserver` command to `build-server`.

Fixes #9075.
</Description>
    <CreatedDate>18/04/2018</CreatedDate>
    <ClosedDate>18/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9089</PullRequestID>
        <IssueID>9287</IssueID>
        <Title>Change name of buildserver command to build-server</Title>
        <Description>## Expected  behavior

`dotnet build-server shutdown`

## Actual behavior

`dotnet buildserver shutdown`

(Sorry I missed this earlier :-(






</Description>
        <CreatedDate>16/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9079</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Help text improves</Title>
    <Description>fix #8869
fix https://github.com/dotnet/cli/issues/9023
fix https://github.com/dotnet/cli/issues/8563</Description>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>17/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9079</PullRequestID>
        <IssueID>9212</IssueID>
        <Title>Better help text on `dotnet tool`</Title>
        <Description>As in
``
</Description>
        <CreatedDate>22/03/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9055</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Update dotnet/sdk to latest from release/2.1.3xx</Title>
    <Description>Includes the fix for dotnet/sdk#2128
</Description>
    <CreatedDate>11/04/2018</CreatedDate>
    <ClosedDate>13/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9055</PullRequestID>
        <IssueID>2128</IssueID>
        <Title>Get Executable name properly</Title>
        <Description>For OSX and Unix we shouldn't strip file ext to obtain DLL name.

Cc @pakrym 

Fixes https://github.com/dotnet/cli/issues/2125

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2128)

&lt;!-- Reviewable:end --&gt;
</Description>
        <CreatedDate>29/03/2016</CreatedDate>
        <ClosedDate>30/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9053</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Insert NuGet Build 4.7.0-rtm.5081 into cli</Title>
    <Description>Cherry-picked from #9040</Description>
    <CreatedDate>11/04/2018</CreatedDate>
    <ClosedDate>11/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9053</PullRequestID>
        <IssueID>9040</IssueID>
        <Title>Insert NuGet Build 4.7.0-rtm.5081 into cli</Title>
        <Description>Insert NuGet Build 4.7.0-rtm.5081 into cli release/2.1.2xx branch</Description>
        <CreatedDate>10/04/2018</CreatedDate>
        <ClosedDate>10/04/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>9011</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>sdmaclea</FixedByID>
    <Title>[Arm64] Enable crossgen</Title>
    <Description>Enable Arm64 Crossgen 

Fixes for arm64 #8998 

Depends on dotnet/core-setup#3987 ++

Works if I manually copy crossgen dependencies from core-setup

```bash
# Copy x64_arm64 crossgen
 cp -r \
    ../core-setup/packages/transport.runtime.linux-arm64.microsoft.netcore.runtime.coreclr/2.1.0-preview3-26404-06/tools/x64_arm64 \
    ./.nuget/packages/runtime.linux-arm64.microsoft.netcore.app/2.1.0-preview3-26404-01/tools

# Copy x64_arm64 libclrjit.so
cp -r \
    ../core-setup/packages/transport.runtime.linux-arm64.microsoft.netcore.jit/2.1.0-preview3-26404-06/runtimes/x64_arm64 \
    ./.nuget/packages/runtime.linux-arm64.microsoft.netcore.app/2.1.0-preview3-26404-01/runtimes/

```

@eerhardt 
Contains #8896 which I hope/expect will merge before dotnet/core-setup#3987 is ready</Description>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>17/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9011</PullRequestID>
        <IssueID>9255</IssueID>
        <Title>[Arm] crossgen cli tools</Title>
        <Description>Arm64 &amp; Arm crosscomponent crossgen tools are available and are being consumed by coreclr core-setup to crossgen the runtime.

They are not yet being used by cli to crossgen the SDK (done for x64).

One of the issues is that the crosscomponent crossgen tool is contained in a private coreclr package which is enacapsulated by core-setup.  ClI does not seem to have the necessary version info to reference the correct package.

Options:
+ Core-setup redistribute the crosscomponent crossgen tool(s)
+ Create a mechanism to determine the correct coreclr package version.

For arm64 the crosscomponent crossgen tool is here 
``</Description>
        <CreatedDate>05/04/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9011</PullRequestID>
        <IssueID>6702</IssueID>
        <Title>CI build fails when running dotnet restore</Title>
        <Description>## Steps to reproduce
1. Run `dotnet restore` as part of the Jenkins CI process in an **Execute Shell** step.
## Expected  behavior

`dotnet restore` will restore the packages.
## Actual behavior

Fails with:

``

I've opened an associated [SO question](http://stackoverflow.com/questions/38736096/jenkins-ci-ssl-ca-error) that covers the issue, but was wondering if I have a configuration problem with the CLI.
</Description>
        <CreatedDate>03/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9011</PullRequestID>
        <IssueID>8896</IssueID>
        <Title>[Arm64] Enable arm64 cli builds</Title>
        <Description>Adds arm64 builds

Depends on #8901 merging

@Petermarcu @johnbeisner @peterhuene @livarcocc 
</Description>
        <CreatedDate>25/03/2018</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>9011</PullRequestID>
        <IssueID>6702</IssueID>
        <Title>CI build fails when running dotnet restore</Title>
        <Description>## Steps to reproduce
1. Run `dotnet restore` as part of the Jenkins CI process in an **Execute Shell** step.
## Expected  behavior

`dotnet restore` will restore the packages.
## Actual behavior

Fails with:

``

I've opened an associated [SO question](http://stackoverflow.com/questions/38736096/jenkins-ci-ssl-ca-error) that covers the issue, but was wondering if I have a configuration problem with the CLI.
</Description>
        <CreatedDate>03/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8996</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Implement `dotnet publish --no-build`</Title>
    <Description>Fix #5331 </Description>
    <CreatedDate>04/04/2018</CreatedDate>
    <ClosedDate>06/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8996</PullRequestID>
        <IssueID>7521</IssueID>
        <Title>Dotnet publish no-build switch disappeared </Title>
        <Description>## Steps to reproduce
Dotnet publish -no-build

## Expected  behavior
It is supported

## Actual behavior
No longer supported

## Environment data
`dotnet --info` output:

This is a useful switch. We would like to understand why it's removed and if there is a replacement.




</Description>
        <CreatedDate>15/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8991</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mayankbansal018</FixedByID>
    <Title>Insert Testplatform 15.7 RTM</Title>
    <Description>Inserting Testplatform RTM package in dotnet cli

TestPlatform [Release Notes](https://github.com/Microsoft/vstest-docs/blob/master/docs/releases.md#1570)</Description>
    <CreatedDate>04/04/2018</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8991</PullRequestID>
        <IssueID>5195</IssueID>
        <Title>Should we support side by side installations of x64 and x86 MSIs?</Title>
        <CreatedDate>24/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8579</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>danmosemsft</FixedByID>
    <Title>Log kernel version, product type and installation type, and libc version</Title>
    <Description>Add 5 telemetry datapoints:

### (1) Kernel version
#### Motivation
If we have an issue associated with a kernel or libc version we can assess the breadth of impact to help determine the priority of a fix, and whether the fix should go out in servicing. We may be able to use this datapoint to help prioritize features that only affect certain kernel versions.
#### Alternatives
We have existing datapoints for distro name and version, but this the exact kernel version can vary. For example, we know "ubuntu.14.04-x64" but this encompasses a [range of kernel versions](http://people.canonical.com/~kernel/info/kernel-version-map.html).
#### Source
Existing API `RuntimeInformation.OSDescription`, which itself comes from `uname -srv` on Unix and `RtlGetVersion()` on Windows.
#### Notes
Not attempting to parse this value on the client, as the format is not consistent. It includes name, version, architecture, and kernel build date. Note that Windows subsystem for Linux ("WSL") can be distinguished by the string "Microsoft".
#### Example values
```
Alpine.36	Linux 4.9.60-linuxkit-aufs #1 SMP Mon Nov 6 16:00:12 UTC 2017
Centos.73 	 Linux 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017
Debian.87 	 Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.39-1+deb8u2 (2017-03-07)
Debian.90 	 Linux 4.9.0-2-amd64 #1 SMP Debian 4.9.18-1 (2017-03-30)
fedora.25 	 Linux 4.11.3-202.fc25.x86_64 #1 SMP Mon Jun 5 16:38:21 UTC 2017
Fedora.26 	 Linux 4.14.15-200.fc26.x86_64 #1 SMP Wed Jan 24 04:26:15 UTC 2018
Fedora.27 	 Linux 4.14.14-300.fc27.x86_64 #1 SMP Fri Jan 19 13:19:54 UTC 2018
OpenSuse.423 	 Linux 4.4.104-39-default #1 SMP Thu Jan 4 08:11:03 UTC 2018 (7db1912)
RedHat.69 	 Linux 2.6.32-696.20.1.el6.x86_64 #1 SMP Fri Jan 12 15:07:59 EST 2018
RedHat.72 	 Linux 3.10.0-514.21.1.el7.x86_64 #1 SMP Sat Apr 22 02:41:35 EDT 2017
RedHat.73 	 Linux 3.10.0-514.21.1.el7.x86_64 #1 SMP Sat Apr 22 02:41:35 EDT 2017
SLES.12 	 Linux 4.4.103-6.38-default #1 SMP Mon Dec 25 20:44:33 UTC 2017 (e4b9067)
suse.422 	 Linux 4.4.49-16-default #1 SMP Sun Feb 19 17:40:35 UTC 2017 (70e9954)
Ubuntu.1404 	 Linux 3.19.0-65-generic #73~14.04.1-Ubuntu SMP Wed Jun 29 21:05:22 UTC 2016
Ubuntu.1604 	 Linux 4.13.0-1005-azure #7-Ubuntu SMP Mon Jan 8 21:37:36 UTC 2018
Ubuntu.1604.WSL 	 Linux 4.4.0-43-Microsoft #1-Microsoft Wed Dec 31 14:42:53 PST 2014
Ubuntu.1610 	 Linux 4.8.0-45-generic #48-Ubuntu SMP Fri Mar 24 11:46:39 UTC 2017
Ubuntu.1704 	 Linux 4.10.0-19-generic #21-Ubuntu SMP Thu Apr 6 17:04:57 UTC 2017
Ubuntu.1710 	 Linux 4.13.0-25-generic #29-Ubuntu SMP Mon Jan 8 21:14:41 UTC 2018
OSX1012 	 Darwin 16.7.0 Darwin Kernel Version 16.7.0: Thu Jan 11 22:59:40 PST 2018; root:xnu-3789.73.8~1/RELEASE_X86_64
OSX1013 	 Darwin 17.4.0 Darwin Kernel Version 17.4.0: Sun Dec 17 09:19:54 PST 2017; root:xnu-4570.41.2~1/RELEASE_X86_64
Windows.10 	 Microsoft Windows 10.0.14393
Windows.10.Core 	 Microsoft Windows 10.0.14393
Windows.10.Nano 	 Microsoft Windows 10.0.14393
Windows.7 	 Microsoft Windows 6.1.7601 S
Windows.81 	 Microsoft Windows 6.3.9600
```

### (2) Windows Installation Type
#### Motivation
This tells us the relative popularity of Server, Client, Server Core, and Nano which will help us inform product decisions (features, performance work, fixes, blogs, documentation, possibly polyfills).
#### Alternatives
 We have an existing datapoint that gives us the OS version (for example "win10-x64"), but this can encompass several installation types.
#### Source
`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion@InstallationType`
#### Example values
```
Nano Server
Server Core
Server
Client
```

### (3) Windows Product Type
#### Motivation
This tells us the relative popularity of Windows SKU's such as Professional and Enterprise. Like Installation Type, this will help us inform investments and product decisions.
#### Alternatives
As above, the existing datapoint does not tell us the SKU.
#### Source
`GetProductInfo()`
#### Notes
Not attempting to parse this on the client, as the bitmap can be extended in new Windows versions.
#### Example values
```
Enterprise - "4" (0x4) 
Professional - "48" (0x30)
```
See https://msdn.microsoft.com/en-us/library/windows/desktop/ms724358(v=vs.85).aspx  for the full list.

#### (4, 5) LibC release and version
#### Motivation
Helps decide whether we can take advantage of new libc features. Conversely helps inform deprecation decisions. Also, if there is a bug specific to certain libc versions, we can establish the level of impact.
#### Alternatives
Existing datapoints do not provide this information.
#### Source
`gnu_get_libc_version()` and `gnu_get_libc_release() `for glibc. For musl (Alpine) it seems one must execute `ldd –version | grep “version”`  so I have deferred this. We do have the Alpine kernel version. Also deferred macOS.
#### Example values
```
2.22   stable
2.23   stable
```

</Description>
    <CreatedDate>09/02/2018</CreatedDate>
    <ClosedDate>11/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>73</IssueID>
        <Title>Automate DNVM-based packaging on all platforms</Title>
        <Description>This automates DNVM-based packaging (tar.gz/zip) on all platforms. The output is a zip or tar.gz named as follows `dotnet-[os]-[arch].[version]` (where `[version]` can be overridden by the `DOTNET_BUILD_VERSION` environment variable, but defaults to a simple timestampped version: `0.0.1-alpha-t[yyMMddHHmmss]`). The result will be uploadable using @glennc 's dnvm publishing tools.

@brthor @Sridhar-MS If you guys want to merge the building of the Debian package in to these scripts, that would be just fine! Eventually we should have all of our packages produced out of our standard build (though signing will make that a tricky dance ;)). 

This PR also adds a Dockerfile to create a container that can build dotnet-cli. On a Mac with Docker (and docker-machine/boot2docker/etc.) installed you can use `scripts/dockerbuild.sh` to automatically build the container, mount the repository as a volume and perform a build. The resulting artifacts are brought back to your host Mac. It **should** work on Windows if you are using docker-machine and VirtualBox ( Hyper-V doesn't support shared folders which is needed for mounting host folders into containers :( ) but I haven't tested that. This also requires that you either a) keep your code in some subfolder of `~/` (which docker-machine automatically mounts into the boot2docker VM) or b) manually ensure that your code folder is mounted into the VM at the same path as it is in your host machine.
</Description>
        <CreatedDate>20/10/2015</CreatedDate>
        <ClosedDate>21/10/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>7</IssueID>
        <Title>Initial bootstrapper logic and project layout</Title>
        <Description>Still DNX based right now, but will move over to corerun and eventually native once things are sufficiently bootstrapped.

Helper scripts require DNX/DNU on the path for now. Will make a script to bootstrap.
</Description>
        <CreatedDate>06/10/2015</CreatedDate>
        <ClosedDate>06/10/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4319</IssueID>
        <Title>dotnet-compile</Title>
        <Description># dotnet-compile

**NAME** 
dotnet-compile -- Compiles source files to a binary format and saves to a target file.

**SYNOPSIS**
dotnet compile [options]

**DESCRIPTION**
The compile command compiles source files to a binary file, either IL byte code or native machine code, depending on the options provided. The default option is compilation to IL byte code, but may change to native compilation as that toolchain matures.

The default IL [--il] output is a PE32 exe [exe], with the default extension of ".exe" on all OSes. The exe must include a static main entry point, or it is an error. The dll [dll] output option has the default extension of ".dll".

The IL exe output type needs a runtime host to execute. The IL exe output type also copies a host to the output directory. The host is renamed to the name of the exe. For example, if the file is intended to be "foo" (`-o foo`), then the host will be called foo, with the appropriate default native file extension fo the OS (see the native file extensions, below). The PE32 exe will be called "[filename]"-app.exe". In this case, it would be called "foo-app.exe".

The default native [--native] output is a native exe that conforms to the architecture of the underlying operating system (i.e. running on 64-bit OS will produce a native 64-bit exe). This can be overriden via the --arch switch and specifying the wanted architecture. The executable has a default extension of "" on Linux and OS X and ".exe" on Windows. The source must include a static void main entry point, or it is an error, unless otherwise specified in the project.json. The dynamic library [dylib] output option has the default extension of ".so" on Linux/UNIX, ".dynlib" on OS X and ".dll" on Windows. The static library [staticlib] option has the default extension of ".a" on Linux, UNIX and OS X and ".lib" on Windows.

This command relies on the following artifacts: source files, project.json project file, restore.json temporary file and restored NuGet dependencies. In the case that an app depends on only the .NET Standard Library, then the project.json and restore.json file can be inferred and no additional NuGet dependencies are required. Other cases where these files are not provided or they do not match (more on that later) are error states.

The project.json file represents and describes the project. It can contain several setting, which are described in the [Build](https://docs.asp.net/en/latest/dnx/projects.html#building). The most important information in the project.json file are the root (not transitive) NuGet dependencies and the files to be compiled. By default, this is a wildcard -- "*.cs". It supports both inclusion and exclusion semantics.

The restore.json file is expanded form of the project.json file. It includes the transitive closure of the project, per framework. It is produced by a NuGet client, typically by using the `dotnet restore` command. The restore.json file can be used by tools to safely determine the closure of dependencies, without having to manually calculate them. This file is only intended for tools, is temporary and should not be checked into source control. It should be present in .gitignore files.

It is important to know that a restore.json is invalid given that a project.json has been changed. The restore.json has enough information to determine this state given a project.json. The compile command validates this state and will error if the restore.json is invalid.

The compile command relies on NuGet dependencies for compilation, as references. These are expected to be found in the user-local NuGet cache (typically location here). It is an error state if a given NuGet package is not found.

Output files, including temporary files, are written to the child `bin` folder, which will be created if it doesn't exist. Files will be overwritten as needed.

**Options**

-n, --native [exe | dynlib | lib]
Compiles source to native machine code, for the local machine. The default is a native executable. The default exe extension is no extension and ".exe" on Windows. The default dynlib extension is ".a", ".dynlib" on OS X and ".dll" on Windows.

-a, --arch [x86 | x64]
Determines the architecture of the binary that --native produces. Valid values are x86 for 32-bit and x64 for 64-bit. 

--il [exe | dll]
Compiles source to IL byte code, which is (typically) portable across machine types. The default output is a PE32 exe, with the default extension of ".exe" on all OSes. The exe must include a static main entry point, or it is an error. The DLL output option has the default extension of ".dll".

-o, --output filename
Specifies the filename to be used. It is an error not to specify an output filename. If no extension is provided, the default one is provided for the output type.

-r, --restore
Restores the project before attempting to compile the project.

-v, --verbose
Prints verbose logging information, to follow the flow of execution of the command.
</Description>
        <CreatedDate>15/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4299</IssueID>
        <Title>Move package testing to Docker containers</Title>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Infrastructure</Label>
          <Label>packaging</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8579</PullRequestID>
        <IssueID>4307</IssueID>
        <Title>Find the right way to test the script files shipped as part of the debian package</Title>
        <CreatedDate>08/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Infrastructure</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8544</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Update Microsoft.DotNet.Archive version.</Title>
    <Description>This commit updates Microsoft.DotNet.Archive version number to include a fix
for #8288.</Description>
    <CreatedDate>06/02/2018</CreatedDate>
    <ClosedDate>06/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8544</PullRequestID>
        <IssueID>8967</IssueID>
        <Title>CLI first-run process creates repeating visual artifacts</Title>
        <Description>## Steps to reproduce

Build SDK docker container @ https://github.com/dotnet/dotnet-docker/tree/master/2.0/sdk/stretch/amd64

In that directory, run the following command:

``

## Expected  behavior

No duplicate artifacts

## Actual behavior

A command is running to populate your local package cache to improve restore speed and enable offline access. This command takes up to one minute to complete and only runs once.
Decompressing 0%...1%...2%...3%...4%...5%...6%...7%...8%...9%...10%...11%...12%...13%...14%...15%...16%...17%...18%...19%...20%...21%...22%...23%...24%...25%...26%...27%...28%...29%...30%...31%...32%...33%...34%...35%...36%...37%...38%...39%...40%...41%...42%...43%...44%...45%...46%...47%...48%...49%...50%...51%...52%...53%...54%...55%...56%...57%...58%...59%...60%...61%...62%...63%...64%...65%...66%...67%...68%...69%...70%...71%...72%...73%...74%...75%...76%...77%...78%...79%...80%...81%...82%...83%...84%...85%...86%...87%...88%...89%...90%...91%...92%...93%...94%...95%...96%...97%...98%...99%...100% 7108 ms
Expanding 0%...1%...2%...3%...4%...5%...6%...7%...8%...9%...10%...11%...12%...13%...14%...15%...16%...17%...18%...19%...20%...21%...22%...23%...24%...25%...26%...27%...28%...29%...30%...31%...32%...33%...34%...35%...36%...37%...38%...39%...40%...41%...42%...43%...44%...45%...46%...47%...48%...49%...50%...51%...52%...53%...54%...55%...56%...57%...58%...59%...60%...61%...62%...63%...64%...65%...66%...67%...68%...69%...70%...71%...72%...73%...74%...75%...76%...77%...78%...79%...80%...81%...82%...83%...84%...85%...86%...87%...88%...89%...90%...91%...92%...93%...94%...95%...96%...97%...98%...99%...100% 16836 ms

## Environment

Happens with cmd.exe and bash when building container images with Docker.exe.</Description>
        <CreatedDate>23/12/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8541</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>johnbeisner</FixedByID>
    <Title>Infrastructure updates: CLI:master -&gt; release/2.1.3xx</Title>
    <Description>Cherry-picking infrastructure updates into CLI:release/2.1.3xx

**Orchestrated final publish**
Reference: dotnet/core-eng#2407 
Contains: https://github.com/dotnet/cli/pull/8504
	Commit 8649a5c6
.\build\publish\publishnupkgtoblobfeed.targets
.\build\publish\publishcontent.targets
.\build\publish.targets
.\build\dependencyversions.props
.\build\azureinfo.props


**Use a unchanging version for 'Microsoft.NETCore.App'** 
Contains: https://github.com/dotnet/cli/pull/8448
	Commit 579e8473
.\build_projects\dotnet-cli-build\dotnet-cli-build.csproj


**Repairing the first pass call to 'dotnet msbuild'**
Contains: https://github.com/dotnet/cli/pull/8497 &amp; https://github.com/dotnet/cli/pull/8488
	 Commit 3e35517c
	 Commit 71f22a9f
.\run-build.sh
.\run-build.ps1



</Description>
    <CreatedDate>05/02/2018</CreatedDate>
    <ClosedDate>05/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8541</PullRequestID>
        <IssueID>5675</IssueID>
        <Title>Feedback on dotnet build for CI scenarios</Title>
        <Description>I'm working on a real project, and for my CI scenarios here is what I'm doing.
1. Install dotnet cli 
2. Restore packages (_for .csproj and project.json_)
3. Build projects
4. Build NuGet package
5. Publish NuGet package to nuget.org

With .csproj I've used this pattern for several other projects and it's worked well for me. I'm also very experienced with build technologies.

On step dotnet/sdk#4284 I build my .csproj projects to `OutputRoot\vs` and my `project.json` to `OutputRoot\dotnet`. I also copy my `.nuspec` file to `OutputRoot` so that I can use `nuget.exe pack` to produce the `.nupkg`.

On step dotnet/sdk#4284 I'm calling the following to build my dotnet project.

``

Here you can see that I had to add a path of `dotnet\Mutant.Chicken\bin\Release\netstandard1.5\Mutant.Chicken.dll` to get the file included into the nuget package.

I ran into a situation where we have some tests cases failing on the CI server. So I switched my config to build using `Debug`. When I did that the step to create the .nupkg file failed obviously because the path in the .nuspec has `Release`.

I played around with options `--build-base-path` to see if I could prevent this but didn't see any options that would help me. I also tried to use `--output` but this requires that I pass `--frameworks`. I'd rather not do that because then it ties my build script to one or more specific frameworks. I also don't want to do that because I'd like to build once and get all my output files in the same go like I do with `--build-base-path`.

In my case I had to add special logic into my build script to move folders under `Release`/`Debug` to the `bin` folder directly.

I understand if this is the desired default behavior for VS customers, but this new behavior makes it more difficult when automating scenarios. Minimally there should be a flag to avoid creating the `Release`/`Debug` folder.

cc @davidfowl @BillHiebert 
</Description>
        <CreatedDate>11/04/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>msbuild-mitigated</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8539</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>natemcmaster</FixedByID>
    <Title>Ensure ASP.NET Core is included in macos .pkg installer</Title>
    <Description>Resolves #8529 

Also, updates local builds to use the latest ASP.NET Core from builds from our release/2.1 branch.

cc @JunTaoLuo @Eilon </Description>
    <CreatedDate>05/02/2018</CreatedDate>
    <ClosedDate>06/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8539</PullRequestID>
        <IssueID>9051</IssueID>
        <Title>MacOS pkg installer does not include aspnetcore runtime</Title>
        <Description>The pkg installer for macOS doesn't install the aspnetcore runtime on my machine. However, the tar.gz for macOS contains the runtimes.

## Steps to reproduce
Download https://dotnetfeed.blob.core.windows.net/orchestrated-release-2-1/20180202-02/final/assets/Sdk/2.1.300-preview1-008019/dotnet-sdk-2.1.300-preview1-008019-osx-x64.pkg
Install

## Expected  behavior
Should contain two aspnetcore runtimes
``

## Actual behavior
No aspnetcore shared runtime installed.

Compare to this: https://dotnetfeed.blob.core.windows.net/orchestrated-release-2-1/20180202-02/final/assets/Sdk/2.1.300-preview1-008019/dotnet-sdk-2.1.300-preview1-008019-osx-x64.tar.gz contains the right runtime.

cc @livarcocc @Eilon - safe to assume this is a critical 2.1.0-preview1 scenario, eh?






</Description>
        <CreatedDate>04/02/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8516</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Insert latest dotnet/sdk</Title>
    <Description>In particular, aiming to get dotnet/sdk#1857 inserted for official perf runs.

cc @mikeharder </Description>
    <CreatedDate>31/01/2018</CreatedDate>
    <ClosedDate>01/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8516</PullRequestID>
        <IssueID>1857</IssueID>
        <Title>[WIP]Create dotnet bundle with CLI SDK, SharedFx MSI and Shared Host MSI.</Title>
        <CreatedDate>15/03/2016</CreatedDate>
        <ClosedDate>15/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8512</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>javiercn</FixedByID>
    <Title>Update ASP.NET Core certificate installation message</Title>
    <Description># Customer scenario

First run reporting an out of date informational message for the ASP.NET Core developer certificate installation.

# Bugs this fixes:

#8511

# Workarounds, if any

None

# Risk

Low

# Performance impact

None, we are changing the content of a message that already comes from a resource file.

# Is this a regression from a previous update?

No

# Root cause analysis:

We didn't have the final text that we wanted displayed to the users at the time the feature got in.</Description>
    <CreatedDate>31/01/2018</CreatedDate>
    <ClosedDate>02/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8512</PullRequestID>
        <IssueID>9045</IssueID>
        <Title>Update the first run message for the installation of the ASP.NET Core HTTPS development certificate</Title>
        <Description>## Steps to reproduce
Install the CLI
Run a command like dotnet new console

## Expected  behavior
An up to date message with instructions on how to trust the ASP.NET Core HTTPS development certificate gets displayed.

## Actual behavior
An out of date message is displayed.
</Description>
        <CreatedDate>31/01/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>fit-n-finish</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8486</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Add verbosity option to `install tool` command.</Title>
    <Description>This PR adds the `--verbosity` option to the `install tool` command.

MSBuild/NuGet output is now controllable by the user and defaults to being "quiet".

This enables users to see warnings from NuGet that otherwise would be swallowed
unless NuGet returned a non-zero exit code. As a byproduct of this change, the
exception handling and error messages related to obtaining tool packages was
retooled. We no longer display `install tool` command line help for installation
failures, as it should only be displayed for command line syntax errors.

Fixes #8465.</Description>
    <CreatedDate>26/01/2018</CreatedDate>
    <ClosedDate>02/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8486</PullRequestID>
        <IssueID>9028</IssueID>
        <Title>Tool installation swallows NuGet warnings.</Title>
        <Description>## Steps to reproduce

Install a tool that causes NuGet to output warnings, but no errors:

``






</Description>
        <CreatedDate>24/01/2018</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8285</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Map solution configurations to existing project configurations on add. </Title>
    <Description>This PR implements solution configuration to project configuration mapping.

Previously, when a project was added to the solution with the `sln add`
command, solution configurations would be mapped to a project configuration and
platform of the same name, regardless of whether or not the project had a
configuration or platform of that name.  This caused the solution to appear
dirty when opened in Visual Studio if the configuration or platform did not
exist at the project level because Visual Studio would attempt to correct the
mapping.

The fix is to check what configurations and platforms are supported by the
project and only map to what is present.  If a solution configuration can't be
mapped, the first configuration/platform supported by the project is chosen;
this is consistent with how Visual Studio does the fallback mapping.

Fixes #6221.</Description>
    <CreatedDate>22/12/2017</CreatedDate>
    <ClosedDate>08/01/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8285</PullRequestID>
        <IssueID>8055</IssueID>
        <Title>Visual Studio modifies solution files created from the dotnet CLI.</Title>
        <Description>## Steps to reproduce
``
open the solution with Visual Studio (version info below), open diff of test.sln: 
![image](https://cloud.githubusercontent.com/assets/180189/24581925/eba47238-16f2-11e7-8ec6-bb36946911cc.png)

## Expected  behavior
I would assume Visual Studio would leave the file alone. Or, the template from `dotnet new sln` should conform with what Visual Studio expects. 

## Actual behavior
Visual Studio makes many changes, see above. 

## Environment data
`dotnet --info` output:

.NET Command Line Tools (1.0.1)

Product Information:
 Version:            1.0.1
 Commit SHA-1 hash:  005db40cd1

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\1.0.1

## System info:
![image](https://cloud.githubusercontent.com/assets/180189/24581904/8f2b5378-16f2-11e7-8530-64996a09729d.png)

## Visual Studio info:
Microsoft Visual Studio Community 2017
Version 15.0.26228.12 D15RTWSVC
Microsoft .NET Framework
Version 4.6.01586

</Description>
        <CreatedDate>01/04/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8239</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Suppress previous NuGet messages for clean command.</Title>
    <Description>This commit suppresses messages that were previously generated during a restore
operation.  NuGet serializes the messages into `project.assets.json` during a
restore and the `ReportAssetsLogMessages` task reads and logs the messages.
This causes the clean command to print NuGet diagnostic messages even though a
restore operation does not occur.

The fix is to set the `EmitAssetsLogMessages` property to false for the clean
command, which prevents the `ReportAssetsLogMessages` target from executing.

Fixes #8027.
</Description>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>14/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8239</PullRequestID>
        <IssueID>8876</IssueID>
        <Title>'dotnet clean' seems to ignore project NU1603 warning suppression</Title>
        <Description>## Steps to reproduce
1. Create VS2017 solution for .NET Core 1.1 (error appears in 2.0 tooling, also, I believe)
2. Create console application project
3. Establish dependency on some NuGet package. In my case, I'm using Gray.Microsoft.AspNetCore.SignalR.Server. The important thing is that the package should have dependencies resolved by later versions of some package, generating a NU1603 warning during build.
4. Set project options to:
    a. suppress warning NU1603, and 
    b. treat warnings as errors.

## Expected  behavior
* When performing Clean build in VS2017, this works correctly. No NU1603 warnings are generated (and the clean succeeds). This is the expected behavior of 'dotnet clean &lt;solution&gt;', too.

## Actual behavior
* When performing 'dotnet clean &lt;solution&gt;', the warnings are displayed in the build output and the build fails (because we're set to treat warnings as errors).

In our case, this causes our local builds through VS2017 to work great, but our automated builds based on TeamCity to fail. The failure occurs in the 'clean' step only; 'build' actually uses the suppression option from the project correctly.

## Environment data
`dotnet --info` output:

.NET Command Line Tools (2.0.3)

Product Information:
 Version:            2.0.3
 Commit SHA-1 hash:  12f0c7efcc

Runtime Environment:
 OS Name:     Windows
 OS Version:  6.1.7601
 OS Platform: Windows
 RID:         win7-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.0.3\

Microsoft .NET Core Shared Framework Host

  Version  : 2.0.3
  Build    : a9190d4a75f4a982ae4b4fa8d1a24526566c69df
</Description>
        <CreatedDate>15/11/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8222</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Make restore performed by run command default to nologo and quiet.</Title>
    <Description>This commit changes the run command such that it will now be `/nologo` and
`/verbosity:quiet` (by default) for the restore operation even if a target
framework is specified.

When a target framework is specified, a separate restore operation is performed
that does not pass `/nologo` and the default verbosity is used.  The fix is to
ensure that the arguments used for the restore operation match those that are
used for the build operation.

Fixes #8118.</Description>
    <CreatedDate>12/12/2017</CreatedDate>
    <ClosedDate>18/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8222</PullRequestID>
        <IssueID>8909</IssueID>
        <Title>dotnet run shouldn't include restore output when framework is specified</Title>
        <Description>## Steps to reproduce

1. `dotnet new console`
2. `dotnet run`
3. `dotnet run -f netcoreapp2.1`

## Expected  behavior

Both cases of executing `dotnet run` output only the output of the program.

## Actual behavior

Executing `dotnet run` while specifying framework also seems to output the result of running restore:

``</Description>
        <CreatedDate>28/11/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>8199</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Write UTF-8 BOM for solution files.</Title>
    <Description>Currently the solution file written out by the `sln` command uses a
UTF-8 encoding without a BOM.  This causes problems when the solution
file contains non-ASCII code points because Visual Studio and MSBuild
will not use a UTF-8 encoding when reading the solution file if the
BOM is omitted.

This commit causes the BOM to always be written when writing the
solution files.

Fixes #8184.
</Description>
    <CreatedDate>08/12/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>8199</PullRequestID>
        <IssueID>8929</IssueID>
        <Title>dotnet sln needs to encode UTF8 w/ BOM</Title>
        <Description>VS and MSBuild seem to treat the sln file with a default ANSI encoding if there is no BOM, but we're writing it as UTF-8 without BOM.

## Steps to reproduce

``



</Description>
        <CreatedDate>07/12/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7816</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>seancpeters</FixedByID>
    <Title>1.1.0 branch - added property for aspnet template version</Title>
    <Description>This PR is the rel/1.1.0 analogue of the similar PR for release/15.5 #7811 </Description>
    <CreatedDate>12/10/2017</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7816</PullRequestID>
        <IssueID>7811</IssueID>
        <Title>Added a property to DependencyVersions.props for asp.net template version</Title>
        <Description>The current values for the template engine versions &amp; aspnet template versions are not the final 15.5 values. We're still waiting on a test sdk update before we can get the final versions. This PR uses the version in #7767. The PR is meant to setup the aspnet version handling.</Description>
        <CreatedDate>11/10/2017</CreatedDate>
        <ClosedDate>12/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7811</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>seancpeters</FixedByID>
    <Title>Added a property to DependencyVersions.props for asp.net template version</Title>
    <Description>The current values for the template engine versions &amp; aspnet template versions are not the final 15.5 values. We're still waiting on a test sdk update before we can get the final versions. This PR uses the version in #7767. The PR is meant to setup the aspnet version handling.</Description>
    <CreatedDate>11/10/2017</CreatedDate>
    <ClosedDate>12/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7811</PullRequestID>
        <IssueID>7767</IssueID>
        <Title>updating dotnet/templating build to 20171004-309</Title>
        <Description>
        </Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>11/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7773</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix tool json flakiness</Title>
    <Description>Tests often fail in CI with:
```
A JSON parsing exception occurred in [D:\j\workspace\debug_windows---bc3c3f12\.nuget\packages\.tools\dotnet-portable\1.0.0\netcoreapp2.0\dotnet-portable.deps.json]:
 * Line 1, Column 2 Syntax error: Malformed literal
```

Turns out there's a test that deliberately writes "temp" to this file and other tests can observe that in parallel. :trollface: 

Fix #4660 
</Description>
    <CreatedDate>06/10/2017</CreatedDate>
    <ClosedDate>06/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7773</PullRequestID>
        <IssueID>7115</IssueID>
        <Title>Flaky tests in CLI</Title>
        <Description>- [x] Microsoft.DotNet.Migration.Tests.GivenThatAnAppWasMigrated.
When_migration_succeeds_Then_project_json_artifacts_get_moved_to_backup(
testProjectName: \"TestAppWithLibrary\")
- [x] Microsoft.DotNet.Cli.Utils.Tests.GivenAProjectDependencyCommandResolver.
ItSetsDepsfileToOutputInCommandspecForMSBuild
- [x] Microsoft.DotNet.Cli.Utils.Tests.GivenAProjectDependencyCommandResolver.
ItPassesDepsfileArgToHostWhenReturningACommandSpecForMSBuildProject
- [x] Microsoft.DotNet.Cli.Utils.Tests.GivenAProjectDependencyCommandResolver.
ItReturnsACommandSpecWhenToolIsInAProjectRef
- [ ] see below from @livarcocc 
- [x] see below from @piotrpmsft</Description>
        <CreatedDate>09/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7756</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>benknoble</FixedByID>
    <Title>Quote variable expansions in dotnet-install.sh</Title>
    <Description>Fix #5281 to prevent paths with spaces from causing problems due to word
splitting.

Some of them aren't likely to have issues, but safety first.

See also dotnet/roslyn#22320 for something similar</Description>
    <CreatedDate>03/10/2017</CreatedDate>
    <ClosedDate>06/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7756</PullRequestID>
        <IssueID>7490</IssueID>
        <Title>dotnet-install.sh can't install to path containing spaces</Title>
        <Description>Non-blocking bug, but I noticed this when making an upstream shell script handle spaces properly.

## Steps to reproduce
Run `scripts/obtain/dotnet-install.sh --install-dir a\ b\ c`

## Expected  behavior
The .NET CLI is installed into a folder in the current directory called "a b c".

## Actual behavior
The .NET CLI is installed into a folder in the current directory called "a".

Adding `--verbose` shows a step where the path is trimmed:
``

## Environment data
OSX bash `GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin15)`
Ubuntu Trusty bash `GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)`</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Install-Script</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7721</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Port infrastructure improvements from master to dev/release/2.0.0</Title>
    <Description>Porting the following to the new 2.0.x infrastructure branch from master:

#7352 Update solution to reflect current state
#7530 Eliminate warnings (just that subset, not the part of the PR that updated core-setup)
#7460 Use REST API to upload to feed
#7571 Logging for feed upload
#7522 Rearrange output folders to fix incremental build
#7594 Fix signing after output folders moved
</Description>
    <CreatedDate>28/09/2017</CreatedDate>
    <ClosedDate>29/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7352</IssueID>
        <Title>Update solution to reflect current state</Title>
        <Description>Solution was out of date with respect to the current state of the repo.

Fixes: https://github.com/dotnet/cli/issues/7351.
</Description>
        <CreatedDate>02/08/2017</CreatedDate>
        <ClosedDate>02/08/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7530</IssueID>
        <Title>Update to latest core-setup and clean up</Title>
        <Description>Resolved conflicts for #6942 (I don't have push access to that). Gets everything on latest core-setup, not just runtime. Hopefully the pump is unblocked after this. 
Unpinned stage0
Retargeted to netcoreapp2.1 to fix build
Re-enabled tests that were disabled against msbuild quoting bug on netcoreapp2.1
Finally got rid of the warnings in the build. Fixes #7350 

@eerhardt </Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>26/08/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7460</IssueID>
        <Title>Use Rest Api to upload to the feed</Title>
        <Description>Add pulling logic to make sure it is uploaded to the feed.

Add retry logic for the whole upload process

Remove the old upload script</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>30/08/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7571</IssueID>
        <Title>Add log to UploadToLinuxPackageRepository</Title>
        <Description>There is no indication on VSTS for the step of UploadToLinuxPackageRepository at all due to the log level, add more log to it</Description>
        <CreatedDate>31/08/2017</CreatedDate>
        <ClosedDate>01/09/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7522</IssueID>
        <Title>Rearrange output folders</Title>
        <Description>- Rearrange artifact (output) folder
- Better separation between building and testing (separate stages)
- This makes it possible to run a full build twice in a row without failing</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>02/09/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7721</PullRequestID>
        <IssueID>7594</IssueID>
        <Title>Avoid importing incompatible .props files for signing build</Title>
        <Description>Together with #7593, this should fix the signing build, by making sure that all files imported during the signing build are compatible with MSBuild 14.</Description>
        <CreatedDate>05/09/2017</CreatedDate>
        <ClosedDate>06/09/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7594</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Avoid importing incompatible .props files for signing build</Title>
    <Description>Together with #7593, this should fix the signing build, by making sure that all files imported during the signing build are compatible with MSBuild 14.</Description>
    <CreatedDate>05/09/2017</CreatedDate>
    <ClosedDate>06/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7594</PullRequestID>
        <IssueID>7593</IssueID>
        <Title>Adding consistent "Project" headers to imported props and target files.</Title>
        <Description>The Windows VSO builds are currently failing in the signing step:
dir.props(1,1): Error MSB4041: The default XML namespace of the project must be the MSBuild XML namespace. If the project is authored in the MSBuild 2003 format, please add xmlns="http://schemas.microsoft.com/developer/msbuild/2003" to the &lt;Project&gt; element. If the project has been authored in the old 1.0 or 1.2 format, please convert it to MSBuild 2003 format.
</Description>
        <CreatedDate>05/09/2017</CreatedDate>
        <ClosedDate>05/09/2017</ClosedDate>
        <Labels>
          <Label>build</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7586</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mikkelbu</FixedByID>
    <Title>Add error message for missing value for verbosity</Title>
    <Description>Fixes #7520 </Description>
    <CreatedDate>02/09/2017</CreatedDate>
    <ClosedDate>13/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7586</PullRequestID>
        <IssueID>8655</IssueID>
        <Title>dotnet restore -v throws ArgumentOutOfRangeException</Title>
        <Description>## Steps to reproduce

Run the following in a Windows Command Prompt:

    dotnet restore -v

This can be done from anywhere and does not have to be, for example, run from a directory with a proper .NET Core project.

## Expected  behavior

The help for `dotnet restore` says:

``
</Description>
        <CreatedDate>25/08/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>7557</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>droyad</FixedByID>
    <Title>Fixed name of the LogFileName</Title>
    <Description>Fixed up extension in the help file from #7406</Description>
    <CreatedDate>30/08/2017</CreatedDate>
    <ClosedDate>30/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>7557</PullRequestID>
        <IssueID>7406</IssueID>
        <Title>Clarified the examples for the `--logger` parameter</Title>
        <Description>Replacement PR for #5972

The command line documentation `dotnet help test` currently reads:
``

However the example does not work. It should read `--logger "trx;LogFileName=&lt;Defaults to unique file name&gt;"`, ie without the `[]`. This correct usage can be seen in this [test](https://github.com/dotnet/cli/blob/70c65160f6163666dbe5f052b2331ec59582fce5/test/dotnet-test.Tests/GivenDotnetTestBuildsAndRunsTestfromCsproj.cs#L180)
</Description>
        <CreatedDate>10/08/2017</CreatedDate>
        <ClosedDate>29/08/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6859</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Add explicit dependency for pakcage smoke test</Title>
    <Description>This infrastructure work
#6841</Description>
    <CreatedDate>14/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6859</PullRequestID>
        <IssueID>8376</IssueID>
        <Title>Do not run test on VSTS build</Title>
        <Description>The only job of VSTS build should be building packages. The problem is the E2E post packing smoke test requires functional tests' "TestProjects". Need to invoke the same task before running smoke test</Description>
        <CreatedDate>12/06/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Infrastructure</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6794</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add Microsoft.NET.Build.Extensions and corresponding DLLs in CLI layout</Title>
    <Description>Fixes #6737</Description>
    <CreatedDate>07/06/2017</CreatedDate>
    <ClosedDate>09/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6794</PullRequestID>
        <IssueID>8328</IssueID>
        <Title>Include .NET 4.6.1 support for .NET Standard 2.0 in CLI layout</Title>
        <Description>The tasks and targets that support .NET Standard 2.0 in .NET Framework 4.6.1 need to be included in the CLI's layout.

This is a piece of the work required for dotnet/sdk#1267, which tracks the overall work.



</Description>
        <CreatedDate>01/06/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6789</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>MSBuild 15.3.378</Title>
    <Description>#6788, but for 1.1.0.</Description>
    <CreatedDate>07/06/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6789</PullRequestID>
        <IssueID>6788</IssueID>
        <Title>MSBuild 15.3.378</Title>
        <Description>Corresponds to internal VS PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequest/71918.</Description>
        <CreatedDate>07/06/2017</CreatedDate>
        <ClosedDate>07/06/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6787</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nkolev92</FixedByID>
    <Title>Add force restore option</Title>
    <Description>Adding the force option in the CLI, added in the NuGet as part of the restore no-op work.
More info here:
https://github.com/NuGet/Home/wiki/NuGet-Restore-No-Op
&amp;&amp;
https://github.com/NuGet/Home/wiki/%5BSpec%5D-NuGet-settings-in-MSBuild

This flag will be used by NuGet once 4.3.0.4118 or later is inserted:

Fixes:
NuGet/Home#5080
NuGet/Home#5181

//cc
@emgarten @rrelyea @livarcocc</Description>
    <CreatedDate>07/06/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6787</PullRequestID>
        <IssueID>5080</IssueID>
        <Title>Remove argument separator from commands </Title>
        <Description>Currently, the argument separator (`--`) is only supported on `dotnet run`. This PR removes it from other commands to make the help and usage of these command clearer. 

It also adds a new test to check the `dotnet run` message output and changes an existing test to not check the msbuild argument mesasge for `dotnet run` but only for others. 

/cc @livarcocc @piotrpMSFT @jonsequitur </Description>
        <CreatedDate>19/12/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6787</PullRequestID>
        <IssueID>5181</IssueID>
        <Title>Added ability to pass runsettings as commandline parameters after --</Title>
        <Description>- Added ability to pass runsettings arguments after -- for dotnet test.
- Updated documentation of --logger.

</Description>
        <CreatedDate>30/12/2016</CreatedDate>
        <ClosedDate>06/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6785</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>johnbeisner</FixedByID>
    <Title>.NET Core 2+ Naming and Versioning follow-up; Part 2</Title>
    <Description>Updates to install scripts to consume the renamed packages at blob storage. 
Unpinning the CLI to build from a specific version to 'latest'.

Note: This is part 2 of a 2 part change
PR for Part 1: https://github.com/dotnet/cli/pull/6764
_______________________________
New naming guidelines: dotnet/designs: dotnet/designs#2

@dotnet/dotnet-cli</Description>
    <CreatedDate>07/06/2017</CreatedDate>
    <ClosedDate>08/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6785</PullRequestID>
        <IssueID>4284</IssueID>
        <Title>'dotnet commands' command</Title>
        <Description>dotnet-commands should enumerate all executables on the path that match the 'dotnet-' preamble. The preamble should not be displayed in the output. So, if we have:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6764</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>johnbeisner</FixedByID>
    <Title>.NET Core 2+ Naming and Versioning follow-up; Part 1</Title>
    <Description>Renaming "dotnet-dev" to "dotnet-sdk"; therefore: renaming "dotnet-sdk" to "dotnet-sdk -internal". 
Pinning the install scripts to a unrenamed version so the build will not break on 'latest'.

Note: This is part 1 of a 2 part change
Part 2 will be install script changes to consume this change.

New naming guidelines: dotnet/designs: dotnet/designs#2
Reference: 
https://github.com/dotnet/cli/issues/6734
____________________________________
Also addresses:
https://github.com/dotnet/cli/issues/6718

@dotnet/dotnet-cli
</Description>
    <CreatedDate>05/06/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6764</PullRequestID>
        <IssueID>4284</IssueID>
        <Title>'dotnet commands' command</Title>
        <Description>dotnet-commands should enumerate all executables on the path that match the 'dotnet-' preamble. The preamble should not be displayed in the output. So, if we have:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6757</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nkolev92</FixedByID>
    <Title>Add restore force option - cli 2.0</Title>
    <Description>Adding the force option in the CLI, added in the NuGet as part of the restore no-op work.
More info here:
https://github.com/NuGet/Home/wiki/NuGet-Restore-No-Op
&amp;&amp;
https://github.com/NuGet/Home/wiki/%5BSpec%5D-NuGet-settings-in-MSBuild

This flag will be used by NuGet once 4.3.0.4118 or later is inserted:

Fixes:
NuGet/Home#5080
NuGet/Home#5181

//cc
@emgarten @rrelyea @nguerrera @livarcocc</Description>
    <CreatedDate>03/06/2017</CreatedDate>
    <ClosedDate>05/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6757</PullRequestID>
        <IssueID>5080</IssueID>
        <Title>Remove argument separator from commands </Title>
        <Description>Currently, the argument separator (`--`) is only supported on `dotnet run`. This PR removes it from other commands to make the help and usage of these command clearer. 

It also adds a new test to check the `dotnet run` message output and changes an existing test to not check the msbuild argument mesasge for `dotnet run` but only for others. 

/cc @livarcocc @piotrpMSFT @jonsequitur </Description>
        <CreatedDate>19/12/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6757</PullRequestID>
        <IssueID>5181</IssueID>
        <Title>Added ability to pass runsettings as commandline parameters after --</Title>
        <Description>- Added ability to pass runsettings arguments after -- for dotnet test.
- Updated documentation of --logger.

</Description>
        <CreatedDate>30/12/2016</CreatedDate>
        <ClosedDate>06/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6756</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nkolev92</FixedByID>
    <Title>Add restore force option</Title>
    <Description>Adding the force option in the CLI, added in the NuGet as part of the restore no-op work.
More info here:
https://github.com/NuGet/Home/wiki/NuGet-Restore-No-Op
&amp;&amp;
https://github.com/NuGet/Home/wiki/%5BSpec%5D-NuGet-settings-in-MSBuild

This flag will be used by NuGet once 4.3.0.4118 or later is inserted:

Fixes:
NuGet/Home#5080
NuGet/Home#5181

//cc
@emgarten @rrelyea @nguerrera @livarcocc</Description>
    <CreatedDate>03/06/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6756</PullRequestID>
        <IssueID>5080</IssueID>
        <Title>Remove argument separator from commands </Title>
        <Description>Currently, the argument separator (`--`) is only supported on `dotnet run`. This PR removes it from other commands to make the help and usage of these command clearer. 

It also adds a new test to check the `dotnet run` message output and changes an existing test to not check the msbuild argument mesasge for `dotnet run` but only for others. 

/cc @livarcocc @piotrpMSFT @jonsequitur </Description>
        <CreatedDate>19/12/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6756</PullRequestID>
        <IssueID>5181</IssueID>
        <Title>Added ability to pass runsettings as commandline parameters after --</Title>
        <Description>- Added ability to pass runsettings arguments after -- for dotnet test.
- Updated documentation of --logger.

</Description>
        <CreatedDate>30/12/2016</CreatedDate>
        <ClosedDate>06/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6735</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>johnbeisner</FixedByID>
    <Title>Update README links: .NET Core 2+ Naming and Versioning</Title>
    <Description>The README links at https://github.com/dotnet/cli/tree/release/2.0.0#installers-and-binaries need to be updated for this change - reference: https://github.com/dotnet/cli/pull/6714
__________________________
New naming guidelines: dotnet/designs: dotnet/designs#2
Updates to installer and archive names:
Shift rid to the end
Intermediate package dotnet-sharedframework-* will be renamed to dotnet-runtime-*
__________________________

Addresses: https://github.com/dotnet/cli/issues/6734

@dotnet/dotnet-cli</Description>
    <CreatedDate>01/06/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6735</PullRequestID>
        <IssueID>4284</IssueID>
        <Title>'dotnet commands' command</Title>
        <Description>dotnet-commands should enumerate all executables on the path that match the 'dotnet-' preamble. The preamble should not be displayed in the output. So, if we have:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6701</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Allow resolution of SDKs without minimum msbuild version file</Title>
    <Description>If the resolved SDK is older than one that has an explicit minimumMSBuildVersion file, then resolution would fail.

Instead, treat such SDKs as requiring 15.3.0, which is where the first minimumMSBuildVersion ships and only goes up from here.

@MattGertz for approval

**Customer scenario**

No .NET Core SDK is installed yet with an explicit minimumMSBuild version (all but most recent 2.0.0-preview2 builds at the moment) file or global.json is pinning such a version. In both cases, resolution will fail. For non-web projects, we fall back to the default resolver and in-box 1.x SDK, but web projects will fail to load altogether in this case.

**Bugs this fixes:** 

[VSO 441969](https://devdiv.visualstudio.com/DevDiv/_workitems?id=441969&amp;fullScreen=false&amp;_a=edit)

Fix #6702

**Workarounds, if any**

Install latest preview 2 CLI and don't pin to lower version in global.json

**Risk**

Low

**Performance impact**

Low to none

**Is this a regression from a previous update?**

Yes, introduced by minimum msbuild version support

**Root cause analysis:**

Lack of tests for case where this file is missing. Fixed.

**How was the bug found?**

Dogfooding</Description>
    <CreatedDate>26/05/2017</CreatedDate>
    <ClosedDate>27/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6701</PullRequestID>
        <IssueID>8310</IssueID>
        <Title>Could not find file 'C:\Program Files\dotnet\sdk\1.0.4\minimumMSBuildVersion'</Title>
        <Description>@vsccarl commented on [Fri May 26 2017](https://github.com/dotnet/corefx/issues/20386)

In the latest d15prerel (26526.3001) I'm getting the below error when trying to build any .net Core project. The logs are the same for both C# and VB. The folder exists, but as the logs say, the file is missing.

``

</Description>
        <CreatedDate>27/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6660</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Enable VB tests on all platforms</Title>
    <Description>This reverts commit a4c3e69c3cedc5aedfd4f76eab35e3cf05e447ba.

This should work since 28e25657cbaf03919983e33ad477eab8744a2763 picked
up the fix for Microsoft/msbuild#137.</Description>
    <CreatedDate>22/05/2017</CreatedDate>
    <ClosedDate>22/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6660</PullRequestID>
        <IssueID>4364</IssueID>
        <Title>Need to find a solution for telemetry to understand usage and failure points</Title>
        <Description>We would like to track the usage of the tool in a generic form and make that data available to the public as well.
</Description>
        <CreatedDate>02/11/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6635</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>EdwardBlair</FixedByID>
    <Title>Addresses #6317</Title>
    <Description>skipciplease

Addresses #6317</Description>
    <CreatedDate>19/05/2017</CreatedDate>
    <ClosedDate>23/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6635</PullRequestID>
        <IssueID>8112</IssueID>
        <Title>Don't show Telemetry message portion during first run when  DOTNET_CLI_TELEMETRY_OPTOUT = 1</Title>
        <Description>## Steps to reproduce


i ran:

``

</Description>
        <CreatedDate>14/04/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6631</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Fix dotnet store options</Title>
    <Description>- remove configuration
- remove preserve-working-dir
- add skip-symbols

Fix #6488
Fix #6489
Fix #6490

Also fixes #1 of https://github.com/dotnet/sdk/issues/1126#issuecomment-299173452.  And along with https://github.com/dotnet/sdk/pull/1231 should complete the feature.

@gkhanna79 @ramarag 

/cc @bleroy @dotnet/dotnet-cli </Description>
    <CreatedDate>18/05/2017</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6631</PullRequestID>
        <IssueID>8196</IssueID>
        <Title>Remove the `--preserve-working-dir` option from `dotnet store`</Title>
        <Description>This is a debugging option that can still be reached through MS Build options, but is not required on the CLI command.

</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Store</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6631</PullRequestID>
        <IssueID>8197</IssueID>
        <Title>Remove the `-c|--configuration` option from `dotnet store`</Title>
        <Description>It was mistakenly added, and is not used.





</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Store</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6631</PullRequestID>
        <IssueID>8198</IssueID>
        <Title>Add a `--skip-symbols` option to `dotnet store`</Title>
        <Description>The option skips generation of symbols.




</Description>
        <CreatedDate>02/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Store</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6631</PullRequestID>
        <IssueID>4283</IssueID>
        <Title>dotnet command --&gt; dotnet-command</Title>
        <Description>DotNet driver should interpret the first parameter passed on the command line as the name of an executable it should call. If an executable file with that name is found on the path then any subsequent parameters are passed through to that executable:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6627</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>livarcocc</FixedByID>
    <Title>Fixing restore so that it respects the verbosity param.</Title>
    <Description>Fixing restore so that it respects the verbosity param. The problem was that ConsoleLoggerParameters was overwritting whatever was coming through the command line.

@dotnet/dotnet-cli 

@MattGertz for approval.

**Customer scenario**

Respects the verbosity value passed through the command when invoking dotnet restore.

**Bugs this fixes**

[CLI #5989](https://github.com/dotnet/cli/issues/5989)

**Workarounds, if any**

Run dotnet msbuild /t:restore /v:&lt;verbosity level&gt;

**Risk**

Small. Just removes a default parameter passed to msbuild when verbosity is specified in the command line.

**Performance impact**

N/A

**Root cause analysis**

N/A

**How was the bug found?**

Customer reported.

</Description>
    <CreatedDate>18/05/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6627</PullRequestID>
        <IssueID>7892</IssueID>
        <Title>dotnet restore does not respect verbosity</Title>
        <Description>`dotnet restore -v q` does not respect the quiet flag.

However, `dotnet msbuild /t:restore /v:q` works fine. 

@livarcocc @emgarten </Description>
        <CreatedDate>10/03/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>Parser</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6602</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>livarcocc</FixedByID>
    <Title>Improve Json perf by using JObject.Load.</Title>
    <Description>Fixes #2783 and #2785 

@dotnet/dotnet-cli </Description>
    <CreatedDate>15/05/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6602</PullRequestID>
        <IssueID>5931</IssueID>
        <Title>[Perf] Use JObject.Load instead of JObject.Parse</Title>
        <Description>https://github.com/dotnet/cli/blob/91fb67835d11f60bbe4763f0de6d3859236cb07a/src/dotnet/commands/dotnet-build/IncrementalCache.cs#L61

This is unnecessarily loading the string into memory. Use JObject.Load with the StreamReader.

Edit: Also here - https://github.com/dotnet/cli/blob/ac4c6702d5d345dc9c397f80290f105fedebe98b/src/Microsoft.DotNet.ProjectModel/RuntimeConfig/RuntimeConfig.cs#L40

And here - https://github.com/dotnet/cli/blob/ed05e164fbe0f046de53d7ccab343ec562bb107f/src/Microsoft.DotNet.ProjectModel/GlobalSettings.cs#L70
</Description>
        <CreatedDate>29/04/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>performance</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6602</PullRequestID>
        <IssueID>5933</IssueID>
        <Title>[Perf] Consider using JsonTextReader and JsonTextWriter</Title>
        <Description>There are places where JSON is being loaded into a JObject and then the JObject is being read to return a strongly typed class.

e.g. https://github.com/eerhardt/cli/blob/77da06b392190b1a952fd299236505f989d92f25/src/Microsoft.DotNet.ProjectModel/Graph/LockFileReader.cs

Using JsonTextReader to build the strongly type class will save allocating the intermediary JObject.

In cases where JSON is being written, JsonTextWriter can be used directly rather than creating a JObject and then writing that, again saving allocating intermediary objects.
</Description>
        <CreatedDate>29/04/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>performance</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6599</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Move 2 files to use lower ver msbuild</Title>
    <Description>A missing commit for #6575

The build machine is using an old version of msbuild for signing.
Lower the version of these 2 files to make is available for signing
</Description>
    <CreatedDate>15/05/2017</CreatedDate>
    <ClosedDate>15/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6599</PullRequestID>
        <IssueID>6575</IssueID>
        <Title>Fix signing dependencies project</Title>
        <Description>@dotnet/dotnet-cli 

This one I actually tried out in VSO. I cancelled it before we got to publishing. Signing in working again.</Description>
        <CreatedDate>11/05/2017</CreatedDate>
        <ClosedDate>11/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6594</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mikkelbu</FixedByID>
    <Title>Correct parsing of 'Format Version' header in sln files</Title>
    <Description>Prior to this change the exception on line 138 could not
be thrown, as far as I can tell. The reason for this
is that`HeaderPrefix` contained a trailing space, and we
had verified that `line` (trimmed) started with
`HeaderPrefix`. Hence `line` must contain something more
than `HeaderPrefix` otherwise the tailing space would
have been removed, so the length of `line` could not be
less than or equal to the length of `HeaderPrefix`.

Added and changed tests to ensure that both exceptions
regarding `FormatVersion` are thrown.

Fixes #5978</Description>
    <CreatedDate>14/05/2017</CreatedDate>
    <ClosedDate>15/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6594</PullRequestID>
        <IssueID>7889</IssueID>
        <Title>Misleading error message when `dotnet sln` inadvertently used on csproj file </Title>
        <Description>## Steps to reproduce
* Create a new project -- `dotnet new console`
* Pass the new project's csproj file to `dotnet sln` -- `dotnet sln myproj.csproj list`

## Expected  behavior

Error message should indicate that the file is not a valid solution file because the header on **line 1** is incorrect.

For example, something along the lines of:

    Invalid solution file `myproj.csproj`. Error on line 1: Expected header not found

## Actual behavior
    Invalid solution `myproj.csproj`. Invalid format in line 8: File header is missing

This message is confusing as it both:
* suggests that the file is missing a header when it actually contains the wrong (i.e. an unexpected) header
* reports the error as occurring on line 8 when it actually occurs on line 1.


## Environment data
`dotnet --info` output:
.NET Command Line Tools (1.0.0)

Product Information:
 Version:            1.0.0
 Commit SHA-1 hash:  e53429feb4

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x64

</Description>
        <CreatedDate>09/03/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6584</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mikkelbu</FixedByID>
    <Title>Pass nologo to MSBuild in 'add package' command</Title>
    <Description>Fixes #6534</Description>
    <CreatedDate>12/05/2017</CreatedDate>
    <ClosedDate>15/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6584</PullRequestID>
        <IssueID>8219</IssueID>
        <Title>dotnet add package output should not include MSBuild version header</Title>
        <Description>See  below, I don't see to see this
``</Description>
        <CreatedDate>06/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>fit-n-finish</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6567</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Unify text for installer</Title>
    <Description>![windows-1](https://cloud.githubusercontent.com/assets/6993335/25912885/ac6e2b24-356d-11e7-8774-b1c0c15c96a2.gif)
![mac](https://cloud.githubusercontent.com/assets/6993335/25912890/ae5267b6-356d-11e7-9699-b4cab7ca4b4d.gif)
![deb](https://cloud.githubusercontent.com/assets/6993335/25912893/af623dfc-356d-11e7-86ce-24d55b025234.PNG)

#6448</Description>
    <CreatedDate>10/05/2017</CreatedDate>
    <ClosedDate>15/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6567</PullRequestID>
        <IssueID>8183</IssueID>
        <Title>Unify and tweak telemetry text for deb, windows and masOS</Title>
        <Description>
        </Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6563</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jlanng</FixedByID>
    <Title>Support corporate proxy servers</Title>
    <Description>See issue #6562

I've tested this fix behind a corporate proxy, with an explicit proxy parameter specified, and with a direct connection.</Description>
    <CreatedDate>10/05/2017</CreatedDate>
    <ClosedDate>15/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6563</PullRequestID>
        <IssueID>8240</IssueID>
        <Title>dotnet-install.ps1 doesn't work behind a corporate web proxy</Title>
        <Description>I discovered this when trying to run the buildtools build. There is no opportunity to use the ProxyAddress param since the call to dotnet-install.ps1 is embedded within another script.

I have a fix that I'll submit shortly</Description>
        <CreatedDate>10/05/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Install-Script</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6530</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mikkelbu</FixedByID>
    <Title>Gracefully report invalid project when added via sln-add</Title>
    <Description>Fixes #5900 </Description>
    <CreatedDate>06/05/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6530</PullRequestID>
        <IssueID>7840</IssueID>
        <Title>Unhandled exception in `dotnet sln add` when argument isn't MSBuild-format</Title>
        <Description>When the argument given to `dotnet sln add` is not a valid MSBuild project, the CLI crashes with an unhandled exception originating from MSBuild.

## Steps to reproduce
`dotnet sln add &lt;file that isn't a .csproj&gt;`

## Expected  behavior
An error message explaining the problem and a failure exit code.

## Actual behavior
Unhandled exception with application-crash dialog (on Windows).

``




</Description>
        <CreatedDate>02/03/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6526</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mikkelbu</FixedByID>
    <Title>Fail gracefully when multiple projects exist</Title>
    <Description>Fixes #6267 </Description>
    <CreatedDate>05/05/2017</CreatedDate>
    <ClosedDate>08/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6526</PullRequestID>
        <IssueID>8086</IssueID>
        <Title>dotnet &lt;external cmd&gt; stack dumps if run in a dir with multiple csproj files</Title>
        <Description>## Steps to reproduce
In a console session, go to a directory containing multiple .csproj files.
Run 'dotnet foo' (foo can be replaced by any command name not built in to dotnet)

## Expected  behavior
The program should fail gracefully, emitting a proper error message.

## Actual behavior
This stack dump is sent to the console:
``

## Environment data
`dotnet --info` output:
.NET Command Line Tools (1.0.0-rc4-004842)

Product Information:
 Version:            1.0.0-rc4-004842
 Commit SHA-1 hash:  7238b3efa2

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x86
 Base Path:   C:\Program Files (x86)\dotnet\sdk\1.0.0-rc4-004842





</Description>
        <CreatedDate>06/04/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6520</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Updating the SDK to include the implicit package downgrade warnings fix.</Title>
    <Description>This should fix the issues with, and replace #6511.</Description>
    <CreatedDate>05/05/2017</CreatedDate>
    <ClosedDate>05/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6520</PullRequestID>
        <IssueID>6511</IssueID>
        <Title>Updating the SDK to include the implicit package downgrade warnings fix.</Title>
        <Description>@dotnet/dotnet-cli 

@ManishJayaswal @Pilchie @MattGertz this is just bringing over a change that has already approved in the SDK repo. I will merge once it turns green so that it is available tomorrow morning.

cc @leecow </Description>
        <CreatedDate>04/05/2017</CreatedDate>
        <ClosedDate>05/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5690</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Re-enable solution building tests</Title>
    <Description>Fixes #5205 

@piotrpMSFT @livarcocc @krwq @jonsequitur @eerhardt </Description>
    <CreatedDate>13/02/2017</CreatedDate>
    <ClosedDate>21/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5690</PullRequestID>
        <IssueID>7457</IssueID>
        <Title>Re-enable solution building tests</Title>
        <Description>The solution building portion of these tests have been disabled
1. WhenValidProjectIsPassedTheSlnBuilds
2. MigrateAndBuild

Tracking an issue on the sdk
https://github.com/dotnet/sdk/issues/545
</Description>
        <CreatedDate>04/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5686</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>omajid</FixedByID>
    <Title>Use dotnet-install from the cli master branch</Title>
    <Description>During the `cli` build, the `cli` downloads and executes the bootstrap script from `buildtools`. The bootstrap script then downloads and executes the `dotnet-install` script from `cli`, but in the `rel/1.0.0` branch, not the `master` branch.

This means that someone building `cli`'s master branch will end up using the `dotnet-install.sh` or `dotnet-install.ps1` script from cli's `rel/1.0.0` branch.

Fix that by telling the bootstrap script to download and use the version of dotnet-install script from the `master` branch (which is the current branch the user is building).

Ideally, we would just call the dotnet-install script in the current repo/branch, but because the bootstrap script sits in the middle and is part of a different repository, we can't.

This is a workaround for #5410.

With this change, I can run `./build.sh /t:Compile` on RHEL 7.3 successfully. I didn't test the build on Windows.</Description>
    <CreatedDate>13/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5686</PullRequestID>
        <IssueID>7574</IssueID>
        <Title>Why doesn't cli use the version of dotnet-install in repo?</Title>
        <Description>This is probably a stupid question, so apologies in advance.

Why does the cli grab the `dotnet-install.sh` script from github rather than using the copy at `scripts/obtain/dotnet-install.sh`?

To me, it seems like this approach makes it much harder to fix issues in `dotnet-install.sh` because the version available at github.com is being used and local changes to `dotnet-install.sh` are ignored.</Description>
        <CreatedDate>20/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5662</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Fix dotnet new classlib to contain the correct NETStandard.Library version.</Title>
    <Description>Fix #5638

Getting the correct NETStandard.Library version by reading the shared frameowork's deps.json file.

@dotnet/dotnet-cli 
</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>11/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5662</PullRequestID>
        <IssueID>7711</IssueID>
        <Title>"dotnet new classlib" uses wrong version for NETStandard.Library 2.0</Title>
        <Description>## Steps to reproduce
Using a 2.0 SDK (one built from master)

``




</Description>
        <CreatedDate>09/02/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5657</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>codito</FixedByID>
    <Title>Insert TestPlatform v15.0.0-preview-20170210-02.</Title>
    <Description>Issues fixed:
* Replace invalid characters in trx with unicode escape character (issue microsoft/vstest#320)
* Standard error messages from testhost are passed to console runner (issue microsoft/vstest#281)
* Add autogenerated header to `Program.cs` (issue microsoft/vstest#420)
* Change type name of autogenerated entrypoint (issue microsoft/vstest#430)
* Show adapter messages on runner output (issue microsoft/vstest#300)
* Use RC.3 VSSDK manifests for vsix generation

ASK mode template: [Bug 383308](https://devdiv.visualstudio.com/DevDiv/VS.in%20Agile%20Testing%20IDE/_workitems?_a=edit&amp;id=383308&amp;triage=true)

Required for RTW. Above bug is pending approval.</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5657</PullRequestID>
        <IssueID>4465</IssueID>
        <Title>dotnet repl auto-references mscorlib which breaks on CoreCLR</Title>
        <Description>This may be a Roslyn issue, but I'm starting it off here because that's where I repro'd it.

Do the following:
1. Run `csi` (`dotnet-repl-csi` is broken, I'm fixing that now)
2. Type `System.ConsoleColor.Red`
   1. :+1: `(1,1): error CS0234: The type or namespace name 'ConsoleColor' does not exist in the namespace 'System' (are you missing an assembly reference?)` (this is **expected**)
3. Type `#r "System.Console.dll"`
4. Type `System.ConsoleColor.Red`
   1. :+1: `Red` (again, **expected**, System.Console.dll was properly loaded)
5. Type `System.Console.WriteLine`
   1. :boom: `(1,1): error CS0433: The type 'Console' exists in both 'System.Console, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' and 'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e'`

It looks like `csi` is automatically referencing `mscorlib.dll` causing these type conflicts. AFAIK, CoreCLR-based apps/scripts shouldn't be referencing `mscorlib`. As far as I can tell, this is coming from https://github.com/dotnet/roslyn/blob/master/src/Scripting/Core/Script.cs#L186

Feel free to move over to dotnet/roslyn, I wanted to file it here to make it clear that the `csi` in the dotnet-cli is the one that is broken (the desktop one seems to work fine because referencing mscorlib is OK there).

I'm trying to resolve dotnet/sdk#4430 by converting build scripts to `csx` so they are cross-plat, but unfortunately this is blocking me :(
</Description>
        <CreatedDate>25/11/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Area-External</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5657</PullRequestID>
        <IssueID>4437</IssueID>
        <Title>Add CI test to perform a dotnet-compile-native on hello world</Title>
        <Description>Since there are a lot of moving parts, let us (corert/CLI) both make sure we don't break the E2E experience between PR merges for both CPP and RyuJIT modes on all supported platforms.
</Description>
        <CreatedDate>20/11/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5657</PullRequestID>
        <IssueID>4520</IssueID>
        <Title>Fix Ubuntu 'unknown command' experience</Title>
        <Description>Same versions as dotnet/sdk#4511 

``

Clearly there is an error in the build, and when it attempts to report it, it crashes.
</Description>
        <CreatedDate>07/12/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5657</PullRequestID>
        <IssueID>430</IssueID>
        <Title>Fix project.json dependencies and System.Private.CoreLib casing</Title>
        <CreatedDate>08/12/2015</CreatedDate>
        <ClosedDate>09/12/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5657</PullRequestID>
        <IssueID>4449</IssueID>
        <Title>dotnet -? should list --help as a subcommand for each command</Title>
        <Description>Today, -? is this: 
.NET Command Line Interface
Usage: dotnet [common-options] [command] [arguments]

Arguments:
  [command]     The command to execute
  [arguments]   Arguments to pass to the command

Common Options (passed before the command):
  -v|--verbose  Enable verbose output

Common Commands:
  compile       Compiles a .NET project
  publish       Publishes a .NET project for deployment
  run           Compiles and immediately executes a .NET project

dotnet &lt;common command&gt; --help is a valid command that lists options for each common command, but there's nothing to tell the user that. 
</Description>
        <CreatedDate>23/11/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5655</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Update README.md</Title>
    <Description>Change the links on the dotnet/README.md to point aka.ms/dotnet-* set of links.

Fixes #5572 </Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>11/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5655</PullRequestID>
        <IssueID>7668</IssueID>
        <Title>Links in src/dotnet/README.md are broken</Title>
        <Description>The links for the commands' documentation in https://github.com/dotnet/cli/blob/rel/1.0.0/src/dotnet/README.md lead to 404 errors.  It looks like the individual commands' READMEs were removed in 2d93968a88a724ec69a3c3cfd0ad92576101cbfe.

/cc @seancpeters @blackdwarf </Description>
        <CreatedDate>03/02/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5647</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>First try at refactor of Prepare.targets</Title>
    <Description>@jgoshi @livarcocc @jonsequitur @eerhardt @krwq 

With @jgoshi's #5617 merged, I took a first pass at refactoring Prepare.targets into statically evaluated props files. Here are some things I'm experimenting with:

- DO NOT create a Prepare.props. Instead, decompose the props into files that represent responsibilities. I think that Version.props is a good example. Stage0.props probably needs some naming, if not intention, changes as it intends to cover "the stuff we need to build this repo"
- DO make the root `dir.props` the aggregator of these props. Ordering for pulling in the props files is relevant and that seems like the right place to do it.

Let me know what you think. I hope that this PR contributes some patterns that @jgoshi and @krwq can use for further refactoring.</Description>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>13/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5647</PullRequestID>
        <IssueID>5617</IssueID>
        <Title>Generate host and build info and store them in .props files</Title>
        <Description>@piotrpMSFT @krwq @jonsequitur @livarcocc </Description>
        <CreatedDate>07/02/2017</CreatedDate>
        <ClosedDate>09/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5633</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>change CommandLineApplication.Name for pack and restore to include 'dotnet'</Title>
    <Description>This addresses a few inconsistencies in the "Usage" line of the help output for the `pack` and `restore` commands relative to most of the commands.

It addresses #4813. </Description>
    <CreatedDate>08/02/2017</CreatedDate>
    <ClosedDate>24/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5633</PullRequestID>
        <IssueID>7230</IssueID>
        <Title>Fix help usage for dotnet pack and restore</Title>
        <Description>Discovered this while working on similar bug in dotnet nuget command.

The help usage part of dotnet pack and dotnet restore should correctly display usage as `dotnet pack ...` or `dotnet restore ...`

1. 
``





</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5624</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migrate compilationOptions even when other deprecated options are present</Title>
    <Description>Fixes #5614 

@piotrpMSFT @livarcocc @krwq @jonsequitur </Description>
    <CreatedDate>08/02/2017</CreatedDate>
    <ClosedDate>09/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5624</PullRequestID>
        <IssueID>7697</IssueID>
        <Title>Migration: deprecated compilationOptions are ignored if another deprecated option (like exclude) is used</Title>
        <Description>The issue is if there is a deprecated option that belongs in buildOptions (say the "exclude" option) and "compilationOptions" then in that case we internally generate a buildOptions node. This causes "compilationOptions" to be ignored.

In this example, we would ignore the "emitEntryPoint": true option and the resulting csproj file will incorrectly generate a library rather than an exe.

{
  "compilationOptions": {
    "emitEntryPoint": true,
    "preserveCompilationContext": true
  },
  "exclude": [
    "node_modules"
  ]
}
</Description>
        <CreatedDate>07/02/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Pending Shiproom Approval</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5618</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>Remove incorrect localizations</Title>
    <Description>I've rebased these localization fixes that I made against rel/1.0.0 onto master. 

This replaces #5509.
</Description>
    <CreatedDate>08/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5618</PullRequestID>
        <IssueID>5509</IssueID>
        <Title>remove unused and incorrect localizations</Title>
        <Description>This addresses #4977. Along the way, I removed a number of localization strings that are not in use.</Description>
        <CreatedDate>29/01/2017</CreatedDate>
        <ClosedDate>08/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5603</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>mlorbetske</FixedByID>
    <Title>Update template engine templates version to absorb the fix for #5602</Title>
    <Description>Fixes #5602 </Description>
    <CreatedDate>06/02/2017</CreatedDate>
    <ClosedDate>06/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5603</PullRequestID>
        <IssueID>7691</IssueID>
        <Title>Razor View Precompilation is not working for 1.1 MVC web templates</Title>
        <Description>Solution is to remove the Razor View precompilation package until an updated version of the package is available.</Description>
        <CreatedDate>06/02/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5577</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>throw CommandParsingException rather than crash on missing single value</Title>
    <Description>This fixes the unhandled exception thrown during parsing when a required single value for an option is not supplied, e.g. in the example of #5295. The CommandParsingException will now result in the following output:

```
Specify --help for a list of available options and commands.
Required value for option '-v' was not provided.
```

@livarcocc @piotrpMSFT @blackdwarf </Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5577</PullRequestID>
        <IssueID>7496</IssueID>
        <Title>dotnet build -v   without specifing verbosity level throws exception</Title>
        <Description>`-v` switch alone is pretty popular, since we require passing verbosity level here (i.e. `-v d`) we should at least produce some good error message

## Steps to reproduce
``




</Description>
        <CreatedDate>12/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5537</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migration: Remove System.GC.Server from runtimeconfig.template.json and inject ServerGarbageCollection property into the csproj</Title>
    <Description>Fixes #5526 

@piotrpMSFT @livarcocc @krwq @jonsequitur </Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5537</PullRequestID>
        <IssueID>7639</IssueID>
        <Title>Ensure dotnet new web and dotnet migrate does not include a runtimeconfig.template.json file to set Server GC</Title>
        <Description>Now that the SDK supports enabling Server GC via an MSBUILD property we need to ensure the templates and migrate output don't drop a runtimeconfig.template.json file in the case they only did so to enable Server GC. The web SDK will be setting this property by default.


</Description>
        <CreatedDate>31/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>In PR</Label>
          <Label>Pending Shiproom Approval</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5536</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Revert "Merge pull request #5529 from piotrpMSFT/piotrpMSFT/merge/1.0.0-rc3"</Title>
    <Description>I made a mistake merging the 1.0.0-rc3 integration into rel/1.0.0.

This change reverts #5529, if we want to revert this merge.

This reverts commit 41330f072ffc7dc9e5f5accfc34704e87e925f7b, reversing
changes made to 3eee54e4f9985f76f769d4a494a396c16944d4bb.

@livarcocc @piotrpMSFT </Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5536</PullRequestID>
        <IssueID>5529</IssueID>
        <Title>Merge 1.0.0-rc3</Title>
        <Description>Merge final RC3 changes into rel/1.0.0</Description>
        <CreatedDate>31/01/2017</CreatedDate>
        <ClosedDate>31/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5533</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>refresh enumerator when moving to next subcommand</Title>
    <Description>Subcommand argument parsing has a bug that causes some arguments to be ignored due to the same command enumerator instance was being used for different subcommands. 

This addresses #5448 specifically so the test I added uses the command line pattern from the repro, but the problem is general to all subcommands.</Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5533</PullRequestID>
        <IssueID>7593</IssueID>
        <Title>dotnet add &lt;project&gt; package no longer works</Title>
        <Description>I used to be able to specify the project path when running 'dotnet add package', but it's no longer working:

``</Description>
        <CreatedDate>25/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>RC3 Known Issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5525</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>make InvalidOperationException thrown by RunCommand graceful</Title>
    <Description>This change marks the exceptions thrown from `RunCommand.Initialize` so that they will be displayed as error messages rather than crashing the CLI and being displayed as unhandled exceptions.

It addresses #5422.</Description>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5525</PullRequestID>
        <IssueID>7582</IssueID>
        <Title>dotnet run myapp.dll crashes hard</Title>
        <Description>* Create a new dotnet app of type console
* run restore and publish 
* go to bin/debug/netcore1.1/publish 
* run "dotnet run myapp.dll" (or whatever project name you had) 

The dotnet cli (rc 4) will crash hard and show stack trace that --project is missing. 

I suggest we catch that crash and show a better message to the user along the line "if you want to run myapp.dll then just call "dotnet myapp.dll""




</Description>
        <CreatedDate>21/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>In PR</Label>
          <Label>Pending Shiproom Approval</Label>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5517</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migration: embed compiler resources</Title>
    <Description>Fixes #5477 

@piotrpMSFT @livarcocc @krwq @jonsequitur </Description>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5517</PullRequestID>
        <IssueID>7611</IssueID>
        <Title>dotnet migrate does not handle project.json embed behavior of the compiler/resources folder</Title>
        <Description>## Steps to reproduce
- Download: [CompilerEmbeddedResources.zip](https://github.com/dotnet/cli/files/734037/CompilerEmbeddedResources.zip)
- cd src/ProjectA
- `dotnet restore`
- `dotnet build`

// Note that if you look at the dll at this point the ShouldBeEmbedded.cs is embeded:
![image](https://cloud.githubusercontent.com/assets/2008729/22357055/91e578d6-e3ea-11e6-9a25-1ea9e0fa9e0e.png)

- cd ../../
- Remove the sdk from global.json
- `dotnet migrate`
- cd src/ProjectA
- `dotnet restore`
- `dotnet build`


## Expected  behavior
- Compilation succeeds just as it did in project.json land.

## Actual behavior
``





</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>In PR</Label>
          <Label>Pending Shiproom Approval</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5509</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>remove unused and incorrect localizations</Title>
    <Description>This addresses #4977. Along the way, I removed a number of localization strings that are not in use.</Description>
    <CreatedDate>29/01/2017</CreatedDate>
    <ClosedDate>08/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5509</PullRequestID>
        <IssueID>7324</IssueID>
        <Title>localized strings used as property names in RunCommand</Title>
        <Description>https://github.com/dotnet/cli/blob/706b8a802d49be079fef570b354a70056aa2ad6f/src/dotnet/commands/dotnet-run/RunCommand.cs#L70

@vsccarl that dictionary should contain the concrete property names, not descriptors thereof. Can you revert the localization here?

Notice that the dictionary is built up and then sent to a project evaluator. If these strings get localized then the evaluator will produce different behaviors based on locale.

/cc @krwq @livarcocc @jgoshi we'll need to keep an eye out for issues like this or we'll be in big trouble when @nguerrera checks in the first pass at localized strings.

@MattGertz this kind of issue is going to be tough to spot in all cases. We'll need to think about how we will set up some localized CI machines in the very near future.


edit: here as well:
https://github.com/dotnet/cli/blob/706b8a802d49be079fef570b354a70056aa2ad6f/src/dotnet/commands/dotnet-run/RunCommand.cs#L90</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5507</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>FLGMwt</FixedByID>
    <Title>use correct description string for dotnet build -h: -c</Title>
    <Description>Changed `dotnet build -h` output to use the correct string for the `--configuration` flag (it was erroneously using the same as `--framework`. 

fixes #5506 </Description>
    <CreatedDate>29/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5507</PullRequestID>
        <IssueID>7624</IssueID>
        <Title>`dotnet build -h` uses wrong description for `-c` flag (dupes the framework string)</Title>
        <Description>## Steps to reproduce

Run `dotnet build -h` for cli `rc3-004530`. Notice `-c` flag description is wrong.

``




</Description>
        <CreatedDate>29/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5493</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>display CommandParsingException gracefully</Title>
    <Description>This set of changes handles `CommandParsingException` gracefully (so as not to show the user a stack trace) and generalizes graceful exception display somewhat away from being type-specific.

It specifically addresses #5470.

</Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5493</PullRequestID>
        <IssueID>7608</IssueID>
        <Title>Exception thrown while parsing command line arguments with dotnet new</Title>
        <Description>## Steps to reproduce
`dotnet new Web1.1`
e.g. forgot the `-t`

## Expected  behavior
I expect some output that would indicate the specified arguments were invalid possibly even listing what part was invalid.  Possibly even display the --help content.  I do not expect to see an unhandled exception

## Actual behavior

``






</Description>
        <CreatedDate>26/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5492</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migrate now uses the correct TreatWarningsAsErrors property</Title>
    <Description>Fixes #5487 

@piotrpMSFT @livarcocc @krwq @jonsequitur </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5492</PullRequestID>
        <IssueID>7614</IssueID>
        <Title>dotnet migrate incorrectly migrates the "warningsAsErrors" option</Title>
        <Description>## Steps to reproduce
1. Start with a project.json with `buildOptions/warningsAsErrors`: true
2. Run `dotnet migrate` 

## Expected  behavior
The migrated project has `&lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt;` (https://github.com/dotnet/sdk/blob/master/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.Sdk.props#L78)

## Actual behavior
The migrated project has `&lt;WarningsAsErrors&gt;true&lt;/WarningsAsErrors&gt;` which isn't a property that MSBuild seems to use.

## Environment data
`dotnet --info` output:

``



</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5485</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migration: excluded files need to be removed</Title>
    <Description>Fixes #5461 

@piotrpMSFT @livarcocc @jonsequitur @krwq </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>29/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5485</PullRequestID>
        <IssueID>7603</IssueID>
        <Title>Migration: excluded files need to be removed</Title>
        <Description>If a project.json uses an exclude statement, then the migrated csproj file needs to use Remove. For example:

&amp;lt;Compile Remove="FileToRemove"/&amp;gt;

We need to do the same thing for resources too. Otherwise the migrated project fails to build.</Description>
        <CreatedDate>25/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5482</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Prevent Stage0 Environment Variables from leaking into Stage2 during execution in MSBuild</Title>
    <Description>@livarcocc @jonsequitur 

This will support #4214 </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5482</PullRequestID>
        <IssueID>6863</IssueID>
        <Title>move msbuild install into a subfolder in CLI</Title>
        <Description>## Steps to reproduce

1) Install dotnet CLI from https://dotnetcli.blob.core.windows.net/dotnet/Sdk/1.0.0-preview3-003618/dotnet-dev-win-x64.1.0.0-preview3-003618.zip . By installing, i mean extract the downloaded zip into a directory.

2) Run dotnet.exe restore on the attached project
3) Run dotnet.exe build3 to build the project.
4) Run dotnet.exe pack3 to pack - this will trigger a missing method exception.

This is because msbuild.exe loads up the wrong nuget.commands.dll .

[NetCoreCsproj.zip](https://github.com/dotnet/cli/files/483810/NetCoreCsproj.zip)
## Expected  behavior

it should load the nuget.commands.dll from %(UserProfile).nuget\packages\nuget.build.tasks.pack\3.6.0-beta.1.msbuild.10\build\netstandard1.3\nuget.commands.dll
## Actual behavior

instead it loads the dll from dotnet-dev-win-x64.1.0.0-preview3-003618\sdk\1.0.0-preview3-003618

This is not critical for preview 5 oob as long as nuget pack3 can work by putting the same dependencies in the sdk and cli. 
</Description>
        <CreatedDate>20/09/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5481</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Update THIRD-PARTY-NOTICES</Title>
    <Description>Adding Nuget.Client notices.

Fixes #4854 </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>28/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5481</PullRequestID>
        <IssueID>7259</IssueID>
        <Title>No mention of NuGet.Client in ThirdPartyNotices.txt</Title>
        <Description>A built cli includes various dlls built from from NuGet.Client project. It also includes a LICENSE file and a ThirdPartyNotices.txt. There's no mention of NuGet.Client or its license (Apache 2.0) in either the main LICENSE file or in ThirdPartyNotices.txt.</Description>
        <CreatedDate>28/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5480</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Add dotnet sln create command</Title>
    <Description>This PR adds a create subcommand within the dotnet sln command. It will
drop a predefined SLN file to disk. The commands accepts one parameter
and that is the name of the file w/ an extension. This is a pretty basic
implementation for this first turn of the crank.

Fixed #5259</Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5480</PullRequestID>
        <IssueID>7479</IssueID>
        <Title>Introduce a way to create a solution file</Title>
        <CreatedDate>10/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Area-External</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5472</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migration: support many deprecated features rather than failing migration</Title>
    <Description>Fixes #4166 

@piotrpMSFT @livarcocc @jonsequitur @krwq @piotroko </Description>
    <CreatedDate>26/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5472</PullRequestID>
        <IssueID>6828</IssueID>
        <Title>Migration: Handle Deprecated projects intelligently</Title>
        <Description>Pri-2
- [ ] Fix deprecated properties where possible
- [ ] Warn for deprecated properties with an empty value
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5446</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Port stage0 change</Title>
    <Description>Porting #5442 from master into rel/1.0.0.</Description>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5446</PullRequestID>
        <IssueID>5442</IssueID>
        <Title>Use the latest Stage0 in master</Title>
        <Description>/cc @livarcocc @jonsequitur @krwq @jgoshi 

The TestPackage restore change is necessary because it isn't reading all nuget sources when using the `--source` switch in restore.  `--source` overwrites what is in the nuget.config.  With old stage0, we are using an SDK with bug https://github.com/dotnet/sdk/issues/596.  Using a newer stage0 now has TestPackages use NETCore.App 1.1.0, which isn't in the cache and the restore fails.</Description>
        <CreatedDate>24/01/2017</CreatedDate>
        <ClosedDate>24/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5441</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Update LocalizableStrings.cs</Title>
    <Description>Change the migration after-process message with the link.

Fixes #5440 
</Description>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>24/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5441</PullRequestID>
        <IssueID>7589</IssueID>
        <Title>Migration output is confusing</Title>
        <Description>The output of the migration report is confusing if the only project fails:
``

Note that is says both `migration failed` and `Your project has been migrated`. Repo is here: https://github.com/IntelliTect/Coalesce, the Coalesce.Web project. @livarcocc



</Description>
        <CreatedDate>24/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5432</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jgoshi</FixedByID>
    <Title>Migrate sln should remove global.json from the sln file</Title>
    <Description>Fixes #5355 

@piotrpMSFT @livarcocc @krwq @jonsequitur @piotroko </Description>
    <CreatedDate>23/01/2017</CreatedDate>
    <ClosedDate>25/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>5432</PullRequestID>
        <IssueID>7540</IssueID>
        <Title>migrate command not removing global.json from solution file</Title>
        <Description>## Steps to reproduce
1. `mkdir C:\working_folder\test&amp;&amp;cd C:\working_folder\test`
1. `git clone git clone https://github.com/scottaddie/DotNetCoreSampleApp`
1. `cd DotNetCoreSampleApp`
1. Open `global.json` in text editor, change `version` property value to "1.0.0-rc3-004504", and save file
1. `dotnet migrate DotNetCoreSampleApp.sln`
1. Open migrated solution in VS 2017 RC3, and notice that the `global.json` appears with a red X next to it in Solution Explorer:
![global_json_failed_load](https://cloud.githubusercontent.com/assets/10702007/22002925/a1c0794c-dc04-11e6-8da7-0450014fcb45.png)

## Expected  behavior
The `global.json` file entry should probably be removed from the solution file, and this file shouldn't be listed in Solution Explorer.

## Actual behavior
The `global.json` file entry isn't being removed from the solution file, yet it was moved to the "backup" folder.

## Environment data
`dotnet --info` output:
``





</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>RC3 Known Issue</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4928</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Allow CLI CI servers to opt out of test</Title>
    <Description>Enables signing builds to opt out of running CLI tests. These tests run in PR validation builds and we've not caught any issues in the second layer of testing. This will allow speeding up end-to-end CLI builds.

/cc @eerhardt @livarcocc @krwq @jgoshi 

/approvers: @srivatsn @MattGertz 

Fixes #3527 </Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>05/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4928</PullRequestID>
        <IssueID>6398</IssueID>
        <Title>We should shut off tests in our official VSO builds</Title>
        <Description>Our build takes away too long for such a small product.  We should consider not running tests on our official VSO bulids. Our tests take up the bulk of the time in an official build. The "Test and Package" step in our Win x64 build takes 35 minutes, while the entire build takes 66 minutes.

Instead, we can have a "rolling CI" build on the side running the tests. That way the official build can be published as fast as possible - which is necessary when we want to spin multiple re-builds of the whole .NET Core stack.

@Petermarcu @piotrpMSFT @brthor @livarcocc 
</Description>
        <CreatedDate>11/06/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4923</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Add more xlf files for new strings</Title>
    <Description>More xlf conversions for recently merged PRs with new strings.

There is still one more round of conversion needed after #4901 and #4902 are merged. Let's leave this open until those are merged and I'll update this PR accordingly.

@piotrpMSFT, @livarcocc for code review

@MattGertz for ask mode approval

@nataliatgit, @janbaltus FYI





</Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>05/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4923</PullRequestID>
        <IssueID>4901</IssueID>
        <Title>Localize dotnet-remove-p2p</Title>
        <Description>This was written after we started localizing and has references to a non-existent LocalizableStrings file, such as LocalizableStrings.RequiredArgumentNotPassed. I'm not sure what the text is for these strings.
</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4923</PullRequestID>
        <IssueID>4902</IssueID>
        <Title>Localization for dotnet-new command</Title>
        <Description>
        </Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4922</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>enricosada</FixedByID>
    <Title>[WIP] use Sdk attribute in F# templates too</Title>
    <Description>The idea is to bundle **only** the `Sdk` directory of package `FSharp.NET.Sdk`. The other target file are not needed because these inside restored package are used, not these embeeded (so less code for sdk, and easier for me to update f# afterwards, if needed).
 
The rest of targets files required for F# will be used after restore from `PackageReference` `Fsharp.NET.Sdk`, but at least i can hook inside normal `LanguageTarget` ( ref dotnet/sdk#448 ) for f#, so the flow for c# and f# is the same. The trick is to import FSharp.NET.Sdk **before** microsoft.net.sdk, to populate `LanguageTargets` property.

pratically the embedded sdk include is:

```xml
&lt;PropertyGroup Condition=" '$(LanguageTargets)' == '' and '$(MSBuildProjectExtension)' == '.fsproj' "&gt;

  &lt;!-- On restore --&gt;
  &lt;LanguageTargets Condition=" '$(FSharpLanguageTargets)' == '' "&gt;$(MSBuildThisFileDirectory)Sdk.OnRestore.targets&lt;/LanguageTargets&gt;

  &lt;!-- Normal commands --&gt;
  &lt;LanguageTargets Condition=" '$(FSharpLanguageTargets)' != '' "&gt;$(FSharpLanguageTargets)&lt;/LanguageTargets&gt;
&lt;/PropertyGroup&gt;
```

At `dotnet restore` is imported the $(MSBuildToolsPath)\Microsoft.Common.targets, so restore target exists.
After the `dotnet restore`, the `FSharpLanguageTargets` property is auto-added by the props file inside `FSharp.NET.Sdk` package so can be used to hook usual f# target file for `CoreCompile`.

Like that, c# and f# templates are aligned, the cli contains just the minimal files required (2 sdk files, 1 empty props file) to use a *symbolic* sdk package (ref #1436 )

Checking the bundle locally (take a bit of time the build on my machine), but the sdk import mechanism works ok.

- [ ] bundle only `Sdk` directory of `FSharp.NET.Sdk` package
- [x] template console
- [x] template lib
- [x] template mstest
- [x] template xunit
- [ ] template web

/cc @piotrpMSFT @livarcocc for cli
/cc @dsplaisted @rainersigwald @nguerrera for sdk
/cc  @cartermp @KevinRansom @cloudRoutine for F#
</Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>07/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4922</PullRequestID>
        <IssueID>448</IssueID>
        <Title>Scripts changes to accomodate centos builds. </Title>
        <Description>Does not contain changes to actually build CLI on centos.
</Description>
        <CreatedDate>09/12/2015</CreatedDate>
        <ClosedDate>16/12/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4922</PullRequestID>
        <IssueID>1436</IssueID>
        <Title>restore the NoPackage switch for VSO signing build</Title>
        <Description>Not the prettiest. Ideally, the VSO build would just call a different target so we could have a consistent interface, but I didn't have time to hack that about. This is easier :).

/cc @livarcocc @Sridhar-MS @davidfowl 
</Description>
        <CreatedDate>16/02/2016</CreatedDate>
        <ClosedDate>16/02/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4895</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Include Microsoft.Net.Sdk in CLI layout</Title>
    <Description>Helps towards #4887 

Adds publishing of Microsoft.Net.Sdk to the CLI layout. Adds one-line addition of new SDKs through BundledSdks.props.

/cc @MattGertz @srivatsn @dsplaisted @livarcocc @mlorbetske </Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>03/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4895</PullRequestID>
        <IssueID>7280</IssueID>
        <Title>Update CLI to include offline SDKs for Web and Core</Title>
        <Description> - [x] Update MSBuild to 15.1.0-preview-000451-02
 - [x] Add Core SDK to CLI layout
 - [x] Add Web SDK to CLI layout
 - [x] Add NuGet Pack SDK to CLI layout
 - [ ] Add Test SDK to CLI layout
 - [x] Update Core Template
 - [x] Update Web Template


/cc @srivatsn @dsplaisted @MattGertz @rainersigwald @AndyGerlicher @Sarabeth-Jaffe-Microsoft  @blackdwarf @livarcocc @mlorbetske @rrelyea </Description>
        <CreatedDate>01/12/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4890</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Centralize Microsoft.Net.SDK Version</Title>
    <Description>Builds on #4889 
Centralizes definition of Microsoft.Net.SDK version in CLI repo
Omits the versions in the `dotnet new` templates as these must be static

/cc @jgoshi @krwq @livarcocc @MattGertz @srivatsn for review</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4890</PullRequestID>
        <IssueID>4889</IssueID>
        <Title>Update CLI's MSBuild Version to 15.1.0-preview-000451-02</Title>
        <Description>Builds on #4888 
Updates MSBuild Version number per #4887 

@jgoshi @livarcocc @MattGertz @srivatsn @krwq please take a look and approve</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>02/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4889</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Update CLI's MSBuild Version to 15.1.0-preview-000451-02</Title>
    <Description>Builds on #4888 
Updates MSBuild Version number per #4887 

@jgoshi @livarcocc @MattGertz @srivatsn @krwq please take a look and approve</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4889</PullRequestID>
        <IssueID>4888</IssueID>
        <Title>Centralize definition of MSBuild Version in CLI</Title>
        <Description>This build infrastructure change will assist with #4887. It moves the CLI's dependency version for MSBuild to a common props file and wires up the remainder of the build system to utilize the single version via dir.props pattern from corefx.</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>02/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4889</PullRequestID>
        <IssueID>7280</IssueID>
        <Title>Update CLI to include offline SDKs for Web and Core</Title>
        <Description> - [x] Update MSBuild to 15.1.0-preview-000451-02
 - [x] Add Core SDK to CLI layout
 - [x] Add Web SDK to CLI layout
 - [x] Add NuGet Pack SDK to CLI layout
 - [ ] Add Test SDK to CLI layout
 - [x] Update Core Template
 - [x] Update Web Template


/cc @srivatsn @dsplaisted @MattGertz @rainersigwald @AndyGerlicher @Sarabeth-Jaffe-Microsoft  @blackdwarf @livarcocc @mlorbetske @rrelyea </Description>
        <CreatedDate>01/12/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4888</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Centralize definition of MSBuild Version in CLI</Title>
    <Description>This build infrastructure change will assist with #4887. It moves the CLI's dependency version for MSBuild to a common props file and wires up the remainder of the build system to utilize the single version via dir.props pattern from corefx.</Description>
    <CreatedDate>02/12/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4888</PullRequestID>
        <IssueID>7280</IssueID>
        <Title>Update CLI to include offline SDKs for Web and Core</Title>
        <Description> - [x] Update MSBuild to 15.1.0-preview-000451-02
 - [x] Add Core SDK to CLI layout
 - [x] Add Web SDK to CLI layout
 - [x] Add NuGet Pack SDK to CLI layout
 - [ ] Add Test SDK to CLI layout
 - [x] Update Core Template
 - [x] Update Web Template


/cc @srivatsn @dsplaisted @MattGertz @rainersigwald @AndyGerlicher @Sarabeth-Jaffe-Microsoft  @blackdwarf @livarcocc @mlorbetske @rrelyea </Description>
        <CreatedDate>01/12/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4843</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Thealexbarney</FixedByID>
    <Title>Add InstallDir to path if SDK version is already installed</Title>
    <Description>Fixes #4792 by ensuring that the SDK install directory is added to the current path if the requested SDK version is already installed.

The script checks if the directory is in the path before adding it to avoid re-adding it if running the script multiple times, but it doesn't check if it's at the beginning of the path. This could possibly result in hiding the new installed SDK if the install directory is already in the path, and is listed after another directory containing dotnet.

Is this even an issue worth worrying about, or should the check simply be removed and the directory added even if it's already in the current path?</Description>
    <CreatedDate>24/11/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4843</PullRequestID>
        <IssueID>7215</IssueID>
        <Title>dotnet-install.ps1 doesn't add InstallDir to the path if the specified version is already installed</Title>
        <Description>## Steps to reproduce
Install any cli version that isn't installed:
`.\dotnet-install.ps1 -Version 1.0.0-preview3-003170`

InstallDir is added to the path, and the sdk version is as expected:
`$env:Path.split(";")`

`dotnet --version`
`1.0.0-preview3-003170`

Open a new PowerShell and install the same cli version again:
`.\dotnet-install.ps1 -Version 1.0.0-preview3-003170`

InstallDir is not added to the path, and the sdk version is the one in the main path:
`dotnet --version`
`1.0.0-preview3-004056`

## Expected  behavior
InstallDir is added to the path. This is the same if InstallDir is specified or is the default.

## Actual behavior
InstallDir is not added to the path.

## Environment data
`dotnet --info` output:
.NET Command Line Tools (1.0.0-preview3-004056)

Product Information:
 Version:            1.0.0-preview3-004056
 Commit SHA-1 hash:  ccc4968bc3

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x64





</Description>
        <CreatedDate>20/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4836</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>enricosada</FixedByID>
    <Title>Update fsharp templates for preview4 with latest msbuild style</Title>
    <Description>- add test for all `dotnet-new` templates
- align to version attributes (and #4821):
  - [x] `web`
  - [x] xunit (aligned but using package version of commit eb8e0cfa409d2ef89091f2058487be0e48e8a32e)
  - [x] console
  - [x] lib
  - [x] mstest
</Description>
    <CreatedDate>24/11/2016</CreatedDate>
    <ClosedDate>28/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4836</PullRequestID>
        <IssueID>4821</IssueID>
        <Title>Update CLI `new` templates from SDK repo</Title>
        <Description>Fixes https://github.com/dotnet/cli/issues/4820

@livarcocc @krwq @MattGertz @srivatsn can  you sign off please?

@mlorbetske I don't have new Web templates. Are those incoming?</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>04/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4831</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>phenning</FixedByID>
    <Title>Update Web Template from Template repo</Title>
    <Description>Fixes #4830 

@mlorbetske @piotrpMSFT  @MattGertz @srivatsn can you sign off please?

</Description>
    <CreatedDate>23/11/2016</CreatedDate>
    <ClosedDate>23/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4831</PullRequestID>
        <IssueID>7240</IssueID>
        <Title>Update Web Templates to the latest</Title>
        <Description>
        </Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4829</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jeffkl</FixedByID>
    <Title>Move project.lock.json during migration</Title>
    <Description>1. I updated the tests to expect project.lock.json as well, should I just leave it out of the tests?
2. I generated the test assets project.lock.json by running restore.  This means they are correct but are quite large.  Should I just make them be empty files?

Closes #4753</Description>
    <CreatedDate>23/11/2016</CreatedDate>
    <ClosedDate>23/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4829</PullRequestID>
        <IssueID>7185</IssueID>
        <Title>project.lock.json isn't moved out of root folder.</Title>
        <Description>## Steps to reproduce
migrate project/solution

## Expected  behavior
all files from previous version that aren't used anymore should be moved into backup folder

## Actual behavior
xproj.user and project.lock.json aren't moved





</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4824</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>MSBuildSDKsPath</Title>
    <Description>Fixes #4822 by exposing MSBuildSDKsPath to MSBuild when invoked from CLI.
Adds stub SDKs to enable end-to-end testing.

@mlorbetske @srivatsn can you link issues tracking adding `real` updated SDKs to CLI?

@livarcocc @krwq can you review?

@AndyGerlicher @kieranmo FYI 

@MattGertz this will need your approval to merge


@enricosada note that #4822 introduces an additional model for referencing SDKs in .NET Core. For RC2 we're implementing the model but not an extensibility model. Your existing integration via NuPkg will continue to work. We are looking into the benefit of extensibility for this model and will share with you once we have some kind of plan. For the time being we'll test it with the in-box SDKs but will reach out asap.</Description>
    <CreatedDate>23/11/2016</CreatedDate>
    <ClosedDate>24/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4824</PullRequestID>
        <IssueID>7236</IssueID>
        <Title>Add MSBuildSDKsPath to MSBuild invocations</Title>
        <Description>CLI portion of https://gist.github.com/piotrpMSFT/9ab355cd48a5539c9fc31bafd98df5aa</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4824</PullRequestID>
        <IssueID>7236</IssueID>
        <Title>Add MSBuildSDKsPath to MSBuild invocations</Title>
        <Description>CLI portion of https://gist.github.com/piotrpMSFT/9ab355cd48a5539c9fc31bafd98df5aa</Description>
        <CreatedDate>23/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4793</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Add the path to the dotnet being used to --info</Title>
    <Description>- Please add description for changes you are making.
Utilize ApplicationEnvironment.ApplicationBasePath of DotNet.PlatformAbstractions

Output from Windows
```bat
C:\Users&gt;dotnet --info
.NET Command Line Tools (1.0.0-preview4-004109)

Product Information:
 Version:            1.0.0-preview4-004109
 Commit SHA-1 hash:  98a3974557

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\1.0.0-preview4-004109
```

Output from Ubuntu
```bash
xingmu@xingmu-UX31A:~/Documents/cli/artifacts/ubuntu.16.04-x64/stage2$ ./dotnet --info
.NET Command Line Tools (1.0.0-preview4-004109)

Product Information:
 Version: 1.0.0-preview4-004109
 Commit SHA-1 hash: 98a3974557

Runtime Environment:
 OS Name: ubuntu
 OS Version: 16.04
 OS Platform: Linux
 RID: ubuntu.16.04-x64
 Base Path: /home/xingmu/Documents/cli/artifacts/ubuntu.16.04-x64/stage2/sdk/1.0.0-preview4-004109
```

- If there is an issue related to this PR, please add the reference.
#3900</Description>
    <CreatedDate>20/11/2016</CreatedDate>
    <ClosedDate>21/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4793</PullRequestID>
        <IssueID>6657</IssueID>
        <Title>dotnet --info should display the path to the dotnet being used</Title>
        <Description>Very useful as a developer of the CLI where usually I have a few versions installed. I believe that would be useful in general as well.
</Description>
        <CreatedDate>20/07/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>fit-n-finish</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4782</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dasMulli</FixedByID>
    <Title>Remove unused lock file read from tool resolving logic.</Title>
    <Description>During tool resolving, the project's lock / assets file is read unnecessarily.

Removing this code also fixes an exception that occurs when the file cannot be read, e.g. when the project hasn't been restored:
```
$ dotnet sfsgas
System.AggregateException: One or more errors occurred. (Could not access assets file.) ---&gt; System.InvalidOperationException: Could not access assets file.
   at Microsoft.DotNet.Cli.Utils.FileAccessRetrier.&lt;RetryOnFileAccessFailure&gt;d__0`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at NuGet.Common.ConcurrencyUtilities.&lt;ExecuteWithFileLockedAsync&gt;d__2`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Microsoft.DotNet.Cli.Utils.LockFileFormatExtensions.&lt;ReadWithLock&gt;d__2.MoveNext()
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at Microsoft.DotNet.Cli.Utils.MSBuildProject.GetLockFile()
   at Microsoft.DotNet.Cli.Utils.ProjectToolsCommandResolver.ResolveFromProjectTools(CommandResolverArguments commandResolverArguments)
   at Microsoft.DotNet.Cli.Utils.ProjectToolsCommandResolver.Resolve(CommandResolverArguments commandResolverArguments)
   at Microsoft.DotNet.Cli.Utils.CompositeCommandResolver.Resolve(CommandResolverArguments commandResolverArguments)
   at Microsoft.DotNet.Cli.Utils.CommandResolver.TryResolveCommandSpec(ICommandResolverPolicy commandResolverPolicy, String commandName, IEnumerable`1 args, NuGetFramework framework, String configuration, String outputPath, String applicationName)
   at Microsoft.DotNet.Cli.Utils.Command.Create(ICommandResolverPolicy commandResolverPolicy, String commandName, IEnumerable`1 args, NuGetFramework framework, String configuration, String outputPath, String applicationName)
   at Microsoft.DotNet.Cli.Utils.Command.Create(String commandName, IEnumerable`1 args, NuGetFramework framework, String configuration, String outputPath, String applicationName)
   at Microsoft.DotNet.Cli.Program.ProcessArgs(String[] args, ITelemetry telemetryClient)
   at Microsoft.DotNet.Cli.Program.Main(String[] args)
---&gt; (Inner Exception #0) System.InvalidOperationException: Could not access assets file.
   at Microsoft.DotNet.Cli.Utils.FileAccessRetrier.&lt;RetryOnFileAccessFailure&gt;d__0`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at NuGet.Common.ConcurrencyUtilities.&lt;ExecuteWithFileLockedAsync&gt;d__2`1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Microsoft.DotNet.Cli.Utils.LockFileFormatExtensions.&lt;ReadWithLock&gt;d__2.MoveNext()&lt;---
```

cc @livarcocc @piotrpMSFT </Description>
    <CreatedDate>18/11/2016</CreatedDate>
    <ClosedDate>19/11/2016</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>4763</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>dasMulli</FixedByID>
    <Title>Show nuget and msbuild commands in dotnet-help</Title>
    <Description>This adds both `nuget` and `msbuild` verbs to the output of `dotnet help` as it isn't obvious that they exists (#4762).
I "borrowed" the msbuild text from https://docs.microsoft.com/en-us/dotnet/articles/core/preview3/tools/dotnet-msbuild.

fixes #4700

cc @blackdwarf @piotrpMSFT 
I heard there is a loc freeze coming up 🔜 </Description>
    <CreatedDate>17/11/2016</CreatedDate>
    <ClosedDate>18/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4763</PullRequestID>
        <IssueID>7193</IssueID>
        <Title>Add `dotnet nuget` and `dotnet msbuild` to --help output</Title>
        <Description>## Steps to reproduce
When using dotnet-cli on non-Windows machines, you are able to make use of `dotnet pack` to prepare your NuGet packages for publishing, but still need to use `nuget push` to finish the job. Unfortunately this relies on Mono which has issues with certain SSL ciphers and TLS 1.2. Which means you cannot publish NuGet packages and must use Windows. [Here](https://bugzilla.xamarin.com/show_bug.cgi?id=26658) is a Xamarin bug tracking one of these.

## Expected  behavior
`dotnet pack publish`

## Actual behavior
Need to use `nuget push` on Windows.

## Environment data
NET Command Line Tools (1.0.0-preview2-003148)

Product Information:
 Version:            1.0.0-preview2-003148
 Commit SHA-1 hash:  18ca244551

Runtime Environment:
 OS Name:     Mac OS X
 OS Version:  10.11
 OS Platform: Darwin
 RID:         osx.10.11-x64



</Description>
        <CreatedDate>17/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4763</PullRequestID>
        <IssueID>7144</IssueID>
        <Title>dotnet --help does not contain all of the commands</Title>
        <Description>## Steps to reproduce
Install latest from rel/1.0.0. Type `dotnet --help`. 

## Expected  behavior
See all of the commands that are in the package with the CLI, most notably `migrate`. 

## Actual behavior
The following is returned:

``

Ideally,  we would add `msbuild` and `nuget` here as well and separate the commands per their main use into two groups (main commands, "raw" commands). The groups can be called something else, but the idea is for the user to have an immidiate insight into what to use. 





</Description>
        <CreatedDate>13/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4740</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Hide restore output of first-run experience</Title>
    <Description>Fixes issue #4066 

Issue was caused by CommandFactory + BuiltInCommand

The command factory recognized `restore` as a Built-In Command and, presumably to avoid a process hop, ran the command in-proc as a BuiltInCommand. This works very well for in-proc built-in commands but not so well for built-in commands that then invoke another command out of proc.

Since we were in a built-in command, only the stdout and stderr of the current process were captured. As soon as `dotnet restore` triggered a `dotnet msbuild /t:restore` the output of the child process was not captured and therefore displayed to the user.

The fix here was to change the invocation from CommandFactory to simply `new Command`. Since this is an invocation that happens very infrequently I chose to ignore that `dotnet new` could run in proc and `dotnet restore` out of proc to minimize the code change.

We need to rationalize the intent of the CommandFactory sometime soon and do a broader cleanup.</Description>
    <CreatedDate>16/11/2016</CreatedDate>
    <ClosedDate>28/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4740</PullRequestID>
        <IssueID>6755</IssueID>
        <Title>dotnet first run experience printing restore information</Title>
        <Description>Fix the printout and update the test to compare a Equals and not just a starts with. That's how this regressed.
## Steps to reproduce

Delete the sentinel from the NuGet cache folder for the version of the CLI you are using.
Run dotnet new
## Expected  behavior

See the first run experience printout without the restore print for the temporary project we create.
## Actual behavior

Note the restore information below.
## Welcome to .NET Core!

Learn more about .NET Core @ https://aka.ms/dotnet-docs. Use dotnet --help to see available commands or go to https://aka.ms/dotnet-cli-docs.
## Telemetry

The .NET Core tools collect usage data in order to improve your experience. The data is anonymous and does not include commandline arguments. The data is collected by Microsoft and shared with the community.
You can opt out of telemetry by setting a DOTNET_CLI_TELEMETRY_OPTOUT environment variable to 1 using your favorite shell.
You can read more about .NET Core tools telemetry @ https://aka.ms/dotnet-cli-telemetry.
## Configuring...

A command is running to initially populate your local package cache, to improve restore speed and enable offline access. This command will take up to a minute to complete and will only happen once.
Decompressing 100% 6629 ms
Expanding 100% 4267 ms
log  : Restoring packages for /private/var/folders/qw/s8blrphs09jb9nh0x9x6bjpr0000gn/T/f5xh1utx.0ms/project.json...
log  : Writing lock file to disk. Path: /private/var/folders/qw/s8blrphs09jb9nh0x9x6bjpr0000gn/T/f5xh1utx.0ms/project.lock.json
log  : /private/var/folders/qw/s8blrphs09jb9nh0x9x6bjpr0000gn/T/f5xh1utx.0ms/project.json
log  : Restore completed in 828ms.
Project Microsoft.DotNet.ProjectModel (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.Cli.Utils (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.Files (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.Compiler.Common (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project Microsoft.Extensions.Testing.Abstractions (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.InternalAbstractions (.NETStandard,Version=v1.3) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.Archive (.NETStandard,Version=v1.3) was previously compiled. Skipping compilation.
Project Microsoft.DotNet.Configurer (.NETStandard,Version=v1.6) was previously compiled. Skipping compilation.
Project dotnet (.NETCoreApp,Version=v1.0) will be compiled because inputs were modified
</Description>
        <CreatedDate>19/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4673</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Eliminate imports from CLI, where possible</Title>
    <Description>Fixes #2242

We've come a long way :)

See commit comments for notes on what stayed.

/CC @davidfowl @livarcocc @jgoshi @krwq @Petermarcu </Description>
    <CreatedDate>10/11/2016</CreatedDate>
    <ClosedDate>10/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4673</PullRequestID>
        <IssueID>5572</IssueID>
        <Title>Remove imports from dotnet</Title>
        <Description>We need to see if we still need these:

https://github.com/dotnet/cli/blob/rel/1.0.0/src/dotnet/project.json#L67-L69

Right now they are hiding incompatibilities that should be fixed
</Description>
        <CreatedDate>03/04/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4657</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Invoking a command waits up to 30s for NuGet or another process</Title>
    <Description>@livarcocc @jgoshi 

Fixes #4592 </Description>
    <CreatedDate>08/11/2016</CreatedDate>
    <ClosedDate>09/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4657</PullRequestID>
        <IssueID>7076</IssueID>
        <Title>lock contention for tool project.assets.json causes tests to fail in CI</Title>
        <CreatedDate>02/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4654</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>333fred</FixedByID>
    <Title>Cleaned up dotnet migrate help text</Title>
    <Description>Change the help text for dotnet migrate -r to mention that a file needs to be given, added periods to the end of all sentences. This fixes #4653.

@piotrpMSFT 
</Description>
    <CreatedDate>08/11/2016</CreatedDate>
    <ClosedDate>09/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4654</PullRequestID>
        <IssueID>7112</IssueID>
        <Title>Help text for migrate -r is unclear</Title>
        <Description>## Steps to reproduce
Using 1.0.0-preview3-004056, run `dotnet migration -h`.

## Expected  behavior
The help text for `-r` mentions that it expects a parameter for the file to store the migration log in.

## Actual behavior
No mention of a needed parameter.

While I'm at it, there is inconsistent use of periods at the end of sentences.

@piotrpMSFT.</Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4286</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Add support for publishing self-contained applications.</Title>
    <Description>Fix #4204

@livarcocc @brthor @Sridhar-MS 

@livarcocc - I'm adding a temporary MSBuild project with PackageReferences, so I can use it to publish self-contained.  This test project can be removed when you get the real MSBuildTestApp converted to PackageReference.
</Description>
    <CreatedDate>30/09/2016</CreatedDate>
    <ClosedDate>03/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4286</PullRequestID>
        <IssueID>6853</IssueID>
        <Title>Need to create MSBuild-based "publish" command</Title>
        <Description>Today there is no MSBuild-based "publish" command.  We should create one that publishes MSBuild projects and takes the applicable options that `dotnet publish` takes today.

In order to provide the correct behavior for self-contained apps, we need https://github.com/NuGet/Home/issues/3465 to be supported.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4281</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Support developing on new versions of a supported OS</Title>
    <Description>Adding "BuildRid" to the CLI as a fallback RID to use when inferring which RID to use when building, running, and publishing self-contained applications.

This enables users to use the CLI on newer versions of the OS that aren't fully supported yet - for example using a new OSX version that isn't listed in the runtime graph in the current NuGet packages.

Fix #4238

@livarcocc @brthor @Sridhar-MS @ericstj @gkhanna79 
</Description>
    <CreatedDate>30/09/2016</CreatedDate>
    <ClosedDate>03/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4281</PullRequestID>
        <IssueID>6873</IssueID>
        <Title>Cannot restore packages for self-contained application on macOS Sierra 10.12-x64</Title>
        <Description>On macOS Sierra I cannot restore packages for a dotnet app that I build as a self-contained/standalone app. 
## Steps to reproduce

This is what my project.json file looks like in order to build it self-contained:

``

If I remove the 10.12-x64 runtime reference and add `"type": "platform"` to the app declaration I am able to restore and run. This was working as a self contained app on osx10.11. 
</Description>
        <CreatedDate>23/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4254</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Sridhar-MS</FixedByID>
    <Title>Add support to migrate a directory.</Title>
    <Description>- Given a directory migrate all the project.jsons in it recursively.
- Remove '-p/--project' option. Instead directly pass a directory or project.json as argument.
- Add tests.

Fixes 1 and 3 in #4167 

cc @brthor @livarcocc @eerhardt 
</Description>
    <CreatedDate>26/09/2016</CreatedDate>
    <ClosedDate>29/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4254</PullRequestID>
        <IssueID>6829</IssueID>
        <Title>Migration: Migrate sets of projects</Title>
        <Description>- [x] Allow for the first argument to dotnet-migrate to be a path (remove `-p`) (https://github.com/dotnet/cli/pull/4254)
- [x] If that path has a project, use that and it's P2P dependencies (https://github.com/dotnet/cli/pull/4221)
- [x] Otherwise recursively search for projects and their P2P dependencies (https://github.com/dotnet/cli/pull/4254)
- [x] Allow for `--global-json` or `-g` to migrate all projects found under a global.json as an alternative to the above options (https://github.com/dotnet/cli/pull/4305)
- [x] Add switch to opt out of P2P following (https://github.com/dotnet/cli/pull/4221)
</Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4242</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Add support for Migration defaults</Title>
    <Description>Still working on the tests, but functionality is there.

Fixes #4120 
Fixes #4100 

@eerhardt @Sridhar-MS @livarcocc 
</Description>
    <CreatedDate>23/09/2016</CreatedDate>
    <ClosedDate>20/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4242</PullRequestID>
        <IssueID>6796</IssueID>
        <Title>Migration: Add capability for consuming a Defaults Snapshot </Title>
        <Description>Currently, the Migration tool will output properties even if their value is the same as the default in the sdk.

Add capability for creating a snapshot of these defaults and consuming it in the migration tool so these properties won't be output when the value is equal to the default.
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4242</PullRequestID>
        <IssueID>6783</IssueID>
        <Title>Migration: Redesign TransformApplicator</Title>
        <Description>Based on feedback from @livarcocc 
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4237</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Add `dotnet publish3` command</Title>
    <Description>Partial fix for #4204

@brthor @livarcocc @Sridhar-MS 
</Description>
    <CreatedDate>23/09/2016</CreatedDate>
    <ClosedDate>26/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4237</PullRequestID>
        <IssueID>6853</IssueID>
        <Title>Need to create MSBuild-based "publish" command</Title>
        <Description>Today there is no MSBuild-based "publish" command.  We should create one that publishes MSBuild projects and takes the applicable options that `dotnet publish` takes today.

In order to provide the correct behavior for self-contained apps, we need https://github.com/NuGet/Home/issues/3465 to be supported.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4229</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Create a `dotnet msbuild` command and fill out the applicable command line arguments to `dotnet build3`.</Title>
    <Description>Fix #4203

@livarcocc @brthor @Sridhar-MS 

/cc @dotnet/msbuild - FYI to review the mappings between `dotnet build` args to MSBuild concepts.
</Description>
    <CreatedDate>22/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4229</PullRequestID>
        <IssueID>6852</IssueID>
        <Title>Need to create MSBuild-based "build" command</Title>
        <Description>Today we have `dotnet build3`, but that command acts more like `dotnet msbuild`, since it only passed the specified arguments through to msbuild.  It doesn't take the same args that `dotnet build` took: `--output`, `--framework`, `--configuration` etc.

We should create a command that builds MSBuild based projects and takes the applicable options that `dotnet bulid` took.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4224</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Migration: Remove dependency on lock file and dotnet restore</Title>
    <Description>Migrates XProj -&gt; Csproj references. Fixes #4122 
Migrates project dependencies per framework in the project. Fixes #4223 
Removes the dependency on the lock file and dotnet restore. Fixes #4215 

@eerhardt @Sridhar-MS @livarcocc @emgarten @rrelyea  

Still seeing a couple local test failures on OS X, putting up for xplat test results. 
</Description>
    <CreatedDate>22/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4224</PullRequestID>
        <IssueID>6797</IssueID>
        <Title>Migration: Migrate XProj Project To Project References</Title>
        <Description>discussed with @abpiskunov 

To do this we will:
1.  search the xproj for `ProjectReference` items
2. collect a unique set of includes
3. ensure the projects referenced by the includes are unresolved in the lock file, else throw (overlapping dependency)
4. Migrate these to ProjectReference items in the new csproj
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4224</PullRequestID>
        <IssueID>6867</IssueID>
        <Title>Migration: Migrate ProjectDependencies for each framework</Title>
        <Description>Migrate the project dependencies for each framework in the project and add a condition to their item group.
</Description>
        <CreatedDate>22/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4224</PullRequestID>
        <IssueID>6864</IssueID>
        <Title>Migration: Remove dependency on Restore</Title>
        <Description>Use nuget's project discovery code to remove migration's dependency on the lock file.
</Description>
        <CreatedDate>21/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4220</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Migrate xproj to csproj dependencies</Title>
    <Description>@Sridhar-MS @eerhardt @livarcocc 

Fixes #4122 
</Description>
    <CreatedDate>22/09/2016</CreatedDate>
    <ClosedDate>22/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4220</PullRequestID>
        <IssueID>6797</IssueID>
        <Title>Migration: Migrate XProj Project To Project References</Title>
        <Description>discussed with @abpiskunov 

To do this we will:
1.  search the xproj for `ProjectReference` items
2. collect a unique set of includes
3. ensure the projects referenced by the includes are unresolved in the lock file, else throw (overlapping dependency)
4. Migrate these to ProjectReference items in the new csproj
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4218</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>juergenhoetzel</FixedByID>
    <Title>Handle OS detection errors</Title>
    <Description>@brthor Updated my outdated pull request https://github.com/dotnet/cli/pull/3188

Check the exit status of get_latest_version_info and get_current_os_name to
prevent construction of invalid download URLs based on these functions.
Fixes #2923.
</Description>
    <CreatedDate>21/09/2016</CreatedDate>
    <ClosedDate>23/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4218</PullRequestID>
        <IssueID>6021</IssueID>
        <Title>install.sh should fail when OS is not detected correctly</Title>
        <Description>## Steps to reproduce

Go to not supported OS and install.sh
## Expected  behavior

Error about wrong OS
## Actual behavior

Error is being displayed but script keeps going
## Environment data

`dotnet --info` output:

See this for reference:
https://github.com/dotnet/cli/issues/2918
</Description>
        <CreatedDate>06/05/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>fit-n-finish</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4216</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Project Json mapping migration support</Title>
    <Description>Support for migrating project.json mappings. Fixes #4097
Supporting excludes inside configurations, with item remove. Fixes #4107 
Supporting Framework based build options. Fixes #4201 

Also tests for all these things and their combinations.

cc @eerhardt @livarcocc @Sridhar-MS 
</Description>
    <CreatedDate>21/09/2016</CreatedDate>
    <ClosedDate>21/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4216</PullRequestID>
        <IssueID>6780</IssueID>
        <Title>Migrations: Migrate "mappings"</Title>
        <Description>Migrate the mappings from IncludeContext in project.json
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4216</PullRequestID>
        <IssueID>6788</IssueID>
        <Title>Migration: Support `exclude` in `configuration-&gt;buildOptions`</Title>
        <Description>This is blocked on the item remove syntax being supported in .net core MSBuild, which should be available after the build for this PR is available.

https://github.com/Microsoft/msbuild/pull/922
</Description>
        <CreatedDate>26/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4216</PullRequestID>
        <IssueID>6850</IssueID>
        <Title>Migration: Add support for buildOptions under "frameworks"</Title>
        <Description>See here: https://github.com/dotnet/cli/issues/3577#issuecomment-248127898

Add support for buildOptions under "frameworks" node.
</Description>
        <CreatedDate>19/09/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4191</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>naamunds</FixedByID>
    <Title>Upload checksums for installation artifacts</Title>
    <Description>The checksums are SHA-512 hashes, which users can use to verify file
integrity and authenticity.

Fixes #3693.

cc: @livarcocc @blackdwarf @MichaelSimons 
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>12/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4191</PullRequestID>
        <IssueID>6508</IssueID>
        <Title>CLI builds should produce SHA hashes for artifacts</Title>
        <Description>The CLI builds should be producing SHA hashes for the various artifacts that customers would download on their machine.  This will allow them to do checksum verification to ensure MITM has not occurred.  

This is needed for the [.NET Dockerfiles](https://github.com/dotnet/dotnet-docker) as it is part of the criteria for making the .NET images official Docker images.

@blackdwarf 
</Description>
        <CreatedDate>24/06/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4187</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eyoung100</FixedByID>
    <Title>Adding Support for Distribution Agnostic Installer</Title>
    <Description>- If this PR should not run tests please add text "skip[REMOVE_THIS]ci[REMOVE_THIS]please" (remove the marked text, no quotes).
- Please add description for changes you are making.
- If there is an issue related to this PR, please add the reference.

I'd like to add Gentoo support to the installer so I can test the cli.  I'll submit more pull requests as I find more roadblocks but this is the first.  See Issue #1835 and Issue #3714.  See also: https://github.com/gentoo/dotnet
</Description>
    <CreatedDate>16/09/2016</CreatedDate>
    <ClosedDate>22/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4187</PullRequestID>
        <IssueID>5374</IssueID>
        <Title>Cannot run build.sh on Gentoo due to 404 error</Title>
        <Description>## Steps to reproduce
1. Clone the `cli` repo.
2. Execute `build.sh` on Linux (Gentoo) on branch `rel/1.0.0` or `master`.
## Expected  behavior

Build progresses successfully.
## Actual behavior

Build fails trying to download `dotnet.tar.gz`.

On `rel/1.0.0`:

``
</Description>
        <CreatedDate>14/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4187</PullRequestID>
        <IssueID>6523</IssueID>
        <Title>Provide a default linux friendly installer</Title>
        <Description>Currently you have provided downloads for 7-8 linux distributions, however there are 1000 of linux distros out there.

Please provide a unix friendly installation method from source. This way distributions like Arch, Gentoo, Slackware and other non deb,rpm based can use dotnet core.
## Expected  behavior

`wget http://.....source.tar.gz`
`./configure` - should show you if some dependancy is missing 
`make` - should build it if configure was successful
`make install` - should install it on the right folders and should add dotnetcore and other commands in /usr/bin or similar

Also when distribute source or binary always include an md5 checksum of the file.
</Description>
        <CreatedDate>28/06/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4178</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>kotovaleksandr</FixedByID>
    <Title>fix #4090</Title>
    <Description>fix for #4090 
</Description>
    <CreatedDate>14/09/2016</CreatedDate>
    <ClosedDate>15/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4178</PullRequestID>
        <IssueID>6774</IssueID>
        <Title>Object reference not set to an instance of an object on build resx file</Title>
        <Description>## Steps to reproduce

Add to project folder resx file with content like:
`&lt;data name="Error_InvalidLicense" xml:space="preserve"&gt;Invalid license key&lt;/data&gt;`
## Expected  behavior

Compilation succeeded
## Actual behavior

System.NullReferenceException: Object reference not set to an instance of an object.
   at Microsoft.DotNet.Tools.Resgen.ResourcesFileGenerator.Generate(ResourceFile sourceFile, Stream outputStream)
   at Microsoft.DotNet.Tools.Resgen.ResgenCommand.Execute()
   at Microsoft.DotNet.Tools.Resgen.ResgenCommand.Run(IEnumerable`1 inputFiles, String culture, String outputFile, String version, IEnumerable`1 compilationReference)
## Environment data

`dotnet --info` output:
.NET Command Line Tools (1.0.0-preview3-003223)

Product Information:
 Version:            1.0.0-preview3-003223
 Commit SHA-1 hash:  9d3b727392

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14905
 OS Platform: Windows
 RID:         win10-x64

Exception occurred on code (ResourcesFileGenerator):
var name = e.Attribute("name").Value;
var value = **e.Element("value")**.Value;
rw.AddResource(name, value);

Code try read value as nested tag, but in my resx value contained in tag-value (worked for .NET 4.6).
I can fix this behavior (read value as attribute or from tag value) and send PR.
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>resgen</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4132</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Add Scripts environment variable support</Title>
    <Description>This isn’t exactly equivalent to the project.json behavior with Environment variables, in project.json if a variable failed to resolve as a cli script variable, or environment variable, it would just leave the variable there

In this change, the variable won’t be there, it’ll be blank. Given that that scenario is almost definitely a programmer error, and mimicking that behavior will put plenty of ugliness in the migrated csproj, I think the tradeoff is acceptable

@eerhardt @livarcocc

Fixes #4125

Going to merge when green, received :shipit: on closed PR.
</Description>
    <CreatedDate>31/08/2016</CreatedDate>
    <ClosedDate>01/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4132</PullRequestID>
        <IssueID>6800</IssueID>
        <Title>Migration: Support Script environment variables</Title>
        <Description>project.json scripts support environment variables as variables passed to the script
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4128</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Add Scripts environment variable support</Title>
    <Description>This isn’t exactly equivalent to the project.json behavior with Environment variables, in project.json if a variable failed to resolve as a cli script variable, or environment variable, it would just leave the variable there

In this change, the variable won’t be there, it’ll be blank. Given that that scenario is almost definitely a programmer error, and mimicking that behavior will put plenty of ugliness in the migrated csproj, I think the tradeoff is acceptable

@eerhardt @livarcocc 

Fixes #4125 
</Description>
    <CreatedDate>30/08/2016</CreatedDate>
    <ClosedDate>31/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4128</PullRequestID>
        <IssueID>6800</IssueID>
        <Title>Migration: Support Script environment variables</Title>
        <Description>project.json scripts support environment variables as variables passed to the script
</Description>
        <CreatedDate>30/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4104</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>MichaelSimons</FixedByID>
    <Title>Modified logic dotnet-install.ps1 to provide better diagnostics upon failure</Title>
    <Description>fixes #4103 

cc @eerhardt @jasonwilliams200OK 
</Description>
    <CreatedDate>26/08/2016</CreatedDate>
    <ClosedDate>26/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4104</PullRequestID>
        <IssueID>6785</IssueID>
        <Title>dotnet-install.ps1 should provider better diagnostic information when download fails.</Title>
        <Description>## Steps to reproduce
1.  Disable network adaptor
2.  Run dotnet-install.ps1
## Expected  behavior

Some type of diagnostic information indicating the artifacts failed to download.
## Actual behavior

``
</Description>
        <CreatedDate>26/08/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4083</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Update to new msbuild</Title>
    <Description>Update to version of msbuild that includes microsoft/msbuild#935

@eerhardt 
</Description>
    <CreatedDate>24/08/2016</CreatedDate>
    <ClosedDate>24/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4083</PullRequestID>
        <IssueID>935</IssueID>
        <Title>Download the stage0 dotnet tools from the beta feed.</Title>
        <Description>Set the correct channel so that the stage0 binaries are downloaded correctly.

``

/cc: @brthor 
</Description>
        <CreatedDate>21/01/2016</CreatedDate>
        <ClosedDate>21/01/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4053</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>joelverhagen</FixedByID>
    <Title>Populate .deps.json path property with path property from lock file</Title>
    <Description>This is step #3 in this NuGet issue: https://github.com/NuGet/Home/issues/2522. This work is also tracked by this CLI issue: https://github.com/dotnet/cli/issues/2874.

This PR adds a `"path"` property to the `"libraries"` entries in the `.deps.json` file. For packages, this is the relative path appended to the global packages folder (or fallback folder) to access the package's assets. For projects and other library types, this value is null.

After this work, the .NET Core host process needs to be modified to prefer this property over the concatenation of the package ID and version.
</Description>
    <CreatedDate>16/08/2016</CreatedDate>
    <ClosedDate>18/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4053</PullRequestID>
        <IssueID>4285</IssueID>
        <Title>man pages for dotnet</Title>
        <Description>dotnet executable should support printing its own usage instructions. The same should be printed when calling 'man dotnet'
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>packaging</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4032</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>joelverhagen</FixedByID>
    <Title>Add "path" property to .deps.json file libraries</Title>
    <Description>This is step #3 in this NuGet issue: https://github.com/NuGet/Home/issues/2522. This work is also tracked by this CLI issue: https://github.com/dotnet/cli/issues/2874.

This PR adds a `"path"` property to the `"libraries"` entries in the `.deps.json` file. For packages, this is the relative path appended to the global packages folder (or fallback folder) to access the package's assets. For projects and other library types, this value is null.

After this work, the .NET Core host process need to be modified to prefer this property over the concatenation of the package ID and version.

/cc @eerhardt @emgarten @rrelyea @piotrpMSFT 
</Description>
    <CreatedDate>11/08/2016</CreatedDate>
    <ClosedDate>11/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4032</PullRequestID>
        <IssueID>4285</IssueID>
        <Title>man pages for dotnet</Title>
        <Description>dotnet executable should support printing its own usage instructions. The same should be printed when calling 'man dotnet'
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>packaging</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4020</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Move CLI Build to MSBuild 00024-160610</Title>
    <Description>Part 2 of #4019 
</Description>
    <CreatedDate>09/08/2016</CreatedDate>
    <ClosedDate>09/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4020</PullRequestID>
        <IssueID>4019</IssueID>
        <Title>Fix for #4018</Title>
        <Description>#4018 broke Stage0 because Microsoft.Build.dll expects to find MSBuild.exe next to itself. This is a temporary workaround which bin-places MSBuild.exe into the root directory, unblocking MSBuild. Once this change is in it will again break Stage 0 because the stage0  version of Microsoft.Build.dll now has a higher assembly version number. Once that Stage 0 is in place I will follow up with another PR which rev's the dependencies of the build project and thereby stabilize Stage0.
</Description>
        <CreatedDate>09/08/2016</CreatedDate>
        <ClosedDate>09/08/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4019</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Fix for #4018</Title>
    <Description>#4018 broke Stage0 because Microsoft.Build.dll expects to find MSBuild.exe next to itself. This is a temporary workaround which bin-places MSBuild.exe into the root directory, unblocking MSBuild. Once this change is in it will again break Stage 0 because the stage0  version of Microsoft.Build.dll now has a higher assembly version number. Once that Stage 0 is in place I will follow up with another PR which rev's the dependencies of the build project and thereby stabilize Stage0.
</Description>
    <CreatedDate>09/08/2016</CreatedDate>
    <ClosedDate>09/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4019</PullRequestID>
        <IssueID>4018</IssueID>
        <Title>Update MSBUILD</Title>
        <Description>Moves to latest msbuild NuGet packages.

Fixes a test which fails when re-run on a given machine
Works around packaging issue in msbuild which omits MSBuild.exe.config from the nuget package.

/cc @eerhardt @livarcocc @brthor @anurse @rainersigwald
</Description>
        <CreatedDate>08/08/2016</CreatedDate>
        <ClosedDate>08/08/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4013</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Update HelpCommand.cs</Title>
    <Description>Changing the text from "Common Commands" to just "Commands" to indicate that these are in the box, so to speak.

Fixes #3814 

/cc @brthor @piotrpMSFT @svick 
</Description>
    <CreatedDate>07/08/2016</CreatedDate>
    <ClosedDate>10/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4013</PullRequestID>
        <IssueID>6598</IssueID>
        <Title>Change "Common commands" in the "--help" screen in dotnet</Title>
        <Description>`dotnet --help` lists seven "common commands." Are there any others? What are they?

``

I tried `dotnet help commands` but got an error:

&gt; No executable found matching command "dotnet-commands"
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4000</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>MichaelSimons</FixedByID>
    <Title>Modified dotnet-install.ps1 to support Nano Server</Title>
    <Description>Fixes #3113

cc @krwq @Priya91 @mellinoe 
</Description>
    <CreatedDate>04/08/2016</CreatedDate>
    <ClosedDate>10/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>4000</PullRequestID>
        <IssueID>6160</IssueID>
        <Title>dotnet-install.ps1 should work on NanoServer</Title>
        <Description>Download and run https://raw.githubusercontent.com/dotnet/cli/rel/1.0.0/scripts/obtain/dotnet-install.ps1 on a NanoServer.

**Actual Results:**
powershell : new-object : Cannot find type [net.webclient]: verify that the assembly 
    + CategoryInfo          : NotSpecified: (new-object : Ca...t the assembly :String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError

containing this type is loaded.
At line:1 char:9
- &amp;{iex ((new-object net.webclient).DownloadString('https://raw.githubu ...
-         ~~~~~~~~~~~~~~~~~~~~~~~~
  - CategoryInfo          : InvalidType: (:) [New-Object], PSArgumentExcepti 
    on
  - FullyQualifiedErrorId : TypeNotFound,Microsoft.PowerShell.Commands.NewOb 
    jectCommand

**Expected Results:**
Script should install the dotnet cli successfully.

The script is using Invoke-WebRequest which is based on net.webclient.  I believe you need to use HttpClient in order for it to work on Nano.
</Description>
        <CreatedDate>18/05/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2102</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Sridhar-MS</FixedByID>
    <Title>Fix version badges to display Nuget Version of cli.</Title>
    <Description>We started using the nuget version in rest of our build scripts.
Fixes - #2099

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2102)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>29/03/2016</CreatedDate>
    <ClosedDate>29/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2102</PullRequestID>
        <IssueID>5490</IssueID>
        <Title>Install specific dotnet cli version from install.ps1 or install.sh</Title>
        <Description>## Steps to reproduce

Using the script https://raw.githubusercontent.com/dotnet/cli/rel/1.0.0/scripts/obtain/install.ps1 ( or [install.sh](https://raw.githubusercontent.com/dotnet/cli/rel/1.0.0/scripts/obtain/install.sh) ) to install a specific version

The `Latest` version works, the specific version doesnt works /cc @Sridhar-MS @krwq

The issue is the same for all os

That's really important for ci scenario, so it's possibile to pin a specific version

For example win:

``
## Environment data

Latest source
</Description>
        <CreatedDate>28/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2086</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>enricosada</FixedByID>
    <Title>fix F# build, missing default.win32manifest</Title>
    <Description>fix #2085

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2086)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>27/03/2016</CreatedDate>
    <ClosedDate>28/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2086</PullRequestID>
        <IssueID>5484</IssueID>
        <Title>f# build fail with missing default.win32manifest</Title>
        <Description>## Steps to reproduce

``
## Expected  behavior

build successful
## Actual behavior

compile error: error FS0193: Could not find file `default.win32manifest`
## Environment data

`dotnet --version` output:

1.0.0-beta-002060
</Description>
        <CreatedDate>27/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2083</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>schellap</FixedByID>
    <Title>Resolve hostpolicy from deps file in exec mode</Title>
    <Description>@gkhanna79 PTAL.

For the `dotnet run` scenario, `hostpolicy.dll` itself has to be loaded from the additional probing path (nuget cache).

This PR can go in post #2080 and a new host package is uploaded.

Cc @brthor

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2083)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>27/03/2016</CreatedDate>
    <ClosedDate>28/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2083</PullRequestID>
        <IssueID>2080</IssueID>
        <Title>Packaging work for corehost</Title>
        <Description>&lt;!-- Reviewable:start --&gt;

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2080)

&lt;!-- Reviewable:end --&gt;
</Description>
        <CreatedDate>26/03/2016</CreatedDate>
        <ClosedDate>29/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2076</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>enricosada</FixedByID>
    <Title>compile-fsc, support debugType and fix</Title>
    <Description>add to compile-fsc (f#):
- support property `compilationOptions.debugType` of `project.json`
  the &lt;value&gt; is passed as argument `--debug:&lt;value&gt;` to fsc
  like portablepdb ( ref Microsoft/visualfsharp#999 ). 
  if not specified, default is old behaviour (pdbonly on windows, none on osx/unix) 
- fix do not copy `FSharp.Core` to output dir ( ref Microsoft/visualfsharp#894 )

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2076)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>26/03/2016</CreatedDate>
    <ClosedDate>26/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2076</PullRequestID>
        <IssueID>999</IssueID>
        <Title>[WiP] Refactoring test scripts</Title>
        <CreatedDate>23/01/2016</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2076</PullRequestID>
        <IssueID>894</IssueID>
        <Title>Fix fsharp target framework</Title>
        <Description>fix #692 
- use `--targetprofile:netcore` if target framework is coreclr
- add nuget.conf to make restore safe
- use rc2 because it's requried by fsharp.core
</Description>
        <CreatedDate>19/01/2016</CreatedDate>
        <ClosedDate>25/01/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2035</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Changing --version in the CLI</Title>
    <Description>`dotnet --version` returns just the version number. This helps tools get this information without having to parse the full info.
Introduce a new argument `--info` that returns the current "long form". With this, we also change the long form to say "RID" instead of "Runtime ID" simply because that would avoid any future localization issues and thus make the parsing easier.

Fix #1607 #1882 

@blackdwarf @piotrpMSFT @davidfowl @anurse

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2035)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>24/03/2016</CreatedDate>
    <ClosedDate>25/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2035</PullRequestID>
        <IssueID>5225</IssueID>
        <Title>dotnet --version-minimal</Title>
        <Description>For our CoreClr gating mechanism and for anywhere else we want to machine read the version it would be very helpful if there was a "--version-minimal" which only returned the version without the OS version and everything else.

So, instead of

``
</Description>
        <CreatedDate>26/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2035</PullRequestID>
        <IssueID>5388</IssueID>
        <Title>Need a way to obtain the current runtime id from the CLI</Title>
        <Description>We need a way of asking the .NET CLI what is the runtime id for the current computer. It looks like it may be possible to do this by scrapping the output of 'dotnet.exe --version'. As long as we don't care about localizing 'runtime id', and as long as restoring for 'win10-x64' will restore 'win7-x64' packages (for example) then I think we are already good.

Otherwise I would propose a 'dotnet.exe --runtimeId' which will list the current runtime id that we should use for restoring.
</Description>
        <CreatedDate>15/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2022</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Publish all installers/archives for sharedfx, host, and the sdk</Title>
    <Description>Publishing for debs, pkgs, msis, with appropriate versions dependent on the package type (host, sdk, sharedfx)

Also unify versions of all installers to the semantic version.

Fixes #2007 

Worked with @krwq to get this tested and ready.

cc @Sridhar-MS @piotrpMSFT

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2022)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>24/03/2016</CreatedDate>
    <ClosedDate>24/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2022</PullRequestID>
        <IssueID>5449</IssueID>
        <Title>Ubuntu Latest links are not getting updated with recent builds</Title>
        <Description>The installer links on the [Readme](https://github.com/dotnet/cli/blob/rel/1.0.0/README.md) for Ubuntu are out of date.  The readme indicates the current version is 1.0.0.001971 yet the installers are for 1.0.0.001793.

https://dotnetcli.blob.core.windows.net/dotnet/beta/Installers/Latest/dotnet-ubuntu-x64.latest.deb
https://dotnetcli.blob.core.windows.net/dotnet/beta/Binaries/Latest/dotnet-dev-ubuntu-x64.latest.tar.gz

I took a cursory look and it appears this regression may have been introduced during the refactoring work to replace the scripts with build targets.  I do not see any logic that is updating the latest installer links for ubuntu builds - https://github.com/dotnet/cli/blob/rel/1.0.0/scripts/dotnet-cli-build/PublishTargets.cs
</Description>
        <CreatedDate>23/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2015</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>ellismg</FixedByID>
    <Title>Fix permissions when packaging artifacts</Title>
    <Description>The file permissions in our cross platform packages were all over the
place. Problems included:
- Executable text files
- Executable MSIL files
- Files not readable by world or group

In addition to just looking bad, it could cause problems in cases where
someone takes the tarballs and copies them to a global location (as
root) because now the deps file was not readable by non root users.

Add an additional step when setting everything up to put sensible
permissions on everything before building os specific packages and
tarballs.

Fixes #2004

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2015)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>23/03/2016</CreatedDate>
    <ClosedDate>25/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2015</PullRequestID>
        <IssueID>5446</IssueID>
        <Title>dotnet execution fails with "invalid .deps" file error due to permissions issue in the tarball</Title>
        <Description>## Steps to reproduce
1. Download the latest RHEL CLI tarball from https://dotnetcli.blob.core.windows.net/dotnet/beta/Binaries/Latest/dotnet-dev-rhel-x64.latest.tar.gz
2. Unpack the file into *_/opt/dotnet *_ with sudo privilege. 
3. Set below environment settings to execute .NET Core
   
    export DOTNET_HOME=/opt/dotnet
    PATH=$PATH:/opt/dotnet
4. execute below
   
    dotnet --version
## Expected  behavior

``

Changing the permission set manually to files under /opt/dotnet resolves the issue. 
## Environment data

`dotnet --version` output: 

1.0.0.001946
</Description>
        <CreatedDate>23/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2003</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Clean up PublishTargets</Title>
    <Description>fixes #2002 

cc @naamunds @piotrpMSFT

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/2003)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>23/03/2016</CreatedDate>
    <ClosedDate>23/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>2003</PullRequestID>
        <IssueID>5445</IssueID>
        <Title>Clean up PublishTargets</Title>
        <Description>Filing this to track cleaning up/factoring some code merged as a part of dotnet/cli#1890
</Description>
        <CreatedDate>23/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1999</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Fix Manpage Path</Title>
    <Description>Dependent on #1890 but don't want to kill that test run, so opening up separately.

Puts the dotnet manage in the host deb package and the rest in the sdk package

cc @piotrpMSFT

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1999)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>22/03/2016</CreatedDate>
    <ClosedDate>22/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1999</PullRequestID>
        <IssueID>1890</IssueID>
        <Title>Fix the Debian Package for SharedFx, Publish all to our Repo</Title>
        <Description>cc @livarcocc @anurse 

Let's see if this works

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1890)

&lt;!-- Reviewable:end --&gt;
</Description>
        <CreatedDate>15/03/2016</CreatedDate>
        <ClosedDate>23/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1991</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Peter-Schneider</FixedByID>
    <Title>AnsiConsole color handling</Title>
    <Description>PR #1660 has alredy been merged - but there are actually two `AnsiConsole` classes (one in namespace `Microsoft.DotNet.Cli.Build.Framework` (which has been patched with the previous change) and the other in namespace `Microsoft.DotNet.Cli.Utils`.
With this PR both classes handle the colors in the same way.

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1991)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>22/03/2016</CreatedDate>
    <ClosedDate>22/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1991</PullRequestID>
        <IssueID>1660</IssueID>
        <Title>Fix for issue #1656</Title>
        <CreatedDate>02/03/2016</CreatedDate>
        <ClosedDate>14/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1989</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Peter-Schneider</FixedByID>
    <Title>AnsiConsole color handling</Title>
    <Description>PR #1660 has alredy been merged - but there are actually two `AnsiConsole` classes (one in namespace `Microsoft.DotNet.Cli.Build.Framework` and the other in namespace `Microsoft.DotNet.Cli.Utils`.
With this PR both classes handle the colors in the same way.

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1989)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>22/03/2016</CreatedDate>
    <ClosedDate>22/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1989</PullRequestID>
        <IssueID>1660</IssueID>
        <Title>Fix for issue #1656</Title>
        <CreatedDate>02/03/2016</CreatedDate>
        <ClosedDate>14/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1971</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>Sridhar-MS</FixedByID>
    <Title>Fix 'version' to display commit sha.</Title>
    <Description>Fixes #1958
</Description>
    <CreatedDate>21/03/2016</CreatedDate>
    <ClosedDate>21/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1971</PullRequestID>
        <IssueID>5417</IssueID>
        <Title>Command dotnet --version doesn't print commit SHA any more.</Title>
        <Description>``
</Description>
        <CreatedDate>20/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1947</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Disable deb creation &amp; publishing</Title>
    <Description>Temporarily disabling Debian. While PR #1890 is getting quite close, there is still work there and we need to unblock builds.
</Description>
    <CreatedDate>18/03/2016</CreatedDate>
    <ClosedDate>18/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1947</PullRequestID>
        <IssueID>1890</IssueID>
        <Title>Fix the Debian Package for SharedFx, Publish all to our Repo</Title>
        <Description>cc @livarcocc @anurse 

Let's see if this works

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1890)

&lt;!-- Reviewable:end --&gt;
</Description>
        <CreatedDate>15/03/2016</CreatedDate>
        <ClosedDate>23/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1946</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>jamesqo</FixedByID>
    <Title>Fix a couple of typos in the .md/doc files</Title>
    <Description>A bit of a follow-up on #1945. I noticed there were a bunch of typos in some of the `.md` files, so with the help of `sed -i` I replaced some of them. Here are some of the replaced words:
- intermmediate =&gt; intermediate
- compilerOptions =&gt; compilationOptions
- emitEntryPoints =&gt; emitEntryPoint

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1946)

&lt;!-- Reviewable:end --&gt;
</Description>
    <CreatedDate>18/03/2016</CreatedDate>
    <ClosedDate>22/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1946</PullRequestID>
        <IssueID>1945</IssueID>
        <Title>Fix typo in CompileCommand class name</Title>
        <Description>Happened to notice a typo while reading the source code over, so I did a `sed -i s/Commpile/Compile/g` replacement to fix it. :smile:

&lt;!-- Reviewable:start --&gt;

---

This change is [&lt;img src="https://reviewable.io/review_button.svg" height="35" align="absmiddle" alt="Reviewable"/&gt;](https://reviewable.io/reviews/dotnet/cli/1945)

&lt;!-- Reviewable:end --&gt;
</Description>
        <CreatedDate>18/03/2016</CreatedDate>
        <ClosedDate>22/03/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1930</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Tools on the Shared FX and using NuGet tool restore</Title>
    <Description>Changes are all over the place here. 
Have this working locally but is blocked on #1920 before going in.

The weird commits here are because I needed latest from rel that #1920 hadn't picked up yet. As that PR gets closer to merging, these will shake out.

Putting up primarily for feedback in the meantime.

cc @joelverhagen @piotrpMSFT @Sridhar-MS @schellap @anurse @pakrym
</Description>
    <CreatedDate>17/03/2016</CreatedDate>
    <ClosedDate>17/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1930</PullRequestID>
        <IssueID>1920</IssueID>
        <Title>Incorporate the new CLI layout in builds scripts and add Portable Project Tool commands</Title>
        <Description>- Layout the Sdk, SharedFx and SharedHost in the stage1 and stage2 dirs.
- Create only 2 zips/tar files 
  - `dotnet` - contains shared fx and shared host.
  - `dotnet-dev` - contains shared fx, cli sdk and shared host.
- There is still work that needs to be done for the installers.
  - Need to create a `dotnet` redist for both osx and windows. This will have sharedfx and shared host.
  - Need to create a `dotnet-dev` installer for osx. This will contains sharedfx, shared host and cli sdk.

cc: @piotrpMSFT @brthor
</Description>
        <CreatedDate>17/03/2016</CreatedDate>
        <ClosedDate>18/03/2016</ClosedDate>
        <Labels>
          <Label>blocking-partner</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1930</PullRequestID>
        <IssueID>1920</IssueID>
        <Title>Incorporate the new CLI layout in builds scripts and add Portable Project Tool commands</Title>
        <Description>- Layout the Sdk, SharedFx and SharedHost in the stage1 and stage2 dirs.
- Create only 2 zips/tar files 
  - `dotnet` - contains shared fx and shared host.
  - `dotnet-dev` - contains shared fx, cli sdk and shared host.
- There is still work that needs to be done for the installers.
  - Need to create a `dotnet` redist for both osx and windows. This will have sharedfx and shared host.
  - Need to create a `dotnet-dev` installer for osx. This will contains sharedfx, shared host and cli sdk.

cc: @piotrpMSFT @brthor
</Description>
        <CreatedDate>17/03/2016</CreatedDate>
        <ClosedDate>18/03/2016</ClosedDate>
        <Labels>
          <Label>blocking-partner</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1911</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>schellap</FixedByID>
    <Title>Fix casing of shared and add DT_DIR to readdir</Title>
    <Description>Fixes #1908
</Description>
    <CreatedDate>16/03/2016</CreatedDate>
    <ClosedDate>16/03/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>1911</PullRequestID>
        <IssueID>5396</IssueID>
        <Title>Corehost doesn't mux properly on Unix</Title>
        <Description>## Steps to reproduce
1. Be on a Mac (maybe Linux too?)
2. Download and unpack the latest package from here: https://dotnetcli.blob.core.windows.net/dotnet/beta/Binaries/Latest/dotnet-combined-framework-sdk-host-osx-x64.latest.tar.gz
   1. `curl -O https://dotnetcli.blob.core.windows.net/dotnet/beta/Binaries/Latest/dotnet-combined-framework-sdk-host-osx-x64.latest.tar.gz`
   2. `tar -xf dotnet-combined-framework-sdk-host-osx-x64.latest.tar.gz`
3. Run `./dotnet --help` from that directory
## Expected  behavior

To see the `dotnet` CLI help
## Actual behavior

No output.

With `COREHOST_TRACE` on:

``

/cc @schellap
</Description>
        <CreatedDate>16/03/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>blocking-partner</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>108</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>blackdwarf</FixedByID>
    <Title>Add "about" in the Readme.</Title>
    <Description>Fixes #71 

/cc @richlander 
</Description>
    <CreatedDate>28/10/2015</CreatedDate>
    <ClosedDate>17/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>108</PullRequestID>
        <IssueID>4336</IssueID>
        <Title>What is this repo?</Title>
        <Description>It is conventional for a repo's README.md to give a brief description of what the repo is about. This repo's README gives requirements, hints for building and testing, but no hint as to what the repo is about.
</Description>
        <CreatedDate>19/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>93</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>davidfowl</FixedByID>
    <Title>Fix quoting of arguments to handle things with spaces in them</Title>
    <Description>Partially fixes #57 
</Description>
    <CreatedDate>22/10/2015</CreatedDate>
    <ClosedDate>22/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>93</PullRequestID>
        <IssueID>4324</IssueID>
        <Title>Fix command line execution quoting</Title>
        <Description>It's inconsistent and broken when running cmd vs when running an exe directly.
</Description>
        <CreatedDate>16/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>78</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Package publishing scripts</Title>
    <Description>These are the scripts to publish our deb package to our PPA, sans secrets.

The secrets are intended to be provided via environment variables, and are defined at the beginning of each file.

The "repoapi_client.sh" file was provided by the PPA infrastructure team in Azure.

Fixes #20 
</Description>
    <CreatedDate>20/10/2015</CreatedDate>
    <ClosedDate>21/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>78</PullRequestID>
        <IssueID>4298</IssueID>
        <Title>Setup publishing of Debian packages</Title>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Infrastructure</Label>
          <Label>packaging</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>61</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>JunTaoLuo</FixedByID>
    <Title>Copying content files during publish</Title>
    <Description>#51
</Description>
    <CreatedDate>17/10/2015</CreatedDate>
    <ClosedDate>19/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>61</PullRequestID>
        <IssueID>4320</IssueID>
        <Title>Publish should copy content - other files</Title>
        <Description>We do this in dnx today to copy other files (like config files) to the output directory.
</Description>
        <CreatedDate>16/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>50</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>Package Tool</Title>
    <Description>resolves #25 

This is a tool to produce a debian package from a build output directory structure. 
See the issue above or included readme for details on that structure.
</Description>
    <CreatedDate>16/10/2015</CreatedDate>
    <ClosedDate>17/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>50</PullRequestID>
        <IssueID>4303</IssueID>
        <Title>Package creation should consume build output based on directory conventions</Title>
        <Description>Let's try to avoid having to touch the packaging scripts when adding stuff to the package layout
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>packaging</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>42</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>ahsonkhan</FixedByID>
    <Title>Adding logging based on levels (Error only to Debug)</Title>
    <Description>Issue #13 
</Description>
    <CreatedDate>12/10/2015</CreatedDate>
    <ClosedDate>02/12/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>42</PullRequestID>
        <IssueID>4291</IssueID>
        <Title>Output Verbosity</Title>
        <Description>How do we want to handle verbosity of what is written by the CLI?
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>38</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>ahsonkhan</FixedByID>
    <Title>Driver help: dotnet --help command</Title>
    <Description>Issue #23 
</Description>
    <CreatedDate>09/10/2015</CreatedDate>
    <ClosedDate>18/11/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>38</PullRequestID>
        <IssueID>4301</IssueID>
        <Title>dotnet --help command</Title>
        <Description>should support both --help and invalid input.
</Description>
        <CreatedDate>07/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6</IssueID>
    <RepoID>cli</RepoID>
    <FixedByID>brthor</FixedByID>
    <Title>dotnet-commands Command</Title>
    <Description>Command to list all available commands available on the path.

Works by searching for the dotnet- prefix.
Only the last two commits are interesting here. 

The command exists at dotnet_package/builtins/dotnet-commands

Resolves #2 
</Description>
    <CreatedDate>06/10/2015</CreatedDate>
    <ClosedDate>09/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>cli</RepoID>
        <PullRequestID>6</PullRequestID>
        <IssueID>4284</IssueID>
        <Title>'dotnet commands' command</Title>
        <Description>dotnet-commands should enumerate all executables on the path that match the 'dotnet-' preamble. The preamble should not be displayed in the output. So, if we have:

``
</Description>
        <CreatedDate>05/10/2015</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>

  <PullRequest>
    <IssueID>11059</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Improving error message when targeting pack is not found</Title>
    <Description>Fixes #10748</Description>
    <CreatedDate>30/03/2020</CreatedDate>	
    <ClosedDate>31/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>11059</PullRequestID>
        <IssueID>10748</IssueID>
        <Title>Improve error message when targeting pack is not found</Title>
        <Description>- Make sure that there is no .NET Core 3.0 targeting pack in the dotnet root folder (ie packs\Microsoft.NETCore.App.Ref\3.0.0 should not exist)
- Create a project targeting .NET Core 3.0
- Build the project
- Delete the .NET Core 3.0 targeting pack from the NuGet global packages folder (ie `C:\Users\&lt;user&gt;\.nuget\packages\microsoft.netcore.app.ref\3.1.0`)
- Build the project without an implicit restore (ie `dotnet msbuild`)

**EXPECTED:** Build should fail with message that targeting pack needs to be restored
**ACTUAL:** `error NETSDK1073: The FrameworkReference 'Microsoft.NETCore.App' was not recognized`

The current error message is misleading, and is the same as the message you'd get if you tried to reference a nonexistent FrameworkReference</Description>
        <CreatedDate>02/03/2020</CreatedDate>
        <ClosedDate>31/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11057</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Merge release/5.0.1xx-preview2 to master</Title>
    <Description>#10979 included some commits master already had, abandoning it and making a manual merge</Description>
    <CreatedDate>30/03/2020</CreatedDate>
    <ClosedDate>31/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>11057</PullRequestID>
        <IssueID>10979</IssueID>
        <Title>[automated] Merge branch 'release/5.0.1xx-preview2' =&gt; 'master'</Title>
        <Description>I detected changes in the release/5.0.1xx-preview2 branch which have not been merged yet to master. I'm a robot and am configured to help you automatically keep master up to date, so I've opened this PR.

This PR merges commits made on release/5.0.1xx-preview2 by the following committers:

* dotnet-maestro[bot]
* wli3
* ViktorHofer
* dsplaisted
* zivkan

## Instructions for merging from UI

This PR will not be auto-merged. When pull request checks pass, complete this PR by creating a merge commit, *not* a squash or rebase commit.

&lt;img alt="merge button instructions" src="https://i.imgur.com/GepcNJV.png" width="300" /&gt;

If this repo does not allow creating merge commits from the GitHub UI, use command line instructions.

## Instructions for merging via command line

Run these commands to merge this pull request from the command line.

``

&lt;/details&gt;

Contact .NET Core Engineering if you have questions or issues.
Also, if this PR was generated incorrectly, help us fix it. See https://github.com/dotnet/arcade/blob/master/scripts/GitHubMergeBranches.ps1.
</Description>
        <CreatedDate>24/03/2020</CreatedDate>
        <ClosedDate>30/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>11024</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>MSLukeWest</FixedByID>
    <Title>[Port from 3.1.3] Updating ComputeFilesCopiedToPublishDir to work during design time builds</Title>
    <Description>Manually porting this change since I knew there would be merge conflicts: https://github.com/dotnet/sdk/pull/10907

Fixing a regression caused by my previous change: #10600

That change incorrectly made PublishItemsOutputGroup depend on the targets that actually copy build artifacts instead of the ones that just compute their paths. Since this output group is frequently used during design time builds this caused failures in the case where the build artifacts don't exist yet.

Also adding tests that explicitly add the requirement that this output group should be able to build without the existence of all the publishing artifacts.</Description>
    <CreatedDate>27/03/2020</CreatedDate>
    <ClosedDate>30/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>11024</PullRequestID>
        <IssueID>10600</IssueID>
        <Title>Updating PublishItemsOutputGroup to handle single file publish scenario</Title>
        <Description>Right now we're using the ResolvedFileToPublish item group, but this doesn't take into account the single file scenario.  So I'm creating a new item group that will track what actually gets placed in the publish directory.

I intentionally didn't remove items from ResolvedFileToPublish since that is used in several other targets files.

I plan on also consuming this new item group from the wapproj targets.</Description>
        <CreatedDate>04/02/2020</CreatedDate>
        <ClosedDate>07/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10981</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Automatically reference assembly packs for .NET Framework</Title>
    <Description>Fixes #4009</Description>
    <CreatedDate>24/03/2020</CreatedDate>
    <ClosedDate>27/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>10981</PullRequestID>
        <IssueID>4009</IssueID>
        <Title>Automatically reference .NET Framework reference assembly packages if needed</Title>
        <Description>We've recently released [Microsoft.NETFramework.ReferenceAssemblies packages](https://www.nuget.org/packages/Microsoft.NETFramework.ReferenceAssemblies/) which support building projects targeting .NET Framework on systems without the corresponding reference assembly packages installed globally (for example on a non-Windows machine).

Now that the packages are available, we should update the SDK to automatically include the reference when needed.

Related: #335, dotnet/designs#33</Description>
        <CreatedDate>05/12/2019</CreatedDate>
        <ClosedDate>27/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10842</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>zivkan</FixedByID>
    <Title>Update dependencies from https://github.com/NuGet/NuGet.Client build …</Title>
    <Description>…5.6.0.6489 (#10813)

- NuGet.Build.Tasks - 5.6.0-preview.2.6489

Co-authored-by: dotnet-maestro[bot] &lt;dotnet-maestro[bot]@users.noreply.github.com&gt;</Description>
    <CreatedDate>12/03/2020</CreatedDate>
    <ClosedDate>12/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>10842</PullRequestID>
        <IssueID>10813</IssueID>
        <Title>[master] Update dependencies from nuget/nuget.client</Title>
        <Description>This pull request updates the following dependencies

[marker]: &lt;&gt; (Begin:be39118f-8347-4151-a885-08d7219800a1)
## From https://github.com/NuGet/NuGet.Client
- **Subscription**: be39118f-8347-4151-a885-08d7219800a1
- **Build**: 5.6.0.6489
- **Date Produced**: 3/6/2020 4:17 AM
- **Commit**: 5433d816f748d4ad78b75fc320397d8117f57771
- **Branch**: refs/heads/dev
- **Updates**:
  - **NuGet.Build.Tasks** -&gt; 5.6.0-preview.2.6489

[marker]: &lt;&gt; (End:be39118f-8347-4151-a885-08d7219800a1)

</Description>
        <CreatedDate>10/03/2020</CreatedDate>
        <ClosedDate>10/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10810</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't run tests for official builds</Title>
    <Description>Fixes #10771

Use CIBuild.cmd script out of `eng` folder (which doesn't include `-test` explicitly) instead of `eng/common`.</Description>
    <CreatedDate>09/03/2020</CreatedDate>
    <ClosedDate>10/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>10810</PullRequestID>
        <IssueID>10771</IssueID>
        <Title>Disable building/running test in  official build of sdk in 5.0</Title>
        <CreatedDate>05/03/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10762</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Revert "Add support for net5.0 TargetFramework"</Title>
    <Description>Reverts dotnet/sdk#10728, which I merged into the preview 1 branch accidentally, when it should have gone into master.</Description>
    <CreatedDate>03/03/2020</CreatedDate>
    <ClosedDate>04/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>10762</PullRequestID>
        <IssueID>10728</IssueID>
        <Title>Add support for net5.0 TargetFramework</Title>
        <Description>We will also need a NuGet change to support net5.0.  This PR adds a test which will only pass when we have both in.

@rrelyea </Description>
        <CreatedDate>28/02/2020</CreatedDate>
        <ClosedDate>03/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>10652</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Remove stack dump on dotnet -d</Title>
    <Description>Fixes #4104 
@wli3 has already looked at these changes [here](https://github.com/dotnet/toolset/compare/master...sfoslund:Dotnet-dDump) before the repo merge.</Description>
    <CreatedDate>14/02/2020</CreatedDate>
    <ClosedDate>18/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>10652</PullRequestID>
        <IssueID>4104</IssueID>
        <Title>`dotnet -d` dumps stack to console</Title>
        <Description>I just did `dotnet -d` but without anything else
``
</Description>
        <CreatedDate>27/12/2019</CreatedDate>
        <ClosedDate>18/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4236</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Runtimeconfig partial build updating fix</Title>
    <Description>Adding fix and test coverage for runtimeconfig.json updates not being reflected on partial builds.
Fixes #2787 </Description>
    <CreatedDate>28/01/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4236</PullRequestID>
        <IssueID>2787</IssueID>
        <Title>Changes to runtime config options in .csproj are not reflected in .runtimeconfig.json on partial build</Title>
        <Description>Repro:

``</Description>
        <CreatedDate>03/01/2019</CreatedDate>
        <ClosedDate>21/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4154</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>swaroop-sridhar</FixedByID>
    <Title>[release/3.1.2xx] Add TFM check for `Publish-Trimmed-ReadyToRun-SingleFile`</Title>
    <Description>## Issue 
Fixes #3728

## Scenario
The options `PublishSingleFile`, `PublishReadyToRun`, and `PublishTrimmed` are only supported when targetting netcoreapp3.0 or later.

Trying to publish to a different target (say `.netcoreapp2.1`) today:
* `PublishSingleFile` fails with the `PlaceHolderNotFoundInAppHostException` generated by the `HostWriter`.
* `PublishReadyToRun` and `PublishTrimmed` silently fail to turn on, but the `publish` itself suceeds.

## Fix

This change adds an explicit TFM check to generate error/warnings for non-conforming targets.

`PublishSingleFile`, requires the following conditions to be true:
* `TargetFramework` is `netcoreapp`
* `TargetFrameworkVersion` is at least `3.0`
* The app is an executable (`OutputType=exe`)
If any of the conditions fail, build fails with an appropriate error

`PublishReadyToRun`, and `PublishTrimmed` require the following conditions to be true:
* `TargetFrameworkVersion` is at least `3.0`
If this condition fails, the build issue warnings, but publish itself succeeds.
The version check should ideally be a failure, but they are warnings for maximum compatibility with `3.0` release.

## Risk
Low

## Customer impact

Customers targeting frameworks earlier than netcoreapp3.0 do not observe surprising failures modes for  `PublishSingleFile`, `PublishReadyToRun`, and `PublishTrimmed`, instead they receive a clear error/warning.
</Description>
    <CreatedDate>10/01/2020</CreatedDate>
    <ClosedDate>24/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4154</PullRequestID>
        <IssueID>3728</IssueID>
        <Title>How to debug "GenerateBundle" task failed unexpectedly</Title>
        <Description># Issue Title

dotnet publish xxx.csproj -r win-x64 -c Release /p:PublishSingleFile=true

gives me the following:

C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018: The "GenerateBundle" task failed unexpectedly. [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018: Microsoft.NET.HostModel.AppHost.PlaceHolderNotFoundInAppHostException: Exception of type 'Microsoft.NET.HostModel.AppHost.PlaceHolderNotFoundInAppHostException' was thrown. [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.BinaryUtils.SearchAndReplace(MemoryMappedViewAccessor accessor, Byte[] searchPattern, Byte[] patternToReplace, Boolean pad0s) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.BinaryUtils.SearchAndReplace(String filePath, Byte[] searchPattern, Byte[] patternToReplace, Boolean pad0s) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.HostWriter.&lt;&gt;c__DisplayClass3_0.&lt;SetAsBundle&gt;b__0() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.RetryUtil.RetryOnIOError(Action func) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.HostWriter.SetAsBundle(String appHostPath, Int64 bundleHeaderOffset) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.Bundle.Bundler.GenerateBundle(IReadOnlyList`1 fileSpecs) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.Build.Tasks.GenerateBundle.ExecuteCore() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.Build.Tasks.TaskBase.Execute() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask) [C:\xxx.csproj]

# General

Would love to be able to provide more info, but how?

Is there a debug publish switch?
</Description>
        <CreatedDate>30/09/2019</CreatedDate>
        <ClosedDate>30/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4153</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>swaroop-sridhar</FixedByID>
    <Title>[release/3.1.2xx] Add TFM check for `Publish-Trimmed-ReadyToRun-SingleFile`</Title>
    <Description>The options `PublishSingleFile`, `PublishReadyToRun`, and `PublishTrimmed` are only supported when targetting netcoreapp3.0 or later.

Trying to publish to a different target (say `.netcoreapp2.1`) today:
* `PublishSingleFile` fails with the `PlaceHolderNotFoundInAppHostException` generated by the `HostWriter`.
* `PublishReadyToRun` and `PublishTrimmed` silently fail to turn on, but the `publish` itself suceeds.

This change adds an explicit TFM check to generate error/warnings for non-conforming targets.

`PublishSingleFile`, `PublishReadyToRun`, and `PublishTrimmed` require the following conditions to be true:
* `TargetFramework` is `netcoreapp`
* `TargetFrameworkVersion` is at least `3.0`
* The app is an executable (`OutputType=exe`)

If any of the conditions fail:
* `PublishSingleFile` fails with an appropriate error
* `PublishReadyToRun` and `PublishTrimmed` issue warnings, but publish itself succeeds.
  This is because:
    * The restriction against `classlibs` / `netstandard` frameworks may be relaxed in future releases
    * The version check should ideally be a failure, but they are warnings for maximum compatibility with `3.0` release.

Fixes #3728</Description>
    <CreatedDate>10/01/2020</CreatedDate>
    <ClosedDate>10/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4153</PullRequestID>
        <IssueID>3728</IssueID>
        <Title>How to debug "GenerateBundle" task failed unexpectedly</Title>
        <Description># Issue Title

dotnet publish xxx.csproj -r win-x64 -c Release /p:PublishSingleFile=true

gives me the following:

C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018: The "GenerateBundle" task failed unexpectedly. [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018: Microsoft.NET.HostModel.AppHost.PlaceHolderNotFoundInAppHostException: Exception of type 'Microsoft.NET.HostModel.AppHost.PlaceHolderNotFoundInAppHostException' was thrown. [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.BinaryUtils.SearchAndReplace(MemoryMappedViewAccessor accessor, Byte[] searchPattern, Byte[] patternToReplace, Boolean pad0s) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.BinaryUtils.SearchAndReplace(String filePath, Byte[] searchPattern, Byte[] patternToReplace, Boolean pad0s) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.HostWriter.&lt;&gt;c__DisplayClass3_0.&lt;SetAsBundle&gt;b__0() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.RetryUtil.RetryOnIOError(Action func) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.AppHost.HostWriter.SetAsBundle(String appHostPath, Int64 bundleHeaderOffset) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.HostModel.Bundle.Bundler.GenerateBundle(IReadOnlyList`1 fileSpecs) [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.Build.Tasks.GenerateBundle.ExecuteCore() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.NET.Build.Tasks.TaskBase.Execute() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [C:\xxx.csproj]
C:\Program Files\dotnet\sdk\3.0.100\Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Publish.targets(809,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask) [C:\xxx.csproj]

# General

Would love to be able to provide more info, but how?

Is there a debug publish switch?
</Description>
        <CreatedDate>30/09/2019</CreatedDate>
        <ClosedDate>30/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4144</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Remove redundant Update attribute</Title>
    <Description>Inside a target, Update on items is ignored (microsoft/msbuild#2835).

This is harmless in this case because the update was intended to apply to
all items where the condition matched, which is the same as not specifying
an Update filter. But it is misleading.</Description>
    <CreatedDate>08/01/2020</CreatedDate>
    <ClosedDate>28/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4144</PullRequestID>
        <IssueID>2835</IssueID>
        <Title>Merge release/2.1.6xx to release/2.2.2xx</Title>
        <Description>
This is an automatically generated pull request from release/2.1.6xx into release/2.2.2xx.

``

Once all conflicts are resolved and all the tests pass, you are free to merge the pull request.</Description>
        <CreatedDate>17/01/2019</CreatedDate>
        <ClosedDate>17/01/2019</ClosedDate>
        <Labels>
          <Label>Area-Infrastructure</Label>
          <Label>Auto-Merge If Tests Pass</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4121</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>AaronRobinsonMSFT</FixedByID>
    <Title>Fix parsing of metadata when looking for COM related CustomAttributes. [3.1.2xx]</Title>
    <Description># Description

When enumerating a class during COM `ClsidMap` generation, it can occur that the class contains an attribute that is defined in the same assembly as the class it is adorning. This causes the current attribute enumerating code to fail because it was written assuming all attributes where 'references' not actual definitions.

Fixes #4099
Replaces #4112 

# Customer Impact

If a user has a class they intend to expose as a COM server with attributes defined in the current class's assembly, the entire build will fail.

# Risk

Minimal. Additional testing has been added for these scenarios. This also will only impact scenarios involving authoring of COM server, which are already small.

# Regression

No. This code was introduced in .NET 3.0 and has not changed.
</Description>
    <CreatedDate>02/01/2020</CreatedDate>
    <ClosedDate>09/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4121</PullRequestID>
        <IssueID>4099</IssueID>
        <Title>GenerateClsidMap failed unexpectedly</Title>
        <Description>When I try to build a project of mine that sets EnableComHosting=true, I get the following build error:

``</Description>
        <CreatedDate>27/12/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4121</PullRequestID>
        <IssueID>4112</IssueID>
        <Title>Fix parsing of metadata when looking for COM related CustomAttributes.</Title>
        <Description>Fixes https://github.com/dotnet/sdk/issues/4099</Description>
        <CreatedDate>31/12/2019</CreatedDate>
        <ClosedDate>02/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4067</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>swaroop-sridhar</FixedByID>
    <Title>[release/3.1.2xx]Generate RID graph in self-contained builds</Title>
    <Description>## Issue 
#3361

## Scenario
Customer tries to load load plugins with RID-specific assets into a self-contained app.
This operation currently fails.

## Fix

In order to support loading components (plugins) with RID-specific assets, the `AssemblyDependencyResolver` requires the RID fallback graph.

The component itself should not carry the RID fallback graph with it (it would need to have the graph of all the RIDs there are and it would need to be updated with every addition).

For framework dependent apps, the RID fallback graph comes from the core framework Microsoft.NETCore.App, so there is no need to write it into the app.

If self-contained apps, the (applicable subset of) RID fallback graph needs to be written to the deps.json manifest.

## Risk
Medium

This change affects contents generated in the deps.json file for every single-file app.
However, it only adds information (RID-graph) that is consumed by the `AssemblyDependencyResolver`.
It doesn't change any other sections in the `deps.json` manifest.

## Customer impact
Customer is able to load load plugins with RID-specific assets into a self-contained app.
</Description>
    <CreatedDate>16/12/2019</CreatedDate>
    <ClosedDate>16/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>4067</PullRequestID>
        <IssueID>3361</IssueID>
        <Title>Self-contained apps should include RID fallback graph in .deps.json</Title>
        <Description>With the introduction of `AssemblyDependencyResolver` in 3.0 we're making it relatively easy to dynamically load components with their entire dependency trees. Such components can be portable in the sense that they include RID specific assets (for example different asset for Windows and Linux).

In order to correctly resolve dependencies of such component, the `AssemblyDependencyResolver` must have a RID fallback graph to follow (so that when we're running on `win10-x64`, we know that we should also look for assets which are `win-x64` or even `win`). The component itself should not carry the RID fallback graph with it (it would need to have the graph of all the RIDs there are and it would need to be updated with every addition).

Just like framework dependent apps which rely on the framework to provide the RID fallback graph, the component should rely on the host app to provide the RID fallback graph.

So if the host app is a framework dependent app, the RID fallback graph comes from the core framework `Microsoft.NETCore.App`. In this case everything works fine.

If the host app is a self-contained app, it in itself doesn't need a RID fallback graph since it's been built/published for one specific RID and thus it only carries assets which are necessary for that RID. But if a portable component is about to be loaded into such app, the RID fallback graph is necessary.

The proposal is to modify the SDK to include the RID fallback graph in self-contained app's `.deps.json`. It should be the graph filtered by the RID the app is targeting (just like what we do for the shared framework).

The problem is also discussed in https://github.com/dotnet/core-setup/issues/6960</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>11/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3972</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>sfoslund</FixedByID>
    <Title>Consolidating PackageVersion and NuGetPackageVersion metadata</Title>
    <Description>Removing PacakgeVersion metadata in favor of NuGetPackageVersion 
Fixes #3499</Description>
    <CreatedDate>26/11/2019</CreatedDate>
    <ClosedDate>17/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3972</PullRequestID>
        <IssueID>3499</IssueID>
        <Title>Redundant PackageName and NuGetPackageId metadata</Title>
        <Description>There's a mix of checking PackageName and NuGetPackageId in the targets and now we seem to be setting both all the time in ResolvePackageAssets.

I actually trimmed down the metadata in 2.1 to stop doing this, but it crept back in c7549ffe



</Description>
        <CreatedDate>02/08/2019</CreatedDate>
        <ClosedDate>17/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3460</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't fail design-time build if runtime pack isn't downloaded</Title>
    <Description>- Fixes #3409
- Fixes test flakiness which prevented #3409 from being caught before checkin
- Adds better error message if runtime pack hasn't been downloaded
- Doesn't also report error finding runtime list if the runtime pack hasn't been downloaded</Description>
    <CreatedDate>25/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3460</PullRequestID>
        <IssueID>3409</IssueID>
        <Title>Changing RID to one that hasn't been used before can cause design-time build failure</Title>
        <Description>I believe this regressed with #3394 

If you do not have the runtime pack in your nuget cache yet, and you change the RID of your project, the design time build will fail. Unfortunately the test that is specifically designed to test this case of changing RIDs is not reliable because dependening on state of nuget cache (say due to tests that have already run), it may pass even though the bug is present.

We need a better approach than just skipping ResolveRuntimePackAssets always in design-time builds as was done before #3394, but we can't have it fail as this will block the nomination that would restore the runtime pack.</Description>
        <CreatedDate>11/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3460</PullRequestID>
        <IssueID>3409</IssueID>
        <Title>Changing RID to one that hasn't been used before can cause design-time build failure</Title>
        <Description>I believe this regressed with #3394 

If you do not have the runtime pack in your nuget cache yet, and you change the RID of your project, the design time build will fail. Unfortunately the test that is specifically designed to test this case of changing RIDs is not reliable because dependening on state of nuget cache (say due to tests that have already run), it may pass even though the bug is present.

We need a better approach than just skipping ResolveRuntimePackAssets always in design-time builds as was done before #3394, but we can't have it fail as this will block the nomination that would restore the runtime pack.</Description>
        <CreatedDate>11/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3459</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Calculate PackageConflictPreferredPackages from KnownFrameworkReference items</Title>
    <Description>Use `KnownFrameworkReference` metadata to calculate `PackageConflictPreferredPackages` instead of hardcoding.  The hardcoded values were incorrect after the runtime packs had been renamed.

I haven't figured out a good way to test this, as the behavior would only be observable when you reference a package with an asset that matches the assembly and file versions of the same asset in a runtime pack.  But there's not a good way to determine which package version you would need to reference to line these up.

Fix #3362</Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>26/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3459</PullRequestID>
        <IssueID>3362</IssueID>
        <Title>Conflict resolution broken for self-contained APP when packages have same version as shared framework</Title>
        <Description>The hardcoded list here is now broken:
https://github.com/dotnet/sdk/blob/ec0d2190853afd6c6a8a410d7dc386a9f1ca391b/src/Tasks/Microsoft.NET.Build.Tasks/ResolveTargetingPackAssets.cs#L133-L135

This causes bad behavior from conflict resolution:
``

Restore and build it to observe the issue.
</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>26/07/2019</ClosedDate>
        <Labels>
          <Label>Blocking-RTM</Label>
          <Label>Bug</Label>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3456</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix building VB WPF project</Title>
    <Description>The target to select the VB runtime DLL from ReferencePath was not being run when compiling the temporary project for a XAML build.

Fix #3450</Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3456</PullRequestID>
        <IssueID>3450</IssueID>
        <Title>WPF for VB build failed with error BC2017: could not find library 'Microsoft.VisualBasic.dll'</Title>
        <Description>@YunWeiaa commented on [Tue Jul 23 2019](https://github.com/dotnet/wpf/issues/1346)

* .NET Core Version: 3.0.100-preview8-013392
``

 **Actual behavior:** &lt;!-- callstack for crashes / exceptions --&gt;
 Dotnet build failed with error BC2017: could not find library 'Microsoft.VisualBasic.dll'
![image](https://user-images.githubusercontent.com/33921754/61700175-dac71a00-ad6e-11e9-8055-a7d4872940ce.png)

 **Expected behavior:**
 Build succeeded.

 


---

@YunWeiaa commented on [Tue Jul 23 2019](https://github.com/dotnet/wpf/issues/1346#issuecomment-514141226)

Note: WPF for c# build and run successfully.

---

@grubioe commented on [Tue Jul 23 2019](https://github.com/dotnet/wpf/issues/1346#issuecomment-514330319)

This will succeed with build 3.0.100-preview7-012821.  Can you try with this build?  Thanks

---

@vatsan-madhavan commented on [Tue Jul 23 2019](https://github.com/dotnet/wpf/issues/1346#issuecomment-514428977)

Create a `global.json` for your app using `dotnet new globaljson --sdk-version 3.0.100-preview7-012821` and build against that. 

If you don't have that SDK, you can install it using the scripts at https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script. 

</Description>
        <CreatedDate>24/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3448</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Do not use apphost when resolving assets for dotnet store</Title>
    <Description>Some changes in the way apphost is handled broke the case where you
use an exe project as the dotnet store "manifest" project.

The fix is to set UseAppHost=false when doing the store resolution.

Fix #3168</Description>
    <CreatedDate>23/07/2019</CreatedDate>
    <ClosedDate>24/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3448</PullRequestID>
        <IssueID>3168</IssueID>
        <Title>dotnet store fails with "the destination is a folder instead of a file" in 3.0 SDK</Title>
        <Description>This is based on the repro from dotnet/cli#11223 which can be found [here](https://github.com/narcis-pv/dotnet-core-target-manifest-bug).

Running the `dotnet store` command described in the repro with .NET Core SDK 3.0.100-preview6-011540 produces error like this:
``

Running the same on .NET Core SDK 2.2.100 (using `global.json`) works just fine.
Seems like a regression in 3.0.</Description>
        <CreatedDate>23/04/2019</CreatedDate>
        <ClosedDate>24/07/2019</ClosedDate>
        <Labels>
          <Label>Store</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3447</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Use host model for apphost</Title>
    <Description>part of #11300</Description>
    <CreatedDate>23/07/2019</CreatedDate>
    <ClosedDate>27/07/2019</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>3441</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix regeneration of files when asset cache changes.</Title>
    <Description>Both the deps.json and runtimeconfig.json files remain unchanged when an
incremental build takes place that changes a property that would invalidate the
assets cache.

For a property like `SelfContained`, this might mean the files are no longer
valid for the incremental build's output.

Fixes dotnet/cli#11956.</Description>
    <CreatedDate>20/07/2019</CreatedDate>
    <ClosedDate>20/07/2019</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>3440</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>kzu</FixedByID>
    <Title>Add support for @(AssemblyMetadata) items that turn into assembly attributes</Title>
    <Description>Given that `AssemblyMetadataAttribute` is such a common assembly-level attribute, this adds support
for specifying it directly via simple items, such as:

```
    &lt;AssemblyMetadata Include="Foo" Value="Bar" /&gt;
    &lt;AssemblyMetadata Include="Bar" Value="Baz" /&gt;
```

This also avoids having to learn the `_Parameter1` and `_Parameter2` syntax in `AssemblyAttribute` elements, 
and is more similar to the way other higher-level properties like `AssemblyTitle` or `Product` are also
turned into assembly attributes.

Partially fixes #3166

The feature can be disabled by setting `$(GenerateAssemblyMetadataAttributes)` to `false`.</Description>
    <CreatedDate>19/07/2019</CreatedDate>
    <ClosedDate>16/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3440</PullRequestID>
        <IssueID>3166</IssueID>
        <Title>GenerateAssemblyInfo support for InternalsVisibleToAttribute and AssemblyMetadataAttribute</Title>
        <Description>Hello,

In our .NET 4.7.2 applications we set the InternalsVisibleTo attribute on our libraries so that our internal unit test projects can run unit tests on internal methods without having to go through the trouble of putting public signatures of these methods into the class and wrapping everything in preprocessor directives.

We also make use of the AssemblyMetadata attribute to have our build system add vital diagnostic information to our assemblies so that there is never an issue with identifying when a project was built, from what repo commit etc.  This has made identifying and fixing bugs much easier more efficient.

To set these values we've manually set the InternalsVisibleTo attribute at design time into the AssemblyInfo.cs file.  We also have our build system inject the values into the AssemblyInfo.cs file at build time during the build (but the changes are not committed as the metadata all build version related metadata).

In .NET Standard and Core we've found that the common Assembly Attributes are now set in the project file.  Do you have plans to add these other attributes to the Microsoft.NET.GenerateAssemblyInfo.targets file so that they an be included in the project file so the new generate assembly info functionality can support adding these to the output assembly?

We have read there is a workaround where we can set the property GenerateAssemblyInfo to False and add an AssemblyInfo.cs file to the .NET Standard/Core projects but we would rather not use this workaround.  For one we do not know how long it will be supported and also we do not know if it will break the new project build workflow in some way.

Can you please provide some advice on how these attributes can be used in .NET Standard/Core project files without the workaround or an indication if you plan on adding support for them to the Microsoft.NET.GenerateAssemblyInfo.targets file?

Thank you,

Bryan</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>16/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3439</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>kzu</FixedByID>
    <Title>Add support for @(InternalsVisibleTo) items that turn into assembly attributes</Title>
    <Description>Given that `InternalsVisibleTo` (IVT) is such a common assembly-level attribute, this adds support
for specifying it directly via simple items, such as:

```
  &lt;ItemGroup&gt;
    &lt;InternalsVisibleTo Include="MyLibrary.Tests" /&gt;
  &lt;/ItemGroup&gt;
```

Optionally, a `Key` metadata can be specified to provide a strong-named IVT:

```
  &lt;ItemGroup&gt;
    &lt;InternalsVisibleTo Include="MyLibrary.Tests" Key="PUBLIC_KEY" /&gt;
  &lt;/ItemGroup&gt;
```

The targets will also use automatically a `$(PublicKey)` if available and no `%(Key)` metadata
override is found. Otherwise, it will default to an IVT without a key.

This also avoids having to learn the `_Parameter1` syntax in `AssemblyAttribute` elements, and is
more similar to the way other higher-level properties like `AssemblyTitle` or `Product` are also
turned into assembly attributes.

To turn off this feature, set `$(GenerateInternalsVisibleToAttributes)` to `false`.

Partially fixes #3166</Description>
    <CreatedDate>19/07/2019</CreatedDate>
    <ClosedDate>17/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3439</PullRequestID>
        <IssueID>3166</IssueID>
        <Title>GenerateAssemblyInfo support for InternalsVisibleToAttribute and AssemblyMetadataAttribute</Title>
        <Description>Hello,

In our .NET 4.7.2 applications we set the InternalsVisibleTo attribute on our libraries so that our internal unit test projects can run unit tests on internal methods without having to go through the trouble of putting public signatures of these methods into the class and wrapping everything in preprocessor directives.

We also make use of the AssemblyMetadata attribute to have our build system add vital diagnostic information to our assemblies so that there is never an issue with identifying when a project was built, from what repo commit etc.  This has made identifying and fixing bugs much easier more efficient.

To set these values we've manually set the InternalsVisibleTo attribute at design time into the AssemblyInfo.cs file.  We also have our build system inject the values into the AssemblyInfo.cs file at build time during the build (but the changes are not committed as the metadata all build version related metadata).

In .NET Standard and Core we've found that the common Assembly Attributes are now set in the project file.  Do you have plans to add these other attributes to the Microsoft.NET.GenerateAssemblyInfo.targets file so that they an be included in the project file so the new generate assembly info functionality can support adding these to the output assembly?

We have read there is a workaround where we can set the property GenerateAssemblyInfo to False and add an AssemblyInfo.cs file to the .NET Standard/Core projects but we would rather not use this workaround.  For one we do not know how long it will be supported and also we do not know if it will break the new project build workflow in some way.

Can you please provide some advice on how these attributes can be used in .NET Standard/Core project files without the workaround or an indication if you plan on adding support for them to the Microsoft.NET.GenerateAssemblyInfo.targets file?

Thank you,

Bryan</Description>
        <CreatedDate>22/04/2019</CreatedDate>
        <ClosedDate>16/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3421</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>drewnoakes</FixedByID>
    <Title>Remove CheckForDuplicateItemsContinueOnError property</Title>
    <Description>#### Description
Remove unused CheckForDuplicateItemsContinueOnError property.

This was logically part of https://github.com/dotnet/sdk/pull/3399, which switched to using the generic ContinueOnError throughout, which is a better pattern for design time builds. but had to wait for https://github.com/dotnet/wpf/pull/1235 to go through.

#### Customer Impact
None. This is just finishing the change so that we don't have dead code to confuse us in 3.0.

#### Regression?
No. 

#### Risk
Low. Removes dead code.

--
Follows #3399.

The `CheckForDuplicateItemsContinueOnError` property was used by WPF projects.

https://github.com/dotnet/wpf/pull/1235 makes WPF use `ContinueOnError` instead, so this temporary property can be removed once things propagate.

Marked as WIP as merging should be [delayed a few days](https://github.com/dotnet/sdk/pull/3399#discussion_r302977781).</Description>
    <CreatedDate>14/07/2019</CreatedDate>
    <ClosedDate>13/08/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3421</PullRequestID>
        <IssueID>3399</IssueID>
        <Title>Continue design time builds if resolving package assets fails</Title>
        <Description>(This is an alternative implementation of #3398.)

Design time builds are stopping if `ResolvePackageAssets` hits an error (dotnet/project-system#4992).

This PR uses the fact that design-time builds set the `ContinueOnError` property to `ErrorAndContinue`.

</Description>
        <CreatedDate>05/07/2019</CreatedDate>
        <ClosedDate>12/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3415</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Select appropriate VB runtime by default</Title>
    <Description>Fix #3387 
Fix #2793 

This comment in the code describes and documents the approach:

```
By default, VBRuntime is chosen as follows:

    .NET Framework:
      Same as classic vbproj. $(FrameworkPathOverride) is passed  as
      /sdkpath to compiler and Microsoft.VisualBasic.dll will be used
      from there even if there is no explicit reference to it. This is
      accomplished by leaving $(VBRuntime) unset.

    .NET Core 3.0+:
      Locate Microsoft.VisualBasic among references and pass it as
      /vbruntime to compiler.

    .NET Core &lt; 3.0 or .NET Standard:
      Use embedded VB runtime as there is no Microsoft.VisualBasic.dll
      available that is complete enough to serve as /vbruntime.

   These defaults can be overridden as follows:

    $(UseReferencedVBRuntime) == true:
      Use referenced Microsoft.VisualBasic regardless of TFM.

      This is an escape hatch for a custom Microsoft.VisualBasic reference
      that can work as /vbruntime on a target framework other than .NET Core 3.0+

    $(VBRuntime) != '':
      Pass it through to compiler unchanged.
```</Description>
    <CreatedDate>12/07/2019</CreatedDate>
    <ClosedDate>16/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3415</PullRequestID>
        <IssueID>3387</IssueID>
        <Title>VB.NET "My" not working as expected?</Title>
        <Description>@cston and @KathleenDollard,

Here is an isolated example running on the most recent bits as far as I can tell (at least with regards to the Microsoft.VisualBasic side of things).

Module Program
  Sub Main(args As String())
    Console.WriteLine(My.Computer.Name)
    Console.WriteLine((New Microsoft.VisualBasic.Devices.ServerComputer).Name)
    Console.WriteLine(System.Environment.MachineName)
  End Sub
End Module

The first line doesn’t work in .NET Core 3.0; however, the second and third lines do.  Playing with the same code in the full .NET Framework, all three lines work and when you jump to the reference for My.Computer.Name, it goes to Microsoft.VisualBasic.Devices.ServerComputer.Name.  I then jumped back over to the .NET Core source tree and that property simply returns System.Environment.MachineName.  One thing I find interesting about this is it’s not a 1:1 map… how does My.Computer.Name map to a property inside of an instantiated instance of Microsoft.VisualBasic.Devices.ServerComputer?  Some “magic” black-box stuff there?

So am I just missing something as far as how to "light up" the My side of things when working with a .NET Core 3.0 console project?  Or is there some additional work that still has to be done beyond the work that has taken place within the Microsoft.VisualBasic namespace?

(BTW, @cston great work thus far!)

Thanks.

Cory Smith</Description>
        <CreatedDate>30/05/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3415</PullRequestID>
        <IssueID>2793</IssueID>
        <Title>Result of chr() cannot be used as initial value of a Const in .Net Core 3 Preview 1</Title>
        <Description>Version: 3.0.100-preview-009812
Commit: e3abf6e935

Runtime Environment:
OS Name: Windows
OS Version: 10.0.17763
OS Platform: Windows
RID: win10-x64
Base Path: C:\Program Files\dotnet\sdk\3.0.100-preview-009812\

Host (useful for support):
Version: 3.0.0-preview-27122-01
Commit: 00c5c8bc40

Have you experienced this same bug with .NET Framework?: No

In the .Net Framework using VB.Net you can compile this Line:

`` 

In .Net Core 3 Preview 1 it failes with:
error BC30059: Constant expression is required.</Description>
        <CreatedDate>04/01/2019</CreatedDate>
        <ClosedDate>16/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3412</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>elinor-fung</FixedByID>
    <Title>Update Microsoft.NET.HostModel version</Title>
    <Description>This is for dotnet/core-setup#7173

Same change as #3411, but for Preview 7</Description>
    <CreatedDate>12/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3412</PullRequestID>
        <IssueID>7173</IssueID>
        <Title>[Suggestion] cleaner publish layout?</Title>
        <Description>This is a suggestion from one of our customers.

## Expected  behavior
Customer thinks the current publish layout is cluttered.  He has some suggestions:
- Merge dll's into one or a few bigger dll's, so that the published app would only have an exe, and one (or a few) dll's.  He gave the example of Golang where the packed app is a single executable.
- Or put all dependencies into a `libs` folder along side with the executable.

## Actual behavior
The executable and all dependencies are published to same folder.






</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3412</PullRequestID>
        <IssueID>3411</IssueID>
        <Title>Update Microsoft.NET.HostModel version</Title>
        <Description>This is for dotnet/core-setup#7173

It is also affecting Preview 7. This is just the change in master.</Description>
        <CreatedDate>11/07/2019</CreatedDate>
        <ClosedDate>12/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3411</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>elinor-fung</FixedByID>
    <Title>Update Microsoft.NET.HostModel version</Title>
    <Description>This is for dotnet/core-setup#7173

It is also affecting Preview 7. This is just the change in master.</Description>
    <CreatedDate>11/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3411</PullRequestID>
        <IssueID>7173</IssueID>
        <Title>[Suggestion] cleaner publish layout?</Title>
        <Description>This is a suggestion from one of our customers.

## Expected  behavior
Customer thinks the current publish layout is cluttered.  He has some suggestions:
- Merge dll's into one or a few bigger dll's, so that the published app would only have an exe, and one (or a few) dll's.  He gave the example of Golang where the packed app is a single executable.
- Or put all dependencies into a `libs` folder along side with the executable.

## Actual behavior
The executable and all dependencies are published to same folder.






</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3410</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Disable flaky test against bug</Title>
    <Description>Good news: The test found a product bug (#3409) that it is designed to catch.

Bad news: It can still pass depending on what's in the nuget cache from prior tests. So the change that regressed it slipped through and now we have flaky CI.

Disabling the test against the bug that it caught for now.</Description>
    <CreatedDate>11/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3410</PullRequestID>
        <IssueID>3409</IssueID>
        <Title>Changing RID to one that hasn't been used before can cause design-time build failure</Title>
        <Description>I believe this regressed with #3394 

If you do not have the runtime pack in your nuget cache yet, and you change the RID of your project, the design time build will fail. Unfortunately the test that is specifically designed to test this case of changing RIDs is not reliable because dependening on state of nuget cache (say due to tests that have already run), it may pass even though the bug is present.

We need a better approach than just skipping ResolveRuntimePackAssets always in design-time builds as was done before #3394, but we can't have it fail as this will block the nomination that would restore the runtime pack.</Description>
        <CreatedDate>11/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3406</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Supply rid graph to NuGet</Title>
    <Description>Fix #3325</Description>
    <CreatedDate>08/07/2019</CreatedDate>
    <ClosedDate>11/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3406</PullRequestID>
        <IssueID>3325</IssueID>
        <Title>Supply RuntimeIdentifier graph to NuGet</Title>
        <Description>Once this NuGet feature is implemented: https://github.com/NuGet/Client.Engineering/pull/96

We will need to set the appropriate property to supply the SDKs graph to NuGet, as well as remove the infrastructure that implicitly references Microsoft.NETCore.App.</Description>
        <CreatedDate>12/06/2019</CreatedDate>
        <ClosedDate>11/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3399</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>drewnoakes</FixedByID>
    <Title>Continue design time builds if resolving package assets fails</Title>
    <Description>(This is an alternative implementation of #3398.)

Design time builds are stopping if `ResolvePackageAssets` hits an error (dotnet/project-system#4992).

This PR uses the fact that design-time builds set the `ContinueOnError` property to `ErrorAndContinue`.

</Description>
    <CreatedDate>05/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3399</PullRequestID>
        <IssueID>3398</IssueID>
        <Title>Continue design time builds if resolving package assets fails</Title>
        <Description>Design time builds are stopping if `ResolvePackageAssets` hits an error (https://github.com/dotnet/project-system/issues/4992). This PR sets `ContinueOnError` on `ResolvePackageAssets` to `ErrorAndContinue` for design time builds only.

Would the property be better defined in `Microsoft.NET.Sdk.props` with a more general name for broader use?

Alternatively, should this logic piggyback off the `DesignTimeBuild` property of the task itself?

https://github.com/dotnet/sdk/blob/adf76a594158a742e2c22b49b0fb4942cb53317d/src/Tasks/Microsoft.NET.Build.Tasks/ResolvePackageAssets.cs#L153</Description>
        <CreatedDate>05/07/2019</CreatedDate>
        <ClosedDate>12/07/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3399</PullRequestID>
        <IssueID>4992</IssueID>
        <Title>Keyboard input disappears in a Linux terminal window after a .NET Core Application throws an exception.</Title>
        <Description>**Issue**: You have a .NET Core console application that handles input stream from standard input. In a Ubuntu terminal window when that application either crashes or throws an exception and returns the control back to the terminal, the subsequent keyboard input no longer appears in that terminal window.

Same behavior has been observed with **CentOS** and **RHEL**.

**Repro**: Execute the below code by running "**dotnet run**" and observe keyboard activity in the terminal window once the control is back after the exception.

using System;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {

``

}

This appears to be a bug in forwarding I/O streams across processors. 

**Workaround**: Run **"dotnet build"** instead of **"dotnet run"** and execute the compiled binary from ./bin/Debug/dnxcore50/appname
</Description>
        <CreatedDate>03/02/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3393</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix unhandled exception when RuntimeList.xml contains duplicates.</Title>
    <Description>This PR fixes an unhandled exception that results when RuntimeList.xml
contains entries that have the same destination subpath when resolving the
runtime pack assets.  An error is now emitted instead of the unhandled
exception.

Additionally, this fixes an unhandled exception that occurs when the
RuntimeList.xml file is not present in the runtime pack that is caused by
the exception message not having a NETSDK prefix.

Also removed an unnecessary override of the `Execute` method for
`GenerateDepsFile` task.  This override should have been removed with a
previous cleanup PR, but was overlooked.

Fixes dotnet/cli#11705.</Description>
    <CreatedDate>04/07/2019</CreatedDate>
    <ClosedDate>16/07/2019</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>3392</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't write the same framework multiple times to RuntimeConfig.json</Title>
    <Description>Fix dotnet/cli#11709</Description>
    <CreatedDate>03/07/2019</CreatedDate>
    <ClosedDate>04/07/2019</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>3390</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Support automatic Link metadata for Page and Resource items</Title>
    <Description>Fix #2697 
</Description>
    <CreatedDate>03/07/2019</CreatedDate>
    <ClosedDate>23/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3390</PullRequestID>
        <IssueID>2697</IssueID>
        <Title>Automatic Link generation from LinkBase does not work for Page, Resource items</Title>
        <Description>(Filing bugs from my notes after customer visit exploring porting large WPF app to .NET core 3)

This:
``

Does not work as it does for Compile, EmbeddedResource, AdditionalFiles, EmbeddedResource:

https://github.com/dotnet/sdk/blob/9543229b2d30f4c712846540e725014754229919/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Sdk.DefaultItems.targets#L201-L246

This has two consequences:

1. It prevents the easy way of getting these files outside project cone to show in sln explorer
2. Xaml interpretation can actually change based on the Link so the impact of not generating a Link as expected can change the application behavior. I forget the details here, but I observed this in customer app.

I'm unsure if the WindowsDesktop SDK should be handling it or if we should add to above. We probably need to do this for Resource items as well.

cc @dsplaisted @vatsan-madhavan

</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>23/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3375</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>fadimounir</FixedByID>
    <Title>Disable R2R compilations for non-exe projects</Title>
    <Description>Fixes #3364</Description>
    <CreatedDate>29/06/2019</CreatedDate>
    <ClosedDate>10/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3375</PullRequestID>
        <IssueID>3364</IssueID>
        <Title>Block R2R compilation for library projects</Title>
        <Description>Publish on library is a strange case already and trips people up a lot.

It could also be a source of problems if some lib developer publishes R2R for a certain platform/arch, and another app developer uses that lib on a different target</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3373</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>swaroop-sridhar</FixedByID>
    <Title>Always publish the AppHost</Title>
    <Description>Always copy the AppHost from intermediate to publish directory in order to ensure that the sequence
    dotnet publish /p:PublishSingleFile=true
    dotnet publish /p:PublishSingleFile=false
places the correct unbundled apphost in the publish directory.

Fixes #3337</Description>
    <CreatedDate>29/06/2019</CreatedDate>
    <ClosedDate>26/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3373</PullRequestID>
        <IssueID>3337</IssueID>
        <Title>App host not published correctly after a previous PublishSingleFile</Title>
        <Description>To repro:
1) dotnet new console
2) dotnet publish -r win-x64 /p:PublishSingleFile
3) dotnet publish -r win-x64

After step 2, there will be a single app.exe (+pdb) file in the publish folder. Approx size is ~70 MB.
Step 3 correctly copies all dlls and other files to the publish folder, but fails to overwrite app.exe with the non-bundled version of the file (should be around ~150 KB). The large single-file bundle is still there in the publish folder.

Not sure if we can do something about it. This falls in the "clean publish" category of bugs, but I thing at least we should overwrite the app.exe in the publish folder with the correct one.</Description>
        <CreatedDate>17/06/2019</CreatedDate>
        <ClosedDate>26/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3353</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Retarget from netcoreapp2.0 to netcoreapp2.1 for source-build</Title>
    <Description>Fix #3317 
</Description>
    <CreatedDate>25/06/2019</CreatedDate>
    <ClosedDate>26/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3353</PullRequestID>
        <IssueID>3317</IssueID>
        <Title>Source-build patch removal for SDK.</Title>
        <Description>Source-build has some patches that we are currently applying to your repo.  This issue tracks removing the patches.  These patches can be found at https://github.com/dotnet/source-build/tree/release/3.0/patches/sdk.

Patches that have the responsibility "Repo" and the Disposition "Incorporate" are patches that we believe are valid source-build fixes that should be moved into your repo.  Please let us know if these don't seem like good patches.  Any changes with the responsibility "source-build" is something that we plan to keep going forward or integrate in another way - please also let us know if you think there may be problems with those patches.

Patch name | Type | Disposition | Responsibility | Notes
-- | -- | -- | -- | --
sdk/0001-Upgrade-to-netcoreapp2.1.patch | ToolCompat | Incorporate | Repo | 
sdk/0002-Add-missing-PlatformAbstractions-reference.patch | Bug | Incorporate | source-build |  
sdk/0003-Consolidate-versions.patch | Coherence | Incorporate | source-build |  

</Description>
        <CreatedDate>10/06/2019</CreatedDate>
        <ClosedDate>26/06/2019</ClosedDate>
        <Labels>
          <Label>source-build</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3348</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Unify more build and publish logic</Title>
    <Description>Implement some of the unification in #3311, but without changing the product behavior.

Determines which assets should be copied local for both build and publish in the `ResolvePackageAssets` task.</Description>
    <CreatedDate>21/06/2019</CreatedDate>
    <ClosedDate>25/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3348</PullRequestID>
        <IssueID>3311</IssueID>
        <Title>Exclude Publish="false" package assets from build output, don't infer Publish="false" from PrivateAssets="all"</Title>
        <Description>See https://github.com/dotnet/designs/pull/78</Description>
        <CreatedDate>07/06/2019</CreatedDate>
        <ClosedDate>10/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3340</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix small build issues</Title>
    <Description>Three separate small issues in three commits:


1. Fix incremental build in VS when only target files change. This had been driving me crazy causing tests to run without my targets changes. Fixed the other two while I was playing around nearby.

2. Remove outdated workaround

3. Auto-bump version of task assemblies. Fix #2953. Follows [Arcade recommendation](https://github.com/dotnet/arcade/blob/master/Documentation/CorePackages/Versioning.md#recommanded-settings). </Description>
    <CreatedDate>18/06/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3340</PullRequestID>
        <IssueID>2953</IssueID>
        <Title>Assembly version stopped being bumped with every build in 2.1.300+</Title>
        <Description>MSBuild on desktop cannot load more than one version of our tasks unless we bump the assembly version. (MSBuild on coreclr can't either, but we have a 1:1 msbuild:sdk relationship on coreclr so it's moot. The current limitations on coreclr are even worse, can't load SxS in same load context regardless of version, but again moot here.)

If an MSBuild node is alive using a different build of the same Major.Minor.Patch release, then it will use targets from the new build and tasks from the old one. When there are contract changes between the tasks and targets, this can lead to confounding errors  like "task X could not be loaded from Microsoft.NET.Build.Tasks.dll" or "task Y does not take parameter Z". 

We got around this in the past by bumping the assembly version with every build. Since tasks are always dynamically loaded and never referenced directly at compilation time, this doesn't have the usual negative consequences of requiring excessive binding redirects, etc.

This has a history of regressing with infrastructure (repo toolset, arcade, etc.,) because the infrastructure is opinionated that the build number should not be part of the assembly version, which makes sense for most things, but not build tasks. We need to add test coverage to stop this from regressing. It can go a long time unreported because 1) things might still work when mixing tasks and targets between builds and 2) msbuild nodes eventually shut down and things start working again, letting the problem get chalked up to flakiness that can't be reproduced.

Now, with the move to build-to-build upgrades of patches, https://github.com/dotnet/core-sdk/pull/530, I think there will be a prompt to terminate users of older build or a prompt to reboot following the upgrade.That would mitigate this, but we should still be defensive for forced SxS patch installs (via .zip or whatever).</Description>
        <CreatedDate>16/02/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3333</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update stage 0</Title>
    <Description>Replaces #3332, hopefully fixing test failures</Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>14/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3333</PullRequestID>
        <IssueID>3332</IssueID>
        <Title>Update stage 0</Title>
        <CreatedDate>14/06/2019</CreatedDate>
        <ClosedDate>14/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3331</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Preserve metadata from Reference items</Title>
    <Description>Fix #2254 </Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3331</PullRequestID>
        <IssueID>2254</IssueID>
        <Title>Reference metadata is not preserved by ImplicitlyExpandNETStandardFacades</Title>
        <Description>For a project targeting .Net Framework 4.7.1 with a reference to netstandard libraries, the target `ImplicitlyExpandNETStandardFacades` replaces certain references with their Facades so netstandard based assemblies work as expected. This currently works great if the project does not associate metadata(like aliases) with any of these references, but when it does - those aren't honored breaking build. 

Filing this issue to ensure that the missing metadata is preserved when the replacement is done.

Adding few more details, here is the reference in question:
``
Notice the missing alias to System.Net.http.</Description>
        <CreatedDate>17/05/2018</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3330</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't hash DesignTimeBould for ResolvePackageAssets</Title>
    <Description>Fixes #3313 </Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>14/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3330</PullRequestID>
        <IssueID>3313</IssueID>
        <Title>DesignTimeBuild is included in ResolvePackageAssets HashSettings</Title>
        <Description>This will cause the cache to be rebuilt always when building after a design time build, or design time building after a build.

The test was updated to allow DesignTimeBuild to not be in the cache:

https://github.com/dotnet/sdk/blob/de72490d26acee011e22f40113209323976980e0/src/Tasks/Microsoft.NET.Build.Tasks.UnitTests/GivenAResolvePackageAssetsTask.cs#L21

But it is actually written:

https://github.com/dotnet/sdk/blob/de72490d26acee011e22f40113209323976980e0/src/Tasks/Microsoft.NET.Build.Tasks/ResolvePackageAssets.cs#L376

Probably need a test that checks the opposite of the settings hash test for DesignTimeBuild: that you can change it without influencing the hash.</Description>
        <CreatedDate>08/06/2019</CreatedDate>
        <ClosedDate>14/06/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3327</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Reduce verbosity of conflict resolution</Title>
    <Description>Also:
* Reduce line noise in preview message
* Log info about arbitrary copy-local choice in conflict resolution

Fix #2468 
Fix #3319 </Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3327</PullRequestID>
        <IssueID>2468</IssueID>
        <Title>Preview message should not have a code.</Title>
        <Description>We were trying to shorten this and adding a code to the error message causes msbuild to list the file. (And, btw, RuntimeIdentifierInference.targets is a weird place for this logging.)

We will need to tweak the tests to allow this to not have a code as I added enforcement that all messages have codes, but I think this one needs to be a special case.

### Expected
``</Description>
        <CreatedDate>10/08/2018</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3327</PullRequestID>
        <IssueID>3319</IssueID>
        <Title>Issues with conflict resolution logging</Title>
        <Description>1. At normal verbosity, there are unactionable messages about things that happen in very common cases. For example, every core WPF project has a conflict between WindowsBase in netcore app. Importance should be lowered so that you can still see in binlog/diag, but not otherwise. We regularly get questions about what to do about a conflict, when there is nothing to do.

2. It is quite noisy to have codes associated with non-error, non-warnings. We should refactor to not bother having codes for messages. Related: https://github.com/dotnet/sdk/issues/2468

3. We are concatenating strings, so we end up with a code inside a code. NETSDKXXXX: Encountered conflict yada, yada.  NETSDKYYYY. Choosing Foo.



</Description>
        <CreatedDate>11/06/2019</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3326</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Support PublishReadyToRun for framework-dependent deployment</Title>
    <Description>Fix #3110 </Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3326</PullRequestID>
        <IssueID>3110</IssueID>
        <Title>Resolve runtime pack assets for crossgen even if app is framework-dependent</Title>
        <Description>Crossgen operates on implementation assemblies only, even when passed as references to the compiler. To crossgen a framework-dependent app, we need all of the framework implementation assemblies to be passed to crossgen as references.

Note that crossgen requires picking a RID. The app can be framework-dependent, but it must be RID specific. (Crossgen generates native code, which can't be rid-agnostic, obviously.) We are guaranteed to have downloaded the runtime packs, we just need to resolve the framework assemblies from it as though the app was self-contained, but without putting them in deps.json or copying them, etc.

Today, crossgen tasks can find the base shared framework implementation assemblies next to it (it ships in the base runtime pack), but this doesn't work for the other frameworks like WindowsDesktop or ASP.NET. This also can't just blindly aggregate all the files in all the runtime packs, this list needs to account for conflict resolution (WindowsBase in WindowsDesktop wins over WindowsBase in NETCoreApp), etc.</Description>
        <CreatedDate>09/04/2019</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels>
          <Label>Blocking Partner</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3375</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>fadimounir</FixedByID>
    <Title>Disable R2R compilations for non-exe projects</Title>
    <Description>Fixes #3364</Description>
    <CreatedDate>29/06/2019</CreatedDate>
    <ClosedDate>10/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3375</PullRequestID>
        <IssueID>3364</IssueID>
        <Title>Block R2R compilation for library projects</Title>
        <Description>Publish on library is a strange case already and trips people up a lot.

It could also be a source of problems if some lib developer publishes R2R for a certain platform/arch, and another app developer uses that lib on a different target</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>10/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3373</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>swaroop-sridhar</FixedByID>
    <Title>Always publish the AppHost</Title>
    <Description>Always copy the AppHost from intermediate to publish directory in order to ensure that the sequence
    dotnet publish /p:PublishSingleFile=true
    dotnet publish /p:PublishSingleFile=false
places the correct unbundled apphost in the publish directory.

Fixes #3337</Description>
    <CreatedDate>29/06/2019</CreatedDate>
    <ClosedDate>26/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3373</PullRequestID>
        <IssueID>3337</IssueID>
        <Title>App host not published correctly after a previous PublishSingleFile</Title>
        <Description>To repro:
1) dotnet new console
2) dotnet publish -r win-x64 /p:PublishSingleFile
3) dotnet publish -r win-x64

After step 2, there will be a single app.exe (+pdb) file in the publish folder. Approx size is ~70 MB.
Step 3 correctly copies all dlls and other files to the publish folder, but fails to overwrite app.exe with the non-bundled version of the file (should be around ~150 KB). The large single-file bundle is still there in the publish folder.

Not sure if we can do something about it. This falls in the "clean publish" category of bugs, but I thing at least we should overwrite the app.exe in the publish folder with the correct one.</Description>
        <CreatedDate>17/06/2019</CreatedDate>
        <ClosedDate>26/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3353</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Retarget from netcoreapp2.0 to netcoreapp2.1 for source-build</Title>
    <Description>Fix #3317 
</Description>
    <CreatedDate>25/06/2019</CreatedDate>
    <ClosedDate>26/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3353</PullRequestID>
        <IssueID>3317</IssueID>
        <Title>Source-build patch removal for SDK.</Title>
        <Description>Source-build has some patches that we are currently applying to your repo.  This issue tracks removing the patches.  These patches can be found at https://github.com/dotnet/source-build/tree/release/3.0/patches/sdk.

Patches that have the responsibility "Repo" and the Disposition "Incorporate" are patches that we believe are valid source-build fixes that should be moved into your repo.  Please let us know if these don't seem like good patches.  Any changes with the responsibility "source-build" is something that we plan to keep going forward or integrate in another way - please also let us know if you think there may be problems with those patches.

Patch name | Type | Disposition | Responsibility | Notes
-- | -- | -- | -- | --
sdk/0001-Upgrade-to-netcoreapp2.1.patch | ToolCompat | Incorporate | Repo | 
sdk/0002-Add-missing-PlatformAbstractions-reference.patch | Bug | Incorporate | source-build |  
sdk/0003-Consolidate-versions.patch | Coherence | Incorporate | source-build |  

</Description>
        <CreatedDate>10/06/2019</CreatedDate>
        <ClosedDate>26/06/2019</ClosedDate>
        <Labels>
          <Label>source-build</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3348</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Unify more build and publish logic</Title>
    <Description>Implement some of the unification in #3311, but without changing the product behavior.

Determines which assets should be copied local for both build and publish in the `ResolvePackageAssets` task.</Description>
    <CreatedDate>21/06/2019</CreatedDate>
    <ClosedDate>25/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3348</PullRequestID>
        <IssueID>3311</IssueID>
        <Title>Exclude Publish="false" package assets from build output, don't infer Publish="false" from PrivateAssets="all"</Title>
        <Description>See https://github.com/dotnet/designs/pull/78</Description>
        <CreatedDate>07/06/2019</CreatedDate>
        <ClosedDate>10/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3340</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix small build issues</Title>
    <Description>Three separate small issues in three commits:


1. Fix incremental build in VS when only target files change. This had been driving me crazy causing tests to run without my targets changes. Fixed the other two while I was playing around nearby.

2. Remove outdated workaround

3. Auto-bump version of task assemblies. Fix #2953. Follows [Arcade recommendation](https://github.com/dotnet/arcade/blob/master/Documentation/CorePackages/Versioning.md#recommanded-settings). </Description>
    <CreatedDate>18/06/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3340</PullRequestID>
        <IssueID>2953</IssueID>
        <Title>Assembly version stopped being bumped with every build in 2.1.300+</Title>
        <Description>MSBuild on desktop cannot load more than one version of our tasks unless we bump the assembly version. (MSBuild on coreclr can't either, but we have a 1:1 msbuild:sdk relationship on coreclr so it's moot. The current limitations on coreclr are even worse, can't load SxS in same load context regardless of version, but again moot here.)

If an MSBuild node is alive using a different build of the same Major.Minor.Patch release, then it will use targets from the new build and tasks from the old one. When there are contract changes between the tasks and targets, this can lead to confounding errors  like "task X could not be loaded from Microsoft.NET.Build.Tasks.dll" or "task Y does not take parameter Z". 

We got around this in the past by bumping the assembly version with every build. Since tasks are always dynamically loaded and never referenced directly at compilation time, this doesn't have the usual negative consequences of requiring excessive binding redirects, etc.

This has a history of regressing with infrastructure (repo toolset, arcade, etc.,) because the infrastructure is opinionated that the build number should not be part of the assembly version, which makes sense for most things, but not build tasks. We need to add test coverage to stop this from regressing. It can go a long time unreported because 1) things might still work when mixing tasks and targets between builds and 2) msbuild nodes eventually shut down and things start working again, letting the problem get chalked up to flakiness that can't be reproduced.

Now, with the move to build-to-build upgrades of patches, https://github.com/dotnet/core-sdk/pull/530, I think there will be a prompt to terminate users of older build or a prompt to reboot following the upgrade.That would mitigate this, but we should still be defensive for forced SxS patch installs (via .zip or whatever).</Description>
        <CreatedDate>16/02/2019</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3333</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update stage 0</Title>
    <Description>Replaces #3332, hopefully fixing test failures</Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>14/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3333</PullRequestID>
        <IssueID>3332</IssueID>
        <Title>Update stage 0</Title>
        <CreatedDate>14/06/2019</CreatedDate>
        <ClosedDate>14/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3331</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Preserve metadata from Reference items</Title>
    <Description>Fix #2254 </Description>
    <CreatedDate>14/06/2019</CreatedDate>
    <ClosedDate>19/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3331</PullRequestID>
        <IssueID>2254</IssueID>
        <Title>Reference metadata is not preserved by ImplicitlyExpandNETStandardFacades</Title>
        <Description>For a project targeting .Net Framework 4.7.1 with a reference to netstandard libraries, the target `ImplicitlyExpandNETStandardFacades` replaces certain references with their Facades so netstandard based assemblies work as expected. This currently works great if the project does not associate metadata(like aliases) with any of these references, but when it does - those aren't honored breaking build. 

Filing this issue to ensure that the missing metadata is preserved when the replacement is done.

Adding few more details, here is the reference in question:
``
Notice the missing alias to System.Net.http.</Description>
        <CreatedDate>17/05/2018</CreatedDate>
        <ClosedDate>19/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3330</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't hash DesignTimeBould for ResolvePackageAssets</Title>
    <Description>Fixes #3313 </Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>14/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3330</PullRequestID>
        <IssueID>3313</IssueID>
        <Title>DesignTimeBuild is included in ResolvePackageAssets HashSettings</Title>
        <Description>This will cause the cache to be rebuilt always when building after a design time build, or design time building after a build.

The test was updated to allow DesignTimeBuild to not be in the cache:

https://github.com/dotnet/sdk/blob/de72490d26acee011e22f40113209323976980e0/src/Tasks/Microsoft.NET.Build.Tasks.UnitTests/GivenAResolvePackageAssetsTask.cs#L21

But it is actually written:

https://github.com/dotnet/sdk/blob/de72490d26acee011e22f40113209323976980e0/src/Tasks/Microsoft.NET.Build.Tasks/ResolvePackageAssets.cs#L376

Probably need a test that checks the opposite of the settings hash test for DesignTimeBuild: that you can change it without influencing the hash.</Description>
        <CreatedDate>08/06/2019</CreatedDate>
        <ClosedDate>14/06/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3327</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Reduce verbosity of conflict resolution</Title>
    <Description>Also:
* Reduce line noise in preview message
* Log info about arbitrary copy-local choice in conflict resolution

Fix #2468 
Fix #3319 </Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3327</PullRequestID>
        <IssueID>2468</IssueID>
        <Title>Preview message should not have a code.</Title>
        <Description>We were trying to shorten this and adding a code to the error message causes msbuild to list the file. (And, btw, RuntimeIdentifierInference.targets is a weird place for this logging.)

We will need to tweak the tests to allow this to not have a code as I added enforcement that all messages have codes, but I think this one needs to be a special case.

### Expected
``</Description>
        <CreatedDate>10/08/2018</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3327</PullRequestID>
        <IssueID>3319</IssueID>
        <Title>Issues with conflict resolution logging</Title>
        <Description>1. At normal verbosity, there are unactionable messages about things that happen in very common cases. For example, every core WPF project has a conflict between WindowsBase in netcore app. Importance should be lowered so that you can still see in binlog/diag, but not otherwise. We regularly get questions about what to do about a conflict, when there is nothing to do.

2. It is quite noisy to have codes associated with non-error, non-warnings. We should refactor to not bother having codes for messages. Related: https://github.com/dotnet/sdk/issues/2468

3. We are concatenating strings, so we end up with a code inside a code. NETSDKXXXX: Encountered conflict yada, yada.  NETSDKYYYY. Choosing Foo.



</Description>
        <CreatedDate>11/06/2019</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3326</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Support PublishReadyToRun for framework-dependent deployment</Title>
    <Description>Fix #3110 </Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3326</PullRequestID>
        <IssueID>3110</IssueID>
        <Title>Resolve runtime pack assets for crossgen even if app is framework-dependent</Title>
        <Description>Crossgen operates on implementation assemblies only, even when passed as references to the compiler. To crossgen a framework-dependent app, we need all of the framework implementation assemblies to be passed to crossgen as references.

Note that crossgen requires picking a RID. The app can be framework-dependent, but it must be RID specific. (Crossgen generates native code, which can't be rid-agnostic, obviously.) We are guaranteed to have downloaded the runtime packs, we just need to resolve the framework assemblies from it as though the app was self-contained, but without putting them in deps.json or copying them, etc.

Today, crossgen tasks can find the base shared framework implementation assemblies next to it (it ships in the base runtime pack), but this doesn't work for the other frameworks like WindowsDesktop or ASP.NET. This also can't just blindly aggregate all the files in all the runtime packs, this list needs to account for conflict resolution (WindowsBase in WindowsDesktop wins over WindowsBase in NETCoreApp), etc.</Description>
        <CreatedDate>09/04/2019</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels>
          <Label>Blocking Partner</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3320</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix duplicate resolved files to publish</Title>
    <Description>Fix #3257 

There were two issues.

1. A misunderstanding of msbuild batching rules and unqualified metadata caused satellite assemblies to be included twice (from same source location) into the publish list. (See https://github.com/microsoft/msbuild/issues/4429)
2. There are assemblies with the same name and version in multiple frameworks. We have to choose one arbitrarily.




</Description>
    <CreatedDate>11/06/2019</CreatedDate>
    <ClosedDate>12/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3320</PullRequestID>
        <IssueID>3257</IssueID>
        <Title>Double write during publish</Title>
        <Description>Publishing a self-contained WPF template app writes some files twice because `ResolvedFileToPublish` has the same dll from different runtime packs (for example, Microsoft.Win32.Registry.dll comes from both netcoreapp and the windowsdesktop pack).
This causes crossgen failures when used together with `PublishReadyToRun=true`.

Looks very similar to https://github.com/dotnet/sdk/issues/3035 which was addressed in https://github.com/dotnet/sdk/pull/3021, but I'm still seeing this with version `3.0.100-preview6-012031`.

/cc @fadimounir @nguerrera @peterhuene 

edit: it fails during `PublishReadyToRun=true` only when used together with the linker. Without linking, the duplicates are already crossgen'd, and so they don't hit the failure. In any case, `ResolvedFileToPublish` has duplicates that shouldn't be there, and we end up with `DoubleWrites` of some files.

&lt;img width="565" alt="image" src="https://user-images.githubusercontent.com/787361/58192612-00a04780-7c76-11e9-8ffc-102d4b993fb2.png"&gt;
</Description>
        <CreatedDate>22/05/2019</CreatedDate>
        <ClosedDate>12/06/2019</ClosedDate>
        <Labels>
          <Label>Blocking Partner</Label>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3315</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>vatsan-madhavan</FixedByID>
    <Title>Add warnings related to Microsoft.NET.Sdk.WindowsDesktop</Title>
    <Description>Related: #3126 
This is also needed to completely fix https://github.com/dotnet/wpf/issues/866 - we still can't support support multitargeting `netcoreapp2.2`, and also to fix https://github.com/dotnet/wpf/issues/867

- Adds warning strings related to `Microsoft.NET.Sdk.WindowsDesktop`
- Adds a check to warn when `UseWpf` or `UseWindowsForms` is set without including `Microsoft.NET.Sdk.WindowsDesktop`</Description>
    <CreatedDate>10/06/2019</CreatedDate>
    <ClosedDate>16/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3315</PullRequestID>
        <IssueID>3126</IssueID>
        <Title>Warn if project is missing both Desktop SDK and UseWPF/UseWinForms</Title>
        <Description>Even if we have cool tooling that adds the appropriate stuff to a project file based on various actions in the IDE, there will still be users who manually edit their WinForms/WPF project files.

We should emit a warning under the following conditions:

* `Microsoft.NET.Sdk.WindowsDesktop` is specified but there is no `UseWPF` or `UseWinForms`
* `UseWPF` or `UseWinForms` is specified but the SDK attribute is not `Microsoft.NET.Sdk.WindowsDesktop`

In the first case, it would be great if the warning could say something to the effect of:

"Microsoft.NET.Sdk.WindowsDesktop is specified, but no corresponding UseWPF or UseWinForms property was found."

In the latter case, using WPF as an example, something to the effect of:

"UseWPF was specified but the SDK attribute is not Microsoft.NET.Sdk.WindowsDesktop"

Not sure if this is an SDK concern or not, but I figured I'd log it somewhere.</Description>
        <CreatedDate>12/04/2019</CreatedDate>
        <ClosedDate>02/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3310</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix P/Invoke signatures for the resource updater.</Title>
    <Description>The resource updater was not specifying a CharSet for the Windows API
P/Invoke signatures and therefore the ANSI versions of the APIs were
being used.

This caused an unhandled exception when customizing the apphost on
Windows when the intermediate apphost path contained Unicode characters
because the ANSI resource updating API couldn't find the file.

Fixes [AB#900429](https://devdiv.visualstudio.com/0bdbc590-a062-4c3f-b0f6-9383f67865ee/_workitems/edit/900429).</Description>
    <CreatedDate>06/06/2019</CreatedDate>
    <ClosedDate>07/06/2019</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>3303</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Resolve runtime target assets without copying for non-netcoreapp targets.</Title>
    <Description>A [previous change](https://github.com/peterhuene/sdk/commit/545410772bb7c41d26b22dd9f3ba0cd3e8acd63e) disabled the resolution of runtime target assets when not
targeting netcoreapp by default. However, some users may want to be able to
inspect the runtime target assets from their package dependencies without
having them copied locally by default when not targeting netcoreapp.

This commit changes the previous fix by resolving the runtime target assets to
populate the `RuntimeTargetsCopyLocalItems` group, but sets the `CopyLocal`
metadata to false which prevents the items from ultimately being included in
the copy local files.  The property `CopyLocalRuntimeTargetAssets` now controls
this behavior, which defaults to `true` only when netcoreapp is the target TFM.

Fixes #3261.</Description>
    <CreatedDate>05/06/2019</CreatedDate>
    <ClosedDate>05/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3303</PullRequestID>
        <IssueID>3261</IssueID>
        <Title>Consider making runtime target assets available as an item</Title>
        <Description>In part of the MSBuild build that attempts to assemble a set of build tools to make a usable MSBuild distribution (sort of a mini-`core-sdk` for our own bootstrap purposes), we extracted some specific items to copy from the `@(RuntimeCopyLocalItems)` and `@(ResolvedRuntimeTargets)` items output by `ResolvePackageAssets`:

https://github.com/microsoft/msbuild/blob/0411d07a7853af88f2555dd84258c005bdce709c/eng/BootStrapMSBuild.targets#L31-L41

In 3.0-preview5, `@(ResolvedRuntimeTargets)` was renamed to `@(RuntimeTargetsCopyLocalItems)`, and it is not populated in full framework builds, unless the explicit opt-out `$(DisableRuntimeTargets)` is set to `false`.

It might be worth creating the items for explicit use by custom targets, and just not adding them to the default copy local/publish items in the full framework build.</Description>
        <CreatedDate>23/05/2019</CreatedDate>
        <ClosedDate>05/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3284</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix failure to read assets cache file the first time it's written</Title>
    <Description>Fixes issue reported by @nguerrera, introduced in #3268:

&gt; Seeing message NETSDK1062: Unable to use package assets cache due to I/O error. This can occur when the same project is built more than once in parallel. Performance may be degraded, but the build result will not be impacted. [D:\Temp\demo\demo.csproj]
&gt;
&gt; Looks like the change you made has the file still open for write when we try to read it back on first build.
&gt;
&gt; Can you take a look, this will be a significant perf regression in preview 6

Fix #3287</Description>
    <CreatedDate>31/05/2019</CreatedDate>
    <ClosedDate>31/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3284</PullRequestID>
        <IssueID>3268</IssueID>
        <Title>Use PackageDownload in VS, fix design time build failures</Title>
        <Description>- Use PackageDownload when supported on full MSBuild.  Fixes https://github.com/dotnet/cli/issues/10440
- Don't fail design-time builds when the target framework or RuntimeIdentifier doesn't match what's in the (now outdated) assets file.  Fixes #2322
  - I'd like to add tests to cover this, but haven't yet</Description>
        <CreatedDate>26/05/2019</CreatedDate>
        <ClosedDate>29/05/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3284</PullRequestID>
        <IssueID>3287</IssueID>
        <Title>Getting package assets cache messages on build with the latest master bits</Title>
        <Description>@nguerrera, @dsplaisted: I started getting loads of messages during build in the winforms-designer repo after updating to the most recent SDK:

``

Are these messages possibly related to https://github.com/dotnet/sdk/pull/3268? It looks like this error comes from ResolvePackageAssets.cs and those are the most recent changes around the code that triggers this message. Setting `&lt;DisablePackageAssetsCache&gt;true&lt;/DisablePackageAssetsCache&gt;` makes the messages go away, but it doesn't seem like the right fix.</Description>
        <CreatedDate>31/05/2019</CreatedDate>
        <ClosedDate>31/05/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3283</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix filtering of satellite assemblies when publishing for netcoreapp3.0.</Title>
    <Description>This PR fixes filtering of satellite assemblies when publishing an
application targeting netcoreapp3.0.

An incorrect property name in the `_FilterSatelliteResourcesForPublish` target
was causing the satellite filtering done for publish to have no effect.

This was only a problem when not reusing the build output for publish;
unfortunately this is currently the case for netcoreapp3.0 targeted
applications due to references that are marked as `PrivateAssets="all"`.

This PR fixes the property name and adds test coverage for publishing
when targeting netcoreapp3.0 with filtered satellite assemblies.

Fixes #3277.</Description>
    <CreatedDate>31/05/2019</CreatedDate>
    <ClosedDate>31/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3283</PullRequestID>
        <IssueID>3277</IssueID>
        <Title>SatelliteResourceLanguages doesn't filter resources from Publish output when targeting .NET Core 3.0</Title>
        <Description>Publish the following project:

``

## Expected

Publish folder should only have resource subfolders for `de` and `pt`.

## Actual

The publish folder will include the Humanizer resources for all languages the package supports:

![image](https://user-images.githubusercontent.com/145043/58606671-4f8b4580-8251-11e9-9e22-593e29ceab4d.png)

## Notes

When targeting .NET Core 2.2, the publish output is correctly filtered.  Also, when targeting .NET Core 3.0, the build output is correctly filtered, but the publish output is not.

FYI @peterhuene @livarcocc, we should fix this for 3.0</Description>
        <CreatedDate>30/05/2019</CreatedDate>
        <ClosedDate>31/05/2019</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3275</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Log error when building for Windows Desktop on non-Windows.</Title>
    <Description>This PR causes the SDK to log an error (NETSDK1100) if the user attempts to
build a Windows Desktop targeted application on a non-Windows platform.

This works via any explicit or implicit (i.e. from the SDK) framework reference
to `Microsoft.WindowsDesktop.App*`; if the current platform is not Windows and
the framework reference exists, the error is logged.

Fixes dotnet/cli#11410 and dotnet/cli#10842.</Description>
    <CreatedDate>30/05/2019</CreatedDate>
    <ClosedDate>31/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3275</PullRequestID>
        <IssueID>10842</IssueID>
        <Title>Update dependencies from https://github.com/NuGet/NuGet.Client build …</Title>
        <Description>…5.6.0.6489 (#10813)

- NuGet.Build.Tasks - 5.6.0-preview.2.6489

Co-authored-by: dotnet-maestro[bot] &lt;dotnet-maestro[bot]@users.noreply.github.com&gt;</Description>
        <CreatedDate>12/03/2020</CreatedDate>
        <ClosedDate>12/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3268</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Use PackageDownload in VS, fix design time build failures</Title>
    <Description>- Use PackageDownload when supported on full MSBuild.  Fixes https://github.com/dotnet/cli/issues/10440
- Don't fail design-time builds when the target framework or RuntimeIdentifier doesn't match what's in the (now outdated) assets file.  Fixes #2322
  - I'd like to add tests to cover this, but haven't yet</Description>
    <CreatedDate>26/05/2019</CreatedDate>
    <ClosedDate>29/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3268</PullRequestID>
        <IssueID>2322</IssueID>
        <Title>[Feedback] We should not be breaking design-time builds when the assets file is missing framework data</Title>
        <Description>https://developercommunity.visualstudio.com/content/problem/232872/adding-existing-multitargeted-sdk-csproj-causes-er.html
https://developercommunity.visualstudio.com/content/problem/234605/projects-with-multiple-targetframeworks-restore-on.html

When a project contains multiple TFMs, there is a race where we can perform a design-time build for one of the TFMs that errors because the assets file is missing data for one of the other TFMs. This prevents us from sending data to NuGet that would resolve the issue.

&gt; @davkean says:
&gt; This isn’t a regression, and I can see what is happening. Probably more common due to performance improvements or changes in NuGet restore logic (did you reduce the timeout?)
&gt; In summary, due to timing the design-time build is failing, causing us to fail to nominate NuGet:
&gt; 
&gt; Given a project with net45;net452;netstandard20


&gt; net45 design-time build starts
&gt; net46 design-time build starts
&gt; net45 design-time build finishes (tell NuGet about TFM + Packages)
&gt; net46 design-time build finishes (tell NuGet about TFM + Packages)
&gt; NuGet restores (assets file only contains net45/net46 and not netstandard20)
&gt; netstandard20 design-time builds starts
&gt; netstandard20 design-time build fails with:
 
&gt;
&gt; error : Assets file 'C:\Users\davkean\Downloads\obj\project.assets.json' doesn't have a target for '.NETStandard,Version=v2.0'. Ensure that restore has run and that you have included 'netstandard2.0' in the TargetFrameworks for your project.
&gt;
&gt; That prevents us from telling NuGet about netstandard20.
&gt;
&gt; It’s a bit of a flaw that this error blocks the build from completing. We should rethink that – we should also consider not nominating for restore unless the first build of all TFMs have completed to prevent NuGet from double restoring.&gt; 

and 

&gt; @davkean says:
&gt; We came to the conclusion that we're going to remove the error that checks to see if the assets file contains the TFM for design-time builds; it will still continue to occur for solution/command-line builds.
&gt; 

</Description>
        <CreatedDate>12/06/2018</CreatedDate>
        <ClosedDate>29/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3255</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Fix generate package on build pack as tool</Title>
    <Description>NuGet/Home#7801

(the easiest way to understand that is)since nuget no longer sets NoBuild on GeneratePackageOnBuild, we need to do similar logic to get the previous state.

fix https://github.com/dotnet/sdk/issues/3253</Description>
    <CreatedDate>22/05/2019</CreatedDate>
    <ClosedDate>22/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3255</PullRequestID>
        <IssueID>7801</IssueID>
        <Title>"dotnet new" can generate invalid code if directory name is not a valid C# namespace identifier</Title>
        <Description>## Steps to reproduce
``</Description>
        <CreatedDate>23/02/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3252</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update NuGet</Title>
    <Description>Replacement for #3243, on top of #3250 which should hopefully fix things.</Description>
    <CreatedDate>21/05/2019</CreatedDate>
    <ClosedDate>22/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3252</PullRequestID>
        <IssueID>3243</IssueID>
        <Title>Insert NuGet 5.2.0-preview2.6020 into master</Title>
        <CreatedDate>16/05/2019</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3252</PullRequestID>
        <IssueID>3250</IssueID>
        <Title>Update stage 0</Title>
        <Description>Should unblock #3243</Description>
        <CreatedDate>20/05/2019</CreatedDate>
        <ClosedDate>21/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3250</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update stage 0</Title>
    <Description>Should unblock #3243</Description>
    <CreatedDate>20/05/2019</CreatedDate>
    <ClosedDate>21/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3250</PullRequestID>
        <IssueID>3243</IssueID>
        <Title>Insert NuGet 5.2.0-preview2.6020 into master</Title>
        <CreatedDate>16/05/2019</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3247</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Copy runtime pack resource assemblies on self-contained build/publish.</Title>
    <Description>This commit implements copying resource assemblies for self-contained
build/publish from runtime packs.

Closes #3068.</Description>
    <CreatedDate>17/05/2019</CreatedDate>
    <ClosedDate>17/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>3247</PullRequestID>
        <IssueID>3068</IssueID>
        <Title>Support framework satellite assemblies in self-contained deployment</Title>
        <Description>The runtime packs for Microsoft.WindowsDesktop.App now have satellites assemblies. However, they are not used by self-contained build or publish.

They should be deployed exactly as satellites from a NuGet package. That is:

1. If `$(SatelliteResourceLanguages)` is not specified, then all satellites are deployed.

2. If `$(SatelliteResourceLanguages)` is specified, then only matching satellites are deployed.

cc @dsplaisted @leecow @vivmishra

This is needed for .NET Core 3.0 Preview 6</Description>
        <CreatedDate>01/04/2019</CreatedDate>
        <ClosedDate>17/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2778</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>jp2masa</FixedByID>
    <Title>Added back the PublishDepsFilePath property</Title>
    <Description>Fixes #2777

## Changes
- Added back the PublishDepsFilePath property.</Description>
    <CreatedDate>29/12/2018</CreatedDate>
    <ClosedDate>31/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2778</PullRequestID>
        <IssueID>2777</IssueID>
        <Title>.NET Global Tools publish broken</Title>
        <Description>.NET Global Tools publish uses the `PublishDepsFilePath` property to include the deps file, but it no longer exists (.NET Core 3.0 Preview 1).

This bug was introduced here: https://github.com/dotnet/sdk/commit/1936ebd7307cebd6c5d1d8d699b9844f73b8fb2c#diff-7dc833d02f198e5a9f0ab88e229db18aL520.

I believe that the property shouldn't have been removed.</Description>
        <CreatedDate>29/12/2018</CreatedDate>
        <ClosedDate>31/12/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2774</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Resolve assets from targeting pack</Title>
    <Description>First steps for dotnet/cli#10085

- References "Targeting Packs" with ExcludeAssets="all", and resolves assets from the targeting packs directly (instead of going through the assets file)
- References "Runtime Packs" if necessary to support self-contained publish (these still go through the assets file for now)
- For now, hard-codes a `KnownFrameworkReference` to Microsoft.NETCore.App, and includes the RID graph directly.  These will need to be added to core-sdk
- The list of runtime packs for each `KnownFrameworkReference`, and the RIDs available, will also need to be supplied by core-sdk</Description>
    <CreatedDate>26/12/2018</CreatedDate>
    <ClosedDate>11/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2774</PullRequestID>
        <IssueID>10085</IssueID>
        <Title>Mark shipping/non-shipping assets appropriately across all of our repos</Title>
        <Description>The following repos need changes to IsShipping metadata:

* cli
* cliCommandLineParser
* sdk
* toolset

None of these repos ship packages directly. The packages are all transport-only. Therefore, IsShippingPackage should be false for all of them. 

* For each repo, make sure we have https://github.com/dotnet/arcade/pull/1900

* Make sure all test projects are IsShipping=false (therefore IsShippingAssembly=false, IsShippingPackage=false)

* Product projects should be IsShippingAssembly=true, IsShippingPackage= false

cc @chcosta </Description>
        <CreatedDate>31/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2740</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Fix the build</Title>
    <Description>Two severe issues:

1. Official build is failing, and it's apparently at a line where we are attempting to use undefined $env:VSSDKInstall. It is unclear what this line was accomplishing so I've removed it. I suspect it may have been working around past arcade version issues. Does that ring a bell?

2. In the port to arcade, the act of running tests against full msbuild was coupled to building with full msbuild whereas before it was a custom build argument. Now the latest arcade is always building with VS when available, which means our tests are not running on core on Windows on any leg. I've tied it to an env var instead of the build engine. This also removes the requirement to have VS installed to build. It is now used only when testing full msbuild as it was originally.

Fixes #2589

Changes to eng\common are mirrored in https://github.com/dotnet/arcade/pull/1594

Also fixed some annoyances encountered while debugging this:

* build on command line will use stage0 sdk always, not ambient sdk on PATH

* dogfood script now puts stage0 dotnet on PATH too

* Locate stage0 bundled versions irrespective of SDK version used to build. This could cause tests to fail in VS if using an ambient SDK from Program Files. 
</Description>
    <CreatedDate>11/12/2018</CreatedDate>
    <ClosedDate>15/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2740</PullRequestID>
        <IssueID>2589</IssueID>
        <Title>Decouple build engine from msbuild under test in build scripts</Title>
        <Description>Main actual scenario impacted: clone repo, build, requires VS. Also causing issues for perf tests.

Plan:

- [x] Remove vswhere from global.json completely
- [x] Put vswhere as package dependency of test 
   (there's an implicit vshwhere of 2.5.2 now, so not needed)
- [x] Add a -testFullMSBuild switch (extracted from trailing $properties that are passed to common\build.ps1, and can be intercepted in configure-toolset.ps1)
   (used TestFullMSBuild=true env var instead)
- [x] Replace the yaml that is doing -msbuildengine vs with -testFullMSBuild
  (used TestFullMSBuild=true evn var instead)

cc @johnbeisner @tmat
</Description>
        <CreatedDate>16/10/2018</CreatedDate>
        <ClosedDate>15/12/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2739</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>wli3</FixedByID>
    <Title>Use PackageVersion for shim gen</Title>
    <Description>fix #2698
PackageVersion should be the source of truth for nuget layout.

https://github.com/NuGet/NuGet.Client/blob/3c9b61826814dc800a2a295f0985ce4f295483d6/src/NuGet.Core/NuGet.Build.Tasks.Pack/NuGet.Build.Tasks.Pack.targets#L28</Description>
    <CreatedDate>10/12/2018</CreatedDate>
    <ClosedDate>11/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2739</PullRequestID>
        <IssueID>2698</IssueID>
        <Title>Package Shim only look at "Version" not "PackageVersion"</Title>
        <Description>If this 2 properties are different. Shim will have the wrong path.</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>12/12/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>tool</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2738</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Support ASP.NET Core PackageReference when targeting .NET Core 3.0 or higher</Title>
    <Description>Fixes dotnet/cli#10124

Also fixes #2527</Description>
    <CreatedDate>10/12/2018</CreatedDate>
    <ClosedDate>11/12/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2738</PullRequestID>
        <IssueID>10124</IssueID>
        <Title>dotnet build on Azure Function project results in unexpected output in bin folder</Title>
        <Description>Since a couple of days ago I am running into some problems when trying to build and publish my Azure Function on a buildserver. When I build and publish my function on my local machine, it works fine but on the build server I get a different result. I've tried different versions of the .NET SDK but that does not seem to matter. Any ideas?

## Steps to reproduce
- Create an Azure Function v2 project in Visual Studio
- dotnet build -c Release
- open bin/Release folder

## Expected  behavior
Folder with bin folder like this (this is the expected result I get on my local machine):
![functions2](https://user-images.githubusercontent.com/9202734/53008000-aefadd80-3438-11e9-8524-7938eab21906.PNG)

## Actual behavior
Folder with minimal files like this (this is the output on the build server):
![functions1](https://user-images.githubusercontent.com/9202734/53008003-b15d3780-3438-11e9-87a5-0016537deb4c.PNG)

## Environment data
`dotnet --info` output:

 Version:   2.2.103
 Commit:    8edbc2570a

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17134
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.2.103\

Host (useful for support):
  Version: 2.2.2
  Commit:  a4fd7b2c84

.NET Core SDKs installed:
  1.0.0-preview2-003131 [C:\Program Files\dotnet\sdk]
  1.0.0-preview2.1-003155 [C:\Program Files\dotnet\sdk]
  1.0.0 [C:\Program Files\dotnet\sdk]
  1.1.0 [C:\Program Files\dotnet\sdk]
  2.0.0 [C:\Program Files\dotnet\sdk]
  2.1.201 [C:\Program Files\dotnet\sdk]
  2.1.402 [C:\Program Files\dotnet\sdk]
  2.2.101 [C:\Program Files\dotnet\sdk]
  2.2.103 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.1 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 1.0.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.0.5 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.0-preview1-001100-00 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 1.1.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.0.7 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.0 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.1 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.2 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]

## Project File
``</Description>
        <CreatedDate>19/02/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2738</PullRequestID>
        <IssueID>2527</IssueID>
        <Title>KnownFrameworkReferences need to be specific to a target framework version</Title>
        <Description>Right now, we have `KnownFrameworkReference` items that look something like this in Microsoft.NETCoreSdk.BundledVersions.props:

``

These are not specific to the version of .NET Core targeted.  So if you were targeting .NET Core 2.x, you could still add a `FrameworkReference` to Microsoft.DesktopUI, and we would try to add the package reference to the targeting pack.

The `KnownFrameworkReference` items should include a `TargetFrameworkVersion` on them to which they apply, and the `ResolveFrameworkReferences` task should filter them to only look at the ones that apply to the current target framework version.  (We might also want a nice error message if you have a FrameworkReference to something that's available in a different version of .NET Core).</Description>
        <CreatedDate>12/09/2018</CreatedDate>
        <ClosedDate>11/12/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2701</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Rename `_HandlePackageFileConflictsForBuild` back to `_HandlePackageFileConflicts`</Title>
    <Description>This commit renames the `_HandlePackageFileConflictsForBuild` target back to
the original name of `_HandlePackageFileConflicts`.

This prevents a failure to find the target when using a previously shipping
`Microsoft.NET.Build.Extensions.NETFramework.targets` with a 3.0 .NET Core SDK.

Fixes #2695.</Description>
    <CreatedDate>28/11/2018</CreatedDate>
    <ClosedDate>28/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2701</PullRequestID>
        <IssueID>2695</IssueID>
        <Title>ImplicitlyExpandNETStandardFacades does not run when using full framework MSBuild and 3.0 .NET Core SDK</Title>
        <Description>As part of unifying publish and build (https://github.com/dotnet/sdk/commit/1936ebd7307cebd6c5d1d8d699b9844f73b8fb2c#diff-037688beff60348f7a74e33446cb6131), we split _HandlePackageFileConflicts into two targets: _HandlePackageFileConflictsForBuild and _HandlePackageFileConflictsForPublish.

This required updating the `BeforeTargets` declaration of the ImplicitlyExpandNETStandardFacades target in Microsoft.NET.Build.Extensions.NETFramework.targets.

Unfortunately, that targets file ships separately for the .NET Core SDK and full Framework MSBuild.  So if you have a 3.0 SDK but are building with full-framework MSBuild, you will get the old copy of Microsoft.NET.Build.Extensions.NETFramework.targets, which expects there to be a _HandlePackageFileConflicts target instead of _HandlePackageFileConflictsForBuild.

Probably the way to fix this is to rename _HandlePackageFileConflictsForBuild to _HandlePackageFileConflicts, and _HandlePackageFileConflictsForPublish can still be a separate target (at least for now).

@peterhuene, thoughts?</Description>
        <CreatedDate>27/11/2018</CreatedDate>
        <ClosedDate>28/11/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2700</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Skip resource updating on Nano Server.</Title>
    <Description>This commit fixes the resource updater usage to be skipped when building on
Nano Server.

For Windows Server Nano 2016, this fixes an `EntryPointNotFoundException` because
`BeginUpdateResource` cannot be found in kernel32.

For 1709+ of Windows Server Nano, this fixes an `HResultException` with code
`80070000`, because the export resolves but seemingly is not implemented.

Fixes #2652.</Description>
    <CreatedDate>28/11/2018</CreatedDate>
    <ClosedDate>28/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2700</PullRequestID>
        <IssueID>2652</IssueID>
        <Title>CreateAppHost task fails within Nano Server containers in 3.0</Title>
        <Description>Using SDK version 3.0.100-preview-009734

1. Start with a `microsoft/nanoserver` container with dotnet 3.0 SDK installed (e.g. `microsoft/dotnet-nightly:3.0-sdk` [Dockerfile](https://github.com/dotnet/dotnet-docker/blob/8246e49feb420454055daddbac2120b40dc88c41/3.0/runtime/nanoserver-1803/amd64/Dockerfile))
2. mkdir app
3. cd app
4. dotnet new
5. dotnet build

Results:

``
</Description>
        <CreatedDate>07/11/2018</CreatedDate>
        <ClosedDate>28/11/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2684</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Use `PreserveNewest` for explicitly published files.</Title>
    <Description>The publish targets contain files that are explicitly published, such as the
build output, the deps file, the runtime config, etc.  Because the default for
resolved files to publish was to always copy, a second publish operation when
everything was up-to-date had needless copies of these files.

This commit changes those items to use `PreserveNewest` so that they are only
copied if the source is newer than the target.

Fixes #2573.</Description>
    <CreatedDate>21/11/2018</CreatedDate>
    <ClosedDate>19/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2684</PullRequestID>
        <IssueID>2573</IssueID>
        <Title>Publishing is not incremental</Title>
        <Description>Repro project:
``

Run msbuild twice:
`msbuild /bl:Repro1.binlog`
`msbuild /bl:Repro2.binlog`

The files are copied twice. 

![image](https://user-images.githubusercontent.com/41759/46638412-9f2bce00-cb15-11e8-9104-7866f9a2ebe4.png)

</Description>
        <CreatedDate>08/10/2018</CreatedDate>
        <ClosedDate>19/02/2019</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2681</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Add back `RunResolvePublishAssemblies` target.</Title>
    <Description>This commit adds the `RunResolvePublishAssemblies` target back as a no-op
target.  The Azure Functions SDK relies on this target for making copy local
work for build.  However, since the 3.0 SDK behaves the same as publish for
build copy local, this is no longer necessary.

Adding the target back will prevent the Azure Functions SDK from breaking.

Fixes dotnet/cli#10363.</Description>
    <CreatedDate>20/11/2018</CreatedDate>
    <ClosedDate>20/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2681</PullRequestID>
        <IssueID>10363</IssueID>
        <Title>dotnet build+publish and dotnet publish does not produce the same result - fails when running as unprivileged user in Docker container</Title>
        <Description>When the Dockerfile has both the steps `dotnet build` and `dotnet publish`, then the error `realpath(): Permission denied` appears at runtime when running as unprivileged user

## Steps to reproduce

1. Create simple webapp with command 
`dotnet new webapp -o mywebapp --no-https` 
2. Use Dockerfile from here: 
https://github.com/Lybecker/dotnetclibug/blob/master/Dockerfile
3. Uncomment line 15
`RUN dotnet build "mywebapp.csproj" -c Release -o /app`
4. Build the container 
`docker build -t mywebapp:issue .`
5. Execute the container 
`docker run –rm mywebapp:issue`

The problem only appears, when uncomment line 15

The issue has been reproduced have reproduced the issue on Windows and Linux.

## Expected  behavior
The dotnet kestrel process starts without any errors.

## Actual behavior
`docker run --rm mywebapp:issue`
_realpath(): Permission denied
realpath(): Permission denied
realpath(): Permission denied_
warn: Microsoft.AspNetCore.DataProtection.Repositories.EphemeralXmlRepository[50]
      Using an in-memory repository. Keys will not be persisted to storage.
warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[59]
      Neither user profile nor HKLM registry available. Using an ephemeral key repository. Protected data will be unavailable when application exits.
warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]
      No XML encryptor configured. Key {ea673121-40e4-4712-9072-58e595942f1d} may be persisted to storage in unencrypted form.
Hosting environment: Production
Content root path: /app
Now listening on: http://[::]:8080
Application started. Press Ctrl+C to shut down.

## Environment data
Reproduced on Linux and Windows:

**Linux**
.NET Core SDK (reflecting any global.json):
 Version:   2.2.300
 Commit:    73efd5bd87

Runtime Environment:
 OS Name:     ubuntu
 OS Version:  18.04
 OS Platform: Linux
 RID:         ubuntu.18.04-x64
 Base Path:   /usr/share/dotnet/sdk/2.2.300/

Host (useful for support):
  Version: 2.2.5
  Commit:  0a3c9209c0

.NET Core SDKs installed:
  2.2.300 [/usr/share/dotnet/sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.2.5 [/usr/share/dotnet/shared/Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.2.5 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.2.5 [/usr/share/dotnet/shared/Microsoft.NETCore.App]

**Windows**
.NET Core SDK (reflecting any global.json):
 Version:   2.2.202
 Commit:    8a7ff6789d

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.17763
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\2.2.202\

Host (useful for support):
  Version: 2.2.3
  Commit:  6b8ad509b6

.NET Core SDKs installed:
  2.1.504 [C:\Program Files\dotnet\sdk]
  2.1.505 [C:\Program Files\dotnet\sdk]
  2.1.602 [C:\Program Files\dotnet\sdk]
  2.2.105 [C:\Program Files\dotnet\sdk]
  2.2.202 [C:\Program Files\dotnet\sdk]

.NET Core runtimes installed:
  Microsoft.AspNetCore.All 2.1.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.All 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.All]
  Microsoft.AspNetCore.App 2.1.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 2.1.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.1.9 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 2.2.3 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]







</Description>
        <CreatedDate>02/07/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2665</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix publishing WPF assets</Title>
    <Description>Fixes #2654 </Description>
    <CreatedDate>15/11/2018</CreatedDate>
    <ClosedDate>15/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2665</PullRequestID>
        <IssueID>2654</IssueID>
        <Title>PresentationFramework not found in SelfContainedDeployments</Title>
        <Description>_From @rido-min on November 8, 2018 22:29_

# PresentationFramework not found in SelfContainedDeployments

1 - Create WPF app `dotnet new wpf`
2 - Create a Publishing Profile with Self Contained and a RID:
``

_Copied from original issue: dotnet/core#2044_</Description>
        <CreatedDate>08/11/2018</CreatedDate>
        <ClosedDate>15/11/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2646</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Implement copy-local of package dependencies for 3.0 targeted projects. </Title>
    <Description>This PR implements some of the unification of the `dotnet build` and
`dotnet publish` experiences.

For 3.0 targeted projects, `dotnet build` will now copy the package
dependencies locally into the output directory instead of relying on the NuGet
cache.  It behaves the same as `dotnet publish`, only copying what is not
provided by the shared frameworks.

Additionally, `dotnet publish` will now copy the build outputs rather than
regenerating a deps file or resolving package dependencies, provided there are
no package references excluded from publishing or packages are coming from a
runtime store.

The `CopyLocalLockFileAssemblies` property can be set to `false` to revert to
the previous behavior for `dotnet build`.

Fixes dotnet/cli#10061.
Fixes #933.

</Description>
    <CreatedDate>06/11/2018</CreatedDate>
    <ClosedDate>13/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2646</PullRequestID>
        <IssueID>10061</IssueID>
        <Title>dotnet new angular boilerplate doesn't connect API with client</Title>
        <Description>## Steps to reproduce

1. `dotnet new angular --name=MyApp`
2. `cd MyApp`
3. `dotnet build`
4. `dotnet run`
5. Open the url that the terminal displays in the browser, e.g., http://localhost:53000
6. Click the Fetch Data button in the top nav

## Expected  behavior
- Data should be displayed  
- The network tab should show a 200 OK for the endpoint /api/SampleData/WeatherForecasts

## Actual behavior
- Loading... is displayed indefinitely
- The network tab returns a 404 NOT FOUND for the endpoint /api/SampleData/WeatherForecasts

![image](https://user-images.githubusercontent.com/13296622/51394398-80b37680-1af7-11e9-9f40-61f00455b299.png)


## Environment data
`dotnet --info` output:

``






</Description>
        <CreatedDate>18/01/2019</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2646</PullRequestID>
        <IssueID>933</IssueID>
        <Title>Filtering CopyLocalLockFileAssemblies</Title>
        <Description>When you use CopyLocalLockFileAssemblies with a netcoreapp project, it copies shared framework assets too.

While you can use publish instead to copy without those assemblies, there are circumstances where its more practical and efficient to just have the single build step. In particular pack is driven by build output not publish output. Consider the case where I want to flatten dependencies in a nupkg (e.g. as currently required to package msbuild tasks).

One way to address this would be to just have a flag to apply the same filtering as publish to CopyLocalLockFileAssemblies.

Alternatively, I find myself wishing that I could just slap metadata on my package references to exclude their full closure from CopyLocal. ExcludeAssets=Runtime almost works, but if I have another sibling package that pulls in overlapping assets in its closure, they get re-included.

In the msbuild task scenario, I really want to say "copy everything that is not in the closure of Microsoft.NETCore.App, Microsoft.Build.Framework, or Microsoft.Build.Utilities.Core"

I managed to get close enough to that with this workaround:

``
</Description>
        <CreatedDate>03/03/2017</CreatedDate>
        <ClosedDate>13/11/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2643</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix resource updating for the apphost when the assembly contains no resources.</Title>
    <Description>This commit fixes the resource updater so that it can handle enumerating
resources on an assembly that contains no Win32 resources.

Fixes #10276.</Description>
    <CreatedDate>03/11/2018</CreatedDate>
    <ClosedDate>04/11/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2643</PullRequestID>
        <IssueID>10276</IssueID>
        <Title>Multiple global tool versions installed with unexpected behaviours thereafter</Title>
        <Description>## Steps to reproduce

I honestly don't know how I or `dotnet tool install -g` got me here 😕 but I have two version of [`dotnet-try`](https://www.nuget.org/packages/dotnet-try/) installed:

``
</Description>
        <CreatedDate>21/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2625</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix NuGet.config casing</Title>
    <Description>Should fix Ubuntu failures in #2615

Sending a new version of #2619 and #2622, hopefully with #2623 merged everything well work now!</Description>
    <CreatedDate>26/10/2018</CreatedDate>
    <ClosedDate>26/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2625</PullRequestID>
        <IssueID>2615</IssueID>
        <Title>[Darc-Update] Update dependencies from build 20181025.8 of https://github.com/dotnet/arcade</Title>
        <Description>This change updates the dependencies from https://github.com/dotnet/arcade to the following

- Microsoft.AspNetCore.ApiVersioning - 1.0.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.Swashbuckle.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.ApiCompat.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Arcade.Sdk.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Build.Tasks.Feed.2.2.0-beta.18525.8.symbols.nupkg - 2.2.0-beta.18525.8
- symbols/Microsoft.DotNet.Build.Tasks.Packaging.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.CodeAnalysis.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Darc.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.DarcLib.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Deployment.Tasks.Links.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.Analyzers.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.GenAPI.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.Client.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.JobSender.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.Sdk.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Maestro.Client.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Maestro.Tasks.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SignCheck.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SignTool.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SwaggerGenerator.CmdLine.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SwaggerGenerator.MSBuild.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.GenFacades.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.XUnitExtensions.2.4.0-beta.18525.8.symbols.nupkg - 2.4.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- Microsoft.DotNet.SwaggerGenerator.MSBuild - 1.0.0-beta.18525.8
- Microsoft.AspNetCore.ApiVersioning.Analyzers - 1.0.0-beta.18525.8
- Microsoft.AspNetCore.ApiVersioning.Swashbuckle - 1.0.0-beta.18525.8
- Microsoft.DotNet.ApiCompat - 1.0.0-beta.18525.8
- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18525.8
- Microsoft.DotNet.Build.Tasks.Feed - 2.2.0-beta.18525.8
- Microsoft.DotNet.Build.Tasks.Packaging - 1.0.0-beta.18525.8
- Microsoft.DotNet.CodeAnalysis - 1.0.0-beta.18525.8
- Microsoft.DotNet.Darc - 1.0.0-beta.18525.8
- Microsoft.DotNet.DarcLib - 1.0.0-beta.18525.8
- Microsoft.DotNet.XUnitExtensions - 2.4.0-beta.18525.8
- Microsoft.DotNet.Deployment.Tasks.Links - 1.0.0-beta.18525.8
- Microsoft.DotNet.GenFacades - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.Client - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.JobSender - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.Sdk - 1.0.0-beta.18525.8
- Microsoft.DotNet.Maestro.Client - 1.0.0-beta.18525.8
- Microsoft.DotNet.Maestro.Tasks - 1.0.0-beta.18525.8
- Microsoft.DotNet.SignCheck - 1.0.0-beta.18525.8
- Microsoft.DotNet.SignTool - 1.0.0-beta.18525.8
- Microsoft.DotNet.SwaggerGenerator.CmdLine - 1.0.0-beta.18525.8
- Microsoft.DotNet.GenAPI - 1.0.0-beta.18525.8</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2625</PullRequestID>
        <IssueID>2619</IssueID>
        <Title>Fix NuGet.config casing</Title>
        <Description>Should fix Ubuntu failures in https://github.com/dotnet/sdk/pull/2615</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2625</PullRequestID>
        <IssueID>2622</IssueID>
        <Title>Fix nuget config casing</Title>
        <Description>Should fix Ubuntu failures in #2615, and hopefully the flakiness from #2619</Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2625</PullRequestID>
        <IssueID>2623</IssueID>
        <Title>Public conditions</Title>
        <Description>This should ensure ci / pr builds scheduled only use public resources.

FYI @mmitche @dsplaisted </Description>
        <CreatedDate>26/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2622</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix nuget config casing</Title>
    <Description>Should fix Ubuntu failures in #2615, and hopefully the flakiness from #2619</Description>
    <CreatedDate>26/10/2018</CreatedDate>
    <ClosedDate>26/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2622</PullRequestID>
        <IssueID>2615</IssueID>
        <Title>[Darc-Update] Update dependencies from build 20181025.8 of https://github.com/dotnet/arcade</Title>
        <Description>This change updates the dependencies from https://github.com/dotnet/arcade to the following

- Microsoft.AspNetCore.ApiVersioning - 1.0.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.Swashbuckle.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.ApiCompat.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Arcade.Sdk.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Build.Tasks.Feed.2.2.0-beta.18525.8.symbols.nupkg - 2.2.0-beta.18525.8
- symbols/Microsoft.DotNet.Build.Tasks.Packaging.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.CodeAnalysis.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Darc.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.DarcLib.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Deployment.Tasks.Links.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.Analyzers.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.GenAPI.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.Client.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.JobSender.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Helix.Sdk.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Maestro.Client.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.Maestro.Tasks.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SignCheck.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SignTool.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SwaggerGenerator.CmdLine.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.SwaggerGenerator.MSBuild.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.GenFacades.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- symbols/Microsoft.DotNet.XUnitExtensions.2.4.0-beta.18525.8.symbols.nupkg - 2.4.0-beta.18525.8
- symbols/Microsoft.AspNetCore.ApiVersioning.1.0.0-beta.18525.8.symbols.nupkg - 1.0.0-beta.18525.8
- Microsoft.DotNet.SwaggerGenerator.MSBuild - 1.0.0-beta.18525.8
- Microsoft.AspNetCore.ApiVersioning.Analyzers - 1.0.0-beta.18525.8
- Microsoft.AspNetCore.ApiVersioning.Swashbuckle - 1.0.0-beta.18525.8
- Microsoft.DotNet.ApiCompat - 1.0.0-beta.18525.8
- Microsoft.DotNet.Arcade.Sdk - 1.0.0-beta.18525.8
- Microsoft.DotNet.Build.Tasks.Feed - 2.2.0-beta.18525.8
- Microsoft.DotNet.Build.Tasks.Packaging - 1.0.0-beta.18525.8
- Microsoft.DotNet.CodeAnalysis - 1.0.0-beta.18525.8
- Microsoft.DotNet.Darc - 1.0.0-beta.18525.8
- Microsoft.DotNet.DarcLib - 1.0.0-beta.18525.8
- Microsoft.DotNet.XUnitExtensions - 2.4.0-beta.18525.8
- Microsoft.DotNet.Deployment.Tasks.Links - 1.0.0-beta.18525.8
- Microsoft.DotNet.GenFacades - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.Client - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.JobSender - 1.0.0-beta.18525.8
- Microsoft.DotNet.Helix.Sdk - 1.0.0-beta.18525.8
- Microsoft.DotNet.Maestro.Client - 1.0.0-beta.18525.8
- Microsoft.DotNet.Maestro.Tasks - 1.0.0-beta.18525.8
- Microsoft.DotNet.SignCheck - 1.0.0-beta.18525.8
- Microsoft.DotNet.SignTool - 1.0.0-beta.18525.8
- Microsoft.DotNet.SwaggerGenerator.CmdLine - 1.0.0-beta.18525.8
- Microsoft.DotNet.GenAPI - 1.0.0-beta.18525.8</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2622</PullRequestID>
        <IssueID>2619</IssueID>
        <Title>Fix NuGet.config casing</Title>
        <Description>Should fix Ubuntu failures in https://github.com/dotnet/sdk/pull/2615</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>26/10/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2621</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Ensure default apphost RID is set prior to `_IsExecutable` reassignment. </Title>
    <Description>Because of the `_IsExecutable` reassignment that happens when the Test SDK
changes `OutputType`, a test project that builds with `HasRuntimeOutput` set to
true will cause a build failure due to the default apphost not being restored,
but requested to be resolved as a project asset.

The fix is to ensure that the `DefaultAppHostRuntimeIdentifier` property is set
prior to reassigning the `_IsExecutable` property.

Fixes #2620.</Description>
    <CreatedDate>25/10/2018</CreatedDate>
    <ClosedDate>25/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2621</PullRequestID>
        <IssueID>2620</IssueID>
        <Title>Upgrading from 2.2 SDK to 3.0 introduces NETSDK1047 error</Title>
        <Description>We're trying to upgrade the master branch of aspnetcore to build with the latest 3.0.100-alpha builds, and running into this error which didn't happen in the 2.2 SDK.

&gt; C:\b\w\695426870b618c58\.dotnet\x64\sdk\3.0.100-alpha1-009701\Sdks\Microsoft.NET.Sdk\targets\Microsoft.PackageDependencyResolution.targets(208,5): error NETSDK1047: Assets file 'C:\b\w\695426870b618c58\modules\KestrelHttpServer\test\Kestrel.Core.Tests\obj\project.assets.json' doesn't have a target for '.NETCoreApp,Version=v2.2/win-x64'. Ensure that restore has run and that you have included 'netcoreapp2.2' in the TargetFrameworks for your project. You may also need to include 'win-x64' in your project's RuntimeIdentifiers. [C:\b\w\695426870b618c58\modules\KestrelHttpServer\test\Kestrel.Core.Tests\Kestrel.Core.Tests.csproj]

I can't figure out why I'm getting an error about `win-x64` because we don't set this RID in our project files. I can provide a binlog if you want.

**To reproduce:**
1. Clone https://github.com/aspnet/KestrelHttpServer/tree/a8073167e7adcca0d6708d4da56e43066535e3a5
1. Using the 3.0.100-alpha1-009701 SDK, try to build the KestrelHttpServer.sln.</Description>
        <CreatedDate>24/10/2018</CreatedDate>
        <ClosedDate>25/10/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2604</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Ensure inputs exist for CreateAppHost task.</Title>
    <Description>This commit fixes design time builds where the intermediate assembly may not
exist, causing the `CreateAppHost` task to fail.

The change is to condition the `_CreateAppHost` target based on the existence
of the two input files: the intermediate assembly and the native apphost.

Fixes #2599.</Description>
    <CreatedDate>23/10/2018</CreatedDate>
    <ClosedDate>23/10/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2604</PullRequestID>
        <IssueID>2599</IssueID>
        <Title>CreateAppHost runs and fails during VS design time build if project isn't already built</Title>
        <Description>## Repro steps

1. Install .NET Core 3.0 SDK (I had 3.0.100-alpha1-009697)
2. `dotnet new wpf`
3. Open VS.
4. Open the project created in 2.

## Result

``

## Expected
We probably shouldn't run this target if the assemblies it's going to work on don't exist.
</Description>
        <CreatedDate>21/10/2018</CreatedDate>
        <ClosedDate>06/11/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2134</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Disable package asset cache in tool deps json generation</Title>
    <Description>Fix #2128</Description>
    <CreatedDate>11/04/2018</CreatedDate>
    <ClosedDate>11/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2134</PullRequestID>
        <IssueID>2128</IssueID>
        <Title>2.1.300-preview2: Unable to use DotNetCliToolReference due to deps.json generation failure</Title>
        <Description>There appears to be a regression in DotNetCliToolReference support.

**Repro**
On a clean mac, install the .NET Core CLI using the .pkg installer (not .tar.gz)

Create a new project via `dotnet new xunit`

Run `dotnet xunit`

**Expected**

Should launch xunit

**Actual**

The SDK fails to launch it with this error.

&gt; Unable to generate deps.json, it may have been already generated.  You can specify the "-d" option before the tool name for diagnostic output (for example, "dotnet -d &lt;toolname&gt;": /usr/local/share/dotnet/sdk/2.1.300-preview2-008530/Sdks/Microsoft.NET.Sdk/targets/GenerateDeps/GenerateDeps.proj

The real issue seems to be this:

&gt; error MSB4018: System.UnauthorizedAccessException: Access to the path '/usr/local/share/dotnet/sdk/2.1.300-preview2-008530/Sdks/Microsoft.NET.Sdk/targets/GenerateDeps/obj/Debug/netcoreapp2.1/GenerateDeps.assets.cache' is denied.

The .pkg installer does not give write access to this path.

``</Description>
        <CreatedDate>10/04/2018</CreatedDate>
        <ClosedDate>12/04/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2133</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Add back NuGetSourceType=Package metadata in package resolution</Title>
    <Description>This was used in a few places to distinguish between refs coming from NuGet from others.

In particular, it caused all nuget refs to be copied to refs/folder on Build with PreserveCompilationContext=true.

Fix #2121</Description>
    <CreatedDate>10/04/2018</CreatedDate>
    <ClosedDate>16/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2133</PullRequestID>
        <IssueID>2121</IssueID>
        <Title>Building an app with PreserveCompilationContext=true causes files from the shared runtime to be copied to bin\refs directory</Title>
        <Description>This is a regression (?) in 2.1.0-preview2 sdk. Repro steps:

1) Acquire preview1 Sdk - https://www.microsoft.com/net/download/dotnet-core/sdk-2.1.300-preview1
2) `dotnet new mvc`
3) `dotnet build`

Examine the bin\Debug\netcoreapp2.1 directory and notice all it has is the app's binaries.

4) Clean the bin directory and run `dotnet build` using the preview2 Sdk (I used `2.1.300-preview2-008367`)

The bin directory has a refs directory that contains 300+ files from shared runtimes.</Description>
        <CreatedDate>09/04/2018</CreatedDate>
        <ClosedDate>17/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2126</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't include files with source extension in None item by default</Title>
    <Description>Fixes #1157</Description>
    <CreatedDate>09/04/2018</CreatedDate>
    <ClosedDate>11/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2126</PullRequestID>
        <IssueID>1157</IssueID>
        <Title>Setting EnableDefaultCompileItems to False doesn't remove the files from solution Explorer</Title>
        <Description>_From @jinujoseph on February 8, 2017 23:9_

Create a ClassLibrary (.Net Core) 
Take a copy of Class1.cs and drop in the same folder
you will see of them included 
Now edit the csproj and put the below information 

``
Build again , it includes only Class1.cs but the solution explorer shows all files, expected ? 

![image](https://cloud.githubusercontent.com/assets/12449387/22761664/9c18182e-ee10-11e6-8ccb-400383d403ff.png)


**Build**
26206.0.d15rel


_Copied from original issue: dotnet/project-system#1504_</Description>
        <CreatedDate>27/04/2017</CreatedDate>
        <ClosedDate>11/04/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2118</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Include assembly and file versions in deps file for non self-contained publish</Title>
    <Description>Fixes #1847

Also fixes #1942 (in most cases)</Description>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>21/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2118</PullRequestID>
        <IssueID>1847</IssueID>
        <Title>Add additional metadata to deps.json to support "framework wins over app"</Title>
        <Description>This is the SDK work to support the core-setup feature https://github.com/dotnet/core-setup/issues/3546

That core-setup issue adds new metadata to the framework's deps.json to help determine which assemblies are newer during file-based probing. This would need to be done by the SDK during build and\or publish. That metadata includes assembly version and file version, where assembly version is compared first and if equal, then file version is compared.

@nguerrera </Description>
        <CreatedDate>08/01/2018</CreatedDate>
        <ClosedDate>21/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
          <Label>blocking-RC</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2118</PullRequestID>
        <IssueID>1942</IssueID>
        <Title>deps file is not regenerated when non-nuget references change</Title>
        <Description>Currently the target that generates the deps file only runs when project.assets.json is older than deps.json, but if non-package references are changed, then the deps file would also need to change.

We do want to keep incrementality because it is an expensive operation, but we should account for the other task parameters that can change the deps file.</Description>
        <CreatedDate>08/02/2018</CreatedDate>
        <ClosedDate>21/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>blocking-RC</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2101</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Allow dotnet host path to be overridden via DOTNET_INSTALL_DIR environment variable</Title>
    <Description>Fixes #2098</Description>
    <CreatedDate>30/03/2018</CreatedDate>
    <ClosedDate>03/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2101</PullRequestID>
        <IssueID>2098</IssueID>
        <Title>Do not assume specific location of dotnet CLI</Title>
        <Description>The tests currently assume dotnet CLI is installed in `$(RepoRoot)/.dotnet`:

https://github.com/dotnet/sdk/blob/master/src/Tests/Microsoft.NET.TestFramework/ToolsetInfo.cs#L119

Instead the tests should use `DOTNET_INSTALL_DIR` environment variable to locate dotnet CLI.

In future we might want to change this to `DOTNET_ROOT`, once it's implemented.</Description>
        <CreatedDate>29/03/2018</CreatedDate>
        <ClosedDate>04/04/2018</ClosedDate>
        <Labels>
          <Label>Infrastructure</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2091</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Move DefineConstants where they'll actually apply</Title>
    <Description>We were setting it before Sdk.props / Directory.Build.props, and repo toolset was overwriting it.

This caused #if EXTENSIONS to never be taken and a task loading error to occur when NETBuildExtensionsError was used.

This is the minimal fix for 2.1.2xx / 15.7. I hope to refactor things in 2.1.3xx so that our project files are more standard and this mistake is harder to make.

**Customer scenario**

Customers is attempting to reference a version of .NETStandard library (greater than certain version) from .NETFramework, but does not have a recent enough SDK.

There is supposed to be an error message indicating that the SDK is not recent enough, but instead it triggers a task loading failure with no indication of what is actually wrong.

**Bugs this fixes:** 

Fix #2061 

**Workarounds, if any**

Learn what the real error message was supposed to read and follow its instructions to update SDK used.

**Risk**

Low

**Performance impact**

None. Triggers only in error case.

**Is this a regression from a previous update?**

No

**Root cause analysis:**

Infrastructure changes in move to repo toolset cause a DefineConstants in the csproj to not be honored. Test coverage has been added to prevent a regression.

**How was the bug found?**

Customer reported
</Description>
    <CreatedDate>28/03/2018</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2091</PullRequestID>
        <IssueID>2061</IssueID>
        <Title>Instead of generating an error saying a 2.x SDK is needed, we generate an error loading the NETBuildExtensionsError task</Title>
        <Description># Repro steps

Check out the `build_fail` branch of https://github.com/multiarc/SDKRepro/

Build with full Framework MSBuild:

`msbuild /restore`

# Expected

Error message: The version of Microsoft.NET.Sdk used by this project is insufficient to support references to libraries targeting .NET Standard 1.5 or higher.  Please install version 2.0 or higher of the .NET Core SDK.

# Actual

Error message:

&gt; C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.NETFramework.targets(65,5): error MSB4062: The "NETBuildExtensionsError" task could not be loaded from the assembly C:\Program Files (x86)\Microsoft Visual Studio\Preview\Enterprise\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\\tools\net46\Microsoft.NET.Build.Extensions.Tasks.dll.  Confirm that the &lt;UsingTask&gt; declaration is correct, that the assembly and all its dependencies are available, and that the task contains a public class that implements Microsoft.Build.Framework.ITask. [C:\git\repro\2045-Pagination\src\A\A.csproj]
&gt;
&gt; C:\Program Files\dotnet\sdk\1.1.7\Sdks\Microsoft.NET.Sdk\build\Microsoft.NET.Sdk.targets(92,5): Cannot find project info for 'C:\git\repro\2045-Pagination\src\B\B.csproj'. This can indicate a missing project reference. [C:\git\repro\2045-Pagination\src\A\A.csproj]

# Root cause

Microsoft.NET.Build.Extensions.Tasks.dll no longer includes the `NETBuildExtensionsError` task.  Instead it includes the `NETSdkError` task.  This is because the `DefineConstants` property in the project is no longer applying because it was moved before the `Sdk.props` import, and there is a `DefineConstants` in repo toolset that is overriding it.

# Meme

![image](https://user-images.githubusercontent.com/145043/37548198-77a0bbe0-2933-11e8-8af4-4b48dda6ebac.png)
</Description>
        <CreatedDate>16/03/2018</CreatedDate>
        <ClosedDate>05/04/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2088</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>peterhuene</FixedByID>
    <Title>Fix case sensitivity when mapping project paths to project infos.</Title>
    <Description>When a solution contains a path to a project that differs by case for a project
reference identity, the build fails because the project info can't be found.

The fix is to make the internal map case insensitive, allowing the case
difference in a project's path in the solution file.

Fixes dotnet/cli#8048.</Description>
    <CreatedDate>27/03/2018</CreatedDate>
    <ClosedDate>31/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2088</PullRequestID>
        <IssueID>8048</IssueID>
        <Title>Webpack not auto-building while app is running</Title>
        <Description>## Steps to reproduce
1) Create new project with `dotnet new angular`
2) Restore packages and install dependencies with `dotnet restore` and `npm install`
3) Run the project with `dotnet run`
4) Make a change to any component. For example, append `HELLO, WORLD` to the **home.component.html** file
5) Save the change. **Notice the browser does not auto-refresh**
6) Refresh the browser - the change is **NOT** applied
7) Stop the project the project
8) Run the project again with `dotnet run` - notice the change is **STILL NOT** applied
9) Stop the project again
10) Run `webpack`
11) Run the project with `dotnet run` - VIOLA! Now the change **is** visible

## Expected  behavior
I expect to be able to make a change and, upon saving, see the change reflected in my browser.

## Actual behavior
No changes can be seen until the `webpack` command is ran at the command line.

## Environment data
`dotnet --info` output:

.NET Command Line Tools (1.0.0)

Product Information:
 Version:            1.0.0
 Commit SHA-1 hash:  e53429feb4

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.14393
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\1.0.0




</Description>
        <CreatedDate>31/03/2017</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2085</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Roll forward self-contained apps to latest patch version</Title>
    <Description>- Bring back behavior where self-contained apps will roll-forward to the latest patch the SDK knows about
  - We had reverted this in #1574
  - Hopefully the implementation here should be a bit easier to follow
- Add an error message when the version of .NET Core in the assets file is different than what was expected based on current settings: `The project was restored using Microsoft.NETCore.App version 2.0.0, but with current settings, version 2.0.6 would be used instead.  To resolve this issue, make sure the same settings are used for restore and for subsequent operations such as build or publish.  Typically this issue can occur if the RuntimeIdentifier property is set during build or publish but not during restore.`
- Fix various test issues

Related: #1570

@nguerrera @livarcocc @dotnet/dotnet-cli for review</Description>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>28/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2085</PullRequestID>
        <IssueID>1574</IssueID>
        <Title>Revert self-contained implicit versions to 1.0.5/1.1.2/2.0.0</Title>
        <Description>NOTE: This just bumps the versions back down with reverting the whole commit because

1. We need a fix in that commit to actually use 2.0.0 instead of the bundled version for framework-dependent apps
2. There's test cleanup that allows these versions to be changed and test to pass that we should keep.</Description>
        <CreatedDate>08/09/2017</CreatedDate>
        <ClosedDate>11/09/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2085</PullRequestID>
        <IssueID>1570</IssueID>
        <Title>Explicit restore for self-contained app behaves differently than implicit restore</Title>
        <Description>## Steps to reproduce
1. mkdir ExplicitRestore
1. cd ExplicitRestore
1. dotnet new console --no-restore
1. dotnet restore -r debian.8-x64
Inspect the obj/project.assets.json to see what version of Microsoft.NETCore.App is used - Microsoft.NETCore.App/2.0.0

1. mkdir ImplicitRestore
1. cd ImplicitRestore
1. dotnet new console --no-restore
1. dotnet build -r debian.8-x64
The build step fails - notice the version of Microsoft.NETCore.App being used - 
'''
/ImplicitRestore/ImplicitRestore.csproj : error NU1102: Unable to find package Microsoft.NETCore.App with version (&gt;= 2.0.1)
/ImplicitRestore/ImplicitRestore.csproj : error NU1102:   - Found 14 version(s) in nuget.org [ Nearest version: 2.0.0 ]
'''

## Expected  behavior
I was expecting the two scenarios to behave the same.  Specifically I would expect them to be using the same version of Microsoft.NETCore.App - 2.0.1

## Actual behavior
Explicit restore uses Microsoft.NETCore.App 2.0.0 while the implicit restore uses 2.0.1.

## Environment data
`dotnet --info` output:

``
</Description>
        <CreatedDate>07/09/2017</CreatedDate>
        <ClosedDate>06/04/2018</ClosedDate>
        <Labels>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2083</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Handle asset file reading errors more robustly</Title>
    <Description>The recent episode where an assembly binding conflict resulted in nonsensical "Missing target in assets file" errors revealed several holes in how errors in the assets file are handled. This ensures that we never allow a bogus empty lock file to surface to our build logic and that all messages from NuGet or System.IO are preseved in the build output.

Fix #18 </Description>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>27/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2083</PullRequestID>
        <IssueID>18</IssueID>
        <Title>Adapt MSBuild logger to a NuGet logger</Title>
        <Description>When loading a LockFile, the API takes a NuGet.Common.ILogger.  In order to get good logging information from NuGet, we should implement a NuGet logger that can write to the MSBuild logger in our tasks that need to load a LockFile.

See the TODO in the LockFileCache class added in https://github.com/dotnet/sdk/pull/8.
</Description>
        <CreatedDate>04/08/2016</CreatedDate>
        <ClosedDate>29/03/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2073</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>david-driscoll</FixedByID>
    <Title>Implicitly define compilation constant for target framework without version</Title>
    <Description>Added ImplicitFrameworkDefineHierarchy property with out the versioned value for the given TargetFrameworkIdentifier

More information and origin @ #2072

🚲🏠 Please bike shed this, I just tried pick a name that worked, without changing the meaning of the existing properties.  `Hierarchy`, `Parent`, `Root` are all possibly valid values, along with many more.</Description>
    <CreatedDate>21/03/2018</CreatedDate>
    <ClosedDate>21/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2073</PullRequestID>
        <IssueID>2072</IssueID>
        <Title>Implicitly define compilation constants for target framework without a specific version</Title>
        <Description>I was talking to @dsplaisted (iirc) and someone else at summit and this was one scenario that I felt was missing from the current SDK.

It may make sense to also have a general compilation constant that is just the Target Framework Identifier without the version.  Of course this won't work for all cases of the compilation constants (ie, missing API's between versions) but there are places where .NET Desktop differs greatly from .NET Core, and being able to codify that across versions would be helpful.

When multi-targeting, you times have to make code that targets a specific framework (or standard). If you shift your target forward or backward, and go from say `&lt;TargetFrameworks&gt;netstandard1.3;net45&lt;/TargetFrameworks&gt;` to `&lt;TargetFrameworks&gt;netstandard2.0;net471&lt;/TargetFrameworks&gt;` any of your pre-existing conditional compilation bits will have to be updated from `NETSTANDARD1_3`/`NET45` to ``NETSTANDARD2_0/`NET471`.

so...
* `NETSTANDARD1_0`, `NETSTANDARD1_3`, `NETSTANDARD2_0`, `...` -&gt; `NETSTANDARD`
* `NET45`, `NET461`, `NET471`, `...` -&gt; `NETFRAMEWORK`
* `NETCOREAPP1_0`, `NETCOREAPP2_0` -&gt; `NETCOREAPP`
</Description>
        <CreatedDate>21/03/2018</CreatedDate>
        <ClosedDate>22/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2064</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natemcmaster</FixedByID>
    <Title>Issue a warning on restore about obsolete DotNetCliToolReference</Title>
    <Description>Resolves #2014 

I will make a corresponding change to dotnet/cli to generate Microsoft.NETCoreSdk.BundledCliTools.props with a list of obsolete package IDs to match https://github.com/dotnet/cli/blob/master/build/BundledDotnetTools.props.

VS:

![image](https://user-images.githubusercontent.com/2696087/37615207-eeb0e088-2b69-11e8-9a11-86c8e3a67ff6.png)

Command line:

![image](https://user-images.githubusercontent.com/2696087/37615256-100ade78-2b6a-11e8-9c78-a9420f76c85d.png)

FYI @muratg @DamianEdwards @prafullbhosale @divega @bricelam @Eilon </Description>
    <CreatedDate>19/03/2018</CreatedDate>
    <ClosedDate>22/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2064</PullRequestID>
        <IssueID>2014</IssueID>
        <Title>Add obsolete warning for DotNetCliToolReference packages that are now built-in commands</Title>
        <Description>A few ASP.NET Core packages that used to be installed via DotNetCliToolReference will be built-in commands for the CLI.  When invoking "dotnet watch" now, it will use the built-in version, not the one delivered via DotNetCliToolReference, so DotNetCliToolReference should be removed.
cref https://github.com/aspnet/Announcements/issues/290.


Since we don't have a proper way to issue obsolete messages about packages (NuGet/Home#2867), can we add a target that runs before Restore that issues an obsolete warning for the following packages

``

Proposed text:

&gt; warning SDK0000: the DotNetCliToolReference to Microsoft.DotNet.Watcher.Tools is obsolete. This tool is now bundled in the CLI. The DotNetCliToolReference can be removed.

</Description>
        <CreatedDate>01/03/2018</CreatedDate>
        <ClosedDate>22/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2060</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>ericstj</FixedByID>
    <Title>Fix package override resolver desktop</Title>
    <Description>In desktop projects the PackageOverrideResolver was throwing ArgumentNullException due to 
one item coming from a package and the other not.

Moreover I noticed that the one that was thought to come from a package was actually a platform item
and the reason we thought it came from a package was that I had a *.nuspec in the root of the drive where I was building from.

We need tests to cover these cases.

Fixes #1854</Description>
    <CreatedDate>16/03/2018</CreatedDate>
    <ClosedDate>20/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2060</PullRequestID>
        <IssueID>1854</IssueID>
        <Title>ResolvePackageFileConflicts throwing when referencing System.Diagnostics.DiagnosticSource by assembly path</Title>
        <Description>This is new failure that just started happening in some Razor tests for our MSBuild functionality. This started failing for us `2.2.0-preview1-007927` - this was working before in `2.2.0-preview1-007866`.

I've attached a repro project, which is doing some esoteric things because this is part of our tests for our MSBuild targets 😆. I think the probably might not be anything wierd that we're doing though.

The project file looks like this:
``
[Repro.zip](https://github.com/dotnet/sdk/files/1627368/Repro.zip)
</Description>
        <CreatedDate>12/01/2018</CreatedDate>
        <ClosedDate>20/03/2018</ClosedDate>
        <Labels>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2042</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natemcmaster</FixedByID>
    <Title>Add SuppressNETCoreSdkPreviewMessage property to suppress the preview SDK version</Title>
    <Description>Cref #2033 

cc @nguerrera @livarcocc </Description>
    <CreatedDate>13/03/2018</CreatedDate>
    <ClosedDate>13/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2042</PullRequestID>
        <IssueID>2033</IssueID>
        <Title>How to disable "preview version" warning message?</Title>
        <Description>Currently, the SDK issues this high importance message when I build

&gt; You are working with a preview version of the .NET Core SDK. You can define the SDK version via a global.json file in the current project. 

I already have a global.json file and I explicitly set it a preview version, so the warning seems unnecessary. How can I disable this message altogether?</Description>
        <CreatedDate>09/03/2018</CreatedDate>
        <ClosedDate>13/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2040</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Support filtering satellite assemblies from publish via SatelliteResourceLanguages property</Title>
    <Description>Fixes #774

Thanks to @wli3 for pairing on this.</Description>
    <CreatedDate>13/03/2018</CreatedDate>
    <ClosedDate>16/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2040</PullRequestID>
        <IssueID>774</IssueID>
        <Title>Allow disabling of copying resource assemblies from NuGet packages during publish</Title>
        <Description>Many NuGet packages (including [those](https://www.nuget.org/packages/microsoft.Data.edm) [shipped](https://www.nuget.org/packages/microsoft.Data.odata) [by](https://www.nuget.org/packages/Microsoft.Data.Services.Client) [Microsoft](https://www.nuget.org/packages/System.Spatial)) include localized resource satellite assemblies in the main package. This can greatly inflate the publish output size of a typical ASP.NET Core application (like https://github.com/aspnet/live.asp.net) for no benefit in the cases where localized resources from such packages aren't desired or needed.

In this case, the publish output size grows from 12 MB to 26 MB due to the resource assemblies.

It would be great to have an MSBUILD property that could be set in the application's project file to disable copying of satellite assemblies from NuGet references to the publish folder.</Description>
        <CreatedDate>01/02/2017</CreatedDate>
        <ClosedDate>16/03/2018</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2025</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update stage 0 .NET Core SDK version</Title>
    <Description>I'm having issues with CI failing but tests passing locally in #2008, so in this PR I'm trying to isolate some of the changes and test them separately.</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>13/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2025</PullRequestID>
        <IssueID>2008</IssueID>
        <Title>Re-enable a few tests</Title>
        <Description>Fixes #1077
Fixes #1293</Description>
        <CreatedDate>01/03/2018</CreatedDate>
        <ClosedDate>15/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2010</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't set a default ProjectAssetsFile path in the SDK</Title>
    <Description>Resolves #1486 
Resolves #1438, and #1057 (it doesn't enable the scenario, but does fix the SDK's piece)

NuGet sets the `ProjectAssetsFile` property in the `.g.props` file it generates, so this property should already be set by the time we would get to the code this PR removes.

TODO: Test whether this affects behavior when restore hasn't occurred.</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>19/04/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2010</PullRequestID>
        <IssueID>1486</IssueID>
        <Title>Build locates restore files in BaseIntermediateOutputPath instead of RestoreOutputPath</Title>
        <Description>Relevant source: https://github.com/dotnet/sdk/blob/98ea6b2a1701ee9e2e3dd8122c77d5a2adcc5bb7/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.PackageDependencyResolution.targets#L28

If a user uses the `RestoreOutputPath` property to change the output path, `dotnet restore` will put the `project.assets.json` in that path. `dotnet build` will fail to find the assets file if `RestoreOutputPath` is does not resolve to the same location as `BaseIntermediateOutputPath`.</Description>
        <CreatedDate>14/08/2017</CreatedDate>
        <ClosedDate>17/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2010</PullRequestID>
        <IssueID>1438</IssueID>
        <Title>Sdk should use $(ProjectAssetsFile) always, never reset it, and never assume it is named project.assets.json</Title>
        <Description>Currently the `project.assets.json` for a project is defaulted to be `$(BaseIntermediateOutputPath)\project.assets.json` (where `$(BaseIntermediateOutputPath)` defaults to `obj`).

This makes it such that two projects can no longer exist in the same folder by default (and will also cause conflicts if the user unwittingly updates `$(BaseIntermediateOutputPath)` to be shared across all projects in the solution, as can be done with `$(BaseOutputPath)`, rather than ensuring that it remains unique per-project).

I propose that the `project.assets.json` file be updated to include either `MSBuildProjectName` or `AssemblyName` (in other places in the SDK, `AssemblyName` seems to be the preferred prefix) by default or for a switch to be added to easily enable this functionality.

</Description>
        <CreatedDate>21/07/2017</CreatedDate>
        <ClosedDate>19/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2010</PullRequestID>
        <IssueID>1057</IssueID>
        <Title>Provide a way to override the output location of the assets.json file</Title>
        <Description>It seems that right now, the assets.json file is always output into [`$(BaseIntermediateOutputPath)`](https://github.com/dotnet/sdk/blob/b76e22d01bd8ce8ce0b0997a6800e804986bf29c/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.PackageDependencyResolution.targets#L28). NuGet respects a different property, [`$(RestoreOutputPath)`](https://github.com/NuGet/NuGet.Client/blob/68245312b050c5b992120448353eba3e20cdc414/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets#L422-L429 ).

I would just like a single, well-supported way to override the location.

@eerhardt </Description>
        <CreatedDate>30/03/2017</CreatedDate>
        <ClosedDate>17/04/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2008</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Re-enable a few tests</Title>
    <Description>Fixes #1077
Fixes #1293</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>15/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2008</PullRequestID>
        <IssueID>1077</IssueID>
        <Title>Update VS install on CI machines to a version with the bundled .NET Core / .NET Standard .props, and re-enable tests</Title>
        <Description>In #1052, I'm removing the `RuntimeFrameworkVersion` from test projects that target .NET Core 2.0.  This doesn't work with the version of VS installed on the CI machines yet, so I'm disabling the following tests on full framework:

- Microsoft.NET.Build.Tests.GivenThatWeWantToReferenceAnAssembly.ItRunsAppsDirectlyReferencingAssemblies
- Microsoft.NET.Build.Tests.GivenThatWeWantToVerifyProjectReferenceCompat.Project_reference_compat (when targeting .NET Core 2.0)
- Microsoft.NET.Build.Tests.GivenThatWeWantToVerifyNuGetReferenceCompat.Nuget_reference_compat (when targeting .NET Core 2.0 or .NET Standard 2.0)
- Microsoft.NET.Publish.Tests.GivenThatWeWantToPublishAHelloWorldProject.Conflicts_are_resolved_when_publishing_a_portable_app
- Microsoft.NET.Publish.Tests.GivenThatWeWantToPublishAHelloWorldProject.Conflicts_are_resolved_when_publishing_a_self_contained_app
- Microsoft.NET.Publish.Tests.GivenThatWeWantToPublishAHelloWorldProject.Publish_standalone_post_netcoreapp2_app_and_it_should_run
- Microsoft.NET.Publish.Tests.GivenThatWeWantToPublishAHelloWorldProject.Conflicts_are_resolved_when_publishing_a_portable_app

We need to update the CI machines to a newer version of VS and then re-enable these tests.

See also #1041, we will probably fix both of these together.</Description>
        <CreatedDate>05/04/2017</CreatedDate>
        <ClosedDate>15/03/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>2008</PullRequestID>
        <IssueID>1293</IssueID>
        <Title>Tool deps file generation tests fail when run on full Framework MSBuild</Title>
        <Description>The tests in `GivenThatWeWantToGenerateADepsFileForATool` are failing when running on full Framework MSBuild with the following error:

&gt; C:\git\dotnet-sdk\bin\Debug\Sdks\Microsoft.NET.Sdk\build\GenerateDeps\GenerateDeps.proj(29,5): error MSB4184: The expression "[System.IO.Path]::GetDirectoryName("C:\git\dotnet-sdk\packages\.tools\testtool\1.0.0\netcoreapp2.0\project.assets.json")" cannot be evaluated. Illegal characters in path.

The scenarios these tests cover aren't applicable to full framework MSBuild, but it is unexpected that they would fail in this way.  We should investigate what is going on.</Description>
        <CreatedDate>02/06/2017</CreatedDate>
        <ClosedDate>15/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1989</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update implicit NETStandard.Library package version, and re-enable test</Title>
    <Description>- Re-enable test for error targeting .NET Standard 2.1 (Fixes #1632)
- Update to version 2.0.2 of NETStandard.Library package (Resolves #1608)</Description>
    <CreatedDate>23/02/2018</CreatedDate>
    <ClosedDate>27/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1989</PullRequestID>
        <IssueID>1632</IssueID>
        <Title>The SDK should not succeed in building netstandard2.1</Title>
        <Description>See PR https://github.com/dotnet/sdk/pull/1603</Description>
        <CreatedDate>05/10/2017</CreatedDate>
        <ClosedDate>27/02/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1989</PullRequestID>
        <IssueID>1608</IssueID>
        <Title>NETStandard.Library 2.0.2 should be picked up in SDK servicing</Title>
        <Description>/cc @livarcocc @dsplaisted </Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>27/02/2018</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1985</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Rename SDK build directory to "targets" in source and layout</Title>
    <Description>This renames the build folder (not at the root of the repo, but the one with the Microsoft.NET.Sdk targets) to "targets".  This is mostly because GitHub code search and file finder ignore files in a folder named build.

This also gets rid of the buildCrossTargeting folder, by renaming `buildCrossTargeting/Microsoft.NET.Sdk.targets` to `targets/Microsoft.NET.Sdk.CrossTargeting.targets`.

@nguerrera had concerns that renaming these files would cause merge conflicts when integrating changes to the renamed files from other branches, but I tried this out locally with some simple changes and they automatically merged correctly.

Fixes #1071</Description>
    <CreatedDate>23/02/2018</CreatedDate>
    <ClosedDate>23/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1985</PullRequestID>
        <IssueID>1071</IssueID>
        <Title>Consider renaming build directory</Title>
        <Description>This concerns primarily the directory `sdk\src\Tasks\Microsoft.NET.Build.Tasks\build`.  

The Github searching / indexing logic will exclude directories with names "build", "log", "tmp" or "vendor".  This exclusion is for all manner of searching including code content, file names, etc ...  

This is unfortunately because a lot of the core logic for the SDK exists under this directory.  I actually spent about 30+ minutes tracking down a bug because I couldn't locate Microsoft.NET.Sdk.CSharp.props.  I was only able to find it when a search I did happened to include a clone of this repo.  

I hate filing bugs like this because I don't think the github behavior is sensible here.  But it is the behavior and it's severely reducing the usability of this repo via the web UI. </Description>
        <CreatedDate>03/04/2017</CreatedDate>
        <ClosedDate>23/02/2018</ClosedDate>
        <Labels>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1983</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Revert #699</Title>
    <Description>In #699, we tried to work around assembly loading issues by avoiding running any of our tasks before NuGet restore. Since we've addressed the underlying assembly loading issue, we can simplify our code by going back to a single target that checks for implicit package overrides

Resolves #783 
</Description>
    <CreatedDate>22/02/2018</CreatedDate>
    <ClosedDate>27/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1983</PullRequestID>
        <IssueID>699</IssueID>
        <Title>Don't run CheckForImplicitPackageReferenceOverrides before NuGet restore</Title>
        <Description>This should help avoid assembly loading ordering issues, where the some of the (.NET Standard) NuGet assemblies were being loaded from the .NET SDK instead of the (.NET Framework) versions from the NuGet tasks</Description>
        <CreatedDate>20/01/2017</CreatedDate>
        <ClosedDate>23/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Pending Shiproom Approval</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1983</PullRequestID>
        <IssueID>783</IssueID>
        <Title>Clean up from multi-targeting SDK tasks</Title>
        <Description>#762 switched to multi-targeting our SDK tasks for .NET Standard and .NET Framework.  There are some cleanup items we should do that we didn't do at the time in order to reduce churn and risk:

- Remove System.Security.Claims.dll, System.Security.Principal.Windows.dll, and System.Xml.ReaderWriter.dll [from tools\net46 in the SDK layout](https://github.com/dotnet/sdk/blob/a4b62ccc2e41893ae7804b97c500dee56d5458fc/build/Nuget/Microsoft.NET.Sdk.Nuget.targets#L53-L67).  These were dependencies for the .NET Standard version of the tasks that should not be needed anymore, but were left in at the time just to be safe.
- We are excluding the Roslyn assemblies and their dependencies [from the SDK layout](https://github.com/dotnet/sdk/blob/a4b62ccc2e41893ae7804b97c500dee56d5458fc/build/Nuget/Microsoft.NET.Sdk.Nuget.targets#L118-L127).  We no longer reference Roslyn at all in our tasks, so we can delete this.
- In #699, we tried to work around assembly loading issues by avoiding running any of our tasks before NuGet restore.  Since we've addressed the underlying assembly loading issue, we can simplify our code by going back to a single target that checks for implicit package overrides
</Description>
        <CreatedDate>01/02/2017</CreatedDate>
        <ClosedDate>27/02/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1667</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Include updated Http and Compression libraries for .NET 4.7.1 if necessary</Title>
    <Description>Fixes #1647.  .NET 4.7.1 has support for .NET Standard 2.0 built-in, so most of the facades aren't necessary.  However, the assembly versions of System.Net.Http and System.IO.Compression in .NET 4.7.1 are still 4.0.0.0.  This means that the versions from the contract NuGet packages (which are versioned 4.1.0.0 or higher) would be preferred to the in-box version (which is newer).  So if there is a dependency on the "contract" version of these DLLs, or on netstandard.dll, we use the 4.2.0.0 version of the DLLs from the .NET Standard 2.0 "facades".  (Though these DLLs are not actually facades, they contain the implementation.)

Also updates the stage 0 version of the CLI, and fixes a failure it caused with our FilterCopyLocal targets, as described [here](https://github.com/dotnet/sdk/issues/933#issuecomment-337795307).

</Description>
    <CreatedDate>19/10/2017</CreatedDate>
    <ClosedDate>08/11/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1667</PullRequestID>
        <IssueID>1647</IssueID>
        <Title>System.Net.Http and System.IO.Compression .NET Standard facades need to be included when targeting .NET 4.7.1</Title>
        <Description>.NET 4.7.1 ships with support for the .NET Standard 2.0 APIs, as well as the necessary facades.  So it's not supposed to need any facades injected by the `ImplicitlyExpandNETStandardFacades` target.

However, the in-box assembly versions of System.Net.Http and System.IO.Compression are less than the OOB and facade versions of those libraries.  This will be fixed in .NET 4.7.2, however for 4.7.1, we still need to inject just those two facades as necessary.</Description>
        <CreatedDate>11/10/2017</CreatedDate>
        <ClosedDate>10/11/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1663</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update framework references from NuGet packages with HintPath if there's also a matching DLL from NuGet</Title>
    <Description>Applies the fix from #1454 to framework references that come from NuGet packages</Description>
    <CreatedDate>18/10/2017</CreatedDate>
    <ClosedDate>18/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1663</PullRequestID>
        <IssueID>1454</IssueID>
        <Title>Update simple name references with HintPath from DLL from NuGet package instead of replacing reference</Title>
        <Description>Fixes #1244</Description>
        <CreatedDate>25/07/2017</CreatedDate>
        <ClosedDate>10/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1651</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix incorrect itemspec for references from ImplicitlyExpandNETStandardFacades</Title>
    <Description>- Merge release/2.0.0 into release/15.5 (in order to pick up fix from #1644)
- Fix #1499, which I expected to be fixed by #1454 except there was a mistake in the XML
- Added test case to cover the broken scenario</Description>
    <CreatedDate>13/10/2017</CreatedDate>
    <ClosedDate>16/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1651</PullRequestID>
        <IssueID>1644</IssueID>
        <Title>Undo test workaround that is no longer needed</Title>
        <CreatedDate>10/10/2017</CreatedDate>
        <ClosedDate>11/10/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1651</PullRequestID>
        <IssueID>1499</IssueID>
        <Title>Conflict resolution with packages.config-based projects results in yellow warnings in Solution explorer</Title>
        <Description>To reproduce:
1. Create a .NET Framework project targeting .NET 4.7.
2. Install System.Runtime package and choose "packages.config".
3. Create a netstandard2.0 project (or 1.5 or 1.6) and reference that from the desktop project.
4. Unload and reload the solution.

Expect: Builds successfully with no warnings in IDE or solution explorer.
Actual: Builds successfully, but warnings appear in IDE and solution explorer shows yellow warning icon next to references.
![image](https://user-images.githubusercontent.com/8918108/29379290-d47d1610-8276-11e7-8901-0aa68593aebf.png)

This is essentially the same as https://github.com/dotnet/sdk/issues/1244 but a different way to get there.  In this case it wasn't simple name conflict resolution but the task.

Because conflict resolution *removes* the items that were directly authored in the csproj by nuget the IDE emits a warning because it cannot reconcile that the *winning* items should actually be used.

I think we need to come up with a strategy that works for both places and makes the IDE happy with the consolidated references.

/cc @dsplaisted 

</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>26/10/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>Needs more tests</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1651</PullRequestID>
        <IssueID>1454</IssueID>
        <Title>Update simple name references with HintPath from DLL from NuGet package instead of replacing reference</Title>
        <Description>Fixes #1244</Description>
        <CreatedDate>25/07/2017</CreatedDate>
        <ClosedDate>10/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1629</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Pass /noconfig, /nostdlib to satellite compilation appropriately</Title>
    <Description>These switches are no-ops on core csc, but vital on desktop csc. If a user would reference the desktop compiler package, then we'd end up passing desktop assemblies implied by lack of /noconfig /nostdlib to the compilation of a netstandard assembly.

Fix #1447

</Description>
    <CreatedDate>05/10/2017</CreatedDate>
    <ClosedDate>05/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1629</PullRequestID>
        <IssueID>1447</IssueID>
        <Title>Satellite assembly build fails when using Microsoft.Net.Compilers package</Title>
        <Description>Adding package Microsoft.Net.Compilers to a project with localized resources and compiling with `` task that compiles satellite assemblies.
</Description>
        <CreatedDate>24/07/2017</CreatedDate>
        <ClosedDate>05/10/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1618</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>In conflict resolution, treat items from FrameworkList.xml as platform assemblies</Title>
    <Description>Fixes #1336

Tests still to come (though they will probably depend on the .NET 4.7.1 targeting pack, so they'll have to be disabled until it is released).

@ericstj @AlexGhiondea @nguerrera @AndyGerlicher @cdmihai for review</Description>
    <CreatedDate>30/09/2017</CreatedDate>
    <ClosedDate>12/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1618</PullRequestID>
        <IssueID>1336</IssueID>
        <Title>Make conflict resolution read/understand the TargetFrameworkList XML file </Title>
        <Description>This issue tracks the work required to make conflict resolution understand the targetframework list from the targeting pack on Desktop and passing that information to the conflict resolution target.</Description>
        <CreatedDate>12/06/2017</CreatedDate>
        <ClosedDate>18/11/2017</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Needs more tests</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1612</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Use .NET Standard facades without reference assembly bit set</Title>
    <Description>Bring back the fixes from #1582, which were reverted in #1610, this time without regressing ASP.NET Core apps on .NET Framework.

This does this by using only the "lib" and not the "ref" files from the .NET Standard facades, but putting each facade in two separate MSBuild items: `Reference` with `Private` set to false, which means they won't be copied locally, and `ReferenceCopyLocalPaths` which will be copied locally.  This will result in the deps.json file will have those items listed with type `referenceassembly` instead of `reference`, which means this won't run afoul of https://github.com/dotnet/core-setup/issues/2981.

This also uses the simple name as the identity for the `Reference` items, and uses the `HintPath` metadata for the full path.  This should resolve at least some cases of #1499.</Description>
    <CreatedDate>27/09/2017</CreatedDate>
    <ClosedDate>10/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1612</PullRequestID>
        <IssueID>1582</IssueID>
        <Title>Update support libraries to those that are only lib.</Title>
        <Description>@dsplaisted you may want to take this and create your own PR.  Not sure if its complete.</Description>
        <CreatedDate>12/09/2017</CreatedDate>
        <ClosedDate>14/09/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1612</PullRequestID>
        <IssueID>1610</IssueID>
        <Title>Revert "Update support libraries to those that are only lib."</Title>
        <Description>Reverts dotnet/sdk#1582, which broke ASP.NET Core web apps running on .NET Framework.

A description of the issue, thanks to @eerhardt:

Previously we used to reference both the “ref assembly” to compile and the “runtime assembly” to run.  Now, we are no longer referencing the “ref assembly” at compile time.  We are compiling and running solely against the “runtime assembly”.

This changed the way the .deps.json file is created.  For the assembly it is looking for “Microsoft.Win32.Primitives”, the deps.json file changed from:

``

We have a pretty well-known bug in the 2.0.0 version of the DependencyModel library that was fixed in 2.0.1 - https://github.com/dotnet/core-setup/issues/2981.  Basically, the DependencyModel doesn’t resolve “type: reference” libraries correctly.
</Description>
        <CreatedDate>26/09/2017</CreatedDate>
        <ClosedDate>27/09/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1612</PullRequestID>
        <IssueID>1499</IssueID>
        <Title>Conflict resolution with packages.config-based projects results in yellow warnings in Solution explorer</Title>
        <Description>To reproduce:
1. Create a .NET Framework project targeting .NET 4.7.
2. Install System.Runtime package and choose "packages.config".
3. Create a netstandard2.0 project (or 1.5 or 1.6) and reference that from the desktop project.
4. Unload and reload the solution.

Expect: Builds successfully with no warnings in IDE or solution explorer.
Actual: Builds successfully, but warnings appear in IDE and solution explorer shows yellow warning icon next to references.
![image](https://user-images.githubusercontent.com/8918108/29379290-d47d1610-8276-11e7-8901-0aa68593aebf.png)

This is essentially the same as https://github.com/dotnet/sdk/issues/1244 but a different way to get there.  In this case it wasn't simple name conflict resolution but the task.

Because conflict resolution *removes* the items that were directly authored in the csproj by nuget the IDE emits a warning because it cannot reconcile that the *winning* items should actually be used.

I think we need to come up with a strategy that works for both places and makes the IDE happy with the consolidated references.

/cc @dsplaisted 

</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>26/10/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>Needs more tests</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1610</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Revert "Update support libraries to those that are only lib."</Title>
    <Description>Reverts dotnet/sdk#1582, which broke ASP.NET Core web apps running on .NET Framework.

A description of the issue, thanks to @eerhardt:

Previously we used to reference both the “ref assembly” to compile and the “runtime assembly” to run.  Now, we are no longer referencing the “ref assembly” at compile time.  We are compiling and running solely against the “runtime assembly”.

This changed the way the .deps.json file is created.  For the assembly it is looking for “Microsoft.Win32.Primitives”, the deps.json file changed from:

```
"Microsoft.Win32.Primitives/4.0.3.0": {
      "type": "referenceassembly",
```

In the old file to 

```
    "Microsoft.Win32.Primitives/4.0.3.0": {
      "type": "reference",
```

We have a pretty well-known bug in the 2.0.0 version of the DependencyModel library that was fixed in 2.0.1 - https://github.com/dotnet/core-setup/issues/2981.  Basically, the DependencyModel doesn’t resolve “type: reference” libraries correctly.
</Description>
    <CreatedDate>26/09/2017</CreatedDate>
    <ClosedDate>27/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1610</PullRequestID>
        <IssueID>1582</IssueID>
        <Title>Update support libraries to those that are only lib.</Title>
        <Description>@dsplaisted you may want to take this and create your own PR.  Not sure if its complete.</Description>
        <CreatedDate>12/09/2017</CreatedDate>
        <ClosedDate>14/09/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1594</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add build/test environment scripts</Title>
    <Description>Cherry pick build/test environment scripts which I added as part of #1565 into master.

@nguerrera @livarcocc @johnbeisner @wli3 for review</Description>
    <CreatedDate>20/09/2017</CreatedDate>
    <ClosedDate>21/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1594</PullRequestID>
        <IssueID>1565</IssueID>
        <Title>Use correct target path for runtimeTargets items when resolving conflicts</Title>
        <Description>Fixes #1510 

EDIT: Also fixes #1465 now

@nguerrera @ericstj @eerhardt for review</Description>
        <CreatedDate>06/09/2017</CreatedDate>
        <ClosedDate>14/09/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1571</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>[DO NOT MERGE] Test CI</Title>
    <Description>Non-Windows Jenkins legs are timing out in #1565, this is an "empty" PR to see if it will pass without any changes</Description>
    <CreatedDate>07/09/2017</CreatedDate>
    <ClosedDate>13/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1571</PullRequestID>
        <IssueID>1565</IssueID>
        <Title>Use correct target path for runtimeTargets items when resolving conflicts</Title>
        <Description>Fixes #1510 

EDIT: Also fixes #1465 now

@nguerrera @ericstj @eerhardt for review</Description>
        <CreatedDate>06/09/2017</CreatedDate>
        <ClosedDate>14/09/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1565</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Use correct target path for runtimeTargets items when resolving conflicts</Title>
    <Description>Fixes #1510 

EDIT: Also fixes #1465 now

@nguerrera @ericstj @eerhardt for review</Description>
    <CreatedDate>06/09/2017</CreatedDate>
    <ClosedDate>14/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1565</PullRequestID>
        <IssueID>1510</IssueID>
        <Title>.NET framework SDK projects without a RID are incorrectly passing RID specific assets to conflict resolution.</Title>
        <Description>1. Create a .net standard 1.4 library.
2. Create a .net core SDK class library (multi-targeting) and have net461 as one of the targets.
3. Reference the .net standard 1.4 library from the multi-targeting class library.
4. Build.

Expect: all netstandard facades appear in bin directory.
Actual: System.Security.Cryptography.Algorithms.dll is missing.  Notice the following (among others) in the log:
``

Bug is here: https://github.com/dotnet/sdk/blob/b20dc8212d57adc1f122e5d3c837e327d2065e60/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.ConflictResolution.targets#L23-L47

.NET Core is the only thing that understands RuntimeTarget items.  I suspect that whole item should be conditioned on something (TargetFrameworkIdentifier?) that means "I should get RuntimeTarget items copied".

/cc @dsplaisted </Description>
        <CreatedDate>17/08/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
        <Labels>
          <Label>Blocking Partner</Label>
          <Label>Bug</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1565</PullRequestID>
        <IssueID>1465</IssueID>
        <Title>"Encountered conflict" build messages reported for satellite assemblies during build of .NET Core project</Title>
        <Description>Repro: 
1. Create a .NET Core project targeting net46
2. Add a package reference to some nuget package that contains satellite assemblies, e.g. Microsoft.VisualStudio.Composition, 15.3.38
3. Run

``</Description>
        <CreatedDate>01/08/2017</CreatedDate>
        <ClosedDate>25/09/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1559</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Disable multilevel lookup in build/test to prevent accidental machine dependencies</Title>
    <Description>Cherry-picked multi-level lookup fix from #1519 for master</Description>
    <CreatedDate>02/09/2017</CreatedDate>
    <ClosedDate>02/09/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1559</PullRequestID>
        <IssueID>1519</IssueID>
        <Title>Bump default versions for self-contained apps</Title>
        <Description>Also, prevent multilevel lookup from interfering with builds.</Description>
        <CreatedDate>18/08/2017</CreatedDate>
        <ClosedDate>21/08/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1530</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>tishion</FixedByID>
    <Title>Fix-#1521 Output the file path in warning message</Title>
    <Description>This PR only enriches the log message with the file path which caused the warning, but it doesn't provide the approach to allow the user to ignore these kind of warnings. Please refer to the issue #1521 </Description>
    <CreatedDate>23/08/2017</CreatedDate>
    <ClosedDate>30/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1530</PullRequestID>
        <IssueID>1521</IssueID>
        <Title>VS 15.3 came with new unexpected and not actionable warnings</Title>
        <Description>After upgrade to VS 2017 15.3 and corresponding MSBuild our solution started to produce a lot of the following warnings:

Microsoft.NET.Build.Extensions.NETFramework.targets(48,5): warning : Resolved file has a bad image, no metadata, or is otherwise inaccessible. Index not found. (Exception from HRESULT: 0x80131124) [C:\***.csproj]

@ericstj I believe it belongs to your GetDependsOnNETStandard task.

There are multiple problems with it. For one it does not have any MSB number and there is no way to look it up or to suppress it. Another problem - this warning is not actionable, as even with Diagnostics log level it does not tell which exactly binary caused the warning. And third - the warning is most probably bogus anyway and simply reacts on some unmanaged reference.

Please advise how we supposed to deal with it. It pollutes our otherwise clean build output.</Description>
        <CreatedDate>19/08/2017</CreatedDate>
        <ClosedDate>24/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1526</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Close paren in property reference for NuGet import</Title>
    <Description>This condition was being interpreted as a content, because the $()
expression never closed, so it was comparing the literal string
`$(ImportNuGetBuildTasksPackTargetsFromSdk` to `false`, which doesn't
match.

Fixes #1491.</Description>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>24/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1526</PullRequestID>
        <IssueID>1491</IssueID>
        <Title>Pack targets are no longer being overridden on adding a package reference to NuGet.Build.Tasks.Pack nupkg</Title>
        <Description>[out.txt](https://github.com/dotnet/sdk/files/1226157/out.txt)
Repro steps:
dotnet new classlib
Add a package reference to NuGet.Build.Tasks.Pack nupkg 4.4.0-preview1-4422 ([nuget-build feed on myget](https://dotnet.myget.org/feed/nuget-build/package/nuget/NuGet.Build.Tasks.Pack/4.4.0-preview1-4422))
dotnet pack (using dotnet 2.0 RTM)

The pack targets that are shipped with dotnet sdk 2.0 end up being used instead of the ones from the nupkg.

attached a diag log from packing the csproj (you can search for the resolved value of the property NuGetBuildTasksPackTargets)

CC: @nguerrera @dsplaisted 

</Description>
        <CreatedDate>15/08/2017</CreatedDate>
        <ClosedDate>24/08/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1505</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Revert "Update version to 2.0.2-vspre"</Title>
    <Description>Reverts dotnet/sdk#1504, which was merged into the wrong branch</Description>
    <CreatedDate>17/08/2017</CreatedDate>
    <ClosedDate>17/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1505</PullRequestID>
        <IssueID>1504</IssueID>
        <Title>Update version to 2.0.2-vspre</Title>
        <Description>Update version to 2.0.2-vspre</Description>
        <CreatedDate>16/08/2017</CreatedDate>
        <ClosedDate>16/08/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1487</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dasMulli</FixedByID>
    <Title>Change xml formatting for store artifacts xml</Title>
    <Description>Fixes most of https://github.com/dotnet/cli/issues/7010

Fixes #1490

cc @eerhardt @ramarag </Description>
    <CreatedDate>15/08/2017</CreatedDate>
    <ClosedDate>18/08/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1487</PullRequestID>
        <IssueID>1490</IssueID>
        <Title>dotnet store artifacts.xml file structure nits</Title>
        <Description>Moved from https://github.com/dotnet/cli/issues/7010

## Steps to reproduce

Use the `dotnet store` command and examine the `artifacts.xml` target manifest file output.

## Expected  behavior

Neat file structure.

## Actual behavior

Little bit messy file structure:

``

Response @mikkelbu 8/15/2017
&gt; @guardrex As far as I can tell the problems are not in this project. We just call msbuild with a /t:ComposeStore option. The problems reside in the sdk, more precisely in this line.
https://github.com/dotnet/sdk/blob/cd25d6bbfc2aac61cc790c511900427ac64fdaa8/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.ComposeStore.targets#L142

&gt; All the spacing problems should be easy to solve (I don't know much about msbuild, so I cannot tell whether it is possible to solve the problem about casing).

Response @dasMulli 8/15/2017

&gt; @mikkelbu you're right that's where it comes from. Since this was practically done after playing around with that line, I went ahead and opened a PR..

cc/ @dasMulli @mikkelbu</Description>
        <CreatedDate>15/08/2017</CreatedDate>
        <ClosedDate>18/08/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1461</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update error message text when 2.0 SDK is required to build a project</Title>
    <Description>Update error message to account for #1387.

cc @ericstj @terrajobst</Description>
    <CreatedDate>27/07/2017</CreatedDate>
    <ClosedDate>28/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1461</PullRequestID>
        <IssueID>1387</IssueID>
        <Title>Add netstandard support facades when ns1.5+ libraries are referenced</Title>
        <Description>Previously we only added the netstandard2.0 facades when a netstandard2.0 library
was referenced.

This will also apply them if a netstandard1.5 or greater library is referenced.

This addresses the case where packages (like System.Runtime) are broken after NuGet
remapped net461 from netstandard1.4 to netstandard2.0.

Fixes #1386 

/cc @livarcocc @dsplaisted </Description>
        <CreatedDate>05/07/2017</CreatedDate>
        <ClosedDate>06/07/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Impacts VS</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1456</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>ericstj</FixedByID>
    <Title>Free metadata reader and assembly after reading metadata</Title>
    <Description>Fixes leak of assemblies where they weren't being closed until GC.

Fixes #1453 

/cc @rainersigwald @livarcocc </Description>
    <CreatedDate>25/07/2017</CreatedDate>
    <ClosedDate>27/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1456</PullRequestID>
        <IssueID>1453</IssueID>
        <Title>GetFileDependsOnNETStandard holds handles to assemblies after it returns</Title>
        <Description>I believe this is the root cause of https://github.com/NuGet/Home/issues/5609.

I've been looking at this with @mishra14. 

It appears that [GetFileDependsOnNETStandard](https://github.com/dotnet/sdk/blob/98ea6b2a1701ee9e2e3dd8122c77d5a2adcc5bb7/src/Tasks/Microsoft.NET.Build.Extensions.Tasks/GetDependsOnNETStandard.netstandard.cs#L14), introduced to support .NET Standard 2.0 in VS 15.3, holds locks on files longer than it should.

It [appears](https://github.com/dotnet/sdk/blob/98ea6b2a1701ee9e2e3dd8122c77d5a2adcc5bb7/src/Tasks/Microsoft.NET.Build.Extensions.Tasks/GetDependsOnNETStandard.net46.cs#L130) to close the handle to the files it's inspecting, but we can observe through the debugger that they don't get closed immediately--stepping over that line and running a `handle.exe` search shows the handle still open.

When `devenv.exe` is started from an environment with `set ImplicitlyExpandNETStandardFacades=false`, project creation succeeds. That property [disables calling `GetDependsOnNETStandard`](https://github.com/dotnet/sdk/blob/98ea6b2a1701ee9e2e3dd8122c77d5a2adcc5bb7/src/Tasks/Microsoft.NET.Build.Extensions.Tasks/msbuildExtensions/Microsoft/Microsoft.NET.Build.Extensions/Microsoft.NET.Build.Extensions.NETFramework.targets#L24).</Description>
        <CreatedDate>25/07/2017</CreatedDate>
        <ClosedDate>27/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1454</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update simple name references with HintPath from DLL from NuGet package instead of replacing reference</Title>
    <Description>Fixes #1244</Description>
    <CreatedDate>25/07/2017</CreatedDate>
    <ClosedDate>10/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1454</PullRequestID>
        <IssueID>1244</IssueID>
        <Title>Simple name reference conflict resolution results in yellow-reference</Title>
        <Description>It looks like the project system is complaining about simple name removals.

To reproduce:
1. Create an SDK project targeting .NET 4.6.
2. Add a simple name Reference to System.Net.Http in the project file.
3. Add a package reference to System.Net.Http 4.3.2.
4. Build.

Expect: 
Succcessful build with no warnings.

Actual:
Successful build, but project system is putting a yellow triangle on the reference.  In an non-SDK project (legacy CSProj) I see similar behavior with an actual warning `The referenced component 'System.Net.Http' could not be found.`

This seems to be the result of https://github.com/dotnet/sdk/blob/25c7fce70a2f27aa67b84fded37d9ce7b89c9b06/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.PackageDependencyResolution.targets#L371-L375, and I suspect the same thing would have happened in the old project.json implementation of this logic.  I'm not certain this is the right place for the issue but I wanted to open here to get folks to look at it.  Perhaps we can set some metadata on the winning item that came from the package to make the project system happy.
![image](https://cloud.githubusercontent.com/assets/8918108/26380432/759bc32a-3fd3-11e7-8656-8d31d141f4bf.png)

@davkean @jasonmalinowski do either of you have any idea what the project system is looking at to determine if a reference item in the project was successfully resolved?
</Description>
        <CreatedDate>23/05/2017</CreatedDate>
        <ClosedDate>26/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1442</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>BrunoJuchli</FixedByID>
    <Title>Fix #1435 - calculation of ResolvedPath for project references</Title>
    <Description>See #479 and #1435 for error description and analysis of the problem. In short:

The old implementation combined the relative `&lt;ProjectReference Include="..." /&gt;` path with the directory of the `ProjectAssetFile`.
Corrected this to combine the relative project reference with the current's project path.

Questions:
 - Is it actually the desired outcome that ResolvedPath points to the csproj file? Or should it point to the output directory of that project?
 - Is ProjectPath always passed in as full path? (otherwise it needs to be enclosed by a `Path.GetFullPath`)</Description>
    <CreatedDate>22/07/2017</CreatedDate>
    <ClosedDate>30/10/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1442</PullRequestID>
        <IssueID>479</IssueID>
        <Title>ResolvePackageDependencies produces incorrect Resolved paths for project references</Title>
        <Description>ResolvePackageDependencies resolves paths for project references were computed based on the project root, which was originally [based on the location of the project lock file](https://github.com/dotnet/sdk/blob/39b7aba65043f9cb3cb7fce1b7466b5985d3b960/src/Tasks/Microsoft.NET.Build.Tasks/ResolvePackageDependencies.cs#L429). This needs to be updated or removed since the assets file has moved, and the assets file may contain more appropriate root folder information.

The resolved path for project references is not actually used anywhere currently, so this bug does not cause any problems, but should be fixed anyway.</Description>
        <CreatedDate>12/12/2016</CreatedDate>
        <ClosedDate>23/01/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1442</PullRequestID>
        <IssueID>1435</IssueID>
        <Title>ResolvePackageDependencies produces invalid ResolvedPath for `&lt;ProjectReference .../&gt;`</Title>
        <Description>Running on latest previews (VS2017.3 Preview 4, .net sdk 2.0.0-preview2-006497) my build fails because the `ResolvePackageDependencies` Task produces invalid results / output. I'm building from within VS.

In short, a path included in `@(PackageDefinitions-&gt;'%(ResolvedPath)'` is wrong. Here is the actual vs the expected path:

&gt; C:\Development\StaticProxy.Fody.VS2017\IntegrationTests\StaticProxy.Fody\StaticProxy.Fody.csproj
C:\Development\StaticProxy.Fody.VS2017\StaticProxy.Fody\StaticProxy.Fody.csproj

The actual path does not exist, that's why a consumer of this path fails.

The complete output for that particular PackageDefinition (which results from a `&lt;ProjectReference Include="..\StaticProxy.Fody\StaticProxy.Fody.csproj" /&gt;`) is:

&gt; 2&gt;                StaticProxy.Fody/1.0.0
&gt; 2&gt;                        Name=StaticProxy.Fody
&gt; 2&gt;                        Path=../StaticProxy.Fody/StaticProxy.Fody.csproj
&gt; 2&gt;                        ResolvedPath=C:\Development\StaticProxy.Fody.VS2017\IntegrationTests\StaticProxy.Fody\StaticProxy.Fody.csproj
&gt; 2&gt;                        Type=project
&gt; 2&gt;                        Version=1.0.0

Excerpts from the *.csproj of the project (targeting net462) follows, but I would like to mention that some of the projects in the solution actualy do target netstandard - don't know if that makes a difference?

	&lt;?xml version="1.0" encoding="utf-8"?&gt;
	&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
	  &lt;PropertyGroup&gt;
		&lt;TargetFrameworks&gt;net462&lt;/TargetFrameworks&gt;
	  &lt;/PropertyGroup&gt;
	  &lt;ItemGroup&gt;
		&lt;Reference Include="System" /&gt;
		...
		&lt;PackageReference Include="Castle.Core" Version="4.1.1" /&gt;
		...
      &lt;/ItemGroup&gt;
	  ...
	  &lt;ItemGroup&gt;
		&lt;ProjectReference Include="..\StaticProxy.Fody\StaticProxy.Fody.csproj" /&gt;
	  &lt;/ItemGroup&gt;
	&lt;/Project&gt;


Link to project: https://github.com/BrunoJuchli/StaticProxy.Fody/tree/7d8b924d90759cb3248803514ba631463358494a/

Diagnostic MSBuild Log: https://gist.github.com/BrunoJuchli/c5c8b5e74571cbaa99e8e8e5997acaf3/raw/9bc0f0bd94cd77ccf0cbfb58bf66982dfca961bb/MsBuildLog.txt
</Description>
        <CreatedDate>21/07/2017</CreatedDate>
        <ClosedDate>26/07/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1436</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>BrunoJuchli</FixedByID>
    <Title>Fix #1435 - calculation of ResolvedPath for project references</Title>
    <Description>See #1435 for error description and analysis of the problem.

Questions:
 - Is it actually the desired outcome that ResolvedPath points to the csproj file? Or should it point to the output directory of that project?
 - Is ProjectPath always passed in as full path? (otherwise it needs to be enclosed by a `Path.GetFullPath`)</Description>
    <CreatedDate>21/07/2017</CreatedDate>
    <ClosedDate>22/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1436</PullRequestID>
        <IssueID>1435</IssueID>
        <Title>ResolvePackageDependencies produces invalid ResolvedPath for `&lt;ProjectReference .../&gt;`</Title>
        <Description>Running on latest previews (VS2017.3 Preview 4, .net sdk 2.0.0-preview2-006497) my build fails because the `ResolvePackageDependencies` Task produces invalid results / output. I'm building from within VS.

In short, a path included in `@(PackageDefinitions-&gt;'%(ResolvedPath)'` is wrong. Here is the actual vs the expected path:

&gt; C:\Development\StaticProxy.Fody.VS2017\IntegrationTests\StaticProxy.Fody\StaticProxy.Fody.csproj
C:\Development\StaticProxy.Fody.VS2017\StaticProxy.Fody\StaticProxy.Fody.csproj

The actual path does not exist, that's why a consumer of this path fails.

The complete output for that particular PackageDefinition (which results from a `&lt;ProjectReference Include="..\StaticProxy.Fody\StaticProxy.Fody.csproj" /&gt;`) is:

&gt; 2&gt;                StaticProxy.Fody/1.0.0
&gt; 2&gt;                        Name=StaticProxy.Fody
&gt; 2&gt;                        Path=../StaticProxy.Fody/StaticProxy.Fody.csproj
&gt; 2&gt;                        ResolvedPath=C:\Development\StaticProxy.Fody.VS2017\IntegrationTests\StaticProxy.Fody\StaticProxy.Fody.csproj
&gt; 2&gt;                        Type=project
&gt; 2&gt;                        Version=1.0.0

Excerpts from the *.csproj of the project (targeting net462) follows, but I would like to mention that some of the projects in the solution actualy do target netstandard - don't know if that makes a difference?

	&lt;?xml version="1.0" encoding="utf-8"?&gt;
	&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
	  &lt;PropertyGroup&gt;
		&lt;TargetFrameworks&gt;net462&lt;/TargetFrameworks&gt;
	  &lt;/PropertyGroup&gt;
	  &lt;ItemGroup&gt;
		&lt;Reference Include="System" /&gt;
		...
		&lt;PackageReference Include="Castle.Core" Version="4.1.1" /&gt;
		...
      &lt;/ItemGroup&gt;
	  ...
	  &lt;ItemGroup&gt;
		&lt;ProjectReference Include="..\StaticProxy.Fody\StaticProxy.Fody.csproj" /&gt;
	  &lt;/ItemGroup&gt;
	&lt;/Project&gt;


Link to project: https://github.com/BrunoJuchli/StaticProxy.Fody/tree/7d8b924d90759cb3248803514ba631463358494a/

Diagnostic MSBuild Log: https://gist.github.com/BrunoJuchli/c5c8b5e74571cbaa99e8e8e5997acaf3/raw/9bc0f0bd94cd77ccf0cbfb58bf66982dfca961bb/MsBuildLog.txt
</Description>
        <CreatedDate>21/07/2017</CreatedDate>
        <ClosedDate>26/07/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1432</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't automatically set Link metadata for items coming from Shared Projects</Title>
    <Description>**Customer scenario**

Reference a Shared Project from an Sdk-style project.

**Bugs this fixes:** 

#1415 and dotnet/cli#7092

**Workarounds, if any**

Set the `SetLinkMetadataAutomatically` property to false

**Risk**

Low.

**Performance impact**

No.

**Is this a regression from a previous update?**

Yes, referencing shared projects was regressed by #1246

**Root cause analysis:**

With #1246, we automatically set `Link` metadata for items that are outside of the project folder.  Shared project references are implemented via importing the shared project's `.projitems` file in the referencing project, so automatically setting the `Link` metadata on these items caused them to also show up in the referencing project (as well as potentially change the path under the output they were copied to).  This change avoids setting the `Link` metadata for items coming from shared projects.

**How was the bug found?**

Customer report</Description>
    <CreatedDate>20/07/2017</CreatedDate>
    <ClosedDate>21/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1432</PullRequestID>
        <IssueID>1415</IssueID>
        <Title>dotnet sdk 2.0 degrades shared projects experience in VS</Title>
        <Description>**Before upgrading from 1.0.1 to 2.0**
Clone https://github.com/dotnet/symreader-converter
Sync to commit 98c41bf14a75994269df842b314c8a32d8e4aa3b.

Run ``, and open SymReaderConverter.sln in VS.

![image](https://user-images.githubusercontent.com/41759/28233531-568c6c80-68ac-11e7-87e2-ec39d68035c1.png)

Notice all the linked files that shouldn't be displayed in the project.
</Description>
        <CreatedDate>14/07/2017</CreatedDate>
        <ClosedDate>21/07/2017</ClosedDate>
        <Labels>
          <Label>In PR</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1432</PullRequestID>
        <IssueID>7092</IssueID>
        <Title>Unable to start process "dotnet-projectmodel-server" while starting VS2015</Title>
        <Description>## Steps to reproduce
Install dotnet cli sdk 1.0.0-preview3-004050
Open an xproj based solution (I opened the [nuget.core](https://github.com/NuGet/NuGet.Client) solution, Not sure if this is an issue with all xproj solutions.)

## Expected  behavior
Solution should load without error

## Actual behavior

Get an error - 

![2016-11-04](https://cloud.githubusercontent.com/assets/10507120/20018227/26ccc3ee-a284-11e6-82ab-113cfeb523b8.png)



## Environment data
`dotnet --info` output:

``

## Extra

Not sure if dev14 is suppose to play nice with preview3. Raising a bug for visibility.


</Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>31/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1432</PullRequestID>
        <IssueID>1246</IssueID>
        <Title>Automatically set Link metadata on items outside the project folder</Title>
        <Description>Fixes #1115 

- Automatically add `Link` metadata for `Compile`, `AdditionalFiles`, `None`, `Content`, and `EmbeddedResource` items where:
  - `Link` metadata is not already set, and
  - The item’s `FullPath` is outside of the project directory
- If setting the `Link` metadata automatically, the value will be set to `%(LinkBase)\%(RecursiveDir)%(Filename)%(Extension)`.  If `LinkBase` or `RecursiveDir` are not defined, then those pieces will be left out of the value.  So `&lt;Compile Include="..\Shared\**\*.cs" LinkBase="Shared" /&gt;` would show the items under the "Shared" folder in solution explorer, instead of the root, and would preserve any heirarchy under the shared folder.
- Allow opting out of automatically adding `Link` metadata by setting the `SetLinkMetadataAutomatically` property to false
</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>25/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1432</PullRequestID>
        <IssueID>1246</IssueID>
        <Title>Automatically set Link metadata on items outside the project folder</Title>
        <Description>Fixes #1115 

- Automatically add `Link` metadata for `Compile`, `AdditionalFiles`, `None`, `Content`, and `EmbeddedResource` items where:
  - `Link` metadata is not already set, and
  - The item’s `FullPath` is outside of the project directory
- If setting the `Link` metadata automatically, the value will be set to `%(LinkBase)\%(RecursiveDir)%(Filename)%(Extension)`.  If `LinkBase` or `RecursiveDir` are not defined, then those pieces will be left out of the value.  So `&lt;Compile Include="..\Shared\**\*.cs" LinkBase="Shared" /&gt;` would show the items under the "Shared" folder in solution explorer, instead of the root, and would preserve any heirarchy under the shared folder.
- Allow opting out of automatically adding `Link` metadata by setting the `SetLinkMetadataAutomatically` property to false
</Description>
        <CreatedDate>24/05/2017</CreatedDate>
        <ClosedDate>25/05/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1407</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Expand .NET Standard facades during design-time builds when referencing a .NET Standard project that hasn't been built yet</Title>
    <Description>Fixes #1403

I would like to fix #1393 together with this, which is a similar bug for .NET Standard 1.x projects.  However, I'm still assessing the risk of doing so by changing the TargetPlatformIdentifier from `Windows` to `Portable` for .NET Standard projects.</Description>
    <CreatedDate>13/07/2017</CreatedDate>
    <ClosedDate>17/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1407</PullRequestID>
        <IssueID>1403</IssueID>
        <Title>IDE shows missing netstandard.dll while build succeeds</Title>
        <Description>I’m using the latest (public) version of VS with the latest .NET Core tooling. I’m consuming a .NET Standard 2.0 library from a .NET Framework 4.6.1 project. The project builds and runs just fine, but shows errors in the IDE:

![Errors in IDEs](https://user-images.githubusercontent.com/5169960/28092473-584c1fb8-6648-11e7-928e-5c3b78fa764f.jpg)

## Repro steps

1. Create a .NET Standard 2.0 class library
2. Change the code of `Class1` as follows:
    ``

## Expected Behavior

No squiggles and no items in the error list.

## Actual Behavior

The error list shows the following errors:

* CS0012: The type `ValueTuple&lt;,&gt;` is defined in an assembly that is not referenced. You must add a reference to assembly `netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51`.
* CS1503: Argument 1: cannot convert from `(string key, int value)` to `bool`

However, the project compiles &amp; runs fine.

## Findings

From @davkean

&gt; It’s very likely the compiler isn’t being given the netstandard.dll via the design-time build. No idea how this gets added to a .NET Framework 4.6.1 project – but whomever adds that dll should investigate. They can get the results of a design-time build: https://github.com/dotnet/project-system/blob/master/docs/design-time-builds.md#getting-visual-studio-to-output-the-results-of-a-design-time-build.

From @nguerrera 

&gt; Please file a bug on dotnet/sdk as that’s where the component that adds the netstandard ref to netframework projects [now lives](https://github.com/dotnet/sdk/blob/release/2.0.0/src/Tasks/Microsoft.NET.Build.Extensions.Tasks/msbuildExtensions/Microsoft/Microsoft.NET.Build.Extensions/Microsoft.NET.Build.Extensions.NETFramework.targets#L23-L25).
 
</Description>
        <CreatedDate>11/07/2017</CreatedDate>
        <ClosedDate>19/07/2017</ClosedDate>
        <Labels>
          <Label>Impacts VS</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1407</PullRequestID>
        <IssueID>1393</IssueID>
        <Title>ResolveReferences inconsistencies</Title>
        <Description>I have a net461 console project using non-SDK tooling that references a netstandard1.4 library project that uses SDK tooling.

If I build the solution, then call `ResolveReferences` on the console project, the `ImplicitlyExpandDesignTimeFacades` target detects that the referenced netstandard project references System.Runtime, and injects all the net461 facades.

However, if I clean the solution, then call `ResolveReferences` again, `ImplicitlyExpandDesignTimeFacades` does _not_ detect the System.Runtime reference, as the referenced project has not yet been built and there is no assembly to inspect.

However, if I do the same thing with a PCL instead of netstandard, `ResolveReferences` works correctly regardless of whether the project has been built or not.

This is because [the logic for injecting the facades](https://github.com/Microsoft/msbuild/blob/6851538897f5d7b08024a6d8435bc44be5869e53/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets#L95) checks whether any of the project references have a `TargetPlatformIdentifier` value of `Portable`. This is true for PCL projects, not NOT for netstandard. For netstandard projects, the value is `Windows`, which is clearly incorrect.</Description>
        <CreatedDate>06/07/2017</CreatedDate>
        <ClosedDate>21/07/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1387</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>ericstj</FixedByID>
    <Title>Add netstandard support facades when ns1.5+ libraries are referenced</Title>
    <Description>Previously we only added the netstandard2.0 facades when a netstandard2.0 library
was referenced.

This will also apply them if a netstandard1.5 or greater library is referenced.

This addresses the case where packages (like System.Runtime) are broken after NuGet
remapped net461 from netstandard1.4 to netstandard2.0.

Fixes #1386 

/cc @livarcocc @dsplaisted </Description>
    <CreatedDate>05/07/2017</CreatedDate>
    <ClosedDate>06/07/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1387</PullRequestID>
        <IssueID>1386</IssueID>
        <Title>Referencing NETStandard1.5 / NETStandard1.6 library in NET461 project gets wrong facades</Title>
        <Description>See https://github.com/dotnet/core/issues/730#issuecomment-313152425.

Related: https://github.com/dotnet/corefx/issues/19058

The netstandard mapping for `net461` changed from `netstandard1.4` to `netstandard2.0` and NET462 changed from `netstandard1.5` to `netstandard2.0`.

This causes a ref-def mismatch for our old packages, consider System.Runtime:
- netstandard1.0 : 4.0.0.0
- netstandard1.2 : 4.0.10.0
- netstandard1.3 : 4.0.20.0
- netstandard1.5 : 4.1.0.0
- net45 : 4.0.0.0
- net451 : 4.0.10.0
- net46 : 4.0.20.0
- net462 : 4.1.0.0

A library compiled against `netstandard1.5` would get a reference to assembly version 4.1.0.0.  Prior to the NuGet change that library would only run on net462 or later, where the package also carried a facade with the same version.  After the NuGet change its a problem because the package only provides the 4.1.0.0 facade for `net462` and higher.

@terrajobst, @weshaggard, and I had thought about this and planned for it by having the netstandard2.0 support package supersede those older netstandard constituent packages (see related issue).  The idea was the netstandard2.0 support package would be applicable in all cases where it mattered.  The problem was I later did an optimization that only applies the ns2 support libs when netstandard.dll is referenced.

The fix here, will be to instead apply the netstandard support libs whenever netstandard.dll or System.Runtime 4.1.0.0 (or later) is referenced.</Description>
        <CreatedDate>05/07/2017</CreatedDate>
        <ClosedDate>06/07/2017</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1007</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dasMulli</FixedByID>
    <Title>Incremental build improvements for generated AssemblyInfo.cs</Title>
    <Description>Addresses #967 by:
1. Splitting `CoreGenerateAssemblyInfo` into:
  * `_CalculateAssemblyAttributes` which produces `AssemblyAttribute` items.
  * `_CalculateGeneratedAssemblyInfoFileName` which uses the present `AssemblyAttribute` items to product the name of the generated assembly info file, using the `Hash` task introduced in https://github.com/Microsoft/msbuild/pull/1328:
    * `VersionPrefix=1.0.0` =&gt; `obj/Debug/netstandard2.0/lib1.AssemblyInfo.e32ef0.cs`
    * `VersionPrefix=1.0.1` =&gt; `obj/Debug/netstandard2.0/lib1.AssemblyInfo.5be252.cs`
    *  All `Generate*AssemblyAttribute` set to `false` =&gt; `obj/Debug/netstandard2.0/lib1.AssemblyInfo.cs`
2. `CoreGenerateAssemblyInfo` then uses the generated file name as `Outputs` and is executed on incremental builds only when any of the `AssemblyAttribute` items change (even custom ones not generated by the SDK).</Description>
    <CreatedDate>18/03/2017</CreatedDate>
    <ClosedDate>25/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>1007</PullRequestID>
        <IssueID>967</IssueID>
        <Title>AssemblyInfo generation skipped on incremental build even if Version/VersionSuffix changes</Title>
        <Description>## Steps to reproduce:

* `dotnet new lib`
* `dotnet restore`
* `dotnet build`
* `dotnet build /p:VersionSuffix=alpha`
* `dotnet publish /p:Version=1.2.3`
* `dotnet pack /p:VersionSuffix=beta`

## Expected behaviour:

The `bin/Debug/netstandard1.4/tmp.AssemblyInfo.cs` should be updated on every subsequent build/publish/pack command and the resulting assembly shall contain the requested attributes.

## Actual behaviour:

detailed log contains:
``

## Rationale

Since the inputs of `CoreGenerateAssemblyInfo` is limited to `$(MSBuildAllProjects)` it is skipped on incremental build when only the command line arguments change.
Maybe the file name can be changed to include the `Version` property so msbuild will see that the output `tmp.1.0.0-beta.AssemblyInfo.cs` is missing and run the target?</Description>
        <CreatedDate>09/03/2017</CreatedDate>
        <ClosedDate>26/05/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>993</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Updated return of matching TF and RID instructions</Title>
    <Description>Instead of returning a semicolon-delimited string, which must be parsed
on the receiving end and cannot be easily converted to an item (with
relevant metadata like which project it's associated with), return
structured data in the only way MSBuild can: as an item with metadata.

Metadata includes the closest matching TargetFramework and whether or
not the project should have TargetFramework and/or RuntimeIdentifier
stripped before calling it.

Consumed by Microsoft.Common.CurrentVersion.targets in the coordinated
change Microsoft/msbuild#1866.</Description>
    <CreatedDate>15/03/2017</CreatedDate>
    <ClosedDate>16/05/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>993</PullRequestID>
        <IssueID>1866</IssueID>
        <Title>Insert NuGet Build 4.6.0-rtm-4825 into sdk</Title>
        <Description>Insert NuGet Build 4.6.0-rtm-4825 into sdk release/2.1 branch</Description>
        <CreatedDate>19/01/2018</CreatedDate>
        <ClosedDate>26/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>981</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Import Microsoft.Common.Props before Microsoft.NET.Sdk.props</Title>
    <Description>We had some discussion in #924 about how we might import Directory.Build.props files before the .NET SDK's .props files.  I've realized that there may be a simpler solution to this: simply import Microsoft.Common.props before Microsoft.NET.Sdk.props.

I've looked at this a bit and it doesn't look like there is any specific reason that we were importing the SDK .props first.  The main thing that I noted with this change is that .props files from NuGet packages would be imported before the defaults from Microsoft.NET.Sdk.props were set.

We would probably want to add a test to cover this, but I wanted to get this PR out there to start getting feedback on this approach to solving the problem.

@nguerrera @rainersigwald @eerhardt @jeffkl</Description>
    <CreatedDate>13/03/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>981</PullRequestID>
        <IssueID>924</IssueID>
        <Title>Directory.Build.props should be imported before SDK props do anything</Title>
        <Description>Using a `Directory.Build.props` file is one way we've told people to set properties before the common props run (see https://github.com/Microsoft/msbuild/issues/1603).  However, `Directory.Build.props` is currently evaluated after `Microsoft.NET.Sdk.props`, which means setting some properties such as the `Configuration` or `Platform` in `Directory.Build.props` leads to inconsistent results, as there are other default property values which are based on them in `Microsoft.NET.Sdk.props`.

A fix to this would be to duplicate the logic [from MSBuild](https://github.com/Microsoft/msbuild/blob/7a255b89c90c38520b5cc6869a5e2a2f1e66da20/src/Tasks/Microsoft.Common.props#L26-L32) that imports `Directory.Build.props` in the SDK targets, and then set `ImportDirectoryBuildProps` to false so that the common props don't try to import it again.

This would be a breaking change for projects that rely (likely accidentally) on the current behavior, so we'd need to assess the compat risk of this change.</Description>
        <CreatedDate>01/03/2017</CreatedDate>
        <ClosedDate>15/03/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>950</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Lock down public surface</Title>
    <Description>Fix #55 - We now public-sign on non-Windows builds instead of leaving assemblies unsigned there
Fix #656 - Limit public surface to Tasks and use InternalsVisibleTo(tests) for other things that were public only for test purposes and being blocked by #55

Also, get rid of the #if PRODUCT and special handling of CacheArtifactParser.cs. I had intended to make this go through IVTA too, but then found that this level of tests do not reference the build tasks, but merely execute them via msbuild, and I didn't want to break that layering. I just wrote the trivial parsing from scratch in to the test using an XLinq query. This is intentionally different from the product code. If the format changes, the tests will break, but I consider that a feature.

@eerhardt @ramarag @333fred @dsplaisted 

</Description>
    <CreatedDate>07/03/2017</CreatedDate>
    <ClosedDate>09/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>950</PullRequestID>
        <IssueID>55</IssueID>
        <Title>Signing does not work on non-Windows</Title>
        <Description>When signing on non-Windows platforms, we get output something like:
`error CS7027: Error signing output with public key from file '/Users/livarcocc/Documents/git/core-sdk/build/Targets/../Strong Name Keys/RoslynInternalKey.Private.snk' -- Assembly signing not supported.`
Once signing is supported on non-Windows, remove the condition in Common.props.
</Description>
        <CreatedDate>16/08/2016</CreatedDate>
        <ClosedDate>09/03/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>950</PullRequestID>
        <IssueID>656</IssueID>
        <Title>Lock down public surface of Microsoft.NET.Build.Tasks</Title>
        <Description>There are things that are public for unit testing only. Switch them to IVTA. This requires changing how we handle signing on non-Windows to public sign instead of not signing at all.</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>09/03/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>950</PullRequestID>
        <IssueID>55</IssueID>
        <Title>Signing does not work on non-Windows</Title>
        <Description>When signing on non-Windows platforms, we get output something like:
`error CS7027: Error signing output with public key from file '/Users/livarcocc/Documents/git/core-sdk/build/Targets/../Strong Name Keys/RoslynInternalKey.Private.snk' -- Assembly signing not supported.`
Once signing is supported on non-Windows, remove the condition in Common.props.
</Description>
        <CreatedDate>16/08/2016</CreatedDate>
        <ClosedDate>09/03/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>916</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>stevedesmond-ca</FixedByID>
    <Title>Fix build on Ubuntu 16.04</Title>
    <Description>Tests were not previously configured to handle 16.04, only 14.04 -- fixes #915</Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>916</PullRequestID>
        <IssueID>915</IssueID>
        <Title>Build (specifically, 1 test) fails on Ubuntu 16.04</Title>
        <Description>Steps to reproduce:
- attempt to build SDK on Ubuntu 16.04 with `./build.sh --configuration Release --platform "Any CPU"`

Expected result:
- build succeeds

Observed result:
``

Incoming PR to fix this.</Description>
        <CreatedDate>24/02/2017</CreatedDate>
        <ClosedDate>27/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>911</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Use windows PDB for symweb compat</Title>
    <Description>**Customer scenario**

Symbols for the SDK tasks dll are not on symweb. And they are currently in incompatible portable format. Without this, we may have difficulty locating appropriate symbols to diagnose customer-reported issues.

**Bugs this fixes:**

#897 (there also need to be build definition changes to automate the uploading)

**Workarounds, if any**

Go locate the portable PDB manually from the raw build drop when debugging. 

**Risk**

Low. Only PDB is changed. No product code is affected.

**Performance impact**

None. Again, only PDB is impacted.

**Is this a regression from a previous update?**

No. We may have built with windows PDB prior to self-hosting SDK build on SDK but that started quite a while ago. Regardless, the build definition has never uploaded symbols to symweb.

**Root cause analysis:**

We did not consider the symweb impact of using SDK defaults, which we are dogfooding.

**How was the bug found?**

Dogfooding

@srivatsn @tmat @333fred </Description>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>24/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>911</PullRequestID>
        <IssueID>897</IssueID>
        <Title>Symbols for Microsoft.Net.Build.Tasks.dll are not be published</Title>
        <Description>The symbols for Microsoft.Net.Build.Tasks.dll are not being published to symweb - making it hard to debug them.</Description>
        <CreatedDate>21/02/2017</CreatedDate>
        <ClosedDate>24/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>899</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>codito</FixedByID>
    <Title>Update TestPlatform to v15.0.0-preview-20170222-09.</Title>
    <Description>Fixes included in this release:
- Performance: provide `DeisgnMode` flag for adapters to distinguish IDE and CLI runs (Microsoft/vstest#349)
- If test code uses TypeDescriptors, string[] are not converted as expected (Microsoft/vstest#427)
- Navigation to test from test explorer is broken if user has new roslyn based test project targeting desktop (Microsoft/vstest#523)

Ask mode template: [Bug 387252](https://devdiv.visualstudio.com/DevDiv/VS.in%20Agile%20Testing%20IDE/_workitems?id=387252&amp;_a=edit)

These fixes are required for RTW, pending shiproom approval of above bug.</Description>
    <CreatedDate>22/02/2017</CreatedDate>
    <ClosedDate>22/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>899</PullRequestID>
        <IssueID>349</IssueID>
        <Title>Support generating a documentation file with GenerateDocumentationFile property</Title>
        <Description>Fixes #193, by automatically setting the `DocumentationFile` property if `GenerateDocumentationFile` is true.

Follow-up bugs to file once this is merged:
- Update the compilation context preservation process to correctly handle the documentation file options (or ignore them entirely if we don't need them).
- Don't set OutputPath in the props files for the Sdk. If we're just going to be modifying it in the targets, then setting it to something in the props files can lead to unexpected behavior when the value is used in the project but doesn't represent the final value of the property.
- In [dotnet/roslyn-project-system](https://github.com/dotnet/roslyn-project-system): Update the "Build" property page so that you can check a box to generate an Xml documentation file without specifying the filename. This should set `GenerateDocumentationFile` to true in the project file instead of setting the `DocumentationFile` property. This behavior should light up based on the `GenerateDocumentationFile` capability so that projects that don't use the Sdk still get the old behavior.</Description>
        <CreatedDate>02/11/2016</CreatedDate>
        <ClosedDate>03/11/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>899</PullRequestID>
        <IssueID>427</IssueID>
        <Title>Default for "Description" should indicate that it's also an assembly description</Title>
        <Description>This is both an assembly and package description - so the default should indicate that:

![image](https://cloud.githubusercontent.com/assets/1103906/20612260/21cd701c-b30c-11e6-920b-0b034c3cc323.png)

</Description>
        <CreatedDate>25/11/2016</CreatedDate>
        <ClosedDate>14/12/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>899</PullRequestID>
        <IssueID>523</IssueID>
        <Title>Update Microsoft.NET.Sdk.props</Title>
        <Description>Fixes https://github.com/dotnet/sdk/issues/516</Description>
        <CreatedDate>16/12/2016</CreatedDate>
        <ClosedDate>16/12/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>889</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>clairernovotny</FixedByID>
    <Title>Add props/targets for PCL, Windows and Xamarin TFM's</Title>
    <Description>This is to implement #491 

- [x] Targets implemented
- [x] Add tests

The project I added to test works when restored/built locally and overriding the MSBuildSdksPath to point to the locally built version. Not sure yet why the test in the harness is failing.

The build server will need the Xamarin and UWP workloads installed and very likely VS 2015 to get the SL5 and WP8 targets.</Description>
    <CreatedDate>18/02/2017</CreatedDate>
    <ClosedDate>08/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>889</PullRequestID>
        <IssueID>491</IssueID>
        <Title>Support additional target frameworks such as for Xamarin, UWP, etc</Title>
        <Description>The current SDK is missing what should be static reference info for its property groups. That makes using multi-targeting much harder and puts more useless info in the csproj.

For example:
https://github.com/onovotny/Zeroconf/blob/367c63d21dacf841c204b13ea178fdce174bb93b/Zeroconf/Zeroconf.csproj#L3

All of those property groups should be in the SDK (with the possible exception of the TargetPlatformMinVersion attribute for UAP, but even there it can default to 10.0.10240 easily).

What should be in the SDK:
- All "inbox" TFM's
  - All PCL profiles with standard aliases (portable-net45+win8+wpa81+wp8), etc. Bonus points for parsing and allowing any order of matching frameworks (via NuGet core logic in task?)
- All installable frameworks (wp8, win, wpa, sl, uap, all Xamarin tfms)

Those property groups should include the appropriate `LanguageTargets` that point to the correct version to ensure a proper build. For a user, it should "just work".

I think it's ok that some TFM's cannot be built with `dotnet build`, but require `msbuild` so that it picks up the correct MSBuildExtension paths for built-in targets. Bonus points for an error/warning if the appropriate targets is missing telling the user to install *foobar* SDK to get it. Clearly some of these builds will only work on Windows too, but that's ok.

</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>886</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>smadala</FixedByID>
    <Title>Insert TestPlatform v15.0.0-preview-20170217-05.</Title>
    <Description>- Discovery is not getting triggered for project targeting net46 (issue [#375688](https://devdiv.visualstudio.com/DevDiv/VS.in%20Agile%20Testing%20IDE/_workitems?id=375688&amp;_a=edit))
- Add TestContainer project capability and IsTestProject prop to Microsoft.Net.Test.Sdk.props (issue https://github.com/Microsoft/vstest/issues/394)
- Console output is badly formated (issue https://github.com/Microsoft/vstest/issues/478)
- Option to minimize console output on vstest.console (issue https://github.com/Microsoft/vstest/issues/301)

ASK mode template: Bug [386425](https://devdiv.visualstudio.com/DevDiv/VS.in%20Agile%20Testing%20IDE/_workitems?id=386425&amp;fullScreen=false&amp;_a=edit)
</Description>
    <CreatedDate>17/02/2017</CreatedDate>
    <ClosedDate>18/02/2017</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>878</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Use Microsoft.NETCore.App 1.1.1 when targeting netcoreapp1.1</Title>
    <Description>When targeting netcoreapp1.1, use version 1.1.1 of the package and shared runtime unless otherwise specified via RuntimeFrameworkVersion

Fixes (half of) #860</Description>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>18/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>878</PullRequestID>
        <IssueID>860</IssueID>
        <Title>Implicit Package Reference to NetCoreApp 1.0.4, 1.1.1</Title>
        <Description>In PR dotnet/cli#5673 we will be moving the in-box frameworks in CLI to 1.0.4 and 1.1.1. We should update the implicit package reference in the SDK to reference the same. I wonder if we should make these versions externally configurable so that the invoking IDE can force the SDK to match what is available.

/cc @dsplaisted @srivatsn </Description>
        <CreatedDate>11/02/2017</CreatedDate>
        <ClosedDate>20/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>876</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Allow .NET Core 2.0 projects to reference assemblies on disk</Title>
    <Description>Fix #120 

The necessary change to the product is to generate the correct .deps.json file.  We were already copying the reference assembly and supporting files into the build/publish folder.

Note this doesn't attempt to fix 'dotnet pack' for this scenario.  That will be up to the NuGet team.

@nguerrera @dsplaisted @srivatsn 

/cc @terrajobst </Description>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>876</PullRequestID>
        <IssueID>120</IssueID>
        <Title>Scenario: enable references to any assembly on disk</Title>
        <Description>.NET Core projects never supported referencing an assembly sitting on disk. MSBuild support this more naturally.

To enable this we need to ensure:
- [x] The assembly is copied to the build and publish folders.
- [x] The assembly is added to the .deps.json file.
- [ ] How does "dotnet pack" handle this scenario?
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>28/02/2017</ClosedDate>
        <Labels>
          <Label>Scenario</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>873</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Make AppendRuntimeIdentifierToPath=true the default</Title>
    <Description>Fix #868

@dsplaisted @srivatsn @eerhardt @piotrpMSFT </Description>
    <CreatedDate>15/02/2017</CreatedDate>
    <ClosedDate>17/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>873</PullRequestID>
        <IssueID>868</IssueID>
        <Title>RID-specific builds should use RID-specific Output Path</Title>
        <Description>We have identified a regression between project.json and csproj which is preventing users from generating deterministic build outputs.

Because this issue prevents us from providing deterministic build outputs, we will need to fix it at some point. I’d rather fix it in 1.0 RTM, before the change becomes `breaking relative to 1.0`.
 
## Background
### What we had in Project.json
In `project.json` the CLI would append the RID to a project’s output path if the output contained RID-specific artifacts. This meant that:
 
``
 
## What’s the issue?
In the new SDK we do not have a unique output path for common build configurations. Consider these scenarios:
 
- Portable Project
  - dotnet build
- Multi-TFM project
  - dotnet build –framework=netcoreapp1.0
  - dotnet build –framework=netcoreapp1.1
- Multi-RID project
  - dotnet build –runtime=win7-x64
  - dotnet build –runtime=win7-x86
 
In the first two project types, everything is fine. The portable project has but a single output. The multi-TFM project has two outputs, but each goes into a TMF-specific directory.
 
The Multi-RID project is the problem. Both of those `build` invocations will result in outputs being generated into the same directory, despite the outputs being meaningfully different!
 
What is worse, this error will likely occur silently. Our own incrementality checks will assume that the x86 build produced valid outputs for x64 and will simply return.
 
## How to fix?
We already have a property, `AppendRuntimeIdentifierToOutputPath`, that is defaulted to ‘false’. We would like, instead, to set this property to `true` by default IFF the current build has a `RuntimeIdentifier` specified. This will provide a unique output path for every build gesture advertised to users. It will also simplify fixes for several `race condition` style bugs that we’re facing because RIDs do not have unique output paths.
 
## What’s the risk?
Early adopters of the SDK [anyone using it so far] may have dependencies on the output path of their RID-specific builds. They will have two recourses once this change is made:
a. Update their dependencies to use the new output path
b. Set AppendRuntimeIdentifierToOutputPath=false in their csproj/on the cmd line
 

/cc @srivatsn @MattGertz @nguerrera @dsplaisted </Description>
        <CreatedDate>14/02/2017</CreatedDate>
        <ClosedDate>17/02/2017</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>855</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>codito</FixedByID>
    <Title>Insert TestPlatform v15.0.0-preview-20170210-02.</Title>
    <Description>Issues fixed:
* Replace invalid characters in trx with unicode escape character (issue microsoft/vstest#320)
* Standard error messages from testhost are passed to console runner (issue microsoft/vstest#281)
* Add autogenerated header to `Program.cs` (issue microsoft/vstest#420)
* Change type name of autogenerated entrypoint (issue microsoft/vstest#430)
* Show adapter messages on runner output (issue microsoft/vstest#300)
* Use RC.3 VSSDK manifests for vsix generation
* **(Edit)** MSBuild  warning on simple xunit test project (issue microsoft/vstest#433)
ASK mode template: [Bug 383308](https://devdiv.visualstudio.com/DevDiv/VS.in%20Agile%20Testing%20IDE/_workitems?_a=edit&amp;id=383308&amp;triage=true)

Required for RTW. Above bug is pending approval.</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>320</IssueID>
        <Title>Allow granular opt out of assembly info generation</Title>
        <Description>Fix #302
</Description>
        <CreatedDate>25/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>281</IssueID>
        <Title>Don't delete Stage0 nuget package from the cache</Title>
        <Description>dsplaisted [8:09 PM]  
When I run a build on the SDK, the build and buildCrossTargeting folders are getting deleted from the Stage0 Microsoft.Net.Sdk package folder in the repo-local package cache.  Is this supposed to happen? 

nguerrera [11:31 AM] for Daniel's question. I am also seeing this and it's tripping up VS quite badly. I notice that there's an InvalidatePackageCache target that sometimes warns it can't finish nuking the package.

``

eerhardt [11:37 AM]  
yes, it is intended.  (but we can look at another approaches)
the reason this happens is for testing.  We need to guarantee that our tests resolve the newly built Sdk
and not the Stage0 version from the cache
one option would be just to delete the hash files in the cache.  then NuGet will never use that cached version
another option would be to use separate package caches between the build and the tests
but that has perf drawbacks
another thought I just realized - we could specify [_version_] in the PackageReference
which means "use this version AND ONLY this version"
that seems like the most appropriate to me right now
but we still need to delete the newly built version from the package cache
for incremental dev work purposes
I build clean repo - tests pass
make a change which breaks tests  - tests still pass cuz it uses previously cached version
</Description>
        <CreatedDate>14/10/2016</CreatedDate>
        <ClosedDate>18/10/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>420</IssueID>
        <Title>'appsettings.json' files are optional by convention - publish .csproj in Preview 4 fails with MSB3030 error</Title>
        <Description>Moved from https://github.com/dotnet/cli/issues/4791 on behalf of @peterblazejewicz

@nguerrera pointed out that this is an SDK issue.

----

I have set of projects, including one in the  production at my company. I've migrated sample project to .csproj and now I found it fails to publish with '1.0.0-preview4-004107' because of missing file:

&gt; dotnet publish
Microsoft (R) Build Engine version 15.1.0.0
Copyright (C) Microsoft Corporation. All rights reserved.
  PolymerShopDotnet.Client -&gt; /Users/piotrblazejewicz/git/polymer-shop-dotnet/PolymerShopDotnet/src/PolymerShopDotnet.Client/bin/Debug/netcoreapp1.0/PolymerShopDotnet.Client.dll
/Users/piotrblazejewicz/.nuget/packages/microsoft.net.sdk/1.0.0-alpha-20161104-2/build/Microsoft.NET.Publish.targets(98,5): error MSB3030: Could not copy the file "/Users/piotrblazejewicz/git/polymer-shop-dotnet/PolymerShopDotnet/src/PolymerShopDotnet.Client/appsettings.json" __because it was not found.__ [/Users/piotrblazejewicz/git/polymer-shop-dotnet/PolymerShopDotnet/src/PolymerShopDotnet.Client/PolymerShopDotnet.Client.csproj]

This behavior is different from tools behavior based on `project.json` I believe. 

``
</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>08/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>430</IssueID>
        <Title>Space in between ids in RuntimeIdentifiers caused restore to fail</Title>
        <Description>Specifying the RIDs for a net core app leaving space between the ids causes restore to fail

This fails:
``

Moving this over here from the CLI: https://github.com/dotnet/cli/issues/4845</Description>
        <CreatedDate>26/11/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>300</IssueID>
        <Title>Create a Nuget package for the full SDK</Title>
        <Description>Microsoft.Build.Runtime only puts together MSBuild, it is not a full build environment. To be usable as a library, a package containing MSBuild, Nuget, C# compilers, compiler targets must exist.

We think the SDK is the right place to put this issue so that this package can be consumed by users &amp; the CLI repo.

https://github.com/Microsoft/msbuild/issues/1096
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>855</PullRequestID>
        <IssueID>433</IssueID>
        <Title>Target "BuiltProjectOutputGroup" does not exist when using &lt;TargetFrameworks&gt;</Title>
        <Description>This means that multi-targeting .net core projects cannot be referenced by VSIX projects, which invoke this target to discover what to include in the VSIX. All is well when using a single &lt;TargetFramework&gt;, but I cannot do that because of #266. </Description>
        <CreatedDate>27/11/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>852</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>replace project-level Common.props imports with Directory.Build.props</Title>
    <Description>This removes the Common.props imports from the projects under /test and /src and replaces them with Directory.Build.props.

This addresses #802.</Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>852</PullRequestID>
        <IssueID>802</IssueID>
        <Title>In SDK build, set BaseIntermediateOutputPath before it is used for MSBuildProjectExtensionsPath</Title>
        <Description>We're overriding BaseIntermediateOutputPath in our Common.props file, but this is after it's used to calculate the MSBuildProjectExtensionsPath, which means we aren't getting any of the NuGet generated props or targets files (and hence the props or targets from packages) as part of our build.

To fix this, we can use Directory.Import.targets, which will get imported before the MSBuildProjectExtensionsPath is evaluated.  We can put a Directory.Import.targets in the src/ and test/ folders which imports our Common.props, and then remove the explicit Common.props import from all of our projects.</Description>
        <CreatedDate>03/02/2017</CreatedDate>
        <ClosedDate>17/04/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>847</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Remove requirement for specifying a RID in desktop exe projects</Title>
    <Description>**Customer scenario**
* Cannot build AnyCPU desktop app (common case) using SDK/new project system without applying a cumbersome and hard-to-understand workaround.
* Cannot build desktop app with native nuget dependencies without making a RID choice.

The approach taken is scoped to address these two common cases:

1. Building AnyCPU desktop application
2. Building win7+ desktop applications with native dependencies

Both of the above will happen automatically and F5 successfully without any mention of RuntimeIdentifier or PlatformTarget in the project. Other scenarios will still require adjusting the RID and PlatformTarget to resolve the native dependencies correctly and stamp the resulting binary correctly.

Follow-ups to improve the experience outside these cases:

* https://github.com/dotnet/sdk/issues/840
* https://github.com/dotnet/sdk/issues/843

**Bugs this fixes:**
Fix #396 and its myriad of duplicates/consequences.

**Workarounds, if any**
Specify dummy runtime identifier for AnyCPU app, and explicitly let PlatformTarget to AnyCPU.
Always pick a RID whenever taking native nuget dependencies from a desktop app.

**Risk**
Low. We address two common cases with new defaults. Specifying PlatformTarget and RuntimeIdentifier explicitly shuts off these defaults and gives the user the same control they had before. We simply make it so that this control needn't be used for the most common cases.

**Performance impact**
Minimal. A few extra checks are needed in msbuild evaluation.

**Is this a regression from a previous update?**
No.

**Root cause analysis**
N/A since we are amending a deliberate design decision in response to significant customer and partner feedback.

**How was the bug found**
Customer and partner reported.

@srivatsn @dsplaisted @eerhardt @dotnet/project-system 




</Description>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>847</PullRequestID>
        <IssueID>396</IssueID>
        <Title>Remove requirement of setting RuntimeIdentifier in project file for .NET Framework Exe projects</Title>
        <Description>Right now we require that .NET Framework Exe projects [set a `RuntimeIdentifier` property](https://github.com/dotnet/sdk/blob/0908e3556df08d9ba308291b4d9fe4fb2154c0fc/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.RuntimeIdentifierInference.targets#L49).  This is because ASP.NET Core projects depend on the native library in the [libuv package](https://github.com/aspnet/libuv-package).  In .NET Core we have a way of deploying both x86 and x64 versions and loading the correct one at runtime, but we don't have this for .NET Framework.  That means we effectively don't support AnyCPU for projects that depend on Libuv (or other packages authored in the same way).

At a minimum, we should change it so that the RuntimeIdentifier is only required when there is a package in the dependency graph that has architecture-specific assets.

We should also try to get rid of the requirement of setting`RuntimeIdentifier` in web projects.  This could include setting it to a default in the Web SDK targets when targeting .NET Framework, or updating the Libuv and Kestrel packages to deploy both architectures and load the right native DLL at runtime.</Description>
        <CreatedDate>16/11/2016</CreatedDate>
        <ClosedDate>16/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>836</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Use RID less targets to obtain compile assets</Title>
    <Description>https://github.com/NuGet/Home/issues/4207 reports that NuGet is incorrectly including runtime assemblies in the "compile" assets for RID-specific targets. This is compounded by the fact that this SDK populates References using compile assets from RID-specific targets, but these compile assets should be independent of RID, and come from the RID-less targets.

This change derives `ResolvedCompileFileDefinitions` and `ResolvedFrameworkAssemblies` from file dependencies with parent target equal to `NuGetTargetMoniker` (i.e. excluding the RID if one exists)

A fix for the NuGet issue is available (https://github.com/NuGet/NuGet.Client/pull/1103) but is not currently targeting RTW because of risk. My fix may also carry some risk for any scenarios where builds were previously working by accident because we were pulling in runtime assets. But making this available for consideration in case we decide to take it.

Fixes #592

/cc @emgarten @dsplaisted @srivatsn @nguerrera @ericstj </Description>
    <CreatedDate>08/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>836</PullRequestID>
        <IssueID>592</IssueID>
        <Title>RID-specific targets section from assets file is being used for compile assets.</Title>
        <Description>When compiling a project that sets a RuntimeIdentifier we should select the compile assets from the RID-less target in the assets.json, but select the runtime assets from the RID-specific target.  It seems that this is not happening.

Repro:
https://gist.github.com/ericstj/452c243859cdc5f88da084d205bc73e9

dotnet restore
dotnet build

notice conflict errors.  There are various other errors later on which may or not be related, but I'd expect this to build (not run) as is.

The relevant code in the old task that did this was https://github.com/NuGet/NuGet.BuildTasks/blob/4a57a0ef4bee31f122d50a39fe3dddd4ca03fb07/src/Microsoft.NuGet.Build.Tasks/ResolveNuGetPackageAssets.cs#L303.

/cc @natidea @jasonmalinowski </Description>
        <CreatedDate>05/01/2017</CreatedDate>
        <ClosedDate>15/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>835</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Fixing self-contained tests on OSX Sierra</Title>
    <Description>Our self-contained tests use netcoreapp1.0 and the current machine's RID.  When building/running on OSX Sierra this is a problem because netcoreapp1.0 only supported the previous 2 OSX versions.

The fix is to check if we are running on a newer OSX machine than what was supported, and downgrade the RID to a supported RID.

Fix #834 

/cc @wjk</Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>07/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>835</PullRequestID>
        <IssueID>834</IssueID>
        <Title>Publishing Test Fails on macOS Sierra</Title>
        <Description>I was trying to build [my fork of dotnet/sdk](https://github.com/wjk/dotnet-sdk) in Release configuration, but one of the tests failed. Specifically, the ["It builds a runnable output" test](https://github.com/dotnet/sdk/blob/master/test/Microsoft.NET.Build.Tests/GivenThatWeWantToBuildASelfContainedApp.cs), when published on my Mac running macOS Sierra, does _not_ output a runnable entry point (apphost), nor does it write out the hostfxr or hostpolicy libraries. (The DLL, PDB, and the various JSON files are present, however.)

Some informal testing on the output of `dotnet new console` (modified only to add an explicit RID) reveals that a simple `dotnet build` does not write out the entry point or the host libraries.  While`dotnet publish` copies all the DLL dependencies, it does not add an entry point or the host libraries, either! This seems like a serious problem. Can anyone point out what might be going wrong? My platform information is below. Thanks!

``</Description>
        <CreatedDate>07/02/2017</CreatedDate>
        <ClosedDate>07/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>832</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rohit21agrawal</FixedByID>
    <Title>update nuget to 4.0.0-rtm-2275</Title>
    <Description>Updating to version of nuget that was inserted into VS via PR #56138 
CC: @srivatsn @rrelyea</Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>07/02/2017</ClosedDate>
    <Issues />
  </PullRequest>
  <PullRequest>
    <IssueID>828</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>TheRealPiotrP</FixedByID>
    <Title>Enable P2P's to determine their own compilation RID</Title>
    <Description>Fixes the RID P2P component of #696 

This is part of a two-part PR. The second part is microsoft/msbuild#1674. 

## What
These PRs, together, enable the following class of projects:
* A RID-specific root project [App.csproj]
* A portable dependency project [Library.csproj]

With this fix in place, one can:
* `dotnet restore App.csproj`
* `dotnet build -r osx.10.11-x64 App.csproj`

Without the fix, Library.csproj will not build because the `osx.10.11-x64` runtime identifier will be passed through as a global property, forcing it to build for a target that does not exist in the NuGet assets file.

## How
The MSBuild portion of the fix adds `RuntimeIdentifier` to the list of `RemoveProperties` passed to the P2P in `_GetProjectReferenceTargetFrameworkProperties`. It also passes along the value of `RuntimeIdentifier` as `ReferringRuntimeIdentifier` so that the dependency can decide how it wants to interpret that Runtime Identifier. The model used is identical to that used for TargetFramework.

The SDK portion of the fix expands the `GetTargetFrameworkProperties` target to also account for RuntimeIdentifiers. The logic is as follows:
* If the project has `RuntimeIdentifier` or `RuntimeIdentifiers` set then use the ReferringRuntimeIdentifier
* If the project does not specify a RID through either mechanism then use `''` as the RuntimeIdentifier

The effect is that RID-specific projects will attempt to build with the RID passed to the root project. Portable projects will be built without a RID specified. 

## Testing
The PR includes a thorough test for the scenario in question, building a RID-specific project that references both a RID-specific and Portable library. Both libraries are proven to compile successfuly through runtime invocation. The RID-specific library both invokes a RID-specific native dependency AND inspects its own RID via an overloaded AssemblyInfo Description attribute.

The feature was enabled without impacting any existing SDK tests.

The combination of these changes was tested on my local machine by manually editing `Microsoft.Common.CurrentVersion.targets` in the Stage0 `dotnet` directory.

## Risk
This feature requires augmenting `Microsoft.Common.CurrentVersion.targets`. Despite this being a central target, there are mitigating circumstances:
* The target modified is specific to the new project system
* The modification is a verbatim copy of the identical behavior for TargetFramework

## Merge Strategy
Due to the codeflow for these fixes, the following will need to happen in order:
 - [] MSBuild PR is merged
 - [] New MSBuild is inserted into CLI
 - [] SDK's CLI dependency is rev'd to latest and SDK PR is merged
 - [] New SDK is inserted into CLI

/cc @srivatsn @DustinCampbell @livarcocc @jonsequitur @rainersigwald @AndyGerlicher @nguerrera @dsplaisted </Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>828</PullRequestID>
        <IssueID>696</IssueID>
        <Title>Runtime-specific build fails for projects with P2P references</Title>
        <Description>[ Moved from dotnet/cli#4992 ]

## Steps to reproduce
[test_app.zip](https://github.com/dotnet/sdk/files/642914/test_app.zip)
in test_app\App:
- ``


</Description>
        <CreatedDate>20/01/2017</CreatedDate>
        <ClosedDate>16/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>828</PullRequestID>
        <IssueID>1674</IssueID>
        <Title>Allow toolset that tests run against to be controlled by command-line options</Title>
        <Description>- Tests no longer need to be run from within an enlistment of dotnet/sdk.  You should be able to build the tests, then copy the test folder (`bin\Debug\Tests`) and the `TestAssets` folder to another machine and run the tests there.
- Command-line options can be used to specify what "toolset" to run against:

``</Description>
        <CreatedDate>20/10/2017</CreatedDate>
        <ClosedDate>26/10/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>820</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Match Microsoft.NETCore.App package version to runtime version, and allow it to float</Title>
    <Description>Fixes #686

This PR modifies how the runtime framework version is handled.  The following is still true (ie unaffected with this PR):

- There isn't a `PackageReference` to Microsoft.NETCore.App explicitly in your project file
- You specify the version of .NET Core to target via the `TargetFramework` attribute, ie netcoreapp1.0 or netcoreapp1.1
- If you want to target a specific patch version, or a prerelease version, you do that by setting the `RuntimeFrameworkVersion` property

The changes in this PR are:

- If you don't specify a `RuntimeFrameworkVersion`, the package version of Microsoft.NETCore.App will match the version in the `TargetFramework` property.  So if the project targets netcoreapp1.0, then version 1.0.0 of Microsoft.NETCore.App will be used, instead of version 1.1 as was previously the case
- The resolved version of the Microsoft.NETCore.App package will be used as the framework version in the runtimeconfig.json file, instead of using the `RuntimeFrameworkVersion` property directly.  This allows floating versions (for example `2.0-*`) to be specified in the `RuntimeFrameworkVersion` property.

@nguerrera @srivatsn @eerhardt @natemcmaster</Description>
    <CreatedDate>05/02/2017</CreatedDate>
    <ClosedDate>09/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>820</PullRequestID>
        <IssueID>686</IssueID>
        <Title>runtimeconfig.json contains incorrect framework version</Title>
        <Description>Repro:
``

**Details**
Using CLI: 1.0.0-rc3-004517

Happens even when `&lt;DisableImplicitFrameworkReferences&gt;true&lt;/DisableImplicitFrameworkReferences&gt;` is added.</Description>
        <CreatedDate>19/01/2017</CreatedDate>
        <ClosedDate>09/02/2017</ClosedDate>
        <Labels>
          <Label>Blocking Partner</Label>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>819</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Set version early enough not to be overridden by winfx targets on desktop</Title>
    <Description>**Customer scenario**

* net4x package version should be same as other platforms (1.0.0), but it is currently 1.0.0.0 (one too many zeros)
* VersionPrefix has no impact on net4x projects
* Projects multi-targeting net4x and netcoreapp and using default version will fail to nuget restore in VS

Fix #814
Fix #422 
Fix #93 


**Workarounds, if any**

None for VersionPrefix not working on net4x.
For the others, specify an explicit Version in your .csproj


**Risk**

Low. 

**Performance impact**

None 

**Is this a regression from a previous update?**

The nuget restore may have worked before but the version prefix issue has always existed. The fix is the same for both.

**Root cause analysis:**

Missing test coverage for version prefix using desktop msbuild (added with PR).

**How was the bug found?**

Dogfooding and customer reported

@srivatsn @dsplaisted @eerhardt @dotnet/project-system 
</Description>
    <CreatedDate>04/02/2017</CreatedDate>
    <ClosedDate>05/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>819</PullRequestID>
        <IssueID>814</IssueID>
        <Title>Ensure same version for multi-targeting scenarios from innerbuilds</Title>
        <Description>Per phone discussion and these scenarios..
https://github.com/NuGet/Home/issues/4487
https://github.com/NuGet/Home/issues/4496</Description>
        <CreatedDate>04/02/2017</CreatedDate>
        <ClosedDate>05/02/2017</ClosedDate>
        <Labels>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>819</PullRequestID>
        <IssueID>422</IssueID>
        <Title>AssemblyVersion and FileVersion is not affected by VersionPrefix</Title>
        <Description>I have migrated my .NET Core project to .csproj. The resulting project file contains a `&lt;VersionPrefix&gt;` element. AFAIK it should work that way:

1. `VersionPrefix` is used as a prefix (= 1.2.3 in my .csproj)
2. `VersionSuffix` is used as a suffix (not defined in my project)
3. `Version` is computed as `$(VersionPrefix)-$(VersionSuffix)` if not defined in .csproj
4. `AssemblyVersion` and `FileVersion` is based on `Version`

When I build the project, the `AssemblyVersion` and `FileVersion` are set to 1.0.0 instead of 1.2.3. When I explicitly set `Version` in my .csproj, everything works. There is something wrong.

Am I missing something?</Description>
        <CreatedDate>22/11/2016</CreatedDate>
        <ClosedDate>05/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>819</PullRequestID>
        <IssueID>93</IssueID>
        <Title>VersionPrefix defaults to 1.0.0 regardless of whether Version actually starts with 1.0.0 or not</Title>
        <Description>Today we have in Microsoft.NETCore.Sdk.targets (with one no-op line removed for brevity):

``
</Description>
        <CreatedDate>25/08/2016</CreatedDate>
        <ClosedDate>05/02/2017</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>817</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>jonsequitur</FixedByID>
    <Title>include documentation file when publishing</Title>
    <Description>This adds an item to include documentation files during publish. It addresses issue #795. 

@dsplaisted @nguerrera @piotrpMSFT @livarcocc </Description>
    <CreatedDate>04/02/2017</CreatedDate>
    <ClosedDate>03/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>817</PullRequestID>
        <IssueID>795</IssueID>
        <Title>dotnet publish does not copy the documentation file with csproj</Title>
        <Description>## Steps to reproduce
Have a solution with multiple projects
The main "web" project has the GenerateDocumentationFile set to true

## Expected  behavior
When I run dotnet publish of the main "web" project, I expect that the XML documentation file is copied into the publishing folder. (Note the build will generate the file as it should.)

## Actual behavior
When I run dotnet publish of the main "web" project, it does not copy the XML documentation file to the psublish folder.

## My workaround
My current workaround is to update the csproj of the main web project and manually copy the file:
``

## Environment data
.NET Command Line Tools (1.0.0-rc3-004530)

Product Information:
 Version:            1.0.0-rc3-004530
 Commit SHA-1 hash:  0de3338607

Runtime Environment:
 OS Name:     Windows
 OS Version:  6.3.9600
 OS Platform: Windows
 RID:         win81-x64
 Base Path:   C:\Program Files\dotnet\sdk\1.0.0-rc3-004530

This issue has been copied over from https://github.com/dotnet/cli/issues/5562.</Description>
        <CreatedDate>02/02/2017</CreatedDate>
        <ClosedDate>11/04/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>815</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>333fred</FixedByID>
    <Title>Update the assembly version with every nightly build. Fixes #488.</Title>
    <Description>Fixes #488. Tagging @srivatsn for review.</Description>
    <CreatedDate>04/02/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>815</PullRequestID>
        <IssueID>488</IssueID>
        <Title>Bump tasks assembly and file versions automatically with every nightly build</Title>
        <Description>Currently both are hard-coded to 1.0.0.0.

We keep running in to issues where there is a build-to-build break in the SDK and an msbuild process can't SxS load two SDK task assemblies with the same name.

I think we can bump both with every daily build number. It's a simple fix and since the tasks assembly is not designed to have any exchange types, SxS loading any two different builds should be acceptable.

cc @davkean @rainersigwald @dsplaisted 
</Description>
        <CreatedDate>13/12/2016</CreatedDate>
        <ClosedDate>31/07/2018</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>811</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>'dotnet run' doesn't work on self-contained apps</Title>
    <Description>Fixing the build output of self-contained applications to be runnable.  Also making 'dotnet run' and Visual Studio F5 work on self-contained applications.

This change also adds an option to append the $(RuntimeIdentifier) to the build output, since the output changes between RIDs.  This would be a breaking change, so the option is defaulted to "off".

@davkean - can you check the usage of the `&lt;None&gt;` item.  It is being used because `&lt;ReferenceCopyLocalPaths&gt;` won't let me rename the file (which is needed for the host executable).  These items shouldn't show up in VS since they are added by a Target, right?

Fix #527

/cc @srivatsn 


## Scenario

When a user sets the `&lt;RuntimeIdentifier&gt;` property in their project, or does a build with `dotnet build -r RID`, the build output is not runnable.  When calling `dotnet run` they get errors like:

```
A fatal error was encountered. The library 'hostpolicy.dll' required to execute the application was not found in 'F:\DotNetTest\DependencyTest\bin\Debug\netcoreapp2.0\'.
```

## Bugs

#527 #791 

## Workarounds

Publish the self-contained app, and then you can run it.

## Risk

~The change to the OutputPath is risky this late.  But @nguerrera said he needed this change for some desktop work as well.  This change makes the output consistent with the output for project.json projects when a RuntimeIdentifier was set.~

By default, there is no change to the OutputPath now.

This change only affects self-contained .NET Core apps during build/run and allows run to work.

## Performance Impact

Minimal, a few more files are being copied to the output folder during build of a self-contained app.

## Regression Analysis

This was a regression from project.json-based projects.</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>811</PullRequestID>
        <IssueID>527</IssueID>
        <Title>dotnet build with runtime specified does not create the right output</Title>
        <Description>Moved from https://github.com/dotnet/cli/issues/5039 on behalf of @Fabi, @nguerrera 

----

## Steps to reproduce
1. Install Visual Studio 2017 RC
2. Follow the "Deploying a simple self-contained deployment" part from https://docs.microsoft.com/en-us/dotnet/articles/core/preview3/deploying/ until step 5

## Expected  behavior
After running the dotnet build -r win10-x64 command a folder with the build files (including an .exe file not only dll) should be created at ".\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;"


## Actual behavior
There is no runtime folder with executables generated. That only works with the publish command now.
Before on json based project files it worked fine.

## Environment data
`dotnet --info` output:

``


-----


@nguerrera this is the standalone publish scenario. It should work like this:

## on build
Build produces the portable output as well as a RID-specific output. The RID-specific output contains the portable output + the appropriate RID-specific host for the app. That host still uses deps.json, etc. to load Shared Framework artifacts from the nuget cache

## on publish
The publish output is RID specific. It includes everything from the RID-specific build output + everything from the RID-specific Shared Framework. The publish output can now be zip'd and then deployed to any host with a matching RID.</Description>
        <CreatedDate>17/12/2016</CreatedDate>
        <ClosedDate>04/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>811</PullRequestID>
        <IssueID>527</IssueID>
        <Title>dotnet build with runtime specified does not create the right output</Title>
        <Description>Moved from https://github.com/dotnet/cli/issues/5039 on behalf of @Fabi, @nguerrera 

----

## Steps to reproduce
1. Install Visual Studio 2017 RC
2. Follow the "Deploying a simple self-contained deployment" part from https://docs.microsoft.com/en-us/dotnet/articles/core/preview3/deploying/ until step 5

## Expected  behavior
After running the dotnet build -r win10-x64 command a folder with the build files (including an .exe file not only dll) should be created at ".\bin\Debug\netcoreapp1.0\&lt;runtime_identifier&gt;"


## Actual behavior
There is no runtime folder with executables generated. That only works with the publish command now.
Before on json based project files it worked fine.

## Environment data
`dotnet --info` output:

``


-----


@nguerrera this is the standalone publish scenario. It should work like this:

## on build
Build produces the portable output as well as a RID-specific output. The RID-specific output contains the portable output + the appropriate RID-specific host for the app. That host still uses deps.json, etc. to load Shared Framework artifacts from the nuget cache

## on publish
The publish output is RID specific. It includes everything from the RID-specific build output + everything from the RID-specific Shared Framework. The publish output can now be zip'd and then deployed to any host with a matching RID.</Description>
        <CreatedDate>17/12/2016</CreatedDate>
        <ClosedDate>04/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>811</PullRequestID>
        <IssueID>791</IssueID>
        <Title>'dotnet run' fails for self-contained applications</Title>
        <Description>Using this project on a windows machine:

``

### Notes

When initially designing .NET Core for MSBuild, we wanted the experience that "framework-dependent vs. self-contained was a publish time decision".  That mean that you can take the same .csproj and without modifying it, publish as a "framework-dependent (a.k.a. portable/shared framework)" or a "self-contained" app. In order to support that, a decision was made that `dotnet build` and `dotnet run` were always framework-dependent.

However, this turns out to not be a great decision because there are scenarios where you want to target a .NET Core runtime that you haven't installed on the machine.  In this case, you explicitly choose that you are a self-contained app, and you target the framework version (like a nightly build of Microsoft.NETCore.App) that you want. You still should be able to `dotnet run` your application. The only thing that works today is to `dotnet publish` and then execute the app, which IDEs don't typically do.

To enable this, I think the things that need to be done are:
1. Copy the `hostfxr` and `hostpolicy` assemblies to the output folder
1. (Optional) Copy the `dotnet` executable to the output folder and rename it to $(TargetName)[.exe]
     - If we do this, we also need to change the "Run Information" to point to this executable instead of the `dotnet` on the path.
1. Set the output folder to have the RID in it.
     - This might not be required, but that's how project.json based projects did it.
the `dotnet` muxer.

See https://github.com/dotnet/cli/blob/rel/1.0.0-preview2.1/src/Microsoft.DotNet.Compiler.Common/Executable.cs#L96-L108 for how this worked on project.json based projects.  Specifically the `CoreHost.CopyTo(_runtimeOutputPath, _compilerOptions.OutputName + Constants.ExeSuffix);` part, which does the first two steps above.</Description>
        <CreatedDate>02/02/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>809</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Use case insensitive comparison for determining which packages should be excluded from publishing</Title>
    <Description>Fixes #376</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>809</PullRequestID>
        <IssueID>376</IssueID>
        <Title>&lt;PrivateAssets&gt;All&lt;/PrivateAssets&gt; still puts dll into publish directory</Title>
        <Description>Related to https://github.com/dotnet/cli/issues/2024
Related to https://github.com/dotnet/sdk/issues/42

[r2024.tar.gz](https://github.com/dotnet/sdk/files/582430/r2024.tar.gz)

Repro attached.

In this project NewtonSoft.json is included with the reference:

``

However, publish still puts the dll into the publish directory.

/CC @davidfowl who opened the original issue against CLI</Description>
        <CreatedDate>10/11/2016</CreatedDate>
        <ClosedDate>04/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>806</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update property name for exclude pattern in project folder to match where it's consumed</Title>
    <Description>Fixes #631 

#### Scenario

Build or publish a project using the .NET SDK that has a .vscode, .git, or other folder starting with "." in the project folder.  Without this fix files in these folders that match the right extensions (.json, .cs, etc.) will be included in the project and, in the case of Web SDK projects, the .json files will be included in the publish output.

#### Bug

#631

#### Workarounds

Add the following property to the project file, or otherwise explicitly exclude the unwanted folder from the items:

```xml
&lt;DefaultExcludesInProjectFolder&gt;$(DefaultItemExcludesInProjectFolder);**/.*/**&lt;/DefaultExcludesInProjectFolder&gt;
```

#### Risk

Low

#### Performance Impact

Low

#### Regression Analysis

This was introduced in #630, where I accidentally renamed a property where it was defined, but not where it was consumed.</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>806</PullRequestID>
        <IssueID>631</IssueID>
        <Title>Web project publishes .vscode directory</Title>
        <Description>Since websdk repo is private, opening an issue here..

The glob patterns in sdk/websdk publish folders that should be considered "hidden" like `.vscode`.
This probably also applies to files/folders that one would expect to be hidden.. Maybe every file/folder starting with a dot?

@guardrex also discovered that the `Properties` folder is deployed as well thus deploying publish profiles.

Steps to reproduce:
* `dotnet new -t web1.1`
* `dotnet restore`
* `code .`
* Omnisharp-VSCode asks to add "required assets" &gt; klick "yes"
* `dotnet publish -c Release`
* `ls -la bin/Release/netcoreapp1.1/publish/.vscode/`
``

cc @dsplaisted @mlorbetske </Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>806</PullRequestID>
        <IssueID>631</IssueID>
        <Title>Web project publishes .vscode directory</Title>
        <Description>Since websdk repo is private, opening an issue here..

The glob patterns in sdk/websdk publish folders that should be considered "hidden" like `.vscode`.
This probably also applies to files/folders that one would expect to be hidden.. Maybe every file/folder starting with a dot?

@guardrex also discovered that the `Properties` folder is deployed as well thus deploying publish profiles.

Steps to reproduce:
* `dotnet new -t web1.1`
* `dotnet restore`
* `code .`
* Omnisharp-VSCode asks to add "required assets" &gt; klick "yes"
* `dotnet publish -c Release`
* `ls -la bin/Release/netcoreapp1.1/publish/.vscode/`
``

cc @dsplaisted @mlorbetske </Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>RC3 Known Issue</Label>
          <Label>Urgency-Soon</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>806</PullRequestID>
        <IssueID>630</IssueID>
        <Title>Stop removing items that were included in the project file</Title>
        <Description>Instead, only apply the patterns that used to be called DefaultRemoves to the items that are implicitly included.  If someone adds an include for a file to their project file, we should respect that.

Fixes #623
Fixes #588

The `DefaultRemoves` property was originally used so that when you had wildcard includes in your project file, you wouldn't have to specifically exclude the `bin`, `obj`, etc. folders.  When we switched to implicit includes, I left it in with the idea that it would help you have a cleaner project file if you did want to explicitly see a wildcard include in your project, and it would help protect you from accidentally including items that you "shouldn't" from the output folders.

However, it's become apparent that it comes with two huge downsides:
 - If you actually want items that would match the patterns in `DefaultRemoves`, you will include them in the project file, and that won't work, and you will have absolutely no idea why and there's no good way to debug / figure it out
 - If you do manage to figure out why the items aren't being included, there's no good way to override the behavior to let you include a file.  You have to turn off the `DefaultRemoves` entirely, which then means your implicit globs will suddenly pick up a bunch of files that they shouldn't, unless you jump through even more hoops in your project file.

This PR makes it so that if you put an item in your project file, it will be respected.  The items that will be included implicitly remain the same as before.

This PR also takes the opportunity to remove the `packages` folder from the list of folders that the default includes don't apply to.  It's unclear why this was originally [added in the CLI](https://github.com/dotnet/cli/commit/94bafb17).  @davidfowl [had this to say about it](https://github.com/aspnet/websdk/pull/88/files/621bb3d2a625ceab3b2123b1a11dd69357eb79bd):

&gt; It was likely because of a mix of older packages folder (nuget v2) and xproj. Though that should only have been at the solution level...

Removing this exclusion will make default items in projects with code or other assets in a "packages" folder work as people will expect.

This change will need to be made together with a change to the Web SDK, as now it will be its responsibility to remove these items from its default includes.  I will also submit a PR for that.
</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>14/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Pending Shiproom Approval</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>805</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>jinujoseph</FixedByID>
    <Title>Giving more information on 'No compatiblity target frameowrk' failure</Title>
    <Description>fixes #788 

Message was 
```
C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\Sdks\Microsoft.NET.Sdk\build\Microsoft.NET.Sdk.Common.targets(69,5): error : Project 'c:\users\billhie\documents\visual studio 2017\Projects\WebApplication2\WebApplication2\WebApplication2.csproj' has no target framework compatible with '.NETCoreApp,Version=v1.0'.
Done building project "WebApplication2.csproj" -- FAILED.
```

New Message 

```
4&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\Sdks\Microsoft.NET.Sdk\build\Microsoft.NET.Sdk.Common.targets(69,5): error : Project 'C:\Users\jinuj\documents\visual studio 2017\Projects\WebApplication1\WebApplication1\WebApplication1.csproj' targets '.NETCoreApp,Version=v1.1'. It cannot be referenced by a project that targets '.NETCoreApp,Version=v1.0'.
4&gt;Done building project "WebApplication1.csproj" -- FAILED.
```

@srivatsn @nguerrera </Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>805</PullRequestID>
        <IssueID>788</IssueID>
        <Title>Improve error message when referencing projects fails due to incompaiblity</Title>
        <Description>1. Create a 1.1 NET Core project (there are templates in VS for 1.1 web projects)
2. Add a unit test project - the default template in VS targets NetCore 1.0
3. Add a ref from the test project to the first one.
4. Build

Fails with:

``

Since this is going to be a common situation, we want to improve the error message. 
</Description>
        <CreatedDate>02/02/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>804</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>mavasani</FixedByID>
    <Title>Use TreatWarningsAsErrors instead of WarningsAsErrors for PreserveCom…</Title>
    <Description>…pilationContext targets.

TreatWarningsAsErrors controls warning as error behavior for the entire compilation, while WarningsAsErrors is a string of set of diagnostic IDs that need to be treated as errors.

Fixes #756</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>804</PullRequestID>
        <IssueID>756</IssueID>
        <Title>PreserveCompilationContext targets incorrectly uses WarningsAsErrors</Title>
        <Description>dotnet-migrate (since corrected) and PreserveCompilationContext targets use the property `WarningsAsErrors`. The correct property is `TreatWarningsAsErrors`. PreserveCompilationContext needs to be updated</Description>
        <CreatedDate>30/01/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>797</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Report that a project only has one TFM</Title>
    <Description>Partially fixes dotnet/sdk#739.

The first iteration of cross-targeting support code unconditionally
queried each ProjectReference for the best TFM to build against, and
then explicitly specified that TFM when building the reference. This
caused a race condition when building a set of projects that had a
single-TFM project and another project that had a reference to it. The
entry point (probably .sln) build would build the referenced project
with no TF specified, and then the referencing project would build it
with an explicit TF specified. These two builds appeared different to
the MSBuild engine (because they had different sets of global
properties) and so were both executed, resulting in a race condition.

The fix is in two parts:
* Allow a project to report back through GetTargetFrameworkProperties
that it only has one TF to build.
* When a project reports that it has only one TF to build, issue its
build request without specifying any TF. (https://github.com/Microsoft/msbuild/pull/1667)

This commit is the former.</Description>
    <CreatedDate>02/02/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>797</PullRequestID>
        <IssueID>739</IssueID>
        <Title>Multi-proc build of a .sln file is 'The process cannot access the file because it is being used by another process.'</Title>
        <Description>In the CLI repo, we have a Test.sln file which we `dotnet build`.  However, we are seeing random failures that look like the following:

``</Description>
        <CreatedDate>26/01/2017</CreatedDate>
        <ClosedDate>04/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>781</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Exclude OutputPath and IntermediateOutputPath from default item includes</Title>
    <Description>Fixes #627</Description>
    <CreatedDate>01/02/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>781</PullRequestID>
        <IssueID>627</IssueID>
        <Title>Changing the output path causes it's contents to be added to your project </Title>
        <Description>1. File -&gt; New Console Application (.NET Core)
2. Right project and choose Properties
3. Choose Build tab, in Output Path enter "Bar
4. Build

Expected: The project tree not to change
Actual: The output is shown in the tree:

![image](https://cloud.githubusercontent.com/assets/1103906/21834787/212fafe2-d80c-11e6-866a-e1340ead7789.png)

</Description>
        <CreatedDate>11/01/2017</CreatedDate>
        <ClosedDate>01/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>772</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Generate .swr file dynamically based on files in package layout</Title>
    <Description>#762 broke the VsixV3 generation (which only runs on Microbuild), as the .swr file was out of sync with the files deployed to the output directory.

This change should fix that by dynamically generating an .swr file based on the files that are actually in the packages layout folder.

Variable substitutions occur when the .swr file is generated, so it has the version "hard-coded" based on the `Version` property from when Microsoft.NET.Nuget.proj is built, and it has absolute paths to the files instead of paths relative to the `OutputPath` property.  This seems like it should be fine, but I don't know much about .swr files.</Description>
    <CreatedDate>01/02/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>772</PullRequestID>
        <IssueID>762</IssueID>
        <Title>Multitarget SDK tasks to .NET 4.6 as well as .NET Standard, and load different versions of NewtonSoft.Json side-by-side</Title>
        <Description>Fixes #745 

Prior to this PR, we were compiling our tasks once for .NET Standard.  We ship the dependencies of our tasks together with the tasks, and these dependencies include the NuGet API DLLs as well as Microsoft.Extensions.DependencyModel.

The NuGet DLLs are multitargeted to .NET Framework and .NET Standard.  The .NET Standard versions of the DLLs depend on NewtonSoft.Json 9.0.1, while the .NET Framework versions depend on version 6.0.4.  Using the .NET Standard versions of the NuGet DLLs on .NET Framework ended up causing problems, as the .NET Framework versions of those are shipped together with the NuGet restore tasks.  So if an SDK task ran first, it would load the .NET Standard version of a NuGet DLL from the SDK task folder, while if the NuGet restore task ran first, it would load the .NET Framework version of NuGet DLLs from the NuGet tasks folder.  The SDK task would not load all the NuGet DLLs, however, so if an SDK task ran first, there would be a mix of .NET Standard and .NET Framework targeted NuGet DLLs, which in turn depended on different versions of NewtonSoft.Json.  When they tried to exchange types from NewtonSoft.Json, it would fail with the message `Method not found: 'NuGet.RuntimeModel.RuntimeGraph NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(Newtonsoft.Json.Linq.JToken)'.`

We mitigated this in #699 by avoiding running any of our tasks before the NuGet restore task runs.  However, if a non-CPS project references a .NET SDK project, then the build can run in-process in Visual Studio, and load the SDK tasks into VS.  Depending on timing, this can happen before the .NET Framework versions of the NuGet DLLs have been otherwise loaded, resulting in the same error: #745 

This PR attempts to provide a "real" fix to the problem, by switching the build of the tasks assembly to multitargeting .NET Standard 1.3 and .NET Framework 4.6, and to ship the .NET Framework versions of the NuGet DLLs with the .NET Framework version of the SDK tasks.  This way, it won't matter where the NuGet DLLs are loaded from first, as both places will have the exact same DLLs.

However, switching to the .NET Framework versions of the NuGet DLLs means that we have the NuGet DLLs which depend on version 6.0.4 of NewtonSoft.Json, as well as Microsoft.Extensions.DependencyModel which still depends on version 9.0.1.  Generally in targeting .NET Framework you would use binding redirects to unify different versions of diamond dependencies to a single version.  However, binding redirects are not supported for MSBuild tasks.  To resolve this issue, this PR includes NewtonSoft.Json in a subfolder, and uses `Assembly.LoadFrom` to load that DLL before any NuGet APIs are used.  Thus, when the framework tries to bind the references from the NuGet DLLs to NewtonSoft.Json 6.0.4, it will use the already-loaded 6.0.4 version, instead of trying to load the 9.0.1 version that is in the base tasks folder and failing due to a version mismatch.  So the 9.0.1 and 6.0.4 versions will load side-by-side, and everything should work as long as we don't try to exchange types between the two.

With this change, we are also relying on NuGet and the build process to copy the dependencies of the task assembly to the net46 output folder, and including them in the tools\net46 folder of the NuGet package, instead of explicitly listing each DLL to be copied in Microsoft.NET.Sdk.Nuget.targets.</Description>
        <CreatedDate>31/01/2017</CreatedDate>
        <ClosedDate>31/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Pending Shiproom Approval</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>768</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add runtimeconfig.json to BuiltProjectOutputGroupOutput</Title>
    <Description>Adds runtimeconfig.json to BuiltProjectOutputGroupOutput item. This will cause it to be included in the NuGet package if an application project is packed.

Fixes #472 </Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>768</PullRequestID>
        <IssueID>472</IssueID>
        <Title>runtimeconfig.json file is not added to BuiltProjectOutputGroupOutput in inner build</Title>
        <Description>For any app targeting netcoreapp1.0 , a runtimeconfig.json file is generated in the bin folder, but pack fails to include it in the nupkg because this is not included in the list of files given by BuiltProjectOutputGroup target.

Talked to @rainersigwald about this, the bug lies in 
https://github.com/dotnet/sdk/blob/master/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.Sdk.targets#L119-L128 


This issue is being tracked on the NuGet side by : https://github.com/NuGet/Home/issues/3878

CLI : https://github.com/dotnet/cli/issues/2432</Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>01/02/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>In PR</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>763</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Continue on Error in ResolvePackageDependencies</Title>
    <Description>**Customer scenario**

A customer with one project containing a broken dependency may observe all the other projects in the solution have unresolved NuGet packages. Specifically, projects which transitively depend on the broken project contain unresolved package references after reloading the solution. This experience is confusing for users since it suggests all their projects are broken, when in fact just one is broken.

**Bugs this fixes:**

#717 

**Workarounds, if any**

Fix the broken project reference, assuming user can root cause the problem

**Risk**

Low

**Performance impact**

None

**Is this a regression from a previous update?**

No

**Root cause analysis:**

This occurs because the broken project reference produces an error upstream in all the dependent projects, and this error forces the ResolvePackageDependencies to terminate prematurely. The fix is to allow the task to continue when it encounters errors since the errors do not prevent the task from performing its duties including emitting resolved package references.

**How was the bug found?**

Dogfooding

/cc @nguerrera @dsplaisted @srivatsn @rainersigwald 
</Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>763</PullRequestID>
        <IssueID>717</IssueID>
        <Title>resolved nuget packages are not sent, when csproj depends on another csproj with some broken reference</Title>
        <Description>1. Open this solution \\vwdbuild01\Temp\antonpis\repro\MultipleIssues.zip and wait for all restores to happen if any
2. see WebAppllication1 has yellow nuget packages.

Actual:

What is happening is dependencies tree does not receive resolved package references for WebApplication1 at all. Assets file contains them. Notice, that if i remove a reference on ConsoleApp1 , everything starts to work and we receive resolved references for WebApplication1. What makes ConsoleApp1 special is that it has some unknown project reference "MyProject1" and some unknown assembly references. So somehow it affects data that is sent from DT build. 

Expected behavior would be to send resolved data for what ever was successfully resolved and unresolved data for what is unresolved. Otherwise whole tree is yellow and user would not know what dependency was not resolved.


</Description>
        <CreatedDate>24/01/2017</CreatedDate>
        <ClosedDate>31/01/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
          <Label>resolution-fixed</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>762</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Multitarget SDK tasks to .NET 4.6 as well as .NET Standard, and load different versions of NewtonSoft.Json side-by-side</Title>
    <Description>Fixes #745 

Prior to this PR, we were compiling our tasks once for .NET Standard.  We ship the dependencies of our tasks together with the tasks, and these dependencies include the NuGet API DLLs as well as Microsoft.Extensions.DependencyModel.

The NuGet DLLs are multitargeted to .NET Framework and .NET Standard.  The .NET Standard versions of the DLLs depend on NewtonSoft.Json 9.0.1, while the .NET Framework versions depend on version 6.0.4.  Using the .NET Standard versions of the NuGet DLLs on .NET Framework ended up causing problems, as the .NET Framework versions of those are shipped together with the NuGet restore tasks.  So if an SDK task ran first, it would load the .NET Standard version of a NuGet DLL from the SDK task folder, while if the NuGet restore task ran first, it would load the .NET Framework version of NuGet DLLs from the NuGet tasks folder.  The SDK task would not load all the NuGet DLLs, however, so if an SDK task ran first, there would be a mix of .NET Standard and .NET Framework targeted NuGet DLLs, which in turn depended on different versions of NewtonSoft.Json.  When they tried to exchange types from NewtonSoft.Json, it would fail with the message `Method not found: 'NuGet.RuntimeModel.RuntimeGraph NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(Newtonsoft.Json.Linq.JToken)'.`

We mitigated this in #699 by avoiding running any of our tasks before the NuGet restore task runs.  However, if a non-CPS project references a .NET SDK project, then the build can run in-process in Visual Studio, and load the SDK tasks into VS.  Depending on timing, this can happen before the .NET Framework versions of the NuGet DLLs have been otherwise loaded, resulting in the same error: #745 

This PR attempts to provide a "real" fix to the problem, by switching the build of the tasks assembly to multitargeting .NET Standard 1.3 and .NET Framework 4.6, and to ship the .NET Framework versions of the NuGet DLLs with the .NET Framework version of the SDK tasks.  This way, it won't matter where the NuGet DLLs are loaded from first, as both places will have the exact same DLLs.

However, switching to the .NET Framework versions of the NuGet DLLs means that we have the NuGet DLLs which depend on version 6.0.4 of NewtonSoft.Json, as well as Microsoft.Extensions.DependencyModel which still depends on version 9.0.1.  Generally in targeting .NET Framework you would use binding redirects to unify different versions of diamond dependencies to a single version.  However, binding redirects are not supported for MSBuild tasks.  To resolve this issue, this PR includes NewtonSoft.Json in a subfolder, and uses `Assembly.LoadFrom` to load that DLL before any NuGet APIs are used.  Thus, when the framework tries to bind the references from the NuGet DLLs to NewtonSoft.Json 6.0.4, it will use the already-loaded 6.0.4 version, instead of trying to load the 9.0.1 version that is in the base tasks folder and failing due to a version mismatch.  So the 9.0.1 and 6.0.4 versions will load side-by-side, and everything should work as long as we don't try to exchange types between the two.

With this change, we are also relying on NuGet and the build process to copy the dependencies of the task assembly to the net46 output folder, and including them in the tools\net46 folder of the NuGet package, instead of explicitly listing each DLL to be copied in Microsoft.NET.Sdk.Nuget.targets.</Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>762</PullRequestID>
        <IssueID>745</IssueID>
        <Title>Don't load assemblies of the wrong version into devenv.exe</Title>
        <Description>Causes:
Error occurred while restoring NuGet packages: Method not found: 'NuGet.RuntimeModel.RuntimeGraph NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(Newtonsoft.Json.Linq.JToken)'.

Was first recorded in NuGet repo: https://github.com/NuGet/Home/issues/4272

Fix for RC3 was taken: https://github.com/dotnet/sdk/pull/699

@onovotny just said on that issue, that it is still reproing with RC3.

??</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>31/01/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>762</PullRequestID>
        <IssueID>699</IssueID>
        <Title>Don't run CheckForImplicitPackageReferenceOverrides before NuGet restore</Title>
        <Description>This should help avoid assembly loading ordering issues, where the some of the (.NET Standard) NuGet assemblies were being loaded from the .NET SDK instead of the (.NET Framework) versions from the NuGet tasks</Description>
        <CreatedDate>20/01/2017</CreatedDate>
        <ClosedDate>23/01/2017</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
          <Label>Pending Shiproom Approval</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>762</PullRequestID>
        <IssueID>745</IssueID>
        <Title>Don't load assemblies of the wrong version into devenv.exe</Title>
        <Description>Causes:
Error occurred while restoring NuGet packages: Method not found: 'NuGet.RuntimeModel.RuntimeGraph NuGet.RuntimeModel.JsonRuntimeFormat.ReadRuntimeGraph(Newtonsoft.Json.Linq.JToken)'.

Was first recorded in NuGet repo: https://github.com/NuGet/Home/issues/4272

Fix for RC3 was taken: https://github.com/dotnet/sdk/pull/699

@onovotny just said on that issue, that it is still reproing with RC3.

??</Description>
        <CreatedDate>27/01/2017</CreatedDate>
        <ClosedDate>31/01/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>release blocking</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>565</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Implicitly define compilation constants for any Configuration</Title>
    <Description>Fixes #521</Description>
    <CreatedDate>29/12/2016</CreatedDate>
    <ClosedDate>04/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>565</PullRequestID>
        <IssueID>521</IssueID>
        <Title>Emit $(DefineConstants);RELEASE for release configuration.</Title>
        <Description>Today, as part of migration we have to emit the following: 

``

We do that because project.json had this defineconstants in it, so, to keep the behavior the same for migrated projects, we have to emit it as well.

Would it be possible to emit this in SDK itself?

cc @dsplaisted 
</Description>
        <CreatedDate>16/12/2016</CreatedDate>
        <ClosedDate>04/01/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>561</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add conditions for implicit framework references for .NET 3.5 and below</Title>
    <Description>Fixes #532 

There aren't any tests for this, as we run all our tests using the .NET CLI version of MSBuild, which doesn't support targeting .NET 3.5 and lower (as there are no reference assemblies for these frameworks).</Description>
    <CreatedDate>29/12/2016</CreatedDate>
    <ClosedDate>04/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>561</PullRequestID>
        <IssueID>532</IssueID>
        <Title>Targeting net20 results in broken reference warnings</Title>
        <Description>_From @jnm2 on December 17, 2016 17:54_

(I'm multitargeting `net20` and `netstandard1.3` but this happens also when just targeting `net20`.)

Under Dependencies &gt; Assemblies I have `System`, `System.Core`, `System.Data`, `System.Drawing`, `System.Runtime.Serialization`, `System.Xml` and `System.Xml.Linq`. Of these I only actually need `System`, so ordinarily I'd delete the rest. However deleting is impossible since they are defined outside my .csproj.

Not being able to delete doesn't bother me too much, except that I get build warnings for `System.Core`, `System.Runtime.Serialization` and `System.Xml.Linq` due to targeting `net20`.

If you are going to require mandatory assembly references if one of the targets is .NET Framework, I'd expect you to detect which references make sense to add given the framework version. (Personally I'd be even more happy with no mandatory references and having to list them in the .csproj so I can delete all of them except `System`.)

_Copied from original issue: dotnet/roslyn-project-system#987_</Description>
        <CreatedDate>18/12/2016</CreatedDate>
        <ClosedDate>04/01/2017</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>558</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>srivatsn</FixedByID>
    <Title>Revert "Change encoding of template files from us-ascii to utf-8"</Title>
    <Description>Reverts dotnet/sdk#465 since it broke the signed build.</Description>
    <CreatedDate>28/12/2016</CreatedDate>
    <ClosedDate>28/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>558</PullRequestID>
        <IssueID>465</IssueID>
        <Title>Change encoding of template files from us-ascii to utf-8</Title>
        <Description>- To address Microsoft/vstest#252

/cc @codito @singhsarab @srivatsn </Description>
        <CreatedDate>06/12/2016</CreatedDate>
        <ClosedDate>28/12/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>539</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Import common targets if LanguageTargets property isn't set.</Title>
    <Description>This will allow restore to succeed.  Fixes #448. Fixes #373 

Rather than generating an error (as specified in #448), this PR imports the common targets if the `LanguageTargets` property isn't set.  This means that restore can succeed even if the language targets aren't otherwise set, which means that F# or another language could be provided solely as a NuGet package instead of an MSBuild SDK.

@enricosada How does this look to you?  Once it is possible to have third party SDKs (see https://github.com/Microsoft/msbuild/issues/1493), you may still prefer to use an SDK for F# over a NuGet package.  It would make the project files more succinct and might avoid the project showing up differently in solution explorer when you create or open a project before the restore completes.</Description>
    <CreatedDate>20/12/2016</CreatedDate>
    <ClosedDate>28/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>539</PullRequestID>
        <IssueID>448</IssueID>
        <Title>Generate an error message if LanguageTargets property is not set and cannot be inferred</Title>
        <Description>`Sdk.targets` will import the CSharp or VisualBasic targets files depending on whether the project file extension is `.csproj` or `.vbproj`.  The `LanguageTargets` property can also be set to specify the targets file to import.

If `LanguageTargets` isn't set and the project file extension is neither `.csproj` nor `.vbproj`, then the build should fail with a helpful error.  This could happen if someone didn't specify the F# SDK for an `.fsproj`, for example.</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>28/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>539</PullRequestID>
        <IssueID>373</IssueID>
        <Title>Extension point for languages</Title>
        <Description>To have an awesome language agnostic experience it's nice if the sdk (like previous `preview2`) has a clean extension point to add additional languages

Atm works ( ref f# [examples](https://github.com/dotnet/netcorecli-fsc/tree/master/examples/preview3) and [tests suite](https://github.com/dotnet/netcorecli-fsc/tree/master/test-msbuild) ), but can be improved a bit

An example the [fsharp with preview3](https://github.com/dotnet/netcorecli-fsc/blob/99e22f5413fa0dc7ea16bf92a35fb0048fa99207/examples/preview3/console/ExampleConsoleApp.fsproj#L26-L28)

So:

1. Add a `PackageReference`  to a lang sdk package who contains msbuild target files (example [FSharp.NET.Sdk](https://github.com/dotnet/netcorecli-fsc/tree/master/src/FSharp.NET.Sdk) ) who are auto imported
     - The targets file contains a:
          - `CoreCompile` task =&gt; ok, thats usually invoke the compiler to compile
          - `CreateManifestResourceNames` task =&gt; why?
2. Import at the end `$(MSBuildToolsPath)\Microsoft.Common.targets` (instead of `Microsoft.CSharp.targets`)

That's ok and works, but with some issues:

- I cannot directly include `Microsoft.Common.targets` inside my target files, because at the first `dotnet restore` doesnt exists, so restore doesnt work (`Common` imports nuget restore target somewhere).
- I think is important to be able to import `Microsoft.Common.targets` inside custom language targets, for example to be able to replicate the .net framework build script (so wildcard include before and after `.Common` import). If i put `.Common` inside the target file is an authoring error because is included two times (on `dotnet restore` is ok, but after that is included two times)
- I can specify to import the target inside nugetpackage at the end of project file, but is annoying atm because i need to do that starting from $NugetPackageCacheRoot directory, so that's going to include version of package. Also doesnt work at first `dotnet restore`, because doesnt exists yet, so i need to conditionally include `Common` anyway

Best experience from project:

- Just include a `PackageReference` with custom targets like `CoreCompile` (compiler can be a dotnet sdk tool :love:)
- No need to include `Microsoft.Common.targets` target at the end, maybe another target who will invoke the auto-imported lang target.

@nguerrera you have some ideas about how to do the extensibility changes?

/cc @piotrpMSFT @livarcocc @blackdwarf 
/cc @cartermp @KevinRansom @cloudRoutine for F#


Moved from https://github.com/dotnet/cli/issues/4669 on behalf of @enricosada</Description>
        <CreatedDate>10/11/2016</CreatedDate>
        <ClosedDate>28/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>539</PullRequestID>
        <IssueID>448</IssueID>
        <Title>Generate an error message if LanguageTargets property is not set and cannot be inferred</Title>
        <Description>`Sdk.targets` will import the CSharp or VisualBasic targets files depending on whether the project file extension is `.csproj` or `.vbproj`.  The `LanguageTargets` property can also be set to specify the targets file to import.

If `LanguageTargets` isn't set and the project file extension is neither `.csproj` nor `.vbproj`, then the build should fail with a helpful error.  This could happen if someone didn't specify the F# SDK for an `.fsproj`, for example.</Description>
        <CreatedDate>02/12/2016</CreatedDate>
        <ClosedDate>28/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>510</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>jinujoseph</FixedByID>
    <Title>Adding ClassLibrary (.NET Core) and Creating new VSIX for ClassLibrary (.NET Standard)</Title>
    <Description>fixes #441
@srivatsn @dsplaisted </Description>
    <CreatedDate>16/12/2016</CreatedDate>
    <ClosedDate>20/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>510</PullRequestID>
        <IssueID>441</IssueID>
        <Title>Add new project template for "Class Library (.NET Core)"</Title>
        <Description>@terrajobst Are there any other template changes besides this that we need?</Description>
        <CreatedDate>30/11/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>507</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Respect signing options in satellite assembly generation</Title>
    <Description>Fix #499 

I've been a bit opportunistic about cramming the test coverage in to an existing test, but I need this to be checked in ASAP so that I can actually have a "stage 0" SDK with which we can build production satellite assemblies for CLI and SDK.

@srivatsn @dsplaisted </Description>
    <CreatedDate>15/12/2016</CreatedDate>
    <ClosedDate>16/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>507</PullRequestID>
        <IssueID>499</IssueID>
        <Title>.NET Core satellite assembly generation does not support signing</Title>
        <Description>We replace the AL.exe based satellite assembly generation with our own Roslyn-based emit, but we don't propagate the signing options.</Description>
        <CreatedDate>14/12/2016</CreatedDate>
        <ClosedDate>16/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>506</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Add Diagnostic Messages Infrastructure</Title>
    <Description>Add plumbing to get diagnostic messages from SDK tasks to console out put, VS Error List, and VS dependency node in solution explorer.

Part of #26

### Summary
- This is similar to the [diagnostic message APIs](https://github.com/dotnet/cli/blob/6fcbefa4f7a0016a68d3cda52779298a5cd20837/src/Microsoft.DotNet.ProjectJsonMigration/Microsoft.DotNet.Internal.ProjectModel/DiagnosticMessage.cs) in the CLI
- Uses MSBuild to log warnings and errors
- Creates `&lt;DiagnosticMessages&gt;` items that can be processed downstream. Right now the only downstream task is `PreprocessPackageDependenciesDesignTime` which I’ve updated to display relevant diagnostics in the dependency node.

![image](https://cloud.githubusercontent.com/assets/7732033/21242090/7efbd0ce-c2c7-11e6-8802-86596c4db3f9.png)

Here is an overview of the design:

1. I added a `DiagnosticMessages` property to the `TaskBase` class. 

```csharp
        [Output]
        public ITaskItem[] DiagnosticMessages
        {
            get { return _diagnostics.GetDiagnosticMessages(); }
        }
```

This means any task in our SDK can emit `&lt;DiagnosticMessages&gt;`. I use this approach because the SDK distributes functionality over many small tasks, so relevant diagnostics may come from many places. 

2. The base class also has a `DiagnosticsHelper` that contains overloaded Add methods. (Alternatively, we could add another base class to the hierarchy.) 

A task can emit a diagnostic by calling `Diagnostics.Add(...);`
This does two things:
- Add the diagnostic to a collection of `&lt;DiagnosticMessages&gt;`.
- If severity is warning or error, log it to MSBuild. We are logging here for convenience. Alternatively, we could let some downstream task aggregate all the diagnostics and log them.

Targets that call the task should add DiagnosticMessages to the output list:
```xml
	&lt;Output TaskParameter="DiagnosticMessages" ItemName="DiagnosticMessages" /&gt;
```

And add themselves to a property that indicates they emit diagnostics so downstream callers can DependsOnTargets them:
```xml
  &lt;PropertyGroup&gt;
    &lt;EmitsDiagnosticMessages&gt;
      RunResolvePackageDependencies
    &lt;/EmitsDiagnosticMessages&gt;
  &lt;/PropertyGroup&gt;
```

3. Downstream tasks DependsOnTargets `EmitsDiagnosticMessages`. E.g.
```xml    
&lt;Target Name="ResolvePackageDependenciesDesignTime" DependsOnTargets="$(EmitsDiagnosticMessages)"&gt;
```

Right now the only target that does this is `ResolvePackageDependenciesDesignTime`. It only considers diagnostic messages that have a `ParentTarget` and `ParentPackage` (i.e. diagnostics that appear in the dependencies node hierarchy). I have not made any changes to project system to recognize diagnostic messages, so they appear as Unknown

Still Pending:
- [x] Support messages on the TargetFramework Node
- [x] Update tests, particularly for `PreprocessPackageDependenciesDesignTime`, which currently fail the build</Description>
    <CreatedDate>15/12/2016</CreatedDate>
    <ClosedDate>05/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>506</PullRequestID>
        <IssueID>26</IssueID>
        <Title>Provide Diagnostic Items as part of Package Dependency Resolution task</Title>
        <Description>Diagnostics. In some cases when your task can detect error or warning for some packages, it should send diagnostics associated with that package. For example:
- Package is unresolved, we used to have an error 
- Version was unified , we used to have a warning

Here is a full list of diagnostics we had (not all of them are applicable to lock file): https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.ProjectModel/ErrorCodes.NuGet.cs 
- [ ] Diagnostics should be another item type and following your data schema we should have  new collections DiagnosticsDefinitions, and DiagnosticsDependencies, which would associate diagnostic messages with packages. ItemSpec could be TFM/package/version/&lt;diagnostic-code&gt;, with metadata “Message” and “Type” (error or warning)
- [ ] Each package might have multiple diagnostics at the same time: errors and warnings.
- [ ] Diagnostics will be displayed under package in the tree
- [ ] Also diagnostics should be displayed in the error list as Intellisense errors. I am not sure if Dependencies Tree should be the one pushing them to error list or not, but I can do that too.
- [ ] It might not be a pri 0 workitem to make diagnostics work right now, but we at least need a schema ready , just return empty for now. I would already made Tree to be aware or them.
</Description>
        <CreatedDate>08/08/2016</CreatedDate>
        <ClosedDate>30/06/2017</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
          <Label>Urgency-Soon</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>494</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix handling of runtimeconfig files in incremental builds</Title>
    <Description>Fixes #471</Description>
    <CreatedDate>14/12/2016</CreatedDate>
    <ClosedDate>14/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>494</PullRequestID>
        <IssueID>471</IssueID>
        <Title>Incremental build deletes *.runtimeconfig.*.json if there is a runtimeconfig.template.json in the project</Title>
        <Description>The issue is that the fix made for deps.json (https://github.com/dotnet/sdk/pull/424) was not made for runtimeconfig.json.

This causes every other F5 of a .NET Core App that has a runtimconfig.template.json to fail.

It turns out that the issue is less common for runtimeconfig.json because we have and Inputs=runtimeconfig.template.json which causes the task to run always if the file does not exist (and it commonly doesn't). However, if the file does exist then we get the same bad behavior for runtimeconfig.json that was seen with deps.json.

When fixing this, we should also:

* Make sure to actually skip the generation if it's up to date but there is no template file
* Audit all other uses of FileWrites for other possible latent issues here. </Description>
        <CreatedDate>09/12/2016</CreatedDate>
        <ClosedDate>21/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>489</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Add Framework Assemblies from project assets file to compiler references</Title>
    <Description>Add Framework Assemblies raised from project assets file to compiler references. Previously, we were not doing anything with this information.

Fixes #365 and #409. Note that the scenario in #409 is already addressed by [implicit framework references](https://github.com/dotnet/sdk/blob/0908e3556df08d9ba308291b4d9fe4fb2154c0fc/src/Tasks/Microsoft.NET.Build.Tasks/build/Microsoft.NET.Sdk.BeforeCommon.targets#L79) because the scenario only relies on 'System'.

To workaround a failure in a preexisting test due to https://github.com/Microsoft/msbuild/issues/1345, I added the ability to disable the new targets but they are on by default.</Description>
    <CreatedDate>13/12/2016</CreatedDate>
    <ClosedDate>20/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>489</PullRequestID>
        <IssueID>365</IssueID>
        <Title>Transitive package framework assembly references don't get included in build.</Title>
        <Description>Trying to utilize a transitive package framework assembly reference results in build errors. From the looks of it, the transitive framework assembly references are not passed over to csc but are included in the restore file.

Note: This used to work in project.json land.

See the simple repro here: 
[FrameworkAssemblyRepro.zip](https://github.com/dotnet/sdk/files/579575/FrameworkAssemblyRepro.zip)

/cc @barrytang @Eilon </Description>
        <CreatedDate>08/11/2016</CreatedDate>
        <ClosedDate>20/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>489</PullRequestID>
        <IssueID>409</IssueID>
        <Title>frameworkAssemblies aren't being hoisted into Reference nodes</Title>
        <Description>Make a new class library and convert the target framework to net45.

``

Notice compile and runtime have `_._`, that's because the implementation has a **frameworkAssembly** with the actual implementation, in this case **System**. This is broken on new .NET Core projects. The task/target that converts the asset file to msbuild items doesn't seem to take **frameworkAssemblies** into account.


</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>22/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>489</PullRequestID>
        <IssueID>409</IssueID>
        <Title>frameworkAssemblies aren't being hoisted into Reference nodes</Title>
        <Description>Make a new class library and convert the target framework to net45.

``

Notice compile and runtime have `_._`, that's because the implementation has a **frameworkAssembly** with the actual implementation, in this case **System**. This is broken on new .NET Core projects. The task/target that converts the asset file to msbuild items doesn't seem to take **frameworkAssemblies** into account.


</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>22/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>478</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Raise Transitive Project References to MSBuild elements</Title>
    <Description>Raise closure of Transitive Project References to msbuild as `ProjectReference` elements. This closure is generated by NuGet in the assets file.

Fixes #200 
See https://github.com/dotnet/roslyn-project-system/issues/199#issuecomment-261368911 for details on P2P plan.</Description>
    <CreatedDate>12/12/2016</CreatedDate>
    <ClosedDate>21/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>478</PullRequestID>
        <IssueID>200</IssueID>
        <Title>P2P references should be transitive</Title>
        <Description>Example: Consider the below dependency chain
ProjectA-&gt; ProjectB-&gt;ProjectC

Here ProjectA depends on ProjectC but build fails with error

`C:\Users\sridhper\.nuget\packages\microsoft.netcore.sdk\1.0.0-alpha-20160923-4\build\netstandard1.0\Microsoft.PackageDependencyResolution.targets(142,5): error : Unexpected Dependency D:\github\tryout\TestAppDependencyGraph \ProjectC\ProjectC.csproj with no version number [D:\github\tryout\TestAppDependencyGraph\ProjectA\ProjectA.csproj]`

Point of failure is [here](https://github.com/dotnet/sdk/blob/2d2aa82bea8f923571a185fe31434e73e4ddcf13/src/Tasks/Microsoft.NETCore.Build.Tasks/ResolvePackageDependencies.cs#L345)

cc @eerhardt 
</Description>
        <CreatedDate>01/10/2016</CreatedDate>
        <ClosedDate>21/12/2016</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>468</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Move Compile and EmbeddedResource item globs to Sdk .props file instead of project templates</Title>
    <Description>This matches the changes to the web templates and Sdk from aspnet/websdk#74 and aspnet/Templates#735.

EDIT: I've updated this PR based on our design discussion around this.  It works like this:

- `EnableDefaultItems` defaults to `true`.  If a project sets it to false, then all the default item globs will be disabled
- `EnableDefaultCompileItems`, `EnableDefaultEmbeddedResourceItems`, and `EnableDefaultContentItems` can control whether the default globs are used for each item type.  The first two default to `true`, while it is TBD if the one for `Content` items should default to `true` for non-Web projects
- If the default globs for `Compile` and `EmbeddedResource` are used, then those globs are also removed from `Content`.  This expresses this in a way that the tooling understands.
  - ~~The `.targets` file also removes them via an item list reference, ie: `&lt;Content Remove="@(Compile)" /&gt;`.  This should make sure that the build behavior is still correct if the globs are customized in complicated ways that we can't handle otherwise.  In these cases, the IDE may add unnecessary elements to the project file when you edit the project contents from the UI.  This seems like an acceptable trade-off.~~
  - Testing revealed that having patterns like `&lt;Content Remove="@(Compile)" /&gt;` in the targets caused errors when trying to change Build action of files (for example from Compile to Content): "One or more values are invalid. Cannot add 'Class1.cs' to the project, because the path is explicitly excluded from the project".  So I've removed those.
- Items in the BaseOutputPath, BaseIntermediateOutputPath, and that match various patterns that should always be ignored (*.user, *.*proj, etc), are removed in the targets files whether the default globs are enabled or not.  You can disable this separately by setting `DisableDefaultRemoves` to `true`.

Remaining work items:

- [x] Figure out whether we should enable the default Content glob for all projects or just for Web projects.  Right now the default value is set to false, and the Web SDK can turn it on by setting `&lt;EnableDefaultContentItems&gt;true&lt;/EnableDefaultContentItems&gt;`
  - Resolved by using `None` items to show all relevant files in the .NET SDK
- [x] Figure out how to handle *.config files that shouldn't be published directly, such as app.config, or web.$(Configuration).config
  - This will need to be handled by the Web SDK, since it's going to be the one that would be including these files as `Content` items with `CopyToPublishDirectory` set to `PreserveNewest`.
- [ ] Figure out why the project.json tooling was excluding the packages folder from globs by default, and if we still need to do that
- [x] Add more tests
- [x] Test behavior in IDE
- [x] Remove the logic that would go in the Web SDK from the .NET SDK, and add it to the Web SDK.</Description>
    <CreatedDate>07/12/2016</CreatedDate>
    <ClosedDate>30/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>468</PullRequestID>
        <IssueID>74</IssueID>
        <Title>Revert "DocumentationFile default"</Title>
        <Description>Reverts dotnet/sdk#68
</Description>
        <CreatedDate>20/08/2016</CreatedDate>
        <ClosedDate>20/08/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>468</PullRequestID>
        <IssueID>735</IssueID>
        <Title>.NET Core 1.1.0 - SDK 1.0.0 Preview 2.1-003177 Setup Failed</Title>
        <Description>Greetings.

I'm trying to install .NET Core 1.1 on clean Windows 10, with latest VS 2017 RC installed. Regardless of whether the VS 2017 module ".NET Core and Docker (Preview)" is installed, the .NET Core 1.1.0 SDK still fails to install.
The error message is as follows

0x80070666 - Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.

And the error log is

&gt; [1D38:1498][2017-01-26T17:58:48]i001: Burn v3.10.2.2516, Windows v10.0 (Build 14393: Service Pack 0), path: C:\Users\cltsa\AppData\Local\Temp\{A172FBB3-21A6-43E3-9006-E43CEED43AA3}\.cr\dotnet-dev-win-x64.1.0.0-preview2-1-003177.exe
[1D38:1498][2017-01-26T17:58:48]i000: Initializing string variable 'DOTNETHOME' to value '[ProgramFiles6432Folder]dotnet'
[1D38:1498][2017-01-26T17:58:48]i000: Initializing string variable 'BUNDLEMONIKER' to value 'Microsoft .NET Core 1.1.0 - SDK 1.0.0 Preview 2.1-003177'
[1D38:1498][2017-01-26T17:58:48]i009: Command Line: '-burn.clean.room=C:\Users\cltsa\Downloads\dotnet-dev-win-x64.1.0.0-preview2-1-003177.exe'
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'WixBundleOriginalSource' to value 'C:\Users\cltsa\Downloads\dotnet-dev-win-x64.1.0.0-preview2-1-003177.exe'
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'WixBundleOriginalSourceFolder' to value 'C:\Users\cltsa\Downloads\'
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'WixBundleLog' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848.log'
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'WixBundleName' to value 'Microsoft .NET Core 1.1.0 - SDK 1.0.0 Preview 2.1-003177 (x64)'
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'WixBundleManufacturer' to value 'Microsoft Corporation'
[1D38:29F0][2017-01-26T17:58:48]i000: Setting numeric variable 'WixStdBALanguageId' to value 1033
[1D38:29F0][2017-01-26T17:58:48]i000: Setting version variable 'WixBundleFileVersion' to value '1.0.0.3177'
[1D38:1498][2017-01-26T17:58:48]i100: Detect begin, 5 packages
[1D38:1498][2017-01-26T17:58:48]i000: Setting numeric variable 'VCRedist_KeyExists' to value 1
[1D38:1498][2017-01-26T17:58:48]i000: Setting string variable 'VCRedist_KeyValue' to value 'v14.0.23026.00'
[1D38:1498][2017-01-26T17:58:48]w120: Detected partially cached package: VC_redist.x64.exe, invalid payload: VC_redist.x64.exe, reason: 0x80070002
[1D38:1498][2017-01-26T17:58:48]i052: Condition '(VCRedist_KeyExists AND VCRedist_KeyValue &gt;= "v14.0.23506.00")' evaluates to false.
[1D38:1498][2017-01-26T17:58:48]i103: Detected related package: {B76A65C9-4BCA-41BD-AD6C-2DC0120F4B14}, scope: PerMachine, version: 4.0.20977.0, language: 0 operation: MajorUpgrade
[1D38:1498][2017-01-26T17:58:48]i103: Detected related package: {7AB69CC0-742C-4881-8F8A-D836691FCD88}, scope: PerMachine, version: 4.0.20977.0, language: 0 operation: MajorUpgrade
[1D38:1498][2017-01-26T17:58:48]i101: Detected package: VC_redist.x64.exe, state: Absent, cached: Partial
[1D38:1498][2017-01-26T17:58:48]i101: Detected package: dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi, state: Absent, cached: Complete
[1D38:1498][2017-01-26T17:58:48]i101: Detected package: dotnet_sharedframework_win_x64.1.1.0.msi, state: Absent, cached: Complete
[1D38:1498][2017-01-26T17:58:48]i101: Detected package: dotnet_hostfxr_win_x64.1.1.0.msi, state: Absent, cached: Complete
[1D38:1498][2017-01-26T17:58:48]i101: Detected package: dotnet_host_win_x64.1.1.0.msi, state: Absent, cached: Complete
[1D38:1498][2017-01-26T17:58:48]i199: Detect complete, result: 0x0
[1D38:29F0][2017-01-26T17:58:50]i000: Setting numeric variable 'EulaAcceptCheckbox' to value 1
[1D38:1498][2017-01-26T17:58:50]i200: Plan begin, 5 packages, action: Install
[1D38:1498][2017-01-26T17:58:50]w321: Skipping dependency registration on package with no dependency providers: VC_redist.x64.exe
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleLog_VC_redist.x64.exe' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_000_VC_redist.x64.exe.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleRollbackLog_dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_001_dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi_rollback.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleLog_dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_001_dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleRollbackLog_dotnet_sharedframework_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_002_dotnet_sharedframework_win_x64.1.1.0.msi_rollback.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleLog_dotnet_sharedframework_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_002_dotnet_sharedframework_win_x64.1.1.0.msi.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleRollbackLog_dotnet_hostfxr_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_003_dotnet_hostfxr_win_x64.1.1.0.msi_rollback.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleLog_dotnet_hostfxr_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_003_dotnet_hostfxr_win_x64.1.1.0.msi.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleRollbackLog_dotnet_host_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_004_dotnet_host_win_x64.1.1.0.msi_rollback.log'
[1D38:1498][2017-01-26T17:58:50]i000: Setting string variable 'WixBundleLog_dotnet_host_win_x64.1.1.0.msi' to value 'C:\Users\cltsa\AppData\Local\Temp\Microsoft_.NET_Core_1.1.0_-_SDK_1.0.0_Preview_2.1-003177_(x64)_20170126175848_004_dotnet_host_win_x64.1.1.0.msi.log'
[1D38:1498][2017-01-26T17:58:50]i201: Planned package: VC_redist.x64.exe, state: Absent, default requested: Present, ba requested: Present, execute: Install, rollback: None, cache: Yes, uncache: No, dependency: None
[1D38:1498][2017-01-26T17:58:50]i201: Planned package: dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi, state: Absent, default requested: Present, ba requested: Present, execute: Install, rollback: Uninstall, cache: No, uncache: No, dependency: Register
[1D38:1498][2017-01-26T17:58:50]i201: Planned package: dotnet_sharedframework_win_x64.1.1.0.msi, state: Absent, default requested: Present, ba requested: Present, execute: Install, rollback: Uninstall, cache: No, uncache: No, dependency: Register
[1D38:1498][2017-01-26T17:58:50]i201: Planned package: dotnet_hostfxr_win_x64.1.1.0.msi, state: Absent, default requested: Present, ba requested: Present, execute: Install, rollback: Uninstall, cache: No, uncache: No, dependency: Register
[1D38:1498][2017-01-26T17:58:50]i201: Planned package: dotnet_host_win_x64.1.1.0.msi, state: Absent, default requested: Present, ba requested: Present, execute: Install, rollback: Uninstall, cache: No, uncache: No, dependency: Register
[1D38:1498][2017-01-26T17:58:50]i299: Plan complete, result: 0x0
[1D38:1498][2017-01-26T17:58:50]i300: Apply begin
[1D38:1498][2017-01-26T17:58:50]i010: Launching elevated engine process.
[1D38:1498][2017-01-26T17:58:51]i011: Launched elevated engine process.
[1D38:1498][2017-01-26T17:58:52]i012: Connected to elevated engine.
[0EFC:2490][2017-01-26T17:58:52]i358: Pausing automatic updates.
[0EFC:2490][2017-01-26T17:58:52]i359: Paused automatic updates.
[0EFC:2490][2017-01-26T17:58:52]i370: Session begin, registration key: SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{aeefdc43-0737-449a-91fd-90d4cf44688d}, options: 0x7, disable resume: No
[0EFC:2490][2017-01-26T17:58:52]i000: Caching bundle from: 'C:\Users\cltsa\AppData\Local\Temp\{778F45BC-2545-4A4A-98AB-B53D23C0A7FA}\.be\dotnet-dev-win-x64.1.0.0-preview2-1-003177.exe' to: 'C:\ProgramData\Package Cache\{aeefdc43-0737-449a-91fd-90d4cf44688d}\dotnet-dev-win-x64.1.0.0-preview2-1-003177.exe'
[0EFC:2490][2017-01-26T17:58:52]i320: Registering bundle dependency provider: {aeefdc43-0737-449a-91fd-90d4cf44688d}, version: 1.0.0.3177
[0EFC:2490][2017-01-26T17:58:52]i371: Updating session, registration key: SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{aeefdc43-0737-449a-91fd-90d4cf44688d}, resume: Active, restart initiated: No, disable resume: No
[1D38:26B4][2017-01-26T17:58:52]w343: Prompt for source of package: VC_redist.x64.exe, payload: VC_redist.x64.exe, path: C:\Users\cltsa\Downloads\VC_redist.x64.exe
[1D38:26B4][2017-01-26T17:58:52]i338: Acquiring package: VC_redist.x64.exe, payload: VC_redist.x64.exe, download from: https://download.microsoft.com/download/1/F/0/1F01DD22-748C-41A7-89DE-54D64355CDA6/vc_redist.x64.exe
[0EFC:0888][2017-01-26T17:58:53]i305: Verified acquired payload: VC_redist.x64.exe at path: C:\ProgramData\Package Cache\.unverified\VC_redist.x64.exe, moving to: C:\ProgramData\Package Cache\10B1683EA3FF5F36F225769244BF7E7813D54AD0\VC_redist.x64.exe.
[0EFC:2490][2017-01-26T17:58:53]i301: Applying execute package: VC_redist.x64.exe, action: Install, path: C:\ProgramData\Package Cache\10B1683EA3FF5F36F225769244BF7E7813D54AD0\VC_redist.x64.exe, arguments: '"C:\ProgramData\Package Cache\10B1683EA3FF5F36F225769244BF7E7813D54AD0\VC_redist.x64.exe" /q /norestart'
[0EFC:0888][2017-01-26T17:58:53]i304: Verified existing payload: dotnet_dev_win_x64.1.0.0_preview2_1_003177.msi at path: C:\ProgramData\Package Cache\{8DD22081-A4D7-4C96-8534-725191A12848}v4.0.3177\dotnet-dev-win-x64.1.0.0-preview2-1-003177.msi.
[0EFC:0888][2017-01-26T17:58:53]i304: Verified existing payload: cab952584936531070DA98ED0B5C2D6204A at path: C:\ProgramData\Package Cache\{8DD22081-A4D7-4C96-8534-725191A12848}v4.0.3177\dnet-1.cab.
[0EFC:0888][2017-01-26T17:58:53]i304: Verified existing payload: dotnet_sharedframework_win_x64.1.1.0.msi at path: C:\ProgramData\Package Cache\{EEFD95C3-2469-40C4-B5CD-1C9A586F7C1B}v1.1.0\dotnet-sharedframework-win-x64.1.1.0.msi.
[0EFC:0888][2017-01-26T17:58:53]i304: Verified existing payload: dotnet_hostfxr_win_x64.1.1.0.msi at path: C:\ProgramData\Package Cache\{5FF9D357-F232-4F20-8F65-BA615F5FB8D7}v4.16.1179\dotnet-hostfxr-win-x64.1.1.0.msi.
[0EFC:0888][2017-01-26T17:58:53]i304: Verified existing payload: dotnet_host_win_x64.1.1.0.msi at path: C:\ProgramData\Package Cache\{5E97AB5D-76FC-4FC8-B466-ED0B136374C9}v4.16.1179\dotnet-host-win-x64.1.1.0.msi.
[0EFC:2490][2017-01-26T17:58:53]e000: Error 0x80070666: Process returned error: 0x666
[0EFC:2490][2017-01-26T17:58:53]e000: Error 0x80070666: Failed to execute EXE package.
[1D38:1498][2017-01-26T17:58:53]e000: Error 0x80070666: Failed to configure per-machine EXE package.
[1D38:1498][2017-01-26T17:58:53]i319: Applied execute package: VC_redist.x64.exe, result: 0x80070666, restart: None
[1D38:1498][2017-01-26T17:58:53]e000: Error 0x80070666: Failed to execute EXE package.
[0EFC:2490][2017-01-26T17:58:53]i351: Removing cached package: VC_redist.x64.exe, from path: C:\ProgramData\Package Cache\10B1683EA3FF5F36F225769244BF7E7813D54AD0\
[0EFC:2490][2017-01-26T17:58:53]i372: Session end, registration key: SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{aeefdc43-0737-449a-91fd-90d4cf44688d}, resume: None, restart: None, disable resume: No
[0EFC:2490][2017-01-26T17:58:53]i330: Removed bundle dependency provider: {aeefdc43-0737-449a-91fd-90d4cf44688d}
[0EFC:2490][2017-01-26T17:58:53]i352: Removing cached bundle: {aeefdc43-0737-449a-91fd-90d4cf44688d}, from path: C:\ProgramData\Package Cache\{aeefdc43-0737-449a-91fd-90d4cf44688d}\
[0EFC:2490][2017-01-26T17:58:53]i371: Updating session, registration key: SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{aeefdc43-0737-449a-91fd-90d4cf44688d}, resume: None, restart initiated: No, disable resume: No
[1D38:1498][2017-01-26T17:58:54]i399: Apply complete, result: 0x80070666, restart: None, ba requested restart:  No

Just wondering if there is any workaround for this, so I could work on my existing .NET Core 1.1 project.
I'm not sure if this is the right place to ask about this. I'm sorry if it's not, and please point me to the right place.

Thanks you.</Description>
        <CreatedDate>26/01/2017</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>466</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Stop defaulting NeutralLanguage</Title>
    <Description>This can cause MissingManifestException if project doesn't have English neutral resources in main assembly, or incorrectly displaying non-English neutral resources to English end-user.

Fix #382
Fix #410 

@srivatsn @dsplaisted @davkean</Description>
    <CreatedDate>07/12/2016</CreatedDate>
    <ClosedDate>09/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>466</PullRequestID>
        <IssueID>382</IssueID>
        <Title>Don't add NeutralResourcesLanguageAttribute to AssemblyInfo when no embedded resources are used</Title>
        <Description>Currently, the generated AssemblyInfo will always include a `NeutralResourcesLanguageAttribute` by default. This is an issue when creating a minimum dependency package without using embedded resources (e.g. just referencing `System.Runtime` for `netstandard1.0` - see attached example). The approach of building packages/libraries with minimum dependencies is still recommended for targeting `netstandard` &lt; 2.0.

Although it is totally possible to set the `GenerateNeutralResourcesLanguageAttribute` property to false, it isn't (yet) documented very visibly and not immediately obvious.

I feel that no dependency on `System.Resources.ResourceManager` should be required by default so I propose to not emit the attribute if no `EmbeddedResource` item exists. The `project.json` tooling also did not emit the attribute.

[example.zip](https://github.com/dotnet/sdk/files/585100/example.zip)</Description>
        <CreatedDate>11/11/2016</CreatedDate>
        <ClosedDate>09/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>466</PullRequestID>
        <IssueID>410</IssueID>
        <Title>ResourceManager can't find parent culture resources when built using csproj/msbuild</Title>
        <Description>Moving https://github.com/dotnet/cli/issues/4781 on behalf of @ryanbrandenburg

----

## Steps to reproduce
1. Clone [this](https://github.com/ryanbrandenburg/ResourceManagerMsbuild) repo
2. Run the project.

## Expected  behavior
Finds the parent culture of "en" and outputs "key1 en" (this is confirmed to work with ".NET Command Line Tools (1.0.0-preview3-003770)" which still used project.json)

## Actual behavior
Unable to find parent culture, so A MissingManifest exception is thrown.

## Environment data
`dotnet --info` output:
.NET Command Line Tools (1.0.0-preview3-004056)

Product Information:
 Version:            1.0.0-preview3-004056
 Commit SHA-1 hash:  ccc4968bc3

Runtime Environment:
 OS Name:     Windows
 OS Version:  6.3.9600
 OS Platform: Windows
 RID:         win81-x64</Description>
        <CreatedDate>19/11/2016</CreatedDate>
        <ClosedDate>09/12/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>465</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>smadala</FixedByID>
    <Title>Change encoding of template files from us-ascii to utf-8</Title>
    <Description>- To address Microsoft/vstest#252

/cc @codito @singhsarab @srivatsn </Description>
    <CreatedDate>06/12/2016</CreatedDate>
    <ClosedDate>28/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>465</PullRequestID>
        <IssueID>252</IssueID>
        <Title>dotnet build3: build-time constants work differently than dotnet build</Title>
        <Description>## Steps to reproduce

Compare the build-time constants available in `dotnet build` vs. `dotnet build3`. It looks like none of the build-time constants set in the .csproj under a TFM condition don't make it to `csc`.
1. Extract this example project: [defines.zip](https://github.com/dotnet/sdk/files/525212/defines.zip)
2. Build it with `dotnet build` and run.
3. Build it with `dotnet build3` and run.
4. Compare the output.
## Expected  behavior

The output should be the same.

``
</Description>
        <CreatedDate>12/10/2016</CreatedDate>
        <ClosedDate>12/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>463</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Include pre-restored project.assets.json in project templates</Title>
    <Description>This PR adds a "pre-restored" project.assets.json file to the project templates.  This means that when the project is created, but before the restore operation completes, the project will be functional.  Without this change, the project will not have the right references, so there will be design-time build errors, and intellisense won't show any .NET APIs.

This depends on the packages being available in the user's NuGet package cache folder, so the first time a project is created on a machine, the errors will still show up until package restore completes.

**Escrow Template**:

Customer scenario –On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.
Bugs this fixes: not filed
Workarounds - wait for restore to complete
Risk – Medium: when creating the templates, the build process deletes a line from project.assets.json that has the value for `packageFolders`, as this is machine-specific.  NuGet (or its tasks, etc) may not expect that to be missing from the assets file.
Performance impact - None.
Is this a regression? - No
Root cause analysis - After #453 is fixed with PR #457, the design-time "build" succeeds.  But the design-time invocation of the build doesn't compile anything (as I understand it), it merely gathers the parameters needed to pass to the compiler.  So the compilation is now failing because there are no references to the .NET Framework APIs from NuGet packages until after the restore completes.
How was the bug found? - Internal testing.</Description>
    <CreatedDate>06/12/2016</CreatedDate>
    <ClosedDate>06/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>463</PullRequestID>
        <IssueID>453</IssueID>
        <Title>NuGet restore error on project creation.</Title>
        <Description>On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.

![nuget_restore](https://cloud.githubusercontent.com/assets/3981619/20869439/27d341d6-ba27-11e6-9682-46b944d93096.png)
</Description>
        <CreatedDate>04/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>463</PullRequestID>
        <IssueID>457</IssueID>
        <Title>Skip ResolvePackageDependencies task during design-time builds where restore hasn't occured</Title>
        <Description>Fixes #453 

When the Sdk was a NuGet package, its targets would never run before a restore completed.  Now that it's an MSBuild Sdk, the targets can get run before a restore.  The ResolvePackageDependencies task will generate an an error if the project assets file isn't found.  When a project was created, it would generate an error in the design time build, which would show up in the error list in Visual Studio and then disappear when the package restore operation completed.

This change skips the RunResolvePackageDependencies target if the `DesignTimeBuild` property is true and the assets file can't be found.


**Escrow Template:**

Customer scenario –On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.
Bugs this fixes: #453 
Workarounds - none
Risk – Low.
Performance impact - None.
Is this a regression? - Yes
Root cause analysis - When the Sdk was a NuGet package, its targets would never run before a restore completed.  Now that it's an MSBuild Sdk, the targets can get run before a restore. 
How was the bug found? - Internal testing.

@MattGertz  for RC.2 Approval</Description>
        <CreatedDate>05/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>457</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Skip ResolvePackageDependencies task during design-time builds where restore hasn't occured</Title>
    <Description>Fixes #453 

When the Sdk was a NuGet package, its targets would never run before a restore completed.  Now that it's an MSBuild Sdk, the targets can get run before a restore.  The ResolvePackageDependencies task will generate an an error if the project assets file isn't found.  When a project was created, it would generate an error in the design time build, which would show up in the error list in Visual Studio and then disappear when the package restore operation completed.

This change skips the RunResolvePackageDependencies target if the `DesignTimeBuild` property is true and the assets file can't be found.


**Escrow Template:**

Customer scenario –On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.
Bugs this fixes: #453 
Workarounds - none
Risk – Low.
Performance impact - None.
Is this a regression? - Yes
Root cause analysis - When the Sdk was a NuGet package, its targets would never run before a restore completed.  Now that it's an MSBuild Sdk, the targets can get run before a restore. 
How was the bug found? - Internal testing.

@MattGertz  for RC.2 Approval</Description>
    <CreatedDate>05/12/2016</CreatedDate>
    <ClosedDate>05/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>453</IssueID>
        <Title>NuGet restore error on project creation.</Title>
        <Description>On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.

![nuget_restore](https://cloud.githubusercontent.com/assets/3981619/20869439/27d341d6-ba27-11e6-9682-46b944d93096.png)
</Description>
        <CreatedDate>04/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>453</IssueID>
        <Title>NuGet restore error on project creation.</Title>
        <Description>On project creation, nuget package restore error shows up in the error list and goes away once the restore is complete.

![nuget_restore](https://cloud.githubusercontent.com/assets/3981619/20869439/27d341d6-ba27-11e6-9682-46b944d93096.png)
</Description>
        <CreatedDate>04/12/2016</CreatedDate>
        <ClosedDate>05/12/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>444</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>srivatsn</FixedByID>
    <Title>Add setup authoring for the SDK files </Title>
    <Description>This change creates a vs package that lays down the SDK files in the msbuild SDK folder.  This change depends on #425 before this can go in.

@dotnet/project-system @dsplaisted @jinujoseph @basoundr </Description>
    <CreatedDate>30/11/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>444</PullRequestID>
        <IssueID>425</IssueID>
        <Title>Switch the .NET Sdk to a simulated "MSBuild Sdk" instead of a NuGet package</Title>
        <Description>MSBuild is adding support for an `Sdk` attribute to the top-level project element which will automatically import `.props` and `.targets` files from an "Sdk": Microsoft/MSBuild#1392

This PR:

- Updates the Microsoft.Net.Sdk package so that it can be used as an Sdk
- Copies our package and the NuGet.Build.Tasks.Pack package it depends on to an Sdk folder for tests to use
- Updates the projects used in our tests to have imports to the `.props` and `.targets` files for our Sdk, instead of referencing the NuGet package

Once we have a version of MSBuild that supports the Sdk feature, we should replace the imports from our TestAssets projects with an Sdk attribute.  I think we should wait to merge this PR until that happens.</Description>
        <CreatedDate>24/11/2016</CreatedDate>
        <ClosedDate>02/12/2016</ClosedDate>
        <Labels>
          <Label>Approved to merge</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>425</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Switch the .NET Sdk to a simulated "MSBuild Sdk" instead of a NuGet package</Title>
    <Description>MSBuild is adding support for an `Sdk` attribute to the top-level project element which will automatically import `.props` and `.targets` files from an "Sdk": Microsoft/MSBuild#1392

This PR:

- Updates the Microsoft.Net.Sdk package so that it can be used as an Sdk
- Copies our package and the NuGet.Build.Tasks.Pack package it depends on to an Sdk folder for tests to use
- Updates the projects used in our tests to have imports to the `.props` and `.targets` files for our Sdk, instead of referencing the NuGet package

Once we have a version of MSBuild that supports the Sdk feature, we should replace the imports from our TestAssets projects with an Sdk attribute.  I think we should wait to merge this PR until that happens.</Description>
    <CreatedDate>24/11/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>425</PullRequestID>
        <IssueID>1392</IssueID>
        <Title>[regression since 15.2] net core sdk project auto restore does not pop up error list for restore errors</Title>
        <Description>Original bug: https://github.com/NuGet/Home/issues/5509

Moving this here since NuGet is no longer populating the error list for net core sdk projects and it seems more reasonable for the sdk target to pop up the error list.

## Details about Problem

NuGet product used (NuGet.exe | VS UI | Package Manager Console | dotnet.exe): VS 

NuGet version (x.x.x.xxx): 4.3.0.4250

VS version (if appropriate): d15prerel/26627.3006

Worked before? If so, with which NuGet version: 4.2.0.2457 in VS 15.2

## Detailed repro steps so we can see the same problem

1. File New Project -&gt; Net standard class library.

2. Change target framework to netstandard1.4.

3. Close Error list and output windows if open.

4. Edit csproj to add the following - 
``

...

### Expected 

The error list should be displayed as in 15.2 - 
![editcsprojin15 2](https://user-images.githubusercontent.com/10507120/27712654-da7edd4c-5cdc-11e7-9a1c-94f89204288c.PNG)

### Actual 

No error list is displayed - 
![editcsprojin15 3](https://user-images.githubusercontent.com/10507120/27712664-e677a34a-5cdc-11e7-844b-e1decf4dfa2a.PNG)

</Description>
        <CreatedDate>06/07/2017</CreatedDate>
        <ClosedDate>06/07/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>424</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Fix handling of ProjectName.deps.json file in incremental builds</Title>
    <Description>Fixes #408

The issue was that if the ProjectName.deps.json file was up to date, then the `GenerateDepsFile` target would be skipped and the deps.json file would not be included in the `FileWrites` item group, causing it to get deleted by `IncrementalClean`.  This change adds a separate target which always runs which adds the deps.json file to the `FileWrites` group even if `GenerateDepsFile` isn't run.</Description>
    <CreatedDate>24/11/2016</CreatedDate>
    <ClosedDate>30/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>424</PullRequestID>
        <IssueID>408</IssueID>
        <Title>The projectname.deps.json file is removed every 2nd build. #4779 </Title>
        <Description>Copied from https://github.com/dotnet/cli/issues/4779

Install VS d15prerel.25918.01 build
Create a new ASP.NET Core Web Applicatoin (.NET Core)
Open the bin\debug\netcoreapp1.0 folder so you can see the build output
Build once deps file is there
Build again it is gone
Build again it is back
This causes the runtime (F5) to fail every 2nd build.</Description>
        <CreatedDate>18/11/2016</CreatedDate>
        <ClosedDate>30/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>418</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Skip nearest target framework resolution if TargetFramework is specified and ReferringTargetFramework is empty</Title>
    <Description>Fixes #416</Description>
    <CreatedDate>22/11/2016</CreatedDate>
    <ClosedDate>23/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>418</PullRequestID>
        <IssueID>416</IssueID>
        <Title>The "GetNearestTargetFramework" task was not given a value for the required parameter "ReferringTargetFramework".</Title>
        <Description>This is a scenario of Service Fabric application with an ASP.NET Core web service targeting .NET Framework.

In Visual Studio, Service Fabric Application project (similar to a Deployment project) adds project references to the service projects. With https://github.com/dotnet/sdk/pull/363, the SDK will check if referencing project and referenced project are compatible in terms of the target frameworks. However, Service Fabric Application project is not a managed code project, so it doesn't have any target framework moniker. In this case, the SDK reports an error on the referenced service project (ASP.NET Core on .NET FX)because of ReferringTargetFramework being empty.

As a tactical fix for RC.2, I suggest this:  If ReferringTargetFramework is empty, GetNearestTargetFramework returns the only TFM if the project only has one. Otherwise, it throws error. In this case, the semantic of ReferringTargetFramework being empty is that the referencing project can accept any TFM.</Description>
        <CreatedDate>21/11/2016</CreatedDate>
        <ClosedDate>23/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>397</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dmportella</FixedByID>
    <Title>[WIP] Modified project files default output to be lowercase</Title>
    <Description>The default capitalization of the outputpath was set to `bin\Debug` and `bin\Release`. I changed it so its default to be lowercase.

Closes #375

Let me know if this is all that is needed.</Description>
    <CreatedDate>16/11/2016</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>397</PullRequestID>
        <IssueID>375</IssueID>
        <Title>Capitalization of build folders names in case sensitive OS's</Title>
        <Description>Moved from https://github.com/dotnet/cli/issues/2010 on behalf of @dmportella and @joshfree 

------


Moved from https://github.com/dotnet/corefx/issues/7173 on behalf of @dmportella

&gt; HI everyone
&gt; 
&gt; Not sure if this is the right place to post this request but I wanted to ask for a change in the build folder setup for dotnet applications, I would like bin/Debug, bin/Release to be by default lower case. I know sounds lazy and all changing this would have no effect on a windows platform but would go be so cool not having to keep reminding yourself that the debug folder name is {caps}Debug and not debug.
&gt; 
&gt; ![image](https://cloud.githubusercontent.com/assets/676817/13982643/21b3c73e-f0e3-11e5-98eb-9ad067917332.png)
&gt; 
&gt; Anyway
&gt; 
&gt; peace
</Description>
        <CreatedDate>10/11/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Bug</Label>
          <Label>up-for-grabs</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>381</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add deps and runtime configuration files to @(FileWrites) so they are deleted during Clean</Title>
    <Description>Fixes #305</Description>
    <CreatedDate>11/11/2016</CreatedDate>
    <ClosedDate>11/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>381</PullRequestID>
        <IssueID>305</IssueID>
        <Title>Clean target leaves json files</Title>
        <Description>Building and then cleaning a .net core project currently leaves behind:
- `xyz.deps.json`
- `xyz.runtimeconfig.json`
- `xyz.runtimeconfig.deps.json`

May be related to #225 
</Description>
        <CreatedDate>19/10/2016</CreatedDate>
        <ClosedDate>11/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>371</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add all projects to MSBuildAllProjects property</Title>
    <Description>Fixes #277 

@nguerrera </Description>
    <CreatedDate>09/11/2016</CreatedDate>
    <ClosedDate>10/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>371</PullRequestID>
        <IssueID>277</IssueID>
        <Title>Make sure all projects add themselves to MSBuildAllProjects</Title>
        <Description>Reminded by #276 that we're not doing this everywhere.
</Description>
        <CreatedDate>13/10/2016</CreatedDate>
        <ClosedDate>10/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>368</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>natidea</FixedByID>
    <Title>Use LockFile.PackageFolders instead of NuGetPathContext</Title>
    <Description>Use LockFile.PackageFolders instead of NuGetPathContext when it is available 

Fixes #361

/cc @dotnet/project-system @emgarten </Description>
    <CreatedDate>09/11/2016</CreatedDate>
    <ClosedDate>10/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>368</PullRequestID>
        <IssueID>361</IssueID>
        <Title>Use LockFile.PackageFolders instead of NuGetPathContext when it is available</Title>
        <Description>In `Microsoft.NET.Build.Tasks.NuGetPackageResolver`, use `LockFile.PackageFolders` instead of `NuGetPathContext` when it is available.

From Justin:

&gt; When resolving packages from a project.lock.json or project.assets.json file the folder paths given in the file should be used instead of NuGetPathContext.
&gt; 
&gt; ResolvePackageDependencies should pass the paths to FallbackPackagePathResolver here: https://github.com/NuGet/NuGet.Client/blob/dev/src/NuGet.Core/NuGet.Packaging/FallbackPackagePathResolver.cs#L26
&gt; 
&gt; Passing NuGetPathContext will re-evaluate the global packages folder path, and that may not match the folder used by restore if it was passed in on the command line to restore. The value in the assets file however will contain exactly what restore used.

When using NuGetPathContext, NuGet finds the paths to the global packages folder and fallback package folders by reading NuGet.Config, including the user wide NuGet.config. This could lead to errors for users running as a service or under a system account which doesn’t have a profile:

&gt; C:\Users\dotnetcoretest2\.nuget\packages\microsoft.net.sdk\1.0.0-alpha-20161029-1\build\Microsoft.PackageDependencyResolution.targets(138,5): error MSB4018: The "ResolvePackageDependencies" task failed unexpectedly. 
&gt; 
&gt; C:\Users\dotnetcoretest2\.nuget\packages\microsoft.net.sdk\1.0.0-alpha-20161029-1\build\Microsoft.PackageDependencyResolution.targets(138,5): error MSB4018: NuGet.Configuration.NuGetConfigurationException: Failed to read NuGet.Config due to unauthorized access. Path: 'C:\WINDOWS\system32\config\systemprofile\AppData\Roaming\NuGet\NuGet.Config'. ---&gt; System.UnauthorizedAccessException: Access to the path 'C:\WINDOWS\system32\config\systemprofile' is denied. 
</Description>
        <CreatedDate>05/11/2016</CreatedDate>
        <ClosedDate>10/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>366</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add tests for non-SDK projects referencing SDK projects</Title>
    <Description>Expands the tests added in #363 to also test non-SDK projects targeting .NET Framework referencing SDK projects.

@nguerrera @srivatsn </Description>
    <CreatedDate>08/11/2016</CreatedDate>
    <ClosedDate>09/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>366</PullRequestID>
        <IssueID>363</IssueID>
        <Title>Add validation that referenced project target framework is compatible with current target</Title>
        <Description>This fixes #264 for the case where both projects use the .NET SDK.</Description>
        <CreatedDate>07/11/2016</CreatedDate>
        <ClosedDate>08/11/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>363</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add validation that referenced project target framework is compatible with current target</Title>
    <Description>This fixes #264 for the case where both projects use the .NET SDK.</Description>
    <CreatedDate>07/11/2016</CreatedDate>
    <ClosedDate>08/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>363</PullRequestID>
        <IssueID>264</IssueID>
        <Title>All invalid p2p references should result in warnings/errors</Title>
        <Description>We're moving to a model where builds via the command-line and Visual Studio are exactly the same, no different validation, no different warnings, etc.

The first step of this, is to push P2P validation to MSBuild indirectly via ResolveProjectReferences. The project system will then pick up these warnings/errors during builds and design-time builds and push them to the Error List and [stop blocking you from adding a reference](https://github.com/dotnet/roslyn-project-system/pull/595).

We already do some validating in the multi-TFM case, this bug is representing the work to do similar validation in the single-TFM case, and to make sure that we're erroring/warning in the right cases.
</Description>
        <CreatedDate>12/10/2016</CreatedDate>
        <ClosedDate>08/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>360</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Include app.config file in published files if it exists</Title>
    <Description>Fixes #314</Description>
    <CreatedDate>04/11/2016</CreatedDate>
    <ClosedDate>04/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>360</PullRequestID>
        <IssueID>314</IssueID>
        <Title>AutoGenerateBindingRedirects config file not included in publish output</Title>
        <Description>I manually set AutoGenerateBindingRedirects to true (although I noticed this will happen by default per #267), but when I run 'dotnet publish3 &lt;name&gt;.csproj', the file '&lt;name&gt;.exe.config' is not included in publish output.

I'm repro-ing this on an ASP.NET Core (.NET Framework) Web API project
</Description>
        <CreatedDate>24/10/2016</CreatedDate>
        <ClosedDate>04/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>349</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Support generating a documentation file with GenerateDocumentationFile property</Title>
    <Description>Fixes #193, by automatically setting the `DocumentationFile` property if `GenerateDocumentationFile` is true.

Follow-up bugs to file once this is merged:
- Update the compilation context preservation process to correctly handle the documentation file options (or ignore them entirely if we don't need them).
- Don't set OutputPath in the props files for the Sdk. If we're just going to be modifying it in the targets, then setting it to something in the props files can lead to unexpected behavior when the value is used in the project but doesn't represent the final value of the property.
- In [dotnet/roslyn-project-system](https://github.com/dotnet/roslyn-project-system): Update the "Build" property page so that you can check a box to generate an Xml documentation file without specifying the filename. This should set `GenerateDocumentationFile` to true in the project file instead of setting the `DocumentationFile` property. This behavior should light up based on the `GenerateDocumentationFile` capability so that projects that don't use the Sdk still get the old behavior.</Description>
    <CreatedDate>02/11/2016</CreatedDate>
    <ClosedDate>03/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>349</PullRequestID>
        <IssueID>193</IssueID>
        <Title>DocumentationFile being dropped at OutputPath instead of OutputPath/TFM</Title>
        <Description>Output for documentation file with the csproj below is ending up in the output path and then it gets copied to tfm. But this may cause problems where the documentation should actually be different per tfm.

``
</Description>
        <CreatedDate>29/09/2016</CreatedDate>
        <ClosedDate>03/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>348</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Force current runtime and arch for GenerateResources on Core msbuild</Title>
    <Description>Fix #346 with a workaround for Microsoft/msbuild#1293

Also cleaning up the nearby usage 'hack' to just 'workaround' ;)

@srivatsn @rainersigwald @NTaylorMullen @dotnet/project-system </Description>
    <CreatedDate>01/11/2016</CreatedDate>
    <ClosedDate>02/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>348</PullRequestID>
        <IssueID>346</IssueID>
        <Title>Can't run GenerateResource Task</Title>
        <Description>_From @NTaylorMullen on November 1, 2016 0:30_

After `dotnet migrate` ing [Microsoft.AspNetCore.Razor.Design](https://github.com/aspnet/RazorTooling/tree/dev/src/Microsoft.AspNetCore.Razor.Design) attempting to restore3/build3 results in the following error:

`
C:\Users\nimullen\AppData\Local\Microsoft\dotnet\sdk\1.0.0-preview3-003892\Microsoft.Common.CurrentVersion.targets(2801,5): error MSB4216: Could not run the "GenerateResource" task because MSBuild could not create or connect to a task host with runtime "CLR4" and architecture "x86".  Please ensure that (1) the requested runtime and/or architecture are available on the machine, and (2) that the required executable "C:\Users\nimullen\AppData\Local\Microsoft\dotnet\sdk\1.0.0-preview3-003892\MSBuild.exe" exists and can be run. [C:\Users\nimullen\Documents\GitHub\RazorTooling\src\Microsoft.AspNetCore.Razor.Design\Microsoft.AspNetCore.Razor.Design.csproj]
`

I thought I recalled seeing an issue associated with GenerateResource task being unable to run but I can no longer find it. Feel free to move or close this issue as a duplicate.

Dotnet info:
``

_Copied from original issue: dotnet/cli#4556_</Description>
        <CreatedDate>01/11/2016</CreatedDate>
        <ClosedDate>02/11/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>348</PullRequestID>
        <IssueID>1293</IssueID>
        <Title>Tool deps file generation tests fail when run on full Framework MSBuild</Title>
        <Description>The tests in `GivenThatWeWantToGenerateADepsFileForATool` are failing when running on full Framework MSBuild with the following error:

&gt; C:\git\dotnet-sdk\bin\Debug\Sdks\Microsoft.NET.Sdk\build\GenerateDeps\GenerateDeps.proj(29,5): error MSB4184: The expression "[System.IO.Path]::GetDirectoryName("C:\git\dotnet-sdk\packages\.tools\testtool\1.0.0\netcoreapp2.0\project.assets.json")" cannot be evaluated. Illegal characters in path.

The scenarios these tests cover aren't applicable to full framework MSBuild, but it is unexpected that they would fail in this way.  We should investigate what is going on.</Description>
        <CreatedDate>02/06/2017</CreatedDate>
        <ClosedDate>15/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>339</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Handle packagerefs with satellite assemblies</Title>
    <Description>Fix #338 

@srivatsn @livarcocc @dotnet/project-system 

@MattGertz for approval. This is blocking the CLI team and would prevent customer publishing if any package with a satellite assembly is referenced.
</Description>
    <CreatedDate>28/10/2016</CreatedDate>
    <ClosedDate>28/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>339</PullRequestID>
        <IssueID>338</IssueID>
        <Title>GenerateDepsFile fails</Title>
        <Description>Just go into the CLI and update this https://github.com/dotnet/cli/blob/rel/1.0.0/build_projects/dotnet-cli-build/dotnet-cli-build.csproj#L46 to the latest SDK 1.0.0-alpha-20161027-4.

It seems like CreateProjectReferenceInfos is trying to get a project file for a package reference.

``
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>28/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>337</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Support for running tests in Visual Studio</Title>
    <Description>- Adds launchSettings.json files to test projects to support running tests with F5
- Set NUGET_PACKAGES environment variable when running MSBuild commands, to match the value set by `build.ps1` when launching tests from VS

With the changes from dotnet/roslyn-project-system#658, this will let you launch tests from VS.  You can add `-class` or `-method` to the arguments to specify which tests to run.
</Description>
    <CreatedDate>28/10/2016</CreatedDate>
    <ClosedDate>28/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>337</PullRequestID>
        <IssueID>658</IssueID>
        <Title>Error message missing data: The required attribute "" is empty or missing from the element &lt;Compile&gt;.</Title>
        <Description>When trying a `&lt;Compile Exclude="&lt;pattern&gt;" /&gt;` to fix a SDK vs `.csproj` issue, an error is properly thrown. The `Include="..."` attribute is missing. The error message presented is:

&gt; The required attribute "" is empty or missing from the element &lt;Compile&gt;.

What it should say is:

&gt; The required attribute "**Include**" is empty or missing from the element &lt;Compile&gt;.</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>17/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>327</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Add framework reference assemblies to the deps.json file.</Title>
    <Description>Fix #322

Get the assembly's extension from MSBuild instead of hard coding '.dll'.

Fix #323 

@dsplaisted @nguerrera 

/cc @dotnet/project-system @pakrym - in case you want to take a look.
</Description>
    <CreatedDate>26/10/2016</CreatedDate>
    <ClosedDate>27/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>327</PullRequestID>
        <IssueID>322</IssueID>
        <Title>Need to add plain @(Reference) information to the .deps.json file</Title>
        <Description>On Desktop projects (and technically .NET Core projects now in the MSBuild world), it is possible to have normal references to assemblies.  Specifically references to "Reference Assemblies" in the .NET Framework.

We need to add these assemblies to the .deps.json file.  In project.json based projects, for desktop specifically, these kinds of references only got added to "CompilationAssemblies", there were no runtime assets for them, since it assumed the runtime library is already present.  Thus they should only be added to the "compile" libraries in the deps.json file.

See https://github.com/dotnet/cli/blob/1278e9d6bf35500e9672fe3f53125df1d08717d8/src/Microsoft.DotNet.ProjectModel/Compilation/LibraryExporter.cs#L389-L402

Also, when we do this, the project.json based CLI would use the relative path from the "Reference Assemblies" folder (`C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework`) in the path in the .deps.json file.  See https://github.com/dotnet/cli/blob/1278e9d6bf35500e9672fe3f53125df1d08717d8/src/Microsoft.DotNet.ProjectModel/DependencyContextBuilder.cs#L221-L238
</Description>
        <CreatedDate>26/10/2016</CreatedDate>
        <ClosedDate>27/10/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>327</PullRequestID>
        <IssueID>323</IssueID>
        <Title>Need to pass $(TargetExt) into GenerateDepsFile</Title>
        <Description>We are currently hard-coding the assembly extension to `.dll` when generating the .deps.json file.  We should be passing in $(TargetExt) instead and passing it through to SingleProjectInfo.

See https://github.com/dotnet/sdk/blob/e703af27f9b81686974a8fac555e27251f15aa23/src/Tasks/Microsoft.NET.Build.Tasks/SingleProjectInfo.cs#L42
</Description>
        <CreatedDate>26/10/2016</CreatedDate>
        <ClosedDate>27/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>321</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Add P2P reference information to deps.json.</Title>
    <Description>Fix #121

@nguerrera @dsplaisted 

/cc @dotnet/project-system 
</Description>
    <CreatedDate>26/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>321</PullRequestID>
        <IssueID>121</IssueID>
        <Title>Scenario: enable P2P references across all aspects of the sdk functionality</Title>
        <Description>- [ ] ensure P2P references are written to the .deps.json file.  (Do they get put into the lock file by NuGet? We currently only use lock file information for .deps.json generation).
- [ ] ensure they are copied to the build and publish folders
- [ ] ensure P2P references' resource assemblies are copied to the build and publish folders.  And also that the P2P references' resource assemblies are added to the .deps.json file.
</Description>
        <CreatedDate>02/09/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
          <Label>Scenario</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>320</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Allow granular opt out of assembly info generation</Title>
    <Description>Fix #302
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>320</PullRequestID>
        <IssueID>302</IssueID>
        <Title>AssemblyInfo Generation conflicts with User specified AssemblyInfo</Title>
        <Description>In investigating this issue: https://github.com/dotnet/cli/issues/4378

I found that in project.json, existing AssemblyInfo attributes are detected prior to assembly info generation by parsing all the source files in the project. Existing assembly info attributes are excluded from the generated file.

https://github.com/dotnet/cli/blob/rel/1.0.0/src/Microsoft.DotNet.Compiler.Common/AssemblyInfoFileGenerator.cs#L23

This explains the duplicate assembly info issues in migrated projects. 

@eerhardt @nguerrera PTAL
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>319</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Update defaults for assembly unification and automatic binding redirection</Title>
    <Description>Fixes #315 and #267.

This warning remains, but looks like an issue with the `microsoft.aspnetcore.razor.tools` package:

&gt; C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Microsoft.Common.CurrentVersion.targets(1900,5): warning MSB3270: There was a mismatch between the processor architecture of the project being built "MSIL" and the processor architecture of the reference "C:\Users\billhie.nuget\packages\microsoft.aspnetcore.razor.tools\1.0.0-preview2-final\lib\net451\dotnet-razor-tooling.exe", "AMD64". This mismatch may cause runtime failures. Please consider changing the targeted processor architecture of your project through the Configuration Manager so as to align the processor architectures between your project and references, or take a dependency on references with a processor architecture that matches the targeted processor architecture of your project.
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>319</PullRequestID>
        <IssueID>315</IssueID>
        <Title>Building an Asp.Net Core application targeting desktop framework generates binding redirect warnings</Title>
        <Description>Create a new ASP.NET core web application targeting DotNet 4.5.2. After restoring the build generates the following warnings. Should these warnings be disabled for this scenario? Or if they are valid, should the targets file be updated to automatically apply these binding redirects?

1&gt;Consider app.config remapping of assembly "Newtonsoft.Json, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed" from Version "6.0.0.0" [] to Version "9.0.0.0" [C:\Users\billhie.nuget\packages\newtonsoft.json\9.0.1\lib\net45\Newtonsoft.Json.dll] to solve conflict and get rid of warning.
1&gt;Consider app.config remapping of assembly "System.Collections.Immutable, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" from Version "1.1.37.0" [] to Version "1.2.0.0" [C:\Users\billhie.nuget\packages\system.collections.immutable\1.2.0\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll] to solve conflict and get rid of warning.
1&gt;Consider app.config remapping of assembly "Microsoft.AspNetCore.Routing.Abstractions, Culture=neutral, PublicKeyToken=adb9793829ddae60" from Version "1.0.0.0" [] to Version "1.0.1.0" [C:\Users\billhie.nuget\packages\microsoft.aspnetcore.routing.abstractions\1.0.1\lib\net451\Microsoft.AspNetCore.Routing.Abstractions.dll] to solve conflict and get rid of warning.
1&gt;Consider app.config remapping of assembly "Microsoft.AspNetCore.Routing, Culture=neutral, PublicKeyToken=adb9793829ddae60" from Version "1.0.0.0" [] to Version "1.0.1.0" [C:\Users\billhie.nuget\packages\microsoft.aspnetcore.routing\1.0.1\lib\net451\Microsoft.AspNetCore.Routing.dll] to solve conflict and get rid of warning.
1&gt;Consider app.config remapping of assembly "System.Reflection.Metadata, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" from Version "1.2.0.0" [] to Version "1.3.0.0" [C:\Users\billhie.nuget\packages\system.reflection.metadata\1.3.0\lib\portable-net45+win8\System.Reflection.Metadata.dll] to solve conflict and get rid of warning.
1&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Microsoft.Common.CurrentVersion.targets(1900,5): warning MSB3276: Found conflicts between different versions of the same dependent assembly. Please set the "AutoGenerateBindingRedirects" property to true in the project file. For more information, see http://go.microsoft.com/fwlink/?LinkId=294190.
1&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\MSBuild\15.0\Bin\Microsoft.Common.CurrentVersion.targets(1900,5): warning MSB3270: There was a mismatch between the processor architecture of the project being built "MSIL" and the processor architecture of the reference "C:\Users\billhie.nuget\packages\microsoft.aspnetcore.razor.tools\1.0.0-preview2-final\lib\net451\dotnet-razor-tooling.exe", "AMD64". This mismatch may cause runtime failures. Please consider changing the targeted processor architecture of your project through the Configuration Manager so as to align the processor architectures between your project and references, or take a dependency on references with a processor architecture that matches the targeted processor architecture of your project.
1&gt;WebApplication3 -&gt; C:\Users\billhie\documents\visual studio 2017\Projects\WebApplication3\src\WebApplication3\bin\Debug\net452\WebApplication3.exe
</Description>
        <CreatedDate>24/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>319</PullRequestID>
        <IssueID>267</IssueID>
        <Title>AutoGenerateBindingRedirects should be on by default for desktop projects</Title>
        <Description>This should be turned on by default, similar to what we do in the legacy templates.
</Description>
        <CreatedDate>13/10/2016</CreatedDate>
        <ClosedDate>28/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>317</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Add tests for using "dotnet run3" on a project that isn't in the current directory</Title>
    <Description>Adds tests for #301.  Will fail until #313 is merged.

Also includes a test which is currently disabled due to a bug in the .NET CLI (see https://github.com/dotnet/cli/issues/4447#issuecomment-255914849).
</Description>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>317</PullRequestID>
        <IssueID>301</IssueID>
        <Title>`RunWorkingDirectory` needs to be a full path</Title>
        <Description>## Steps to reproduce

Fix https://github.com/dotnet/cli/issues/4447
Have a project in a separate directory than the current directory.
`dotnet run3 --project App\App.csproj`
## Expected  behavior

The project should build and run.
## Actual behavior

``

The issue here is the RunWorkingDirectory is coming back as a relative path from the .csproj.  We should be returning full path instead.
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>317</PullRequestID>
        <IssueID>313</IssueID>
        <Title>Setting RunWorkingDirectory to be the full path using $(TargetDir).</Title>
        <Description>Fix #301 

@dsplaisted @nguerrera 

/cc @dotnet/project-system 
</Description>
        <CreatedDate>24/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>313</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Setting RunWorkingDirectory to be the full path using $(TargetDir).</Title>
    <Description>Fix #301 

@dsplaisted @nguerrera 

/cc @dotnet/project-system 
</Description>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>26/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>313</PullRequestID>
        <IssueID>301</IssueID>
        <Title>`RunWorkingDirectory` needs to be a full path</Title>
        <Description>## Steps to reproduce

Fix https://github.com/dotnet/cli/issues/4447
Have a project in a separate directory than the current directory.
`dotnet run3 --project App\App.csproj`
## Expected  behavior

The project should build and run.
## Actual behavior

``

The issue here is the RunWorkingDirectory is coming back as a relative path from the .csproj.  We should be returning full path instead.
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>26/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>310</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Remove packages folder from Compile and EmbeddedResource item lists</Title>
    <Description>Fixes #306
</Description>
    <CreatedDate>21/10/2016</CreatedDate>
    <ClosedDate>02/11/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>310</PullRequestID>
        <IssueID>306</IssueID>
        <Title>Match Compile, EmbeddedResource project.json defaults</Title>
        <Description>There's been an ask to clean up the compile and embedded resource items post-migration. 

To do this safely (without risk of mangling someones project), SDK will need to update it's default excludes to match that of project.json. 

These are the full set of defaults for project.json

``
</Description>
        <CreatedDate>20/10/2016</CreatedDate>
        <ClosedDate>02/11/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>309</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Implicitly define compilation constants for target framework</Title>
    <Description>Fixes #195

This is a re-submit of #295, which was closed due to some infrastructure issues and can't be re-opened because it was submitted before we made the repo public.
</Description>
    <CreatedDate>21/10/2016</CreatedDate>
    <ClosedDate>21/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>309</PullRequestID>
        <IssueID>195</IssueID>
        <Title>We should inject implicit TFM DefineConstants</Title>
        <Description>In project.json-based projects, we had automatic defines injected for the TFM. So if I was building for netstandard1.3, there was an implicit define #NETSTANDARD1_3 that I could automatically use in a #if.

We should add this into the dotnet/sdk as well, so developers can easily write code for specific TFMs.
</Description>
        <CreatedDate>29/09/2016</CreatedDate>
        <ClosedDate>21/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>309</PullRequestID>
        <IssueID>295</IssueID>
        <Title>Implicitly define compilation constants for target framework</Title>
        <Description>Fixes #195

The project.json based .NET CLI tooling puts underscores in place of periods in the version numbers for some framework identifiers (`NETSTANDARD1_3`), but not others (`NETCORE45`).  It also uses `NET` as an abbreviation for `.NETFRAMEWORK`.

Here I've simply defined all possibilities, so a library targeting .NET 4.6.1 will have these defines: `NET461`, `NETFRAMEWORK461`, and `NETFRAMEWORK4_6_1`.  A library targeting .NET Standard 2.0 will have `NETSTANDARD20` and `NETSTANDARD2_0` defined.

I also haven't yet figured out a good way to test this.  It gets tested incidentally as part of the preserve compilation context tests.  To directly test it I'd like to be able to build a project and get the list of compilation constants that were used.  Possible ways of doing this could be to parse the log file (ugh!) or to evaluate the project with the MSBuild APIs and get the value of the `DefineConstants` property.
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>21/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>307</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Revert "Re-design "type: platform" for MSBuild."</Title>
    <Description>Reverts dotnet/sdk#299, which appears to be causing [CI failures](https://ci.dot.net/job/Private/job/dotnet_sdk/job/master/job/debug_windows_nt_prtest/349/):

&gt; System.TypeInitializationException : The type initializer for 'Microsoft.NET.TestFramework.Commands.MSBuildTest' threw an exception.\r\n---- System.TypeInitializationException : The type initializer for 'Microsoft.DotNet.Cli.Utils.Constants' threw an exception.\r\n-------- System.TypeInitializationException : The type initializer for 'Microsoft.DotNet.InternalAbstractions.RuntimeEnvironment' threw an exception.\r\n------------ System.IO.FileLoadException : Could not load file or assembly 'System.Runtime.InteropServices.RuntimeInformation, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)
</Description>
    <CreatedDate>20/10/2016</CreatedDate>
    <ClosedDate>20/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>307</PullRequestID>
        <IssueID>299</IssueID>
        <Title>Re-design "type: platform" for MSBuild.</Title>
        <Description>Instead of relying on a library being marked as "type: platform", we now have an MSBuild property that gives the name of the platform library.

By default, .NET Core projects use 'Microsoft.NETCore.App' for the platform library, but users or other nupkgs can set the property, if necessary.

Fix #17 

@nguerrera @livarcocc @piotrpMSFT 

/cc @dotnet/project-system 
</Description>
        <CreatedDate>18/10/2016</CreatedDate>
        <ClosedDate>19/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>299</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Re-design "type: platform" for MSBuild.</Title>
    <Description>Instead of relying on a library being marked as "type: platform", we now have an MSBuild property that gives the name of the platform library.

By default, .NET Core projects use 'Microsoft.NETCore.App' for the platform library, but users or other nupkgs can set the property, if necessary.

Fix #17 

@nguerrera @livarcocc @piotrpMSFT 

/cc @dotnet/project-system 
</Description>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>19/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>299</PullRequestID>
        <IssueID>17</IssueID>
        <Title>Re-design how to get "type: platform" information in MSBuild</Title>
        <Description>In order to tell if an application is 'portable' or not, we need to get whether a dependency is marked as "type: platform", and which dependency it is.

However, that information is not available in the project.lock.json file.  See https://github.com/NuGet/Home/issues/2695.

Once NuGet provides that info in the project.lock.json file, we should be able to remove the TODOs in our MSBuild Tasks that need this information.
</Description>
        <CreatedDate>04/08/2016</CreatedDate>
        <ClosedDate>19/10/2016</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>298</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>srivatsn</FixedByID>
    <Title>Make templates show up under a .NET Core group in VS. </Title>
    <Description>Also ensure that unit test projects don't roll up and that NETStandard template shows up higher than the framework class library template in the rollup.

@dotnet/project-system 

Fixes #230
</Description>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>298</PullRequestID>
        <IssueID>230</IssueID>
        <Title>Templates should show up under .NET Core node</Title>
        <Description>In the new prjoect dialog.
</Description>
        <CreatedDate>07/10/2016</CreatedDate>
        <ClosedDate>18/10/2016</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>296</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Add CrossPlatformExecutable project capability for .NETCoreApp</Title>
    <Description>@srivatsn 

Fix #245 but adds it to targets and does not follow #246, which wants to have nuget folders per TFM and these in props. I have several unresolved concerns about the latter and we're getting indication that having the capability defined at all is urgent.
</Description>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>19/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>296</PullRequestID>
        <IssueID>245</IssueID>
        <Title>Add "Containerizable" capability to light up container tooling</Title>
        <Description>We need to add "Containerizable" capability to light up the container tooling just for .NETCoreApp.
</Description>
        <CreatedDate>11/10/2016</CreatedDate>
        <ClosedDate>19/10/2016</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>296</PullRequestID>
        <IssueID>246</IssueID>
        <Title>We need "XXX.DesignTime.props" per TFM</Title>
        <Description>In the new project system, there is a handshake between projects and tooling called [project capabilities](https://github.com/Microsoft/VSProjectSystem/blob/master/doc/overview/about_project_capabilities.md). 

We've run into the first situation [where we need a capability](https://github.com/dotnet/sdk/issues/245) just for a specific TFM. In the past, we've always had a capability turned on regardless of TFMs.

This presents a little bit of engineering work as we do not have a targets/props file that is per TFM, today it's one file with TFM checks inside of it.  

Given we want capabilities in props - we can't do TFM checks because in the single TFM case it's hasn't been set yet.
</Description>
        <CreatedDate>11/10/2016</CreatedDate>
        <ClosedDate>10/05/2017</ClosedDate>
        <Labels>
          <Label>Feature Request</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>295</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Implicitly define compilation constants for target framework</Title>
    <Description>Fixes #195

The project.json based .NET CLI tooling puts underscores in place of periods in the version numbers for some framework identifiers (`NETSTANDARD1_3`), but not others (`NETCORE45`).  It also uses `NET` as an abbreviation for `.NETFRAMEWORK`.

Here I've simply defined all possibilities, so a library targeting .NET 4.6.1 will have these defines: `NET461`, `NETFRAMEWORK461`, and `NETFRAMEWORK4_6_1`.  A library targeting .NET Standard 2.0 will have `NETSTANDARD20` and `NETSTANDARD2_0` defined.

I also haven't yet figured out a good way to test this.  It gets tested incidentally as part of the preserve compilation context tests.  To directly test it I'd like to be able to build a project and get the list of compilation constants that were used.  Possible ways of doing this could be to parse the log file (ugh!) or to evaluate the project with the MSBuild APIs and get the value of the `DefineConstants` property.
</Description>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>21/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>295</PullRequestID>
        <IssueID>195</IssueID>
        <Title>We should inject implicit TFM DefineConstants</Title>
        <Description>In project.json-based projects, we had automatic defines injected for the TFM. So if I was building for netstandard1.3, there was an implicit define #NETSTANDARD1_3 that I could automatically use in a #if.

We should add this into the dotnet/sdk as well, so developers can easily write code for specific TFMs.
</Description>
        <CreatedDate>29/09/2016</CreatedDate>
        <ClosedDate>21/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>292</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>dsplaisted</FixedByID>
    <Title>Don't delete Stage0 version of .NET SDK NuGet package from cache</Title>
    <Description>This fixes #281 and should make the solution work better in Visual Studio when you do a command-line build.

There's an outstanding question of whether we need to surround the version in brackets when we [set it for the test projects](https://github.com/dotnet/sdk/blob/0708a4f3587c7f8feae778ef6af4441777a9ca55/test/Microsoft.NET.TestFramework/TestAsset.cs#L60) in order to be sure that NuGet doesn't pick a different version.

An alternate solution would be to put something like the following in `Common.props`:

``` xml
&lt;NuGetPackageRoot Condition="'$(BuildingInsideVisualStudio)' == 'true'"&gt;$(UserProfile)\.nuget\packages\&lt;/NuGetPackageRoot&gt;
```

This would get evaluated before the generated NuGet props, and would ensure that the build in Visual Studio always uses the user's package cache, even when a command-line build restores in a context that uses the repo`s packages folder.

I've also included a commit in this PR to update the GUIDs in SDK.sln so that the projects will be loaded with CPS.  This isn't necessary with a change @jinujoseph made last week, but it shouldn't hurt and makes it easier to use the solution until that change makes its way to a build of VS we start using.
</Description>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>292</PullRequestID>
        <IssueID>281</IssueID>
        <Title>Don't delete Stage0 nuget package from the cache</Title>
        <Description>dsplaisted [8:09 PM]  
When I run a build on the SDK, the build and buildCrossTargeting folders are getting deleted from the Stage0 Microsoft.Net.Sdk package folder in the repo-local package cache.  Is this supposed to happen? 

nguerrera [11:31 AM] for Daniel's question. I am also seeing this and it's tripping up VS quite badly. I notice that there's an InvalidatePackageCache target that sometimes warns it can't finish nuking the package.

``

eerhardt [11:37 AM]  
yes, it is intended.  (but we can look at another approaches)
the reason this happens is for testing.  We need to guarantee that our tests resolve the newly built Sdk
and not the Stage0 version from the cache
one option would be just to delete the hash files in the cache.  then NuGet will never use that cached version
another option would be to use separate package caches between the build and the tests
but that has perf drawbacks
another thought I just realized - we could specify [_version_] in the PackageReference
which means "use this version AND ONLY this version"
that seems like the most appropriate to me right now
but we still need to delete the newly built version from the package cache
for incremental dev work purposes
I build clean repo - tests pass
make a change which breaks tests  - tests still pass cuz it uses previously cached version
</Description>
        <CreatedDate>14/10/2016</CreatedDate>
        <ClosedDate>18/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>291</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Enable pack in the SDK by default.</Title>
    <Description>The following issues are being fixed:
- $(AssemblyName) being defined in outer build
- $(OutputPath) being defined in outer build
- The above is fixed by importing Microsoft.NET.Sdk.props in both inner and outer builds.
- Defaulting $(Authors)
- Updating NuGet and the CLI for the latest NuGet logic

Fix #224
Fix #285 

Also fixing https://github.com/dotnet/cli/issues/4425

@nguerrera @rohit21agrawal 

/cc @dotnet/project-system 
</Description>
    <CreatedDate>17/10/2016</CreatedDate>
    <ClosedDate>17/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>291</PullRequestID>
        <IssueID>224</IssueID>
        <Title>OutputPath is not defined in the outer build</Title>
        <Description>There should be a way to obtain the output path in the outer build. 

The reason this is needed is because that's where nupkg will be generated by default. So if the DLL is output to bin\debug\netcoreapp1.0*.dll , there should be a variable in the outer build to provide the path upto bin\debug.

@nguerrera 
</Description>
        <CreatedDate>07/10/2016</CreatedDate>
        <ClosedDate>17/10/2016</ClosedDate>
        <Labels>
          <Label>Bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>291</PullRequestID>
        <IssueID>285</IssueID>
        <Title>dotnet new --type msbuild should be packable</Title>
        <Description>This is a more specific bug for the defaulting of `$(Authors)` and `$(AssemblyName)`. Issue https://github.com/dotnet/sdk/issues/2 is too broad.

Moved from https://github.com/dotnet/cli/issues/4419.
## Steps to reproduce
1. `dotnet new --type msbuild`
2. `dotnet restore3`
3. `dotnet build3`
4. `dotnet pack3`
## Expected  behavior

A .nupkg should be produced.
## Actual behavior

There is an error about missing ID and Authors metadata.

IMHO, `$(AssemblyName)` should be defaulted to the .csproj name without extension (which `build3` seems to figure out in some other way). `$(Authors)` should default to `$(AssemblyName)`.

`project.json` defaulted ID to the project directory name and authors to the project ID.
## Environment data

`dotnet --info` output:

``
</Description>
        <CreatedDate>14/10/2016</CreatedDate>
        <ClosedDate>17/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>283</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>eerhardt</FixedByID>
    <Title>Handle multiple versions of a Library in LockFile.Libraries.</Title>
    <Description>When a project targets multiple TFMs, it can depend on multiple versions of the same Library.  When this happens more than one version shows up in LockFiles.Libraries, which causes our code to throw.

I inspected all the places we use LockFile.Libraries for correctness.

Fix #280 

Note:  I was able to remove the "FindMSBuildProject" code because https://github.com/NuGet/Home/issues/3611 is now fixed.
</Description>
    <CreatedDate>14/10/2016</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>283</PullRequestID>
        <IssueID>280</IssueID>
        <Title>GenerateDepsFile task failing with "System.ArgumentException: An item with the same key has already been added."</Title>
        <Description>## Steps to reproduce

Sorry, wasn't able to make a nice little minimal repro for this one. In PowerShell:
1. `git clone https://github.com/joelverhagen/NuGet.Client.git`
2. `cd NuGet.Client`
3. `git checkout jver/sdk-repro`
4. `cd src\NuGet.Core`
5. `Get-ChildItem .\*.csproj -Recurse | % { dotnet restore3 $_.FullName }`
6. `dotnet build3 NuGet.RuntimeModel\NuGet.RuntimeModel.csproj`
## Expected  behavior

The build should succeed... or at least no fail with this error 😄. I've been working through a lot of failures so it's possible there's another waiting in line.
## Actual behavior

Build fails.

``
</Description>
        <CreatedDate>14/10/2016</CreatedDate>
        <ClosedDate>14/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>282</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>nguerrera</FixedByID>
    <Title>Allow targeting frameworks that are not netstandard compatible</Title>
    <Description>- Move build/netstandard1.0 to build/ root
- Stress net40 and net40-client a bit in tests

@eerhardt @srivatsn @dotnet/project-system @joelverhagen @emarten 

Fix #268 
Fix #270 
</Description>
    <CreatedDate>14/10/2016</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>282</PullRequestID>
        <IssueID>268</IssueID>
        <Title>net40-client class library does not build</Title>
        <Description>## Steps to reproduce
1. `dotnet new --type lib` a project.json
2. Target `net40-client` and `net45`
3. `dotnet migrate`
4. `dotnet build3 -f net45`
5. `dotnet build3 -f net40-client`
## Expected  behavior

Both `net45` and `net40-client` builds should result in a .dll (pass `/target:library` to `csc`).
## Actual behavior

`net45` build works fine. `net40-client` build fails:

``
</Description>
        <CreatedDate>13/10/2016</CreatedDate>
        <ClosedDate>14/10/2016</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>282</PullRequestID>
        <IssueID>270</IssueID>
        <Title>net40 builds output to bin, not bin\net40</Title>
        <Description>## Steps to reproduce
1. `dotnet new` a project.json
2. Target `net40` and `net45` instead of `netstandard1.6`
3. `dotnet migrate`
4. `dotnet build3 -f net45`
5. `dotnet build3 -f net40`
## Expected  behavior

`net45` artifacts should be under `bin\net45`.
`net40` artifacts should be under `bin\net40`.
## Actual behavior

`net45` build works fine. `net40` artifacts are directly under `bin`.
## Environment data

Tried latest SDK package (1.0.0-alpha-20161013-1).

`dotnet --info` output:

``
</Description>
        <CreatedDate>13/10/2016</CreatedDate>
        <ClosedDate>14/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>276</IssueID>
    <RepoID>sdk</RepoID>
    <FixedByID>rainersigwald</FixedByID>
    <Title>Incrementality for CoreGenerateAssemblyInfo</Title>
    <Description>Fixes (the first part of) #275.

The CoreGenerateAssemblyInfo target was always executing and always
writing code to the assemblyinfo source file, causing unnecessary
rebuilds.

Since this solution adopts the standard "all relevant imported projects"
approach to did-a-property-change, I also made sure the
GenerateAssemblyInfo.targets file used that pattern--but I did not check
for that pattern elsewhere.
</Description>
    <CreatedDate>13/10/2016</CreatedDate>
    <ClosedDate>13/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>sdk</RepoID>
        <PullRequestID>276</PullRequestID>
        <IssueID>275</IssueID>
        <Title>Incremental Csc is broken in our SDK</Title>
        <Description>I know this can't be fixed wholly in the `dotnet/sdk`, but this SDK owns this experience, so logging here to track the full end-to-end experience.
## Repro:

``

As you can see, `Csc` is still getting called for subsequent invocations.
</Description>
        <CreatedDate>13/10/2016</CreatedDate>
        <ClosedDate>13/10/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
</PullRequests>