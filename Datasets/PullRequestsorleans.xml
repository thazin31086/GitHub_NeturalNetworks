<PullRequests>
  <PullRequest>
    <IssueID>6431</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove Microsoft prefix from logging categories</Title>
    <Description>See #6430</Description>
    <CreatedDate>25/03/2020</CreatedDate>
    <ClosedDate>25/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6431</PullRequestID>
        <IssueID>6430</IssueID>
        <Title>Avoid most cases of loggers with non-static category names</Title>
        <Description>Replaces #6303
Fixes #6289

There are several instances where some dynamic data is included in the logger name where I left it largely as-is because there should be relatively few instances which do not grow unbounded over the life of a process.

/cc @KevinCathcart </Description>
        <CreatedDate>24/03/2020</CreatedDate>
        <ClosedDate>25/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6430</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Avoid most cases of loggers with non-static category names</Title>
    <Description>Replaces #6303
Fixes #6289

There are several instances where some dynamic data is included in the logger name where I left it largely as-is because there should be relatively few instances which do not grow unbounded over the life of a process.

/cc @KevinCathcart </Description>
    <CreatedDate>24/03/2020</CreatedDate>
    <ClosedDate>25/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6430</PullRequestID>
        <IssueID>6303</IssueID>
        <Title>WIP: Logging categories</Title>
        <Description>Fixes #6289.

The first commit is proposed changes. The second one flags all the dynamic data cases with comments, as some decision still needs to be made for each one.

I've not done anything with the `Microsoft.Orleans.` categories, as I'm not sure if changing them are worth any possible breakage of existing deployment's log filtering schemes. </Description>
        <CreatedDate>13/02/2020</CreatedDate>
        <ClosedDate>25/03/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6430</PullRequestID>
        <IssueID>6289</IssueID>
        <Title>Logging category names are inconsistent</Title>
        <Description>Under Microsoft.Extensions.Logging, it is normal to use a type name complete with namespace, for the logging category.

Most of Orleans does indeed do this, sometimes with fictitious subtype names where it makes sense. That is all good. But there are a surprising number of locations where this is not followed, or has other anomalies.

This includes:
* `RuntimeCodeGen` (No namespace),
* `MembershipOracle` (No Namespace),
* `LeaseBasedQueueBalancer-{name}` (No namespace, use of `-` as separator)
* `AsyncTimer-{name}` (No namespace, use of `-` as separator)
* `SiloHealthMonitor/&lt;SiloAddress&gt;` (no namespace, use of `/` as separator)
* `Orleans.Runtime.ReminderService.GrainBasedReminderTable_&lt;Data.Address&gt;` (use of `_` as seperator)
* `Orleans.Streams.PersistentStreamPullingManager-&lt;streamProviderName&gt;` (use of `-` as separator)
* `Microsoft.Orleans.Networking` (weirdly begins Microsoft.Orleans),
* `Microsoft.Orleans.Messaging.&lt;Subcategories&gt;` (Weirdly begins Microsoft.Orleans).
* `Orleans.RuntimeSiloLogStatistics`/`Orleans.RuntimeClientLogStatistics` (It seems really odd that there is no '.' after Runtime).
* `Orleans.Runtime.Scheduler &lt;SchedulingContext.Name&gt;.WorkItemGroup`, (use of space of seperator. [1])
* Last, but certainly not least, `AsynchAgent` and `TaskSchedulerAgent`, both strip leading "Orleans." off of the type name which ends up getting used by the logger, resulting in categories that begin with `Runtime.`

------

The ones that lack namespaces (or lack the leading `Orleans.`) are obnoxious, as it makes it more difficult to configure the logging level for Orleans internals Separately from the logging level for other parts of the application. I was expected to just be able to configure for `Orleans`, but instead would need `Orleans`, `Runtime`, `Microsoft.Orleans`, and all the class names missing a namespace.

I don't have a problem with separating dynamic data with something other than a simple dot, but currently there is a mixture of `_`, `/`, `-`, space, and sometimes even `.` for that. (Dot is being used to seperate dynamic data more often than any of the others are.)

That said, dynamic values should in logging category names should be used with caution, since using them with an unbounded set of values can effectively be a slow memory leak. See #6096 for details. So dynamic values that have a small fixed set of values, like stream providers, is not a big deal, but including things like grain identity information can be somewhat suspect. Especially concerning is `TransactionalState`, and `TransactionComitter`. 

-----

So what I would like to see happen:
1. Add the namespace to the 5 or so cases that are missing it.
2. Change `AsynchAgent`, and `TaskSchedulerAgent` to use the full namespace as a basis for the logging category.
3. Add the missing dot in `SiloLogStatistics`, and `ClientLogStatistics`, unless that was deliberate.
4. Evaluate usages of dynamic values in category names, and remove them in cases where they are likely to effectively be memory leaks.
5. Consider standardizing the separators used for dynamically determined data in logging category names. (This is not particularly important.)
6. Consider changing the few `Microsoft.Orleans.` categories to just `Orleans.`. (This is definitely not important, and leaving them as-is may make sense, since some people may have these configured specially.)

Footnotes:
[1] Also this actually uses the namespace and type names of the subclass, which is rather odd when the class in question is internal with no subclasses, especially since for non system priority contexts, the hypothetical subclass's name is not used.</Description>
        <CreatedDate>07/02/2020</CreatedDate>
        <ClosedDate>25/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6415</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>MembershipTableCleanupAgent: dispose timer if cleanup is unsupported</Title>
    <Description>Fixes #6410</Description>
    <CreatedDate>20/03/2020</CreatedDate>
    <ClosedDate>20/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6415</PullRequestID>
        <IssueID>6410</IssueID>
        <Title>Timer should have fired at ... which is ~3 hours ago</Title>
        <Description>Hello, my silos seem to be doing fine however I keep getting this warning in logs every ~5 minutes along with the other message saying 

&gt; Watchdog had 1 Health Check Failure(s) out of 5 Health Check Participants.

Should I do something about it? Should it be self-healing? Reboot helps for a couple of days

My setup:
Orleans 3.0
ASP.NET Core 3.0 in Docker on Linux
ADO.NET clustering (MySQL)
3 Silos total, 1 week uptime for each


</Description>
        <CreatedDate>19/03/2020</CreatedDate>
        <ClosedDate>20/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6414</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Allow grain call filters to retry calls</Title>
    <Description>Fixes #6391</Description>
    <CreatedDate>20/03/2020</CreatedDate>
    <ClosedDate>23/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6414</PullRequestID>
        <IssueID>6391</IssueID>
        <Title>Grain calls retry policy</Title>
        <Description>Is there a standard and centralized way to implement retry strategies when calling grain methods from a client or from another grain?

I want to use Polly to retry calls that throw specific exceptions, like `ConnectionFailedException`. But I don't know where to put this code, without doing it manually everywhere I call a grain method.

I tried with an `OutgoingGrainCallFilter`, but it seems `context.Invoke()` cannot be called multiple times.

Thanks in advance for your help!</Description>
        <CreatedDate>11/03/2020</CreatedDate>
        <ClosedDate>23/03/2020</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6397</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Update performance counter dependencies</Title>
    <Description>Fixes #6393</Description>
    <CreatedDate>13/03/2020</CreatedDate>
    <ClosedDate>13/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6397</PullRequestID>
        <IssueID>6393</IssueID>
        <Title>After upgrading from 2.4.5 to 3.1.2,A warning appears:Error initializing CPU &amp; Memory perf counters</Title>
        <Description>This is the log：

warn: Orleans.Statistics.PerfCounterEnvironmentStatistics[100719]
      Error initializing CPU &amp; Memory perf counters - you need to repair Windows perf counter config on this machine with 'lodctr /r' command
System.Runtime.InteropServices.MarshalDirectiveException: Cannot marshal 'parameter #3': Cannot marshal a string by-value with the [Out] attribute.
   at System.StubHelpers.StubHelpers.ThrowInteropParamException(Int32 resID, Int32 paramIdx)
   at System.Management.ManagementPath.GetWbemPath(IWbemPath wbemPath)
   at System.Management.ManagementPath.GetWbemPath()
   at System.Management.ManagementPath.get_Path()
   at System.Management.ManagementScope.set_prvpath(ManagementPath value)
   at System.Management.ManagementScope._Clone(ManagementScope scope, IdentifierChangedEventHandler handler)
   at System.Management.ManagementScope._Clone(ManagementScope scope)
   at System.Management.ManagementObjectSearcher..ctor(ManagementScope scope, ObjectQuery query, EnumerationOptions options)
   at Orleans.Statistics.PerfCounterEnvironmentStatistics.InitCpuMemoryCounters()</Description>
        <CreatedDate>12/03/2020</CreatedDate>
        <ClosedDate>13/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6396</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix System namespace classification in Orleans.CodeGenerator</Title>
    <Description>Addendum to #6394</Description>
    <CreatedDate>13/03/2020</CreatedDate>
    <ClosedDate>13/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6396</PullRequestID>
        <IssueID>6394</IssueID>
        <Title>Omit assembly name for all types from System namespace during codegen</Title>
        <Description>This is a fix for the regression discussed in https://github.com/dotnet/orleans/issues/6392

The fix allows users of Orleans versions prior to 3.1.0 to upgrade without breaking compatibility.
Users of Orleans 3.1.0 and 3.1.2 will experience a degraded rolling upgrade experience.</Description>
        <CreatedDate>12/03/2020</CreatedDate>
        <ClosedDate>12/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6378</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Fix test glitch in PersistenceProvider_Memory_FixedLatency_WriteRead</Title>
    <Description>Failure mode:
```
Write: Expected minimum latency = 00:00:00.2000000 Actual = 00:00:00.1975619

 at Tester.AzureUtils.Persistence.PersistenceProviderTests_Local.PersistenceProvider_Memory_FixedLatency_WriteRead()
    in C:\agent\_work\2\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs:line 237

```

This looks to be caused by a simple system clock resolution / rounding error edge case glitch in the test code.

This is a fix for a test glitch encountered with running Functional tests for PR #6374 </Description>
    <CreatedDate>03/03/2020</CreatedDate>
    <ClosedDate>03/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6378</PullRequestID>
        <IssueID>6374</IssueID>
        <Title>Fix errors reported by GitHub Semmle code analysis tools.</Title>
        <Description>https://lgtm.com/projects/g/dotnet/orleans/?mode=list&amp;severity=error

Fix errors reported by GitHub Semmle code analysis tools:

- Missing X-Frame-Options HTTP header - https://lgtm.com/rules/1506102236348/
- Using a package with a known vulnerability - https://lgtm.com/rules/1506697777412/
- Possible loss of precision - https://lgtm.com/rules/1506096756023/

Ensure Test.cmd clears the `Platform` environment variable (same as in Build.cmd) in case it is run on separate cmd session (eg Appveyor builds)

Remove unused $outDir param from Parallel-Tests.ps1 script.</Description>
        <CreatedDate>01/03/2020</CreatedDate>
        <ClosedDate>04/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6303</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>KevinCathcart</FixedByID>
    <Title>WIP: Logging categories</Title>
    <Description>Fixes #6289.

The first commit is proposed changes. The second one flags all the dynamic data cases with comments, as some decision still needs to be made for each one.

I've not done anything with the `Microsoft.Orleans.` categories, as I'm not sure if changing them are worth any possible breakage of existing deployment's log filtering schemes. </Description>
    <CreatedDate>13/02/2020</CreatedDate>
    <ClosedDate>25/03/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6303</PullRequestID>
        <IssueID>6289</IssueID>
        <Title>Logging category names are inconsistent</Title>
        <Description>Under Microsoft.Extensions.Logging, it is normal to use a type name complete with namespace, for the logging category.

Most of Orleans does indeed do this, sometimes with fictitious subtype names where it makes sense. That is all good. But there are a surprising number of locations where this is not followed, or has other anomalies.

This includes:
* `RuntimeCodeGen` (No namespace),
* `MembershipOracle` (No Namespace),
* `LeaseBasedQueueBalancer-{name}` (No namespace, use of `-` as separator)
* `AsyncTimer-{name}` (No namespace, use of `-` as separator)
* `SiloHealthMonitor/&lt;SiloAddress&gt;` (no namespace, use of `/` as separator)
* `Orleans.Runtime.ReminderService.GrainBasedReminderTable_&lt;Data.Address&gt;` (use of `_` as seperator)
* `Orleans.Streams.PersistentStreamPullingManager-&lt;streamProviderName&gt;` (use of `-` as separator)
* `Microsoft.Orleans.Networking` (weirdly begins Microsoft.Orleans),
* `Microsoft.Orleans.Messaging.&lt;Subcategories&gt;` (Weirdly begins Microsoft.Orleans).
* `Orleans.RuntimeSiloLogStatistics`/`Orleans.RuntimeClientLogStatistics` (It seems really odd that there is no '.' after Runtime).
* `Orleans.Runtime.Scheduler &lt;SchedulingContext.Name&gt;.WorkItemGroup`, (use of space of seperator. [1])
* Last, but certainly not least, `AsynchAgent` and `TaskSchedulerAgent`, both strip leading "Orleans." off of the type name which ends up getting used by the logger, resulting in categories that begin with `Runtime.`

------

The ones that lack namespaces (or lack the leading `Orleans.`) are obnoxious, as it makes it more difficult to configure the logging level for Orleans internals Separately from the logging level for other parts of the application. I was expected to just be able to configure for `Orleans`, but instead would need `Orleans`, `Runtime`, `Microsoft.Orleans`, and all the class names missing a namespace.

I don't have a problem with separating dynamic data with something other than a simple dot, but currently there is a mixture of `_`, `/`, `-`, space, and sometimes even `.` for that. (Dot is being used to seperate dynamic data more often than any of the others are.)

That said, dynamic values should in logging category names should be used with caution, since using them with an unbounded set of values can effectively be a slow memory leak. See #6096 for details. So dynamic values that have a small fixed set of values, like stream providers, is not a big deal, but including things like grain identity information can be somewhat suspect. Especially concerning is `TransactionalState`, and `TransactionComitter`. 

-----

So what I would like to see happen:
1. Add the namespace to the 5 or so cases that are missing it.
2. Change `AsynchAgent`, and `TaskSchedulerAgent` to use the full namespace as a basis for the logging category.
3. Add the missing dot in `SiloLogStatistics`, and `ClientLogStatistics`, unless that was deliberate.
4. Evaluate usages of dynamic values in category names, and remove them in cases where they are likely to effectively be memory leaks.
5. Consider standardizing the separators used for dynamically determined data in logging category names. (This is not particularly important.)
6. Consider changing the few `Microsoft.Orleans.` categories to just `Orleans.`. (This is definitely not important, and leaving them as-is may make sense, since some people may have these configured specially.)

Footnotes:
[1] Also this actually uses the namespace and type names of the subclass, which is rather odd when the class in question is internal with no subclasses, especially since for non system priority contexts, the hypothetical subclass's name is not used.</Description>
        <CreatedDate>07/02/2020</CreatedDate>
        <ClosedDate>25/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6369</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove ProcessExitHandlingOptions</Title>
    <Description>Closes #6270</Description>
    <CreatedDate>28/02/2020</CreatedDate>
    <ClosedDate>28/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6369</PullRequestID>
        <IssueID>6270</IssueID>
        <Title>Remove ProcessExitHandlingOptions</Title>
        <Description>No longer necessary - this is the responsibility of hosting</Description>
        <CreatedDate>30/01/2020</CreatedDate>
        <ClosedDate>28/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6364</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove ClientInvokeCallback</Title>
    <Description>Fixes #6363</Description>
    <CreatedDate>28/02/2020</CreatedDate>
    <ClosedDate>28/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6364</PullRequestID>
        <IssueID>6363</IssueID>
        <Title>Remove ClientInvokeCallback</Title>
        <Description>It has been superseded by grain call filters for a very long time now</Description>
        <CreatedDate>27/02/2020</CreatedDate>
        <ClosedDate>28/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6360</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>alexrp</FixedByID>
    <Title>Expand documentation on client connectivity and dependency injection.</Title>
    <Description>Closes #6359.</Description>
    <CreatedDate>27/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6360</PullRequestID>
        <IssueID>6359</IssueID>
        <Title>Is a ClusterClient expected to recover from intermittent connection issues?</Title>
        <Description>I've seen cohosting and dependency injection examples where people are injecting a singleton `IClusterClient` at startup (which is also what I'm currently doing), but looking through the documentation, I couldn't actually find out whether the client is expected to eventually recover from intermittent connection issues.

This is of course an important guarantee to have since, if the client is *not* guaranteed to recover and one is using a singleton instance, the application would need to be restarted to obtain a working client instance again.

This seems like an obvious enough issue that I would imagine this guarantee is actually there, but I would rest easier knowing for sure whether that's the case.</Description>
        <CreatedDate>27/02/2020</CreatedDate>
        <ClosedDate>27/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6358</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Clear RequestContext after use</Title>
    <Description>Fixes #6353</Description>
    <CreatedDate>27/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6358</PullRequestID>
        <IssueID>6353</IssueID>
        <Title>Clear RequestContext after use</Title>
        <Description>@debmdale mentioned strange behavior in gitter: https://gitter.im/dotnet/orleans?at=5e56d358819be7679e939d4a

It seems that there are cases where `RequestContext` is not being reset after use.

Examples of potential missed cleanup (non-exhaustive):

* https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Catalog/Catalog.cs#L1128
* https://github.com/dotnet/orleans/blob/0099fefe1be345084747a31c5fd8039920b317a9/src/Orleans.Runtime/Core/InsideRuntimeClient.cs#L310</Description>
        <CreatedDate>26/02/2020</CreatedDate>
        <ClosedDate>27/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6357</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Undo unnecessary RequestContext.Clear in networking</Title>
    <Description>See also #5974, which was the original version of this, and what this undoes.
This hasn't been needed since #6014</Description>
    <CreatedDate>27/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6357</PullRequestID>
        <IssueID>5974</IssueID>
        <Title>Clear RequestContext when spawning connections</Title>
        <Description>This was causing reliability issues because new connections could occasionally be started due to a Ping message, which has a `"Ping"` `RequestContext` header set. The connection would then capture that `RequestContext` and would import it into messages created by the `SiloConnection` itself. These messages would then be treated as though they were Ping messages by the remote silo.

Examples of such messages are:
* Rejections for messages destined to an old silo generation
* Directory lookups - this is trickier, it relies on an optimization whereby `IncomingMessageAgent.ReceiveMessage` is called synchronously from the connection 

This would result in timeouts (which can prevent a silo from starting), active silos being declared dead, obscure exceptions such as `Unrecoverable Rejection (info: System.InvalidOperationException: Expected result of type Orleans.GrainDirectory.AddressesAndTag but encountered a null value.)`, and `NullReferenceExceptions` from `ActivationDirectory.FindTarget`</Description>
        <CreatedDate>25/09/2019</CreatedDate>
        <ClosedDate>26/09/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6357</PullRequestID>
        <IssueID>6014</IssueID>
        <Title>Simplify ConnectionListener.RunAsync</Title>
        <Description>Fixing in response to feedback from @davidfowl </Description>
        <CreatedDate>05/10/2019</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6356</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Avoid destructuring in log templates</Title>
    <Description>This was seen to cause an issue in #6314</Description>
    <CreatedDate>26/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6356</PullRequestID>
        <IssueID>6314</IssueID>
        <Title>Client is rejecting when Client is from .NET Framework</Title>
        <Description>Hi, I for forked from Sample Blazor proejct it works well and I add a `.NET Framework` web project with the same confuguration.

I if Client is .NET Core Web project, `ClusterClient.Connect()` works well, but if Client run on `.NET Framework`  Web project, got this error:

 	Client is rejecting message: Request *cli/6d8736a5@b161089d-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: . Reason = Retry count exceeded. Msg is: Request *cli/6d8736a5@b161089d-&gt;S127.0.0.1:30000:0*stg/17/00000011@S00000011 #2: 


and the `Silo` Console show the log:

	The property accessor threw an exception: SocketException

----


The detail Silo log:

    info: Orleans.Hosting.SiloHostedService[0]
        Orleans Silo started.
    info: Microsoft.Orleans.Networking[0]
        Closing connection with remote endpoint 127.0.0.1:28625
    [18:39:28 INF] Closing connection with remote endpoint 127.0.0.1:28625
    info: Microsoft.Orleans.Networking[0]he property accessor threw 
        Connection Local: 127.0.0.1:30000, Remote: 127.0.0.1:28625, ConnectionId: 0HLTL4VVENOV2 terminated
    [18:39:28 INF] Connection {
    "ConnectionId": "0HLTL4VVENOV2",
    "RemoteEndPoint": {
        "AddressFamily": "InterNetwork",
        "Address": {
            "AddressFamily": "InterNetwork",
            "ScopeId": "The property accessor threw an exception: SocketException",
            "IsIPv6Multicast": false,
            "IsIPv6LinkLocal": false,
            "IsIPv6SiteLocal": false,
            "IsIPv6Teredo": false,
            "IsIPv4MappedToIPv6": false,
            "Address": 16777343,
            "$type": "IPAddress"
        },
        "Port": 28625,
        "$type": "IPEndPoint"
    },
    "LocalEndPoint": {
        "AddressFamily": "InterNetwork",
        "Address": {
            "AddressFamily": "InterNetwork",
            "ScopeId": "The property accessor threw an exception: SocketException",
            "IsIPv6Multicast": false,
            "IsIPv6LinkLocal": false,
            "IsIPv6SiteLocal": false,
            "IsIPv6Teredo": false,
            "IsIPv4MappedToIPv6": false,
            "Address": 16777343,
            "$type": "IPAddress"
        },
        "Port": 30000,
        "$type": "IPEndPoint"
    },
    "IsValid": false,
    "$type": "GatewayInboundConnection"
} terminated



I have searched but no related issue,How can I reslove this issue?
</Description>
        <CreatedDate>19/02/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6354</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Add UnregisterMany to IGrainDirectory to support batch unregistrations </Title>
    <Description>Add UnregisterMany to IGrainDirectory to support batch unregistrations.
Rename InCluster to Dht.

This is a followup to #6340.</Description>
    <CreatedDate>26/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6354</PullRequestID>
        <IssueID>6340</IssueID>
        <Title>Basic support for pluggable grain directory</Title>
        <Description>Out of scope for this PR;

- Per grain type directory (will come in another PR)
- CosmosDB implementation
</Description>
        <CreatedDate>25/02/2020</CreatedDate>
        <ClosedDate>26/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6352</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve TLS troubleshooting experience</Title>
    <Description>Fixes #6317</Description>
    <CreatedDate>26/02/2020</CreatedDate>
    <ClosedDate>26/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6352</PullRequestID>
        <IssueID>6317</IssueID>
        <Title>Improve troubleshooting experience for TLS</Title>
        <Description>Currently, authentication errors which occur during TLS negotiation are not clearly visible in logs.

We should improve the experience to assist users in troubleshooting configuration issues.

Eg, recently an internal user hit a permissions issue getting the private key for a certificate. The logs didn't expose the underlying exception, so debugging it wasn't as simple as it should have been.</Description>
        <CreatedDate>19/02/2020</CreatedDate>
        <ClosedDate>26/02/2020</ClosedDate>
        <Labels>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6351</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove new() constraint for grain persistence</Title>
    <Description>See #6334 - though I don't believe this fully resolves the issue

This is a compilation-breaking change for anyone who has a custom IPersistentState/IStorage/IGrainRuntime implementation, but the fix is simple (remove the constraint from the implementation)

I don't consider accepting this PR a given - we can discuss it and decide whether to merge or close it.</Description>
    <CreatedDate>26/02/2020</CreatedDate>
    <ClosedDate>26/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6351</PullRequestID>
        <IssueID>6334</IssueID>
        <Title>Can the 'new()' constraint on IPersistentState&lt;TState&gt; be dropped?</Title>
        <Description>It stands to reason that a constructor needs to be present for serializers to create instances of a type. However, this constraint goes a step further and requires the type and its constructor to be public, which leads to many types being unnecessarily exposed from an assembly. I am not personally aware of any serialization frameworks that require a type's constructor to be *public*, so perhaps this constraint could be dropped?</Description>
        <CreatedDate>22/02/2020</CreatedDate>
        <ClosedDate>24/03/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6342</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Avoid using GrainTimer in non-grain contexts</Title>
    <Description>Fixes #6341</Description>
    <CreatedDate>25/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6342</PullRequestID>
        <IssueID>6341</IssueID>
        <Title>Avoid use of GrainTimer outside of Grain</Title>
        <Description>Currently, the GrainTimer class is used outside the context of a grain in several places in the codebase:

* In Catalog, for the activation collection timer
* In LocalReminderService for both individual reminders as well as the reminder list refresh timer
* In ClientObserverRegistrar, as a refresh timer
* In SystemTarget, used by TypeManager, DeploymentLoadPublisher, and PersistentStreamPullingAgent/Manager

I believe it's good to replace these with a different, non-grain timer mechanism so that we can keep the GrainTimer single-responsibility.
</Description>
        <CreatedDate>25/02/2020</CreatedDate>
        <ClosedDate>27/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6331</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>srollinet</FixedByID>
    <Title>Fix deadlocks with MySQL Storage</Title>
    <Description>Set isolation level to `READ COMMITED` to avoid Gap Lock issues
Fixes #6316</Description>
    <CreatedDate>22/02/2020</CreatedDate>
    <ClosedDate>25/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6331</PullRequestID>
        <IssueID>6316</IssueID>
        <Title>Deadlocks when using MySql with Persistence.AdoNet</Title>
        <Description>I had to migrate one project from Postgres to MySql (MariaDB more precisely) and I had a lot of deadlock problems when massively persisting grain states

The issue is caused by Gap Locks (https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks)

Changing the transaction's isolation level from `REPEATABLE READ` (default in MySql) to `READ COMMITTED` in `WriteToStorage` procedure fixes the problem.

I don't see any advantage to use `REPEATABLE READ` in this context @veikkoeeva any thoughts?

If this solution is ok for you, I'd be happy to make a PR</Description>
        <CreatedDate>19/02/2020</CreatedDate>
        <ClosedDate>25/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6322</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove GrainId clusterId constructor parameter and associated code</Title>
    <Description>As of #6305, the code removed by this PR is no longer useful.</Description>
    <CreatedDate>20/02/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6322</PullRequestID>
        <IssueID>6305</IssueID>
        <Title>Remove current multicluster implementation</Title>
        <Description>This is a preparation step for the future pluggable directory</Description>
        <CreatedDate>14/02/2020</CreatedDate>
        <ClosedDate>20/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6312</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Avoid registering Gateway in DI since it can be null</Title>
    <Description>Workaround for #6276 </Description>
    <CreatedDate>19/02/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6312</PullRequestID>
        <IssueID>6276</IssueID>
        <Title>Autofac compatibilty issue</Title>
        <Description>Hello, I have a issue regarding compatibility with `Autofac` and `GatewayPort = 0`

I cannot figure out how to configure it to play nice with Orleans.
Here is a minimal repro on sample project https://github.com/dotnet/orleans/compare/master...alfeg:autofac-compatilibity?expand=1
exception is  
``
at https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Silo/Silo.cs#L243

Issues is seems to be in registration that return `null`
https://github.com/dotnet/orleans/blob/master/src/Orleans.Runtime/Hosting/DefaultSiloServices.cs#L128 Autofac doesn't like it at all

Is there a sane way to disable Gateway with Autofac?



</Description>
        <CreatedDate>02/02/2020</CreatedDate>
        <ClosedDate>26/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6311</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>OracPrime</FixedByID>
    <Title>Manual stats dump #6310</Title>
    <Description>As per #6310, allow users to dump statistics on demand, rather than just on a timer.
</Description>
    <CreatedDate>18/02/2020</CreatedDate>
    <ClosedDate>18/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6311</PullRequestID>
        <IssueID>6310</IssueID>
        <Title>Ability to dump statistics on demand</Title>
        <Description>I'd quite like to be able to dump statistics at particular times, rather than just wait for a timer to go off.
I'm happy to submit a PR, but wanted to float my design here and see if it meets approval.

The statistics are done by ClientStatisticsManager and SiloStatisticsManager, both of which are internal classes with no public interface.  They are each registered as singletons inthe service container.

I propose defining an IStatisticsManager interface with a single Dump method on it.  Because the context for registering the singletons is different, I believe I can make both ClientStatisticsManager and SiloStatisticsManager implement IStatisticsManager.

Users wishing to use the manual dump would then use code like this

      ISiloHostBuilder builder = new SiloHostBuilder()
                                                         .NormalConfigCalls();
      var host = builder.Build();
      var stats = host.Services.GetService&lt;IStatisticsManager&gt;();

and then stats.Dump() when required.

Does that sound reasonable/correct?
</Description>
        <CreatedDate>18/02/2020</CreatedDate>
        <ClosedDate>18/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6306</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>rallets</FixedByID>
    <Title>Azure queue streams configuration</Title>
    <Description>Following discussion #6300 
Add a new page with some details about usage, configuration and implementation of Azure Queue Streams.</Description>
    <CreatedDate>15/02/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6306</PullRequestID>
        <IssueID>6300</IssueID>
        <Title>How to configure pressure in Azure Streams</Title>
        <Description>I'm using a Persisted stream via Azure Queue, running in Storage Emulator, using a VM as development machine. It looks like the pulling agents are keeping my CPU at 100%, slowing down everything and making difficult to work.
I was wondering if it was possible to change the behaviour of the polling, as example changing the number of pulling agents to 1, with a 1 second interval between each poll. I'm not able to find any documentation about this configuration option.
Thank you</Description>
        <CreatedDate>12/02/2020</CreatedDate>
        <ClosedDate>21/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6302</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Ilchert</FixedByID>
    <Title>Added ability to skip client TLS authentication.</Title>
    <Description>Fixed #6282</Description>
    <CreatedDate>13/02/2020</CreatedDate>
    <ClosedDate>13/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6302</PullRequestID>
        <IssueID>6282</IssueID>
        <Title>Allow omit client certificate when using Tls.</Title>
        <Description>Now there is no way to skip client certificate in the [`TlsClientConnectionMiddleware`](https://github.com/dotnet/orleans/blob/d2b9478be6fb3e237fcdc52093f20bb6b2bbb277/src/Orleans.Connections.Security/Security/TlsClientConnectionMiddleware.cs#L36), but [`AuthenticateAsClientAsync` ](https://docs.microsoft.com/en-us/dotnet/api/system.net.security.sslstream.authenticateasclientasync?view=netcore-3.1) allows you to skip it. [source](https://source.dot.net/#System.Net.Security/System/Net/Security/SslStream.cs,349) </Description>
        <CreatedDate>03/02/2020</CreatedDate>
        <ClosedDate>13/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6301</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Add System.Threading.Tasks.Extensions dependency to Abstractions</Title>
    <Description>Proper fix for Fix for #6296</Description>
    <CreatedDate>12/02/2020</CreatedDate>
    <ClosedDate>12/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6301</PullRequestID>
        <IssueID>6296</IssueID>
        <Title>【V3.1.0-rc1】 Orleans.CodeGenerator failed</Title>
        <Description>Upgrade to V3.1.0-rc1 based on [Orleans.MultiClient failed](https://github.com/lfzm/Orleans.MultiClient)


``</Description>
        <CreatedDate>11/02/2020</CreatedDate>
        <ClosedDate>13/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6299</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>KevinCathcart</FixedByID>
    <Title>Use current element for SimpleQueueCacheCursor.Element</Title>
    <Description>Fixes #6298 
Fixes #6281

For brevity I am `using SQC = SimpleQueueCache; using SQCC = SimpleQueueCacheCursor;`, within this post.

The whole idea of this change is to change SQCC so that its `Element` value always points to the cursors current element, rather than its next value. This change is remarkably small, especially if you do not count the comment changes.

Specifically it has the invariant that: whenever a method is not currently executing, if `current` is not null, then it always equals `Element.Value.Batch`. (Note: Invariant does not need to hold at end of re-entrant calls while some other `SQCC` method is running.) I will informally prove that invariant holds a little further below. I will also informally argue as to why this change is safe.

While there are further changes or refactorings that could be made, I've tried to keep this a minimal change, viewing this as a bug-fix rather than a substantial refactoring.

While I have tried to be thorough in my analysis of the impact of this, it is possible I am overlooking something. If you see (or think you see) any scenarios where this change would break things, please let me know. 

## Why this is safe
`PersistentStreamPullingAgent` will not notice any difference between this version of the code, and the previous one, except as a side effect of any tiny changes in the execution time of the code in question. All calls to `SQC` or `SQCC` will return the same values. They won't always have exactly the same effect, but there is no observable difference from the pulling agent's perspective.

From `SQC`'s perspective, not much changes. It sees one fewer call to `TryGetNextMessage(...)` per cursor, but that would have been the call when `SQCC.current` was not null, but `SQC.Element` is null, so that would be a call that does an early return anyway. It also returns a different value from the `TryGetNextMessage(...)` call, but that does not really impact the rest of the class in any meaningful way.

The real difference to `SQC` is the timing of the remaining calls to `TryGetNextMessage(...)`, which occur one cursor `MoveNext()` cycle later than they previously did, ensuring that that the cursor's `Element` value always contains the current batch being processed, so that batch does not get cleaned up while it is processing. 

For `SQCC`, the semantics of the `Element` property change substantially, to become the current value the cursor is pointing at, rather than the next value. Since `SQC` was already treating the value of `Element` as the current element this is desirable. There are two other minor differences: If `MoveNext()` returns false, the value of `current` is changed to null, rather than remaining the same. This is not an issue since the Enumerator pattern on which the cursors are based already says that the current value is undefined after `MoveNext()` returns false. Similarly upon calling `Dispose()`, the value of `current` is also set to null, which is needed to maintain the invariant, and accessing a cursor after disposing it would be a bug already anyway.

## Proof that the invariant holds
&lt;details&gt;&lt;summary&gt;Proof collapsed by default. Click to Expand&lt;/summary&gt;
Inductive base case: When the `SQCC` class is constructed both values are null, so the invariant holds.

Inductive recursive state: Our goal here is to show that any changes made to the object that impact the fields in question will preserve the invariant, assuming it already holds at the start. 

In all cases where `current` changes it is either being set to `Element.Value.Batch`, or `Element` is also changing at the same time and `current` gets set to the same value. This happens in two places: `SQCC.Dispose(...)` ends up setting both values to null, while `SQCC.MoveNext()` sets `current` to `Element.Value.Batch` if `current` is null, and `Element`. Otherwise it calls `SQC.TryGetNextMessage(...)`, one or many times, and will end up setting `current` to the value it output. `SQC.TryGetNextMessage(...)` will output null if `Element` was already null. In all other cases it will update `Element`, and return `Element.Value.Batch`.

Therefore we can conclude that `current` will never change in a way that will break the invariant. So the invariant can only be broken if `Element` changes while `current` is not null (unless current changes to match). (Note: I am ignoring somebody setting `Element.Value` or `Element.Value.Batch`, since no code actually does that).

So when does `Element` change? It changes when `SQCC.Set(...)` or `SQCC.UnSet(...)` are called. Analyzing these:
* `SQCC.Set(...)` called by:
    * `SQC.AdvanceCursor(...)` which is only called by:
        * `SQC.TryGetNextMessage(...)` which is only called by `SQCC.MoveNext()`, which also changes `current` to match.
    * `SQC.SetCursor(...)` which is only called by:
        * `SQC.InitializeCursor(...)` which is called by:
            * `SQC.GetCacheCursor(...)`, which calls it immediately after constructing `SQCC`, so both `current` and `Element` are null.
            * `SQC.RefreshCursor(...)` which is called by `SQC.Refresh(...)`, but only if `Element` is null. In that case, either `current` is either also null, per the invariant, or something else has already broken the invariant..
* `SQCC.Unset(...)` called by:
    * `SQC.UnsetCursor(...)` which is called by:
        * `SQCC.Dispose(...)` which also sets `current` to match.
        * `SQC.InitializeCursor(...)` which was analyzed above.
        * `SQC.TryGetNextMessage(...)` which was analyzed above.

Thus I have shown that the the invariant holds when constructed, and no method calls modify the the members in question in a way that breaks the invariant, unless the invariant is already broken. Therefore by induction, I have shown that the invariant always holds.
&lt;/details&gt;</Description>
    <CreatedDate>12/02/2020</CreatedDate>
    <ClosedDate>18/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6299</PullRequestID>
        <IssueID>6298</IssueID>
        <Title>Possible issue in SimpleQueueCacheCursor.RecordDeliveryFailure</Title>
        <Description>I'm looking at the code for `SimpleQueueCacheCursor.RecordDeliveryFailure()`. That code is called by the `PersistentStreamPullingAgent` when the current value retrieved from the cursor could not be delivered. The function looks like this:

https://github.com/dotnet/orleans/blob/7090d7dbb62032f664488c38c6fda85bc4cbb45b/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCacheCursor.cs#L111-L120

The confusing thing is that `Element` is documented as pointing to the next element after current. So it would seem like the DeliveryFailure flag is being set on the element after the one that failed. Which might not be much of a problem as long as such an element always exists, and the code that consumes consumes this flag looks ahead (but that would certainly warrant a comment).  However there is not always a next item, and it looks like the code that consumes this (`SimpleQueueCacheItem.DrainBucket`)  does not look ahead.

So am I missing something, or is this buggy?

If this is buggy, fixing this directly seems tricky, because the value in the cursor's `current` field may no longer even be in the cache, since it could be in the previous cache bucket relative to `Element`, and therefore would be eligible for cleanup.
</Description>
        <CreatedDate>11/02/2020</CreatedDate>
        <ClosedDate>18/02/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6299</PullRequestID>
        <IssueID>6281</IssueID>
        <Title>SimpleQueueCache mixes delivery receipts</Title>
        <Description>I need for a custom implementation of IQueueAdapterFactory. In my solution I would like to use SimpleQueueAdapterCache for IQueueAdapterCache GetQueueAdapterCache() method's response. But if I use this implementation I experiences the calls of IQueueAdapterReceiver.MessagesDeliveredAsync(IList&lt;IBatchContainer&gt; messages) are confused.

Expected behavior:
MessagesDeliveredAsync should be called after the subscribed grain processed the IBatchContainer successfully. If the grain throws exception the method shouldn't be called until the retry period (which is 1 min as default) timing out. After the time out the method call shouldn't contain the failed messages. It's important because we can send ACK to the queue after a success message processing.

Current behavior:

1. If there is only one message in the cache it won’t wait to finish processing of it.
2. If there are more than one message in the cache it won’t wait to finish processing of last batch.
3. If processing of any message from the cache is failed the next one batch will be marked as failure (except if the message was the last one in that case nothing will be marked). The marked messages won’t be passed to the MessagesDeliveredAsync method as parameter. So the failed messages will be passed but some of the success won’t be.

Implementation issues:

1. When tries to get the next batch from the cursor here: https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L244
it will remove the cursor from the cached message if it was the last one. This will cause the purge thinks there is no consumer on the message here: https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L92
2. Reason is same as above.
3. Here the cache should filter the failed messages:
https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCache.cs#L121 
But when sets its state here:
https://github.com/dotnet/orleans/blob/9699b6df713e461765a825c2d40af0079f6f18de/src/OrleansProviders/Streams/Common/SimpleCache/SimpleQueueCacheCursor.cs#L118
the Element.Value will point to the next one and not to the “current” variable however the method is called for the “current”.


I created a short code sample for repro:
https://github.com/Gaben007/OrleansCustomStreamProviderTest</Description>
        <CreatedDate>03/02/2020</CreatedDate>
        <ClosedDate>18/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6297</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Add missing dependency to Orleans.CodeGenerator</Title>
    <Description>Fix for #6296

Add System.Threading.Tasks.Extensions as a dependency to Orleans.CodeGenerator</Description>
    <CreatedDate>11/02/2020</CreatedDate>
    <ClosedDate>11/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6297</PullRequestID>
        <IssueID>6296</IssueID>
        <Title>【V3.1.0-rc1】 Orleans.CodeGenerator failed</Title>
        <Description>Upgrade to V3.1.0-rc1 based on [Orleans.MultiClient failed](https://github.com/lfzm/Orleans.MultiClient)


``</Description>
        <CreatedDate>11/02/2020</CreatedDate>
        <ClosedDate>13/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6284</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Add missing reference to Microsoft.Orleans.Persistence.AzureStorage package</Title>
    <Description>Fixes #6283.</Description>
    <CreatedDate>04/02/2020</CreatedDate>
    <ClosedDate>04/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6284</PullRequestID>
        <IssueID>6283</IssueID>
        <Title>HelloWorld sample for dotnetcore 3.0 doesn't work</Title>
        <Description>I'm trying to run BuildAndRun.ps1 for orleans\samples\3.0\HelloWorld and it fails with the following output 

PS C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld&gt; .\BuildAndRun.ps1
  Restore completed in 74.22 ms for C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\HelloWorld.Interfaces\HelloWorld.Interfaces.csproj.
  Restore completed in 89.26 ms for C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\HelloWorld.Grains\HelloWorld.Grains.csproj.
  Restore completed in 89.26 ms for C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\SiloHost\SiloHost.csproj.
  Restore completed in 89.27 ms for C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\OrleansClient\OrleansClient.csproj.
Microsoft (R) Build Engine version 16.4.0+e901037fe for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  HelloWorld.Interfaces -&gt; C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\HelloWorld.Interfaces\bin\Debug\netstandard2.0\HelloWorld.Interfaces.dll
  HelloWorld.Grains -&gt; C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\HelloWorld.Grains\bin\Debug\netstandard2.0\HelloWorld.Grains.dll
  OrleansClient -&gt; C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\OrleansClient\bin\Debug\netcoreapp2.1\OrleansClient.dll
Program.cs(30,26): error CS1061: 'ISiloBuilder' does not contain a definition for 'AddAzureBlobGrainStorage' and no accessible extension method 'AddAzureBlobGrainStorage' accepting a first argument of type 'ISiloBuilder' could be found (are you missing a using directive or an assembly reference?) [C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\SiloHost\SiloHost.csproj]

Build FAILED.

Program.cs(30,26): error CS1061: 'ISiloBuilder' does not contain a definition for 'AddAzureBlobGrainStorage' and no accessible extension method 'AddAzureBlobGrainStorage' accepting a first argument of type 'ISiloBuilder' could be found (are you missing a using directive or an assembly reference?) [C:\Users\shreyagr\source\repos\orleans\Samples\3.0\HelloWorld\src\SiloHost\SiloHost.csproj]
    0 Warning(s)
    1 Error(s)</Description>
        <CreatedDate>04/02/2020</CreatedDate>
        <ClosedDate>04/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6264</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove AsynchAgent, Executor, and related</Title>
    <Description>Note that this is based on #6261, so that must be merged first, after which I will rebase this onto master</Description>
    <CreatedDate>27/01/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6264</PullRequestID>
        <IssueID>6261</IssueID>
        <Title>Schedule Tasks and WorkItems on .NET ThreadPool</Title>
        <Description>This PR schedules Tasks and IWorkItems on the shared .NET ThreadPool instead of the fixed-size thread pool currently used by OrleansTaskScheduler.

The numbers below are from the original PR, which is a combination of this, #6263, and #6264

.NET Framework | Before | After | Improvement
-- | -- | -- | --
Client to Silo | 110100 | 167325 | 52%
Client to 2 Silos | 129940 | 151976 | 17%
Hosted Client | 866952 | 841110 | -3%
Silo to Silo | 136971 | 148303 | 8%

.NET Core 3.1 | Before | After | Improvement
-- | -- | -- | --
Client to Silo | 155065 | 222870 | 44%
Client to 2 Silos | 215204 | 275873 | 28%
Hosted Client | 1300241 | 1367962 | 5%
Silo to Silo | 183478 | 230966 | 26%

I believe this is worth merging even with a degradation in the HostedClient test on .NET Fx. The test I'm using suffers from a noisy neighbor problem because all nodes (clients/silos) are hosted in the same process and therefore sharing the same ThreadPool &amp; resources - so there will be a clear difference between the Before case (where everyone has their own set of dedicated threads) and the After case (where they share one pool).

Distributed Tests:

.NET Framework | Before | After | Improvement
-- | -- | -- | --
NightlyLoadTest | 252802.4 | 304374.3 | 20%
ActivationCollectorStressTest | 319953.9 | 350815 | 10%
PingLoadTest_LocalReentrant | 182881.7 | 214457.2 | 17%
PingLoadTest_RandomReentrant_MultiSilos | 639675 | 665155.5 | 4%

.NET Core 3.1 | Before | After | Improvement
-- | -- | -- | --
NightlyLoadTest | 336430.7 | 423326.2 | 26%
ActivationCollectorStressTest | 379334.4 | 402166.2 | 6%
PingLoadTest_LocalReentrant | 163721.5 | 222958.2| 36%
PingLoadTest_RandomReentrant_MultiSilos | 615306.3 | 644713 | 5%</Description>
        <CreatedDate>25/01/2020</CreatedDate>
        <ClosedDate>21/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6261</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Schedule Tasks and WorkItems on .NET ThreadPool</Title>
    <Description>This PR schedules Tasks and IWorkItems on the shared .NET ThreadPool instead of the fixed-size thread pool currently used by OrleansTaskScheduler.

The numbers below are from the original PR, which is a combination of this, #6263, and #6264

.NET Framework | Before | After | Improvement
-- | -- | -- | --
Client to Silo | 110100 | 167325 | 52%
Client to 2 Silos | 129940 | 151976 | 17%
Hosted Client | 866952 | 841110 | -3%
Silo to Silo | 136971 | 148303 | 8%

.NET Core 3.1 | Before | After | Improvement
-- | -- | -- | --
Client to Silo | 155065 | 222870 | 44%
Client to 2 Silos | 215204 | 275873 | 28%
Hosted Client | 1300241 | 1367962 | 5%
Silo to Silo | 183478 | 230966 | 26%

I believe this is worth merging even with a degradation in the HostedClient test on .NET Fx. The test I'm using suffers from a noisy neighbor problem because all nodes (clients/silos) are hosted in the same process and therefore sharing the same ThreadPool &amp; resources - so there will be a clear difference between the Before case (where everyone has their own set of dedicated threads) and the After case (where they share one pool).

Distributed Tests:

.NET Framework | Before | After | Improvement
-- | -- | -- | --
NightlyLoadTest | 252802.4 | 304374.3 | 20%
ActivationCollectorStressTest | 319953.9 | 350815 | 10%
PingLoadTest_LocalReentrant | 182881.7 | 214457.2 | 17%
PingLoadTest_RandomReentrant_MultiSilos | 639675 | 665155.5 | 4%

.NET Core 3.1 | Before | After | Improvement
-- | -- | -- | --
NightlyLoadTest | 336430.7 | 423326.2 | 26%
ActivationCollectorStressTest | 379334.4 | 402166.2 | 6%
PingLoadTest_LocalReentrant | 163721.5 | 222958.2| 36%
PingLoadTest_RandomReentrant_MultiSilos | 615306.3 | 644713 | 5%</Description>
    <CreatedDate>25/01/2020</CreatedDate>
    <ClosedDate>21/02/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6261</PullRequestID>
        <IssueID>6263</IssueID>
        <Title>Schedule received messages onto .NET ThreadPool</Title>
        <CreatedDate>27/01/2020</CreatedDate>
        <ClosedDate>21/02/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6261</PullRequestID>
        <IssueID>6264</IssueID>
        <Title>Remove AsynchAgent, Executor, and related</Title>
        <Description>Note that this is based on #6261, so that must be merged first, after which I will rebase this onto master</Description>
        <CreatedDate>27/01/2020</CreatedDate>
        <ClosedDate>21/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6259</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Skip flaky EHStatistics_MonitorCalledAccordingly test</Title>
    <Description>This test has been flaky for a long time. See #4594</Description>
    <CreatedDate>24/01/2020</CreatedDate>
    <ClosedDate>24/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6259</PullRequestID>
        <IssueID>4594</IssueID>
        <Title>EHStatistics_MonitorCalledAccordingly intermitently failing</Title>
        <Description>ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.EHStatistics_MonitorCalledAccordingly fails intermittently.

Stacktrace
MESSAGE:
Assert.True() Failure\r\nExpected: True\r\nActual: False
+++++++++++++++++++
STACK TRACE:
at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.AssertCacheMonitorCallCounters(CacheMonitorCounters totalCacheMonitorCallCounters) in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 118 at ServiceBus.Tests.MonitorTests.EHStatisticMonitorTests.&lt;EHStatistics_MonitorCalledAccordingly&gt;d__9.MoveNext() in D:\j\workspace\functional_pr---83d31c72\test\Extensions\ServiceBus.Tests\StatisticMonitorTests\EHStatisticMonitorTests.cs:line 103 --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) --- End of stack trace from previous location where exception was thrown --- at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</Description>
        <CreatedDate>15/05/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P3</Label>
          <Label>bug</Label>
          <Label>test-issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6258</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix codegen incremental rebuild</Title>
    <Description>Fixes #6244</Description>
    <CreatedDate>24/01/2020</CreatedDate>
    <ClosedDate>26/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6258</PullRequestID>
        <IssueID>6244</IssueID>
        <Title>Build not sufficient after changing from release to debug (or vice versa)</Title>
        <Description>In Release build.
Rebuild, Run,
Make a chain in (say) my interfaces assembly, 
Run.  OK.
Switch to debug.
Run.  Build errors as other assemblies aren't seeing the change in the interfaces assembly
Rebuild.
Run. OK.</Description>
        <CreatedDate>16/01/2020</CreatedDate>
        <ClosedDate>26/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6251</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Adds MySqlConnector library using invariant MySql.Data.MySqlConnector</Title>
    <Description>This adds support for MySqlConnector library using MySql.Data.MySqlConnector
invariant string.

Note: MySql.Data.MySqlConnector library uses the same namespace as the
official Oracle library 'MySql.Data.MySql' which has traditionally
interpreted as the invariant name also. Hence in Orleans the invariant
string is different than in the library used. Likely support for
DbProviderFactory changes this as using that one can use load library
separate from the invariant.

Fixes #6230.</Description>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>24/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6251</PullRequestID>
        <IssueID>6230</IssueID>
        <Title>Add MySqlConnector AdoNet Provider</Title>
        <Description>Would it be possible for the next release to add the [MySQLConnector](https://github.com/mysql-net/MySqlConnector) ADO.NET Driver support to Orleans? 

MySQLConnector Provider is a drop in replacement for Oracle's MySQL Provider, but provides true async support (rather than the "sync over async" that Oracle's MySQL Provider implements). 

While the namespaces are unchanged to `MySql.Data.MySqlClient`, using `InvariantNameMySql` is not working, because the provider is [hard-coded](https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/AdoNet/Shared/Storage/DbConnectionFactory.cs#L30) to look for `MySql.Data` assembly, but MySqlConnector assembly is called `MySqlConnector` and hence can't be accessed when using the `AdoNetInvariants.InvariantNameMySql`.

Due to true lack of async support, Oracle's MySQL Provider is 6 times slower than similarly setup MSSQL Provider (a load test on MSSQL Server does run in 22 Seconds where Oracle's MySQL Provider takes 5 minutes and 30 seconds)</Description>
        <CreatedDate>13/01/2020</CreatedDate>
        <ClosedDate>24/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6250</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>TestCluster: support configurators for IHostBuilder &amp; ISiloBuilder</Title>
    <Description>Fixes #5465

Note: this `[Obsolete]`s `ISiloBuilderConfigurator`.

I split this into 2 commits to make it reviewable. The first includes the important changes and the second commit is the test changes for Orleans itself.</Description>
    <CreatedDate>20/01/2020</CreatedDate>
    <ClosedDate>23/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6250</PullRequestID>
        <IssueID>5465</IssueID>
        <Title>Add configuration support for ISiloBuilder to TestClusterBuilder</Title>
        <Description>Hi, in order to configure common options for a "test silo" and a "real silo" -- it would be great if there was some way to configure a `ISiloBuilder` in the same way as `TestClusterBuilder.AddSiloBuilderConfigurator&lt;T&gt;()` is working today.</Description>
        <CreatedDate>22/03/2019</CreatedDate>
        <ClosedDate>23/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6246</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>OracPrime</FixedByID>
    <Title>Change duplicate activation to a debug-level message</Title>
    <Description>#6240 The myriads of messages will now only appear if debug logging is enabled</Description>
    <CreatedDate>17/01/2020</CreatedDate>
    <ClosedDate>17/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6246</PullRequestID>
        <IssueID>6240</IssueID>
        <Title>Myriads of "Tried to create a duplicate activation" messages</Title>
        <Description>I just migrated a project from Orleans 1.5.10 to Orleans 3.0.2.

In a grain I branch off some tasks and await them later which produces myriads of log messages. I simply can reproduce this issue by changing the _Hello World_ project located here: https://github.com/dotnet/orleans/tree/ca20a57c2a4b3a491468708b2e797006a36a01eb/Samples/3.0/HelloWorld

Just replace the code of `HelloGrain.cs` in project `HelloWorld.Grains` with the following snippet:

``

What is happening here? Is there something wrong with my _task branch off_ approach?

Orleans 1.5.10 did not write those log messages.</Description>
        <CreatedDate>15/01/2020</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6242</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove defunct *nix build scripts</Title>
    <Description>Closes #6195</Description>
    <CreatedDate>16/01/2020</CreatedDate>
    <ClosedDate>17/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6242</PullRequestID>
        <IssueID>6195</IssueID>
        <Title>3.0.2 Linux build.sh errors</Title>
        <Description>build.sh doesn't work for 3.0.2 Orleans on Ubuntu 18.04. The file /opt/code/OrleansCrossPlatform.sln.metaproj isn't present on my computer, so I'm pretty sure it's in the docker container. 

ivy@zerofluid:~/orleans-3.0.2$ sudo ./build.sh 
Launching build in Docker Container
Running command: /opt/code/run-build.sh
Using code from: /home/ivy/orleans-3.0.2
Unable to find image 'mcr.microsoft.com/dotnet/core/sdk:3.0' locally
3.0: Pulling from dotnet/core/sdk
16ea0e8c8879: Pull complete 
50024b0106d5: Pull complete 
ff95660c6937: Pull complete 
9c7d0e5c0bc2: Pull complete 
063a4686bd41: Pull complete 
cec5fae69b11: Pull complete 
adbf0f5973d9: Pull complete 
403487be26e6: Pull complete 
Digest: sha256:9491613d05e3684fec39f8e8ca91f7de2ee35cc6503b77739c505c4506ccb9c5
Status: Downloaded newer image for mcr.microsoft.com/dotnet/core/sdk:3.0
Microsoft (R) Build Engine version 16.3.2+e481bbf88 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

/opt/code/OrleansCrossPlatform.sln.metaproj : error MSB4126: The specified solution configuration "|Any CPU" is invalid. Please specify a valid solution configuration using the Configuration and Platform properties (e.g. MSBuild.exe Solution.sln /p:Configuration=Debug /p:Platform="Any CPU") or leave those properties blank to use the default solution configuration. [/opt/code/OrleansCrossPlatform.sln]

Build FAILED.

/opt/code/OrleansCrossPlatform.sln.metaproj : error MSB4126: The specified solution configuration "|Any CPU" is invalid. Please specify a valid solution configuration using the Configuration and Platform properties (e.g. MSBuild.exe Solution.sln /p:Configuration=Debug /p:Platform="Any CPU") or leave those properties blank to use the default solution configuration. [/opt/code/OrleansCrossPlatform.sln]
    0 Warning(s)
    1 Error(s)

Time Elapsed 00:00:00.19</Description>
        <CreatedDate>19/12/2019</CreatedDate>
        <ClosedDate>17/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6238</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>voronov-maxim</FixedByID>
    <Title>Add support Microsoft.Data.SqlClient provider, fix #6229</Title>
    <Description>Fixes #6229 </Description>
    <CreatedDate>15/01/2020</CreatedDate>
    <ClosedDate>21/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6238</PullRequestID>
        <IssueID>6229</IssueID>
        <Title>SiloHostBuilder with Microsoft.Data.SqlClient provider </Title>
        <Description>Thrown System.Collections.Generic.KeyNotFoundException: 'The given key 'Microsoft.Data.SqlClient' was not present in the dictionary.'

Stack trace
``

"Microsoft.Orleans.Core" Version="3.0.2"
dotnet version 3.1.100</Description>
        <CreatedDate>13/01/2020</CreatedDate>
        <ClosedDate>21/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6237</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>A quick fix to add more known connector libraries to ADO.NET</Title>
    <Description>This is a quick fix to add some known alternative connector libraries
to SQL Server and MySQL ADO.NET providers. The values are still hard-coded
and the real fix would to provide similar defaults but have a developer
configuration surface.

Fixes #6229 and #6230.</Description>
    <CreatedDate>15/01/2020</CreatedDate>
    <ClosedDate>15/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6237</PullRequestID>
        <IssueID>6229</IssueID>
        <Title>SiloHostBuilder with Microsoft.Data.SqlClient provider </Title>
        <Description>Thrown System.Collections.Generic.KeyNotFoundException: 'The given key 'Microsoft.Data.SqlClient' was not present in the dictionary.'

Stack trace
``

"Microsoft.Orleans.Core" Version="3.0.2"
dotnet version 3.1.100</Description>
        <CreatedDate>13/01/2020</CreatedDate>
        <ClosedDate>21/01/2020</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6237</PullRequestID>
        <IssueID>6230</IssueID>
        <Title>Add MySqlConnector AdoNet Provider</Title>
        <Description>Would it be possible for the next release to add the [MySQLConnector](https://github.com/mysql-net/MySqlConnector) ADO.NET Driver support to Orleans? 

MySQLConnector Provider is a drop in replacement for Oracle's MySQL Provider, but provides true async support (rather than the "sync over async" that Oracle's MySQL Provider implements). 

While the namespaces are unchanged to `MySql.Data.MySqlClient`, using `InvariantNameMySql` is not working, because the provider is [hard-coded](https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/AdoNet/Shared/Storage/DbConnectionFactory.cs#L30) to look for `MySql.Data` assembly, but MySqlConnector assembly is called `MySqlConnector` and hence can't be accessed when using the `AdoNetInvariants.InvariantNameMySql`.

Due to true lack of async support, Oracle's MySQL Provider is 6 times slower than similarly setup MSSQL Provider (a load test on MSSQL Server does run in 22 Seconds where Oracle's MySQL Provider takes 5 minutes and 30 seconds)</Description>
        <CreatedDate>13/01/2020</CreatedDate>
        <ClosedDate>24/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6236</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Obsolete IGatewayListProvider.IsUpdatable</Title>
    <Description>Also minor cleanup to use async instead of blocking calls

Fixes #6177</Description>
    <CreatedDate>14/01/2020</CreatedDate>
    <ClosedDate>14/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6236</PullRequestID>
        <IssueID>6177</IssueID>
        <Title>Doc states that StaticGatewayListProvider is not updatable though it is not true.</Title>
        <Description>The documentation for "IGatewayListProvider.IsUpdatable" states that "StaticGatewayListProvider is not updatable":
https://github.com/dotnet/orleans/blob/425be00b30f4d3f80f53594134dbe4df5d7b053b/src/Orleans.Core/Messaging/IGatewayListProvider.cs#L27-L31
But the "StaticGatewayListProvider.IsUpdatable" always returns "true":
https://github.com/dotnet/orleans/blob/425be00b30f4d3f80f53594134dbe4df5d7b053b/src/Orleans.Core/Messaging/StaticGatewayListProvider.cs#L29-L32
Issues:
- The statement is not correct.
- If all providers return "true" then this property may not be even needed at all.</Description>
        <CreatedDate>12/12/2019</CreatedDate>
        <ClosedDate>14/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6234</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Avoid capturing ExecutionContext in GrainTimer and other timers</Title>
    <Description>Fixes #5563

This means that `RequestContext` will not automatically flow into timers, etc. My belief is that this is the correct behavior and that the current behavior is a likely source of bugs.</Description>
    <CreatedDate>14/01/2020</CreatedDate>
    <ClosedDate>14/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6234</PullRequestID>
        <IssueID>5563</IssueID>
        <Title>AsyncLocal values flow into timer callbacks and stream observers</Title>
        <Description>The values of AsyncLocals will flow into timer callbacks and stream observers from their registration point. RequestContext uses an AsyncLocal to manage properties, which is probably why they are like this, but it shouldn't affect all AsyncLocals.

This is quite unintuitive for me because I would only expect these to flow whenever I call an async method.

In my project `Trace.Begin` will initialize an AsyncLocal and disposing it will set it back to null.  `$1` is the grain instance and `$2` is the value that was stored in the AsyncLocal (which has been cleared to null).
![](https://files.gitter.im/dotnet/orleans/Kc98/image.png)

When the timer callback is called I see the AsyncLocal value from the point of registration.
![](https://files.gitter.im/dotnet/orleans/n3hk/image.png)

Wrapping the timer registration with the following prevents the values from flowing through:
``</Description>
        <CreatedDate>29/04/2019</CreatedDate>
        <ClosedDate>14/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6233</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove accidental commit of ASPNetCoreHostedServices folder</Title>
    <Description>I just noticed this mistake while looking at our samples folder

This folder was not supposed to be included in the commit of #6130 - it looks like a merge mistake</Description>
    <CreatedDate>14/01/2020</CreatedDate>
    <ClosedDate>14/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6233</PullRequestID>
        <IssueID>6130</IssueID>
        <Title>Added ASP.NET Core co-hosting sample</Title>
        <Description>Pretty straightfoward, this sample shows how to use ASP.NET Core 3.0 with Orleans 3.0 in a hosted service model, where the ASP.NET Core framework runs the silo and client as hosted services, exposing a REST API for the grain.

Signed-off-by: Mike Lloyd &lt;mike@reboot3times.org&gt;</Description>
        <CreatedDate>18/11/2019</CreatedDate>
        <ClosedDate>10/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6221</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add OrleansDebuggerHelper.GetGrainInstance to aid in local debugging</Title>
    <Description>Fixes #6220 
cc @OracPrime

Example usage (from Immediate Window in VS debugger):

```C#
Orleans.Runtime.Utilities.OrleansDebuggerHelper.GetGrainInstance(myGrainReference)
```</Description>
    <CreatedDate>08/01/2020</CreatedDate>
    <ClosedDate>09/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6221</PullRequestID>
        <IssueID>6220</IssueID>
        <Title>Debugger support for interrogating grains</Title>
        <Description>When I'm debugging, I am often working in a single silo.  The methods I am using will typically have some grain references to other grains that I will be calling or have called.  It would be really nice to have a debugger helper that allowed me to go from a grain id to the C# object underlying the grain.  This helper would need to be something that could be evaluated in the immediate or watch windows of the debugger.   If the grain id refers to a non-local grain then clearly it needs to return null or throw an exception.</Description>
        <CreatedDate>08/01/2020</CreatedDate>
        <ClosedDate>09/01/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6217</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Close ConnectionManager later in shutdown stage</Title>
    <Description>Quick fix for #6185</Description>
    <CreatedDate>07/01/2020</CreatedDate>
    <ClosedDate>14/01/2020</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6217</PullRequestID>
        <IssueID>6185</IssueID>
        <Title>Gossiping prints timeout warning during silo shutting down</Title>
        <Description>In Orleans 3.0.2, Liveness Gossip prints timeout warning during shutting down silo host.

In a multiple nodes (6 nodes) cluster, only some nodes received Gossip event, and the other silos fallback to old mechanism (with a lot of ping warnings).

Following log are copied from a local environment.

Environment Summary:
    Two nodes: node 1 is running, node 2 is shutting down
    Azure Storage Simulator, Simple Stream Provider
    Orleans 3.0.2 Debug Build (add some log in Gossip methods, increase gossip timeout to 10 seconds)
    Log Level: Trace
    Silo Port: 20001, 20002
    Gateway Port: 30001, 30002

Brief Logs:
``</Description>
        <CreatedDate>17/12/2019</CreatedDate>
        <ClosedDate>11/02/2020</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6188</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Migrate 'src' subdirectory to new code generator</Title>
    <Description>This paves the way for removing the reflection-based code generator, but also more importantly, for multi-targeting Orleans itself.

Note that this is 2 commits, one of them is from #6184, so that should be merged and this rebased on top of master again before merging.

Third time's the charm 😉</Description>
    <CreatedDate>17/12/2019</CreatedDate>
    <ClosedDate>18/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6188</PullRequestID>
        <IssueID>6184</IssueID>
        <Title>Fix 'dotnet pack --no-build'</Title>
        <Description>Fixes #6073

@pechkarus @turowicz are either of you able to build this PR and test it? I tested locally with the repro sln I posted on the issue thread.

The fix is to use AfterTargets instead of DependsOnTargets. DependsOnTargets will invoke the requisite targets, whereas AfterTargets just signifies sequencing.</Description>
        <CreatedDate>17/12/2019</CreatedDate>
        <ClosedDate>18/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6184</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix 'dotnet pack --no-build'</Title>
    <Description>Fixes #6073

@pechkarus @turowicz are either of you able to build this PR and test it? I tested locally with the repro sln I posted on the issue thread.

The fix is to use AfterTargets instead of DependsOnTargets. DependsOnTargets will invoke the requisite targets, whereas AfterTargets just signifies sequencing.</Description>
    <CreatedDate>17/12/2019</CreatedDate>
    <ClosedDate>18/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6184</PullRequestID>
        <IssueID>6073</IssueID>
        <Title>error NETSDK1085 when creating package using dotnet cli 3.0.100</Title>
        <Description>After updating `dotnet` tools to 3.0.100, creation of NuGet packages started to fail.

Looks like behavior might have changed in dotnet 3.* as compared to 2.* ([see changes](https://github.com/dotnet/sdk/commit/af4fc22af555a2cc647dc533436e764759ad827f)) and now 
`Microsoft.Orleans.CodeGenerator.MSBuild` violates `NoBuild` constraint. I believe this behavior is the same for 2.4.* and 3.0.* of `Microsoft.Orleans.CodeGenerator.MSBuild`.

#### Command: 
``</Description>
        <CreatedDate>29/10/2019</CreatedDate>
        <ClosedDate>18/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6171</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>CodeGen: fix ambiguous reference to Orleans namespace</Title>
    <Description>Fixes #6165

I didn't spot any other instances of the same bug, so hopefully this is it.</Description>
    <CreatedDate>10/12/2019</CreatedDate>
    <ClosedDate>10/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6171</PullRequestID>
        <IssueID>6165</IssueID>
        <Title>"Microsoft.Orleans.CodeGenerator.MSBuild" fails to code generate when "*.Orleans.*" occurs in (at a minimum) grains impls or grains interface namespace</Title>
        <Description>In the process of upgrading to .net core 3.1, and orleans 3.0.1, I ran into an issue with "Microsoft.Orleans.OrleansCodeGenerator.Build" code generation - i believe this has happened previously as this generator relies on a specific version of the framework, and has not yet been released since 3.1.0 dnc was released.

I did not realize there was a second code generator, which seems to be independent of the dnc version - "Microsoft.Orleans.CodeGenerator.MSBuild".

I inquired about this on your [gitter](https://gitter.im/dotnet/orleans?at=5deaed7b26eeb8518f7b7435), but here's the problem described in the link:

* Project was previously working on dnc3.0, using "Microsoft.Orleans.OrleansCodeGenerator.Build"
* Update to dnc3.1, "Microsoft.Orleans.OrleansCodeGenerator.Build" fails on code generation with:
``

This issue ***seems*** to be related to having a namespace in my code `*.Orleans.*`.  I have set up a repro of the issue [here](https://github.com/Kritner-Blogs/OrleansGettingStarted/pull/17/commits/0fcbe07c7a6c3fb824bd49036d43f560e7f0fb23).  Note that in the previous [commit](https://github.com/Kritner-Blogs/OrleansGettingStarted/pull/17/commits/b3b77d3daa1542303406e1b85e95476748a47a11), the code generation worked, prior to my projects containing `*.Orleans.*` in their namespaces.

Without `*.Orleans.*` in namespace:
![image](https://user-images.githubusercontent.com/8814983/70435637-5b07c680-1a55-11ea-982c-b4dd04b70c92.png)


With `*.Orleans.*` in namespace:
![image](https://user-images.githubusercontent.com/8814983/70435536-17ad5800-1a55-11ea-9c63-461f5c436cd3.png)

The runnable projects for this solution are:

* Kritner.OrleansGettingStarted.SiloHost
* Kritner.OrleansGettingStarted.Client

both of which can be run with the basic `dotnet run` from their respective project directories (though note the interfaces and grains projects fail to build on the most up to date commit on that branch... https://github.com/Kritner-Blogs/OrleansGettingStarted/pull/17</Description>
        <CreatedDate>09/12/2019</CreatedDate>
        <ClosedDate>10/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6168</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Specify endpoint AddressFamily in Socket constructor</Title>
    <Description>See #6093</Description>
    <CreatedDate>10/12/2019</CreatedDate>
    <ClosedDate>10/12/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6168</PullRequestID>
        <IssueID>6093</IssueID>
        <Title>IClusterClient in Azure App Service connecting to Silo in a VM</Title>
        <Description>I've got a Orleans silo running on a VM within a VNET with ip address &amp; port 10.1.2.4:30000.
I have an Azure App Service which has been configured with VNET integration to the VM's VNET.
I've currently configured the Network Security Groups &amp; OS Firewalls to allow all connections over the port ranges that the silo has been configured with.

When I attempt to connect a ClusterClient from the .net core web app running in the Azure App Service I get back:
``
Which indicates to me that the App Service is correctly VNET integrated.

I'm also able to successfully connect to the silo with a ClusterClient from my local machine (which has a VPN connection to the VNET), so there isn't an issue with the silo not accepting connections.

Is the IClusterClient meant to be able to run in an Azure App Service ? Does it maybe attempt to listen on a local socket which is not permitted according to the [Azure App Service restrictions](https://github.com/projectkudu/kudu/wiki/Azure-Web-App-sandbox#networking-restrictionsconsiderations)?

Is there some kind of work around, that does not involve having to convert everything to run in the hugely complex Kubernetes/Docker nightmare, or setting up IIS on virtual machines.</Description>
        <CreatedDate>06/11/2019</CreatedDate>
        <ClosedDate>12/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6146</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>One more fix for 3.0.1</Title>
    <Description>Fixed CodeGenerator.MSBuild cannot ResolveAssembly in .NetCore 3.0 (#6143)

(cherry picked from commit 2b0e9e6496ad5c9190100f8b6048e58a987feb36)</Description>
    <CreatedDate>27/11/2019</CreatedDate>
    <ClosedDate>27/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6146</PullRequestID>
        <IssueID>6143</IssueID>
        <Title>Fixed CodeGenerator.MSBuild cannot ResolveAssembly in .NetCore 3.0</Title>
        <Description>In `` ,  because the symbol is still .NETCOREAPP2.0 , this PR has been verified in my project !  </Description>
        <CreatedDate>27/11/2019</CreatedDate>
        <ClosedDate>27/11/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6139</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Redact logged connection string in ADO storage provider during init</Title>
    <Description>Fix for #6134 </Description>
    <CreatedDate>25/11/2019</CreatedDate>
    <ClosedDate>25/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6139</PullRequestID>
        <IssueID>6134</IssueID>
        <Title>ADO.NET persistence logs connection string credentials</Title>
        <Description>I have noticed that the ADO.NET persistence package logs the complete connection string, including credentials. This would seem to be a security risk. We'll only deploy using `Warning` level logging so in practice this won't compromise production credentials, and we use Serilog so I could probably filter that out specifically, but it would probably be much more efficient to redact the content at the log output point. If it matters, I use SQL Server, I don't know if this is a problem with other database packages.

&gt; [08:32:34 INF] Initialized storage provider: ServiceId=XXX ProviderName=Default Invariant=System.Data.SqlClient ConnectionString=Data Source=XXX;Database=XXX;User Id=XXX;Password=XXX;.

</Description>
        <CreatedDate>20/11/2019</CreatedDate>
        <ClosedDate>10/12/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6126</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jsteinich</FixedByID>
    <Title>DynamoDB: support extended membership protocol</Title>
    <Description>Implements the extended membership protocol for DynamoDB.

Fixes #6099 

Still need to go through testing.

I noticed a few things while implementing this:

1. `ReadAll` isn't guaranteed to return all silo entries at the same version. It seemed like other implementations can also be inconsistent, but I'm not familiar enough to say for certain.
2. The Azure implementation seems to be more aggressive at throwing exceptions when rows don't exist than other implementations. I'm not sure what the preference is.
3. `DynamoDBMembershipTable` is getting a bit hard to read with all the low level dynamo db. It could be broken up, but it may be better to use a higher level api. That type of refactoring seems outside the scope of this PR though.</Description>
    <CreatedDate>17/11/2019</CreatedDate>
    <ClosedDate>25/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6126</PullRequestID>
        <IssueID>6099</IssueID>
        <Title>DynamoDB clustering: support extended membership protocol</Title>
        <Description>The current implementation of the DynamoDB clustering provider only supports the initial membership protocol, not the later [extension to the protocol](https://dotnet.github.io/orleans/Documentation/implementation/cluster_management.html#extension-to-totally-order-membership-views) to support totally ordered views of cluster membership.

It's important to support this so that the provider will function correctly.

See this PR which adds such support to Consul: https://github.com/dotnet/orleans/pull/6095</Description>
        <CreatedDate>07/11/2019</CreatedDate>
        <ClosedDate>25/11/2019</ClosedDate>
        <Labels>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6118</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Add information about Shared/Main SQL scripts</Title>
    <Description>Fixes #6117.</Description>
    <CreatedDate>13/11/2019</CreatedDate>
    <ClosedDate>14/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6118</PullRequestID>
        <IssueID>6117</IssueID>
        <Title>Docs: CREATE TABLE OrleansQuery script missing from ADO.NET script links</Title>
        <Description>Release 3.0 removed the scripts from the NuGet packages, but the documentation is missing a link to the "main" script which applies some database settings, and critically, creates the `OrleansQuery` table needed by all the other scripts. Consequently none of the other scripts can be executed for a new database. I only use SQL Server (the script used to be named `SQLServer-Main.sql`) but I assume the same problem applies for the other database types. (Luckily I have this file from some 2.x projects and I'm guessing it didn't change for 3.0.)

The scripts are listed [here](http://dotnet.github.io/orleans/Documentation/clusters_and_clients/configuration_guide/adonet_configuration.html) which are accessed from a link in the docs [here](http://dotnet.github.io/orleans/Documentation/grains/grain_persistence/relational_storage.html#realization-of-the-goals).

I noticed a couple of other minor issues on this page:

The intro paragraph says "The Orleans data storage layout has been explained already in Runtime Tables," but the docs don't contain a topic by that name, that I can find.

The section titled [Realization of the Goals](http://dotnet.github.io/orleans/Documentation/grains/grain_persistence/relational_storage.html#realization-of-the-goals) ends with a invalid link ("included in the database scripts").</Description>
        <CreatedDate>13/11/2019</CreatedDate>
        <ClosedDate>20/11/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6102</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>mindlink</FixedByID>
    <Title>Fix routing of gateway count changed events to registered servi…</Title>
    <Description>Update the `OutsideRuntimeClient` to add registered `GatewayCountChanged` services as handlers of the internal event. This fixes #6098.

Additionally, when disposed remove the registered handlers in cases where the cluster client is disposed and registered handlers live longer.</Description>
    <CreatedDate>08/11/2019</CreatedDate>
    <ClosedDate>15/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6102</PullRequestID>
        <IssueID>6098</IssueID>
        <Title>AddGatewayCountChangedHandler does not work</Title>
        <Description>`AddGatewayCountChangedHandler` doesn't work because the implementation of `OutsideRuntimeClient` doesn't forward on the event like he does for connection lost - https://github.com/dotnet/orleans/blob/c683fa8f2fddf310c2dfc3c9cf43db4fb80be1ad/src/Orleans.Core/Runtime/OutsideRuntimeClient.cs#L121

This means there doesn't seem to be a simple way to know when a connection is re-established? Something that is necessary for client subscription to be resumed.</Description>
        <CreatedDate>07/11/2019</CreatedDate>
        <ClosedDate>15/11/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6095</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Consul: support extended membership protocol</Title>
    <Description>Implements the extended membership protocol (with monotonic versioning) for Consul.

Should fix #6089 - needs verification</Description>
    <CreatedDate>06/11/2019</CreatedDate>
    <ClosedDate>07/11/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6095</PullRequestID>
        <IssueID>6089</IssueID>
        <Title>SiloStatusChangeNotification being hit multiple times</Title>
        <Description>**Environment:**

- 4 Windows Servers (1 silo on each server)
- Consul Clustering
- Ado Reminders (MariaDB)

Current working orleans version 2.3.4 (no issues)
Issues reported once updated to orleans 2.4.3

**Reported Issue:**

MariaDb database being hit by large amounts of select reminders query. (643,945 selects in 40min starting with an empty reminders table, then eventually creating about 60 reminders)

`SELECT 		GrainId, 		ReminderName, 		StartTime, 		Period, 		Version 	FROM OrleansRemindersTable 	WHERE 		ServiceId = 'xxx' AND 'xxx' IS NOT NULL 		AND ((GrainHash &gt; 2107253094 AND 2107253094 IS NOT NULL) 		OR (GrainHash &lt;= -2052557686 AND -2052557686 IS NOT NULL))`

After tuning on Information logs we've seen 'Added Server..' log more than 13,000 times in 40min

`Added Server Sxx.xx.xxx.24:20001:310558213/xA2F1633E. Current view: [Sxx.xx.xxx.21:20001:310557917 -&gt; &lt;MultiRange: Size=x2FE94EF8, %Ring=18.715%&gt;, Sxx.xx.xxx.22:20001:310557967 -&gt; &lt;MultiRange: Size=x3C9921CC, %Ring=23.671%&gt;, Sxx.xx.xxx.24:20001:310558213 -&gt; &lt;MultiRange: Size=x422D3E8A, %Ring=25.850%&gt;, Sxx.xx.xxx.23:20001:310558077 -&gt; &lt;MultiRange: Size=x515050B2, %Ring=31.763%&gt;]`

This log is being called via this call stack: 

SiloStatusListenerManager.Participate.ProcessMembershipUpdates.NotifyObservers -&gt;
VirtualBucketsRingProvider.SiloStatusChangeNotification.**AddServer**.NotifyLocalRangeSubscribers - &gt; RangeChangeNotification.OnRangeChange.ReadAndUpdateReminders.ReadTableAndStartTimers

The log 'Starting VirtualBucketsRingProvider on silo' is only hit 4 times within the 40min session.

What is triggering Silo Status Change Notification? 





</Description>
        <CreatedDate>04/11/2019</CreatedDate>
        <ClosedDate>07/11/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6061</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ry8806</FixedByID>
    <Title>Clarified docs about Azure Table Storage Limits</Title>
    <Description>fixes: #6054 </Description>
    <CreatedDate>22/10/2019</CreatedDate>
    <ClosedDate>22/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6061</PullRequestID>
        <IssueID>6054</IssueID>
        <Title>Docs:  orleans/src/Documentation/grains/grain_persistence/index.md </Title>
        <Description>Is the 64kb Limit for Azure Table storage still valid?

I've been searching the Azure Table Storage docs, but can't find any reference to 64kb being a limit
https://docs.microsoft.com/en-gb/azure/storage/common/storage-scalability-targets#azure-table-storage-scale-targets

Does this mean that the limit in Table Storage has been increased?
If so, let me know and I'll do a PR to change it 😄 </Description>
        <CreatedDate>18/10/2019</CreatedDate>
        <ClosedDate>22/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6056</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>orthrus</FixedByID>
    <Title>Implement CleanupDefunctSiloEntries for Consul membership provider</Title>
    <Description>Implemented IMembershipTable.CleanupDefunctSiloEntries for Consul.
Fixes #5546.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>22/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6056</PullRequestID>
        <IssueID>5546</IssueID>
        <Title>After enabling cleaning of dead entries occour NotImplementedException.</Title>
        <Description>Orleans Version is:2.3.0
Membership:Consul

SiloConfig:
`Configure&lt;ClusterMembershipOptions&gt;(options=&gt; options.DefunctSiloCleanupPeriod=TimeSpan.FromMinutes(3))`

After silo starts, it prompts the following error:

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100662]
      DeleteDeadMembershipTableEntries operation is not supported by the current implementation of IMembershipTable. Disabling the timer now.</Description>
        <CreatedDate>24/04/2019</CreatedDate>
        <ClosedDate>22/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6055</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>orthrus</FixedByID>
    <Title>Implement CleanupDefunctSiloEntries for Consul membership provider</Title>
    <Description>Implemented IMembershipTable.CleanupDefunctSiloEntries for Consul.
Fixes #5546.</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6055</PullRequestID>
        <IssueID>5546</IssueID>
        <Title>After enabling cleaning of dead entries occour NotImplementedException.</Title>
        <Description>Orleans Version is:2.3.0
Membership:Consul

SiloConfig:
`Configure&lt;ClusterMembershipOptions&gt;(options=&gt; options.DefunctSiloCleanupPeriod=TimeSpan.FromMinutes(3))`

After silo starts, it prompts the following error:

fail: Orleans.Runtime.MembershipService.MembershipOracleData[100662]
      DeleteDeadMembershipTableEntries operation is not supported by the current implementation of IMembershipTable. Disabling the timer now.</Description>
        <CreatedDate>24/04/2019</CreatedDate>
        <ClosedDate>22/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6049</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Remove SQL scripts from AdoNet NuGet packages</Title>
    <Description>Based on the discussion in #4867, this PR is a replacement for #6044. It removes SQL scripts from the AdoNet provider packages. The prevailing opinion is that we shouldn't have them pollute the AdoNet packages, and that we don't even want a readme.md there.

We can separately decide how to let developers know where to find the scripts.</Description>
    <CreatedDate>16/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6049</PullRequestID>
        <IssueID>4867</IssueID>
        <Title>Avoiding the OrleansAdoNetContent folder</Title>
        <Description>The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore, and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans, but not for an established project. In my case, the files are possibly harmful, as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Description>
        <CreatedDate>22/08/2018</CreatedDate>
        <ClosedDate>23/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6049</PullRequestID>
        <IssueID>6044</IssueID>
        <Title>[WIP] Move sql scripts into a separate NuGet package</Title>
        <Description>Fixes #4867.</Description>
        <CreatedDate>14/10/2019</CreatedDate>
        <ClosedDate>16/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6045</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Expecho</FixedByID>
    <Title>Added structured logging</Title>
    <Description>Implemented structured logging (see #5865) for the project OrleansProviders. Doing it project by project makes it a bit more manageable than to do the whole lot in one changeset.</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>14/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6045</PullRequestID>
        <IssueID>5865</IssueID>
        <Title>Log parameter names improvement for structured loggers</Title>
        <Description>A lot of log messages use the "old" String.Format syntax, with `{0}`  style parameters 

    Log.Info("Starting AsyncAgent {0} on managed thread {1}", Name, Thread.CurrentThread.ManagedThreadId)

When you use a structured logger, it results in 2 parameters named `0` and `1`, which is not a really useful information.

It can also cause indexation errors if you index the log messages. In my case I use Graylog to manage my logs and I see a lot of indexing errors because the same parameter with name `0` is not always of the same type. (int, string, ...)

This could be replaced by something like

    Log.Info("Starting AsyncAgent {AgentName} on managed thread {ThreadId}", Name, Thread.CurrentThread.ManagedThreadId)

The goal is maybe not to change it everywhere, but at least to improve the most common log messages in a first time and to improve the other logs over time.</Description>
        <CreatedDate>14/08/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6044</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>[WIP] Move sql scripts into a separate NuGet package</Title>
    <Description>Fixes #4867.</Description>
    <CreatedDate>14/10/2019</CreatedDate>
    <ClosedDate>16/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6044</PullRequestID>
        <IssueID>4867</IssueID>
        <Title>Avoiding the OrleansAdoNetContent folder</Title>
        <Description>The solution to #4243 causes repositories and projects to be polluted by the OrleansAdoNetContent folder. One has to employ various hacks to ensure that the folder is removed after package restore, and in the case of `dotnet restore` there doesn't even seem to exist any target to use with AfterTargets to get rid of the files.

I see how the files could be useful for someone just starting out with Orleans, but not for an established project. In my case, the files are possibly harmful, as I'm running on a modified schema and these files would only confuse my colleagues.

A possible solution would be to move the copying of these files into the OrleansSQLUtils project. One can then reference the individual packages to bypass the copying of the SQL files.

Has anyone else spent way too much time fighting these files? :) Any other ideas as to what can be done about it?</Description>
        <CreatedDate>22/08/2018</CreatedDate>
        <ClosedDate>23/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6042</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title> Prevent Orleans + Kestrel from interfering with each other's networking services</Title>
    <Description>This is a quick fix for #6040. Ideally we will implement something more robust and configurable but this will suffice for 3.0.0

Fixes #6040

Note that this is based on top of #6035, so that comes first after which I will rebase this.
</Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6042</PullRequestID>
        <IssueID>6040</IssueID>
        <Title>Orleans + ASP.NET co-hosting can cause NullReferenceException in ASP.NET</Title>
        <Description>This is specific to Orleans 3.0-rc1.

Currently both Orleans &amp; Kestrel register an implementation for `IConnectionListenerFactory`. Both have different requirements of the created ConnectionContexts, however and so when they are both configured on the same `IHostBuilder`/container we can observe `NullReferenceException`s from ASP.NET. Registering them in the reverse order would likely cause similar issues in Orleans.

Example:

``

Kestrel registers an implementation here: https://github.com/aspnet/AspNetCore/blob/00e0b97466a3aa7e535b1e34fb04c11f5970fb28/src/Servers/Kestrel/Kestrel/src/WebHostBuilderKestrelExtensions.cs#L32

Orleans registers an implementation here: https://github.com/dotnet/orleans/blob/e816f02f12df34e9e554ae2b898528c42d9d87a4/src/Orleans.Runtime/Hosting/DefaultSiloServices.cs#L355

We can change our registration to disambiguate it from Kestrel's, but issues may occur with other users of these abstractions. I imagine the problem would also exist with `IConnectionFactory` (eg, maybe Orleans + SignalR).

cc @davidfowl</Description>
        <CreatedDate>11/10/2019</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6042</PullRequestID>
        <IssueID>6040</IssueID>
        <Title>Orleans + ASP.NET co-hosting can cause NullReferenceException in ASP.NET</Title>
        <Description>This is specific to Orleans 3.0-rc1.

Currently both Orleans &amp; Kestrel register an implementation for `IConnectionListenerFactory`. Both have different requirements of the created ConnectionContexts, however and so when they are both configured on the same `IHostBuilder`/container we can observe `NullReferenceException`s from ASP.NET. Registering them in the reverse order would likely cause similar issues in Orleans.

Example:

``

Kestrel registers an implementation here: https://github.com/aspnet/AspNetCore/blob/00e0b97466a3aa7e535b1e34fb04c11f5970fb28/src/Servers/Kestrel/Kestrel/src/WebHostBuilderKestrelExtensions.cs#L32

Orleans registers an implementation here: https://github.com/dotnet/orleans/blob/e816f02f12df34e9e554ae2b898528c42d9d87a4/src/Orleans.Runtime/Hosting/DefaultSiloServices.cs#L355

We can change our registration to disambiguate it from Kestrel's, but issues may occur with other users of these abstractions. I imagine the problem would also exist with `IConnectionFactory` (eg, maybe Orleans + SignalR).

cc @davidfowl</Description>
        <CreatedDate>11/10/2019</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6042</PullRequestID>
        <IssueID>6035</IssueID>
        <Title>Add TLS middleware with sample</Title>
        <Description>This PR adds support for securing client-to-silo and silo-to-silo connections using mutual-TLS.
Adds several `UseTls` methods to `ISiloBuilder`, `IClientBuilder`, and `ISiloHostBuilder`.

TLS can be configured on the silo like so:

``

I understand that this will not suffice for all cases. The `connection` parameter has a `Features` property which allows the users to determine which endpoint is being connected to (among other things). This could be used to determine the correct `TargetHost` value.

Fixes #828

xref https://github.com/aspnet/AspNetCore/issues/12809</Description>
        <CreatedDate>10/10/2019</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6041</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>RozzaysRed</FixedByID>
    <Title>Add warning message at startup</Title>
    <Description>Adding warning message at startup if debug level logging is set and recommends setting log level to info for production.

Addresses #5873 </Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6041</PullRequestID>
        <IssueID>5873</IssueID>
        <Title>Add a warning about runtime running with trace level higher than Info</Title>
        <Description>This was suggested by @EranOfer in https://github.com/dotnet/orleans/issues/5851#issuecomment-520709746</Description>
        <CreatedDate>16/08/2019</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6039</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>rmja</FixedByID>
    <Title>Add section on use of Task.Factory.StartNew()</Title>
    <Description>... with async delegates. Fixes #5977 </Description>
    <CreatedDate>11/10/2019</CreatedDate>
    <ClosedDate>11/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6039</PullRequestID>
        <IssueID>5977</IssueID>
        <Title>Add information about Task.Factory.StartNew gotchas in the docs</Title>
        <Description>The current documentation about running tasks inside a grain (https://dotnet.github.io/orleans/Documentation/grains/external_tasks_and_grains.html) suggests to use `Task.Factory.StartNew()`, but there are some issues regarding this, and it would be nice if those were pointed out in the doc.

Specifically, it should be stated that `Task.Factory.StartNew()` does not natively support async delegates, and so it should be used as `Task.Factory.StartNew(MyMethodAsync).Unwrap()` in this case.</Description>
        <CreatedDate>26/09/2019</CreatedDate>
        <ClosedDate>12/10/2019</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6035</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add TLS middleware with sample</Title>
    <Description>This PR adds support for securing client-to-silo and silo-to-silo connections using mutual-TLS.
Adds several `UseTls` methods to `ISiloBuilder`, `IClientBuilder`, and `ISiloHostBuilder`.

TLS can be configured on the silo like so:

``` C#
var host = new HostBuilder()
    .UseOrleans((context, siloBuilder) =&gt;
    {
        var isDevelopment = context.HostingEnvironment.IsDevelopment();
        siloBuilder
            .UseLocalhostClustering(serviceId: "HelloWorldApp", clusterId: "dev")
            .UseTls(StoreName.My, "fakedomain.faketld", allowInvalid: isDevelopment, StoreLocation.LocalMachine, options =&gt;
            {
                if (isDevelopment)
                {
                    options.AllowAnyRemoteCertificate();
                }
            });
    })
    .ConfigureLogging(logging =&gt; logging.AddConsole())
    .Build();
```

By default, when the `UseTls` extension method is used, both sides of all connections are required to present a certificate.

This adds a new package: `Microsoft.Orleans.Connections.Security` which targets `netcoreapp3.0` ***only*** and therefore .NET Core 3.0 is required to use this functionality.

A sample application is included under Samples\3.0\TransportLayerSecurity.

There are some rough edges here which I would especially like feedback on.  For example, a `TargetHost` must be set whenever a connection is made. I would like to know how users would expect to set this value. In the provided sample the value is set to a fixed value:

``` C#
.UseTls(StoreName.My, "fakedomain.faketld", allowInvalid: true, StoreLocation.LocalMachine, options =&gt;
{
    options.OnAuthenticateAsClient = (connection, sslOptions) =&gt;
    {
        sslOptions.TargetHost = "fakedomain.faketld";
    };
    // NOTE: Do not do this in a production environment
    options.AllowAnyRemoteCertificate();
})
```

I understand that this will not suffice for all cases. The `connection` parameter has a `Features` property which allows the users to determine which endpoint is being connected to (among other things). This could be used to determine the correct `TargetHost` value.

Fixes #828

xref https://github.com/aspnet/AspNetCore/issues/12809</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6035</PullRequestID>
        <IssueID>828</IssueID>
        <Title>Adding optional TLS/encryption to transport channel</Title>
        <Description>Adding TLS option to client-silo and inter-silo communications would make a great end-to-end encryption promise when combined with encryption between silo and storage. It looks like using TLS in socket connections involves adding a configuration option to settings and then applying it to socket connections. Encryption between silos and storage is less clear to me otherwise than that it may require more than simply changing connection string (for instance, here's background material for [Azure Table Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2015/04/28/client-side-encryption-for-microsoft-azure-storage-preview.aspx)).

To get this going, what would be needed to add encryption?
1. Where and what kind of parameters should be added to configuration to support TLS on client-silo and inter-silo communications? It would feel like it's appropriate to allow different settings to apply to option between inter-silo and client-silo communications.
2. Whe are in code are relevant places handling socket communications and apply encryption settings?
3. Some consideration should be given on adding encryption on per-provider basis and maybe separated to their respective tickets, but I'll add here to get things going.
</Description>
        <CreatedDate>22/09/2015</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6032</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Default to cleaning up dead silo entries in the cluster membership table after 7 days</Title>
    <Description>Fixes #5733.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6032</PullRequestID>
        <IssueID>5733</IssueID>
        <Title>Enable membership table cleanup by default</Title>
        <CreatedDate>01/07/2019</CreatedDate>
        <ClosedDate>10/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6031</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Add an explicit reference to Microsoft.Bcl.AsyncInterfaces pack…</Title>
    <Description>Fixes #6028.</Description>
    <CreatedDate>10/10/2019</CreatedDate>
    <ClosedDate>10/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6031</PullRequestID>
        <IssueID>6028</IssueID>
        <Title>Could not load file or assembly 'Microsoft.Bcl.AsyncInterfaces, Dependency missing in Orleans 3.0 RC1?</Title>
        <Description>I might be a bit quick to jump the gun, but i wanted to try out orelans-3.0.0-RC1 after it got released. going from 3.0.0-Beta1 broke to me, seems like Microsoft.Bcl.AsyncInterfaces is missing. 
got this error: 
``
installing it made it work however. Wanted to drop the info somewhere in case it got missing somewhere. Saw no info in the release notes about this</Description>
        <CreatedDate>09/10/2019</CreatedDate>
        <ClosedDate>10/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6024</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Revert #6009 &amp; #6018</Title>
    <Description>We will re-address this in 3.1.0 time frame with additional modifications to support rolling-upgrade from older versions

See #6009
See #6018

Re-opens #5729

Please rebase on top of master</Description>
    <CreatedDate>08/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6024</PullRequestID>
        <IssueID>6009</IssueID>
        <Title>Add missing serializers on internal types</Title>
        <Description>These are being masked by the presence of the ILBasedFallbackSerializer</Description>
        <CreatedDate>03/10/2019</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6024</PullRequestID>
        <IssueID>6018</IssueID>
        <Title>Disable ILBasedSerializer by default</Title>
        <Description>Fixes #5729

Users can re-enable `ILBasedSerializer` by calling `siloBuilder.EnableLegacyILBasedSerializer()` and `clientBuilder.EnableLegacyILBasedSerializer()`</Description>
        <CreatedDate>07/10/2019</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6024</PullRequestID>
        <IssueID>5729</IssueID>
        <Title>Disable ILBasedSerializer by default</Title>
        <Description>In preparation for deletion in 3.0 (#5728). It's been deprecated for some time already.</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>serialization</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6018</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Disable ILBasedSerializer by default</Title>
    <Description>Fixes #5729

Users can re-enable `ILBasedSerializer` by calling `siloBuilder.EnableLegacyILBasedSerializer()` and `clientBuilder.EnableLegacyILBasedSerializer()`</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6018</PullRequestID>
        <IssueID>5729</IssueID>
        <Title>Disable ILBasedSerializer by default</Title>
        <Description>In preparation for deletion in 3.0 (#5728). It's been deprecated for some time already.</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>serialization</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6017</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Support adding [DebuggerStepThrough] to generated classes via project option</Title>
    <Description>Fixes #5001

Enable by adding this to your csproj:

``` xml 
  &lt;PropertyGroup&gt;
    &lt;OrleansCodeGenDebuggerStepThrough&gt;true&lt;/OrleansCodeGenDebuggerStepThrough&gt;
  &lt;/PropertyGroup&gt;
```

With this enabled, all generated `GrainReference`, serializer, and `IGrainMethodInvoker` implementations will be decorated with `[DebuggerStepThrough]`.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6017</PullRequestID>
        <IssueID>5001</IssueID>
        <Title>Add option to Orleans generated code  will be hidden from the debugging process</Title>
        <Description>This is quite helpful when you don’t  want to go to stepping inside of a generated method while debugging.</Description>
        <CreatedDate>18/09/2018</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6016</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>CodeGen: disambiguate parameters with duplicate names</Title>
    <Description>Disambiguate parameters with duplicate names (eg, `Task Foo(int value, int value)`)

Fixes #5936 

Closes #5937</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6016</PullRequestID>
        <IssueID>5936</IssueID>
        <Title>Microsoft.Orleans.CodeGenerator.MSBuild generates invalid code for F# interface methods with multiple unnamed arguments</Title>
        <Description>F# interface declarations allow declaring methods without specifying argument names.
`Microsoft.Orleans.CodeGenerator.MSBuild` generates invalid code for F# interface methods that have multiple unnamed arguments.

Note that `Microsoft.Orleans.CodeGenerator.Build` generates valid code in this scenario. 

Repro PR: #5937</Description>
        <CreatedDate>07/09/2019</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6016</PullRequestID>
        <IssueID>5937</IssueID>
        <Title>Repro for #5936</Title>
        <Description> See #5936 
Note that this repro results in invalid code being generated and thus breaks the build.</Description>
        <CreatedDate>07/09/2019</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6013</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Move from WindowsAzure.Storage library to Microsoft.AzureCosmos.Table and Microsoft.Azure.Storage.* packages.</Title>
    <Description>This is to complete the work started by @seniorquico in #5479.

Marked as WIP for now because there are four functional test failures to investigate, likely test issues.</Description>
    <CreatedDate>05/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6013</PullRequestID>
        <IssueID>5479</IssueID>
        <Title>Update Azure Storage libraries</Title>
        <Description>We keep experiencing the issue described in #5003. The fix in the upstream repo was rejected as the Azure Table storage service/API/SDKs were being transferred from the Azure Storage team to the Cosmos DB team.

The Cosmos DB team has released a new [SDK for Azure Table storage](https://docs.microsoft.com/en-us/azure/cosmos-db/table-sdk-dotnet-standard) with support for .NET Standard. Interestingly, the team chose to release this under a _new_ package ID, [Microsoft.Azure.Cosmos.Table](https://www.nuget.org/packages/Microsoft.Azure.Cosmos.Table), as opposed to updating their existing Microsoft.Azure.CosmosDB.Table package.

Additionally, the Azure Storage SDK has since been broken out into separate packages. We now have:

- [Microsoft.Azure.Storage.Blob](https://www.nuget.org/packages/Microsoft.Azure.Storage.Blob/)
- [Microsoft.Azure.Storage.Common](https://www.nuget.org/packages/Microsoft.Azure.Storage.Common/)
- [Microsoft.Azure.Storage.File](https://www.nuget.org/packages/Microsoft.Azure.Storage.File/)
- [Microsoft.Azure.Storage.Queue](https://www.nuget.org/packages/Microsoft.Azure.Storage.Queue/)

The new Common library contains, `CloudStorageAccount`, `StorageException`, retry policies, etc..

I [took a stab](https://github.com/seniorquico/orleans/tree/update-azure-storage) at updating the package references in the Orleans solution, hoping this will bring a fix to our issue. Unfortunately, I encountered several problems.

First, the new, refactored Azure Storage SDKs have picked up a transitive dependency on Microsoft.Azure.KeyVault.Core with a specified version of "&gt;=1.0.0". NuGet restores the lowest applicable version, 1.0.0. Unfortunately, that particular version does not provide a library under a TFM for .NET Standard. This causes NuGet errors like the following:

&gt; error NU1701: Package 'Microsoft.Azure.KeyVault.Core 1.0.0' was restored using '.NETFramework,Version=v4.6.1' instead of the project target framework '.NETStandard,Version=v2.0'. This package may not be fully compatible with your project.

I had to promote Microsoft.Azure.KeyVault.Core to an explicit dependency to get an updated version with a library under a TFM for .NET Standard. Is there another option besides adding an explicit dependency? If not, is it preferred to specify the oldest or newest version in the new, explicit dependency?

Next, while the Microsoft.Azure.Cosmos.Table library keeps a mostly consistent API with prior versions of WindowsAzure.Storage, all of the "common" classes were duplicated and the namespaces updated. This is problematic, for example, in shared classes like `AzureStorageUtils` where `CloudStorageAccount` and `StorageException` now exist in both the `Microsoft.Azure.Cosmos.Table`
and `Microsoft.WindowsAzure.Storage` namespaces and lead to ambiguous references. I noticed that the Microsoft.Azure.CosmosDB.Table package (which only supports NetFx) was recently updated to take a dependency on Microsoft.Azure.Storage.Common (thus reusing `CloudStorageAccount`, `StorageException`, etc.). I reached out to the Cosmos DB team to see if a similar future is in store for Microsoft.Azure.Cosmos.Table.

Next, the classes `NameValidator` and `StorageErrorCodeStrings` were changed to an `internal` visibility in Microsoft.Azure.Cosmos.Table (they remain `public` in Microsoft.Azure.Storage.Common).

Finally, even though the NuGet package indicates `Microsoft.Azure.Cosmos.Table` is released under an MIT license, the source code is not yet available. I also reached out to the Cosmos DB team for guidance.

So, how to proceed? Should the Blob/Queue code get separated from the Table code? That sounds undesirable _if_ there's some confirmation the Microsoft.Azure.Cosmos.Table library will end up taking on a Microsoft.Azure.Storage.Common dependency. While waiting for a Cosmos DB team response, the refactored Azure Storage SDKs are getting new bug fixes for Blob and Queue. WindowsAzure.Storage appears to be frozen.</Description>
        <CreatedDate>27/03/2019</CreatedDate>
        <ClosedDate>08/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6008</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add regression test for #5243</Title>
    <Description>Closes #5243</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6008</PullRequestID>
        <IssueID>5243</IssueID>
        <Title>MSBuild code generator cannot generate serializer for struct with array field</Title>
        <Description>I changed the code generator in my project to `Microsoft.Orleans.CodeGenerator.MSBuild` hoping to work around some code generation problems I had on my build server. Supposedly, the new code generator is better anyway.

However, it seems that it cannot generate a serializer for a value type containing an array of a "primitive" type. This is the gist of the exception that is thrown by the code generator:

&gt; System.NotSupportedException: Field MyStruct.myArray in type MyStruct is not an INamedTypeSymbol and therefore is not supported. Type is Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol+SZArray

This would be my value type:

``

As far as I can tell the exception is thrown in [SerializerGenerator.IsValueTypeFieldsShallowCopyable](https://github.com/dotnet/orleans/blob/008605e3717ccd5f7396c388090e8c7a6ea1a46c/src/Orleans.CodeGenerator/Generators/SerializerGenerator.cs#L633).

The issue seems to be that the new code generator will only create a serializer if the field can be shallow copied. However, an array of a type that can be shallow copied can also be shallow copied by copying the array. The old code generator didn't have this issue and I hope this can be fixed in the new code generator.</Description>
        <CreatedDate>11/12/2018</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6007</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Avoid generating duplicate method id switch labels</Title>
    <Description>Fixes #5818

Fixes #5295</Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6007</PullRequestID>
        <IssueID>5818</IssueID>
        <Title>Implementing a method in an interface which hides a method in a base interface will cause codegen errors which don't easily give in to human understanding</Title>
        <Description>kidding but having an interface like 

``

Will cause codegen issues using both the `Microsoft.Orleans.CodeGenerator.MSBuild` package and the older one and the error mentions the id of the interface/method being a duplicate but the id cannot be found in codegen, however thanks to @ReubenBond  I found that if you look at the line mentioned, t he method will be there.

Double clicking in VS 2019 does not bring the codegen file up since it is in obj folder so you should know where it is to find it.

Best is to either have an analyzer not allowing methods hiding parent methods (since this is an error most of the times) or at least show an error with the method names involved. IMHO fixing this to generate correct code for it is not even required since almost always you don't want to do this in your interfaces</Description>
        <CreatedDate>01/08/2019</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6007</PullRequestID>
        <IssueID>5295</IssueID>
        <Title>The switch statement contains multiple cases with label value...</Title>
        <Description>Grain interfaces with duplicate/hidden method definitions of a base interface cause invalid code to be generated.

Example:
``

Normal VS setup does cause a warning on the hidden method but that doesn't break compilation. The generated code does.

I'll see if I can get around to a PR. Not sure I'll have time though. :( Likely either deduping in GrainInterfaceCommon.GenerateGrainInterfaceAndMethodSwitch *or*, perhaps more properly, accounting for hidden methods during ID generation in OrleansLegacyCompat.GetMethodId...</Description>
        <CreatedDate>04/01/2019</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6004</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve MethodInfo resolution for grain call filters</Title>
    <Description>Fixes #4233</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6004</PullRequestID>
        <IssueID>4233</IssueID>
        <Title>Generic interface, non-generic grain causes Exception from Method property in interceptor</Title>
        <Description>The following code demonstrates an issue which occurs in `IIncomingGrainCallFilter` implementations when accessing `IGrainCallContext.Method` from a non-generic grain which is called using a generic reference. For example, calling `CaterpillarGrain` below using `IHungryGrain&lt;Apple&gt;` will reproduce this issue.

``

Workaround: Access the grain using a non-generic interface. In the above example, this is `ICaterpillarGrain`

xref: #4178</Description>
        <CreatedDate>15/03/2018</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6003</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Deduplicate test categories</Title>
    <Description>Test cases should be either BVT or Functional but not both. This PR makes removes the Functional trait from test cases which are also marked as BVT.

Fixes #5706</Description>
    <CreatedDate>02/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6003</PullRequestID>
        <IssueID>5706</IssueID>
        <Title>Tests should have one category of BVT, SlowBVT, &amp; Functional</Title>
        <Description>Currently there are at least 400 tests which are in both BVT &amp; Functional categories. There is no need for an overlap: it just slows down test runs

Note: check to make sure no coverage is lost in Azure DevOps (i.e, that build settings are correct to ensure all tests are being run once)</Description>
        <CreatedDate>21/06/2019</CreatedDate>
        <ClosedDate>03/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>6000</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Remove InternalsVisibleTo set for extensions by making necessary internal types public</Title>
    <Description>Fixes #4477.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>6000</PullRequestID>
        <IssueID>4477</IssueID>
        <Title>Orleans Core public surface insufficient for extension development</Title>
        <Description>External and application engineers cannot build extension libraries on Orleans without access to internals.  This is evidenced by our internally maintained extension libraries, many of which require access to Orleans Core internals.

[assembly: InternalsVisibleTo("Orleans.Clustering.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Clustering.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Hosting.AzureCloudServices")]
[assembly: InternalsVisibleTo("Orleans.Persistence.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Persistence.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Reminders.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Reminders.DynamoDB")]
[assembly: InternalsVisibleTo("Orleans.Streaming.AzureStorage")]
[assembly: InternalsVisibleTo("Orleans.Streaming.EventHubs")]
[assembly: InternalsVisibleTo("Orleans.Streaming.SQS")]
[assembly: InternalsVisibleTo("Orleans.TelemetryConsumers.Counters")]
[assembly: InternalsVisibleTo("Orleans.Transactions.DynamoDB")]

Internal access needs be removed for extension libraries.  Where extension libraries currently require internal access, either alternate solutions need be found or the accessed capabilities need be exposed in maintainable public apis.
</Description>
        <CreatedDate>16/04/2018</CreatedDate>
        <ClosedDate>02/10/2019</ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5998</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Propagate message [de]serialization exceptions to callers</Title>
    <Description>Currently when deserialization fails for a response message we do not propagate that deserialization exception to the caller. This PR adds behavior to propate such exceptions back to the original caller.

Fixes #4748

Fixes #5397

xref #5978</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>02/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5998</PullRequestID>
        <IssueID>4748</IssueID>
        <Title>Exception thrown during OnActivateAsync not posted to client?</Title>
        <Description>I try this: a grain implemented Grain(T), while the entity T can not be found in storage during OnActivateAsync, a EntityNotFoundException will be thrown. And the exception will not be posted to the client. How can I handle this error?</Description>
        <CreatedDate>06/07/2018</CreatedDate>
        <ClosedDate>02/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5998</PullRequestID>
        <IssueID>5397</IssueID>
        <Title>Test Reliability: ExceptionPropagation_ClientToGrain_SerializationFailure</Title>
        <Description>UnitTests.General.ExceptionPropagationTests.ExceptionPropagation_ClientToGrain_SerializationFailure is flaky. Example test run: https://ci.dot.net/job/dotnet_orleans/job/master/job/functional_prtest/2578/testReport/junit/UnitTests.General/ExceptionPropagationTests/ExceptionPropagation_ClientToGrain_SerializationFailure/

``</Description>
        <CreatedDate>25/02/2019</CreatedDate>
        <ClosedDate>02/10/2019</ClosedDate>
        <Labels>
          <Label>test-issue</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5998</PullRequestID>
        <IssueID>5978</IssueID>
        <Title>Exception deserialization failure</Title>
        <Description>When the client does not refer to the server's Exception type, Client will fail and timeout error will be raised.I think there should be a general approach.</Description>
        <CreatedDate>26/09/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5997</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add IBinaryTokenStreamReader.Length property</Title>
    <Description>Fixes #5996

cc @SebastianStehle </Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5997</PullRequestID>
        <IssueID>5996</IssueID>
        <Title>Support either Length or number of read bytes for IBinaryTokenStreamReader</Title>
        <Description>Hi,

in 2.X I have written a custom stream as a wrapper around a IBinaryTokenStreamReader for a custom JSON.NET serializer.

https://github.com/Squidex/squidex/blob/master/src/Squidex.Infrastructure/Orleans/StreamReaderWrapper.cs#L59

The Length property has gone and therefore it is not possible to implement the Read method anymore.

I would either need:

1. A Length property in `IBinaryTokenStreamReader`

or 

2. `ReadByteArray` should return the number of read bytes if count is too large.</Description>
        <CreatedDate>01/10/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5995</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Make TestClusterBuilder.AddSiloBuilderConfigurator and TestClusterBuilder.AddClientBuilderConfigurator fluent style APIs</Title>
    <Description>Fixes #5617.</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5995</PullRequestID>
        <IssueID>5617</IssueID>
        <Title>Add fluent support to TestClusterBuilder</Title>
        <Description>The TestClusterBuilder should support fluent method chaining so we can do the following

``
</Description>
        <CreatedDate>17/05/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5994</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove most instances of MarshalByRefObject</Title>
    <Description>Fixes #5700</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5994</PullRequestID>
        <IssueID>5700</IssueID>
        <Title>Remove MarshalByRefObject base classes</Title>
        <Description>We do not need any of our types to subclass `MarshalByRefObject`. We should remove it.</Description>
        <CreatedDate>20/06/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5992</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Move FileLoggerProvider from Core to TestingHost</Title>
    <Description>Fixes #5705</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5992</PullRequestID>
        <IssueID>5705</IssueID>
        <Title>Remove FileLoggerProvider etc</Title>
        <Description>We should rely on an existing providers for tests (eg [`Serilog.Extensions.Logging.File`](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) or at least move it out of `Orleans.Core`.</Description>
        <CreatedDate>21/06/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5990</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[WIP] Remove ILBasedSerializer</Title>
    <Description>Fixes #5728 
Fixes #5729

I'm not sure if we want to keep some of this for implementing backwards-compatible exception serialization properly, but opening for testing anyway</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5990</PullRequestID>
        <IssueID>5728</IssueID>
        <Title>Remove ILBasedSerializer</Title>
        <Description>* [ ] Remove `ILBasedSerializer`
* [ ] Update documentation</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>serialization</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5990</PullRequestID>
        <IssueID>5729</IssueID>
        <Title>Disable ILBasedSerializer by default</Title>
        <Description>In preparation for deletion in 3.0 (#5728). It's been deprecated for some time already.</Description>
        <CreatedDate>27/06/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>serialization</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5989</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add serializer for RegexStreamNamespacePredicate</Title>
    <Description>Fixes #5819</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5989</PullRequestID>
        <IssueID>5819</IssueID>
        <Title>RegexStreamNamespacePredicate is not serializable</Title>
        <Description>When using RegexImplicitStreamSubscriptionAttribute I experienced the following exception  in RegexStreamNamespacePredicate:

``

Initially reported here: https://github.com/OrleansContrib/Orleankka/issues/159 but tracked down to Orleans codebase.</Description>
        <CreatedDate>01/08/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5988</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add additional internal health checks for membership</Title>
    <Description>Fixes #5847 (see also #5987)</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5988</PullRequestID>
        <IssueID>5847</IssueID>
        <Title>IMembershipOracle not added to services in 2.4.0?</Title>
        <Description>Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans`, crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface, `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable&lt;IHealthCheckParticipant&gt;` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?</Description>
        <CreatedDate>11/08/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5988</PullRequestID>
        <IssueID>5987</IssueID>
        <Title>Remove unused IMembershipOracle interface</Title>
        <Description>Fixes #5985

See #5847</Description>
        <CreatedDate>01/10/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5987</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove unused IMembershipOracle interface</Title>
    <Description>Fixes #5985

See #5847</Description>
    <CreatedDate>01/10/2019</CreatedDate>
    <ClosedDate>01/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5987</PullRequestID>
        <IssueID>5985</IssueID>
        <Title>Remove IMembershipOracle</Title>
        <Description>`IMembershipOracle` is no longer used as it has been split up into smaller parts which are each responsible for less. We should remove it for 3.0

Fixes #5847</Description>
        <CreatedDate>30/09/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5987</PullRequestID>
        <IssueID>5847</IssueID>
        <Title>IMembershipOracle not added to services in 2.4.0?</Title>
        <Description>Doing a test-run upgrade to 2.4.0 and my health-check hosted service, which is modeled partially off of the one in Samples\2.3, fails to resolve its dependency on `IMembershipOracle` when using `UseOrleans`, crashing the startup process. I don't see anything in the change log or reviewing the recent commits that indicates registration of this type was removed. I _do_ see that there is now another type implementing the `IHealthCheckParticipant` interface, `MembershipTableManager` (registration of which was added in DefaultSiloServices). I've update my hosted service to expect an `IEnumerable&lt;IHealthCheckParticipant&gt;` instead of just the `IMembershipOracle` and things are working smoothly now. Would this be the suggested work around?</Description>
        <CreatedDate>11/08/2019</CreatedDate>
        <ClosedDate>01/10/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5963</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>tcz717</FixedByID>
    <Title>Fix Connect blocked when ConnectAsync completed synchronously</Title>
    <Description>Fix for #5158

Acccodring to [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket.connectasync?view=netcore-2.2), `ConnectAsync(SocketAsyncEventArgs)` will return bool 

&gt; true if the I/O operation is pending. The Completed event on the e parameter will be raised upon completion of the operation.
&gt; 
&gt; false if the I/O operation completed synchronously. In this case, The Completed event on the e parameter will not be raised and the e object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.

In windows, looks like `ConnectAsync` will alwasy return true (pending) even if operation is done immediately https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncEventArgs.Windows.cs#L163-L164 . 

But in Linux host, the [corefx](https://github.com/dotnet/corefx/blob/d391103/src/System.Net.Sockets/src/System/Net/Sockets/SocketAsyncContext.Unix.cs#L14-L33) says:
```csharp
    // The asynchronous socket operations here generally do the following:
    // (1) If the operation queue is Ready (queue is empty), try to perform the operation immediately, non-blocking.
    // If this completes (i.e. does not return EWOULDBLOCK), then we return the results immediately
    // for both success (SocketError.Success) or failure.
    // No callback will happen; callers are expected to handle these synchronous completions themselves.
```

That means if operation completed synchronously, the Completed callback will be never invoked, which will make `AutoResetEvent.WaitOne` keeping waiting until timeout. That's why the server did not receive `Preamble` and timeout [here](https://github.com/dotnet/orleans/blob/v2.4.2/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L207)

I see you plan to rewrite network stack in 3.0.0. I don't if this bug will be solved. But as for 2.x version, my possible solution is to change Connect method https://github.com/dotnet/orleans/blob/2.4.3/src/Orleans.Core/Messaging/SocketManager.cs#L196-L209 like 
```csharp
        internal static void Connect(Socket s, IPEndPoint endPoint, TimeSpan connectionTimeout)
        {
            var signal = new AutoResetEvent(false);
            var e = new SocketAsyncEventArgs();
            e.RemoteEndPoint = endPoint;
            e.Completed += (sender, eventArgs) =&gt; signal.Set();
            bool pending = s.ConnectAsync(e);

            if (pending &amp;&amp; !signal.WaitOne(connectionTimeout))
                throw new TimeoutException($"Connection to {endPoint} could not be established in {connectionTimeout}");

            if (e.SocketError != SocketError.Success || !s.Connected)
                throw new OrleansException($"Could not connect to {endPoint}: {e.SocketError}");
        }
```</Description>
    <CreatedDate>19/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5963</PullRequestID>
        <IssueID>5158</IssueID>
        <Title>Client connection using AdoNetClustering  fails on Docker container</Title>
        <Description>- Used Orleans 2.1.0. 
- Run on .NET Core 2.1, Docker linux container.

[orleans.log](https://github.com/dotnet/orleans/files/2542565/orleans.log)
(frontend is Orleans Client app. backend is silo. Db is Postgresql)

Using StaticClustering configuration runs perfectly.

I saw an issue similar with this at https://github.com/Azure/service-fabric-issues/issues/1182</Description>
        <CreatedDate>02/11/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5959</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Remove activation from message target list if constructor threw an ex…</Title>
    <Description>Fix for #5947

StatelessWorker and "regular" Grain are in fact impacted by this bug. We never saw this behavior for Grains since if the constructor throw, they are not registered in the directory, whereas StatelessWorker doesn't use the directory.</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5959</PullRequestID>
        <IssueID>5947</IssueID>
        <Title>Exception thrown from constructor of stateless worker grain eventually freezes grain call</Title>
        <Description>I have found a bug that requires a silo restart to resolve (tested with Orleans versions 1.5.3 and 1.5.9).

You can simply reproduce the bug with the [_HelloWorld_](https://github.com/dotnet/orleans/tree/v1.5.9/Samples/HelloWorld) sample project.

I used the `HelloWorld.SeparateProcess` solution, but I think this doesn't make a difference. At first change the `DoClientWork` method in file `Program.cs` of project `OrleansClient` like this:
``

When running the silo and client, an `OrleansException` is propagated to the client, **but only for 4 iterations**. After that, the client call `var response = await friend.SayHello("Good morning, my friend!");` freezes.

I think the number of 4 has a reason: I run the silo on a Quad Core processor, and as far as I know, Orleans activates a stateless worker with a specific key on each core. Here the key is `0`, which means, 4 grain instances of the stateless worker are tried to instantiate, and then further tries are blocked.

Of course, it is a bad idea to throw an exception from a grain constructor, but we had an issue where this was the case and wondered why our services stopped. Even if the condition that raised the bug in the constructor disappeard, the grain was never again tried to activate.

**FYI**: I tested the same scenario with the `OnActivateAsync` method (throwing an exception from there), but in this case the bug does not occur. So I don't think this bug is related to https://github.com/dotnet/orleans/issues/4748.</Description>
        <Code>```csharp
private static async Task DoClientWork()
{
  var friend = GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0);

  while (true)
  {
    try
    {
      // example of calling grains from the initialized client
      var response = await friend.SayHello("Good morning, my friend!");
      Console.WriteLine("\n\n{0}\n\n", response);
    }
    catch (Exception exc)
    {
      Console.WriteLine(exc);
    }

    Console.WriteLine("Press RETURN to repeat.");
    Console.ReadLine();
  }
}
```

This will run the grain call in a loop.

Now add a constructor that throws an exception to class `HelloGrain` of project `HelloWorldGrains`:

```csharp
public HelloGrain()
{
  throw new Exception("Intentionally thrown.");
}
```

When running the silo and client, everything works as expected: an `OrleansException`, which contains the thrown exception as an inner exception, is propagated to the client.

So far, so good.

Now make the `HelloGrain` a _stateless worker_:

```csharp
[StatelessWorker]
public class HelloGrain : Orleans.Grain, IHello
{
  // ...
}
`</Code>
        <CreatedDate>12/09/2019</CreatedDate>
        <ClosedDate>16/09/2019</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5958</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Remove activation from message target list if constructor threw an exception</Title>
    <Description>Fix for #5947

`StatelessWorker` and "regular" `Grain` are in fact impacted by this bug. We never saw this behavior for `Grains` since if the constructor throw, they are not registered in the directory, whereas `StatelessWorker` doesn't use the directory.</Description>
    <CreatedDate>16/09/2019</CreatedDate>
    <ClosedDate>16/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5958</PullRequestID>
        <IssueID>5947</IssueID>
        <Title>Exception thrown from constructor of stateless worker grain eventually freezes grain call</Title>
        <Description>I have found a bug that requires a silo restart to resolve (tested with Orleans versions 1.5.3 and 1.5.9).

You can simply reproduce the bug with the [_HelloWorld_](https://github.com/dotnet/orleans/tree/v1.5.9/Samples/HelloWorld) sample project.

I used the `HelloWorld.SeparateProcess` solution, but I think this doesn't make a difference. At first change the `DoClientWork` method in file `Program.cs` of project `OrleansClient` like this:
``

When running the silo and client, an `OrleansException` is propagated to the client, **but only for 4 iterations**. After that, the client call `var response = await friend.SayHello("Good morning, my friend!");` freezes.

I think the number of 4 has a reason: I run the silo on a Quad Core processor, and as far as I know, Orleans activates a stateless worker with a specific key on each core. Here the key is `0`, which means, 4 grain instances of the stateless worker are tried to instantiate, and then further tries are blocked.

Of course, it is a bad idea to throw an exception from a grain constructor, but we had an issue where this was the case and wondered why our services stopped. Even if the condition that raised the bug in the constructor disappeard, the grain was never again tried to activate.

**FYI**: I tested the same scenario with the `OnActivateAsync` method (throwing an exception from there), but in this case the bug does not occur. So I don't think this bug is related to https://github.com/dotnet/orleans/issues/4748.</Description>
        <Code>```csharp
private static async Task DoClientWork()
{
  var friend = GrainClient.GrainFactory.GetGrain&lt;IHello&gt;(0);

  while (true)
  {
    try
    {
      // example of calling grains from the initialized client
      var response = await friend.SayHello("Good morning, my friend!");
      Console.WriteLine("\n\n{0}\n\n", response);
    }
    catch (Exception exc)
    {
      Console.WriteLine(exc);
    }

    Console.WriteLine("Press RETURN to repeat.");
    Console.ReadLine();
  }
}
```

This will run the grain call in a loop.

Now add a constructor that throws an exception to class `HelloGrain` of project `HelloWorldGrains`:

```csharp
public HelloGrain()
{
  throw new Exception("Intentionally thrown.");
}
```

When running the silo and client, everything works as expected: an `OrleansException`, which contains the thrown exception as an inner exception, is propagated to the client.

So far, so good.

Now make the `HelloGrain` a _stateless worker_:

```csharp
[StatelessWorker]
public class HelloGrain : Orleans.Grain, IHello
{
  // ...
}
`</Code>
        <CreatedDate>12/09/2019</CreatedDate>
        <ClosedDate>16/09/2019</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5949</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Frank-Krick</FixedByID>
    <Title>Remove packages OrleansSqlUtils and OrleansAWSUtils from OrleansCross…</Title>
    <Description>…Platform.sln to make build possible after #5946</Description>
    <CreatedDate>13/09/2019</CreatedDate>
    <ClosedDate>13/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5949</PullRequestID>
        <IssueID>5946</IssueID>
        <Title>Remove AWS, Service Fabric, &amp; ADO.NET metapackages</Title>
        <Description>Removes the following metapackages (packages which exist only to pull in other packages and have no content of their own):

* [`Microsoft.Orleans.OrleansSqlUtils`](https://www.nuget.org/packages/Microsoft.Orleans.OrleansSqlUtils)
* [`Microsoft.Orleans.OrleansAWSUtils`](https://www.nuget.org/packages/Microsoft.Orleans.OrleansAWSUtils)
* [`Microsoft.Orleans.ServiceFabric`](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric)</Description>
        <CreatedDate>11/09/2019</CreatedDate>
        <ClosedDate>11/09/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5944</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Update Microsoft.CodeAnalysis packages</Title>
    <Description>Fixes #5834</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5944</PullRequestID>
        <IssueID>5834</IssueID>
        <Title>Nullable reference types are unsupported</Title>
        <Description>C# 8.0 is still in preview, I know... We're getting closer to the release of .NET Core 3.0 and C# 8.0, though!

I'm using C# 8 and enabled `Nullable`. Now hitting a small roadblock while designing some Grain API: I use nullable reference types as part of the Grain interfaces to ensure me and my colleagues have a codified contract with regard to the nullability of that API's parameters and its return value.

The MSBuild codegen of Orleans results in lines like this:
``
(Unrelated: The space after the question mark - strange quirk all nullable reference types have in the generated code.)

And turns out while that is still marked as an open question https://github.com/dotnet/csharplang/issues/2201 for the lang team, the compiler team went ahead and resolved it, by making `typeof` of a nullable reference type a compiler error https://github.com/dotnet/roslyn/pull/35001.

Can Orleans instead just work with `typeof(T)` instead of `typeof(T?)` in this auto-generated code? As noted in the compiler PR above this basically is the same type in the type system anyway:
&gt; The reason is for this apparent inconsistency is that it's actually in line with previous decisions. The root problem we're trying to address here is that parts of the C# type system aren't reflected in the runtime type system. Hence `typeof(List&lt;string?&gt;)` and `typeof(List&lt;string&gt;)` will have the same value.
&gt; https://github.com/dotnet/roslyn/issues/29894#issuecomment-482274990

@ReubenBond was so kind and already chimed in on gitter:
&gt; @bddckr I was asking myself yesterday "how long until someone opens an issue on nullable reference type support?" 😜
&gt; 
&gt; Hopefully it's simple enough to fix (would you like to take a stab at it?), but I anticipate a few issues. The notnull type constraint will be another
&gt; https://gitter.im/dotnet/orleans?at=5d4b1564d03a7c63e6e81cc8

&gt; @bddckr if for example the user creates some container type, `MyContainer&lt;T&gt; where T : notnull` there may be some requirement for generated code to also include nullability assertions. It may be easier to just disable nullable reference types for the generated files, but it's possible that the user would have generic grain methods or grain interfaces which have those `notnull` constraints, so in that case we likely would need to copy the constraints onto the generated classes (GrainReference impl, for ex). We already do that for other constraints. I think there are other new constraints which we need to handle (`enum`?)
&gt; https://gitter.im/dotnet/orleans?at=5d4b18fc2612bb718c2862de


I don't think the _attributes_ would change much really - Orleans is only generating this for serialization AFAICS. I don't believe any serialization in C# was updated yet for nullable ref types, so we might just get away with it as they'll all do...

`notnull` as mentioned by Reuben is actually special - it's a language keyword, allowing a type parameter to be constrained.

---

I'm actively trying to work on this and will be reporting back in here. Hopefully it won't be too much work 🤞</Description>
        <CreatedDate>07/08/2019</CreatedDate>
        <ClosedDate>11/09/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5943</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Upgrade to .NET Core 3.0-preview9 release train</Title>
    <Description>Upgrades packages to 3.0-preview9 and fixes some associated issues:

Fixes #5925 - Unable to use TestSilo on 3.0 (Removal of internal `NullScope.Instance` from logging)
Fixes #5611 - Exceptions when using aspnetcore preview 5 (Dependency Injection validation issue)</Description>
    <CreatedDate>11/09/2019</CreatedDate>
    <ClosedDate>26/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5943</PullRequestID>
        <IssueID>5925</IssueID>
        <Title>Unable to use TestSilo on 3.0</Title>
        <Description>According to this https://github.com/dotnet/orleans/blob/dad62cc16d4d6de671563f6b1e54196f617926a5/src/Orleans.Core/Logging/FileLogger.cs#L141 it looks like we're depending on the _old_ pubternal types there were all removed on .Net Core 3.0. 

With that we're unable to run unit test using the TestCluster as it fail to start with this:

``

According to https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.abstractions.internal.nullscope?view=aspnetcore-2.2&amp;viewFallbackFrom=aspnetcore-3.0 the type indeed was removed...

Any workarounds for now?

Thanks!</Description>
        <CreatedDate>31/08/2019</CreatedDate>
        <ClosedDate>26/09/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5943</PullRequestID>
        <IssueID>5611</IssueID>
        <Title>Exceptions when using aspnetcore preview 5</Title>
        <Description>Hello

I just made the simplest app possible with orleans and aspnetcore preview 5

``

it threw this when I started it:

`System.AggregateException: 'Some services are not able to be constructed (Error while validating the service descriptor 'ServiceType: Orleans.Streams.Core.IStreamSubscriptionHandleFactory Lifetime: Singleton ImplementationType: Orleans.Streams.StreamSubscriptionHandlerFactory': Unable to resolve service for type 'Orleans.Streams.IStreamProvider' while attempting to activate 'Orleans.Streams.StreamSubscriptionHandlerFactory'.)`</Description>
        <CreatedDate>13/05/2019</CreatedDate>
        <ClosedDate>26/09/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5940</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Revert "Bound retries for failed send in ClientMessageCenter and simplify (#5893)"</Title>
    <Description>This PR (#5893) appears to have destabilized our reliability tests. Let's revert and redo it.</Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>09/09/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5940</PullRequestID>
        <IssueID>5893</IssueID>
        <Title>Bound retries for failed send in ClientMessageCenter and simplify</Title>
        <Description>It's possible for the client to get into a loop when it's unable to find an available gateway. This PR bounds the number of send attempts and attempts to simplify the ClientMessageCenter code for managing gateways by using a lock instead of CompareExchange</Description>
        <CreatedDate>22/08/2019</CreatedDate>
        <ClosedDate>06/09/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5937</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Repro for #5936</Title>
    <Description> See #5936 
Note that this repro results in invalid code being generated and thus breaks the build.</Description>
    <CreatedDate>07/09/2019</CreatedDate>
    <ClosedDate>07/10/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5937</PullRequestID>
        <IssueID>5936</IssueID>
        <Title>Microsoft.Orleans.CodeGenerator.MSBuild generates invalid code for F# interface methods with multiple unnamed arguments</Title>
        <Description>F# interface declarations allow declaring methods without specifying argument names.
`Microsoft.Orleans.CodeGenerator.MSBuild` generates invalid code for F# interface methods that have multiple unnamed arguments.

Note that `Microsoft.Orleans.CodeGenerator.Build` generates valid code in this scenario. 

Repro PR: #5937</Description>
        <CreatedDate>07/09/2019</CreatedDate>
        <ClosedDate>07/10/2019</ClosedDate>
        <Labels>
          <Label>codegen</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5800</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove LocalSilo from MembershipTableSnapshot. Detect death in gossip</Title>
    <Description>Follow-up to #5796</Description>
    <CreatedDate>30/07/2019</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5800</PullRequestID>
        <IssueID>5796</IssueID>
        <Title>Send a snapshot of the membership table on gossip</Title>
        <Description>Right now, when a silo change a silo entry in the membership table, it will "gossip" the new silo/status to other silos in the cluster. Since silos can miss notifications, it's not safe for them to infer anything based on this information alone, so they have to go to storage and refresh the all table.

In this PR, now silo that has modified the membership table will send a full snapshot of it, with the version number. This way, other silos in the cluster can either ignore the gossip if they are already up-to-date (or ahead), or can simply use it directly, without reading in the storage.

This should reduce the time of membership change propagation and reduce contention on the membership table.</Description>
        <CreatedDate>29/07/2019</CreatedDate>
        <ClosedDate>30/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5799</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Vhab</FixedByID>
    <Title>Improve codegen's .NET Core 3 compatibility</Title>
    <Description>Fixes #5793 using @ReubenBond 's instructions.

Successfully compiles a minimal netstandard2.0 project on Linux .NET Core 2.2, 3.0 Preview 7 and a combination of the 2.
Previously this would fail on the 3.0 variant.</Description>
    <CreatedDate>30/07/2019</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5799</PullRequestID>
        <IssueID>5793</IssueID>
        <Title>MSBuild codegen failing when only .NET Core 3 preview SDK is available</Title>
        <Description>It would appear something is causing `Microsoft.Orleans.CodeGenerator.MSBuild` to fall back to trying to use .NET Core 2.0.0 SDK when only .NET Core 3 Preview7 is available.

When using only 3.0 I'm getting the following message when attempting to build a .net standard 2.0 library containing a grain:

``

I've setup a reproduction case at https://github.com/Vhab/OrleansCodegenNetCore3

It's using docker as it's the easiest way to get a clean environment to test in.

It contains 3 images, one with .NET Core 2,2, one with 3.0p7 and one with both.
The first and last one build fine, but the one with only 3.0 fails.

The repo includes a readme with how to run the reproduction cases.</Description>
        <CreatedDate>27/07/2019</CreatedDate>
        <ClosedDate>30/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5794</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JorgeCandeias</FixedByID>
    <Title>Updating Blazor Sample</Title>
    <Description>This updates the Blazor sample to .NET 3.0 Preview 7 requirements, as per the chat on gitter and #5788.
I expect this to break again but for the time being it appears to function.</Description>
    <CreatedDate>27/07/2019</CreatedDate>
    <ClosedDate>28/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5794</PullRequestID>
        <IssueID>5788</IssueID>
        <Title>Blazor Sample does not post Todos</Title>
        <Description>To replicate, just load as README instructs.  Everything boots and I can get the weather data; however, I can't post a Todo.</Description>
        <CreatedDate>25/07/2019</CreatedDate>
        <ClosedDate>25/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5785</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Networking fixes</Title>
    <Description>* Fix wire protocol backwards compatibility with older versions
* Implement most feedback from #5436
* Add protocol version option for upgradeability of network protocol
* General cleanup in networking code</Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5785</PullRequestID>
        <IssueID>5436</IssueID>
        <Title>Networking system rewrite</Title>
        <Description>Replaces the existing networking system with a system based upon work originally done for Kestrel, dubbed [Bedrock](https://github.com/aspnet/AspNetCore/issues/4772).

The core purpose of this is to modernize the networking stack and eventually support implementing TLS (#828). In addition, Orleans gains improved support for non-TCP/non-Socket networking, including the ability to host on Kestrel.

Fixes #1372
Closes #307</Description>
        <CreatedDate>12/03/2019</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5784</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add UsePerfCounterEnvironmentStatistics overload for ISiloBuilder</Title>
    <Description>Fixes #5782</Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>24/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5784</PullRequestID>
        <IssueID>5782</IssueID>
        <Title>Missing UsePerfCounterEnvironmentStatistics for SiloBuilder</Title>
        <Description>There is currently no extension method `UsePerfCounterEnvironmentStatistics` for `ISiloBuilder` (only `ISiloHostBuilder`) but a corresponding `UseLinuxEnvironmentStatistics` was added for `ISiloBuilder`. Is there a plan to add this method or a workaround? I can simulate with reflection but I'd rather not.</Description>
        <CreatedDate>24/07/2019</CreatedDate>
        <ClosedDate>24/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5777</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix potential NullReferenceException in CallbackData</Title>
    <Description>Fixes #5624</Description>
    <CreatedDate>23/07/2019</CreatedDate>
    <ClosedDate>23/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5777</PullRequestID>
        <IssueID>5624</IssueID>
        <Title>NullReferenceException in SafeTimer</Title>
        <Description>Hi,

this is a support request, because i feel a little bit stupid right now.

From time to time I get a lof of exceptions like this:

``

Which is strange, because...

1. I have disabled the logs for this category: https://github.com/Squidex/squidex/blob/master/src/Squidex/Config/Logging.cs#L26

2. I don't see how it can happen, because there is nothing in your code and this stack trace that could be null.

Usually everything works fine and I just restart the node to get rid of the log entries, but I have no idea how it can happen.</Description>
        <CreatedDate>21/05/2019</CreatedDate>
        <ClosedDate>23/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5770</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Remove options and logic for automatic resending of messages</Title>
    <Description>Resolves #5667.

Automatic message resend was a bad idea. We forgot to remove the logic in 2.0.</Description>
    <CreatedDate>20/07/2019</CreatedDate>
    <ClosedDate>23/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5770</PullRequestID>
        <IssueID>5667</IssueID>
        <Title>Remove message retry functionality</Title>
        <Description>It is a bad idea to blindly retry messages that fail to process/deliver. Because of that the default retry count is set to zero. We need to remove this code altogether to simplify the codebase and prevent the potential confusion. We should have done that as part of 2.0 effort.</Description>
        <CreatedDate>04/06/2019</CreatedDate>
        <ClosedDate>23/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5769</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Fix OnCompleteAsync &amp; OnErrorAsync in StreamImpl</Title>
    <Description>Fixes #5697.
Fix NullRreferenceException thrown in OnCompletedAsync &amp; OnErrorAsync.</Description>
    <CreatedDate>19/07/2019</CreatedDate>
    <ClosedDate>19/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5769</PullRequestID>
        <IssueID>5697</IssueID>
        <Title>NullReferenceException on Stream Client when Calling OnCompletedAsync</Title>
        <Description>When a Stream client calls `OnCompletedAsync` I get a NullReferenceException.  A minimal repro is provided in the attached zip
[OrleansSample.zip](https://github.com/dotnet/orleans/files/3306576/OrleansSample.zip)
</Description>
        <CreatedDate>19/06/2019</CreatedDate>
        <ClosedDate>19/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5763</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>srollinet</FixedByID>
    <Title>Fix #5686 - Json serialization with Postgres</Title>
    <Description>fixes #5686
replace jsonb columns by text, to ensure the properties ordering is not modified.</Description>
    <CreatedDate>18/07/2019</CreatedDate>
    <ClosedDate>19/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5763</PullRequestID>
        <IssueID>5686</IssueID>
        <Title>Json serialization, references, wrong ordering</Title>
        <Description>Using Json serialization when you have multiple references to the same object usually creates a graph such that the first time an object is encountered it has the properties and an `$id` which identifies that instance. Thereafter, in the JSON a `$ref` property is used to identify that pre-defined object and a reference is inserted.

I have a situation where the `$ref` comes _before_ the definition of the object, which means that is being deserialized to `null`. 

This is a real headscratcher, because I cant reproduce the same problem in isolation using a simpler object graph and JSON.NET. Butmy fairly complex grain state exhibits the problem _every time_.

Has anyone ever experienced this? 

Below is a (snipped) copy of my JSON demonstrating the problem. You'll notice 2 `"$ref" : "5"` that come before the definition of `"$id": "5"`:

``</Description>
        <CreatedDate>13/06/2019</CreatedDate>
        <ClosedDate>19/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5744</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Revert recent directory changes</Title>
    <Description>This is a near-total revert of #5701 &amp; #5731 since they destabilized master

I will attempt to stabilize those changes and re-introduce them if successful</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5744</PullRequestID>
        <IssueID>5701</IssueID>
        <Title>LocalGrainDirectory: use membership snapshots</Title>
        <CreatedDate>20/06/2019</CreatedDate>
        <ClosedDate>28/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5744</PullRequestID>
        <IssueID>5731</IssueID>
        <Title>Fix race introduced in membership</Title>
        <CreatedDate>29/06/2019</CreatedDate>
        <ClosedDate>05/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5741</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Configure application parts in UseTransactions</Title>
    <Description>Fixes #5742

Reported by @Ilchert [via gitter](https://gitter.im/dotnet/orleans?at=5d249f5f17cc7b05ca9be318).</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5741</PullRequestID>
        <IssueID>5742</IssueID>
        <Title>Register Transaction.Abstractions framework path in UseTransactions</Title>
        <Description>I was trying to create a new `ITransactionalStateStorageFactory` implemetation but after registration, gran call failed with exception: `'Cannot find generated GrainReference class for interface 'Orleans.Transactions.Abstractions.ITransactionManagerExtension''`. 
To fix it - just add `Orleans.Transactions.Abstractions` assembly to framework path. I guess that this registration should be done in `UseTransactions` extension method.</Description>
        <CreatedDate>09/07/2019</CreatedDate>
        <ClosedDate>09/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5727</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>bojidar-bg</FixedByID>
    <Title>Change Client IP Address selection logic to use routing tables</Title>
    <Description>Addresses #5568.

Haven't tested the pull request, but at least it builds. If someone knows of an easy way to test a PR to Orleans under Linux, I would be glad to hear.

Based on code from [this StackOverflow question](https://stackoverflow.com/questions/15086863/c-sharp-know-with-which-ip-we-use-to-communicate-with-another-ip).

This PR is mostly a proof-of-concept for now.</Description>
    <CreatedDate>27/06/2019</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5727</PullRequestID>
        <IssueID>5568</IssueID>
        <Title>"Failed to get a local IP address" on Linux with localhost clustering</Title>
        <Description>**OS**: Arch Linux, updated 30.04.2019
**Linux kernel**: 5.0.10-arch1-1-ARCH
**Orleans version**: 2.2.0

**What happened**:
I am creating a cluster with UseLocalhostClustering, but I cannot connect from a client running on the same machine without having internet connection (or when on a tethered connection).
I suspect this is due to the loopback address having UNKNOWN state.

Related to #5097.

Stacktrace of the error:
``

Finally, it would be nice if there was an option for forcing a custom IP address and bypassing automatic IP address selection.
</Description>
        <CreatedDate>02/05/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5719</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Skip flaky MessageTest_TtlUpdatedOnSerialization test</Title>
    <Description>Opened #5718 to track</Description>
    <CreatedDate>26/06/2019</CreatedDate>
    <ClosedDate>01/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5719</PullRequestID>
        <IssueID>5718</IssueID>
        <Title>Flaky test: MessageTest_TtlUpdatedOnSerialization</Title>
        <CreatedDate>26/06/2019</CreatedDate>
        <ClosedDate>31/07/2019</ClosedDate>
        <Labels>
          <Label>test-issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5703</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Alxandr</FixedByID>
    <Title>Add UseAzureTableReminderService OptionsBuilder overload</Title>
    <Description>Add UseAzureTableReminderService overload that accepts OptionsBuilder delegate.

Closes #5699</Description>
    <CreatedDate>21/06/2019</CreatedDate>
    <ClosedDate>21/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5703</PullRequestID>
        <IssueID>5699</IssueID>
        <Title>Add UseAzureTableReminderService overload that accepts OptionsBuilder delegate</Title>
        <Description>Like `UseAzureStorageClustering` and `AddAzureBlobGrainStorage*`, `UseAzureTableReminderService` should also accept an `OptionsBuilder`. Currently I'm forced to do `UseAzureTableReminderService(_ =&gt; {}).Configure(.....);`.</Description>
        <CreatedDate>20/06/2019</CreatedDate>
        <ClosedDate>21/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5690</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Cherry-pick #5473 for 2.3.5</Title>
    <Description>Fix #5473 - codegen fails on recursively defined types (#5688)</Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>13/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5690</PullRequestID>
        <IssueID>5473</IssueID>
        <Title>Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop</Title>
        <Description>The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code, it hangs after generating `..orleans.g.args.txt`

this is the exit error message:
``

It is probably this line `public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;` that is causing the infinite loop.</Description>
        <CreatedDate>25/03/2019</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5690</PullRequestID>
        <IssueID>5688</IssueID>
        <Title>Fix #5473 - StackOverflowException in codegen for recursively defined types</Title>
        <Description>Fixes #5473</Description>
        <CreatedDate>13/06/2019</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5689</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>CodeGenerator: skip empty projects</Title>
    <Description>Fixes #5678</Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>18/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5689</PullRequestID>
        <IssueID>5678</IssueID>
        <Title>Code generator fails on empty projects</Title>
        <Description>``

This should probably be handled, as you don't want the compilation of solutions to fail if you just added a new project that you've yet to add anything to.</Description>
        <CreatedDate>11/06/2019</CreatedDate>
        <ClosedDate>18/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5688</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #5473 - StackOverflowException in codegen for recursively defined types</Title>
    <Description>Fixes #5473</Description>
    <CreatedDate>13/06/2019</CreatedDate>
    <ClosedDate>13/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5688</PullRequestID>
        <IssueID>5473</IssueID>
        <Title>Microsoft.Orleans.CodeGenerator.MSBuild 2.2.4 infinite loop</Title>
        <Description>The following code is probably causing an infinite loop in `Microsoft.Orleans.CodeGenerator.MSBuild`. 
When I build the following code, it hangs after generating `..orleans.g.args.txt`

this is the exit error message:
``

It is probably this line `public abstract class Simple&lt;T&gt; where T : Simple&lt;T&gt;` that is causing the infinite loop.</Description>
        <CreatedDate>25/03/2019</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5684</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Cherry-picked fixes for 2.3.5</Title>
    <Description>Fixes #5661 by allowing configuration to pass in value of MetadataPro… (#5662)
Make transaction log group max size configurable (#5656)
Reduce delay local directory when cluster membership is not stable (#5677)</Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>13/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5684</PullRequestID>
        <IssueID>5661</IssueID>
        <Title>Unable to set MetadataPropertyHandling on serializer in AdoNet persistence</Title>
        <Description>WHen  using `TypeNameHandling` settings which write the type info to the serialized JSON, deserialization only works when the `$id` and `$type` property are the first two properties in the serialized JSON string.

For example, it is possible to get this serialized JSON:

``

Which will not deserialize

&gt;Could not create an instance of type HelloWorld.Interfaces.IInterface. Type is an interface or abstract class and cannot be instantiated. Path 'Greetings.$values[0].Foo', line 1, position 252

However, it is possible for JSON.NET to deserialize this JSON by setting `MetadataPropertyHandling = MetadataPropertyHandling.ReadAhead` - however this option is not exposed by `AdoNetGrainStorageOptions` (as an aside, nor are many other options on the `JsonSerializerSettings`).

This issue causes many problems on deserialization when grain state contains an array/collection of concrete interface implementations. 

</Description>
        <CreatedDate>03/06/2019</CreatedDate>
        <ClosedDate>04/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5684</PullRequestID>
        <IssueID>5662</IssueID>
        <Title>Add ConfigureJsonSerializerSettings delegate to storage providers</Title>
        <Description>…pertyHandling to serializer settings</Description>
        <CreatedDate>03/06/2019</CreatedDate>
        <ClosedDate>04/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5684</PullRequestID>
        <IssueID>5656</IssueID>
        <Title>Make transaction log group max size configurable</Title>
        <Description>When trying to determine cause of broken lock exceptions this was useful.
I can also see it being used to adapt to different storage latencies.</Description>
        <CreatedDate>31/05/2019</CreatedDate>
        <ClosedDate>04/06/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5684</PullRequestID>
        <IssueID>5677</IssueID>
        <Title>Reduce delay localdirectory when cluster membership is not stable</Title>
        <Description>When the `LocalGrainDirectory` receives a register/unregister request that needs to be forwarded (it can happen when all silos doesn't have the same view of the cluster membership), it currently wait 5 seconds before forwarding, to allow some time for the membership changes to propagate.

200ms seems to be a better value since with gossip the membership change should propagate quickly.</Description>
        <CreatedDate>10/06/2019</CreatedDate>
        <ClosedDate>12/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5663</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix Nullable&lt;T&gt;</Title>
    <Description>Fixes #5660</Description>
    <CreatedDate>03/06/2019</CreatedDate>
    <ClosedDate>03/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5663</PullRequestID>
        <IssueID>5660</IssueID>
        <Title>Expected result of type System.Nullable`1[System.Int64] but encountered a null value.</Title>
        <Description>after upgrade to v2.3.3, the grain method return `Nullable&lt;T&gt;` was broken.

https://github.com/mkjeff/orleans/blob/9d67a5c4a27cd9392f5d198b495ac90fa8df6ffb/src/Orleans.Core/Async/TaskExtensions.cs#L118</Description>
        <CreatedDate>03/06/2019</CreatedDate>
        <ClosedDate>03/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5619</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Alxandr</FixedByID>
    <Title>Create GrainReferenceKeyInfo</Title>
    <Description>Create new type GrainReferenceKeyInfo and methods for getting key info from a GrainReference, and getting a GrainReference form the key info. This enables serializers not part of orleans to serialize/deserialize GrainReferences into more space compact representations than the GetKeyString() format.

Resolves #3810.</Description>
    <CreatedDate>20/05/2019</CreatedDate>
    <ClosedDate>13/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5619</PullRequestID>
        <IssueID>3810</IssueID>
        <Title>Possible to make GrainReference and GrainId publicly accessible?</Title>
        <Description>Everything important about GrainReference and GrainId is internal. This is fine for normal use, but really hurts when trying to implement custom storage providers or serializers.

One specific case for which I really need to access the internals of GrainId is to implement grain reference serialization/deserialization in my custom serializer, which is optimized for storage space and having only a ~100 character ToKeyString() result to store is not ideal when I could, under the best circumstances, have between maybe 4 and 20 bytes to store (not counting the possibility of long string keys).

I can just take the source and change the members to be public, but I'm wondering if there is a specific reason they were made internal (other than to simplify the API), and if they can't be made public altogether.</Description>
        <CreatedDate>20/12/2017</CreatedDate>
        <ClosedDate>13/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5579</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JorgeCandeias</FixedByID>
    <Title>Health Check Sample</Title>
    <Description>Orleans Health Check Sample

Targets:
* .NET Core 2.2
* Orleans 2.3.1
* ASP.NET Core 2.2

Based on prior art from [ReubenBond](https://github.com/dotnet/orleans/issues/4843#issuecomment-478055180) and [DarkCow](https://github.com/dotnet/orleans/issues/4843#issuecomment-479576394).

In addition to the code, I would appreciate a review of the readme file for technical correctness. Some bits are to the best of my current knowledge and may be wrong or outdated. Thanks in advance.

Closes #5486 </Description>
    <CreatedDate>06/05/2019</CreatedDate>
    <ClosedDate>12/06/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5579</PullRequestID>
        <IssueID>5486</IssueID>
        <Title>Create HealthCheck Sample</Title>
        <Description>As described. Feel free to assign this to me, unless someone else wants to have a go at it. #4843</Description>
        <CreatedDate>29/03/2019</CreatedDate>
        <ClosedDate>12/06/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5574</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[WIP] Remove base class from [Client,Silo]MessagingOptions</Title>
    <Description>This separates the `MessagingOptions` base class from `ClientMessagingOptions` and `SiloMessagingOptions`.

This is a breaking change: users may have to fix some code so that their application continues to compile.

Effectively subsumes #4753.</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5574</PullRequestID>
        <IssueID>4753</IssueID>
        <Title>[WIP] Support configuration of messaging options via MessagingOptions</Title>
        <Description>Fixes #4751</Description>
        <CreatedDate>10/07/2018</CreatedDate>
        <ClosedDate>22/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5436</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Networking system rewrite</Title>
    <Description>Replaces the existing networking system with a system based upon work originally done for Kestrel, dubbed [Bedrock](https://github.com/aspnet/AspNetCore/issues/4772).

The core purpose of this is to modernize the networking stack and eventually support implementing TLS (#828). In addition, Orleans gains improved support for non-TCP/non-Socket networking, including the ability to host on Kestrel.

Fixes #1372
Closes #307</Description>
    <CreatedDate>12/03/2019</CreatedDate>
    <ClosedDate>22/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5436</PullRequestID>
        <IssueID>828</IssueID>
        <Title>Adding optional TLS/encryption to transport channel</Title>
        <Description>Adding TLS option to client-silo and inter-silo communications would make a great end-to-end encryption promise when combined with encryption between silo and storage. It looks like using TLS in socket connections involves adding a configuration option to settings and then applying it to socket connections. Encryption between silos and storage is less clear to me otherwise than that it may require more than simply changing connection string (for instance, here's background material for [Azure Table Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2015/04/28/client-side-encryption-for-microsoft-azure-storage-preview.aspx)).

To get this going, what would be needed to add encryption?
1. Where and what kind of parameters should be added to configuration to support TLS on client-silo and inter-silo communications? It would feel like it's appropriate to allow different settings to apply to option between inter-silo and client-silo communications.
2. Whe are in code are relevant places handling socket communications and apply encryption settings?
3. Some consideration should be given on adding encryption on per-provider basis and maybe separated to their respective tickets, but I'll add here to get things going.
</Description>
        <CreatedDate>22/09/2015</CreatedDate>
        <ClosedDate>15/10/2019</ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5436</PullRequestID>
        <IssueID>1372</IssueID>
        <Title>Outsourcing of network layer to 3rd party libraries</Title>
        <Description>This question has been brought up more than once - should we 'outsource' the low level networking/socket layer of the Orleans stack to a 3rd party library instead of maintaining the code that deals with socket connections, sending/receiving messages, and buffer pool management within the Orleans codebase.

Potential benefits:
- Reduction of the codebase and its maintenance cost 
- 'Free' support for features like TLS
- Pluggable networking layer that would allow to swap implementations in the future easily
- Ability to easily add additional network protocols, such as HTTP, AMQP, MQTT

Concerns:
- Loss of control and flexibility in detecting and handling network issues
- Loss of low level performance optimizations
- Serialization needs buffer pools for efficiency even if we outsource buffer management for communication

Another somewhat related question that's been discussed is about opening up the Orleans messaging protocol, so that requests to grains could be sent without the need for OrleansClient and from different software stacks and languages.

The first step is to have a virtual meeting to go over the existing implementation of the networking/messaging layer to get interested people more familiar with the status quo and to answer any questions about it.

This issue is intended for accumulating initial questions and ideas in preparation for the meeting. Please comment to add or correct.
</Description>
        <CreatedDate>04/02/2016</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5436</PullRequestID>
        <IssueID>307</IssueID>
        <Title>Orleans sockets, would there be need for more performance?</Title>
        <Description>Out of curiosity I took a look at [SocketManager](https://github.com/dotnet/orleans/blob/master/src/Orleans/Messaging/SocketManager.cs) and [related](https://github.com/dotnet/orleans/search?utf8=%E2%9C%93&amp;q=SocketManager) and I was wondering has anyone considered either [SocketEventAsyncArgs](https://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs%28v=vs.110%29.aspx) or things like [RIO](http://channel9.msdn.com/Events/Build/BUILD2011/SAC-593T) (if this is a good source)/[RDMA](https://msdn.microsoft.com/en-us/library/cc904397%28v=vs.85%29.aspx)?

Long time ago, during the .NET 3.5 era (before `async`, that is) and when Windows Server 2003 was good stuff, I implemented a high-performance soft-realtime socket server and got much better performance with [SocketAsyncEventArgs](https://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs%28v=vs.110%29.aspx). I suppose one factor here is how much of churn there is in senders (e.g. new connections) and world has moved on a bit with the new async interfaces.

Nevertheless, I was thinking some computing scenarios and things like high-performance trading (those guys strip down Linux kernels or have moved to FPGA already) where not so long ago this was quite hot. Some problems I once upon time dodgde are nicely enumerated at [Long running async and memory fragmentation](http://ayende.com/blog/170243/long-running-async-and-memory-fragmentation) (of RavenDb fame, see especially the discussion) and I noticed Cassandra is using [SocketEventAsyncArgs too](https://github.com/datastax/csharp-driver/blob/7150905d316f5cc2da2d598b2eee461c0292cb46/src/Cassandra/TcpSocket.cs#L39). As a final note for those curious [Awaiting Socket Operations](http://blogs.msdn.com/b/pfxteam/archive/2011/12/15/10248293.aspx).

Now that I got this far, I wonder does anyone have use cases for maximum socket performance or would it be nice to have features like these (as in closer to metal and less memory pinning)? Inter-datacenter messaging perhaps? Some inter-silo computing transferring a lot of data?
</Description>
        <CreatedDate>07/04/2015</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5073</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[WIP] Support Service Fabric Stateful Service hosting</Title>
    <Description>Fixes #1059. I consider this satisfying enough of #1059 that we can close that issue and add any extra "good to have" features in separate PRs with individual issues if required.

This PR will be split up into multiple parts:

1. Enabling packaging of `Microsoft.Orleans.Clustering.ServiceFabric` package, which was not included in 2.0. `IMembershipOracle` ..
2. `StatefulServicePlacement` - so that activations are placed deterministically by mapping from grain id to SF partition id (SF partition ids / counts are fixed at deployment time and the service must be deleted and redeployed to 'change' the partition count/scheme).
3. Changes to support placement directors which do not use the grain directory. In short, adds an `IsUsingGrainDirectory` prop to `PlacementStrategy` and removes the existing special-casing around `StatelessWorkerPlacement` being the only placement strategy which can bypass the directory. (PR #5074)
4. Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e, 1:1 relationship). It's possible that this will be contentious, since previously an `ActivationId` was ephemeral. This change is important, though, because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy`, which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)
5. A storage provider backed by Service Fabric Reliable Collections.
6. Hosting utilities for wiring everything together, to make hosting Orleans on SF as simple as possible.</Description>
    <CreatedDate>05/10/2018</CreatedDate>
    <ClosedDate>22/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5073</PullRequestID>
        <IssueID>1059</IssueID>
        <Title>Support deep Service Fabric integration</Title>
        <Description>[Service Fabric](https://azure.microsoft.com/en-us/services/service-fabric/) is a great platform for application hosting which offers high-density hosting, application upgrade, and state replication.

Many users, such as myself, would rather use Orleans than Service Fabric Reliable Actors. There are many reasons for this, including that Orleans is much more mature, open source, and feature rich.

We have [integration packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric) for hosting Orleans atop Service Fabric. This integration is simple and effective but does not allow Orleans to gain all of the benefits which Service Fabric has to offer, such as collocated state.

Orleans should be the obvious choice for Virtual Actors in any hosting environment, so there is some additional work to be done which I would like insight into and assistance with.

This issue is for discussion and tracking of that work.
### Basic Integration:
- [x] **Hosting**: Basic stateless, unpartitioned service hosting. Use the existing [NuGet packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric).
### Integration Required for Collocated State:
- [x] **Gateway Provider**: Implement an `IGatewayListProvider` based on Service Fabric's `NamingService`. Added in #2542
- [x] **Cluster Membership Provider**: Silos need to be discoverable by clients &amp; each other. ~~This should involve creating an `IMembershipTable` implementation which leverages Fabric's `NamingService` or `PropertyService`.~~ This involves creating an `IMembershipOracle` implementation which can receive updates directly from Service Fabric in addition to periodically polling partitions. Added in #2542
- [ ] **Grain Placement**: Orleans should be partitioned and grain placement should deterministically map `GrainId` to partitions. Using consistent hashing means that we do not need to hold/maintain a grain directory. One potential downside to this approach is that we rely on the randomness of GrainIds to balance load across hosts and cannot perform load shedding in a granular fashion. This is mitigated by using a significant number of partitions, allowing Service Fabric to perform this load balancing at the partition level by shifting partitions between nodes based. This change requires only that we configure a new `PlacementStrategy`/`PlacementDirector` which resolves `GrainId` to `SiloAddress` based upon Service Fabric partitions. We can optionally eliminate the Grain Directory when we are using Service Fabric, but keeping the Grain Directory around allows us to use different placement strategies (as long as they are stateless or use a state provider which doesn't require consistent mapping between `GrainId` &amp; Fabric partition.)
- [ ] **Partitioned hosting**: This should only require a Service Fabric configuration change: **Placement** handles the important parts.
- [ ] **State Providers**: deterministic grain placement allows us to use collocated, replicated state. State providers will be based upon `IReliableDictionary&lt;GrainId,byte[]&gt;`, using Service Fabric's Reliable Services model.
### Extras:
- [ ] **Reminder Service**: Reminder Services should be pluggable so that we can provide a Service Fabric-based reminder service.
- [ ] **Stream Provider**: Service Fabric has an `IReliableQueue&lt;T&gt;` which can be used to produce an `IStreamProvider`.
- [ ] **Storage Provider**: Collocated state requires the **Grain Placement** change, but we can also create a simple state service for in-cluster, non-collocated state. That would allow us to use the existing placement strategies.
### General Work Which Would Help:

Much of this work would be much easier if dependency injection was used more pervasively throughout Orleans. There should not be a `GatewayProviderType` enum and there definitely should not be a `GatewayProviderType.ZooKeeper` value. Those things should be configured in a strongly typed manner.
### Result:

Ultimately, this will give us integration which is on-par with Service Fabric's Reliable Actors implementation. We will also have all of the added features of Orleans.

Anything I've missed? Any obvious/subtle challenged which I may have overlooked?
</Description>
        <CreatedDate>22/11/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P1</Label>
          <Label>enhancement</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5073</PullRequestID>
        <IssueID>1059</IssueID>
        <Title>Support deep Service Fabric integration</Title>
        <Description>[Service Fabric](https://azure.microsoft.com/en-us/services/service-fabric/) is a great platform for application hosting which offers high-density hosting, application upgrade, and state replication.

Many users, such as myself, would rather use Orleans than Service Fabric Reliable Actors. There are many reasons for this, including that Orleans is much more mature, open source, and feature rich.

We have [integration packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric) for hosting Orleans atop Service Fabric. This integration is simple and effective but does not allow Orleans to gain all of the benefits which Service Fabric has to offer, such as collocated state.

Orleans should be the obvious choice for Virtual Actors in any hosting environment, so there is some additional work to be done which I would like insight into and assistance with.

This issue is for discussion and tracking of that work.
### Basic Integration:
- [x] **Hosting**: Basic stateless, unpartitioned service hosting. Use the existing [NuGet packages](https://www.nuget.org/packages/Microsoft.Orleans.ServiceFabric).
### Integration Required for Collocated State:
- [x] **Gateway Provider**: Implement an `IGatewayListProvider` based on Service Fabric's `NamingService`. Added in #2542
- [x] **Cluster Membership Provider**: Silos need to be discoverable by clients &amp; each other. ~~This should involve creating an `IMembershipTable` implementation which leverages Fabric's `NamingService` or `PropertyService`.~~ This involves creating an `IMembershipOracle` implementation which can receive updates directly from Service Fabric in addition to periodically polling partitions. Added in #2542
- [ ] **Grain Placement**: Orleans should be partitioned and grain placement should deterministically map `GrainId` to partitions. Using consistent hashing means that we do not need to hold/maintain a grain directory. One potential downside to this approach is that we rely on the randomness of GrainIds to balance load across hosts and cannot perform load shedding in a granular fashion. This is mitigated by using a significant number of partitions, allowing Service Fabric to perform this load balancing at the partition level by shifting partitions between nodes based. This change requires only that we configure a new `PlacementStrategy`/`PlacementDirector` which resolves `GrainId` to `SiloAddress` based upon Service Fabric partitions. We can optionally eliminate the Grain Directory when we are using Service Fabric, but keeping the Grain Directory around allows us to use different placement strategies (as long as they are stateless or use a state provider which doesn't require consistent mapping between `GrainId` &amp; Fabric partition.)
- [ ] **Partitioned hosting**: This should only require a Service Fabric configuration change: **Placement** handles the important parts.
- [ ] **State Providers**: deterministic grain placement allows us to use collocated, replicated state. State providers will be based upon `IReliableDictionary&lt;GrainId,byte[]&gt;`, using Service Fabric's Reliable Services model.
### Extras:
- [ ] **Reminder Service**: Reminder Services should be pluggable so that we can provide a Service Fabric-based reminder service.
- [ ] **Stream Provider**: Service Fabric has an `IReliableQueue&lt;T&gt;` which can be used to produce an `IStreamProvider`.
- [ ] **Storage Provider**: Collocated state requires the **Grain Placement** change, but we can also create a simple state service for in-cluster, non-collocated state. That would allow us to use the existing placement strategies.
### General Work Which Would Help:

Much of this work would be much easier if dependency injection was used more pervasively throughout Orleans. There should not be a `GatewayProviderType` enum and there definitely should not be a `GatewayProviderType.ZooKeeper` value. Those things should be configured in a strongly typed manner.
### Result:

Ultimately, this will give us integration which is on-par with Service Fabric's Reliable Actors implementation. We will also have all of the added features of Orleans.

Anything I've missed? Any obvious/subtle challenged which I may have overlooked?
</Description>
        <CreatedDate>22/11/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P1</Label>
          <Label>enhancement</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5073</PullRequestID>
        <IssueID>5074</IssueID>
        <Title>Allow placement strategies to skip directory registration</Title>
        <Description>Changes to support placement directors which do not use the grain directory. In short, adds an `IsUsingGrainDirectory` prop to `PlacementStrategy` and removes some existing special-casing around `StatelessWorkerPlacement` being the only placement strategy which can bypass the directory.

This is a supporting PR for Service Fabric Stateful Service hosting #5073</Description>
        <CreatedDate>05/10/2018</CreatedDate>
        <ClosedDate>06/10/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5073</PullRequestID>
        <IssueID>5082</IssueID>
        <Title>Allow placement strategies to specify deterministic activation ids</Title>
        <Description>When grains are placed using the (upcoming) Service Fabric Stateful Service strategy, there is no grain directory involvement and hence we need a mechanism to determine which activation id to use when routing messages.

This PR enables that functionality but keeps it *`internal`* so that it will only be exposed to the SF library for now. The reasoning here is that it's unlikely anyone else will need it and if someone stumbles upon this they may opt-in to it for their placement strategy without understanding the consequences.

If `PlacementStrategy.IsDeterministicActivationId` is `true`, then all activations for a particular grain will have an `ActivationId` whose `Key` is equal to the grain's `GrainId.Key`. If `false`, then no behavior changes and `ActivationId` is randomly generated.

Without this PR, initial calls to already-activated grains placed using `StatefulServicePlacement` will round-trip to the target silo using the incorrect generated `ActivationId` and the silo will need to forward those calls to the correct activation. The response message will invalidate the caller's routing cache, but will not specify the activation's new address, so the caller will continue to call using incorrect `ActivationId`s. This is *benign* but unpleasant and inefficient. Users would almost certainly complain about warnings and other garbage in their logs. It is also slower. This PR enables the first and subsequent call to succeed without any round-trips for routing info.

See #5073 under part 4:
&gt; Changes to support activations which have a deterministic `ActivationId` (related to the above) so that a grain which is placed using `StatefulServicePlacement` has a fixed `ActivationId` which can be computed from its `GrainId` (i.e, 1:1 relationship). It's possible that this will be contentious, since previously an `ActivationId` was ephemeral. This change is important, though, because it lets us route calls without needing to learn the `ActivationId` from another source (the grain directory). This is implemented by adding an `IsDeterministicActivationId` property to `PlacementStrategy`, which is then used in `PlacementDirectorsManager.AddActivation`. (PR #5082)</Description>
        <CreatedDate>09/10/2018</CreatedDate>
        <ClosedDate>11/10/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4349</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[WIP] Salvage activations from defunct directory partitions</Title>
    <Description>Fixes #2656

Note that this is based upon #4344, so when reviewing, only look at the last commit.

This PR implements the push model described in #2656, except it does not rely on a specific from silos which do not expect to be receiving registrations. Instead, those silos will forward the registration on to the silo which they believe it belongs to. The process is persistent, so eventually the end state will be reached and the activation will either be re-registered or it will be destroyed as a duplicate.</Description>
    <CreatedDate>29/03/2018</CreatedDate>
    <ClosedDate>09/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4349</PullRequestID>
        <IssueID>2656</IssueID>
        <Title>[Idea] Salvage Activations from Defunct Directory Partitions</Title>
        <Description>This is not my idea, but I'm documenting my understanding of it here for discussion so that we can come up with an action plan.

First, a primer on how Orleans finds where a grain activation lives - correct me if I'm wrong: 
* Orleans supports a flexible placement model where the placement of an activation is dynamic and guided by its placement policy rather than being restricted to a fixed calculation.
* To support this model, Orleans maintains a distributed lookup table of GrainId -&gt; ActivationId, where ActivationId points to the silo which hosts an activation
* This distributed table is partitioned across all silos in the cluster, where each silo holds one partition of the directory.
* Silos are placed around conceptual ring based upon a hash of their `SiloAddress` (similar to nodes in a [Chord DHT](https://en.wikipedia.org/wiki/Chord_(peer-to-peer))).
* In order to find where a grain activation exists in the cluster, its `GrainId` is mapped to a silo on that ring by finding the silo with the largest `hash(SiloAddress)` less than the `hash(GrainId)`. This is the Primary Directory Partition for this grain.
* When a silo is added to the cluster, the directory on each silo is notified and they each perform a hand-off for any grains which have a new primary directory partition (based on the above algorithm).
* When a silo is removed, similar rebalancing happens so that new activations can be placed on a surviving silo.
* Each silo maintains a local cache of parts of the distributed table as an optimization, similar to a DNS cache.

That's how a directory partition handles cluster membership changes, but what happens to the actual activations (`Grain` instances) during a membership change? Currently, if a silo dies, every activation whose primary directory partition was on that silo is eagerly deactivated (see `Catalog.SiloStatusChangeNotification`). That is, if SiloA has an activation whose primary directory partition is on SiloB and SiloB dies, then SiloA will kill that activation. This can cause a large amount of activation churn, particularly in small clusters.

The proposal is to register those activations with the correct, surviving directory partition instead of deactivating them.

We must maintain a few invariants while implementing this optimization:
* Activations must eventually converge to at most one per grain.
* Activations which are tracked using the directory cannot be allowed to exist without being registered in the directory - they cannot be orphaned.
* Activations must eventually be registered in the correct directory partition.

Are there nuances here which I've missed or is this too vague?</Description>
        <CreatedDate>30/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4349</PullRequestID>
        <IssueID>4344</IssueID>
        <Title>[WIP] Improve activation &amp; directory convergence</Title>
        <Description>This is for consideration - I'm not expecting it to be merged as-is.

This changes the implementation of GrainDirectoryHandoffManager to use a queue for executing operations. Each operation must complete successfully before the next operation begins execution.

Using that system, we add resiliency to some of the grain directory balancing operations.
When cluster membership changes, duplicate activations on existing silos are reliably destroyed.</Description>
        <CreatedDate>28/03/2018</CreatedDate>
        <ClosedDate>25/03/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4349</PullRequestID>
        <IssueID>2656</IssueID>
        <Title>[Idea] Salvage Activations from Defunct Directory Partitions</Title>
        <Description>This is not my idea, but I'm documenting my understanding of it here for discussion so that we can come up with an action plan.

First, a primer on how Orleans finds where a grain activation lives - correct me if I'm wrong: 
* Orleans supports a flexible placement model where the placement of an activation is dynamic and guided by its placement policy rather than being restricted to a fixed calculation.
* To support this model, Orleans maintains a distributed lookup table of GrainId -&gt; ActivationId, where ActivationId points to the silo which hosts an activation
* This distributed table is partitioned across all silos in the cluster, where each silo holds one partition of the directory.
* Silos are placed around conceptual ring based upon a hash of their `SiloAddress` (similar to nodes in a [Chord DHT](https://en.wikipedia.org/wiki/Chord_(peer-to-peer))).
* In order to find where a grain activation exists in the cluster, its `GrainId` is mapped to a silo on that ring by finding the silo with the largest `hash(SiloAddress)` less than the `hash(GrainId)`. This is the Primary Directory Partition for this grain.
* When a silo is added to the cluster, the directory on each silo is notified and they each perform a hand-off for any grains which have a new primary directory partition (based on the above algorithm).
* When a silo is removed, similar rebalancing happens so that new activations can be placed on a surviving silo.
* Each silo maintains a local cache of parts of the distributed table as an optimization, similar to a DNS cache.

That's how a directory partition handles cluster membership changes, but what happens to the actual activations (`Grain` instances) during a membership change? Currently, if a silo dies, every activation whose primary directory partition was on that silo is eagerly deactivated (see `Catalog.SiloStatusChangeNotification`). That is, if SiloA has an activation whose primary directory partition is on SiloB and SiloB dies, then SiloA will kill that activation. This can cause a large amount of activation churn, particularly in small clusters.

The proposal is to register those activations with the correct, surviving directory partition instead of deactivating them.

We must maintain a few invariants while implementing this optimization:
* Activations must eventually converge to at most one per grain.
* Activations which are tracked using the directory cannot be allowed to exist without being registered in the directory - they cannot be orphaned.
* Activations must eventually be registered in the correct directory partition.

Are there nuances here which I've missed or is this too vague?</Description>
        <CreatedDate>30/01/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4294</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Added test to exersize queue rebalancing while actively streaming</Title>
    <Description>It's a continuation of #4272. GitHub is angry with me and is not letting me force push (this force is not with me) 
This test is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
</Description>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>18/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4294</PullRequestID>
        <IssueID>4272</IssueID>
        <Title>Added test to exersize queue rebalancing while actively streaming</Title>
        <Description>This tests is a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.
It will not compile or pass tests until Lease based queue balancer fixes #4267 is merged.</Description>
        <CreatedDate>21/03/2018</CreatedDate>
        <ClosedDate>23/03/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4294</PullRequestID>
        <IssueID>3484</IssueID>
        <Title>Stream resubscription issues</Title>
        <Description>Every time we redeploy silos clients cannot resubscribe to stream and so we're forced to redeploy them as well. We do resubscribe once we received ClusterConnectionLost event (we retry infinitely). The weird thing that client actually reconnects and can communicate with actors, it's only streams which are broken.

This is what we see in a logs:

``

</Description>
        <CreatedDate>02/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2711</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sebastianburckhardt</FixedByID>
    <Title>Event-storage interface</Title>
    <Description>As discussed in #2598, we still need an event store API for plugging in various low-level event store interfaces.

This is a work-in-progress PR containing a draft for a solution. We worked on this last year, it includes an implementation for GetEventStore that uses the code contributed by @jkonecki.

The idea is that new event store providers are created by subclassing `Orleans.EventSourcing.EventStorage.EventStorageProviderBase`
and then overriding the abstract methods. The important ones are

```csharp
Task&lt;EventStreamResponse&gt; LoadStream(string streamName, int startAtVersion = 0, int? endAtVersion = null);
Task&lt;bool&gt; AppendToStream(string streamName, IEnumerable&lt;KeyValuePair&lt;Guid, object&gt;&gt; events, int? expectedVersion = null);
```
    
 (see IEventStore.cs for details and comments)</Description>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>30/07/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2711</PullRequestID>
        <IssueID>2598</IssueID>
        <Title>Provide docs for Log Consistency Providers and split test</Title>
        <Description>First of all, thank you @sebastianburckhardt for the great work!

After #1854 got merged I tried play with it but was unable to get it to work. I was unable to find among the tons of tests what are the files related to `OrleansEventSourcing` project. The configuration and requirements is what is hardest to find.

I would suggest a simple page with the minimum required configuration to get it to work. 

Also, would be good if that project has its own test project. I can do it myself if you point out what exactly is related to this project inside the test projects.

Thank you Sebastian! :)</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>10/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5604</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Alxandr</FixedByID>
    <Title>Improve Roslyn TypeCode generation</Title>
    <Description>Should hopefully fix #5482. I'm going to do some testing locally using this build of the code generator to see if it does solve the issue.</Description>
    <CreatedDate>10/05/2019</CreatedDate>
    <ClosedDate>10/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5604</PullRequestID>
        <IssueID>5482</IssueID>
        <Title>Microsoft.Orleans.CodeGenerator.MSBuild - Issues with GrainState being of generic type</Title>
        <Description>Hi, we observed some differences between the `Microsoft.Orleans.OrleansCodeGenerator.Build` (works) and `Microsoft.Orleans.CodeGenerator.MSBuild` (fails) code generator.
Where we're having intermittent issues (while running the same test without rebuild) that produces the exception below.

We have a grain with a state of a generic type. This works fine with `Build` but fails with `MSBuild`. Changing the generic state to a concrete implementation solves the problem in the `MSBuild`-case.

``

At the moment we don't have time to do a repro. Hopefully this can help i some way.</Description>
        <CreatedDate>28/03/2019</CreatedDate>
        <ClosedDate>10/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5586</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Implement IApplicationLifetime for ClientBuilder/SiloHostBuilder</Title>
    <Description>This is a pre-requisite for #5436, which uses `IApplicationLifetime` (from shared Hosting package) to ensure all connections are closed during shutdown.

This aligns `ClusterClient` and `SiloHostBuilder` more closely with the generic `HostBuilder` from `Microsoft.Extensions.Hosting`.</Description>
    <CreatedDate>07/05/2019</CreatedDate>
    <ClosedDate>07/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5586</PullRequestID>
        <IssueID>5436</IssueID>
        <Title>Networking system rewrite</Title>
        <Description>Replaces the existing networking system with a system based upon work originally done for Kestrel, dubbed [Bedrock](https://github.com/aspnet/AspNetCore/issues/4772).

The core purpose of this is to modernize the networking stack and eventually support implementing TLS (#828). In addition, Orleans gains improved support for non-TCP/non-Socket networking, including the ability to host on Kestrel.

Fixes #1372
Closes #307</Description>
        <CreatedDate>12/03/2019</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5585</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Groundwork for span-friendly serialization</Title>
    <Description>This is a pre-requisite for #5436 and lays some groundwork for a more span-friendly serializer (networking replat is based on pipes which use Span&lt;byte&gt;/Memory&lt;byte&gt;)</Description>
    <CreatedDate>07/05/2019</CreatedDate>
    <ClosedDate>20/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5585</PullRequestID>
        <IssueID>5436</IssueID>
        <Title>Networking system rewrite</Title>
        <Description>Replaces the existing networking system with a system based upon work originally done for Kestrel, dubbed [Bedrock](https://github.com/aspnet/AspNetCore/issues/4772).

The core purpose of this is to modernize the networking stack and eventually support implementing TLS (#828). In addition, Orleans gains improved support for non-TCP/non-Socket networking, including the ability to host on Kestrel.

Fixes #1372
Closes #307</Description>
        <CreatedDate>12/03/2019</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5584</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Provide separate options for worker &amp; IO pool min thread counts</Title>
    <Description>Set defaults to 0 (no minimum set)

During development of #5436, the default value for these thread pools was found to be a detrimental to throughput.

It is better to avoid setting a minimum and instead allow users to follow general .NET guidance on setting thread pool limits.</Description>
    <CreatedDate>07/05/2019</CreatedDate>
    <ClosedDate>07/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5584</PullRequestID>
        <IssueID>5436</IssueID>
        <Title>Networking system rewrite</Title>
        <Description>Replaces the existing networking system with a system based upon work originally done for Kestrel, dubbed [Bedrock](https://github.com/aspnet/AspNetCore/issues/4772).

The core purpose of this is to modernize the networking stack and eventually support implementing TLS (#828). In addition, Orleans gains improved support for non-TCP/non-Socket networking, including the ability to host on Kestrel.

Fixes #1372
Closes #307</Description>
        <CreatedDate>12/03/2019</CreatedDate>
        <ClosedDate>22/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5582</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #5565 - NullReferenceException caused by call filter</Title>
    <Description>Fixes #5565

When a `Task` returns `null`, that value cannot be cast to `T` using a hard-cast because that will cause a `NullReferenceException`.

Also adds `ConfigureAwait(false)` inside some private Task helpers for cleanliness.

I am hoping this builds on the build servers, but the `is` syntax I'm using may not be supported there.

cc @SebastianStehle </Description>
    <CreatedDate>07/05/2019</CreatedDate>
    <ClosedDate>08/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5582</PullRequestID>
        <IssueID>5565</IssueID>
        <Title>NullReferenceException when you catch exceptions</Title>
        <Description>Hi,
when you just catch execptions with a filter like:

``

you get a NullReferenceException. I think such a filter should be allowed for grains that void result (Task).
</Description>
        <CreatedDate>30/04/2019</CreatedDate>
        <ClosedDate>08/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5577</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ilyalukyanov</FixedByID>
    <Title>NoOp delete when ETag is null in AzureTableStorage provider</Title>
    <Description>This is to prevent exceptions from Azure Storage SDK when Delete is called with `Etag=null`, i.e. when state for that grain hasn't been written to the storage.

Closes #5219 </Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>09/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5577</PullRequestID>
        <IssueID>5219</IssueID>
        <Title>Clearing state failed for grain which hasn't been yet saved to AzureTable storage</Title>
        <Description>Good day to all.

Calling ClearStateAsync failed with exception when grain instance doesn't have table record.

This is because of grainState.Etag is null during grain Activation if it doesn't have a table record.
Possible solutions:
- Skip deletion for null Etag
- Using '*' as Etag value for null Etag

Exception details:

Exc level 0: System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data, String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation, String grainType, GrainReference grainReference, String tableName, String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130
System.ArgumentException: Delete requires an ETag (which may be the '*' wildcard).
   at Microsoft.WindowsAzure.Storage.Table.TableOperation.Delete(ITableEntity entity) in C:\Program Files (x86)\Jenkins\workspace\release_dotnet_master\Lib\Common\Table\TableOperation.Common.cs:line 190
   at Orleans.Persistence.AzureStorage.AzureTableDataManager`1.DeleteTableEntryAsync(T data, String eTag) in D:\build\agent\_work\24\s\src\Azure\Shared\Storage\AzureTableDataManager.cs:line 320
   at Orleans.Storage.AzureTableGrainStorage.GrainStateTableDataManager.Delete(GrainStateRecord record) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 454
   at Orleans.Storage.AzureTableGrainStorage.DoOptimisticUpdate(Func`1 updateOperation, String grainType, GrainReference grainReference, String tableName, String currentETag) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 160
   at Orleans.Storage.AzureTableGrainStorage.ClearStateAsync(String grainType, GrainReference grainReference, IGrainState grainState) in D:\build\agent\_work\24\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs:line 139
   at Orleans.Core.StateStorageBridge`1.ClearStateAsync() in D:\build\agent\_work\24\s\src\Orleans.Runtime\Storage\StateStorageBridge.cs:line 130

</Description>
        <CreatedDate>04/12/2018</CreatedDate>
        <ClosedDate>09/05/2019</ClosedDate>
        <Labels>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5576</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Cherry-pick #5570 and #5575 for 2.3.2</Title>
    <Description>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt; (#5570)
Accommodate existing RequestContext.PropagateActivityId value in ClusterClient (#5575)</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>03/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5576</PullRequestID>
        <IssueID>5570</IssueID>
        <Title>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt;</Title>
        <Description>Fixes #5569 

The change has been tested in a real cluster.</Description>
        <CreatedDate>02/05/2019</CreatedDate>
        <ClosedDate>03/05/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5576</PullRequestID>
        <IssueID>5575</IssueID>
        <Title>Fix RequestContext.PropagateActivityId value in Hosted Client scenario</Title>
        <Description>When hosted client is enabled (default in 2.3.0+), the value of `SiloMessagingOptions.PropagateActivityId` is being overridden by `ClientMessagingOptions.PropagateActivityId` in the `ClusterClient` constructor.

This workaround ensures that the `SiloMessagingOptions` value takes precedence. It's not perfect - a user could set conflicting values on both classes.

See long-term fix in #5574</Description>
        <CreatedDate>03/05/2019</CreatedDate>
        <ClosedDate>03/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5575</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix RequestContext.PropagateActivityId value in Hosted Client scenario</Title>
    <Description>When hosted client is enabled (default in 2.3.0+), the value of `SiloMessagingOptions.PropagateActivityId` is being overridden by `ClientMessagingOptions.PropagateActivityId` in the `ClusterClient` constructor.

This workaround ensures that the `SiloMessagingOptions` value takes precedence. It's not perfect - a user could set conflicting values on both classes.

See long-term fix in #5574</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>03/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5575</PullRequestID>
        <IssueID>5574</IssueID>
        <Title>[WIP] Remove base class from [Client,Silo]MessagingOptions</Title>
        <Description>This separates the `MessagingOptions` base class from `ClientMessagingOptions` and `SiloMessagingOptions`.

This is a breaking change: users may have to fix some code so that their application continues to compile.

Effectively subsumes #4753.</Description>
        <CreatedDate>03/05/2019</CreatedDate>
        <ClosedDate>09/07/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5573</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Cherry-pick #5561 for 2.3.2</Title>
    <Description>On the client, close gateway connection to dead silos (#5561)</Description>
    <CreatedDate>03/05/2019</CreatedDate>
    <ClosedDate>03/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5573</PullRequestID>
        <IssueID>5561</IssueID>
        <Title>On the client, close gateway connection to dead silos</Title>
        <Description>Fix for #5560 </Description>
        <CreatedDate>26/04/2019</CreatedDate>
        <ClosedDate>30/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5570</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ilyalukyanov</FixedByID>
    <Title>Prevent NullReferenceException with some storage providers when state is Nullable&lt;T&gt;</Title>
    <Description>Fixes #5569 

The change has been tested in a real cluster.</Description>
    <CreatedDate>02/05/2019</CreatedDate>
    <ClosedDate>03/05/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5570</PullRequestID>
        <IssueID>5569</IssueID>
        <Title>Possible NullReferenceException in AzureTableStorage.ReadStateAsync for Grain&lt;Nullable&lt;T&gt;&gt;</Title>
        <Description>If `Nullable&lt;T&gt;` is used for grain state type, the following line will throw a NullReference Exception: https://github.com/dotnet/orleans/blob/v2.3.1/src/Azure/Orleans.Persistence.AzureStorage/Providers/Storage/AzureTableStorage.cs#L83

This would happen as `StateStorageBridge&lt;TState&gt;` instantiates it as `new GrainState&lt;TState&gt;(new TState())`, and when `TState` is e.g. `int?`, then `(new int?()) == null)`.

I'm going to submit a PR that fixes that shortly.</Description>
        <CreatedDate>02/05/2019</CreatedDate>
        <ClosedDate>03/05/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5561</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>On the client, close gateway connection to dead silos</Title>
    <Description>Fix for #5560 </Description>
    <CreatedDate>26/04/2019</CreatedDate>
    <ClosedDate>30/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5561</PullRequestID>
        <IssueID>5560</IssueID>
        <Title>Client does not close connection to a dead Silo</Title>
        <Description>If a Silo stop responding to other silos for some reason, it will be voted `Dead`. The silo in question will then shutdown itself, closing all sockets.

Clients does not check for this status, and instead just get the list of active gateways on a regular basis. If a silo has been voted `Dead`, but for some reason its socket are still open, clients will continue to send message to this faulty silo.</Description>
        <CreatedDate>26/04/2019</CreatedDate>
        <ClosedDate>07/05/2019</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5545</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Alxandr</FixedByID>
    <Title>Fix DI scope issue in azure blob</Title>
    <Description>Closes: #5543</Description>
    <CreatedDate>23/04/2019</CreatedDate>
    <ClosedDate>23/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5545</PullRequestID>
        <IssueID>5543</IssueID>
        <Title>Cannot resolve scoped service 'Microsoft.Extensions.Options.IOptionsSnapshot`1[Orleans.Configuration.AzureBlobStorageOptions]' from root provider.</Title>
        <Description>I enabled validation of services on the service provider, and this gives me an `InvalidOperationException` with the message `Cannot resolve scoped service 'Microsoft.Extensions.Options.IOptionsSnapshot`1[Orleans.Configuration.AzureBlobStorageOptions]' from root provider.`.

The issue stems from the `GetService` call here: https://github.com/dotnet/orleans/blob/master/src/Azure/Orleans.Persistence.AzureStorage/Hosting/AzureBlobSiloBuilderExtensions.cs#L110.

It seems that calling `GetService(MyScopedServiceType)` on a root service provider is disallowed. Any reason this is using a factory function, and not just using normal constructor injection?</Description>
        <CreatedDate>23/04/2019</CreatedDate>
        <ClosedDate>23/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5522</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #5519: use local silo as default primary silo</Title>
    <Description>Fixes #5519</Description>
    <CreatedDate>08/04/2019</CreatedDate>
    <ClosedDate>10/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5522</PullRequestID>
        <IssueID>5519</IssueID>
        <Title>Development clustering: Primary silo endpoint optional?</Title>
        <Description>Hi, the documentation says:
       
     // &lt;param name="primarySiloEndpoint"&gt;
    /// The endpoint of the primary silo, or &lt;see langword="null"/&gt; to use this silo as the primary.
    /// &lt;/param&gt;

But in code I see:

https://github.com/dotnet/orleans/blob/1d49d416e04f4ce7b354a87db8f2b0bbf0744687/src/Orleans.Runtime/MembershipService/SystemTargetBasedMembershipTable.cs#L34</Description>
        <CreatedDate>08/04/2019</CreatedDate>
        <ClosedDate>10/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5498</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>seniorquico</FixedByID>
    <Title>Add UseLinuxEnvironmentStatistics method for ISiloBuilder</Title>
    <Description>Fixes #5497.</Description>
    <CreatedDate>02/04/2019</CreatedDate>
    <ClosedDate>02/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5498</PullRequestID>
        <IssueID>5497</IssueID>
        <Title>Add ISiloBuilder support to UseLinuxEnvironmentStatistics</Title>
        <Description>The `UseLinuxEnvironmentStatistics` extension method in the new Orleans.TelemetryConsumers.Linux package [only operates on a `ISiloHostBuilder`](https://github.com/dotnet/orleans/blob/v2.3.0/src/TelemetryConsumers/Orleans.TelemetryConsumers.Linux/HostBuilderExtensions.cs#L48). I was playing around with the new `ISiloBuilder` and got stuck. Just as a quick test... I wrapped my `ISiloBuilder` in a `ISiloHostBuilder` facade, piped `ConfigureServices` through, and it appeared to work as expected.

Should there be a second `UseLinuxEnvironmentStatistics` extension method that operates on a `ISiloBuilder`? Or am I missing part of the new `ISiloBuilder` pattern?</Description>
        <CreatedDate>01/04/2019</CreatedDate>
        <ClosedDate>02/04/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5487</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JorgeCandeias</FixedByID>
    <Title>Reactive Caching Sample Leftovers</Title>
    <Description>Here are the rest of the changes for now. If #5485 surfaces a better approach, I'll come back to this.

Not super happy with [this commit](https://github.com/dotnet/orleans/commit/54ab4c1abae8e9b2a8d0f3266bd8777e9108bead) though. Is there any way we can disable the timeout warnings only for specific calls?

Also, very grateful for the tips on the previous PR! 👍 </Description>
    <CreatedDate>29/03/2019</CreatedDate>
    <ClosedDate>03/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5487</PullRequestID>
        <IssueID>5485</IssueID>
        <Title>Question: How can one access the IReminderRegistry from a static Grain extension method.</Title>
        <Description>I'm attempting to write a static extension method for the `Grain` type, which, in addition to other things, also registers a timer.

The easiest way would be to call `RegisterTimer()` from the grain, however that method is protected and hence not available to a static extension method.

I'd like to avoid weird stuff like creating an extension `.UseSomething()` method on `IHostBuilder` to expose the timer registry to some static variable.

Is there some nice way to reach the `ITimerRegistry` in this context?</Description>
        <CreatedDate>29/03/2019</CreatedDate>
        <ClosedDate>05/05/2019</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5424</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Improve activation &amp; directory convergence</Title>
    <Description>Rebasing and fixing comments from #4344 </Description>
    <CreatedDate>06/03/2019</CreatedDate>
    <ClosedDate>02/04/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5424</PullRequestID>
        <IssueID>4344</IssueID>
        <Title>[WIP] Improve activation &amp; directory convergence</Title>
        <Description>This is for consideration - I'm not expecting it to be merged as-is.

This changes the implementation of GrainDirectoryHandoffManager to use a queue for executing operations. Each operation must complete successfully before the next operation begins execution.

Using that system, we add resiliency to some of the grain directory balancing operations.
When cluster membership changes, duplicate activations on existing silos are reliably destroyed.</Description>
        <CreatedDate>28/03/2018</CreatedDate>
        <ClosedDate>25/03/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5413</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Throw during startup if no grain classes/interfaces in app parts</Title>
    <Description>Fixes #5288</Description>
    <CreatedDate>28/02/2019</CreatedDate>
    <ClosedDate>28/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5413</PullRequestID>
        <IssueID>5288</IssueID>
        <Title>SiloHostBuilder.Build() should throw if AddApplicationPart() added no app grain classes</Title>
        <Description>#4785 exposed this gap - if a grain class projects lacks the codegen NuGet package, then calling `AddApplicationPart()` on the grain assembly ends up being an no-op due to missing metadata. However, `SiloHostBuilder.Build()` executes fine without warning the users about likely missing grain classes. This is an easy to make mistake when learning Orleans.

The proposal is to have `SiloHostBuilder.Build()` throw if no application grain classes were added.</Description>
        <CreatedDate>02/01/2019</CreatedDate>
        <ClosedDate>28/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5412</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix codegen warnings in source tree</Title>
    <Description>Fixes #5255

Also fixes the source line when the warning is emitted so that it will show correctly in VS/tooling</Description>
    <CreatedDate>28/02/2019</CreatedDate>
    <ClosedDate>28/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5412</PullRequestID>
        <IssueID>5255</IssueID>
        <Title>Fix build warnings caused by new codegen in test tree </Title>
        <Description>The warning introduced in #5031 shows up in our build logs because some test state classes inherit from `Dictionary&lt;,&gt;`</Description>
        <CreatedDate>12/12/2018</CreatedDate>
        <ClosedDate>28/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5407</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #5398: AmbiguousMatchException in code generator</Title>
    <Description>Fixes #5398

The cut over to the new code generator which occurred in 2.2.4 meant that we are now potentially emitting multiple OrleansGeneratedCodeAttributes and this is causing issues with the old code generator

Also dropped superfluous `GeneratedCodeAttribute` - it's not our attribute and we don't care about it.</Description>
    <CreatedDate>28/02/2019</CreatedDate>
    <ClosedDate>28/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5407</PullRequestID>
        <IssueID>5398</IssueID>
        <Title>System.Reflection.AmbiguousMatchException: 'Multiple custom attributes of the same type found.'</Title>
        <Description>Hi,

When I used the Dashboard v2.2.0 with Orleans.Server v2.2.4 the following exception throws:

``
The workaround is to downgrade Microsoft.Orleans.Server to v2.2.0 and just worked again... but would be nice if latest verions can be used. 
</Description>
        <CreatedDate>25/02/2019</CreatedDate>
        <ClosedDate>28/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5404</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Backport PRs #3974 and #5184 to 1.5.7</Title>
    <Description> #3974 (Fixes for Multi-Cluster Support).
#5184 (Add GSI cache maintenance and tests).</Description>
    <CreatedDate>27/02/2019</CreatedDate>
    <ClosedDate>27/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5404</PullRequestID>
        <IssueID>3974</IssueID>
        <Title>Fixes for Multi-Cluster Support</Title>
        <Description>It's been a while since we added multi-cluster support. Running all the tests, I found some bugs:

- when running with at least three clusters, and activating a grain concurrently, messages could get forwarded excessively, causing activation to fail (due to the forward count limit). I fixed this by forwarding only to destinations that are known to be the owner.
- Message.cs contained a bug that made the IsReturnedFromRemoteCluster flag not work correctly. This could also cause excessive forwarding, and failure to remove stale directory cache entries.
- in two places, NullReferenceExceptions were thrown when multi-clusters had no gateways reporting. I put in the proper handling of these situations.
- some tests were failing because the gsi-directory-maintenance was happening too late. To fix this I changed the periodic maintenance loop so it  runs the maintenance immediately after each multi-cluster-configuration change.

I also fixed some tracing issues and added more tests to the Functional category, so we can cover these types of errors in regression.
</Description>
        <CreatedDate>06/02/2018</CreatedDate>
        <ClosedDate>20/03/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5404</PullRequestID>
        <IssueID>5184</IssueID>
        <Title>Add GSI cache maintentance and tests</Title>
        <Description>Fixes the problem where a global-single-instance grain becomes permanently unavailable on a cluster because its directory entry points to a remote cluster that is no longer responsive, even if that cluster has been removed from the multi-cluster.

I added tests to expose the problem behavior, and code that implements a fix.

**Tests:**

The tests use two clusters A and B, create a grain in A, then access it from B (which means cluster B now caches the reference to the grain in A). Then I block communication from A to B (to simulate cluster A going down), and change the multi-cluster configuration to remove A from the multi-cluster (to simulate an admin responding to the outage). Then I try to access the grain from B. Without the fix, this times out trying to contact a non-responding silo in cluster A. With the fix (and if I wait long enough for the cache cleanup to complete before trying to access the grain) this succeeds because the dangling cached reference was removed.

The difference between the two tests is scale (number of grains, silos, clients).

**Fix:**

I added code that validates GSI remote references stored in the grain directory. It is triggered both periodically (30s default), and also immediately after a multi-cluster configuration change.

The validation logic is pretty simple: To check if a reference to a remote cluster should be kept, it pings the silo, and the silo responds with its cluster ID (this is not a throughput hazard… the whole validation happens at a low period, there is only one ping per remote silo, and the ping is a tiny message).

If the response indicates the cluster is not part of the configuration, OR if the response times out, we remove the GSI remote reference from the grain directory. 

This is always safe from a correctness perspective (the reference is logically just a cache), and from a performance perspective, I believe it is ok also: if things are in flux or we timed out for random reasons, it just means the cache may be removed sooner than necessary, but still not “extremely too soon” since this whole validation triggers at a modest period (30s default). 

</Description>
        <CreatedDate>19/11/2018</CreatedDate>
        <ClosedDate>12/12/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5399</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>alexmg</FixedByID>
    <Title>Upgraded Microsoft.Azure.EventHubs package to 3.0.0.</Title>
    <Description>The `Microsoft.Azure.EventHubs` package was upgraded to `2.2.1` to resolve #5369. 

A `3.0.0` version of this package has recently been released. 

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/3.0.0

This PR extends the upgrade to `3.0.0` and takes advantage of the `EventData.SystemProperties` being made public to remove reflection based helpers.</Description>
    <CreatedDate>26/02/2019</CreatedDate>
    <ClosedDate>27/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5399</PullRequestID>
        <IssueID>5369</IssueID>
        <Title>Unable to use Microsoft.Azure.EventHubs package greater than 1.0.3 with Microsoft.Orleans.OrleansServiceBus</Title>
        <Description>It is not possible to use a version of `Microsoft.Azure.EventHubs` greater than `1.0.3` in the same application as Orleans if the EventHubs stream provider is being used.

The `Microsoft.Orleans.OrleansServiceBus` package depends on version `1.0.3` of `Microsoft.Azure.EventHubs` (released Aug 23, 2017) and breaking changes have been made in later releases.

Even though it is not called out specifically in the release notes for `1.1.0` the `EventHubClient.CreateReceiver` method signature was changed to include an optional `ReceiverOptions` parameter.

https://github.com/Azure/azure-event-hubs-dotnet/releases/tag/1.1.0

A `MissingMethodException` is thrown when the `EventHubAdapterReceiver` attempts to create the `PartitionReceiver` due to the additional parameter that was added to the overload being used.

``

It appears that the constant value `"-1"` has been moved to an internal property of the `EventPosition` class.

https://github.com/Azure/azure-event-hubs-dotnet/blob/8aae6b6ec1af44de69326288854f5811985db539/src/Microsoft.Azure.EventHubs/EventPosition.cs#L21

I have investigated the changes required to upgrade `Microsoft.Azure.EventHubs` in a fork.

- Modify `Directory.Build.props` to update `Microsoft.Azure.EventHubs` package to `2.2.1` and `System.Net.Http` to `4.3.3` (to prevent downgrade in other projects).
- The `EventHubConstants.StartOfStream` property can be replaced with the constant `"-1"` leaving the value as a `string`.
- `EventPosition` is only required when creating the `PartitionReceiver` which is done inside the `EventHubAdapterReceiver.CreateReceiver` method where the offset (`string`) and inclusive flag (`bool`) are already available.
- Update reflection based code in `EventHubUtils` to cater for internal changes to `EventData`. Reflection is no longer required for setting the `Offset`, `SequenceNumber`, `EnqueuedTime` and `PartitionKey` properties, but is still required to initialize `SystemProperties` with a new `SystemPropertiesCollection` when `null`.

The unit tests are passing with the exception of `EHBatchedSubscriptionMultiplicityTests.EHBatchedMultipleLinearSubscriptionTest`. This fixture contains integration style tests that I had to point at my own EventHub and Storage Table to get working. I wasn't sure if this failure was related to the upgrade so I ran the same test without the upgrade and it still fails for me locally. I assume there is a difference between my setup and the one used in your build system.

I would be happy to put together a PR with these changes if you are interested.</Description>
        <CreatedDate>15/02/2019</CreatedDate>
        <ClosedDate>25/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5396</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Mark ILBasedSerializer as obsolete</Title>
    <Description>Fixes #5391</Description>
    <CreatedDate>25/02/2019</CreatedDate>
    <ClosedDate>25/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5396</PullRequestID>
        <IssueID>5391</IssueID>
        <Title>Mark ILBasedSerializer et al as [Obsolete]</Title>
        <Description>We created this serializer for cases where BinaryFormatter would otherwise be used, since BF was not going to be made available on .NET Core/.NET Standard. Since it is available there is no need for it.</Description>
        <CreatedDate>23/02/2019</CreatedDate>
        <ClosedDate>25/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5395</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Enable HostedClient by default</Title>
    <Description>Fixes #5337</Description>
    <CreatedDate>25/02/2019</CreatedDate>
    <ClosedDate>27/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5395</PullRequestID>
        <IssueID>5337</IssueID>
        <Title>Enable hosted client by default</Title>
        <CreatedDate>26/01/2019</CreatedDate>
        <ClosedDate>27/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5385</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Update to Microsoft.Extensions.Options 2.1.1 and remove duplicated classes</Title>
    <Description>for #4703 </Description>
    <CreatedDate>22/02/2019</CreatedDate>
    <ClosedDate>22/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5385</PullRequestID>
        <IssueID>4703</IssueID>
        <Title>Update Microsoft.Extensions.Options to 2.1.1 and remove duplicate functionality</Title>
        <Description>Now that Options 2.1.x is released, we can update to it and remove:

* `OptionBuilder&lt;T&gt;`
* `OptionsServiceCollectionExtensions`
* `OptionsBuilderConfigurationExtensions`
* `ConfigureNamedOptions&lt;TOptions, TDep&gt;`
* `PostConfigureOptions&lt;TOptions, TDep&gt;`

Note that this would be considered a breaking change, since it removes those types (some of which are public) and modifies many configuration APIs to use the equivalent types in the options package (same type names, different namespace &amp; assembly)

However, if we don't do it then we may see some clashes for users who update that package on their own accord (eg, since it's a dependency of ASP.NET bits).

Question is: are we ok with that minor breakage and what kind of version bump do we want to associate with it, a minor (2.1.0) or a major (3.0.0)?

PoC branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:update-options</Description>
        <CreatedDate>21/06/2018</CreatedDate>
        <ClosedDate>25/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5365</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Migrate src subdirectory to new codegen</Title>
    <Description>Fixes #5357 
See #5360 &amp; #5361

Tested with 10 successful builds on VSO
</Description>
    <CreatedDate>13/02/2019</CreatedDate>
    <ClosedDate>13/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5365</PullRequestID>
        <IssueID>5357</IssueID>
        <Title>Migrate src tree to source-to-source code generator</Title>
        <Description>The current code generator prevents us from pulling in some packages. So far we have had good  success with the new code generator.

I feel it's time to migrate the `src` subdirectory from the old code generator to the new one. The `test` subdir is already using the new one.

I believe we should do this for 2.3.0</Description>
        <CreatedDate>11/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5365</PullRequestID>
        <IssueID>5360</IssueID>
        <Title>Migrate src subdirectory to new codegen</Title>
        <Description>Fixes #5357

* Migrates all projects in Orleans.sln to the new code generator
* Improves build and rebuild time (rebuild down to 9.5s on my laptop)
* Improves build reliability</Description>
        <CreatedDate>11/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5365</PullRequestID>
        <IssueID>5361</IssueID>
        <Title>Revert "Migrate src subdirectory to new codegen (#5360)"</Title>
        <Description>This reverts commit 9c4a0ce3ef78e761fe0222204a50a8408ba7bdad.

We hit issues in Azure DevOps</Description>
        <CreatedDate>12/02/2019</CreatedDate>
        <ClosedDate>12/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5360</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Migrate src subdirectory to new codegen</Title>
    <Description>Fixes #5357

* Migrates all projects in Orleans.sln to the new code generator
* Improves build and rebuild time (rebuild down to 9.5s on my laptop)
* Improves build reliability</Description>
    <CreatedDate>11/02/2019</CreatedDate>
    <ClosedDate>11/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5360</PullRequestID>
        <IssueID>5357</IssueID>
        <Title>Migrate src tree to source-to-source code generator</Title>
        <Description>The current code generator prevents us from pulling in some packages. So far we have had good  success with the new code generator.

I feel it's time to migrate the `src` subdirectory from the old code generator to the new one. The `test` subdir is already using the new one.

I believe we should do this for 2.3.0</Description>
        <CreatedDate>11/02/2019</CreatedDate>
        <ClosedDate>11/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5343</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #5342: Incorrect specification of global alias</Title>
    <Description>Tested against the sample which @jbrestan provided in #5342 </Description>
    <CreatedDate>31/01/2019</CreatedDate>
    <ClosedDate>31/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5343</PullRequestID>
        <IssueID>5342</IssueID>
        <Title>Runtime code generation issue with Orleankka, TestCluster and OrleansCodeGenerator 2.2.3</Title>
        <Description>When using `Microsoft.Orleans.OrleansCodeGenerator` 2.2.3 with `Orleankka.FSharp` 2.2, the runtime code generation fails for `Orleans.TestingHost.TestCluster` with the following error (taken from the reproduction below):
``
So far I was only able to reproduce it with the test cluster and using Orleankka. Even with Orleankka the production silo and client work fine with 2.2.3 code generator. I'm not sure if F# is also a factor, I haven't tried with C#.

I have reproduction as a unit test in the F# .NET Core sample:
https://github.com/jbrestan/orleans/tree/codegen-runtime-repro/Samples/2.1/FSharp.NetCore/test/FSharp.NetCore.GrainTests
Running `dotnet test` should result in the error message above. If you downgrade OrleansCodeGenerator to 2.2, the test should pass as expected.

Let me know if I can provide more details.</Description>
        <CreatedDate>31/01/2019</CreatedDate>
        <ClosedDate>31/01/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5334</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>justmara</FixedByID>
    <Title>added OnActivate reentrancy test</Title>
    <Description>This test fails on recursive call from OnActivateAsync(). This is for #5331</Description>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>07/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5334</PullRequestID>
        <IssueID>5331</IssueID>
        <Title>Deadlocks on recursive calls</Title>
        <Description>The #3185 issue was closed a year ago, but we're still getting problems with reentrant calls (using orleans 2.2 on netcore/linux).
Assuming interfaces
``
and the call `await cluster.GrainFactory.GetGrain&lt;IGrainA&gt;(1).Start(5)` results in deadlock that fails with timeout.</Description>
        <CreatedDate>24/01/2019</CreatedDate>
        <ClosedDate>07/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5293</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JillHeaden</FixedByID>
    <Title>Clarifies Setup section of "Developing a Grain" document. </Title>
    <Description>Fixes #4785</Description>
    <CreatedDate>03/01/2019</CreatedDate>
    <ClosedDate>03/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5293</PullRequestID>
        <IssueID>4785</IssueID>
        <Title>"Developing a Grain" doc</Title>
        <Description>1. 2.0 (.Net Standard based, right?) doc says to create a class project targeting .Net 4.6.1 - this is confusing
1. It says to install the nuget pkg `Microsoft.Orleans.OrleansCodeGenerator.Build` in to the class library, but merely doing this does not resolve the sample code properly (ie: `IGrainWithGuidKey`, `IGameGrain`, etc)
~~~
PlayerGrain.cs(10,37,10,54): error CS0246: The type or namespace name 'IGrainWithGuidKey' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(18,32,18,37): error CS0246: The type or namespace name 'Grain' could not be found (are you missing a using directive or an assembly reference?)
PlayerGrain.cs(12,14,12,24): error CS0246: The type or namespace name 'IGameGrain' could not be found (are you missing a using directive or an assembly reference?)
~~~</Description>
        <CreatedDate>20/07/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P1</Label>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5290</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Add CollectionAge validation to GrainCollectionOptions</Title>
    <Description>Fix issue #5200 </Description>
    <CreatedDate>02/01/2019</CreatedDate>
    <ClosedDate>12/01/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5290</PullRequestID>
        <IssueID>5200</IssueID>
        <Title>SiloHostBuilder not validating GrainCollectionOptions during build</Title>
        <Description>**Repro code:**

``

**Expected behavior**
The call to siloHostBuilder.Build() should throw an exception because the specified TimeSpan for options.Collection age is less than 1 minute.

**Actual behavior**
The call to siloHostBuilder.Build() succeeds, however, activations will fail because the TimeSpan is less than 1 minutes.  Moreover, when the runtime throws the exception on the silo when the activation fails, the exception never reaches the client which made the initial request to the cluster, and the client experiences a timeout.</Description>
        <CreatedDate>28/11/2018</CreatedDate>
        <ClosedDate>18/03/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5261</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>galvesribeiro</FixedByID>
    <Title>Microsoft.Extensions.Hosting support</Title>
    <Description>This PR adds [Microsoft.Extensions.Hosting](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1) support for Orleans (aka _Generic Host_).

This PR is being worked out aligned with @ReubenBond and the strategy described [here](https://github.com/dotnet/orleans/issues/4702#issuecomment-446684609).

Fixes #4702</Description>
    <CreatedDate>14/12/2018</CreatedDate>
    <ClosedDate>07/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5261</PullRequestID>
        <IssueID>4702</IssueID>
        <Title>Support Microsoft.Extensions.Hosting.Abstractions</Title>
        <Description>In Orleans 2.0, we added `SiloHostBuilder`, which was designed to align with `IHostBuilder` from the `Microsoft.Extensions.Hosting.Abstractions` package (which wasn't yet released).

The intention was that `SiloHostBuilder` would be temporary and we would add support for the [generic host](https://github.com/aspnet/Hosting/issues/1163) once it became available.

It's available now, so we can consider adding support for it.

ASP.NET folks have a similar issue opened for `WebHostBuilder`: https://github.com/aspnet/Hosting/issues/1421. They've scheduled it for 3.0.0, so I imagine it will be a year or more before they move over.

I have a PoC for this on a branch here: https://github.com/dotnet/orleans/compare/master...ReubenBond:feature-generic-host

cc @galvesribeiro &amp; @attilah who asked for this today</Description>
        <CreatedDate>21/06/2018</CreatedDate>
        <ClosedDate>07/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>5239</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Mark key legacy types/methods as [Obsolete]</Title>
    <Description>Fixes #5221

I disabled legacy type warnings for the `test` subtree, maybe that's questionable. The alternative is to either:

1. Port all tests away from `[Obsolete]` types
2. Individually mark every file with the right `#pragma` incantation
3. Individually surround every usage with the right `#pragma`

I figured:

* 1 is too much work for now (especially between rc and final)
* 2 offers little benefit over the chosen approach with more cost
* 3 would make code ugly since it requires many changes which will eventually need to be undone before (presumably) 3.0.</Description>
    <CreatedDate>11/12/2018</CreatedDate>
    <ClosedDate>22/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>5239</PullRequestID>
        <IssueID>5221</IssueID>
        <Title>Mark legacy types as [Obsolete]</Title>
        <Description>We do not plan to ship legacy packages and classes like `AzureSilo` and `AzureClient` as part of 3.0 because they will have outlived their utility by then. To communicate this intent, we need to mark all types that will be going away as [Obsolete] now, so that people have enough time to plan and adjust their code.</Description>
        <CreatedDate>05/12/2018</CreatedDate>
        <ClosedDate>22/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4994</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>rmja</FixedByID>
    <Title>Use grain state type when deserializing json state in azure table sto…</Title>
    <Description>…rage. Fixes #4993</Description>
    <CreatedDate>17/09/2018</CreatedDate>
    <ClosedDate>13/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4994</PullRequestID>
        <IssueID>4993</IssueID>
        <Title>InvalidCastException when deserializing json state when custom JsonProperty is used with TypeNameHandling.None</Title>
        <Description>`InvalidCastException` is thrown when deserializing json state using the Azure Table Storage provider if the state was serialized with properties having the `JsonProperty` attribute with a redefining property name. The exception is thrown if the state is stored with `TypeNameHandling.None`.

A PR is coming...
</Description>
        <CreatedDate>17/09/2018</CreatedDate>
        <ClosedDate>13/02/2019</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4753</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[WIP] Support configuration of messaging options via MessagingOptions</Title>
    <Description>Fixes #4751</Description>
    <CreatedDate>10/07/2018</CreatedDate>
    <ClosedDate>22/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4753</PullRequestID>
        <IssueID>4751</IssueID>
        <Title>Response timeout is not respected</Title>
        <Description>We're using 2.0.3 and despite configured 10s timeout for both client (embedded in the same process) and silo, we sometimes see 30 second TimeoutException in logs:

``

This usually happens after ungraceful shutdown of the silo ...</Description>
        <CreatedDate>09/07/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P3</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4275</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>WIP - More aggressively cleanup system target stream producers.</Title>
    <Description>This is part of a follow-up on stream rebalancing issues raised by @ilyalukyanov in Stream resubscription issues #3484.

The concern was that inactive system target stream producers were not being cleaned up in the pubsub state, leading to streams that could no longer be subscribed to or unsubscribed from.

There is an issue here, though I am unconvinced it is the cause of the behaviors @ilyalukyanov is seeing.  This conclusion comes from the fact that in @ilyalukyanov's scenario, silos were being killed, so the system target stream producers on those silo, by the existing logic, should be cleaned up.  The system target stream producers that where rebalanced would have unregistered as part of the queue rebalancing.  Only if the unregister operation had failed would this bug manifest.  That would have shown up in the logs.

This PR is marked WIP, because it's not yet obvious that this is the right fix.  It's not clear under what conditions the OrleansMessageRejectionException is returned.  The GetApproximateSiloStatus check implies that it was expected that there was a possibility for OrleansMessageRejectionException to be received when the producer was still valid, and I've yet been unable to rule this out.  The cost of getting this wrong is that healthy producers could be removed, thus no longer be notified of subscription changes on that stream.</Description>
    <CreatedDate>21/03/2018</CreatedDate>
    <ClosedDate>28/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4275</PullRequestID>
        <IssueID>3484</IssueID>
        <Title>Stream resubscription issues</Title>
        <Description>Every time we redeploy silos clients cannot resubscribe to stream and so we're forced to redeploy them as well. We do resubscribe once we received ClusterConnectionLost event (we retry infinitely). The weird thing that client actually reconnects and can communicate with actors, it's only streams which are broken.

This is what we see in a logs:

``

</Description>
        <CreatedDate>02/10/2017</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4185</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>[WIP] Shutdown forward workaround</Title>
    <Description>Related issue: #2287 

It's not a fix, it's a workaround. Not pretty, but I believe it has some value.

The issue is pretty "simple" when the silo shutdown, it will

1. Deactivate all grain activations 
2. Then forward the pending requests.

The issue is that we do not await step 2. And it is not possible without some heavy code change right now. The proposed workaround is just to add a delay after deactivating grains, so the system has some time to send the pending requests.

Note that it is happening after we set the silo status to "stopping", so other silos should not try to place new activation on it.

I did not enabled `SiloGracefulShutdown_ForwardPendingRequest` since it is still failing sometimes... but at least it pass most of the time now.</Description>
    <CreatedDate>09/03/2018</CreatedDate>
    <ClosedDate>27/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4185</PullRequestID>
        <IssueID>2287</IssueID>
        <Title>Silo should forward request when asked to shutdown</Title>
        <Description>If I'm not mistaken, when a silo properly shutdown (not stop) it should:
1. Finish the requests that are being processed on locally activated grains (requests that were started to process before shutdown was called)
2. Then forward the remaining non processed requests to another silo so they can be completed by someone else

It seems that step 2. is not properly done. In this test https://github.com/benjaminpetit/orleans/commit/53631d95df931e6c416170d92bd6b4caeb0b1f45 the `await promisesAfterShutdown` throws `TimeoutException`

Am I missing something?
</Description>
        <CreatedDate>12/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2647</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>serbrech</FixedByID>
    <Title>[WIP] migrate sample adventuredotnetcli to new csproj</Title>
    <Description>The migration to the new csproj is done.  

It was noted that a dotnetcli sample not targeting dotnet core made little sense.  
Should I attempt to migrate the sample to the dotnet core bits? Or is it too early?  

part of #2359 </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>27/02/2019</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2647</PullRequestID>
        <IssueID>2359</IssueID>
        <Title>Migrate samples to 2.1</Title>
        <Description>The samples (https://github.com/dotnet/orleans/tree/master/Samples) are on 1.2.3 now. Shouldn't be to difficult to migrate them to 1.3.0.
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4883</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Add timeout mecanism for grain deactivation</Title>
    <Description>It's not the fix I intended to write, but I thinks used in conjunction with #4875, it should fix the issues encountered in #4774 and #4757 </Description>
    <CreatedDate>23/08/2018</CreatedDate>
    <ClosedDate>24/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4883</PullRequestID>
        <IssueID>4875</IssueID>
        <Title>Revisit silo stop/shutdown timeout</Title>
        <CreatedDate>23/08/2018</CreatedDate>
        <ClosedDate>23/08/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4883</PullRequestID>
        <IssueID>4774</IssueID>
        <Title>Race condition with interleaved messages using TCS</Title>
        <Description>We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is crucial to performance boosts we got from batching in our system.

We figured out that problem we're experiencing with graceful shutdown described in #4757 is due to Orleans not being able to deactivate some of the grains. This only happens when TaskCompletionSource is used (along with the buffering and timer-based completion).

I have a failing test (#4773) for this scenario you can pull and check. On the surface, it looks like after DeactivateOnIdle is called Orleans disposes the timer while there interleaved requests, which leaves tasks in the uncompleted state, thus preventing Orleans from deactivating the grain.

Please, advice what can be done wrt to this issue.</Description>
        <CreatedDate>17/07/2018</CreatedDate>
        <ClosedDate>30/08/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4883</PullRequestID>
        <IssueID>4757</IssueID>
        <Title>Incorrect silo shutdown behavior</Title>
        <Description>We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo, which is normal of course. Also there number of other actors that may exchange messages across silos, also normal, of course, since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo, neither from clients nor from other silos (basically, close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead, what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down), and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

``

This is unacceptable behavior for us, as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos, queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x, leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are, Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).</Description>
        <CreatedDate>11/07/2018</CreatedDate>
        <ClosedDate>30/08/2018</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4876</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix DI cycle involving OrleansJsonSerializer</Title>
    <Description>Fixes #4873</Description>
    <CreatedDate>23/08/2018</CreatedDate>
    <ClosedDate>23/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4876</PullRequestID>
        <IssueID>4873</IssueID>
        <Title>StackOverflowException when adding OrleansJsonSerializer as a SerializationProvider</Title>
        <Description>Workaround: use this gist instead https://gist.github.com/ReubenBond/45ef767aff071302ee62731b5c706dd7

Repro:
``

Only the silo fails, the client doesn't have a dependency cycle.</Description>
        <CreatedDate>22/08/2018</CreatedDate>
        <ClosedDate>23/08/2018</ClosedDate>
        <Labels>
          <Label>P2</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4871</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Rename UseDistributedTM to UseTransactions</Title>
    <Description>fix issue #4688 </Description>
    <CreatedDate>22/08/2018</CreatedDate>
    <ClosedDate>22/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4871</PullRequestID>
        <IssueID>4688</IssueID>
        <Title>Rename UseDistributedTM method</Title>
        <Description>The `UseDistributedTM()` method sits on `IServiceCollection` and `ISiloHostBuilder`, but there's no way that we should have a method so ambiguously named.

Please rename to `UseDistributedTransactionManager` or something more obvious.</Description>
        <CreatedDate>14/06/2018</CreatedDate>
        <ClosedDate>23/08/2018</ClosedDate>
        <Labels>
          <Label>P2</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4861</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>No default grains storage added to container if one is not configured.</Title>
    <Description>Addresses - IGrainStorage null implementation registerd in DI container #4710</Description>
    <CreatedDate>20/08/2018</CreatedDate>
    <ClosedDate>20/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4861</PullRequestID>
        <IssueID>4710</IssueID>
        <Title>IGrainStorage null implementation registerd in DI container</Title>
        <Description>We currently add the mapping:
services.TryAddSingleton&lt;IGrainStorage&gt;(sp =&gt; sp.GetServiceByName&lt;IGrainStorage&gt;(ProviderConstants.DEFAULT_STORAGE_PROVIDER_NAME));
any time we add a grain storage, not just when the default is added. This is wasteful, but also seems to break some containers, as returning null for a registered service is considered invalid for some containers. I'm not sure what the 'conforming container' rules are around this, but it's sloppy in any case.</Description>
        <CreatedDate>26/06/2018</CreatedDate>
        <ClosedDate>20/08/2018</ClosedDate>
        <Labels>
          <Label>P3</Label>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4853</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Do not place stateless worker locally if the silo is stopping</Title>
    <Description>Fix for #4852 and #4757 </Description>
    <CreatedDate>16/08/2018</CreatedDate>
    <ClosedDate>17/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4853</PullRequestID>
        <IssueID>4852</IssueID>
        <Title>Revisit handling of StatelessWorker grains during shutdown</Title>
        <Description>Base on the feedback in #4757, we need to reconsider how StatelessWorker grains are handled during silo shutdown.</Description>
        <CreatedDate>16/08/2018</CreatedDate>
        <ClosedDate>17/08/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4853</PullRequestID>
        <IssueID>4757</IssueID>
        <Title>Incorrect silo shutdown behavior</Title>
        <Description>We're experiencing serious problems with a rolling update after migration to 2.0. Let me explain our architecture: we have a single heterogenous Azure queue processed by multiple workers (Competing Consumers pattern). Each message in this queue may be destined to a differrent actor. The setup is quite similar to how built-in Azure Queue Streaming Provider works. See diagram below.

![2018-07-11 12_06_43-untitled diagram xml - draw io](https://user-images.githubusercontent.com/107726/42562033-5785be38-8503-11e8-9e9e-055862a2d9c4.png)

Each node runs pulling agent (queue poller)  and the corresponding TPL DataFlow pipeline outside of the silo but within the same process with the silo (ie embedded). It could happen that recipent actor may reside on a different silo and so the client may forward the message to another silo, which is normal of course. Also there number of other actors that may exchange messages across silos, also normal, of course, since that's the whole point of having Orleans.

The problem arises when we try to shutdown the silo during rolling update. My expectation of Orleans' silo shutdown behavior when `StopAsync()` is called:
1. Don't accept any *new* requests into the silo, neither from clients nor from other silos (basically, close silo gateway)
2. Wait until all outstanding requests are completed (or failed or timed out) and return results
3. Deactivate all actors
4. Done

Instead, what we see from logs is that upon receiving `StopAsync()` Orleans almost immedietely deactivates all actors and then for 1 minute it bounces requests from other clients/silos by trying to forward them to non-existent activations (and they are not reactivated on the current silo of course since it's shutting down), and after 1 minute it kills itself after silo stop timeout is expired (which is 1 minute as I can see from the code). During this time it (Orleans.Runtime.Dispatcher) spills tens of thousands of log messages like:

``

This is unacceptable behavior for us, as:
1. The whole cluster restart takes more than 10 minutes (more then 2 minutes per node. we have 5 nodes at the moment). Which is super slow.
2. Since during this time deactivated actors are not re-activated on other silos, queue messages are timing out and are returned to queue. For 10 minutes chaos which occur during restart messages may breach dequeue count threshold and be moved to quarantine queue. Which is super bad.
4. During restart the queue length may grow up to 100x, leading to client visible processing delays and additional stress. 
3. Our logs cluster (ES) is not made from rubber and on each restart Orleans can easily generate 0.5M log messages. With 10 deployments per day Orleans logs take a considerable amount of space.

The question is what are we doing wrong? No matter what we do we can't gracefully shutdown the silo. Our shutdown routine:
1. Stop all local pulling agents (silo local queue poller).
2. Wait\complete\cancel local pipeline
3. Stop the silo
4. Diconnect local client

It seems that all those steps are useless since requests from other clients\silos are still accepted by the silo after `StopAsync` is issued. I can't trace whether those requests were accepted just before `StopAsync()` but even if they are, Orleans *should not deactivate* actors until all those requests are completed.

P.S. I didn't include in this conversation hundreds of thousands of `SiloUnavailableException` and `OrleansMessageRejectionException` raised by sibling nodes during each restart - I belive it's a topic of its own (perhaps retries could be advised as the solution).</Description>
        <CreatedDate>11/07/2018</CreatedDate>
        <ClosedDate>30/08/2018</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4850</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix NullReferenceException in ExecutingWorkItemsTracker</Title>
    <Description>I hit a `NullReferenceException` here while debugging #4617.

The root cause was the order of initialization of `log` and `executingWorkTracker` in the `ThreadPoolExecutor` constructor.

This PR fixes that, adds some defensiveness, and cleans up the code a little.</Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>16/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4850</PullRequestID>
        <IssueID>4617</IssueID>
        <Title>[Test] TransactionWillRecoverAfterRandomSiloUnGracefulShutdown fails frequently</Title>
        <CreatedDate>22/05/2018</CreatedDate>
        <ClosedDate>30/11/2018</ClosedDate>
        <Labels>
          <Label>P1</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4844</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Fix partial build</Title>
    <Description>Tentative to bring #4740 to the master branch</Description>
    <CreatedDate>14/08/2018</CreatedDate>
    <ClosedDate>14/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4844</PullRequestID>
        <IssueID>4740</IssueID>
        <Title>2.0.4 partial build</Title>
        <Description>Please review each commit independently &amp; in order, it will make it much easier.

Here's my reasoning for these changes:

The below snippet is from Orleans.Server’s `Directory.Build.props` from before this PR. Its job is to determine whether or not the Orleans.Server package will reference `Microsoft.Orleans.OrleansProviders` via a `ProjectReference` or a `PackageReference`.

![image](https://user-images.githubusercontent.com/203839/42272738-76bffb94-7fca-11e8-9d2f-127dd71c6e24.png)

In the present case I need to bump `Server` to 2.0.4, since it refs `Runtime` (and we’re trying to publish `Runtime` 2.0.4 to fix this CoreFx bug). Given the above code, that means `Server` will try to pull `Providers` 2.0.4 from NuGet (which doesn't exist yet). So that’s broken (unless I’m doing it wrong?)

Instead, all of these conditional `&lt;PackageReference&gt;` elements should use the *referenced* package's version from the root `Directory.Build.props` file. The dependency relationship implies that if `ServerVersion != ProvidersVersion`, then `ServerVersion &gt; ProvidersVersion` and therefore `ProvidersVersion` must be published to NuGet already. Otherwise, (if they are equal) then we are currently building both packages and we should use a `&lt;ProjectReference&gt;` instead.

I had to split the Azure package group out into individually versioned packages because the published versions for those packages were inconsistent. Eg, 2.0.0 for most vs 2.0.3 for persistence. If preferred, I can undo this change and drag all Azure packages up to 2.0.4 even though only one package (cloud services) actually needs it.

In the case of the telemetry consumers, I pulled that forward to 2.0.4 since 2.0.3 (the currently specified version) is not published and as above, it would break the build now that we're moving on to 2.0.4.

In order to test locally, set the `FullBuild` environment variable to `false` and run `Build.cmd`. The result should be the following packages:
``</Description>
        <CreatedDate>05/07/2018</CreatedDate>
        <ClosedDate>05/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4830</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>When deactivating a grain, do not stop timers if there are running requests </Title>
    <Description>Fix for #4774 

Thanks @yevhen , I was able to repro this issue 100% with this test. Like said in the issue, this will fix only part of the issue.</Description>
    <CreatedDate>08/08/2018</CreatedDate>
    <ClosedDate>17/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4830</PullRequestID>
        <IssueID>4774</IssueID>
        <Title>Race condition with interleaved messages using TCS</Title>
        <Description>We're extensively using the async batcher pattern described by @hataytuna in this book
https://github.com/hataytuna/Distributed/raw/master/Applied%20Actor%20Model%20with%20Orleans%20v1.1.pdf It is crucial to performance boosts we got from batching in our system.

We figured out that problem we're experiencing with graceful shutdown described in #4757 is due to Orleans not being able to deactivate some of the grains. This only happens when TaskCompletionSource is used (along with the buffering and timer-based completion).

I have a failing test (#4773) for this scenario you can pull and check. On the surface, it looks like after DeactivateOnIdle is called Orleans disposes the timer while there interleaved requests, which leaves tasks in the uncompleted state, thus preventing Orleans from deactivating the grain.

Please, advice what can be done wrt to this issue.</Description>
        <CreatedDate>17/07/2018</CreatedDate>
        <ClosedDate>30/08/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4829</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JillHeaden</FixedByID>
    <Title>4692 gateway</Title>
    <Description>Fixed issue #4692 </Description>
    <CreatedDate>08/08/2018</CreatedDate>
    <ClosedDate>16/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4829</PullRequestID>
        <IssueID>4692</IssueID>
        <Title>Docs: Possible mistake in "Unreliable Deployment on a Cluster of Dedicated Servers"</Title>
        <Description>I tried to follow the guide for DevelopmentClustering
https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Deployment-and-Operations/Configuration-Guide/Typical-Configurations.md/#unreliable-deployment-on-a-cluster-of-dedicated-servers

When I ran the code the client couldn't connect, so I tried changing the client port, in the .UseStaticClustering()-call to the gateway port (30000). That seemed to do the trick.

I guess that it's a typo in the Docs but I'm extremely new to Orleans, so I don't want to assume to much.

If it is a typo I can fix it and submit a PR

Also, the ClusterId and and ServiceId mismatch between the silo and the client config, but I caught that before I even tried to run the code.</Description>
        <CreatedDate>15/06/2018</CreatedDate>
        <ClosedDate>06/09/2018</ClosedDate>
        <Labels>
          <Label>P1</Label>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4824</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Allow implicit subscription attribute to be inheritable</Title>
    <Description>ImplicitStreamSubscription Attribute inherit = false #1909 </Description>
    <CreatedDate>07/08/2018</CreatedDate>
    <ClosedDate>13/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4824</PullRequestID>
        <IssueID>1909</IssueID>
        <Title>ImplicitStreamSubscription Attribute inherit = false</Title>
        <Description>I was trying to implement a base grain class that has an implicit subscription, but it looks like Orleans doesn't support the `ImplicitStreamSubscription` on any base classes. Looking at the code it looks like this was intentionally excluded in `ImplicitStreamSubscriberTable.cs`
 `object[] attribs = grainClass.GetCustomAttributes(typeof(ImplicitStreamSubscriptionAttribute), inherit: false);`

Is there a reason for excluding the inheritance?
</Description>
        <CreatedDate>07/07/2016</CreatedDate>
        <ClosedDate>07/08/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4784</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Kritner</FixedByID>
    <Title>Adds additional dependencies for Grain.Impl and Grain.Interface projects</Title>
    <Description>- Fixes #4783
- May be beneficial to make `Microsoft.Orleans.OrleansCodeGenerator.Build` depend on `Microsoft.Orleans.Core.Abstractions` as to not require it as a separate package installation.

- Changes as per #4783 and discussion on gitter starting at https://gitter.im/dotnet/orleans?at=5b51f88bf9ffc4664bef9663</Description>
    <CreatedDate>20/07/2018</CreatedDate>
    <ClosedDate>20/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4784</PullRequestID>
        <IssueID>4783</IssueID>
        <Title>[Question] Readme issue for installation?</Title>
        <Description>I don't think i'm missing a step, but wanted to verify if the readme is missing something...

![image](https://user-images.githubusercontent.com/8814983/43007924-be038a9a-8c07-11e8-978a-d7daf9106e9b.png)

I have done so on all projects, and verified that both the "Client" and "Server" projects build, however both the grain interface and grain implementation projects do not, giving the compiler error:

``

Looking at the server and client packages from NuGet manager...
![image](https://user-images.githubusercontent.com/8814983/43008214-7071b3d2-8c08-11e8-935d-2dc157f30b6a.png)
![image](https://user-images.githubusercontent.com/8814983/43008249-899fffb2-8c08-11e8-8522-02fccb5c8792.png)

Both nuget packages have dependencies, however the grain projects....
![image](https://user-images.githubusercontent.com/8814983/43008319-bb823e78-8c08-11e8-92d3-464ea740b2cf.png)

have no dependencies, and are failing to build.

Are there packages are needed within the grain projects that aren't specified on the readme?  Which packages are those?  Orleans.Core?  Could these packages be set up as dependencies in the code generation projects?</Description>
        <CreatedDate>20/07/2018</CreatedDate>
        <ClosedDate>20/07/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4784</PullRequestID>
        <IssueID>4783</IssueID>
        <Title>[Question] Readme issue for installation?</Title>
        <Description>I don't think i'm missing a step, but wanted to verify if the readme is missing something...

![image](https://user-images.githubusercontent.com/8814983/43007924-be038a9a-8c07-11e8-978a-d7daf9106e9b.png)

I have done so on all projects, and verified that both the "Client" and "Server" projects build, however both the grain interface and grain implementation projects do not, giving the compiler error:

``

Looking at the server and client packages from NuGet manager...
![image](https://user-images.githubusercontent.com/8814983/43008214-7071b3d2-8c08-11e8-935d-2dc157f30b6a.png)
![image](https://user-images.githubusercontent.com/8814983/43008249-899fffb2-8c08-11e8-8522-02fccb5c8792.png)

Both nuget packages have dependencies, however the grain projects....
![image](https://user-images.githubusercontent.com/8814983/43008319-bb823e78-8c08-11e8-92d3-464ea740b2cf.png)

have no dependencies, and are failing to build.

Are there packages are needed within the grain projects that aren't specified on the readme?  Which packages are those?  Orleans.Core?  Could these packages be set up as dependencies in the code generation projects?</Description>
        <CreatedDate>20/07/2018</CreatedDate>
        <ClosedDate>20/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4780</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Bump orleans package version to 2.1</Title>
    <Description>We recently introduced a breaking change in Core.Abstraction, which means we need to bump every package version to 2.1 as well. More info in #4776 

</Description>
    <CreatedDate>18/07/2018</CreatedDate>
    <ClosedDate>25/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4780</PullRequestID>
        <IssueID>4776</IssueID>
        <Title>Fix partial build</Title>
        <Description>#4739  introduced breaking change in Orleans.Core.Abstraction, Orleans.Core, Orleans.Transaction without set the new package version correctly, which broke partial build. </Description>
        <CreatedDate>17/07/2018</CreatedDate>
        <ClosedDate>17/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4776</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Fix partial build</Title>
    <Description>#4739  introduced breaking change in Orleans.Core.Abstraction, Orleans.Core, Orleans.Transaction without set the new package version correctly, which broke partial build. </Description>
    <CreatedDate>17/07/2018</CreatedDate>
    <ClosedDate>17/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4776</PullRequestID>
        <IssueID>4739</IssueID>
        <Title>Transaction attribution test</Title>
        <Description>Added test cases to ensure transaction attribute options (NotSupported, Required, RequiredNew) properly maintain transaction context.</Description>
        <CreatedDate>03/07/2018</CreatedDate>
        <ClosedDate>11/07/2018</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>testing</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4763</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Added grain storage to benchmarks</Title>
    <Description>Added a grain storage benchmark to help track down #4612.

Unfortunately, not able to repro the issue (yet).
</Description>
    <CreatedDate>11/07/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4763</PullRequestID>
        <IssueID>4612</IssueID>
        <Title>WriteStateAsync() works a lot slower since upgrading to Orleans2</Title>
        <Description>Since upgrading to Orleans2 we have had general slowness in writing grain state. We tried to pin down the issue and we gauged the time it took for us to write jsons of about 1mb each to azure blob storage and the mean went up from about 100ms to 400ms in peak times. 
We looked in the blob storage to see if the data got any larger but it was about the same size (1mb).
We suspected the upgrade to orleans2 to be the cause and when we downgraded back to orleans1 the write time got back to normal (this was the only change we made) so if the cause was something else the downgrade should not have effected this.

This is the graph of the `writeStateAsync()` time from one of our grains "expert-grain":
![screen shot 2018-05-20 at 15 11 21](https://user-images.githubusercontent.com/10612685/40278772-1790bb16-5c40-11e8-902e-57e1159c0be7.png)


We noticed that after restarting the nodes the write time goes down for a few hours before going up again (we used a script to restart the nodes every 4 hours for that reason).

Any suggestions to how we can investigate this further?</Description>
        <CreatedDate>20/05/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4762</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Make azure queue name configurable</Title>
    <Description>-make azure queue name prefix configuration through `AzureQueueOptions`

-if not set, then default to its original value , which is serviceId-providerName

For issue #4577 </Description>
    <CreatedDate>11/07/2018</CreatedDate>
    <ClosedDate>30/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4762</PullRequestID>
        <IssueID>4577</IssueID>
        <Title>Sanitize "." for Azure Queue name and make Queue name configurable</Title>
        <Description>I'm getting exceptions when project name isn't so long or contains "." for example name is "SiloHost.NetCore".

1. Make Azure Queue name configurable or partially configurable. For example for case when silo host is SF service my queue name is "fabric--distrtestapplication-silohost.netcore-azurequeueprovider-0".  It contains 66 symbols instead of max allowed. I want to remove or configure "fabric--" prefix or something else.

2. Sanitize "." with dash "-" as other symbols in AzureQueueDataManager.SanitizeQueueName.</Description>
        <CreatedDate>11/05/2018</CreatedDate>
        <ClosedDate>30/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4761</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Moved request invocation history to core.</Title>
    <Description>Moved request invocation history to orleans core so it's available on the client.
Should address #4706</Description>
    <CreatedDate>11/07/2018</CreatedDate>
    <ClosedDate>18/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4761</PullRequestID>
        <IssueID>4706</IssueID>
        <Title>PerformDeadlockDetection not working in 2.0</Title>
        <Description>Enabling PerformDeadlockDetection on Silo prevents Orleans Client from connecting with following TypeAccessException:

![image](https://user-images.githubusercontent.com/20849443/41804305-78c87750-76d7-11e8-8db0-67ce2cfcde6e.png)

![image](https://user-images.githubusercontent.com/20849443/41804275-e9835cea-76d6-11e8-96c2-4c27d2b5eaf6.png)

Not sure if I'm missing a certain package or if this is an Orleans bug.</Description>
        <CreatedDate>23/06/2018</CreatedDate>
        <ClosedDate>11/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4755</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>DeadlockDetectionWithoutAllowCallChainReentrancyTests</Title>
    <Description>Added deadlock detection testing when allow call chain reenterancy is turned off.


Testing added to help track down PerformDeadlockDetection not working in 2.0 #4706 
</Description>
    <CreatedDate>10/07/2018</CreatedDate>
    <ClosedDate>11/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4755</PullRequestID>
        <IssueID>4706</IssueID>
        <Title>PerformDeadlockDetection not working in 2.0</Title>
        <Description>Enabling PerformDeadlockDetection on Silo prevents Orleans Client from connecting with following TypeAccessException:

![image](https://user-images.githubusercontent.com/20849443/41804305-78c87750-76d7-11e8-8db0-67ce2cfcde6e.png)

![image](https://user-images.githubusercontent.com/20849443/41804275-e9835cea-76d6-11e8-96c2-4c27d2b5eaf6.png)

Not sure if I'm missing a certain package or if this is an Orleans bug.</Description>
        <CreatedDate>23/06/2018</CreatedDate>
        <ClosedDate>11/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4754</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Cherrypick codegen fix for netcoreapp2.1 to 2.0.4 branch (#4673)</Title>
    <Description>xref #4673</Description>
    <CreatedDate>10/07/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4754</PullRequestID>
        <IssueID>4673</IssueID>
        <Title>Fix (or workaround?) for codegen using netcore/netstandard 2.1</Title>
        <Description>Fix for #4585 </Description>
        <CreatedDate>08/06/2018</CreatedDate>
        <ClosedDate>13/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4749</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Cleanup Reminders PartitionKey</Title>
    <Description>Fix #4719 </Description>
    <CreatedDate>06/07/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4749</PullRequestID>
        <IssueID>4719</IssueID>
        <Title>AzureStorage Reminders does not replace invalide path chars in Row and Partition Keys</Title>
        <Description>Hello,

We've experienced an issue recently when our Orleans Cluster has been migrated to Service Fabric.
We are using AzureStorage Table Service for clustering, GrainState persistence and Reminders.

As the sample shows us, we use the ServiceName of the fabric as the ServiceId of the cluster.
(https://github.com/dotnet/orleans/blob/master/Samples/2.0/ServiceFabric/Stateless/StatelessCalculatorService/StatelessCalculatorService.cs )
&gt; // The service id is unique for the entire service over its lifetime. This is used to identify persistent state
&gt; // such as reminders and grain state.
&gt; options.ServiceId = fabricServiceContext.ServiceName.ToString();

This works well for GrainState PartitionKey, since invalid path chars like **/** or **\\** are replaced by underscores:
`fabric:_Silo.ServiceFabric_TheSilo_GrainReference=40080509dab600a3548839c6507585be030000003ab73acd`

But this seems to be not the case for GrainReminders. 
A lot of 400 bad request errors occured because of the PartitionKey name containing invalid path chars. 

&gt; The following characters are not allowed in values for the PartitionKey and RowKey properties:
&gt; 
&gt; The forward slash (/) character
&gt; The backslash (\\) character
&gt; The number sign (#) character
&gt; The question mark (?) character
&gt; Control characters from U+0000 to U+001F, including:
&gt; The horizontal tab (\t) character
&gt; The linefeed (\n) character
&gt; The carriage return (\r) character
&gt; Control characters from U+007F to U+009F

The AzureTableReminderService should use the same sanitization mechanism for PartitionKeys and RowKeys of GrainReminders as GrainState. 

Thank you,</Description>
        <CreatedDate>28/06/2018</CreatedDate>
        <ClosedDate>12/07/2018</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4741</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix package versioning logic</Title>
    <Description>This is very similar to #4740, but based on `master`, with all the changes there.

This should only need skimming compared with the original PR</Description>
    <CreatedDate>05/07/2018</CreatedDate>
    <ClosedDate>14/08/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4741</PullRequestID>
        <IssueID>4740</IssueID>
        <Title>2.0.4 partial build</Title>
        <Description>Please review each commit independently &amp; in order, it will make it much easier.

Here's my reasoning for these changes:

The below snippet is from Orleans.Server’s `Directory.Build.props` from before this PR. Its job is to determine whether or not the Orleans.Server package will reference `Microsoft.Orleans.OrleansProviders` via a `ProjectReference` or a `PackageReference`.

![image](https://user-images.githubusercontent.com/203839/42272738-76bffb94-7fca-11e8-9d2f-127dd71c6e24.png)

In the present case I need to bump `Server` to 2.0.4, since it refs `Runtime` (and we’re trying to publish `Runtime` 2.0.4 to fix this CoreFx bug). Given the above code, that means `Server` will try to pull `Providers` 2.0.4 from NuGet (which doesn't exist yet). So that’s broken (unless I’m doing it wrong?)

Instead, all of these conditional `&lt;PackageReference&gt;` elements should use the *referenced* package's version from the root `Directory.Build.props` file. The dependency relationship implies that if `ServerVersion != ProvidersVersion`, then `ServerVersion &gt; ProvidersVersion` and therefore `ProvidersVersion` must be published to NuGet already. Otherwise, (if they are equal) then we are currently building both packages and we should use a `&lt;ProjectReference&gt;` instead.

I had to split the Azure package group out into individually versioned packages because the published versions for those packages were inconsistent. Eg, 2.0.0 for most vs 2.0.3 for persistence. If preferred, I can undo this change and drag all Azure packages up to 2.0.4 even though only one package (cloud services) actually needs it.

In the case of the telemetry consumers, I pulled that forward to 2.0.4 since 2.0.3 (the currently specified version) is not published and as above, it would break the build now that we're moving on to 2.0.4.

In order to test locally, set the `FullBuild` environment variable to `false` and run `Build.cmd`. The result should be the following packages:
``</Description>
        <CreatedDate>05/07/2018</CreatedDate>
        <ClosedDate>05/07/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4737</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JillHeaden</FixedByID>
    <Title>Updated link to SampleStreamingGrain.cs.</Title>
    <Description>Fixes #4733</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>11/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4737</PullRequestID>
        <IssueID>4733</IssueID>
        <Title>404 for Code Samples link on Orleans Streams page in the documentation</Title>
        <Description>The page at:
[http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html](http://dotnet.github.io/orleans/Documentation/Orleans-Streams/index.html)

Contains a link to a sample at:
[https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs](https://github.com/dotnet/orleans/blob/master/test/TestGrains/SampleStreamingGrain.cs)

Which is a 404. I no longer find such a file in the repo.
</Description>
        <CreatedDate>02/07/2018</CreatedDate>
        <ClosedDate>01/08/2018</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4736</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Workaround for CoreFx/#30781 (Fixes #4505)</Title>
    <Description>Fixes #4505 

This implements a workaround for some divergent behavior between .NET Core and .NET Framework tracked by https://github.com/dotnet/corefx/issues/30781

Note that this is intended for a 2.0.4 release.</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>05/07/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4736</PullRequestID>
        <IssueID>4505</IssueID>
        <Title>Orleans gets slower over time</Title>
        <Description>Hi,

it is a little bit vague, but I have the impression that Orleans gets slower over time.

My specs are:

* .NET Core 2.0
* Running on Kubernetes in GCloud, 2 Nodes/Silos
* Co-Hosted with ASP.NET Core

I have a very simple grain, that just returns the snapshot (my own state system):

https://github.com/Squidex/squidex/blob/master/src/Squidex.Domain.Apps.Entities/Schemas/SchemaGrain.cs#L305

I use my own serializer with JSON.NET and my benchmarks show that the serialization takes 2-3 ms usually. I also tested it with 100x larger states that expected and the performance is great.

I added some profiling to the client side and I have experienced that the call takes 4-5 ms after I deploy it and several days later up to 200ms or even more (the max I have seen is 10seconds).

I also checked my MongoDB logs where I save all slow queries and there is nothing related.

I am a little bit lost.</Description>
        <CreatedDate>24/04/2018</CreatedDate>
        <ClosedDate>02/08/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4727</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Fix azure tests</Title>
    <Description>fix #4720 </Description>
    <CreatedDate>29/06/2018</CreatedDate>
    <ClosedDate>29/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4727</PullRequestID>
        <IssueID>4720</IssueID>
        <Title>Several azure storage tests failing due silo lifecycle</Title>
        <Description>PersistenceProvider_Azure_ChangeReadFormat and 23 others are failing due to:

"System.InvalidOperationException : A suitable constructor for type 'Orleans.Runtime.SiloLifecycleSubject' could not be located. Ensure the type is concrete and services are registered for all parameters of a public constructor."</Description>
        <CreatedDate>28/06/2018</CreatedDate>
        <ClosedDate>29/06/2018</ClosedDate>
        <Labels>
          <Label>test-issue</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4713</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Do not use ip address from interface not operational</Title>
    <Description>Should fix #4524 </Description>
    <CreatedDate>26/06/2018</CreatedDate>
    <ClosedDate>26/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4713</PullRequestID>
        <IssueID>4524</IssueID>
        <Title>Error on type 'MessageCenter'.  The requested address is not valid in its context</Title>
        <Description>After moving to the V2.0 from v2-rc3, several developers get the "The requested address is not valid in its context" error. At several devs all works as expected. We use the ado.net clustering.
From this message is not clear where is a problem

``

</Description>
        <CreatedDate>27/04/2018</CreatedDate>
        <ClosedDate>26/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4689</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Use netcoreapp2.0 for msbuild target dll if using dotnet core msbuild but targeting full .net</Title>
    <Description>#4673 introduced a regression: when using the command `dotnet build` to build project that target the full .NET framework, the variable for `CoreAssembly` is not set, and the variable `TaskAssembly` depends on it.

The easiest workaround here is to always fallback to 2.0 dll

Maybe we could instead removing this task dependency, and rely on the fact that we should find the `dotnet` command in the path @ReubenBond ?</Description>
    <CreatedDate>14/06/2018</CreatedDate>
    <ClosedDate>15/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4689</PullRequestID>
        <IssueID>4673</IssueID>
        <Title>Fix (or workaround?) for codegen using netcore/netstandard 2.1</Title>
        <Description>Fix for #4585 </Description>
        <CreatedDate>08/06/2018</CreatedDate>
        <ClosedDate>13/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4681</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Resubmitting #4667 for an unsquashed merge</Title>
    <Description>#4667 got squash-merged, which is not good for tracking history. I reset the 1.5.4 branch, so that these fixes can be re-merged without getting squashed.</Description>
    <CreatedDate>12/06/2018</CreatedDate>
    <ClosedDate>12/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4681</PullRequestID>
        <IssueID>4667</IssueID>
        <Title>Fixes for v1.5.4</Title>
        <CreatedDate>08/06/2018</CreatedDate>
        <ClosedDate>08/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4674</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Remove dead code that used to track extended statistics</Title>
    <Description>Fixes #4494.</Description>
    <CreatedDate>08/06/2018</CreatedDate>
    <ClosedDate>09/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4674</PullRequestID>
        <IssueID>4494</IssueID>
        <Title>No variable named "trackers"</Title>
        <Description>https://github.com/dotnet/orleans/blob/afcb19571684ea6ab6a34cf85d3c7ee81bd758db/src/Orleans.Runtime/Messaging/IncomingMessageAcceptor.cs#L655</Description>
        <CreatedDate>19/04/2018</CreatedDate>
        <ClosedDate>09/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4673</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Fix (or workaround?) for codegen using netcore/netstandard 2.1</Title>
    <Description>Fix for #4585 </Description>
    <CreatedDate>08/06/2018</CreatedDate>
    <ClosedDate>13/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4673</PullRequestID>
        <IssueID>4585</IssueID>
        <Title>code generation fails with dotnet 2.1 rc1</Title>
        <Description>This is a console app. 

Orleans-CodeGen - Generating file C:\Games\aigame\Game\Server\obj\Debug\netcoreapp2.1\Server.orleans.g.cs
1&gt;-- Code Generation FAILED --
1&gt;
1&gt;Exc level 0: System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. The system cannot find the file specified.
1&gt;   at System.ModuleHandle.ResolveType(RuntimeModule module, Int32 typeToken, IntPtr* typeInstArgs, Int32 typeInstCount, IntPtr* methodInstArgs, Int32 methodInstCount, ObjectHandleOnStack type)
1&gt;   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module, Int32 typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
1&gt;   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
1&gt;   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord, MetadataImport scope, Assembly&amp; lastAptcaOkAssembly, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, Object[] attributes, IList derivedAttributes, RuntimeType&amp; attributeType, IRuntimeMethodInfo&amp; ctor, Boolean&amp; ctorHasParameters, Boolean&amp; isVarArg)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType, Boolean mustBeInheritable, IList derivedAttributes, Boolean isDecoratedTargetSecurityTransparent)
1&gt;   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType)
1&gt;   at System.Attribute.GetCustomAttributes(Assembly element, Type attributeType, Boolean inherit)
1&gt;   at System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](Assembly element)
1&gt;   at Orleans.ApplicationParts.AssemblyAttributeFeatureProvider`1.PopulateFeature(IEnumerable`1 parts, TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\AssemblyAttributeFeatureProvider.cs:line 41
1&gt;   at Orleans.ApplicationParts.ApplicationPartManager.PopulateFeature[TFeature](TFeature feature) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManager.cs:line 49
1&gt;   at Orleans.ApplicationPartManagerExtensions.CreateAndPopulateFeature[TFeature](IApplicationPartManager applicationPartManager) in D:\build\agent\_work\18\s\src\Orleans.Core\ApplicationParts\ApplicationPartManagerExtensions.cs:line 60
1&gt;   at Orleans.CodeGenerator.RoslynCodeGenerator..ctor(IApplicationPartManager partManager, ILoggerFactory loggerFactory) in D:\build\agent\_work\18\s\src\Orleans.CodeGeneration\RoslynCodeGenerator.cs:line 43
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateSourceForAssembly(Assembly grainAssembly, LogLevel logLevel)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCodeInternal(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.CodeGenerator.GenerateCode(CodeGenOptions options)
1&gt;   at Orleans.CodeGeneration.Program.Main(String[] args)
1&gt;C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\Microsoft.Orleans.OrleansCodeGenerator.Build.targets(76,5): error MSB3073: The command ""dotnet" "C:\Users\chris\.nuget\packages\microsoft.orleans.orleanscodegenerator.build\2.0.3\build\..\tasks\netcoreapp2.0\Orleans.CodeGeneration.Build.dll" "@obj\Debug\netcoreapp2.1\codegen\Server.orleans.g.args.txt"" exited with code 3.
1&gt;Done building project "Server.csproj" -- FAILED.</Description>
        <CreatedDate>12/05/2018</CreatedDate>
        <ClosedDate>13/06/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4671</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>JillHeaden</FixedByID>
    <Title>Update NuGets.md</Title>
    <Description>Move Code Generation package to Key Packages area, just below Built-time Code Generation package.
Rename "Additional Packages" section to "Event-Sourcing Package" 
Fixes #4528</Description>
    <CreatedDate>08/06/2018</CreatedDate>
    <ClosedDate>14/06/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4671</PullRequestID>
        <IssueID>4528</IssueID>
        <Title>Orleans 2.0 documentation page inaccuracies</Title>
        <Description>This thread relates to the [Orleans 2.0 documentation page](https://dotnet.github.io/orleans/Documentation/Orleans-2.0.html).

&gt; Explicit programmatic specification of application assemblies that replaces automatic scanning of folders by the Orleans runtime upon silo or client initialization. Orleans will still automatically find relevant types, such as grain interfaces and classes, serializers, etc. in the specified assemblies, but **it will not anymore try to load every assembly it can find in the folder**. An optional helper method for loading all assemblies in the folder is provided for backward compatibility. See Configuration and Migration sections for more details.

I thought that automatic scanning for assemblies was the default behaviour - ref [Application Parts documentation](https://dotnet.github.io/orleans/Documentation/Deployment-and-Operations/Configuration-Guide/Server-Configuration.html#application-parts) and https://github.com/dotnet/orleans/issues/4420#issuecomment-379962127 .

&gt; Overhaul of code generation. **While mostly invisible for developer**, code generation became much more robust in handling serialization of various possible types. Special handling is required for F# assemblies. See Code generation section for more details.

Code generation is not very invisible, given that Orleans won't work without it - ref https://github.com/dotnet/orleans/issues/4417 .</Description>
        <CreatedDate>28/04/2018</CreatedDate>
        <ClosedDate>07/11/2018</ClosedDate>
        <Labels>
          <Label>P1</Label>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4214</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix ADO.NET Reminder configuration &amp; re-enable tests</Title>
    <Description>Fixes #4207 

If this issue affects you, there's a workaround in #4207</Description>
    <CreatedDate>13/03/2018</CreatedDate>
    <ClosedDate>14/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4214</PullRequestID>
        <IssueID>4207</IssueID>
        <Title>[2.0 RC2] Ado.Net reminders provider is broken in RC2</Title>
        <Description>After upgrade to RC2 I have exception when using Ado.Net reminders provider. I configure it as:

``
</Description>
        <CreatedDate>13/03/2018</CreatedDate>
        <ClosedDate>14/03/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4214</PullRequestID>
        <IssueID>4207</IssueID>
        <Title>[2.0 RC2] Ado.Net reminders provider is broken in RC2</Title>
        <Description>After upgrade to RC2 I have exception when using Ado.Net reminders provider. I configure it as:

``
</Description>
        <CreatedDate>13/03/2018</CreatedDate>
        <ClosedDate>14/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4211</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Fix validator ordering</Title>
    <Description>Fix #4203 

The issue is that `SiloClusteringValidator` get `IMembershipOracle` and `IMembershipTable` from DI, and they require themselves a lot of other components in DI...

So if this validator is called before the validators from the options used in these membership constructors, it will fail without a good error message.

I think we should move these "advanced" check in the silo startup to avoid any trouble in the future, but for now it should fix the issue.</Description>
    <CreatedDate>13/03/2018</CreatedDate>
    <ClosedDate>13/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4211</PullRequestID>
        <IssueID>4203</IssueID>
        <Title>NullReferenceException if EndpointOptions.AdvertisedIPAddress is not specified</Title>
        <Description>The following test fails with a `NullReferenceException` when the `AdvertisedIPAddress` line is commented out.

``</Description>
        <CreatedDate>13/03/2018</CreatedDate>
        <ClosedDate>13/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4193</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Add config option to override MessagingOptions.ResponseTimeout when the debugger is attached</Title>
    <Description>Fix for #3830 

Please let me know if what I did is not "option" compatible, but I think this is the cleanest way to implement such flag.</Description>
    <CreatedDate>12/03/2018</CreatedDate>
    <ClosedDate>21/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4193</PullRequestID>
        <IssueID>3830</IssueID>
        <Title>Calling grain method using GrainClient hangs after running for some time</Title>
        <Description>I am using ASP.NET and I have a controller method uses `GrainClient` within   If I run ASP.NET then instantly call this controller, the call to the grain works correctly.  

At some point in the future this stops working, I havent tracked down exactly how long it takes but certainly if I leave it running over night it fails in the morning.

If I step through the code I get a grain reference of  `{GrainReference:*grn/A97D1470/00000000}`. 

If I turn on all exceptions the call to the grain throws this exception

&gt; System.Net.Sockets.SocketException: 'An existing connection was forcibly closed by the remote host'

The NativeErrorCode is `10054`

Oddly enough this exception doesnt seem to bubble up through ASP.NET and make the call fail.</Description>
        <CreatedDate>05/01/2018</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4191</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Fix MemoryStorage - etag mismatch</Title>
    <Description>Fix for #4053 </Description>
    <CreatedDate>12/03/2018</CreatedDate>
    <ClosedDate>12/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4191</PullRequestID>
        <IssueID>4053</IssueID>
        <Title>MemoryStorage - etag mismatch</Title>
        <Description>We have noticed we are getting a lot of etag mismatch issues, and we couldn't figure out why, as during dev they don't usually appear but in prod they do.

Today I had investigated a bit and finally, I found out why its happening. This is how to do it:

- Use a MemoryStorage as persistence for a stateful grain
- Set `State = null`
- `WriteStateAsync`
- Deactivate grain

On next reactivation, if you use `WriteStateAsync` it will throw an etag mismatch exception, even if you explicitly call `ReadStateAsync` and then call `WriteStateAsync` it will still throw an exception, the only way to recover it is to use `ClearStateAsync`

However if you call it when the grain is still activated, it works correctly e.g.
``

Not entirely sure if its a bug or a misuse, i think its a bit of both, but either or ideally it can be prevented because it can lead to some quite hard to track issues.</Description>
        <CreatedDate>17/02/2018</CreatedDate>
        <ClosedDate>12/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4190</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Configure cluster ID in multi-cluster tests</Title>
    <Description>This is a follow-up tp #4160 to fix multi-cluster tests.</Description>
    <CreatedDate>12/03/2018</CreatedDate>
    <ClosedDate>12/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4190</PullRequestID>
        <IssueID>4160</IssueID>
        <Title>Validate that a ClusterId has been specified</Title>
        <CreatedDate>08/03/2018</CreatedDate>
        <ClosedDate>12/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4182</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Treat defaults in options as authoritative</Title>
    <Description>This addresses "Configuration Work - Defaults #3949" 

Where possible, all defaults are defined in options and those defaults are authoritative, even in legacy configurations.

For options defined in runtime, single defaults are not possible, so those will be left as they are.</Description>
    <CreatedDate>09/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4182</PullRequestID>
        <IssueID>3949</IssueID>
        <Title>Configuration Work - Defaults</Title>
        <Description>While moving from monolithic Cluster and Client configurations to options we've duplicated defaults. Many of the options introduced duplicated the defaults in the options, rather than having the options have the authoritative default and referencing these defaults from the legacy configurations.

We need to go through all of the added options and ensure the defaults in the options are correct and authoritative.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>09/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4180</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Set GrainService.Status to Started in the base implementation of StartInBackground()</Title>
    <Description>Fixes #4128.
This should help prevent mistakes of not setting the status to started, which leads to not receiving cluster repartitioning notifications.</Description>
    <CreatedDate>09/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4180</PullRequestID>
        <IssueID>4128</IssueID>
        <Title>How to let timers survive a (graceful) silo shutdown</Title>
        <Description>I have a Game grain, which manages the logic for a turn-based game between two players. Inside this grain, a timer is used to measure the time for each turn and forcefully end a player's turn if they fail to play in a timely manner.

If this grain gets deactivated (even gracefully), the timer will cease to exist. The creation of a new activation of this grain will depend on it receiving external calls, which means it may not happen until one of the players makes a move, which defeats the purpose of the timer. I can save the game's state and let it continue off from where the old silo was shut down, but I currently have no way of bringing the timer back online.

One way is to constantly poll the grain from another grain. This fails because the other grain is also subject to the same limitations as the original (namely, it may get deactivated with no way to restore its timers).

Another way is to have a second grain (let's call it pinger). One could have the game ask the pinger (on deactivation) to call it back after a second or so. This is likely to succeed most of the time, but if the pinger happens to be on the same silo and get deactivated after the game, it will still fail.

Yet another may be to have the game call itself. However, I'm not entirely sure this is a stable solution as I don't know how the silos handle the case of a grain receiving a call while it's already deactivating but not yet fully deactivated. If the grain is removed from the global directory *before* the OnDeactivateAsync call this may succeed. I just thought of this while writing this question, so I have yet to see if this actually works.

A reminder is not appropriate in this scenario because the minimum interval for a reminder is 60 seconds IIRC. An entire turn takes about half a minute.

Any other ideas on how to handle this (and other similar cases)?</Description>
        <CreatedDate>05/03/2018</CreatedDate>
        <ClosedDate>09/03/2018</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4177</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>When the silo shutdown, deactivate grain activations at an earlier stage</Title>
    <Description>Proposed fix for #4174 
</Description>
    <CreatedDate>08/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4177</PullRequestID>
        <IssueID>4174</IssueID>
        <Title>When Silo shutdown, Grain deactivation is happening too late in the lifecycle</Title>
        <Description>Silo will accept new activation in the `Active` state, but will deactivate its grain activation only at stage `RuntimeServices` which is happening after the `ApplicationServices` state.

It will cause issue if the grain implementation rely on a component that is dependant on the `ApplicationServices` state (like storage providers...)</Description>
        <CreatedDate>08/03/2018</CreatedDate>
        <ClosedDate>09/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4175</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Improved transparency and timing of silo lifecycle (second attempt).</Title>
    <Description>Reapplying "Improved transparency and timing of silo lifecycle. #4116" with fixes to test failures which caused the original PR to be reverted.

Marked wip until it passes full VSO tests.

---

Subscrivers are now named.
Silo lifecycle now reports stages prior to start.

_**Example stage reporting:**_
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage -2147483648: Orleans.Runtime.SiloOptionsLogger
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage 2000: Orleans.Runtime.InsideRuntimeClient, Orleans.Runtime.Silo
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage 4000: Orleans.Runtime.Silo
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage 8000: Orleans.Runtime.Silo
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage 10000: Orleans.Runtime.Versions.GrainVersionStore, Orleans.Storage.AzureTableGrainStorage-AzureStore, Orleans.Storage.AzureTableGrainStorage-PubSubStore, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2
...100453 Orleans.Runtime.SiloLifecycleSubject] Stage 20000: Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2

_**Example timing information:**_
...100452 Orleans.Runtime.SiloLifecycleSubject] Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 10000 which took 21 Milliseconds.
...100452 Orleans.Runtime.SiloLifecycleSubject] Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 20000 which took 65 Milliseconds.
...100452 Orleans.Runtime.SiloLifecycleSubject] Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 20000 which took 20 Milliseconds.
...100452 Orleans.Runtime.SiloLifecycleSubject] Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 10000 which took 0 Milliseconds.

Stream provider started in two stages because it initializes in stage 10000, and starts reading events running in stage 20000.</Description>
    <CreatedDate>08/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4175</PullRequestID>
        <IssueID>4116</IssueID>
        <Title>Improved transparancy and timing of silo lifecycle.</Title>
        <Description>- Subscrivers are now named.
- Silo lifecycle now reports stages prior to start.

**_Example stage reporting:_**

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage -2147483648: Orleans.Runtime.SiloOptionsLogger	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 2000: Orleans.Runtime.InsideRuntimeClient, Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 4000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 8000: Orleans.Runtime.Silo	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 10000: Orleans.Runtime.Versions.GrainVersionStore, Orleans.Storage.AzureTableGrainStorage-AzureStore, Orleans.Storage.AzureTableGrainStorage-PubSubStore, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

...100453	Orleans.Runtime.SiloLifecycleSubject]	Stage 20000: Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider, Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2	

**_Example timing information:_**

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 10000 which took 21 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 started in stage 20000 which took 65 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 20000 which took 20 Milliseconds.	

...100452	Orleans.Runtime.SiloLifecycleSubject]	Lifecycle observer Orleans.Providers.Streams.Common.PersistentStreamProvider-AzureQueueProvider2 stopped in stage 10000 which took 0 Milliseconds.

Stream provider started in two stages because it initializes in stage 10000, and starts reading events running in stage 20000.</Description>
        <CreatedDate>03/03/2018</CreatedDate>
        <ClosedDate>08/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4171</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Do not call ResolveIPAddress in EndpointOptions constructor</Title>
    <Description>Related issue #4158 

* Removed call to `ConfigUtilities.ResolveIPAddress` in `EndpointOptions` constructor
* `ConfigUtilities.ResolveIPAddress` no longer use DNS if no hostname provided</Description>
    <CreatedDate>08/03/2018</CreatedDate>
    <ClosedDate>09/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4171</PullRequestID>
        <IssueID>4158</IssueID>
        <Title>Dns.GetHostAddressesAsync failure preventing Silo start</Title>
        <Description>I'm getting the following stack trace when attempting to start a silo. I believe the cause is the default value for `AdvertisedIPAddress` in `EndpointOptions`. I'm trying to run the silo (rc1)  in an AWS Fargate (managed container service) task. I can try to troubleshoot the underlying error more, but I'm pretty sure I'll need to set the `AdvertisedIPAddress` manually anyways, so having the default specified in a different manner (as suggested in https://github.com/dotnet/orleans/issues/4115) may make more sense.

``</Description>
        <CreatedDate>07/03/2018</CreatedDate>
        <ClosedDate>09/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4164</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Persistent stream configurators</Title>
    <Description>Attempt to solve issue #4080 

Major interface and configurator class and its inheritance hierarchy
Silo side: 
```
//main interface and implementation
interface ISiloPersistentStreamConfigurator
interface IRecoverableStreamConfigurator:  ISiloPersistentStreamConfigurator
class SiloPersistentStreamConfigurator : ISiloPersistentStreamConfigurator
class SiloRecoverableStreamConfigurator : SiloPersistentStreamConfigurator 

//specific stream configurator
class SiloAzureQueueStreamConfigurator : SiloPersistentStreamConfigurator
class SiloEventHubStreamConfigurator : SiloRecoverableStreamConfigurator
..and other stream providers are similar 
```
Client side:
```
//main interface and implementation
interface IClusterClientPersistentStreamConfigurator
class ClusterClientPersistentStreamConfigurator : IClusterClientPersistentStreamConfigurator

//specific stream configurator
class ClusterClientAzureQueueStreamConfigurator : ClusterClientPersistentStreamConfigurator
class ClusetrClientEventHubStreamConfigurator : ClusterClientPersistentStreamConfigurator

..and other stream providers are similar 
```
The main idea is to use configurator/builder pattern to achieve a cleaner configuring pattern. Stream providers are complex which has many components, this PR try to use configurator/builder pattern to make configuring more modular, aka per component configuring. 

Stream providers are complex , where named service and named options can be utilized to make stream provider cleaner. But Rome isn't built in one day, we cannot make stream provider great in one day. So the strategy I propose here is to hide stream provider configuration under a builder pattern. So from the public surface, stream provider is already very modular. Under the public surface, we can make stream providers more modular without introducing much breaking changes. 

Sample call pattern:
```
  hostBuilder
  .AddAzureQueueStreams&lt;AzureQueueDataAdapterV2&gt;(StreamProviderName)
   .ConfigureAzureQueue(ob =&gt; ob.Configure(
                            options =&gt;
                            {
                                options.ConnectionString = TestDefaultConfiguration.DataConnectionString;
                            }));
```


TODOs:
- check ConfigureNamedOptionForLogging called for each options correctly or not.
- should we configure default queue balancer?
- configure configurationValidators for options which needs it but haven't , such as sqsOptions and pubsubOptions</Description>
    <CreatedDate>08/03/2018</CreatedDate>
    <ClosedDate>10/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4164</PullRequestID>
        <IssueID>4080</IssueID>
        <Title>Improve persistent stream provider configuration pattern </Title>
        <Description>Persistent stream providers are very complex, it has many components which user can customize. Now the configuration of those components has scattered in three places, one is through inheritance, another one is through giant god  stream provider options which is intended to configure everything, third one is through the component's own option. All three of them has pain points, listed below. 

- Use inheritance,  instead of DI to configure some core component, such as `CheckpointerFactory`, `QueueMapperFactory`, `StreamFailureHandlerFactory` setters on `TAdapterFactory`. This make configuring harder, since if user want to configure those, they need to actually have a reasonable understanding of how Orleans streaming is wired up internally, to know which class to inherit and when to set those factories. Although this is true before, so one may argue it might be fine now. But the fact is, after provider been integrated with lifecycle, its configuration process has been changed entirely. For users who configured those factory through inheritance, they cannot use our extension methods to configure their custom stream provider, and the configuration their are familiar with is gone, and they need to get used to a new one which is almost as bad as before. So I think we should kill this pain point because we provided a new configuration method, it will suck if it is as bad as before. 

- The disadvantage of god stream provider options is its poor flexibility, extensibility and complexity. I will skipped listing its cons here since I think there's a consensus on Why god configuration is bad. 

- Configure one component through its own option is the way to go forward. The problem with it right now is poor discoverability, especially when the configuration is in three places. For example, to configure a queue balancer now, you need to first set the queue balancer type right in the stream provider options, then you need to configure the specific type of queue balancer options through DI, which there's no extra infrastructure to guide you on how to do that. 

I would argue some of those need to be improved in 2.0 scope, because we create a fuss to provide a new way of configuration, it will be bad if this new configuration method is as bad as before, and user need to learn about this new bad way and adapt to it, instead of happily adapt a better way. 

General direction is to uniform these three ways of configuration and develop one consistent and better way to configure stream providers, which also has good discoverability, extensibility and flexibility.  
</Description>
        <CreatedDate>26/02/2018</CreatedDate>
        <ClosedDate>10/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4148</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Fix for PerfCounterEnvironmentStatistics never reports CpuUsage</Title>
    <Description>Fix for #4129 </Description>
    <CreatedDate>07/03/2018</CreatedDate>
    <ClosedDate>07/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4148</PullRequestID>
        <IssueID>4129</IssueID>
        <Title>Bug: PerfCounterEnvironmentStatistics never reports CpuUsage</Title>
        <Description>I think the registration is wrong, because OnStart is never called. 

cpuCounterPF != null, but cpuUsageTimer == null</Description>
        <CreatedDate>05/03/2018</CreatedDate>
        <ClosedDate>21/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4147</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Use List instead of IList in StaticGatewayListProviderOptions</Title>
    <Description>Fixes #4123</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>07/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4147</PullRequestID>
        <IssueID>4123</IssueID>
        <Title>Change the type of the Gateways property in StaticGatewayListProviderOptions in rc1</Title>
        <Description>The type of Gateways in StaticGatewayListProviderOptions is IList&lt;Uri&gt;.
The absence of the AddRange method in IList makes adding multiple gateway endpoints in ClientBuilder unnecessarily cumbersome.

Changing it to a List resolves this issue.

</Description>
        <CreatedDate>04/03/2018</CreatedDate>
        <ClosedDate>07/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4140</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>ADO.NET: Fix formatting of generic class names in storage provider</Title>
    <Description>Fixes #3418

The ADO.NET storage provider was unable to correctly handle nested generic types.

This PR adds support for nested generics.

An ad-hoc test to compare the modified method with the existing method indicates that the modified method is backwards-compatible for simple generics. The string I tested was:
`UnitTests.Grains.GrainStorageGenericGrain`1[System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]`

I'd prefer if we didn't have to go down this route of converting a Type into a string and then parsing it and reformatting it into a slightly prettier string.

Note that both the existing method and the modified method are unable to correctly distinguish arrays. I don't think we should add array support in this PR - it means fundamentally changing how the parsing works (no more `string.Split`).</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4140</PullRequestID>
        <IssueID>3418</IssueID>
        <Title>Using grain type with nested template arguments crashes the AdoNetStorageProvider</Title>
        <Description>Using a grain interface with nested template arguments crashes the AdoNetStorageProvider. I think the logic inside the `ExtractBaseClass` method assumes only one level of template arguments is present.

This works as expected: `ITemplatedGrain&lt;SomeClass&gt;`

This crashes with the error below: `ITemplatedGrain&lt;OtherTemplatedClass&lt;SomeClass&gt;&gt;`

``</Description>
        <CreatedDate>19/09/2017</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4139</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add test for injecting generic services into grains</Title>
    <Description>Just to ensure we have coverage. This is related to #4012 (but doesn't fix that issue)</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4139</PullRequestID>
        <IssueID>4012</IssueID>
        <Title>Not support generic type on Grain. </Title>
        <Description>Hi there, is there any way to support generic type on an Grain? e.g.
``


here is my test repo
https://github.com/darting/orleans-fsharp/blob/master/src/Client/Program.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Grains/Library.fs#L19
https://github.com/darting/orleans-fsharp/blob/master/src/Host/Program.fs#L12

Thanks</Description>
        <CreatedDate>11/02/2018</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4138</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove legacy configuration requirement from Service Fabric hosting</Title>
    <Description>Fixes #4109

The method for configuring endpoint options changes from
```C# 
clusterConfig.Defaults.ConfigureServiceFabricSiloEndpoints(this.serviceContext);
builder.UseConfiguration(clusterConfig);
```
to 
```C#
builder.Configure&lt;EndpointOptions&gt;(options =&gt;
  options.ConfigureFromServiceContext(serviceContext));
```</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4138</PullRequestID>
        <IssueID>4109</IssueID>
        <Title>2.0 rc1 ServiceFabric clustering is dependent on Legacy Configuration</Title>
        <Description>The service fabric clustering components are still dependent on the Legacy GlobalConfiguration object (and legacy nuget package).  

Is ServiceFabric clustering considered to be legacy as well? Since I saw some threads indicating to use another membership provider (like azure table) in SF.

</Description>
        <CreatedDate>02/03/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4136</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Normalize cluster config &amp; simplify binding IConfiguration to TOptions</Title>
    <Description>Fixes #4086.

Unsure if we should also add some sugar methods like `ConfigureClusterId(string)` and `ConfigureSiloName(string)`. `ClusterId` is much more important than `SiloName`.

We could also consider setting `ClusterId` to `"default"` if it's not otherwise set.</Description>
    <CreatedDate>06/03/2018</CreatedDate>
    <ClosedDate>08/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4136</PullRequestID>
        <IssueID>4086</IssueID>
        <Title>SiloBuilder extensions/options usability issues</Title>
        <Description>Let's track here all change that we should do in SiloBuilder extensions methods and options before release.

- [x] `UseDevelopmentClustering` is not very user friendly; user should be able to just call `siloBuilder.UseDevelopmentClustering()`, not `siloBuilder.UseDevelopmentClustering(options =&gt; ....)`
- [x] `ConfigureEndpoints` extensions are in namespace `Orleans.Configuration` instead of `Orleans.Hosting`
- [ ] The method to configure the cluster on the client is called `ConfigureCluster` but is called `Configure` on the silo</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>08/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4133</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Support treating all descendants of a base class as [Serializable]</Title>
    <Description>Resolves #3910

Adding `[KnownBaseType]` to a base class will cause the code generator to consider that class and all subclasses as `[Serializable]`.

Note: only base *classes* are supported, not interfaces. Supporting interfaces is a simple addition which we can add later but it might add a perf hit during build (branch-out search is more costly). We generally prefer "pay for what you use" but this could have an impact on all users.
</Description>
    <CreatedDate>05/03/2018</CreatedDate>
    <ClosedDate>07/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4133</PullRequestID>
        <IssueID>3910</IssueID>
        <Title>[Proposal] New codegen hint</Title>
        <Description>The functional way (style) for doing communication is via messages, which in C# are usually implemented by classes. Currently, Orleans codegen can only generate serializers for class if it's marked with `Serializable` attribute, which means that each and every message class need to be marked with it. That creates a lot of unnecessary noise and make definitions more verbose.

It would be great to have new hint for codegen (ie done via config) to generate serializers for all types which could be assigned from specified type. For example, Orleankka provides 2 base interfaces `Message` and `Result` (for requests and responses respectively) which are used for strongly typed actors (`ActorMessage&lt;TActor&gt;``, ActorMessage&lt;TActor, TResult&gt;`). Having this ability will save 1 line of code per each message definition and will make them more compact. </Description>
        <CreatedDate>25/01/2018</CreatedDate>
        <ClosedDate>07/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4108</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>galvesribeiro</FixedByID>
    <Title>Moved IStartupTask to Runtime.Abstractions package. </Title>
    <Description>This PR address #4106.

That allow extension developers to not depends on whole runtime but on the abstractions instead when using `IStartupTask` and its extension methods.</Description>
    <CreatedDate>02/03/2018</CreatedDate>
    <ClosedDate>02/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4108</PullRequestID>
        <IssueID>4106</IssueID>
        <Title>Move IStartupTask to Runtime Abstractions package</Title>
        <Description>As any other abstractions used by the Silo, I think `IStartupTask` and its extensions to register it should be moved to `Microsoft.Orleans.Runtime.Abstractions`. 

Is there any particular reason for that still on the Runtime package?
</Description>
        <CreatedDate>02/03/2018</CreatedDate>
        <ClosedDate>02/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4103</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Consolidate legacy configuration methods</Title>
    <Description>This removes some duplication in the legacy configuration methods.

By making legacy configuration use `ISiloHostBuilder`, there is less dependence on using `IServiceCollection` methods for provider configuration, as well as less duplication.

This will conflict with #4097, so I'll need to rebase whichever comes second.</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4103</PullRequestID>
        <IssueID>4097</IssueID>
        <Title>Improve configuration validators for ADO.NET configuration</Title>
        <Description>* Consolidate naming of ADO.NET invariant option: now it's `Invariant` in all places, instead of being `AdoInvariant` in clustering and `Invariant` everywhere else.
* Add configuration validators for clustering and reminders and improve grain storage validator to check that `Invariant` is set.
* Propagate invariant value from legacy configuration to reminder configuration.
* Add `invariant` parameter on reminder config extension method which takes a connection string.</Description>
        <CreatedDate>28/02/2018</CreatedDate>
        <ClosedDate>05/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4102</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve usability of custom grain placement configuration</Title>
    <Description>Fixes #4098

</Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>06/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4102</PullRequestID>
        <IssueID>4098</IssueID>
        <Title>Custom placement strategy usability improvements</Title>
        <Description>In 2.0.0-rc1, custom placement strategy registration isn't as obvious as it should be:
``

The director registration should be obvious and discoverable. The strategy registration should not be needed.

cc @yzhao174</Description>
        <CreatedDate>28/02/2018</CreatedDate>
        <ClosedDate>06/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4100</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Move old samples to 1.x folder</Title>
    <Description>I didn't touched to HelloWorld.NetCore to avoid merge conflicts with #4088 </Description>
    <CreatedDate>01/03/2018</CreatedDate>
    <ClosedDate>01/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4100</PullRequestID>
        <IssueID>4088</IssueID>
        <Title>Update HelloWorld.NetCore sample to use 2.0 rc1</Title>
        <Description>Update HelloWorld.NetCore sample to use 2.0 rc0 as a preparation step to update the doc. Since docs use this sample as main example. </Description>
        <CreatedDate>28/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4092</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Make equality requirements of IApplicationPart explicit.</Title>
    <Description>In the discussion on #4084, we decided to make `IApplicationPart` explicitly implement `IEquatable&lt;IApplicationPart&gt;`</Description>
    <CreatedDate>28/02/2018</CreatedDate>
    <ClosedDate>28/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4092</PullRequestID>
        <IssueID>4084</IssueID>
        <Title>Failure loading MemoryStorageGrain</Title>
        <Description>On latest RC, calling `.AddMemoryGrainStorageAsDefault()` fail to register the provider if we are adding any type to application parts manager (i.e. the auto-discovery is disable since I'm adding assemblies manually).

This method is supposed to add the `IMemoryStorageGrain` to the App parts internally.

Logs attached.

Thanks
[logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f (1).txt](https://github.com/dotnet/orleans/files/1764074/logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f.1.txt)
</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4091</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Extensions should add their own application parts</Title>
    <Description>Hopefully I didn't miss any

This addresses #4084</Description>
    <CreatedDate>28/02/2018</CreatedDate>
    <ClosedDate>02/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4091</PullRequestID>
        <IssueID>4084</IssueID>
        <Title>Failure loading MemoryStorageGrain</Title>
        <Description>On latest RC, calling `.AddMemoryGrainStorageAsDefault()` fail to register the provider if we are adding any type to application parts manager (i.e. the auto-discovery is disable since I'm adding assemblies manually).

This method is supposed to add the `IMemoryStorageGrain` to the App parts internally.

Logs attached.

Thanks
[logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f (1).txt](https://github.com/dotnet/orleans/files/1764074/logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f.1.txt)
</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4090</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve usability of dev cluster</Title>
    <Description>Fixes most of #4086
Fixes #4084</Description>
    <CreatedDate>28/02/2018</CreatedDate>
    <ClosedDate>01/03/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4090</PullRequestID>
        <IssueID>4086</IssueID>
        <Title>SiloBuilder extensions/options usability issues</Title>
        <Description>Let's track here all change that we should do in SiloBuilder extensions methods and options before release.

- [x] `UseDevelopmentClustering` is not very user friendly; user should be able to just call `siloBuilder.UseDevelopmentClustering()`, not `siloBuilder.UseDevelopmentClustering(options =&gt; ....)`
- [x] `ConfigureEndpoints` extensions are in namespace `Orleans.Configuration` instead of `Orleans.Hosting`
- [ ] The method to configure the cluster on the client is called `ConfigureCluster` but is called `Configure` on the silo</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>08/03/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4090</PullRequestID>
        <IssueID>4084</IssueID>
        <Title>Failure loading MemoryStorageGrain</Title>
        <Description>On latest RC, calling `.AddMemoryGrainStorageAsDefault()` fail to register the provider if we are adding any type to application parts manager (i.e. the auto-discovery is disable since I'm adding assemblies manually).

This method is supposed to add the `IMemoryStorageGrain` to the App parts internally.

Logs attached.

Thanks
[logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f (1).txt](https://github.com/dotnet/orleans/files/1764074/logs-from-kubesilo-in-kubesilo-57bf49b4b7-zzs9f.1.txt)
</Description>
        <CreatedDate>27/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4081</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Move legacy configuration methods to Orleans.TestingHost.Legacy</Title>
    <Description>- Remove Orleans.TestingHost dependency on legacy packges
- add Orleans.TestingHost.Legacy to configure TestingHost using legacy configuration objects 

Fix issue #3951 
</Description>
    <CreatedDate>27/02/2018</CreatedDate>
    <ClosedDate>28/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4081</PullRequestID>
        <IssueID>3951</IssueID>
        <Title>Configuration Work - TestingHost</Title>
        <Description>Remove use of legacy configuration from Orleans.TestingHost, introducing a Orleans.TestingHost.Legacy if necessary.</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>05/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4077</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Start GrainVersionStore later at runtime</Title>
    <Description>Related issue: #4075 </Description>
    <CreatedDate>26/02/2018</CreatedDate>
    <ClosedDate>28/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4077</PullRequestID>
        <IssueID>4075</IssueID>
        <Title>IVersionStore should not be used before the silo is ready</Title>
        <Description>Right now it is used in `ServiceLifecycleStage.RuntimeGrainServices`, and sometimes when the first silo starts you can get these errors in the logs:

&gt; [2018-02-23 01:23:05.417 GMT 45	Error	102202	Orleans.Storage.AzureTableGrainStorage]	!!!!!!!!!! Error from storage provider AzureTableGrainStorage.Orleans.Runtime.Versions.VersionStoreGrain during ReadState for grain Type=Orleans.Runtime.Versions.VersionStoreGrain Pk=*grn/13BAB4D8/000000000000000000000000000000000600000013bab4d8+loadtests636549168964888958-0xD87DF39E Id=GrainReference:*grn/13BAB4D8/00000000+loadtests636549168964888958 Error=

I think we should move its initialization in  `ServiceLifecycleStage.ApplicationServices`</Description>
        <CreatedDate>23/02/2018</CreatedDate>
        <ClosedDate>01/03/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4048</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Fix bad merge</Title>
    <Description>fix bad merge between #4045 and #4022 
#4045 removed SiloLifeCycle while #4022 is using it. #4022 got merged first. But #4045 didn't get merge conflicts maybe because they are not touching the same file. 

But anyway master doesn't build now. This PR shall fix it </Description>
    <CreatedDate>15/02/2018</CreatedDate>
    <ClosedDate>15/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4045</IssueID>
        <Title>Aligned silo and client lifecycle stages.</Title>
        <CreatedDate>15/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4022</IssueID>
        <Title>Migrate AdoNetGrainStorage to use options and lifecycle</Title>
        <Description>- Migrate AdoNetGrainStorageto use options and lifecycle
- Add GrainPersistenceTestRunner 
- Add persistence tests to AdoNetGrainStorage</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4045</IssueID>
        <Title>Aligned silo and client lifecycle stages.</Title>
        <CreatedDate>15/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4022</IssueID>
        <Title>Migrate AdoNetGrainStorage to use options and lifecycle</Title>
        <Description>- Migrate AdoNetGrainStorageto use options and lifecycle
- Add GrainPersistenceTestRunner 
- Add persistence tests to AdoNetGrainStorage</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4022</IssueID>
        <Title>Migrate AdoNetGrainStorage to use options and lifecycle</Title>
        <Description>- Migrate AdoNetGrainStorageto use options and lifecycle
- Add GrainPersistenceTestRunner 
- Add persistence tests to AdoNetGrainStorage</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4048</PullRequestID>
        <IssueID>4045</IssueID>
        <Title>Aligned silo and client lifecycle stages.</Title>
        <CreatedDate>15/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4040</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Migrate to use string template, instead of String.Format</Title>
    <Description>Migrate part of our logging message to use string template, instead of String.Format 
Reasons:
- String.Format is error prone. You may miss one arg or give extra arg. While string template doesn't have that problem
- Easy to use the logger extension method in a wrong way. See #4015 for more info. 
</Description>
    <CreatedDate>14/02/2018</CreatedDate>
    <ClosedDate>15/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4040</PullRequestID>
        <IssueID>4015</IssueID>
        <Title>Logger is not used currently in Orleans.Runtime.Dispatcher</Title>
        <Description>There is a bug in the usage of the logger in Orleans.Runtime.Dispatcher and possibly in other places.
For example, the LoggerExtensions.Info method signature is:
`internal static void Info(this Logger logger, ErrorCode errorCode, string format, params object[] args)`
But it is used as follows
`logger.Info(ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation, String.Format("Intermediate NonExistentActivation for message {0}", message), ex);`
So the params are as follows:
ErrorCode errorCode =  ErrorCode.Dispatcher_Intermediate_GetOrCreateActivation
string format = String.Format("Intermediate NonExistentActivation for message {0}", message)
params object[] args = ex

This means that we try to call string.Format on the result of this string format and the exception as args.
In most cases this is not a major problem as it just means that the exception is never logged.
It is a big issue if the grain key contains curly braces(maybe not the best idea, but it's the current implementation), the call fails over System.FormatException.
This is the call stack:

`System.FormatException: Input string was not in a correct format.    at System.Text.StringBuilder.AppendFormat(IFormatProvider provider, String format, Object[] args)    at System.String.Format(IFormatProvider provider, String format, Object[] args)    at Orleans.Runtime.LoggerImpl.WriteLogMessage(Int32 errorCode, Severity sev, String format, Object[] args, Exception exception)    at Orleans.Runtime.LoggerExtensions.Info(Logger logger, ErrorCode errorCode, String format, Object[] args)    at Orleans.Runtime.Dispatcher.ReceiveMessage(Message message)`




</Description>
        <CreatedDate>12/02/2018</CreatedDate>
        <ClosedDate>20/02/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4036</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Remove FastKillOnCancel setting, add ProcessExitHandlingOptions</Title>
    <Description>- Remove FastKillOnCancelKeyPress setting from SiloOptions and also legacy configuration, per #3957 
- Add ProcessExitHandlingOptions to configure whether to fast kill on process exit. per #4016 </Description>
    <CreatedDate>14/02/2018</CreatedDate>
    <ClosedDate>14/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4036</PullRequestID>
        <IssueID>3957</IssueID>
        <Title>Configuration Work - unwanted or improperly organized settings</Title>
        <Description>While moving from monolithic Cluster and Client configurations to options, settings surfaced which should probably not be part of Orleans core or may not be categorized correctly.

Below is a list of some such settings, and I encourage others to contribute to this list if the current options seem ill conceived or unnecessary.

AdoNetOptions - should not be in Orleans core.
ServicePointOptions - should not be in Orleans core.
Load shedding settings - Probably should not be part of statistics. (EDIT: moved to its own options)
FastKillOnCancelKeyPress - probably should not be in Orleans core.

Figure out what to do about these.

[Edit]
Thread pool options - don't think thread pool settup should be part of orleans core.
</Description>
        <CreatedDate>02/02/2018</CreatedDate>
        <ClosedDate>15/02/2018</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4036</PullRequestID>
        <IssueID>4016</IssueID>
        <Title>Add a config option to not intercept AppDomain.CurrentDomain.ProcessExit in Silo</Title>
        <Description>Dev that want to intercept `AppDomain.CurrentDomain.ProcessExit` to control silo shutdown currently cannot to it reliably since in `Silo` we always listen to this event and do a "FastKill".

We should add an option to disable this behavior, but let it by default
</Description>
        <CreatedDate>12/02/2018</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>4035</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Merge ServicePointOptions and ThreadPoolOptions to PerformanceTuning</Title>
    <Description>Merge ServicePointOptions and ThreadPoolOptions to PerformanceTuningOptions
 Fix #4034 </Description>
    <CreatedDate>14/02/2018</CreatedDate>
    <ClosedDate>14/02/2018</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>4035</PullRequestID>
        <IssueID>4034</IssueID>
        <Title>PerformanceTuningOptions</Title>
        <Description>Merge ServicePointOptions and ThreadPoolOptions into one option `PerformanceTuningOptions` and keep it in core. Reasons as follows,

They exists for configuring environment to be optimal for orleans cluster performance. Yes none of the target they configure is maintained by orleans, but we think configure them to be at optimal  values is orleans’s responsibility, because they are essential for orleans performance. If we don’t configure them, the default settings for ThreadPool or ServicePointManager greatly affects performance, especially ThreadPool settings. If we ask our user to configure them, then we run risks of low discoverability of the need to configure them and mysterious performance drop after adopting 2.0. 

Default MinThreads for ThreadPool is small, while Orleans needs hundreds of threads to have optimal performance. 
And also, ServicePointOptions are not just for optimization when using AzureStorage. The settings there are for optimizing ServicePointManager to handle small requests, to our understanding. See blog post https://blogs.msdn.microsoft.com/windowsazurestorage/2010/06/25/nagles-algorithm-is-not-friendly-towards-small-requests/ for more info. 

So based on above reasons. We merge those two options into one, with default values. 
</Description>
        <CreatedDate>13/02/2018</CreatedDate>
        <ClosedDate>14/02/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3178</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Service Fabric: make cluster change notifications determinsitic</Title>
    <Description>There is some flakiness in the `HandlesSiloAdditionAndRemoval` test which was caused by non-deterministic execution order of the notifications since we started scheduling those on the task scheduler (see #3059). 

Tests use the default task scheduler (multi-threaded, no strict ordering), real deployments use single-threaded task scheduler. So this PR tightens up the ordering of notifications and fixes a few other issues:
* Starts an async worker using the captured task scheduler to process all notifications. The worker awaits an `AutoResetEvent` and pulls notifications from a queue and delivers them in order.
* `KillMyself` is always called to destroy the oracle, and it's always called last, so finalization logic has been moved from `Stop` and `Shutdown`.
* #3061 introduced an issue whereby subscribers would be re-notified of dead silos, this fixes that issue by ensuring that notifications for dead silos are only sent when the silo transitions from active to dead.

This code would be simplified by using an `ActionBlock&lt;StatusChangeNotification&gt;` from Dataflow, but I am averse to pulling that into this code. If we feel it's fine to add that dependency, then I can go ahead and use it.</Description>
    <CreatedDate>27/06/2017</CreatedDate>
    <ClosedDate>28/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3178</PullRequestID>
        <IssueID>3059</IssueID>
        <Title>Service Fabric: execute cluster update notifications on an Orleans thread</Title>
        <Description>Fix for #3057, in which @rikbosch is experiencing threading issues caused by the `FabricMembershipOracle` not executing cluster status notifications on an Orleans thread.

Proposed solution is to capture the `OrleansTaskScheduler` in the `IMembershipOracle.Start` call and later use it to schedule notifications.</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>07/06/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3178</PullRequestID>
        <IssueID>3061</IssueID>
        <Title>Service Fabric: Mark removed silos as Dead indefinitely</Title>
        <Description>Instead of setting a no-longer-present silo's status to `SiloStatus.None`, leave a tombstone declaring it `Dead`.

Related to #3056</Description>
        <CreatedDate>27/05/2017</CreatedDate>
        <ClosedDate>07/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3175</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>raol</FixedByID>
    <Title>Avoid default port for localhost silo to conflict with Ants Profiler</Title>
    <Description>If I understand the problem correctly, all that needs to be done is
changing the siloPort from 22222 to any other. Decided to use 33333.
Fixes #1663 </Description>
    <CreatedDate>26/06/2017</CreatedDate>
    <ClosedDate>30/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3175</PullRequestID>
        <IssueID>1663</IssueID>
        <Title>Default port 22222 conflicts with RedGate Ants Profiler Service</Title>
        <Description>Given the error for port conflict is the totally unintuitive "An attempt was made to access a socket in a way forbidden by its access permissions" and that it is likely that other developers will use Orleans and have RedGate's Ants Profiler installed, should the default ports in the project templates be changed to avoid conflict?

I should also add that I spent several hours figuring why TestingSiloHost was ignoring port for primary silo specified in xml file and using hardcoded port 22222 until I finally found that I had to explicitly pass a TestingSiloOptions to constructor overriding BasePort. It would be nice if other devs didn't have to go through that. I'm thinking that [unit testing documentation page](http://dotnet.github.io/orleans/Step-by-step-Tutorials/Unit-Testing-Grains) should explicitly say that xml configuration is ignored.
</Description>
        <CreatedDate>07/04/2016</CreatedDate>
        <ClosedDate>01/07/2017</ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>bug</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3160</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>rikbosch</FixedByID>
    <Title>Add ISiloStatusOracle registration to servicecollection</Title>
    <Description>This PR fixes #3159 

It explicitly adds implementation for ISiloStatusOracle, based on already registered IMembershipOracle.</Description>
    <CreatedDate>23/06/2017</CreatedDate>
    <ClosedDate>25/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3160</PullRequestID>
        <IssueID>3159</IssueID>
        <Title>ISiloStatusOracle is not registered in ServiceFabric Utils</Title>
        <Description>ref https://github.com/OrleansContrib/OrleansDashboard/issues/47

SF utils uses a custom IMembershipOracle, but does not register the implementation as ISiloStatusOracle.

This causes problems in the ManagementGrain when using OrleansDashboard</Description>
        <CreatedDate>23/06/2017</CreatedDate>
        <ClosedDate>25/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3139</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove IGrainInvokeInterceptor obsoletion warning in test</Title>
    <Description>Apparently, I missed this one in #3083 and introduced a build warning</Description>
    <CreatedDate>16/06/2017</CreatedDate>
    <ClosedDate>16/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3139</PullRequestID>
        <IssueID>3083</IssueID>
        <Title>Support multiple request interceptors</Title>
        <Description>Implements #2000 and marks the existing interface methods as obsolete.

Interceptors are configured by registering `InvokeInterceptor` instances with the DI container in the `ConfigureServices` startup method, like so:
``

The interceptor set via `IProviderRuntime.SetInvokeInterceptor(...)` is executed last.

Future work: add an extension method to the future SiloBuilder to make configuration more discoverable/obvious.</Description>
        <CreatedDate>02/06/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3130</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Replace DuplicateActivationException with a strongly-typed return value</Title>
    <Description>This PR resolves #2733.

The fix focuses on the logic in `Catalog.InitActivation(...)` and how it interacts with `Catalog.RegisterActivationInGrainDirectoryAndValidate(...)`. Specifically, it removes the `DuplicateActivationException` thrown by the latter and caught by the former. Doing that required slightly reworking the control flow in `InitActivation` so that exceptions aren't the only means of error handling.

* Move recovery logic in `InitActivation` from `catch` to a new method which is called from the `finally` block.
* Return a new `ActivationRegistrationResult` struct from `RegisterActivationInGrainDirectoryAndValidate` which replaces `DuplicateActivationException`.
* When an activation fails to register, return early from `InitActivation` so that the `finally` block can clean up the activation.

One change worth noting: `InitActivation` will no longer throw when there is a duplicate activation. The activation returned by `GetOrCreateActivation` (which calls into `InitActivation`) will eventually have its `ForwardingAddress` fixed to point to the existing activation. Note that the result of `InitActivation` is only used in one specific case: when creating the `IMembershipTableGrain`. I opened #3129 to discuss converting that into a SystemTarget instead of routing it through the directory.</Description>
    <CreatedDate>15/06/2017</CreatedDate>
    <ClosedDate>19/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3130</PullRequestID>
        <IssueID>2733</IssueID>
        <Title>Rename or remove DuplicateActivationException to prevent confusion </Title>
        <Description>`DuplicateActivationException` doesn't mean that a duplicate activation has been created. It is just a means to resolve a race between two or more silos trying concurrently to register activations for the same grain. However, the very name of the exception class and the message of it misleads people to think that they get duplicate activations.

I suggest we rename the exception class to prevent this confusion from happening.

`RegistrationRaceException`? `ActivationAlreadyRegisteredException`? `ExistingActivationException`?</Description>
        <CreatedDate>15/02/2017</CreatedDate>
        <ClosedDate>19/06/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3130</PullRequestID>
        <IssueID>3129</IssueID>
        <Title>Convert IMembershipTableGrain into a SystemTarget</Title>
        <Description>Currently the `IMembershipTableGrain` is special in that it is registered by the primary using the special-purpose `Catalog.CreateSystemGrain(...)` method.

This all only exists for the purpose of `IMembershipTableGrain` which is only valid for test scenarios - it's not reliable in the distributed systems sense of the word.

Ideally, we could remove that method and the notion of a system grain.</Description>
        <CreatedDate>14/06/2017</CreatedDate>
        <ClosedDate>24/05/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3128</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Cleanup stream producers on dead or missing silos.</Title>
    <Description>Catch rejected messages to producers and remove the producer if those rejections come from dead, dying, or missing silos.

This should address #3056?
</Description>
    <CreatedDate>14/06/2017</CreatedDate>
    <ClosedDate>16/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3128</PullRequestID>
        <IssueID>3056</IssueID>
        <Title>AzureQueueStreamProvider errors after trying to publish message</Title>
        <Description>I am exploring orleans for a potential alternative to ServiceFabric actors. I am testing orleans 1.4.1 on service fabric. I have been researching the streams.
I was able to get the SMSProvider working but, the same publishing and subscription does not seem to work with AzureQueue. I am getting the following error. Also, the message is never received by the grain. No exception is thrown by the client producing the message.
``

I am using this against local ASF running single node and azure storage emulator 4.4.
</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>16/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3127</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jdom</FixedByID>
    <Title>Upgrade WindowsAzure.ServiceBus to 4.1.0</Title>
    <Description>Fixes #2910
Fixes #3062</Description>
    <CreatedDate>14/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3127</PullRequestID>
        <IssueID>2910</IssueID>
        <Title>Update to WindowsAzure.ServiceBus 4.0.0</Title>
        <Description>Any issues if OrleansServiceBus is updated for WindowsAzure.ServiceBus 4.0.0? If that's fine, I could prepare a PR, though it is as trivial as changing the dependency version.</Description>
        <CreatedDate>03/04/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3127</PullRequestID>
        <IssueID>3062</IssueID>
        <Title>EventHub provider and latest version of Microsoft Azure Service Bus  v4.1.1 (WindowsAzure.ServiceBus nuget)</Title>
        <Description>Just want to flag this issue for the future release or anyone who stepped on the same problem as we did and make error text search-able.

`Microsoft.Orleans.OrleansServiceBus` v1.4.1 is not compartible with `WindowsAzure.ServiceBus` major version upgrade v4. (v.4.1.1 as per today)
By definition `Microsoft.Orleans.OrleansServiceBus` 1.4.1 depends on `WindowsAzure.ServiceBus`  v3.3.2.

It's safe to upgrade dependance to the latest v3 ( v3.4.6 as per today), but if you have to upgrade `WindowsAzure.ServiceBus`  to a major v4 version - it breaks EH Stream provider and you'll see this error in your logs:

``

Simple fix for this is to downgrade back to major v3 version.</Description>
        <CreatedDate>29/05/2017</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3126</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>xiazen</FixedByID>
    <Title>Replace CacheSizeInMb setting with DataMaxAgeInCache and DataMinTimeInCache in stream providers</Title>
    <Description>PR for issue #3120.
- Remove CacheSzieInMb setting and its related infrastructure, including cache eviction logic around it and FixedSizeObjectPool, to simplify the system and avoid problems mentioned in #3104
- Add DataMaxAgeInCache and DataMinTimeInCache setting to `EHStreamProvider`, `MemoryStreamProvider` and `GeneratorStreamProvider`
- Add statistic monitoring to  MemoryStreamProvider and GeneratorStreamProvider </Description>
    <CreatedDate>14/06/2017</CreatedDate>
    <ClosedDate>19/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3126</PullRequestID>
        <IssueID>3120</IssueID>
        <Title>Upcoming changes on EHStreamProvider, MemoryStreamProvider and GeneratorStreamProvider in 1.5</Title>
        <Description>Per discussion in #3104 , Since for EventhubStreamProvider, MemoryStreamProvider and GeneratorStreamProvider, the stream provider settings of `DataMaxAgeInCache` and `DataMinTimeInCache` conflicts with `CacheSizeInMb`, we reached the decision that

- We will remove `CacheSzieInMb `setting and its related infrastructure, including cache eviction logic around it and `FixedSizeObjectPool`, to simplify the system and avoid problems mentioned in #3104
- Add `DataMaxAgeInCache `and `DataMinTineInCache` setting to all three stream providers

- Add statistic monitoring too all three stream providers

After 1.5, for these three stream providers, `DataMaxAgeInCache`and `DataMinTineInCache `will be the only criteria used to predicate cache eviction. Be sure to monitor your stream provider behavior using our new monitoring feature (#3014) in 1.5 to choose the correct value for `DataMaxAgeInCache` and `DataMinTineInCache`, since these two will be two of the main influences for cache size</Description>
        <CreatedDate>12/06/2017</CreatedDate>
        <ClosedDate>10/07/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3126</PullRequestID>
        <IssueID>3104</IssueID>
        <Title>Subtle but important behavior change in orleans streaming coming with 1.5</Title>
        <Description>We made several changes to Orleans streaming system in 1.5, including new features and bug fixes, some of which are included in Orleans 1.5 beta, remaining of which will be included in future 1.5 official release. 

Aside from obvious changes you can see in our beta release note:
1. Added extension points to EventHubAdapterFactory #2930
2. Added SlowConsumingPressureMonitor for EventHub streams #2873
3. Programmable stream subscribe API #2741 #2796 #2909 

There's a subtle behavior change in EventHubStreamProvider eco system's cache purge logic, which may not be obvious to end users, but may bring confusion. Let me recap 1.4 and compare it to 1.5 to demonstrate. 
## The behavior change
In EventHubStreamProvider, different cache can be configured to use its own block pool or share block pool with other caches. When messages are added to the cache, cache allocate blocks from block pool to store those messages. When messages expired, there's purging logic kicking in and return purged blocks back to block pool. How messages are purged and how blocks are freed to block pool is what it is subtle different between 1.4 and 1.5.

In 1.4, when the fixed size block pool is full, it send a purge request to the cache (name it cache1) which owns its oldest block (block0), requesting it return block 0 back. This "purge block 0" request will enqueue cache1's purgeQueue and wait there. So overtime, cache1 will have a purgeQueue which is full of "purge block x" requests. Whenever new messages are added to cache1, it will dequeue a "purge block x" request from its purgeQueue and do a purge action. This purge action includes two steps: 1. mark messages as purged if they expired, 2 is return block x to the block pool. **But** because this purge action would return block x to the pool whether it has valid messages (messages which haven't expired yet) or not, it produces cache miss bug. This behavior is fine historically to its initial users. But when more and more users started to use EHStreamProvider, this became a problem , because it violates its time based purge promise, which is configured using DataMaxAgeInCache and DataMinTimeInCache in its EHStreamProviderSettings. This bug is fixed in #2934 , which was included in 1.5beta. 

After that fix, in 1.5beta, messages would only be purged if it expired. Cache now will do a time based purge every time when pulling agent try to `ReadFromQueue`, which is more frequent compared to 1.4.  In its time based purge action, it will do two things, 1 is mark messages as purged if they expired, 2 is put purged blocks into a purgedBlock queue if its messages are all purged. When the block pool send a "purge block x" request to the cache, the cache will free every blocks in its purgedBlock queue up to this block x. In this way, we won't be freeing blocks which still contains valid messages.
## What users need to do
This fix brings up a dilemma, which is why I want to write this post. Since even when the block pool is full and it sends out the "purge oldest block" request,  the oldest block is not always purged anymore in 1.5. The promise on "fixed size" is not enforced. **Size of block pool depends more on DataMaxAgeInCache and DataMinTimeInCache  settings, less on CacheSizeInMb**. And since CacheSizeInMb is be essentially based on DataMinTimeInCache and DataMaxAgeInCache Settings, we think it is a good direction to go. And we may remove CacheSizeInMb related settings and infra in the future. 

And to help end users tune their settings to avoid memory allocation related issues, we will be releasing statistic monitoring feature (#3014) in 1.5, which will help end users to understand their cache's behavior and tune their settings to a optimal value. 

Last thing I want to bring up, there could be a bad behavior in 1.5 beta streaming if you used EHStreamProvider under a massive delivery scenario (for example, 15190 TPS per silo). The cause of it is : in massive delivery scenario, purge block x request from block pool can be always too new to purge, hence "free block" action will not be performed even when the cache's purgeBlocks queue is not empty. This results in purged blocks not able to be freed to the pool, which leads to unnecessary memory allocation and potentially out of memory exception from your host. If you see memory issues in streaming when migrating to 1.5 beta, this might be the cause. And we will be including a fix for that in 1.5 . 
</Description>
        <CreatedDate>08/06/2017</CreatedDate>
        <ClosedDate>10/07/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3109</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Add flag to disable FastKill on CTRL-C</Title>
    <Description>Fix for #3094</Description>
    <CreatedDate>08/06/2017</CreatedDate>
    <ClosedDate>09/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3109</PullRequestID>
        <IssueID>3094</IssueID>
        <Title>Control over how Orleans behaves on CTRL+C</Title>
        <Description>The [Orleans Silo listens for CTRL+C](https://github.com/dotnet/orleans/blob/master/src/OrleansRuntime/Silo/Silo.cs#L526) and starts a fast exit when it detects it. This can cause problems if you use something like TopShelf to host a silo and are running it as a console application.

For example, if you configure TopShelf to gracefully shutdown the silo on exit:

``

Is there a way of detecting whether the silo is currently in the process of shutting down? I could not find one. The `SystemStatus` property of `Silo` would seem ideal, but is internal. Alternatively, can the silo configuration be extended to allow this behaviour to be switched off?</Description>
        <CreatedDate>06/06/2017</CreatedDate>
        <ClosedDate>09/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3108</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Fix docs search in Edge</Title>
    <Description>This fixes #3046.
Rebuilt html docs, which picked up recent changes.</Description>
    <CreatedDate>08/06/2017</CreatedDate>
    <ClosedDate>08/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3108</PullRequestID>
        <IssueID>3046</IssueID>
        <Title>Docs search doesn't work in Edge</Title>
        <Description>Search used to work fine in Edge before and continues to work in Chrome, but seems broken in Edge in Win10 15063.296.</Description>
        <CreatedDate>25/05/2017</CreatedDate>
        <ClosedDate>08/06/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3100</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dandago</FixedByID>
    <Title>Rewrote sections on ADO .NET and MemoryStorage providers</Title>
    <Description>I have rewritten the ADO .NET and MemoryStorage provider sections in the Grain Persistence documentation page. The samples and tables are mainly taken from my [ADO .NET Grain Persistence](http://gigi.nullneuron.net/gigilabs/orleans-grain-persistence-with-the-ado-net-storage-provider/) and [Introduction to Grain persistence](http://gigi.nullneuron.net/gigilabs/introduction-to-grain-persistence-with-microsoft-orleans/) articles.

Some things worth noting:
* I have added samples for both XML configuration and code configuration.
* I have added tables listing all the properties you can set.
* I have removed references to PostgreSQL since this is not actually supported (partly addresses #3085).
* I have removed examples of SQL Server specific connection strings as well as a code block showing programmatic configuration that was impossible to read.
* I have added info on the `AdoInvariant`s you need to set (partly addresses #3070). While this is not necessary for SQL Server, I want to get people in the habit of setting it anyway so as not to miss it when setting things up for other vendors (which happened to me).
* I am recommending the use of JSON format over binary.
* I have changed the instructions regarding the StorageProviders sample which were incomplete.</Description>
    <CreatedDate>07/06/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3100</PullRequestID>
        <IssueID>3085</IssueID>
        <Title>Problems with PostgreSQL Storage</Title>
        <Description>In relation to #3070, I am checking out the ADO .NET Storage Provider with PostgreSQL. The [Grain Persistence](https://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Grain-Persistence.html) page does suggest that PostgreSQL is supported, and the Microsoft.Orleans.OrleansSqlUtils package does have a script for PostgreSQL. However:

1. There is no storage table in the script for PostgreSQL:

![image](https://cloud.githubusercontent.com/assets/13241564/26753669/9748c1c6-486b-11e7-834a-d9ee66c1c9c3.png)

2. There is no mention anywhere of what the AdoInvariant for PostgreSQL should be, not even in the Relational Storage page where the ones for SQL Server and MySQL are listed. It's "Npgsql", and needs to be added to the documentation.

3. I was trying to set it up anyway, on a basic Dev/Test Host, using the following configuration:

``

The silo simply hangs after registering storage providers, and does not continue:

![image](https://cloud.githubusercontent.com/assets/13241564/26753685/1b2b7632-486c-11e7-9dbb-467e941fc597.png)

Repro project: 
[postgresql-orleans-repro.zip](https://github.com/dotnet/orleans/files/1049604/postgresql-orleans-repro.zip)</Description>
        <CreatedDate>03/06/2017</CreatedDate>
        <ClosedDate>22/09/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3100</PullRequestID>
        <IssueID>3070</IssueID>
        <Title>Add ADO and other configuration samples to  Relational Storage page in documentation</Title>
        <Description>I am attempting to use the ADO .NET Storage provider with MySQL, which according to the [Storage Providers documentation](http://dotnet.github.io/orleans/Documentation/Getting-Started-With-Orleans/Grain-Persistence.html) should be supported.

The SiloHost is failing to start with the following exception text:

&gt; "Unable to find and/or load a candidate assembly for 'System.Data.SqlClient' invariant name."

I have tracked this to the [DbConnectionFactory.cs](https://github.com/dotnet/orleans/blob/2c0cb3c11c86ee9b4e3299aedeeeab885a39825d/src/OrleansSQLUtils/Storage/DbConnectionFactory.cs) file. Although I installed the _MySql.Data_ package, Orleans still seems to be looking for the package needed if we were to work against SQL Server.

This might be related to the [ADO .NET Invariants](https://github.com/dotnet/orleans/blob/8d6153f46763a3ec97db483142ce17b9d90dc9c9/src/OrleansSQLUtils/Storage/AdoNetInvariants.cs). For SQL Server, System.Data.SqlClient is both the name of the invariant and of the package/assembly. However this is not true for MySQL: the package/assembly is MySql.Data, whereas the invariant is MySql.Data.MySqlClient. If the connection code that looks for the assembly is working based on invariant name, this could explain why it works with SQL Server but not MySQL.

I am using Orleans 1.4.1.</Description>
        <CreatedDate>31/05/2017</CreatedDate>
        <ClosedDate>08/06/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3092</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>wattsm</FixedByID>
    <Title>Correct ClusterFixture's Dispose() method in unit testing tutorial</Title>
    <Description>As per the comments on #3028 fix the `Dispose()` method on `ClusterFixture` so that it calls `StopAllSilos()`.</Description>
    <CreatedDate>06/06/2017</CreatedDate>
    <ClosedDate>06/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3092</PullRequestID>
        <IssueID>3028</IssueID>
        <Title>Update unit test tutorial to use TestCluster</Title>
        <Description>Hello,

I noticed when working through the [unit testing tutorial](https://dotnet.github.io/orleans/Tutorials/Unit-Testing-Grains.html) that it uses `TestingSiloHost` which is [marked as obsolete](https://github.com/dotnet/orleans/pull/2919).

I have rewritten this tutorial to use `TestCluster`, and also added a bit of detail about mocking. I have tried to incorporate as much of the relevant content from the previous version as possible.

Hope this helps. Feed / suggestions / requests more than welcome</Description>
        <CreatedDate>19/05/2017</CreatedDate>
        <ClosedDate>22/05/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3083</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Support multiple request interceptors</Title>
    <Description>Implements #2000 and marks the existing interface methods as obsolete.

Interceptors are configured by registering `InvokeInterceptor` instances with the DI container in the `ConfigureServices` startup method, like so:
```C#
services.AddSingleton&lt;InvokeInterceptor&gt;((method, request, target, invoker) =&gt;
{
    RequestContext.Set(InterceptedPropertyKey, 1);
    return invoker.Invoke(target, request);
});
```

The interceptor set via `IProviderRuntime.SetInvokeInterceptor(...)` is executed last.

Future work: add an extension method to the future SiloBuilder to make configuration more discoverable/obvious.</Description>
    <CreatedDate>02/06/2017</CreatedDate>
    <ClosedDate>15/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3083</PullRequestID>
        <IssueID>2000</IssueID>
        <Title>Allow multiple silo interceptors to be set</Title>
        <Description>The current Orleans interceptor API provides methods for getting and setting interceptors:

``

The problem is that a second call to `SetInvokeInterceptor` will overwrite the original interceptor. This means that two bootstrap providing could be competing for a single interceptor, unless the developer observes any previously set interceptor.

I propose adding a new method to add an interceptor to an internally maintained stack. The runtime code will then run each of the interceptors in the stack in turn.

This would allow easier registration of multiple interceptors.
</Description>
        <CreatedDate>29/07/2016</CreatedDate>
        <ClosedDate>15/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3082</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Blocked grains in "Deactivating" state detection and mitigation </Title>
    <Description>A Grain can be blocked on the Deactivating state. The following PR extends the logic implemented in #2387 to detect such case.</Description>
    <CreatedDate>02/06/2017</CreatedDate>
    <ClosedDate>06/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3082</PullRequestID>
        <IssueID>2387</IssueID>
        <Title>Blocked grains detection and mitigation</Title>
        <Description>Fix for #1383

A bug in a grain implementation can "block" a grain activation. An easy mitigation would be to detect this state when we try to enqueue a new message to this activation, and then destroy it.

This PR implement this workaround. When destroying the current activation, all pending messages will be forwarded to a new activation. The `OnDeactivateAsync` is also called, like a "normal" deactivation.</Description>
        <CreatedDate>04/11/2016</CreatedDate>
        <ClosedDate>07/12/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3077</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shlomiw</FixedByID>
    <Title>Exposing internal IsOrleansShallowCopyable to for external custom serializers </Title>
    <Description>Hi,
As discussed with @ReubenBond in #3064 , I'm exposing `IsOrleansShallowCopyable` for external custom serializer.

Background: I've created a custom serializer for `ObservableCollection`, and copied the logic of copying `List&lt;T&gt;` from `BuiltInTypes.DeepCopyList()`, it uses this method to allow quick shallow copy.</Description>
    <CreatedDate>01/06/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3077</PullRequestID>
        <IssueID>3064</IssueID>
        <Title>DeepCopier with ObservableCollection suddenly requires all class graph to be marked as [Serialized]</Title>
        <Description>Hi,

I've changed a property of a class from List&lt;&gt; to ObservableCollection&lt;&gt;.
This class is EF entity and it has a deep graph of classes connected.

I'm sending this class via grain, and I had no issues before the change.
Now I'm getting SerializationException: 'Type .. in Assembly .. is not marked as serializable'. And I need to do it to *all* the different classes types in the object graph.

Can we avoid setting all these classes as [Serializable]?

Thanks in advance,
Shlomi

Attaching a screenshot of the exception:
![image](https://cloud.githubusercontent.com/assets/1025170/26555235/c8055db0-449c-11e7-94fb-0dc1a7052703.png)
</Description>
        <CreatedDate>29/05/2017</CreatedDate>
        <ClosedDate>30/05/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3073</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve serialization of GrainReference when using JSON</Title>
    <Description>Fixes #3063.

We have a specific `JsonConverter` for grain references which was introduced along with the non-static `SerializationManager` changes. The converter is required to flow the runtime context into `GrainReferences` on .NET Standard, but it was incorrectly implemented.

On full .NET, this converter is technically not required, since `GrainReference` implements `ISerializable` and we flow the runtime into the `StreamingContext.Context` property. This property does not exist on .NET Standard &lt; v2.0 and so this converter is required.

This PR involves a rewrite of the implementation of `GrainReferenceConverter` so that GrainReferences work even if they are passed via a field with an ambiguous type such as `object` or `GrainReference`.

It does this by having an internal serializer which defers to the `ISerializable` implementation, and then manually binding the reference to the runtime at deserialization time.</Description>
    <CreatedDate>31/05/2017</CreatedDate>
    <ClosedDate>01/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3073</PullRequestID>
        <IssueID>3063</IssueID>
        <Title>NullReferenceException roundtrip GrainReference with jsonserializer</Title>
        <Description>Hi,

We get the following exception when activating a previously explicitly subscribed grain from a bootstrapprovider.

The grain has a generic type definition.. which I think is the problem.

Exception / stacktrace
``



</Description>
        <CreatedDate>29/05/2017</CreatedDate>
        <ClosedDate>01/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3061</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Service Fabric: Mark removed silos as Dead indefinitely</Title>
    <Description>Instead of setting a no-longer-present silo's status to `SiloStatus.None`, leave a tombstone declaring it `Dead`.

Related to #3056</Description>
    <CreatedDate>27/05/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3061</PullRequestID>
        <IssueID>3056</IssueID>
        <Title>AzureQueueStreamProvider errors after trying to publish message</Title>
        <Description>I am exploring orleans for a potential alternative to ServiceFabric actors. I am testing orleans 1.4.1 on service fabric. I have been researching the streams.
I was able to get the SMSProvider working but, the same publishing and subscription does not seem to work with AzureQueue. I am getting the following error. Also, the message is never received by the grain. No exception is thrown by the client producing the message.
``

I am using this against local ASF running single node and azure storage emulator 4.4.
</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>16/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>3059</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Service Fabric: execute cluster update notifications on an Orleans thread</Title>
    <Description>Fix for #3057, in which @rikbosch is experiencing threading issues caused by the `FabricMembershipOracle` not executing cluster status notifications on an Orleans thread.

Proposed solution is to capture the `OrleansTaskScheduler` in the `IMembershipOracle.Start` call and later use it to schedule notifications.</Description>
    <CreatedDate>26/05/2017</CreatedDate>
    <ClosedDate>07/06/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>3059</PullRequestID>
        <IssueID>3057</IssueID>
        <Title>invalid RuntimeContext in ServiceFabric silo on range changenotification</Title>
        <Description>Hi,

 We are experiencing some trouble connecting to our cluster running in service fabric. Looking in the silo logs, I see the following exception:

`` comes back on a different context, but I'm not sure..


</Description>
        <CreatedDate>26/05/2017</CreatedDate>
        <ClosedDate>08/06/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2756</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix AsReference() in generated code for null values</Title>
    <Description>Fix #2750 &amp; #2751</Description>
    <CreatedDate>21/02/2017</CreatedDate>
    <ClosedDate>22/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2756</PullRequestID>
        <IssueID>2750</IssueID>
        <Title>Having a null grain reference as a property on a GrainState object results in an exception</Title>
        <Description>Having a Grain state object fails to persist if a grain Interface property is unset (`null`)

Solution is to set EventGrainState.Metadata.Owner = to a grain reference.


**Code:**
``</Description>
        <Code>```csharp
 public class EventGrainState
    {
        public bool IsInitialized { get; set; }
        public ObjectMetadata Metadata { get; set; } = new ObjectMetadata();
        public string Name { get; set; }
        public EventData Data { get; set; } = new EventData();
        public TimeSpan Interval { get; set; }
    }
   public class ObjectMetadata
    {
        public DateTime CreatedDate { get; internal set; }
        public DateTime ModifiedDate { get; internal set; }
        public IUserGrain Owner { get; internal set; }
    }
    public class EventData
    {
        public string EventType { get; set; }
        public string Parameters { get; set; }
    }
```

**Stack Trace:**

```Cannot pass null as an argument to AsReference
Parameter name: grain
   at Orleans.GrainExtensions.AsReference[TGrainInterface](IAddressable grain)
   at NRC.Services.Scheduler.Grains.OrleansCodeGenNRC_Services_Scheduler_Grains_ObjectMetadataSerializer.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at NRC.Services.Scheduler.Grains.OrleansCodeGenNRC_Services_Scheduler_Grains_EventGrainStateSerializer.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.OrleansCodeGenOrleans_GrainStateSerializer`1.DeepCopier(Object original)
   at Orleans.Serialization.SerializationManager.&lt;&gt;c__DisplayClass61_0.&lt;Register&gt;b__0(Object obj)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopierHelper(Type t, Object original)
   at Orleans.Serialization.SerializationManager.DeepCopyInner(Object original)
   at Orleans.Serialization.SerializationManager.DeepCopy(Object original)
   at Orleans.Runtime.GrainReference.InvokeMethodAsync[T](Int32 methodId, Object[] arguments, InvokeMethodOptions options, SiloAddress silo)
   at Orleans.Storage.OrleansCodeGenMemoryStorageGrainReference.WriteStateAsync(String grainType, String grainId, IGrainState grainState)
   at Orleans.Storage.MemoryStorage.&lt;WriteStateAsync&gt;d__21.MoveNext()
`</Code>
        <CreatedDate>21/02/2017</CreatedDate>
        <ClosedDate>22/02/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2756</PullRequestID>
        <IssueID>2751</IssueID>
        <Title>Serializing State classes with null grain references fail in 1.4</Title>
        <Description>As @ReubenBond  and I discussed when I want to serialize a State using WriteStateAsync, if the state class contains a reference to a grain interface say `IPlayer` which was a `GrainWithStringKey` , the serializer (the generated code) throws an exception `ArgumentNullException` when calling `AsReference`

The test failed on a relatively lohng running project which was ok on previous Orleans versions. I can post more info if needed</Description>
        <CreatedDate>21/02/2017</CreatedDate>
        <ClosedDate>22/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2749</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Maarten88</FixedByID>
    <Title>Remove unnecessary service registration of IServiceProvider to itself</Title>
    <Description>This registration causes a "Circular Reference" error when used with Autofac (#2747) and seems unnecessary as the DI framework provides it automatically.</Description>
    <CreatedDate>21/02/2017</CreatedDate>
    <ClosedDate>21/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2749</PullRequestID>
        <IssueID>2747</IssueID>
        <Title>Circular reference in IServiceProvider when using Autofac DI</Title>
        <Description>I upgraded to Orleans 1.4.0, and got an error from Autofac, which I use as my DI framework with Orleans instead of the default Microsoft DI. When starting the Silo host, Autofac complains:

    Circular component dependency detected: Orleans.GrainFactory -&gt; System.IServiceProvider -&gt; System.IServiceProvider.

And then the silo refuses to start. It seems Microsoft DI is more forgiving, returning services.BuildServiceProvider() instead of AutofacServiceProvider(builder.Build()) with the exact same registrations results in a succesful start of the silo.

Runtime/OutsideRuntimeClient.cs line 110 reads:

   services.AddSingleton&lt;IServiceProvider&gt;(sp =&gt; sp);

My guess is that Autofac does not like that, it seems circular indeed so I guess this causes the bug. I'm not sure why that line is there; it seems it can be safely deleted?</Description>
        <CreatedDate>20/02/2017</CreatedDate>
        <ClosedDate>21/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2739</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Reduce severity of ~"codegen asm not present" message from Warn to Info</Title>
    <Description>Fix for review feedback by @jdom on #2737</Description>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2739</PullRequestID>
        <IssueID>2737</IssueID>
        <Title>Change CodeGen classes to be non-static</Title>
        <Description>In preparation for non-static grain clients and non-static SerializationManager, we need to also make this class non-static.

Simple change, functionals pass.</Description>
        <CreatedDate>16/02/2017</CreatedDate>
        <ClosedDate>16/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2735</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Remove more references to global RuntimeClient.Current</Title>
    <Description>Completely removed `InsideRuntimeClient.Current and removed most usages of `RuntimeClient.Current`.

In order to have everthing continue working, I needed to make some of the dependencies in `InsideRuntimeClient` lazy.

Note that this depends on #2592</Description>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>01/03/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2735</PullRequestID>
        <IssueID>2592</IssueID>
        <Title>Non-static SerializationManager</Title>
        <Description>Disclaimer: this is a work in progress. It needs work, more functional testing, and to be split into smaller, more mergable PRs. `SerialziationManager` is a core part of our system and `GrainReference` is serializable, so this PR is necessarily going to be large

Implements changes from #2591 &amp; [#467](https://github.com/dotnet/orleans/issues/467#issuecomment-255074892) (with changes).

When using an external serializer (eg, JSON.NET, ProtoBuf), `GrainReference` instances must be bound via a call to `IGrainFactory.Bind(IAddressable)` before they can be used. When using the Orleans serialization framework, this happens automatically.

Once this is ready, we will be close to completing #467. Only some minor additional work is required to complete the task, basically changing the GrainClient class itself.

Note: this is a breaking change.

EDIT: to be clear, I don't expect this code to be reviewed in detail while I've got the work-in-progress tag on it. When it's ready, I'll remove the tag and update this PR.</Description>
        <CreatedDate>13/01/2017</CreatedDate>
        <ClosedDate>24/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2726</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Cherry-pick two more fixes for 1.4.0</Title>
    <Description>Bugfix - EventHubSequenceToken not used consistently (#2724)
Support grains with generic state where the state param do not match the grain type params (#2715)
</Description>
    <CreatedDate>14/02/2017</CreatedDate>
    <ClosedDate>14/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2726</PullRequestID>
        <IssueID>2724</IssueID>
        <Title>Bugfix - EventHubSequenceToken not used consistently</Title>
        <Description>EventSequenceToken was being used instead of EventHubSequenceToken.</Description>
        <CreatedDate>13/02/2017</CreatedDate>
        <ClosedDate>13/02/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2726</PullRequestID>
        <IssueID>2715</IssueID>
        <Title>Improve support for generic grains with generic state</Title>
        <Description>Current support for generic grains with generic state assumes that the type parameter to the grain is also the type parameter of the state class.

This PR relaxes that assumption by navigating the concrete grain type's hierarchy until it reaches the `Grain&lt;TState&gt;` level and extracting the concrete value of `TState`.

/cc @lwansbrough who [reported this issue on Gitter](https://gitter.im/dotnet/orleans?at=589d05abaa800ee52c75e6de) - thank you, Loch!</Description>
        <CreatedDate>10/02/2017</CreatedDate>
        <ClosedDate>10/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2718</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>amccool</FixedByID>
    <Title>another removal of TestingSiloHost</Title>
    <Description>removed another usage of TestingSiloHost for #2232 </Description>
    <CreatedDate>10/02/2017</CreatedDate>
    <ClosedDate>10/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2718</PullRequestID>
        <IssueID>2232</IssueID>
        <Title>Help wanted: Replace all usages of TestingSiloHost with TestCluster</Title>
        <Description>Our plan is to make `TestingSiloHost` obsolete as it was completely superseded by the more flexible `TestCluster`. Nevertheless, we have several tests in the `TesterInternal` project that are still using it and the declarative config that need to be converted.
We should do a pass and remove all references to the TestingSiloHost class.
In order to do that, those tests would have to stop using the XML configuration, and use programmatic configuration.
For reference, PR #1643 is where the Tester project was migrated to use TestCluster, and specifically this commit from it: https://github.com/dotnet/orleans/pull/1643/commits/d931e6a418eb3ec119c1a254d18b90967fe595f1
</Description>
        <CreatedDate>27/09/2016</CreatedDate>
        <ClosedDate>02/10/2017</ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2713</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>[1.4.0] Fix ServiceFabric support + Samples</Title>
    <Description>xref #2712</Description>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>10/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2713</PullRequestID>
        <IssueID>2712</IssueID>
        <Title>Fix DI registrations for ServiceFabric</Title>
        <Description>Fixes issues with the Service Fabric providers. Reported by @Kwal (thanks!)</Description>
        <CreatedDate>09/02/2017</CreatedDate>
        <ClosedDate>09/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2693</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Revert "Cherry-picked commits from master to go in 1.4.0 final"</Title>
    <Description>Reverts dotnet/orleans#2688</Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>07/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2693</PullRequestID>
        <IssueID>2688</IssueID>
        <Title>Cherry-picked commits from master to go in 1.4.0 final</Title>
        <Description>It's pretty much everything since 1.4.0-beta except for the commits related to non-static `SerializationManager` work.</Description>
        <CreatedDate>07/02/2017</CreatedDate>
        <ClosedDate>07/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2692</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Reduce SchedulingContext allocs for grain activations</Title>
    <Description>By implementing `ISchedulingContext` in `ActivationData` we can remove at least one allocation per call.

I did not perform the same optimization for `SystemTarget` at this stage because there are comparatively very few `SystemTarget`s and we already allocate just one `SchedulingContext` per `SystemTarget` (i.e, not per-call).

I chose to implement this explicitly in `ActivationData` rather than adding a `SchedulingContext` member because it's simple and results in less GC pressure without adding any fields.

Fixes #2677.</Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>13/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2692</PullRequestID>
        <IssueID>2677</IssueID>
        <Title>[Question] Why is a new SchedulingContext created for each grain call?</Title>
        <Description>This question has been on the back of my mind for a while now: Why is a new `SchedulingContext` created for each grain call?

Could we move the `ISchedulingContext` implementation to `ActivationData` either by making that class implement it itself or by including it as a property? `SystemTarget` does something like this. The current implementation seems a bit allocation-heavy.

Perhaps @gabikliot or @sergeybykov or someone else can shed some light?</Description>
        <CreatedDate>06/02/2017</CreatedDate>
        <ClosedDate>13/02/2017</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2686</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>serbrech</FixedByID>
    <Title>Update AzureWebSample to orleans 1.3.1</Title>
    <Description>Part of #2359</Description>
    <CreatedDate>07/02/2017</CreatedDate>
    <ClosedDate>08/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2686</PullRequestID>
        <IssueID>2359</IssueID>
        <Title>Migrate samples to 2.1</Title>
        <Description>The samples (https://github.com/dotnet/orleans/tree/master/Samples) are on 1.2.3 now. Shouldn't be to difficult to migrate them to 1.3.0.
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2670</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Support for grains with generic methods</Title>
    <Description>This PR adds support for generic methods on grains in a pay-for-what-you-use fashion, so any additional cost is only incurred for generic methods. The cost should be quite low anyway because the invoker stub is generated using (simple) IL.

Supports methods with constraints, overloads, generic methods inside generic grains, upcasting arguments, grain observers, and grain extensions (last one not tested). We can address anything I missed as they come.

This is what a generated `GrainReference` method looks like for a generic method:
```C#
public global::System.Threading.Tasks.Task&lt;global::System.Type[]&gt; @GetTypesInferred&lt;T, U&gt;(T @t, U @u, global::System.Int32 @v)
{
    return base.@InvokeMethodAsync&lt;global::System.Type[]&gt;(-1221167187, new global::System.Object[]{typeof (T), typeof (U), @t, @u, @v});
}
```
Notice that it passes the static types of the arguments in the arguments array before the actual arguments.

The other end is more complicated: in the `IGrainMethodInvoker`, we add a static `GenericMethodInvoker` field for each generic method and use that for invoking the methods using runtime codegen (IL). So a snippet of the generated invoker looks like this:
```C#
switch (interfaceId)
{
    case 447824211:
        switch (methodId)
        {
            case 1337175495:
                return GetTypesExplicitT_U_V.@Invoke(@grain, arguments);
            case -105247224:
                return GetTypesInferredT_U_V.@Invoke(@grain, arguments);
            case -1221167187:
                return GetTypesInferredT_U.@Invoke(@grain, arguments);
```

With the fields declared something like this:
```C#
private static readonly global::Orleans.CodeGeneration.GenericMethodInvoker GetTypesExplicitT_U_V = new global::Orleans.CodeGeneration.GenericMethodInvoker(typeof (global::Tester.CodeGenTests.IGrainWithGenericMethods), "GetTypesExplicit", 3);
```

We use these fields to ensure that everything is as efficient as can be: no additional allocations are made on the hot path (any allocs are made only once).

The generated IL for the invokers looks like this:
```
Ldarg_0 // Load the grain argument
Castclass &lt;grain interface type&gt;

// foreach arg:
Ldarg_1 // Load the arguments array
Ldc_I4 &lt;arg index + number of type params&gt;
Ldelem_Ref // Load the argument as a reference (since it's an object array)
CastClass &lt;argument type&gt; // Or Unbox_Any &lt;type&gt; if it's a value type.

Call &lt;concrete method&gt;

// If return type is void
Call TaskDone.Done
// Else if return type is Task
Call PublicOrleansTaskUtils.Box(Task)
// Else if return type is Task&lt;T&gt;
Call PublicOrleansTaskUtils.Box(Task&lt;T&gt;)

Ret
```

Thanks, @Joshua-Ferguson, for your PR which I took inspiration from to create this :) You led the way. I had figured it was too difficult to implement and just not worth it.

Implements #1352
cc @@marianogenovese &amp; @centur (since you both asked about this functionality recently)</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2670</PullRequestID>
        <IssueID>1352</IssueID>
        <Title>Generic Grain Methods</Title>
        <Description>I created an Orleans grain with a generic method call and I noticed that codegen failed. I'm not sure if it should fail on generics (intentional for performance reasons, or user error?). I created a [PR](https://github.com/Joshua-Ferguson/orleans/pull/1) on a fork to show the changes I made to get generics working. But I'm not sure the changes are made are the best way to do it (really just wanted to be able to test that it could be done). I got the type info &lt; T &gt; passed where I could and used &lt; dynamic &gt; everywhere else.

``

I was able to make calls to all these methods.
</Description>
        <CreatedDate>29/01/2016</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2669</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>centur</FixedByID>
    <Title>Fix: assign correct value to grainState.Etag when ClearStateAsync is called</Title>
    <Description>Fixes issue #2668</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2669</PullRequestID>
        <IssueID>2668</IssueID>
        <Title>Bug: Azure Blob Storage provider leaves grain in inconsistent state after ClearStateAsync is called and loses first follow-up write of the state to the same grain in certain conditions</Title>
        <Description>The bug is around Etag being set on ClearStateAsync call and it's a bit tricky to reproduce (code in provider is a bit convoluted). The key point is to re-use grain instance ( while it's still in memory

Reproduction steps:
1. Create a simple grain with Write\Clear state calls (see DebugGrain in the end)

2. Invoke it like this:
``

PS: @richorama owes me a beer and some extra hair for my back that were pulled out investigating this ;)

</Description>
        <CreatedDate>03/02/2017</CreatedDate>
        <ClosedDate>06/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2667</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sebastianburckhardt</FixedByID>
    <Title>event-sourcing documentation</Title>
    <Description>A first draft of the documentation as promised in #2598.

This is not yet complete, as it does not yet discuss the samples which I will add soon.

Also, we most likely want to not merge this until #2651 is completed in case there are more changes to the API.

However, I thought it may be good to at least start this PR as it may be quite helpful to everyone involved to have some coherent documentation.
</Description>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>22/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2667</PullRequestID>
        <IssueID>2598</IssueID>
        <Title>Provide docs for Log Consistency Providers and split test</Title>
        <Description>First of all, thank you @sebastianburckhardt for the great work!

After #1854 got merged I tried play with it but was unable to get it to work. I was unable to find among the tons of tests what are the files related to `OrleansEventSourcing` project. The configuration and requirements is what is hardest to find.

I would suggest a simple page with the minimum required configuration to get it to work. 

Also, would be good if that project has its own test project. I can do it myself if you point out what exactly is related to this project inside the test projects.

Thank you Sebastian! :)</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>10/02/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2667</PullRequestID>
        <IssueID>2651</IssueID>
        <Title>improve JournaledGrain API, add better tests/examples</Title>
        <Description>Based on discussion in #2598.

Added `RetrieveConfirmedEvents` method to JournaledGrain, which can read a desired segment of the event log.

Added many more tests/examples as the first step to better documentation. These demonstrate a diverse collection of scenarios, including several configuration options. 

They are located in folders:
- Tester.EventSourcing
- TestGrains.EventSourcing 
- TestGrainInterfaces.EventSourcing
</Description>
        <CreatedDate>28/01/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2666</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add RequestContextUtil (prep for non-static SerializationManager)</Title>
    <Description>Please review the latest commit only and of course avoid merging before the prior commits are merged (#2654 &amp; #2665).

Since `RequestContext` has an implicit dependency on `SerializationManager`, changes will need to be made to support #467.

This PR injects a seemingly useless class, `RequestContextUtil` which will later hold an instance of non-static `SerializationManager` (as can be seen in #2592).

It also adds a client-side dependency on `Microsoft.Extensions.DependencyInjection`. This needs to happen sooner or later. DI is not exposed to consumers by this PR.</Description>
    <CreatedDate>02/02/2017</CreatedDate>
    <ClosedDate>06/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2666</PullRequestID>
        <IssueID>2654</IssueID>
        <Title>Reduce use of statics. Prep for non-static SerializationManager</Title>
        <Description>Simple changes which were extracted from #2592.

The changes are very basic. Some of the changes only make sense if you evaluate them with the understanding that they are in preparation for making SerializationManager non-static, so keep that in mind.

Most of the changes are simply passing fixtures into test classes.</Description>
        <CreatedDate>30/01/2017</CreatedDate>
        <ClosedDate>06/02/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2666</PullRequestID>
        <IssueID>2665</IssueID>
        <Title>Rename IRuntimeClient.Identity to CurrentActivationIdentity</Title>
        <Description>`IRuntimeClient.Identity` is a confusing property, since the name implies it's the identity of the runtime client (which might be interpreted as client/silo id).</Description>
        <CreatedDate>02/02/2017</CreatedDate>
        <ClosedDate>03/02/2017</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2666</PullRequestID>
        <IssueID>467</IssueID>
        <Title>Make the GrainClient class non-static</Title>
        <Description>Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving this issue.

Client code will create an instance of `GrainClient` instead of using the static `GrainClient.Initialize` as follows:

``

---

@gabikliot wrote:
TODOs:
- [x] Remove all static mutable fields from client runtime.
- [ ] Static Interners
- [x] `RuntimeClient.Current.SendRequest`
- [ ] Static `TraceLogger` instances
- [ ] Static mutable fields inside `TraceLogger`
- [x] Placement Singletons
- [x] Serializer internal collections
- [ ] All statistics counters
</Description>
        <CreatedDate>29/05/2015</CreatedDate>
        <ClosedDate>19/04/2017</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2666</PullRequestID>
        <IssueID>2592</IssueID>
        <Title>Non-static SerializationManager</Title>
        <Description>Disclaimer: this is a work in progress. It needs work, more functional testing, and to be split into smaller, more mergable PRs. `SerialziationManager` is a core part of our system and `GrainReference` is serializable, so this PR is necessarily going to be large

Implements changes from #2591 &amp; [#467](https://github.com/dotnet/orleans/issues/467#issuecomment-255074892) (with changes).

When using an external serializer (eg, JSON.NET, ProtoBuf), `GrainReference` instances must be bound via a call to `IGrainFactory.Bind(IAddressable)` before they can be used. When using the Orleans serialization framework, this happens automatically.

Once this is ready, we will be close to completing #467. Only some minor additional work is required to complete the task, basically changing the GrainClient class itself.

Note: this is a breaking change.

EDIT: to be clear, I don't expect this code to be reviewed in detail while I've got the work-in-progress tag on it. When it's ready, I'll remove the tag and update this PR.</Description>
        <CreatedDate>13/01/2017</CreatedDate>
        <ClosedDate>24/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2661</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Follow up on "Client cluster disconnection #2628"</Title>
    <Description>Following up on #2628

Safer implementation of GrainClient.NotifyClusterConnectionLost and add logging in case of failure when calling event subscriber</Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2661</PullRequestID>
        <IssueID>2628</IssueID>
        <Title>Client cluster disconnection</Title>
        <Description>Fix for "Access to grain client connection status" #2551 

Now `ProxiedMessageCenter` keeps a counter of opened gateway connection. When this counter reach 0, we send an event to the client to notify that the client might have been disconnected from the cluster.

I think we still can have race condition like this:
- Client connected to GW1 (counter set to 1)
- GW1 connection lost (but no update to the counter yet)
- GW2 connection established (but no update to the counter yet)
- GW2 updates the opened connection counter (counter set to 2)
- GW1 updates the opened connection counter (counter set to 1)

But the windows seems small enough for me, so this fix seems still useful for now
</Description>
        <CreatedDate>23/01/2017</CreatedDate>
        <ClosedDate>30/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2660</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Allow overriding MethodId using [MethodId(id)] on interface methods</Title>
    <Description>Implements #2659.

This slightly improves the upgrade story by removing the restriction that method names and method parameter type names cannot be changed without breaking existing clients/silos.

Users can add the `[MethodId(x)]` attribute to methods to override the default algorithm for generating ids.</Description>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2660</PullRequestID>
        <IssueID>2659</IssueID>
        <Title>Override MethodId for generated GrainReferences</Title>
        <Description>In order to support the versioning story which @benjaminpetit is working on, we should support explicitly specifying a method's `MethodId` so that it remains stable when it's renamed or when one of its parameter types are renamed.

The result would look like this:
``

EDIT: ~~the~~ my intention is to add similar attributes for fields/properties to support stable serialization, too. So we could either have a bunch of attributes for types/methods/fields/assemblies, or we could have just one: `[Id(x)]` (which is what Bond call their attribute)</Description>
        <CreatedDate>31/01/2017</CreatedDate>
        <ClosedDate>02/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2658</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sergeybykov</FixedByID>
    <Title>Fixed #2643 Added a data adapter to azure queue stream provider by @jason-bragg</Title>
    <Description>This is an attempt to fix #2643, which has a build failure in vNext.</Description>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2658</PullRequestID>
        <IssueID>2643</IssueID>
        <Title>Added a data adapter to azure queue stream provider</Title>
        <Description>The data adapter allows users to use the new v2 versions of sequence token and batch container without risking changes to the original versions, which are being used in production services.
The adapter also allows service developers to control how data is structured in azure queues, enabling the streaming of azure queue events of legacy systems or systems integrated with other non-orleans services.

This change addresses "Revisit azure queue serialization. #2456"</Description>
        <CreatedDate>26/01/2017</CreatedDate>
        <ClosedDate>30/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2654</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Reduce use of statics. Prep for non-static SerializationManager</Title>
    <Description>Simple changes which were extracted from #2592.

The changes are very basic. Some of the changes only make sense if you evaluate them with the understanding that they are in preparation for making SerializationManager non-static, so keep that in mind.

Most of the changes are simply passing fixtures into test classes.</Description>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>06/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2654</PullRequestID>
        <IssueID>2592</IssueID>
        <Title>Non-static SerializationManager</Title>
        <Description>Disclaimer: this is a work in progress. It needs work, more functional testing, and to be split into smaller, more mergable PRs. `SerialziationManager` is a core part of our system and `GrainReference` is serializable, so this PR is necessarily going to be large

Implements changes from #2591 &amp; [#467](https://github.com/dotnet/orleans/issues/467#issuecomment-255074892) (with changes).

When using an external serializer (eg, JSON.NET, ProtoBuf), `GrainReference` instances must be bound via a call to `IGrainFactory.Bind(IAddressable)` before they can be used. When using the Orleans serialization framework, this happens automatically.

Once this is ready, we will be close to completing #467. Only some minor additional work is required to complete the task, basically changing the GrainClient class itself.

Note: this is a breaking change.

EDIT: to be clear, I don't expect this code to be reviewed in detail while I've got the work-in-progress tag on it. When it's ready, I'll remove the tag and update this PR.</Description>
        <CreatedDate>13/01/2017</CreatedDate>
        <ClosedDate>24/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2651</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sebastianburckhardt</FixedByID>
    <Title>improve JournaledGrain API, add better tests/examples</Title>
    <Description>Based on discussion in #2598.

Added `RetrieveConfirmedEvents` method to JournaledGrain, which can read a desired segment of the event log.

Added many more tests/examples as the first step to better documentation. These demonstrate a diverse collection of scenarios, including several configuration options. 

They are located in folders:
- Tester.EventSourcing
- TestGrains.EventSourcing 
- TestGrainInterfaces.EventSourcing
</Description>
    <CreatedDate>28/01/2017</CreatedDate>
    <ClosedDate>03/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2651</PullRequestID>
        <IssueID>2598</IssueID>
        <Title>Provide docs for Log Consistency Providers and split test</Title>
        <Description>First of all, thank you @sebastianburckhardt for the great work!

After #1854 got merged I tried play with it but was unable to get it to work. I was unable to find among the tons of tests what are the files related to `OrleansEventSourcing` project. The configuration and requirements is what is hardest to find.

I would suggest a simple page with the minimum required configuration to get it to work. 

Also, would be good if that project has its own test project. I can do it myself if you point out what exactly is related to this project inside the test projects.

Thank you Sebastian! :)</Description>
        <CreatedDate>16/01/2017</CreatedDate>
        <ClosedDate>10/02/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2648</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>serbrech</FixedByID>
    <Title>Bump fsharp sample to 1.3.1</Title>
    <Description>Part of #2359 </Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2648</PullRequestID>
        <IssueID>2359</IssueID>
        <Title>Migrate samples to 2.1</Title>
        <Description>The samples (https://github.com/dotnet/orleans/tree/master/Samples) are on 1.2.3 now. Shouldn't be to difficult to migrate them to 1.3.0.
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2645</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve reliability of TimerOrleansTest_Migration test</Title>
    <Description>This test has been unreliable, causing failures in many CI passes.

The crux of the issue is that the test grain starts a timer which fires its first tick immediately (confirmed by in testing).

The asserts which were removed don't really make sense to have in the first place, in my opinion. They're flaky because of how time-sensitive they are.

Fixes #2625</Description>
    <CreatedDate>27/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2645</PullRequestID>
        <IssueID>2625</IssueID>
        <Title>Make TimerOrleansTest_Migration reliable</Title>
        <Description>The `DefaultCluster.Tests.TimerTests.TimerOrleansTest.TimerOrleansTest_Migration` test is unreliable and it's making our builds unreliable, which is frustrating and a bad look.

We should never have to ask @dotnet-bot to re-test something</Description>
        <CreatedDate>23/01/2017</CreatedDate>
        <ClosedDate>27/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2643</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Added a data adapter to azure queue stream provider</Title>
    <Description>The data adapter allows users to use the new v2 versions of sequence token and batch container without risking changes to the original versions, which are being used in production services.
The adapter also allows service developers to control how data is structured in azure queues, enabling the streaming of azure queue events of legacy systems or systems integrated with other non-orleans services.

This change addresses "Revisit azure queue serialization. #2456"</Description>
    <CreatedDate>26/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2643</PullRequestID>
        <IssueID>2456</IssueID>
        <Title>Revisit azure queue serialization.</Title>
        <Description>To support external serializers (specifically json) we merged PRs “Modified stream types to not use fallback serializer and allow external #2330“ and “Azure queue stream provider silo to silo serialization bug fix. #2447”.

While these changes are diligent about verifying that default serialization continues to work to ensure backwards compatibility, the complexity introduced by having two versions of the types that can intermix is significant.  These changes may be perfectly safe, but reasoning about them for confidence in their current state and maintaining them in the future is non-trivial.
There is also a question as to whether the backwards compatibility pattern necessitates the upgrade of services reading from the queue prior to upgrading services writing to the queue.

I am sufficiently concerned about the above to request a reconsideration of this pattern.
In some other stream providers (MemoryStreamProvider, EventHubStreamProvider) we support application layer overrides of the serialization to allow developers to adapt the stream provider to their own data formats.  I am of the opinion that it is safer to introduce a similar solution to the Azure queue stream provider, with the default being the original data formatting, then introduce an alternative serializer that supports the custom serialization needs intended by the pull requests mentioned above.  This would strongly protect existing consumers using the azure queue stream provider, allow new consumers to opt into using the external serializer, and enable application developers to introduce their own application specific solutions as needed.

Tagging: @Carlm-MS, @gabikliot</Description>
        <CreatedDate>29/11/2016</CreatedDate>
        <ClosedDate>02/02/2017</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>external</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2638</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>serbrech</FixedByID>
    <Title>Update Chirper Sample project to Orleans 1.3.1</Title>
    <Description>As part of resolving #2634 
Also removed unecessary Assembly bindings that were there from earlier</Description>
    <CreatedDate>26/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2638</PullRequestID>
        <IssueID>2634</IssueID>
        <Title>Updating Adventure Sample to Orleans 1.3.1</Title>
        <Description>This is the first PR to resolve #2359 

Bumping System.Collections.Immutable to 1.1.37 seems to pull all the System.* dependencies listed under DotNet5.0 (see [System.Collection,Immutable 1.1.3.7](https://www.nuget.org/packages/System.Collections.Immutable/1.1.37))  
These are already available in the target framework, so I removed them manually from packages.config since they are unecessary.   
Any update would pull them again though.</Description>
        <CreatedDate>25/01/2017</CreatedDate>
        <ClosedDate>26/01/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2637</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>galvesribeiro</FixedByID>
    <Title>EventHubs Stream provider ported to netstandard</Title>
    <Description>As part of #2145 this PR add EventHub stream provider support to vNext solution supporting `netstandard1.5`.

The new `netstandard1.5` project rely on the new nugets [Microsoft.Azure.EventHubs](https://www.nuget.org/packages/Microsoft.Azure.EventHubs/0.0.4-preview) and [Microsoft.Azure.EventHubs.Processor](https://www.nuget.org/packages/Microsoft.Azure.EventHubs.Processor/0.0.4-preview) which will deprecate the old ones once they are released. There were namespace changes and a bit of API changes on those nugets and they were addressed with some `#if`s among other small changes. 

For now those nugets were only used at vNext and should only be updated on master when we merge the solutions.

cc: @jason-bragg </Description>
    <CreatedDate>26/01/2017</CreatedDate>
    <ClosedDate>10/02/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2637</PullRequestID>
        <IssueID>2145</IssueID>
        <Title>[CRAWL Phase] .Net Core Compatibility</Title>
        <Description>_This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by having it target [.Net Standard](https://docs.microsoft.com/en-us/dotnet/articles/standard/library) and have the minimal impact as possible in the current codebase. 

Since .Net Core tooling still unreliable and will (drastically) change before it reach RTM, we are following the guidelines from [here](https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild)  and in a new temporary solution we will work at `master` branch.

The target is to have Orleans building and running on .Net Full CLR and .Net Core (hence why target .Net Standard) on Windows and have the full test set only for the .Net Full CLR (.Net 4.6.1+) while having basic validation on .Net Core on Windows. 

We will focus on Windows as a baseline but that doesn't mean people can't run tests on Linux/OSX once this work is done. That means that the core test set will focus on .Net Full CLR and basic .Net Core on Windows but you can test your Orleans application on .Net Core supported OSes. The test framework should stay as is. That means the major efforts will not be to update the test kit to multiple OSes and full .Net Core coverage but, if you feel comfortable, we still accept (and really encourage and appreciate!) PRs however, it will take lower priority (and of course efforts on review) from the core team and people from the community working on this port.

Here are the macro tasks and its issues that will be tracked for this phase:
- [x] Add new solution targeting .Net Standard Library 1.5 (`netstandard15`) - #2177 
- [x] Build Orleans.vNext.sln in the CI Build.cmd script - #2353 #2362
- [x] Replace Binary Serializer - #2162
- [x] Move Performance Counters to its own TelemetryConsumer - #2122 
- [x] Use supported overloads from Socket class - #2195 
- [x] Remove usage of named mutexes #2366
- [x] Remove AppDomain usage for assembly loading/scanning - #2025 and in continued progress by @attilah 
- [x] Run non-silo tests (not blocked by Silo not working in memory) - in progress by @xiazen
- [x] Avoid Silo being MarshalByRefObject but support running tests - #2196 
- [x] Avoid test hooks being MarshalByRefObject (a few still pending) - #2333
- [x] Avoid usages of CallContext - #2197 
- [x] Run all silo tests that do not use extensibility features (such as external storage providers)
- [x] Add storage providers with tests (all implementations that support .net standard out of the box) - #2615
- [x] Add stream providers with tests (all implementations that support .net standard out of the box) - #2615 and #2637
- [x] Extract client implementation from main Orleans.dll (with should have the minimal abstractions)
- [x] Migrate off the MSBuild hack for building .NET Standard once new tooling is available
- [x] Support codegen in the final tooling
- [x] Remove all `NETSTANDARD_TODO` comments by implementing workarounds
- [x] Clean up: Remove all `NETSTANDARD` comments by moving platform specific components to platform specific DLLs
- [x] Design our desired 2.0 nuget package structure (IDs and contents)
- [x] Restructure vNext projects to recreate our expected 2.0 nuget packages output structure
- [x] Full test set passing on .Net Framework 4.6.2 (`net462`)
- [x] Basic validation tests on .Net Core 1.0 (`netcoreapp10`)

**Note**: This list will be updated as new sub-tasks (issues and/or PRs) will emerge from this work.

  </Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2634</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>serbrech</FixedByID>
    <Title>Updating Adventure Sample to Orleans 1.3.1</Title>
    <Description>This is the first PR to resolve #2359 

Bumping System.Collections.Immutable to 1.1.37 seems to pull all the System.* dependencies listed under DotNet5.0 (see [System.Collection,Immutable 1.1.3.7](https://www.nuget.org/packages/System.Collections.Immutable/1.1.37))  
These are already available in the target framework, so I removed them manually from packages.config since they are unecessary.   
Any update would pull them again though.</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2634</PullRequestID>
        <IssueID>2359</IssueID>
        <Title>Migrate samples to 2.1</Title>
        <Description>The samples (https://github.com/dotnet/orleans/tree/master/Samples) are on 1.2.3 now. Shouldn't be to difficult to migrate them to 1.3.0.
</Description>
        <CreatedDate>28/10/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>Hacktoberfest</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2633</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Failsafe Exception serialization (#2310)</Title>
    <Description>This is an implementation of failsafe Exception serialization.

Features:
* Serializes Exceptions so that they can be deserialized even if the original exception type is not available.
* A fallback type, `RemoteNonDeserializableException`, is used in place of the original exception type when the original is not available. In this case, the message and stack trace are preserved, but any additional fields on sub-classes of `Exception` cannot be inspected.
* Exceptions are round-tripped without any loss of fidelity, regardless of whether or not one of the parties does not have access to the original exception type.

Caveats:
* Currently it does not support referential transparency for the exception itself.
* This is an extension to `ILBasedSerializer` and therefore will only be enabled if that is the configured `FallbackSerializationProvider`. This it the default on .NET Core, but not Full .NET.

Let me know if I missed something.

xref #2528</Description>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2633</PullRequestID>
        <IssueID>2528</IssueID>
        <Title>Unable to serialize new .NET package exceptions</Title>
        <Description>Packages I depend on have begun migrating to what I think is "netstandard"? In any case, they now require tiny little micro-packages for each .NET namespace. This would be merely annoying, except the latest versions of these namespace level packages contain types which are no longer `[Serializable]`.

It appears that many exceptions Orleans used to successfully relay from grains to my client applications can no longer be serialized out of the box, and it's not clear how I should add support for serializing them.

Here's a test project demonstrating my problem, and two now unserializable exception types that have been appearing in my logs: https://github.com/realartists/orleans-serialization-failure

I've tried `KnownType`, `KnownAssembly`, and `GenerateSerializer` attributes without success. `KnownType` and `KnownAssembly` silently fail to generate a serializer, only failing at runtime, and `GenerateSerializer` fails during build.

I tried adding a custom serializer for `Exception`, but it's never called for derived types, even as a fallback.

I must be missing something obvious.

I'm using the 1.3.1 nuget package. The specific exceptions I'm seeing are both `Orleans.Runtime.OrleansException`:

_No copier found for object of type System.Net.Http.HttpRequestException. Perhaps you need to mark it [Serializable] or define a custom serializer for it?_
``

</Description>
        <CreatedDate>17/12/2016</CreatedDate>
        <ClosedDate>18/12/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2632</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Update Serialization.md</Title>
    <Description>Improve serialization docs. Fixes #2512.</Description>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>25/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2632</PullRequestID>
        <IssueID>2512</IssueID>
        <Title>Add documentation for IExternalSerializer / &lt;SerializationProviders&gt;</Title>
        <Description>Currently, the [serialization documentation](http://dotnet.github.io/orleans/Documentation/Advanced-Concepts/Serialization.html) does not mention the support for external serializers such as Bond, ProtoBuf, or custom implementations of `IExternalSerializer`.

Ideally, it would:
* Add a section on configuring serialization providers
* Include links to the Bond &amp; ProtoBuf NuGet packages
* Demonstrate configuration via programmatic interface or XML
* Briefly cover the `IExternalSerializer` interface

Programmatic config looks like this:
``</Description>
        <CreatedDate>13/12/2016</CreatedDate>
        <ClosedDate>25/01/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
          <Label>help wanted</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2631</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>attilah</FixedByID>
    <Title>Enhance ServiceRuntime handling, Fix #2491.</Title>
    <Description>- Modify AzureUtils classes to leverage CloudConfigurationManager instead of depending RoleEnvironment.
- Add additional GAC loading method for ServiceRuntime in netfx (took from Azure SDK).
- Fix #2491, AzureClient.DefaultConfiguration works outside of Azure Cloud Service environment and fallback to AppSettings if no ServiceRuntime available.</Description>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>25/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2631</PullRequestID>
        <IssueID>2491</IssueID>
        <Title>Trying to deploy Orleans project - Local and on Azure throws runtime error-Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironmentException: error</Title>
        <Description>Am using the Azure emulator and the Orleans host runs fine. 
This piece of code below in my MVC - global.asax.cs is throwing an error at AzureClient.DefaultConfiguration()...

I tried deploying into Azure too, got the same error.
Has anyone faced this issue and been able to solve it? Don't know what I am missing.
----------------------------------------------------------------------------------

if (RoleEnvironment.IsAvailable)
{
      //azure
      var config = AzureClient.DefaultConfiguration();
      AzureClient.Initialize(config);
      //AzureClient.Initialize();
 }
 else
 {
      //Local deployment
       GrainClient.Initialize(
             Server.MapPath(
             @"~/OrleansClientConfiguration.xml"));
  }

ERROR:
		
Description: An unhandled exception occurred during the execution of the current web request. Please review the stack trace for more information about the error and where it originated in the code. 

Exception Details: Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironmentException: error

Source Error: 

An unhandled exception was generated during the execution of the current web request. Information regarding the origin and location of the exception can be identified using the exception stack trace below.

Stack Trace: 


[RoleEnvironmentException: error]
   Microsoft.WindowsAzure.ServiceRuntime.RoleEnvironment.GetConfigurationSettingValue(String configurationSettingName) +341

[TargetInvocationException: Exception has been thrown by the target of an invocation.]
   AzureWebAppTestRole.MvcApplication.Application_Start() in F:\Projects\Azure\TestDeplyProjects\BST\BST_Test3\AzureTestWebApp\AzureTestWebApp\AzureWebAppTestRole\Global.asax.cs:67

[HttpException (0x80004005): Exception has been thrown by the target of an invocation.]
   System.Web.HttpApplicationFactory.EnsureAppStartCalledForIntegratedMode(HttpContext context, HttpApplication app) +588
   System.Web.HttpApplication.RegisterEventSubscriptionsWithIIS(IntPtr appContext, HttpContext context, MethodInfo[] handlers) +181
   System.Web.HttpApplication.InitSpecial(HttpApplicationState state, MethodInfo[] handlers, IntPtr appContext, HttpContext context) +322
   System.Web.HttpApplicationFactory.GetSpecialApplicationInstance(IntPtr appContext, HttpContext context) +402
   System.Web.Hosting.PipelineRuntime.InitializeApplication(IntPtr appContext) +452

[HttpException (0x80004005): Exception has been thrown by the target of an invocation.]
   System.Web.HttpRuntime.FirstRequestInit(HttpContext context) +646
   System.Web.HttpRuntime.EnsureFirstRequestInit(HttpContext context) +159
   System.Web.HttpRuntime.ProcessRequestNotificationPrivate(IIS7WorkerRequest wr, HttpContext context) +778</Description>
        <CreatedDate>07/12/2016</CreatedDate>
        <ClosedDate>25/01/2017</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2630</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Azure table storage throws InconsistentStateException</Title>
    <Description>Azure table storage throws InconsistentStateException upon a write conflict.

See issue "Storage providers have to throw an InconsistentStateException upon a write conflict #1609"</Description>
    <CreatedDate>23/01/2017</CreatedDate>
    <ClosedDate>24/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2630</PullRequestID>
        <IssueID>1609</IssueID>
        <Title>Storage providers have to throw an InconsistentStateException upon a write conflict</Title>
        <Description>A grain's `WriteStateAsync`leads to `GrainStateStorageBridge.WriteStateAsync` which reports any failure as `OrleansException`, when state conflicts should be reported as InconsistentStateException, according to [documentation](http://dotnet.github.io/orleans/Getting-Started-With-Orleans/Grain-Persistence). Additionally, the `AzureTableStorage` doesn't throw `InconsistentStateException` on state conflicts, since it delegates to `GrainStateTableDataManager.Write` which doesn't throw that exception. This looks like a bug in the code, not in the documentation. Do you think it should be fixed, or keep it like that since existing applications may already rely on the exceptions thrown today?
</Description>
        <CreatedDate>24/03/2016</CreatedDate>
        <ClosedDate>09/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2628</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>benjaminpetit</FixedByID>
    <Title>Client cluster disconnection</Title>
    <Description>Fix for "Access to grain client connection status" #2551 

Now `ProxiedMessageCenter` keeps a counter of opened gateway connection. When this counter reach 0, we send an event to the client to notify that the client might have been disconnected from the cluster.

I think we still can have race condition like this:
- Client connected to GW1 (counter set to 1)
- GW1 connection lost (but no update to the counter yet)
- GW2 connection established (but no update to the counter yet)
- GW2 updates the opened connection counter (counter set to 2)
- GW1 updates the opened connection counter (counter set to 1)

But the windows seems small enough for me, so this fix seems still useful for now
</Description>
    <CreatedDate>23/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2628</PullRequestID>
        <IssueID>2551</IssueID>
        <Title>Access to grain client connection status</Title>
        <Description>&gt; If a client loses connection to the cluster, all of the existing producers and consumers on that client will be removed from the pubsub system, even if the client does not unsubscribe. @jason-bragg 

For this reason we need to know client connection status, some kind of a signal/event on connection change (i.e. is lost, reestablished, ..) so that client can resubscribe to the stream.

There was also short conversation on this topic on [gitter](https://gitter.im/dotnet/orleans?at=5858397bc895451b75f77b42).</Description>
        <CreatedDate>28/12/2016</CreatedDate>
        <ClosedDate>02/02/2017</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2615</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>galvesribeiro</FixedByID>
    <Title>Adding missing Orleans Extensions to .Net Core</Title>
    <Description>As part of #2145, this PR add the remaining projects that OOB support `netstandard` to the vNext solution. 

- [x] ConsulUtils (Tests are disabled on vNext solution due to [an issue with HttpClient on net46 that will be fixed on next `netstandard` release](https://github.com/dotnet/corefx/issues/11100)) - Yay! Now we have tests for Consul :)
- [x] AWSUtils (Some tests are disabled on vNext solution and will be enabled on another PR to avoid big review)
- [x] GoogleUtils
- [x] ~~PSUtils~~ (This will be addressed in a separated PR since it requires many code changes to use new PS SDK)
- [x] TelemetryConsumers.AI
- [x] BondUtils

This PR aims on not change any code on those project except those that require minor changes to support `netstandard`. Otherwise, a new PR will be created just for it. Consul is an exception to this rule because a 2 minor changes where made to the current core because while running the tests, 2 small bugs were found.

Each item goes on its own commit to easy review.
</Description>
    <CreatedDate>19/01/2017</CreatedDate>
    <ClosedDate>24/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2615</PullRequestID>
        <IssueID>2145</IssueID>
        <Title>[CRAWL Phase] .Net Core Compatibility</Title>
        <Description>_This issue will track the **CRAWL** phase of Orleans 2.X milestone as tracked by #2143_

The idea with this task is to basically make Orleans Core compatible with [.Net Core](https://github.com/dotnet/coreclr), by having it target [.Net Standard](https://docs.microsoft.com/en-us/dotnet/articles/standard/library) and have the minimal impact as possible in the current codebase. 

Since .Net Core tooling still unreliable and will (drastically) change before it reach RTM, we are following the guidelines from [here](https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild)  and in a new temporary solution we will work at `master` branch.

The target is to have Orleans building and running on .Net Full CLR and .Net Core (hence why target .Net Standard) on Windows and have the full test set only for the .Net Full CLR (.Net 4.6.1+) while having basic validation on .Net Core on Windows. 

We will focus on Windows as a baseline but that doesn't mean people can't run tests on Linux/OSX once this work is done. That means that the core test set will focus on .Net Full CLR and basic .Net Core on Windows but you can test your Orleans application on .Net Core supported OSes. The test framework should stay as is. That means the major efforts will not be to update the test kit to multiple OSes and full .Net Core coverage but, if you feel comfortable, we still accept (and really encourage and appreciate!) PRs however, it will take lower priority (and of course efforts on review) from the core team and people from the community working on this port.

Here are the macro tasks and its issues that will be tracked for this phase:
- [x] Add new solution targeting .Net Standard Library 1.5 (`netstandard15`) - #2177 
- [x] Build Orleans.vNext.sln in the CI Build.cmd script - #2353 #2362
- [x] Replace Binary Serializer - #2162
- [x] Move Performance Counters to its own TelemetryConsumer - #2122 
- [x] Use supported overloads from Socket class - #2195 
- [x] Remove usage of named mutexes #2366
- [x] Remove AppDomain usage for assembly loading/scanning - #2025 and in continued progress by @attilah 
- [x] Run non-silo tests (not blocked by Silo not working in memory) - in progress by @xiazen
- [x] Avoid Silo being MarshalByRefObject but support running tests - #2196 
- [x] Avoid test hooks being MarshalByRefObject (a few still pending) - #2333
- [x] Avoid usages of CallContext - #2197 
- [x] Run all silo tests that do not use extensibility features (such as external storage providers)
- [x] Add storage providers with tests (all implementations that support .net standard out of the box) - #2615
- [x] Add stream providers with tests (all implementations that support .net standard out of the box) - #2615 and #2637
- [x] Extract client implementation from main Orleans.dll (with should have the minimal abstractions)
- [x] Migrate off the MSBuild hack for building .NET Standard once new tooling is available
- [x] Support codegen in the final tooling
- [x] Remove all `NETSTANDARD_TODO` comments by implementing workarounds
- [x] Clean up: Remove all `NETSTANDARD` comments by moving platform specific components to platform specific DLLs
- [x] Design our desired 2.0 nuget package structure (IDs and contents)
- [x] Restructure vNext projects to recreate our expected 2.0 nuget packages output structure
- [x] Full test set passing on .Net Framework 4.6.2 (`net462`)
- [x] Basic validation tests on .Net Core 1.0 (`netcoreapp10`)

**Note**: This list will be updated as new sub-tasks (issues and/or PRs) will emerge from this work.

  </Description>
        <CreatedDate>12/09/2016</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>2612</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Harden persistent stream provider pulling agent.</Title>
    <Description>-Reduced duplicate logging during errors.
-Fixed null reference exception that occur durring shutdown.

Addresses "EventHubStreamProviders exceptions #2477"</Description>
    <CreatedDate>19/01/2017</CreatedDate>
    <ClosedDate>27/01/2017</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>2612</PullRequestID>
        <IssueID>2477</IssueID>
        <Title>EventHubStreamProviders exceptions</Title>
        <Description>Running into these exceptions in some production services using the EventHubStreamProvider.  These exceptions seem to only occur when pulling agents are being shutdown, so they are transient and have no application impact, but should still be addressed.

System.NullReferenceException: Object reference not set to an instance of an object.
   at Orleans.ServiceBus.Providers.EventHubAdapterReceiver.&lt;GetQueueMessagesAsync&gt;d__19.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter`1.GetResult()
   at Orleans.Streams.PersistentStreamPullingAgent.&lt;ReadFromQueue&gt;d__35.MoveNext()


UnobservedExceptionsHandlerClass Caught an UnobservedTaskException event sent by [Id=3202, Status=Faulted]. Exception = 
Exc level 0: System.AggregateException: A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.
Exc level 1: Orleans.Runtime.OrleansException: SystemTarget PullingAgentSystemTarget/FF/f0f62a85 not active on this silo. Msg=Response S100.117.42.37:11111:218312555*grn/47A87F83/40f3ae87@f124a5a1-&gt;S100.117.42.37:11111:218312555PullingAgentSystemTarget/FF/f0f62a85@Sf0f62a85 #5336990: global::Orleans.Streams.IStreamConsumerExtension:GetSequenceToken()
</Description>
        <CreatedDate>03/12/2016</CreatedDate>
        <ClosedDate>16/02/2017</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1927</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>update ZooKeeperNetEx to 3.4.8.5</Title>
    <Description>- Support .NET Standard 1.3
- Fixed a bug found in #1917 
</Description>
    <CreatedDate>09/07/2016</CreatedDate>
    <ClosedDate>09/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1927</PullRequestID>
        <IssueID>1917</IssueID>
        <Title>Losing connection to Zookeeper intermittently</Title>
        <Description>I have a strange issue with Zookeeper membership provider. We have different production deployments on different servers for different clients, but the issue is all the same. At some point in time (here the trouble starts at 19:31 GMT when exceptions are caught) silos start logging the following:

``

Any idea what is going on here?
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>13/07/2016</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1920</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Maarten88</FixedByID>
    <Title>[WIP] Fix storage for generic grains in a way that is backward-compatible for normal grains</Title>
    <Description>This change is in response to a question in #1915 from @jdom 

For generic grains (which have a long partition key) this sets the rowkey to String.Empty so that ClearStateAsync works. Only ClearState was affected, it seems ReadState and WriteState worked with the long key.

I'm not sure about this one myself: it fixes the problem but I'm not sure I understand the Azure table storage behavior w.r.t how it deals with long keys containing special characters. A better fix would be to change the internal handling of generic arguments by removing the qualified assembly name, making it much shorter. Yet another option would be to change grainReference.ToKeyString() to return a shorter key for generic grains.

This change changes the storage key values for generic grains with previous versions. Normal grains should be unaffected.
</Description>
    <CreatedDate>08/07/2016</CreatedDate>
    <ClosedDate>23/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1920</PullRequestID>
        <IssueID>1915</IssueID>
        <Title>Add coverage for generic state parameter using Azure Storage (after #1897)</Title>
        <Description>While I was doing this minor cleanup, I encountered that this is still failing on the call to ClearState.
@Maarten88 do you know if this is still related to the grain type name or is this a new bug?

Both tests (with long and short name) are now failing, these are the details:

``
</Description>
        <CreatedDate>08/07/2016</CreatedDate>
        <ClosedDate>22/03/2017</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1916</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>WIP: Ad-hoc observables for grains (#940)</Title>
    <Description>Work-in-progress of ad-hoc observables for grains, as described in #940.
## Edit:

The API is now aligned with existing Virtual Streams, so grains can directly return `IAsyncObservable&lt;T&gt;` instead of the custom `IGrainObserver&lt;T&gt;` type I originally had here. This means that `ResumeAsync` works. Discussed more in [this comment](https://github.com/dotnet/orleans/pull/1916#issuecomment-232331824) below.
## Original:

This allows users to define grain interfaces like so:

``` C#
public interface IReactiveGrain&lt;T&gt; : IGrainWithGuidKey
{
    IGrainObservable&lt;T&gt; GetStream(T[] values);
}
```

``` C#
public class ReactiveGrain&lt;T&gt; : Grain, IReactiveGrain&lt;T&gt;
{
    public IGrainObservable&lt;T&gt; GetStream(T[] values)
    {
        return Observable.Create&lt;T&gt;(async observer =&gt;
        {
            if (values == null) throw new ArgumentNullException(nameof(values));
            try
            {
                foreach (var value in values) await observer.OnNext(value);
                await observer.OnCompleted();
            }
            catch (Exception exception)
            {
                await observer.OnError(exception);
            }

            return new AsyncDisposable();
        });
    }
}
```

More advanced usage could use filter values or expression trees as parameters.

There are obvious deficiencies, some of which are called out in the code. For example, observables should error or be disposed when the remote side dies (depending on which side dies). ~~Additionally, this only works for `int` at the moment. It's an easy fix with a bit of IL.~~ Please raise any concerns you have.

This is definitely not a replacement for Virtual Streams, this is a complimentary feature.

The remote grain is only called when the returned observable is subscribed to, it is called every time `Subscribe` is called. The observable captures the arguments at the time of creation so that it can subscribe and resubscribe as needed.

Let me know what you think - all criticism is welcome.
</Description>
    <CreatedDate>08/07/2016</CreatedDate>
    <ClosedDate>03/10/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1916</PullRequestID>
        <IssueID>940</IssueID>
        <Title>Support returning IAsyncObservable&lt;T&gt; from Grain methods</Title>
        <Description>This is a feature request. I may implement it, but I am looking for input before I make an attempt.

Currently, Grains can return `Task` &amp; `Task&lt;T&gt;` to consumers. This represents the asynchronous nature of distributed systems programming well and encapsulates the possibility of failure. `Task&lt;T&gt;` is restricted to returning only a single value, though.

Ideally, Grains should be able to return `IObservable&lt;T&gt;` or `IAsyncObservable&lt;T&gt;` (depending on whether or not back-pressure/ack is required) in addition to `Task` &amp; `Task&lt;T&gt;`.

This differs from the Virtual Streams offered by Orleans in a few ways:
1. Observables are temporary (like tasks), Streams are eternal (like grains)
2. Observables are 1:1 by default, Streams may be many:many
3. Observables can take parameters, Streams are identified by `(type, key)`.

Semantics:
-  Observable methods are invoked on `SubscribeAsync`, not when the client obtains the `IAsyncObservable&lt;T&gt;`.
- Silo failures are propagated to observers through `OnErrorAsync`. Clients can at that point re-`SubscribeAsync`, at which point the grain method is invoked again.

Any obvious issues which aren't covered here?

Input is be greatly appreciated :)
</Description>
        <CreatedDate>26/10/2015</CreatedDate>
        <ClosedDate>17/04/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>help wanted</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1914</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Refactor ConsiderType to make parameters clearer</Title>
    <Description>See discussion in #1888. Minor cleanup for clarity
cc @jdom
</Description>
    <CreatedDate>08/07/2016</CreatedDate>
    <ClosedDate>10/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1914</PullRequestID>
        <IssueID>1888</IssueID>
        <Title>Improve codegen attributes KnownType, GenerateSerializer, KnownAssembly</Title>
        <Description>This introduces the following changes, as discussed with @sergeybykov, @jdom, and @galvesribeiro.
- `[KnownType]` generates serializers for that type as if the type had `[Serializable]`
- `[GenerateSerializer]` is the same as `[KnownType]`, except that it throws if serializers wont be generated
- `[KnownAssembly]` has a property, `TreatTypesAsSerializable` to generate serializers for all types, equivalent to specifying `[KnownType]` for all types.
</Description>
        <CreatedDate>30/06/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1901</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jdom</FixedByID>
    <Title>Do not require explicitly registering grains in ServiceCollection</Title>
    <Description>This is similar to MVC, where the framework is in charge of determining which concrete controller to resolve, and the user is not required to explicitly register the controller, only the dependencies used by the controller.
Grains in Orleans behave in a very similar way where as you can't explicitly register the mapping grain interface -&gt; grain implementation in the container, and instead Orleans determines which concrete Grain implementation to instantiate. The user should not be responsible for registering all the grain implementations that were also already discovered by Orleans. This is boilerplate and non-intuitive (as you were forced to register the concrete type, not the mapping with the interface, which is not common when using DI and especially when you are implementing an interface for consumer to use).

This supersedes #1841, as there is no "fallback" if the registration isn't there, it is instead how it is supposed to work.

EDIT: I made it exactly like MVC's implementation, so that GrainCreator will not even consider explicit registrations for grains (or controllers in the MVC case).

Classes in MVC that are relevant to controller activation:
- [DefaultControllerActivator](https://github.com/aspnet/Mvc/blob/master/src/Microsoft.AspNetCore.Mvc.Core/Controllers/DefaultControllerActivator.cs)
- [TypeActivatorCache](https://github.com/aspnet/Mvc/blob/master/src/Microsoft.AspNetCore.Mvc.Core/Internal/TypeActivatorCache.cs)
- [ActivatorUtilities](https://github.com/aspnet/Common/blob/dev/src/Microsoft.Extensions.ActivatorUtilities.Sources/ActivatorUtilities.cs) and its [façade](https://github.com/aspnet/DependencyInjection/blob/master/src/Microsoft.Extensions.DependencyInjection.Abstractions/ActivatorUtilities.cs)
</Description>
    <CreatedDate>04/07/2016</CreatedDate>
    <ClosedDate>06/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1901</PullRequestID>
        <IssueID>1841</IssueID>
        <Title>GrainCreator fallback on Activator.CreateInstance</Title>
        <Description>With DI set up, all grains are created via `Silo.Services`. This works nicely when wired up to StructureMap, which happily injects into any ad hoc types you request from it - and probably does for many other containers also. 

But there's a bit of an issue if you go for the default option of directly using the `IServiceCollection` passed to your `Startup` class: it requires all candidates for injection to be explicitly registered, and so all requests for Grains from the runtime will return null (and throw obscure exceptions) unless each potential grain type has been manually registered with the container. This manual registration is obviously a drag.

Should `GrainCreator` just fallback on its original behaviour if the DI container can't help it out?
</Description>
        <CreatedDate>14/06/2016</CreatedDate>
        <ClosedDate>04/07/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1897</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>Maarten88</FixedByID>
    <Title>Fix bug with generic state parameter caused by inconsistent use of grainClassName / genericArgument / genericInterface</Title>
    <Description>After lots of debugging on an issue I have with a generic grain that uses storage, I think that this change fixes the issue. The genericArgument was used inconsistently, and sometimes contained the genericInterface value. Also the grainClass parameter did not include the genericArguments during setup of the state, causing the grainType parameter in the first ReadStateAsync to be incorrect.

I moved the location where the conversion was made from SetupActivationInstance() into catalog.GetOrCreateActivation(), passed genericArguments in some functions and fixed the naming.

I think this fixes several bugs, including #1579.

Please test thoroughly, this "works on my machine" but the change might do things that I don't really understand and this is my first pull request on orleans.
</Description>
    <CreatedDate>02/07/2016</CreatedDate>
    <ClosedDate>07/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1897</PullRequestID>
        <IssueID>1579</IssueID>
        <Title>Incomplete grainType when activating generic grains</Title>
        <Description>Hello,

It seems that generic grains can never have their state loaded properly on activation, as the various `PlacementDirectors` that produce the `grainType` string to be used in retrieving the grain from storage are all without generic type information for the grain in question, and therefore produce `grainTypes` with generic args missing.

This contrasts with explicitly calling `ReadStateAsync()` and `WriteStateAsync()` from the grain itself, which, via `GrainStateStorageBridge`, produces a fully-specified `grainType` each time.

The upshot is, state is written to one storage key, but loaded from another in the case of activation.

There's a simple enough workaround in calling `ReadStateAsync()` from each generic grain's `OnActivateAsync()` - but this isn't fantastic, obviously.

Does this sound right?
</Description>
        <CreatedDate>18/03/2016</CreatedDate>
        <ClosedDate>07/07/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1894</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jdom</FixedByID>
    <Title>Fix several incorrect usages of Type and TypeInfo</Title>
    <Description>In preparation for the CoreCLR port #368
</Description>
    <CreatedDate>02/07/2016</CreatedDate>
    <ClosedDate>03/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1894</PullRequestID>
        <IssueID>368</IssueID>
        <Title>Contribution idea: Port Orleans to coreclr</Title>
        <Description>Port the Orleans code to run on [coreclr](https://github.com/dotnet/coreclr).
Some APIs from the full .NET got deprecated in coreclr (aka .NET Core), mainly around files and reflection, but at large the porting effort shouldn't be too big. This will allow to run Orleans efficiently across different platforms.

---

**Tools:**
[Coreclr api search](https://packagesearch.azurewebsites.net/)
[.NET API Usage](http://dotnetstatus.azurewebsites.net/usage)
[.NET Portability Analyzer](https://visualstudiogallery.msdn.microsoft.com/1177943e-cfb7-4822-a8a6-e56c7905292b) - download and Install
[.NET Portability Analyzer Usage](http://blogs.msdn.com/b/dotnet/archive/2014/08/06/leveraging-existing-code-across-net-platforms.aspx)

**Progress so far**: 
[CoreCLR milestones](https://github.com/dotnet/orleans/issues?utf8=%E2%9C%93&amp;q=milestone%3ACoreCLR)
~~[ApiPortabilityAnalysis result file for all projects](https://github.com/dotnet/orleans/blob/master/misc/ApiPortabilityAnalysis-AllProjects-October.08.2015.htm)~~ (let's find an appropriate place to place updates of this file, please don't pollute the master branch with these big reports)

---

There are 2 types of issues: 
(a) easy, just change an API - we have done all those.
(b) deeper profound issues where API was deprecated or changed significantly and we will need to investigate other ways to achieve the same functionality:

**Need to investigate and consider profound rewrite** - feel to open a GH issue with ideas on how to handle each one of those issues (separate issue for each) : 
High priority
- [ ] Create a v2 branch that changes target for Orleans to .NET Standard 1.6
  - Ideally still use csproj as in https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild (this means that we'll have to update from .NET 4.5.1 in all dependent projects)
- [ ] Remove usage of App Domains for scanning https://github.com/dotnet/coreclr/issues/919
  - [ ] Revisit Assembly Loading (`LoadFrom` -&gt; `AsemblyLoadContext`, Location,...) #2025
- [ ] Provide an alternative fallback serializer (BinaryFormatter is not supported in .NET Core). The biggest concern is serializing exceptions, as they are not typically part of the grain interfaces, and we don't generate Orleans serializers for all exceptions in the system. We have a few workarounds in prototype that need to be enhanced.
- [ ] `PerformanceCounter` - not supported in .NET Core.
- [ ] `Environment.UserName`
- [ ] `CallContext.LogicalSetData` - potentially replace with `AsyncLocal&lt;T&gt;`
- [ ] Update codegen to be more aggressive and generate serializers for Exception types
- [ ] `SerializationInfo` - not supported in .NET Core.

2nd priority
- [ ] Compile time codegen working with new dotnet cli tooling (although be aware that the tooling will drop support for `project.json` once it RTMs, and we are not sure if the build tools will work once they start using csproj once again)
  - [ ] Avoid having OrleansCodeGenerator depend on Orleans project, since that creates a circular dependency to getting codegen to work easily (especially since Orleans.dll requires build time codegen). This is a nice to have, but not required if we solve the previous item in some other way.
- [ ] Allow `TestCluster` to work without creating new AppDomains for each silo (for example, by leveraging containers, or spawning and managing new processes)

3rd priority
- [ ] Separate test projects for each provider that brings in a new dependency (ideally even if that dependency is also supported in .NET Core, otherwise we would need to port the entire codebase before we can start testing each individual component we port)
- [ ] CI servers run tests in many platforms
- [x] `System.Runtime.Serialization.FormatterServices.GetUninitializedObject`
- [x] `System.Diagnostics.Process.Handle` -&gt; `System.Diagnostics.Process.SafeHandle`

---

**Already done issues (for progress tracking):**
- [x] `Type.IsInterface`-&gt; `Type.GetTypeInfo.IsInterface` (`IsClass`, `IsGenericType` , `IsAbstract`, `IsPrimitive`, `IsEnum`).
- [x] `Type` -&gt; `TypeInfo` for most members (in Orleans code, and code generated by OrleansCodeGenerator) #1783 #1894 #1997 
- [x] `TextReader.Close` -&gt; `TextReader.Dispose` #609 #2034
- [x] `Socket.Close` -&gt; `Socket.Dispose`
- [x] `Delegate.CreateDelegate` -&gt; `MethodInfo.CreateDelegate`
- [x] `ApplicationException(string)`
- [x] `System.Data` and `System.Transactions` - used in SQL utils. Create a separate OrleansSQLUtils project and move all [Relational Storage](https://github.com/dotnet/orleans/tree/master/src/Orleans/RelationalStorage) code there.
- [x] `XmlTextWriter` and `XMLNode.SelectNodes`.
- [x] `Dns.GetHostAddresses`.
- [x] `System.String.ToLower(CultureInfo.InvariantCulture)` -&gt; Use `CultureInfo.TextInfo.ToLower(String)` instead
- [x] `System.UriTypeConverter`.
- [x] `System.CodeDom.CodeTypeParameter`.
- [x] `BinaryFormatter.Serialize` - solved via #1047.
- [x] `System.Management.ManagementObjectCollection` -  not supported in .NET Core. Investigate and propose alternative options (if `ManagementObject` itself is supported). We use it now in one place, to find TotalPhysicalMemory. Solved via #1048
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1874</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Fix #1869. Grain Extensions + method interception should function correctly</Title>
    <Description>This PR addresses #1869, allowing method interception to function correctly when grain extensions (such as streams) are invoked.

Additionally, comments and naming were (hopefully) improved in the relevant code.

The approach is to give `ActivationData.ExtensionInvoker` a new interface, `IGrainExtensionMap`, which can then be queried when creating the `InterceptedMethodInvoker` for that extension. I've marked the crux of the change with a comment in the change list.

cc @gabikliot - I'd like your opinion on my approach here.
</Description>
    <CreatedDate>26/06/2016</CreatedDate>
    <ClosedDate>08/07/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1874</PullRequestID>
        <IssueID>1869</IssueID>
        <Title>Global Serverside interceptors throws KeyNotFound exception</Title>
        <Description>Hi, I have implemented the following global serverside interceptor. 

``
</Description>
        <CreatedDate>23/06/2016</CreatedDate>
        <ClosedDate>08/07/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1873</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Add project logos c/o Albel Derais</Title>
    <Description>More of bel's work can be found here: https://www.behance.net/Albel

This is a copy of #1845, but on the `gh-pages` branch instead of `master`
</Description>
    <CreatedDate>25/06/2016</CreatedDate>
    <ClosedDate>25/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1873</PullRequestID>
        <IssueID>1845</IssueID>
        <Title>Add project logos c/o Albel Derais</Title>
        <Description>More of bel's work can be found here: https://www.behance.net/Albel
</Description>
        <CreatedDate>16/06/2016</CreatedDate>
        <ClosedDate>25/06/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1859</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Testing for PreferLocalPlacement grain failure handling</Title>
    <Description>This change adds some additional test cases for failure modes around [PreferLocalPlacement] grains. They use the existing `PreferLocalPlacementTestGrain` already in the code base.
- Test case PreferLocalPlacementGrain_ShouldMigrateWhenHostSiloKilled
- Test case PreferLocalPlacementGrain_ShouldNotMigrateWhenOtherSiloKilled

I think these test cases should always work ok, but they currently they only work intermittently.

**i believe these failures are being caused by some unrelated bug(s) in gateway routing that I would like to check the community wisdom about.**

The underlying problem looks like the test client is trying to route the message through the gateway on the silo that was killed, but does throws back the underlying `SiloUnavailableException` when it cannot communicate with that [now dead] gateway silo rather than resending through the connection to the other [still alive] gateway silo.

**Requesting more eyes to confirm the logic in the test cases are correct and should work?**

Note: This PR does not yet contain any fix(es) for the [presumed] underlying gateway issue, so is NOT ready to be merged into master branch yet.

Thoughts?

Failure mode:

```
Orleans.Runtime.SiloUnavailableException : 
The target silo became unavailable for message: Request *cli/6cc4dc86@3e67d7b8-&gt;S127.0.0.1:40001:0*grn/62F215C3/f9816ab2 #8: global::UnitTests.GrainInterfaces.IPreferLocalPlacementTestGrain:GetEndpoint(). 
Target History is: &lt;S127.0.0.1:40001:0:*grn/62F215C3/f9816ab2:&gt;

Result Standard Output: 

******************** Starting test ********************
Silo Primary : Address = 127.0.0.1:5888 Proxy gateway: 127.0.0.1:40000
Silo Secondary_1 : Address = 127.0.0.1:5889 Proxy gateway: 127.0.0.1:40001
Proxy grain was originally located on silo 127.0.0.1:5888
PreferLocalPlacement grain was originally located on silo 127.0.0.1:5888
Killing other silo SiloHandle:127.0.0.1:5889 not hosting locally placed grain
```
</Description>
    <CreatedDate>19/06/2016</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1859</PullRequestID>
        <IssueID>8</IssueID>
        <Title>Code generation does not correctly escape language keywords used as identifiers</Title>
        <Description>Parameters which use language keywords as their name are not correctly escaped by current code generation, which causes compilation failures.

For example, this will cause generated code to fail to compile:

``

A bunch of early adopters have run into this issue (serves us right for calling parameters "event" :stuck_out_tongue_closed_eyes:)
</Description>
        <CreatedDate>24/01/2015</CreatedDate>
        <ClosedDate>01/02/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1842</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jasonholloway</FixedByID>
    <Title>ClusterConfiguration extension for setting Startup class</Title>
    <Description>Just what you'd expect from the title, I'd suppose.

I was moaning a little bit on #1765 about configuring the startup class being non-obvious, especially in the context of `TestCluster`, which prepopulates overrides.

So - a small helper extension method to set the `StartupTypeName` property on all nodes.
</Description>
    <CreatedDate>14/06/2016</CreatedDate>
    <ClosedDate>17/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1842</PullRequestID>
        <IssueID>1765</IssueID>
        <Title>StartupTypeName config location</Title>
        <Description>Just ran into a problem in trying to set up `TestCluster` with a designated startup class for DI: the `StartupTypeName` value appears in the per-node configuration object, and is as such automatically overridden by `TestCluster`, which uses specially-generated config overrides for each silo node it creates, thereby ignoring the settable defaults.

This can be hacked through for now by enumerating through each override node that `TestCluster` creates (or at least I think it can - additional silos can only be created after deployment, can't they...)

But - it occurs to me that the Startup class shouldn't be a per-node value in the first place. Having different DI containers per silo surely poses an ever so slight risk to the location transparency of grains - some seriously sharky waters here.

Could it be moved to `ClusterConfiguration.Globals`?
</Description>
        <CreatedDate>16/05/2016</CreatedDate>
        <ClosedDate>07/11/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1833</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>move Runtime-Tables.md to code</Title>
    <Description>related to #1810.
</Description>
    <CreatedDate>12/06/2016</CreatedDate>
    <ClosedDate>14/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1833</PullRequestID>
        <IssueID>1810</IssueID>
        <Title>Runtime-Tables.md is highly out of sync</Title>
        <Description>In reaction to #1740 and my continued work on improving the documentation (#1264) I've stumbled upon [Runtime-Tables.md](http://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Runtime-Tables.html) file.The entire file has broken links and is basically an old documentation of Azure runtime tables.
I'm not exactly sure what's the purpose of this help file, we can just move that documentation to the code (which already includes most of it). 
</Description>
        <CreatedDate>05/06/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1832</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Add relational storage design rationale</Title>
    <Description>**\* **DO NOT MERGE THIS YET** ***
I add material and arrange the text during the next 24 hours.

The current documentation lacks explanation of the goals and the factors of the of the relational storage sub-system, OrleansSQLUtils, design. This lack of documentation makes it needlessly difficult to:
1. Realize the potential use cases in one’s problem domain.
2. Increases effort to make a contribution.

This patch addresses these problems and partially addresses #1810.
</Description>
    <CreatedDate>10/06/2016</CreatedDate>
    <ClosedDate>13/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1832</PullRequestID>
        <IssueID>1810</IssueID>
        <Title>Runtime-Tables.md is highly out of sync</Title>
        <Description>In reaction to #1740 and my continued work on improving the documentation (#1264) I've stumbled upon [Runtime-Tables.md](http://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Runtime-Tables.html) file.The entire file has broken links and is basically an old documentation of Azure runtime tables.
I'm not exactly sure what's the purpose of this help file, we can just move that documentation to the code (which already includes most of it). 
</Description>
        <CreatedDate>05/06/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1826</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Add relational storage design rationale</Title>
    <Description>The current documentation lacks explanation of the goals and the factors of the of the relational storage sub-system, [OrleansSQLUtils](https://github.com/dotnet/orleans/tree/master/src/OrleansSQLUtils), design. This lack of documentation makes it needlessly difficult to:
1. Realize the potential use cases in one’s problem domain.
2. Increases effort to make a contribution.

This patch addresses these problems and partially addresses #1810.
</Description>
    <CreatedDate>09/06/2016</CreatedDate>
    <ClosedDate>10/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1826</PullRequestID>
        <IssueID>1810</IssueID>
        <Title>Runtime-Tables.md is highly out of sync</Title>
        <Description>In reaction to #1740 and my continued work on improving the documentation (#1264) I've stumbled upon [Runtime-Tables.md](http://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Runtime-Tables.html) file.The entire file has broken links and is basically an old documentation of Azure runtime tables.
I'm not exactly sure what's the purpose of this help file, we can just move that documentation to the code (which already includes most of it). 
</Description>
        <CreatedDate>05/06/2016</CreatedDate>
        <ClosedDate>10/01/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1821</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>robrodi</FixedByID>
    <Title>Migrated to Xunit</Title>
    <Description>Converted all asserts to XUnit (#1793)
</Description>
    <CreatedDate>09/06/2016</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1821</PullRequestID>
        <IssueID>1793</IssueID>
        <Title>Migrate MSTest assertions to xUnit</Title>
        <Description>We migrated all of our tests to xUnit.
Nevertheless, we are still referencing MSTest to perform ~~all~~ some the assertions, instead of using the `xunit.assert` package.

~~We need to perform this final cleanup and get rid of MSTest references entirely.
I started doing find and replace in the Tester project, but there's still several compilation errors, as we are sometimes using overloads that are not supported in xUnit. If you want a nice starting point to know where to go next, please pull my `xunit-assert` branch here: https://github.com/jdom/orleans/tree/xunit-assert~~

We would ~~also~~ need to convert the TesterInternal project
</Description>
        <CreatedDate>27/05/2016</CreatedDate>
        <ClosedDate>20/07/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1802</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dsarfati</FixedByID>
    <Title>Test Helpers - Stateful Grains</Title>
    <Description>Updated  #1792 to include stateful grains.
</Description>
    <CreatedDate>01/06/2016</CreatedDate>
    <ClosedDate>02/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1802</PullRequestID>
        <IssueID>1792</IssueID>
        <Title>Test helpers</Title>
        <Description>Added a grain creator class that further enables unit testing grains without the need for a full silo. This enables the same behavior of the test only constructor `protected Grain(IGrainIdentity identity, IGrainRuntime runtime)` , but doesnt force developers to add test specific code to their production grains. I plan to add Grain&lt;T&gt; as well, but I wanted to get the discussion started.
</Description>
        <CreatedDate>26/05/2016</CreatedDate>
        <ClosedDate>28/05/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1800</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sebastianburckhardt</FixedByID>
    <Title>GSI protocol for multi-clusters</Title>
    <Description>Implements Global-single-instance registration strategy. This is the next installment of the Geo-Distribution Project #948.
</Description>
    <CreatedDate>31/05/2016</CreatedDate>
    <ClosedDate>16/09/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1800</PullRequestID>
        <IssueID>948</IssueID>
        <Title>Geo-Distribution Project</Title>
        <Description>Let's use this issue to discuss the proposed geo-distribution features, and to track progress.

Also see:
- Virtual Meetup: https://www.youtube.com/watch?v=fOl8ophHtug
-  preliminary documentation (including slides, API documentation, and a research paper draft) is at https://github.com/sebastianburckhardt/orleans/tree/geo-docs/geo/docs
</Description>
        <CreatedDate>27/10/2015</CreatedDate>
        <ClosedDate>05/07/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1799</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>robrodi</FixedByID>
    <Title>Xunit assert</Title>
    <Description>#1793 - compiles.
</Description>
    <CreatedDate>30/05/2016</CreatedDate>
    <ClosedDate>09/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1799</PullRequestID>
        <IssueID>1793</IssueID>
        <Title>Migrate MSTest assertions to xUnit</Title>
        <Description>We migrated all of our tests to xUnit.
Nevertheless, we are still referencing MSTest to perform ~~all~~ some the assertions, instead of using the `xunit.assert` package.

~~We need to perform this final cleanup and get rid of MSTest references entirely.
I started doing find and replace in the Tester project, but there's still several compilation errors, as we are sometimes using overloads that are not supported in xUnit. If you want a nice starting point to know where to go next, please pull my `xunit-assert` branch here: https://github.com/jdom/orleans/tree/xunit-assert~~

We would ~~also~~ need to convert the TesterInternal project
</Description>
        <CreatedDate>27/05/2016</CreatedDate>
        <ClosedDate>20/07/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1762</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jasonholloway</FixedByID>
    <Title>Added option to perform provider commands quietly</Title>
    <Description>Half-way down #610 it's quietly suggested that `IManagementGrain.SendControlCommandToProvider` could be exploited to message between silos in a slightly more chatty manner than initially intended - communicating cache invalidations, for instance.

This is all well and good, but the current implementation logs once per message, which has the potential to get quite noisy.

So - I've added an optional parameter to the signature to bypass logging.
</Description>
    <CreatedDate>15/05/2016</CreatedDate>
    <ClosedDate>15/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1762</PullRequestID>
        <IssueID>610</IssueID>
        <Title>Broadcast/per-silo grains</Title>
        <Description>In #587, we discussed the occasional desire to break location transparency of Virtual Actors and have the ability to message a grain (or otherwise) on an individual silo to broadcast a message to all silos.

In my case, I would have been happy to kick off a stream consumer inside a bootstrap provider and push messages to it using a stream, but this is not currently supported.

Use cases include:
- Configuration
- Cache management
- Metrics collection
- Fault injection
- Process control (eg, live code reload)
- Implementing certain distributed algorithms, eg Raft &amp; Paxos

So, how should we do this?
</Description>
        <CreatedDate>15/07/2015</CreatedDate>
        <ClosedDate>17/04/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>help wanted</Label>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1684</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jasonholloway</FixedByID>
    <Title>Generic GrainReferences, Part II</Title>
    <Description>Hi,

This is, I suppose, a speculative Pull Request, in that, firstly, it modifies internal components I'm wary of changing without prior discussion, and, secondly, the expanded behaviour it provides is currently surplus to requirements, given the (understandably) defensive limitation of support for generics.

But, nevertheless:
- GrainReferences now have two properties for two sets of generic arguments: `ActivatingGenArgs` and `CurrentGenArgs`. These replace the single, ambiguous `GenericArguments` property. 
- `ActivatingGenArgs` supplies the gen args of the generic interface first requested. Even after subsequent casts, it is these that should be used for activation. These supplement the typecode encoded within the `GrainId`.
- `CurrentGenArgs` supplies the gen args of the current interface implemented by the particular `GrainReference`. These supplement the typecode passed on method-invocation by `InvokeMethodRequest.InterfaceId`.
- `InvokeMethodRequest` has been expanded to carry the `CurrentGenArgs` of the invoking reference. This is then used at the destination to summon the right `MethodInvoker`.
- Meanwhile, the `ActivatingGenArgs` are still passed on invocation alongside the `InvokeMethodRequest` object, and are picked up by the activating agent, as previously.

The upshot is, that, apart from in the type-matching process and in codegen, different gen args can live alongside each other in relative harmony. 

This is intended as a slightly less half-baked sequel to #1604.
</Description>
    <CreatedDate>14/04/2016</CreatedDate>
    <ClosedDate>11/06/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1684</PullRequestID>
        <IssueID>1604</IssueID>
        <Title>Generic reference casting</Title>
        <Description>Hello,

I've stumbled across another generics-related bug: calling `IGrain.AsReference()` to cast to another, generic grain interface results in an unusable `GrainReference` with the `genericArguments` field unchanged from that of the original reference.

I've had a go at a PR for fixing this, which gets the generated reference classes to override a protected `GenericArguments` property on the base `GrainReference`, much as the `InterfaceName` is overridden currently, but without the public surface.

Hopefully this is all reasonable - I'm a bit mindful of messing with internal components without prior discussion, but am also fairly eager to contribute, so thought I'd give it a go.
</Description>
        <CreatedDate>23/03/2016</CreatedDate>
        <ClosedDate>25/03/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1682</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Preliminary relational persistence queries</Title>
    <Description>An update storage provider for existing relational backends
- A storage provider for MySQL added and for SQL Server (hopefully) improved by easier setup, supported for any ADO.NET supported DB (initial scripts for SQL Server and MySQL).
- Includes support for changing serializers and deserializers at any level of granularity (meaning grain type, id, state data etc., [see tests](https://github.com/dotnet/orleans/pull/1682/commits/eac23b59f5e85fc37fed36d09fb9ce2eaefd0784#diff-e580375a3d638cc0620ee1a22d1d6fd5R108)). This means one can use any serializer or deserializer one wants and even change from one format to another.
- Supports evolving (or versions) or wholesale changing of data types.
- Allows downloading data as streams at any granularity (e.g. avoids LOH allocations and conserves resources otherwise too).
- Allows for sharding using the Orleans built-in sharding, hence supporting it for any ADO.NET backend (having scripts) and even for heterogenous vendor setup (even heterogenous storage setup, should be possible to slice both horizontally and vertically with some additional work).
- Supports multiple simultaneous deployments.
- In-storage special processing supported (e.g. XML and JSON for SQL Server).
- Jenkins hash function exposed and used to hash the index, wrapped to an interface so it can be changed and doesn't create backwards compability issue for the current implementation. This allows also the hashing functionality changed like serializers and deserializers.

Notes to follow...

Fixes #1176.
</Description>
    <CreatedDate>13/04/2016</CreatedDate>
    <ClosedDate>01/08/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1682</PullRequestID>
        <IssueID>1176</IssueID>
        <Title>Refactor current relational storage provider to easier setup and more general purpose</Title>
        <Description>This is a proposal and a sketch to refactor the current relational storage provider for easier to use, to support other databases in addition to SQL Server and increase versatility (current setup [here](https://github.com/dotnet/orleans/tree/master/src/OrleansSQLUtils/Storage/Provider/Setup)). Opinions are invited and welcomed. Things to be considered:
1. Relational storage provider should support a database that has an ADO.NET provider.
2. Getting started should ideally not require more than running a simple setup script.
3. It should be possible to take advantange of vendor specific functionality.
4. Storage-side processing of data should be possible, i.e. updating some data or modifying data layout if stored data type is refactored.
5. Finding the right row should be fast.
6. Sharding.

A table `OrleansStorage` is proposed defining the following columns:
- `GrainId`: the ID of the grain,
- `Type`: the type of the storage class,
- `Payload`: the serialiazed storage object of `Type`,
- `PayloadVersion`: the "schema" version of the payload,
- `ETag`: the version of the payload,
- `ModifiedOn`: the moment this piece of state was modified on in the database.

The idea here is the correct storage state can be pointed to by `GrainId` and indexed efficiently by `Type` type. `ETag`, if provided, gives the version and `ModifiedOn` the date data has been modified. The queries can be loaded into `OrleansQuery` and used [in similar fashion to other queries](https://github.com/dotnet/orleans/blob/master/src/OrleansSQLUtils/CreateOrleansTables_SqlServer.sql#L220). This allows the user to take benefit of general solution that accepts everything, but also to [modify the queries](http://stackoverflow.com/questions/20054854/tsql-select-from-different-table-based-on-a-case-value) so that some types of values are `INSERT`ed to and consequently `SELECT`ed from a purpose-built structures transparently what comes to Orleans.

`PayloadVersion` is an explicit version number of the saved type. The version of the data schema stored in `Payload` can be either embedded in it or provided explicitly in `PayloadVersion`. The idea here is that utilizing storage-side schema version update is easier if the version of the data is explicit. However, the benefit of this is debatable as the _easiness_ depends on serialization format (i.e. binary serialized format is more difficult to modify). If Orleans does not use schema version, it can be "informative" so that developer can use it at is own leisure. There is a [gist discussing schema versioning](https://gist.github.com/ReubenBond/bf7edc056c1a5d3dbb79) also.

Ideally one could choose `Payload` serialization type. In case of relational storage it could be `VARBINARY(MAX)` that accepts any type. For storage-side processing, `NVARCHAR(MAX)` could be useful too (SQL Server 2016, for instance, has native tooling to query JSON data in that type) or `XML`. One option could be to provide all these types simulatenously (i.e. three columns of which one is used on a given row) and allow it to be varied by ID or type (or both). This would require support on Orleans side as much as having the storage provider a way to load and maintain a list of serializers and deserializers used. In the first phase this list could be length one and contain one pregiven binary serializer.

How to support sharding data on Orleans is currently something that needs to investigated more thoroughly. For instance, how important is this feature straight from the beginning?

A more forward looking consideration is that oftentimes there is an explicit or implicit expectation of flexibility on handling data in storage and capacity planning. As for general examples, these requirements may stem from other systems using the same data, compliance or security. This might in future bring into focus a desire to discriminate to which database certain data is stored. For instance, some data should be stored to a more secured database, some on less-reliable or slower storage whereas some hot data to a SSD raid, which has a very different cost. This looks like require support for multiple connection strings chosen based on `Type` and maybe `GrainId` information. This might be handle in the same fashion as `Payload`.
</Description>
        <CreatedDate>18/12/2015</CreatedDate>
        <ClosedDate>01/08/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1427</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jdom</FixedByID>
    <Title>More AggregateException propagation tests</Title>
    <Description>Since AggregateExceptions are a little bit special, some more tests to cover scenarios like AggregateExceptions with multiple inner exceptions, as well as synchronous throws of these.
This is to fulfill user facing expectations in #1378
</Description>
    <CreatedDate>10/02/2016</CreatedDate>
    <ClosedDate>11/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1427</PullRequestID>
        <IssueID>1378</IssueID>
        <Title>Transparently propagate exceptions to callers without modification</Title>
        <Description>Based on a set of tests created by #1356, it's clear that if a grain throws a user-unhandled exception, then Orleans forwards it to the caller, but after it tampers a little bit with it.
It basically wraps it into an AggregateException and also flattens it (so it removes nested AggregateExceptions, messing with the stack trace and so on).

This entails a breaking change that would not be caught by compilers, but it seems that all who responded in #1356 agree that this should be fixed regardless.

The code to fix it is non entirely straightforward, as there are several levels of TaskContinuationSources in the middle (see #875 for example). It would be simpler to fix for now doing a one-off fix, but at some point there's a bigger follow up to avoid the unnecessary use of TaskCompletionSources (paying extra care of in what scheduler the continuations run). I will open another issue for it, nevertheless that might be easier to clean up with .NET 4.6

For now, the tests in [ExceptionPropagationTests](https://github.com/dotnet/orleans/blob/master/test/Tester/ExceptionPropagationTests.cs) are being skipped. When we implement this we'll reenable them.
</Description>
        <CreatedDate>05/02/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1426</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>JSON Grains - Add test case to validate grains using JSON JObject parameters</Title>
    <Description>- A test case for grains that use JSON JObject parameters for input / output.
- See #1368 for some related background discussion.
</Description>
    <CreatedDate>10/02/2016</CreatedDate>
    <ClosedDate>11/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1426</PullRequestID>
        <IssueID>1368</IssueID>
        <Title>JSON Grains - Grain methods using JObject parameter types and/or return types.</Title>
        <Description>I created a minimal repro https://github.com/jthelin/orleans/pull/2 for what seems to be a bug with handling of grains using JSON parameters and/or return values of type `JObject`.

The code all builds ok, but the new test cases `JSON_GetGrain` and `JSON_EchoJson` both fail with exception:
`Cannot find an implementation class for grain interface: UnitTests.GrainInterfaces.IJsonEchoGrain`

I have traced through the GrainInterfaceMap code, and there is indeed no type mapping data present at runtime for IJsonEchoGrain

The "Loaded grain type summary" dump in the silo log does not list that grain either, but I can't see any errors in the silo log(s) about problems loading that grain type, or that it was skipped.
Build log and Silo log: https://gist.github.com/jthelin/1db4393ef330d451beaf

From the silo logs, the `TestGrains.dll` assembly which contains the JsonEchoGrain does get inspected and other grains in that assembly get loaded correctly.

There is already a test case for SerializationManager handling of `JObject` but not one for passing `JObject` values to/from grains.
https://github.com/gabikliot/orleans/commit/d957d272c77027df5d9cf7d897f74d1cb24cab40#diff-b2da0bfffa2a6b698e7d539d22c9889fR50

Any thought on how to narrow down why this grain type won't load correctly?

Test results:
https://ci.appveyor.com/project/jthelin/orleans/build/1.0.495/tests

``
</Description>
        <CreatedDate>03/02/2016</CreatedDate>
        <ClosedDate>10/02/2016</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1425</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Repro for #1424 - KnownAssemblyAttribute does not generate serializers at runtime</Title>
    <Description>Tests skipped to pass CI (search for #1424 in the code)
</Description>
    <CreatedDate>10/02/2016</CreatedDate>
    <ClosedDate>28/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1425</PullRequestID>
        <IssueID>1424</IssueID>
        <Title>KnownAssemblyAttribute does not generate serializers at runtime</Title>
        <Description>It also prevents serializers from being generated in any assemblies containing the attribute.

The issue seems to stem with the way the code generator [processes the attribute](https://github.com/dotnet/orleans/blob/master/src/OrleansCodeGenerator/RoslynCodeGenerator.cs#L310).

I've tried a naive fix - replacing `IntersectWith` with `UnionWith` but things crashed left and right. 
Repro coming soon.
</Description>
        <CreatedDate>10/02/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1423</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Fix: Azure silo fails to start under debugger</Title>
    <Description>Fixes #1422
</Description>
    <CreatedDate>10/02/2016</CreatedDate>
    <ClosedDate>11/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1423</PullRequestID>
        <IssueID>1422</IssueID>
        <Title>CodeGeneratorManager fails to initialize if OrleansCodeGenerator.dll is not already loaded</Title>
        <Description>Discovered this wile debugging an Azure silo.
</Description>
        <CreatedDate>10/02/2016</CreatedDate>
        <ClosedDate>11/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1417</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Repro: F# option deserialization error</Title>
    <Description>Repro for #1346 

Test result (currently skipped for CI):

```
Test Name:  UnitTests.Serialization.SerializationTestsFsharpTypes.SerializationTests_FSharp_IntOption_Some
Test FullName:  UnitTests.Serialization.SerializationTestsFsharpTypes.SerializationTests_FSharp_IntOption_Some
Test Source:    C:\code\ca-ta\orleans\test\Tester\SerializationTests\SerializationTests.FSharpTypes.cs : line 28
Test Outcome:   Failed
Test Duration:  0:00:03.61

Result StackTrace:  
at valueSet(FSharpOption`1 , Int32 )
   at UnitTests.GrainInterfaces.OrleansCodeGenMicrosoft_FSharp_Core_FSharpOptionSerializer`1.Deserializer(Type expected, BinaryTokenStreamReader stream) in C:\code\ca-ta\orleans\src\TestGrainInterfaces\Properties\orleans.codegen.cs:line 7760
   at Orleans.Serialization.SerializationManager.DeserializeInner(Type expected, BinaryTokenStreamReader stream) in C:\code\ca-ta\orleans\src\Orleans\Serialization\SerializationManager.cs:line 1525
   at Orleans.Serialization.SerializationManager.DeserializeInner[T](BinaryTokenStreamReader stream) in C:\code\ca-ta\orleans\src\Orleans\Serialization\SerializationManager.cs:line 1435
   at Orleans.Serialization.SerializationManager.DeserializeFromByteArray[T](Byte[] data) in C:\code\ca-ta\orleans\src\Orleans\Serialization\SerializationManager.cs:line 1709
   at Orleans.Serialization.SerializationManager.RoundTripSerializationForTesting[T](T source) in C:\code\ca-ta\orleans\src\Orleans\Serialization\SerializationManager.cs:line 2203
   at UnitTests.Serialization.SerializationTestsFsharpTypes.RoundtripSerializationTest[T](T input) in C:\code\ca-ta\orleans\test\Tester\SerializationTests\SerializationTests.FSharpTypes.cs:line 22
   at UnitTests.Serialization.SerializationTestsFsharpTypes.SerializationTests_FSharp_IntOption_Some() in C:\code\ca-ta\orleans\test\Tester\SerializationTests\SerializationTests.FSharpTypes.cs:line 29
Result Message: System.Security.VerificationException : Operation could destabilize the runtime.

```
</Description>
    <CreatedDate>09/02/2016</CreatedDate>
    <ClosedDate>28/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1417</PullRequestID>
        <IssueID>1346</IssueID>
        <Title>F# option (FSharpOption&lt;T&gt;) fails to deserialize</Title>
        <Description>Adding an interface that uses `FSharpOption&lt;T&gt;` results in compile-time serializers being generated. This breaks the deserialization of the F# `option` type.
</Description>
        <CreatedDate>28/01/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1415</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Made exceptions to propagate transparently to callers</Title>
    <Description> #1378. Tests with nested awaits and multi-hop calls, which presumably are currently being implemented by @jdom must be merged before this one. 
</Description>
    <CreatedDate>08/02/2016</CreatedDate>
    <ClosedDate>12/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1415</PullRequestID>
        <IssueID>1378</IssueID>
        <Title>Transparently propagate exceptions to callers without modification</Title>
        <Description>Based on a set of tests created by #1356, it's clear that if a grain throws a user-unhandled exception, then Orleans forwards it to the caller, but after it tampers a little bit with it.
It basically wraps it into an AggregateException and also flattens it (so it removes nested AggregateExceptions, messing with the stack trace and so on).

This entails a breaking change that would not be caught by compilers, but it seems that all who responded in #1356 agree that this should be fixed regardless.

The code to fix it is non entirely straightforward, as there are several levels of TaskContinuationSources in the middle (see #875 for example). It would be simpler to fix for now doing a one-off fix, but at some point there's a bigger follow up to avoid the unnecessary use of TaskCompletionSources (paying extra care of in what scheduler the continuations run). I will open another issue for it, nevertheless that might be easier to clean up with .NET 4.6

For now, the tests in [ExceptionPropagationTests](https://github.com/dotnet/orleans/blob/master/test/Tester/ExceptionPropagationTests.cs) are being skipped. When we implement this we'll reenable them.
</Description>
        <CreatedDate>05/02/2016</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1407</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Fixed string.Format arguments number error</Title>
    <Description>#1395

The `RETRIES` parameter is no longer used:

![devenv_2016-02-06_11-43-59](https://cloud.githubusercontent.com/assets/5787619/12865999/fa664dae-ccc6-11e5-861c-e6cc0b3e0ed2.png)
</Description>
    <CreatedDate>06/02/2016</CreatedDate>
    <ClosedDate>08/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1407</PullRequestID>
        <IssueID>1395</IssueID>
        <Title>PVS-Studio: String.Format arguments number error in OrleansManager.Program</Title>
        <Description>Code like that will throw **FormatException**

`WriteStatus(string.Format("**Calling DeleteGrain({0}, {1}, {2})", silo, grainId));`

**V3025 Incorrect format. A different number of format items is expected while calling 'Format' function. Expected: 3. Present: 2. OrleansManager Program.cs 169**

**V3025 Incorrect format. A different number of format items is expected while calling 'Format' function. Expected: 3. Present: 2. OrleansManager Program.cs 183**
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>08/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1405</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Increment and DecrementMetric methods in Orleans.TraceLogger had same body</Title>
    <Description>#1399
</Description>
    <CreatedDate>06/02/2016</CreatedDate>
    <ClosedDate>08/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1405</PullRequestID>
        <IssueID>1399</IssueID>
        <Title>PVS-Studio: Increment and DecrementMetric methods in Orleans.TraceLogger have same body</Title>
        <Description>DecrementMetric actually increments

**V3013 It is odd that the body of 'IncrementMetric' function is fully equivalent to the body of 'DecrementMetric' function (1079, line 1095). Orleans TraceLogger.cs 1079**

``
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>08/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1404</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Added missing throw keyword.</Title>
    <Description>#1396
</Description>
    <CreatedDate>06/02/2016</CreatedDate>
    <ClosedDate>08/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1404</PullRequestID>
        <IssueID>1396</IssueID>
        <Title>PVS-Studio: Missing throw keyword in OrleansRuntime.MemoryStorageGrain</Title>
        <Description>**V3006 The object was created but it is not being used. The 'throw' keyword could be missing: throw new InconsistentStateException(FOO). OrleansRuntime MemoryStorageGrain.cs 129**

``
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>08/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1381</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Fixed Azure table property being not sanitized.</Title>
    <Description>Return values of pure method `string.Replace` weren't used. 
Fixes #1385.
</Description>
    <CreatedDate>05/02/2016</CreatedDate>
    <ClosedDate>05/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1381</PullRequestID>
        <IssueID>1385</IssueID>
        <Title>PVS-Studio: Incorrect AzureStorageTable property key sanitization</Title>
        <Description>I'm going to open issues for all things found by PVS Studio, including already fixed ones. Feel free to close it immediately or mark it up-for-grabs.

Key value won't be sanitized properly because of incorrect usage of Replace method. (Fixed in #1381)

**V3010 The return value of function 'Replace' is required to be utilized. AzureStorageUtils.cs 278**

``
</Description>
        <CreatedDate>06/02/2016</CreatedDate>
        <ClosedDate>09/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1375</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>EventHubStreamProvider checkpointing</Title>
    <Description>This change introduces checkpointing of the eventhub partitions as messages are processed.

Each agent reads from a single eventhub partition.  The agent will start reading at the beginning of the hub or from the most recent events, depending on configuration.  Once events have been read, a checkpoint will be recorded and any time the service (or agent) is restarted it will start reading from the checkpointed location in the eventhub partition, rather than the start (or current data).

As the agent reads more and more events from the partition, it will update the checkpoint in a configurable interval.  The checkpoint recorded is the offset into the partition of the oldest message in the cache.  When there is a restart, depending on how large the message cache is, there will likely be duplicate events as the message cache is rebuilt to the state it was in when the last checkpoint occurred.

This prevents the streaming infrastructure from losing events while the service is down, but at the cost of allowing some duplicates.

NOTE:  To get the checkpoint data from the cache, a new generic checkpoint types was introduced.  This was necessary because different queues will use different data to denote read locations in a queue.  This mechanism is clumsy but I failed to devise a more elegant solution.  I'm quite open to alternative suggestions.

This is the last planned change for Recoverable Event Hub Persistent Stream Provider #1096.
After this PR, the EventHubStreamProvider should be in a state where it can be used in production systems, though users should be aware that there is another set of changes being planned for the EventHubStreamProvider.  While it's complete enough to be used in products, it's still very much under development.

I'll soon create an issue similar to #1096 which will describe the next set of changes to the EventHubStreamProvider.  I welcome community input on this.
</Description>
    <CreatedDate>05/02/2016</CreatedDate>
    <ClosedDate>23/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1375</PullRequestID>
        <IssueID>1096</IssueID>
        <Title>Recoverable Event Hub Persistent Stream Provider</Title>
        <Description>Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate events are allowed.  For instance, a stream of events e1, e2, e3, e4, e5 can be delivered to a consumer ordered as e1, e2, e3, e4, e1, e2, e5, but can’t be delivered in the order e1, e4, e5, e2, e3, e4, e5.
- Recoverable/Rewindable – Consumers can recover from transient errors in stream processing by resuming stream consumption from the sequence token of the last successfully processed event.  Since this is intended only to compensate for transient stream processing errors, only 30 minutes of recoverable stream data is required.
- Persistent streams – Events must be persisted upon generation.  Processing of the event can be delayed, but persistence of the event must be immediate.
- Performant – Must support stream delivery of 2000+ events per second per silo with below 40% CPU utilization.

These requirements came from [343 Industries](https://www.halowaypoint.com/en-us), an early adopter and co-developer of Orleans streaming technology.  [343 Industries](https://www.halowaypoint.com/en-us) developed a recoverable stream provider using EventHub.  This EventHub Stream Provider is being contributed to the Orleans open source project.  During the process of porting this technology to Orleans, the stream provider will be refactored and reorganized to conform to Orleans open source conventions, but the core architecture and requirements must be preserved.

This stream provider will be introduced in the following stages (plan subject to change):
1. Minimal non-recoverable EventHub stream provider
   - Introduction of a new ServiceBus specific project.  OrleansServiceBus.  This will be comparable to the azure specific project OrleansAzureUtils.
   - Development of EventHubQueueAdapter comparable to AzureQueueAdapter, with similar limitations.
     1. Non-rewindable
     2. Will use simple queue cache.
   - Define an EventHubStreamProvider that is a persistent stream provider that uses the EventHubAdapter.
   - Add test coverage for EventHubStreamProvider comparable to that of AzureQueueStreamProvider.
2. Introduce PooledQueueCache (open to better name).  This will be an implementation of the IQueueCache interface which can cache up to 30 minutes of data while minimizing impact to garbage collection.
   - This implementation will cache raw serialized events in pooled blocks of memory that are reused and never collected by garbage collection system.
   - Add PooledQueueCache BVT tests.
3. Add recoverable stream tests using the test stream provider GeneratorStreamProvider with a PooledQueueCache.
4. Update EventHubStreamProvider to be recoverable.
   - Update EventHubQueueAdapter to use PooledQueueCache.
   - EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
   - Add recoverable stream tests comparable to those built against GeneratorStreamProvider.
</Description>
        <CreatedDate>01/12/2015</CreatedDate>
        <ClosedDate>25/02/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1375</PullRequestID>
        <IssueID>1096</IssueID>
        <Title>Recoverable Event Hub Persistent Stream Provider</Title>
        <Description>Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate events are allowed.  For instance, a stream of events e1, e2, e3, e4, e5 can be delivered to a consumer ordered as e1, e2, e3, e4, e1, e2, e5, but can’t be delivered in the order e1, e4, e5, e2, e3, e4, e5.
- Recoverable/Rewindable – Consumers can recover from transient errors in stream processing by resuming stream consumption from the sequence token of the last successfully processed event.  Since this is intended only to compensate for transient stream processing errors, only 30 minutes of recoverable stream data is required.
- Persistent streams – Events must be persisted upon generation.  Processing of the event can be delayed, but persistence of the event must be immediate.
- Performant – Must support stream delivery of 2000+ events per second per silo with below 40% CPU utilization.

These requirements came from [343 Industries](https://www.halowaypoint.com/en-us), an early adopter and co-developer of Orleans streaming technology.  [343 Industries](https://www.halowaypoint.com/en-us) developed a recoverable stream provider using EventHub.  This EventHub Stream Provider is being contributed to the Orleans open source project.  During the process of porting this technology to Orleans, the stream provider will be refactored and reorganized to conform to Orleans open source conventions, but the core architecture and requirements must be preserved.

This stream provider will be introduced in the following stages (plan subject to change):
1. Minimal non-recoverable EventHub stream provider
   - Introduction of a new ServiceBus specific project.  OrleansServiceBus.  This will be comparable to the azure specific project OrleansAzureUtils.
   - Development of EventHubQueueAdapter comparable to AzureQueueAdapter, with similar limitations.
     1. Non-rewindable
     2. Will use simple queue cache.
   - Define an EventHubStreamProvider that is a persistent stream provider that uses the EventHubAdapter.
   - Add test coverage for EventHubStreamProvider comparable to that of AzureQueueStreamProvider.
2. Introduce PooledQueueCache (open to better name).  This will be an implementation of the IQueueCache interface which can cache up to 30 minutes of data while minimizing impact to garbage collection.
   - This implementation will cache raw serialized events in pooled blocks of memory that are reused and never collected by garbage collection system.
   - Add PooledQueueCache BVT tests.
3. Add recoverable stream tests using the test stream provider GeneratorStreamProvider with a PooledQueueCache.
4. Update EventHubStreamProvider to be recoverable.
   - Update EventHubQueueAdapter to use PooledQueueCache.
   - EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
   - Add recoverable stream tests comparable to those built against GeneratorStreamProvider.
</Description>
        <CreatedDate>01/12/2015</CreatedDate>
        <ClosedDate>25/02/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1374</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Relational Storage: reminders range queries: cast to int before range check</Title>
    <Description>a solution for #1365.
At first this was a bit more complicated fix since I wanted to support both `uint` and `int`. IMHO, there's no need for that.
</Description>
    <CreatedDate>04/02/2016</CreatedDate>
    <ClosedDate>11/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1374</PullRequestID>
        <IssueID>1365</IssueID>
        <Title>a bug in relational storage reminders implementation</Title>
        <Description>we might have a problem with the current implementation of reminders in relational storage
the code casts the start and end grain hash from uint to int before querying...
i discovered it because i wrote a new test:

``

will return it, because it returns all negative hashes in our case.
so best case we got some really bad load balancing and one silo is handling half of the reminders,
and in the worst case we might never fire **half** of the reminders.
it seems that the ring's "last" silo's range can have `beginhash`&gt;`endhash`. this silo will get all the negatives.
it's an easy fix, but any system that's currently in production using `MSSQL` or `MySQL` will need a migration script. and we'd probably need to use `BIGINT` in `MSSQL` because it doesn't have unsigned numbers :astonished:
</Description>
        <CreatedDate>02/02/2016</CreatedDate>
        <ClosedDate>11/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1369</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>CodeGen: Add support for F# interfaces</Title>
    <Description>Fixes #1349, includes corresponding tests.
### Background

F# interface definitions do not require parameter names. It is idiomatic to omit parameter names for trivial interface methods:

```
type Interface1 =
    abstract member Multiply : int -&gt; int -&gt; int
```

However, Orleans code generation requires parameter names to be present. The PR addresses this by generating such names when not present, by suffixing the string `"arg"` with the parameter's index (`arg0`, `arg1`, etc.). 
</Description>
    <CreatedDate>04/02/2016</CreatedDate>
    <ClosedDate>05/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1369</PullRequestID>
        <IssueID>1349</IssueID>
        <Title>Code generation fails for grain interfaces derived from interface(s) in an external F# assembly</Title>
        <Description>This worked fine in all versions of Orleans up to and including 1.0.9.
We've tried to work around this by moving the interface definitions to C# and hit #1346. 

Fix and repro coming shortly.
</Description>
        <CreatedDate>29/01/2016</CreatedDate>
        <ClosedDate>05/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1360</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Sql Scripts - removed two redundancies</Title>
    <Description>this should also solve #1341. @veikkoeeva, please take a look.
</Description>
    <CreatedDate>30/01/2016</CreatedDate>
    <ClosedDate>31/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1360</PullRequestID>
        <IssueID>1341</IssueID>
        <Title>Etag is not set in OrleansMembershipTable for SQLServerMembership Provider</Title>
        <Description>Trying to track down why my membership table always has 0x00000 for the Etag.

The VersionETag in OrleansMembershipVersionTable
is set correctly (e.g. not 0x000000)

Using the unit tests.   I removed the ETag column from the OrleansMembershipTable table

and removed it from these queries
MembershipReadRowKey
MembershipReadAllKey

Changed
RelationalOrleansQueries.CreateMembershipEntry
from
`etag = Convert.ToBase64String(record.GetValue&lt;byte[]&gt;("ETag"));`
to
`etag = Convert.ToBase64String(record.GetValue&lt;byte[]&gt;("VersionETag"));`

Now all the tests pass except
MembershipTable_SqlServer_UpdateRow

This test exposes that Etag is never matched in the where clause.   Apparently in the other tests the VersionEtag is being used

Should I create a PR to share code?
</Description>
        <CreatedDate>27/01/2016</CreatedDate>
        <ClosedDate>03/02/2016</ClosedDate>
        <Labels>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1359</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Refactored Asynchrony Documentation</Title>
    <Description>part of #1264.
</Description>
    <CreatedDate>30/01/2016</CreatedDate>
    <ClosedDate>02/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1359</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1358</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Made SerializerGenerationManager non static</Title>
    <Description>#1324
</Description>
    <CreatedDate>30/01/2016</CreatedDate>
    <ClosedDate>02/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1358</PullRequestID>
        <IssueID>1324</IssueID>
        <Title>SerializerGenerationManager should not be a static class</Title>
        <Description>`RoslynCodeGenerator` is the only class which calls into `SerializerGenerationManager`, so an instance can be held by that class.
</Description>
        <CreatedDate>23/01/2016</CreatedDate>
        <ClosedDate>02/02/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1357</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Coreclr compatibility: Delegate.Method -&gt; Delegate.GetMethodInfo()</Title>
    <Description>#368;

Even though `GetMethodInfo` is located in `System.Reflection` namespace, in .Net 4.5.\* it's only a accessor of  del's `Method` property: 
![devenv_2016-01-30_11-56-53](https://cloud.githubusercontent.com/assets/5787619/12695015/b92fa962-c748-11e5-81f1-3fae6f593d7c.png)
</Description>
    <CreatedDate>30/01/2016</CreatedDate>
    <ClosedDate>31/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1357</PullRequestID>
        <IssueID>368</IssueID>
        <Title>Contribution idea: Port Orleans to coreclr</Title>
        <Description>Port the Orleans code to run on [coreclr](https://github.com/dotnet/coreclr).
Some APIs from the full .NET got deprecated in coreclr (aka .NET Core), mainly around files and reflection, but at large the porting effort shouldn't be too big. This will allow to run Orleans efficiently across different platforms.

---

**Tools:**
[Coreclr api search](https://packagesearch.azurewebsites.net/)
[.NET API Usage](http://dotnetstatus.azurewebsites.net/usage)
[.NET Portability Analyzer](https://visualstudiogallery.msdn.microsoft.com/1177943e-cfb7-4822-a8a6-e56c7905292b) - download and Install
[.NET Portability Analyzer Usage](http://blogs.msdn.com/b/dotnet/archive/2014/08/06/leveraging-existing-code-across-net-platforms.aspx)

**Progress so far**: 
[CoreCLR milestones](https://github.com/dotnet/orleans/issues?utf8=%E2%9C%93&amp;q=milestone%3ACoreCLR)
~~[ApiPortabilityAnalysis result file for all projects](https://github.com/dotnet/orleans/blob/master/misc/ApiPortabilityAnalysis-AllProjects-October.08.2015.htm)~~ (let's find an appropriate place to place updates of this file, please don't pollute the master branch with these big reports)

---

There are 2 types of issues: 
(a) easy, just change an API - we have done all those.
(b) deeper profound issues where API was deprecated or changed significantly and we will need to investigate other ways to achieve the same functionality:

**Need to investigate and consider profound rewrite** - feel to open a GH issue with ideas on how to handle each one of those issues (separate issue for each) : 
High priority
- [ ] Create a v2 branch that changes target for Orleans to .NET Standard 1.6
  - Ideally still use csproj as in https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild (this means that we'll have to update from .NET 4.5.1 in all dependent projects)
- [ ] Remove usage of App Domains for scanning https://github.com/dotnet/coreclr/issues/919
  - [ ] Revisit Assembly Loading (`LoadFrom` -&gt; `AsemblyLoadContext`, Location,...) #2025
- [ ] Provide an alternative fallback serializer (BinaryFormatter is not supported in .NET Core). The biggest concern is serializing exceptions, as they are not typically part of the grain interfaces, and we don't generate Orleans serializers for all exceptions in the system. We have a few workarounds in prototype that need to be enhanced.
- [ ] `PerformanceCounter` - not supported in .NET Core.
- [ ] `Environment.UserName`
- [ ] `CallContext.LogicalSetData` - potentially replace with `AsyncLocal&lt;T&gt;`
- [ ] Update codegen to be more aggressive and generate serializers for Exception types
- [ ] `SerializationInfo` - not supported in .NET Core.

2nd priority
- [ ] Compile time codegen working with new dotnet cli tooling (although be aware that the tooling will drop support for `project.json` once it RTMs, and we are not sure if the build tools will work once they start using csproj once again)
  - [ ] Avoid having OrleansCodeGenerator depend on Orleans project, since that creates a circular dependency to getting codegen to work easily (especially since Orleans.dll requires build time codegen). This is a nice to have, but not required if we solve the previous item in some other way.
- [ ] Allow `TestCluster` to work without creating new AppDomains for each silo (for example, by leveraging containers, or spawning and managing new processes)

3rd priority
- [ ] Separate test projects for each provider that brings in a new dependency (ideally even if that dependency is also supported in .NET Core, otherwise we would need to port the entire codebase before we can start testing each individual component we port)
- [ ] CI servers run tests in many platforms
- [x] `System.Runtime.Serialization.FormatterServices.GetUninitializedObject`
- [x] `System.Diagnostics.Process.Handle` -&gt; `System.Diagnostics.Process.SafeHandle`

---

**Already done issues (for progress tracking):**
- [x] `Type.IsInterface`-&gt; `Type.GetTypeInfo.IsInterface` (`IsClass`, `IsGenericType` , `IsAbstract`, `IsPrimitive`, `IsEnum`).
- [x] `Type` -&gt; `TypeInfo` for most members (in Orleans code, and code generated by OrleansCodeGenerator) #1783 #1894 #1997 
- [x] `TextReader.Close` -&gt; `TextReader.Dispose` #609 #2034
- [x] `Socket.Close` -&gt; `Socket.Dispose`
- [x] `Delegate.CreateDelegate` -&gt; `MethodInfo.CreateDelegate`
- [x] `ApplicationException(string)`
- [x] `System.Data` and `System.Transactions` - used in SQL utils. Create a separate OrleansSQLUtils project and move all [Relational Storage](https://github.com/dotnet/orleans/tree/master/src/Orleans/RelationalStorage) code there.
- [x] `XmlTextWriter` and `XMLNode.SelectNodes`.
- [x] `Dns.GetHostAddresses`.
- [x] `System.String.ToLower(CultureInfo.InvariantCulture)` -&gt; Use `CultureInfo.TextInfo.ToLower(String)` instead
- [x] `System.UriTypeConverter`.
- [x] `System.CodeDom.CodeTypeParameter`.
- [x] `BinaryFormatter.Serialize` - solved via #1047.
- [x] `System.Management.ManagementObjectCollection` -  not supported in .NET Core. Investigate and propose alternative options (if `ManagementObject` itself is supported). We use it now in one place, to find TotalPhysicalMemory. Solved via #1048
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1354</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Developing-a-Grain.md more refactoring</Title>
    <Description>part of #1264.
</Description>
    <CreatedDate>29/01/2016</CreatedDate>
    <ClosedDate>29/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1354</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1351</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Stop a stuck BlockingCollection.Take operation that caused thread leak on the client.</Title>
    <Description>Fixes #1350.
</Description>
    <CreatedDate>29/01/2016</CreatedDate>
    <ClosedDate>01/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1351</PullRequestID>
        <IssueID>1350</IssueID>
        <Title>Repeated call to Orleans.GrainClient.Initialize cause growing thread count</Title>
        <Description>We have a service which starts before the silos have finished starting up.  We are seeing an increasing thread count if there is a delay getting the silos up.

This code produces the same effect.

&gt; ``

The thread count increases on each call to `GrainClient.Initialize`, occasionally the total count will decrement, but overall the thread count continues to climb, and does not drop (even after hours with no more calls to `GrainClient.Initialize`

It appears that a majority of the threads have a stack similar to this, waiting at the `Orleans.RuntimeQueue.Take` on `System.Collections.Concurrent.BlockingCollection&lt;Message&gt;.TryTakeWithNoTimeValidation`

&gt; mscorlib.dll!System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout+0x90
&gt; mscorlib.dll!System.Threading.SemaphoreSlim.Wait+0x31a
&gt; System.dll!System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation+0x15d
&gt; System.dll!System.Collections.Concurrent.BlockingCollection`1.TryTake+0xc1
&gt; System.dll!System.Collections.Concurrent.BlockingCollection`1.Take+0x22
&gt; Orleans.dll!Orleans.Runtime.RuntimeQueue`1.Take+0x1a
&gt; Orleans.dll!Orleans.Messaging.ProxiedMessageCenter.WaitMessage+0x3e
&gt; Orleans.dll!Orleans.OutsideRuntimeClient.RunClientMessagePump+0x55
&gt; Orleans.dll!&lt;&gt;c__DisplayClass3.&lt;StartInternal&gt;b__2+0x2f
&gt; mscorlib.dll!System.Threading.Tasks.Task.Execute+0x6e
&gt; mscorlib.dll!System.Threading.ExecutionContext.RunInternal+0x285
&gt; mscorlib.dll!System.Threading.ExecutionContext.Run+0x9
&gt; mscorlib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal+0x2c5
&gt; mscorlib.dll!System.Threading.Tasks.Task.ExecuteEntry+0x85
&gt; mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch+0x1ea
</Description>
        <CreatedDate>29/01/2016</CreatedDate>
        <ClosedDate>01/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1347</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Repros for #1346 and #1349</Title>
    <Description>### Repro for #1346:

Failing tests (ignored to pass CI):
- FSharpGrains_Ping_IntOption_Some
- SerializationTests_FSharp_IntOption_Some

See #1346 for details
### Repro for #1349:

Codegen failure causes the build to fail. Some code has been commented out in order to pass CI:
- To repro the codegen failure: uncomment lines 9-11 from `IGeneratorTestDerivedFromFSharpInterfaceInExternalAssemblyGrain.cs`
- To test correct generation once codegenm succeeds:
  - uncomment the grain class in `GeneratorTestDerivedFromFSharpInterfaceInExternalAssemblyGrain.cs`
  - uncomment lines  260-267 from `GeneratorGrainTest.cs`

&gt; The relevant commented code can also be found by searching for `#1349` 
</Description>
    <CreatedDate>28/01/2016</CreatedDate>
    <ClosedDate>04/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1347</PullRequestID>
        <IssueID>1346</IssueID>
        <Title>F# option (FSharpOption&lt;T&gt;) fails to deserialize</Title>
        <Description>Adding an interface that uses `FSharpOption&lt;T&gt;` results in compile-time serializers being generated. This breaks the deserialization of the F# `option` type.
</Description>
        <CreatedDate>28/01/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1347</PullRequestID>
        <IssueID>1346</IssueID>
        <Title>F# option (FSharpOption&lt;T&gt;) fails to deserialize</Title>
        <Description>Adding an interface that uses `FSharpOption&lt;T&gt;` results in compile-time serializers being generated. This breaks the deserialization of the F# `option` type.
</Description>
        <CreatedDate>28/01/2016</CreatedDate>
        <ClosedDate>28/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1347</PullRequestID>
        <IssueID>1349</IssueID>
        <Title>Code generation fails for grain interfaces derived from interface(s) in an external F# assembly</Title>
        <Description>This worked fine in all versions of Orleans up to and including 1.0.9.
We've tried to work around this by moving the interface definitions to C# and hit #1346. 

Fix and repro coming shortly.
</Description>
        <CreatedDate>29/01/2016</CreatedDate>
        <ClosedDate>05/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1347</PullRequestID>
        <IssueID>1349</IssueID>
        <Title>Code generation fails for grain interfaces derived from interface(s) in an external F# assembly</Title>
        <Description>This worked fine in all versions of Orleans up to and including 1.0.9.
We've tried to work around this by moving the interface definitions to C# and hit #1346. 

Fix and repro coming shortly.
</Description>
        <CreatedDate>29/01/2016</CreatedDate>
        <ClosedDate>05/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1345</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Initialize SerializationManager before CodeGeneratorManager</Title>
    <Description>fixes #1344
</Description>
    <CreatedDate>28/01/2016</CreatedDate>
    <ClosedDate>28/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1345</PullRequestID>
        <IssueID>1344</IssueID>
        <Title>Silo crashes at start-up attempting to generate serializers</Title>
        <Description>This happens when assemblies containing types eligible for serializer generation have been already loaded at the time the Silo is initialized. In this situation `RoslynCodeGenerator` attempts to use `SerializationManager` prior to the latter having been initialized.

PR coming shortly.
</Description>
        <CreatedDate>28/01/2016</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1342</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Injection of grain factory</Title>
    <Description>Addresses "Dependency Injection: register IGrainFactory #988"

To inject the grain factory, we need only to add it to the services collection.  However, we can't do this cleanly because the Microsoft.Extensions.DependencyInjection libraries have not been released, so we can't access them directly from within core, and GrainFactory is an internal class that can't be accessed by the DI library.

Given that there was no clean solution, I compromised on the side of simplicity.  As an interim workaround I added a public singleton instance of grain factory as a -HACK- so we could register it in the services collection for DI.  This will be removed when Microsoft.Extensions.DependencyInjection is released and we can get rid of the OrleansDependencyInjection assembly.

Thoughts?
</Description>
    <CreatedDate>27/01/2016</CreatedDate>
    <ClosedDate>03/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1342</PullRequestID>
        <IssueID>988</IssueID>
        <Title>Dependency Injection: register IGrainFactory</Title>
        <Description>Currently I cannot construct objects which require `IGrainFactory` using DI in Orleans because the implementation is not registered.

Example of a failure scenario:

``

 Is there a good reason for `IGrainFactory` (and friends?) not to be in the container?
</Description>
        <CreatedDate>04/11/2015</CreatedDate>
        <ClosedDate>21/09/2016</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1340</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Cleanup NodeConfig management in ClusterConfiguration.</Title>
    <Description>This is another pass at addressing comments in Stream Recovery Tests #1289
First pass was GetOrAddConfigurationForNode #1313 

The issue here is that the silo nodes are optional in the configuration, so code that needs them tends to use a 'get or create' pattern.  This pattern was coded into the original GetConfigurationForNode call.  From the call name it's not clear that one would be creating the node if it does not exist, when all it appears to do is access it.

Since the actual behavior was 'get or create' the first pass at addressing this ( #1313) simply renamed the operation to GetOrAddConfigurationForNode, to make it more clear what the call was actually doing.  This change introduced no new capabilities, just made the existing behavior more clear.  There remained no means of querying the configuration node without creating it.

This PR breaks the functionality up into the following functions, affording users better control over the node management.

```
    public NodeConfiguration CreateNodeConfigurationForSilo(string siloName);
    public bool TryGetNodeConfigurationForSilo(string siloName, out NodeConfiguration siloNode);
    public NodeConfiguration GetOrCreateNodeConfigurationForSilo(string siloName)
```
</Description>
    <CreatedDate>27/01/2016</CreatedDate>
    <ClosedDate>03/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1340</PullRequestID>
        <IssueID>1289</IssueID>
        <Title>Stream Recovery Tests</Title>
        <Description>Added testing for some basic stream recovery tests.
Tests use test generated streams
Tests are limited to implicit subscriptions
Tests transient stream processing errors, exercising delivery retry and stream rewind logic.
Tests non-transient stream processing errors, exercising exhaustion of delivery retries and error notification.
</Description>
        <CreatedDate>16/01/2016</CreatedDate>
        <ClosedDate>20/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1340</PullRequestID>
        <IssueID>1313</IssueID>
        <Title>GetOrAddConfigurationForNode</Title>
        <Description>Rename GetConfigurationForNode to GetOrAddConfigurationForNode.

Follow-up for comments in Stream Recovery Tests #1289 
</Description>
        <CreatedDate>21/01/2016</CreatedDate>
        <ClosedDate>22/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1340</PullRequestID>
        <IssueID>1313</IssueID>
        <Title>GetOrAddConfigurationForNode</Title>
        <Description>Rename GetConfigurationForNode to GetOrAddConfigurationForNode.

Follow-up for comments in Stream Recovery Tests #1289 
</Description>
        <CreatedDate>21/01/2016</CreatedDate>
        <ClosedDate>22/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1332</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Fixed a bug of not properly handling DeactivateOnIdle inside OnActivateAsync by throwing Exception.</Title>
    <Description>Take 2 on #1325.

We used to just ignore the `DeactivateOnIdle` call made inside OnActivateAsync.
As proposed by @sergeybykov in #1325, `DeactivateOnIdle`  should throw if called from within `OnActivateAsync`.

I disagree with this semantics (I think the right fix is to cause grain to Deactivate immediately, which will also call `OnDeactivateAsync`), but there appears to be a wider opinion that this is the right behavior and since this fix is better than just completely ignoring, I prefer a sub-optimal fix rather than leaving a hanging bug (I don't like leaving hanging bugs).
</Description>
    <CreatedDate>26/01/2016</CreatedDate>
    <ClosedDate>27/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1332</PullRequestID>
        <IssueID>1325</IssueID>
        <Title>Fixed a bug of not properly handling DeactivateOnIdle inside OnActivateAsync.</Title>
        <Description>Discovered by @richorama while working of ["Raft on Orleans"](https://github.com/richorama/OrleansRaft/issues/1).

We used to just ignore the `DeactivateOnIdle` call made inside `OnActivateAsync` (there was just never a scenario for a grain to refuse to activate cleanly).
This fixes the bug.

Notice that refusing to activate via `DeactivateOnIdle` differs from throwing exception from within  `OnActivateAsync` in that in the former case `OnDeactivateAsync` will be called (since `OnActivateAsync` succeeded, thus we have to call `OnDeactivateAsync` before deactivating this activation). In the exception case  `OnDeactivateAsync` will not be called.
</Description>
        <CreatedDate>23/01/2016</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1332</PullRequestID>
        <IssueID>1325</IssueID>
        <Title>Fixed a bug of not properly handling DeactivateOnIdle inside OnActivateAsync.</Title>
        <Description>Discovered by @richorama while working of ["Raft on Orleans"](https://github.com/richorama/OrleansRaft/issues/1).

We used to just ignore the `DeactivateOnIdle` call made inside `OnActivateAsync` (there was just never a scenario for a grain to refuse to activate cleanly).
This fixes the bug.

Notice that refusing to activate via `DeactivateOnIdle` differs from throwing exception from within  `OnActivateAsync` in that in the former case `OnDeactivateAsync` will be called (since `OnActivateAsync` succeeded, thus we have to call `OnDeactivateAsync` before deactivating this activation). In the exception case  `OnDeactivateAsync` will not be called.
</Description>
        <CreatedDate>23/01/2016</CreatedDate>
        <ClosedDate>28/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1329</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Allowing for IGrainStateMapFactory to be created in a external assembly</Title>
    <Description>Allowing for a IGrainStateMapFactory to be created in a external assembly.

Apply PR #1321 to master branch - cherry picked 16b50d9581e238f5e4d5eebd75fd201137edd5cf
</Description>
    <CreatedDate>25/01/2016</CreatedDate>
    <ClosedDate>25/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1329</PullRequestID>
        <IssueID>1321</IssueID>
        <Title>Allowing for a IGrainStateMapFactory to be created in a external assembly</Title>
        <Description>in order to be able to create a IGrainStateMapFactory in non orleans assembly I need these internals to be public.
</Description>
        <CreatedDate>22/01/2016</CreatedDate>
        <ClosedDate>25/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1326</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>refactored grain documentation</Title>
    <Description>part of #1264.
main changes :
- moved grain persistence documentation from Developing-a-Grain.md to a new section Grain-Persistence.md under programmer`s guide
- moved documentation of presence service sample from Developing-a-Grain.md to Presence-Service.md
- moved "Grain interfaces" and "Grain reference" sections from Grains.md to Developing-a-Grain.md
</Description>
    <CreatedDate>23/01/2016</CreatedDate>
    <ClosedDate>28/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1326</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1319</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Generate serializer for type arguments of IAsyncObserver&lt;T&gt;</Title>
    <Description>#1316
</Description>
    <CreatedDate>22/01/2016</CreatedDate>
    <ClosedDate>24/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1319</PullRequestID>
        <IssueID>1316</IssueID>
        <Title>Need to try generate serializer for type arguments of IAsyncObserver&lt;T&gt;</Title>
        <Description>From https://github.com/dotnet/orleans/issues/1286.

With `FireAndForgetDelivery=true` SMS streams silently lose events if those fail to serialize. While there is a design question of how surface such failures, a related mitigation is to include concrete type arguments of classes that implement `IAsyncObserver&lt;T&gt;` in the list of candidates for serializer generation.

If we find a class `Foo : IAsyncObserver&lt;Bar&gt;` we can try to generate a serializer for `Bar` to reduce the probability of the failure and to improve performance of passing event of that type.
</Description>
        <CreatedDate>22/01/2016</CreatedDate>
        <ClosedDate>25/01/2016</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1313</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>GetOrAddConfigurationForNode</Title>
    <Description>Rename GetConfigurationForNode to GetOrAddConfigurationForNode.

Follow-up for comments in Stream Recovery Tests #1289 
</Description>
    <CreatedDate>21/01/2016</CreatedDate>
    <ClosedDate>22/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1313</PullRequestID>
        <IssueID>1289</IssueID>
        <Title>Stream Recovery Tests</Title>
        <Description>Added testing for some basic stream recovery tests.
Tests use test generated streams
Tests are limited to implicit subscriptions
Tests transient stream processing errors, exercising delivery retry and stream rewind logic.
Tests non-transient stream processing errors, exercising exhaustion of delivery retries and error notification.
</Description>
        <CreatedDate>16/01/2016</CreatedDate>
        <ClosedDate>20/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1312</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>Event hub stream provider recovery</Title>
    <Description>Added rewind/recoverability to EventHubStreamProvider

This work is related to "Recoverable Event Hub Persistent Stream Provider #1096"
It is the first part of stage 4.

Update EventHubStreamProvider to be recoverable.
- Update EventHubQueueAdapter to use PooledQueueCache.
- Add recoverable stream tests comparable to those built against GeneratorStreamProvider.

Does not include:
- EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
</Description>
    <CreatedDate>21/01/2016</CreatedDate>
    <ClosedDate>29/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1312</PullRequestID>
        <IssueID>1096</IssueID>
        <Title>Recoverable Event Hub Persistent Stream Provider</Title>
        <Description>Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate events are allowed.  For instance, a stream of events e1, e2, e3, e4, e5 can be delivered to a consumer ordered as e1, e2, e3, e4, e1, e2, e5, but can’t be delivered in the order e1, e4, e5, e2, e3, e4, e5.
- Recoverable/Rewindable – Consumers can recover from transient errors in stream processing by resuming stream consumption from the sequence token of the last successfully processed event.  Since this is intended only to compensate for transient stream processing errors, only 30 minutes of recoverable stream data is required.
- Persistent streams – Events must be persisted upon generation.  Processing of the event can be delayed, but persistence of the event must be immediate.
- Performant – Must support stream delivery of 2000+ events per second per silo with below 40% CPU utilization.

These requirements came from [343 Industries](https://www.halowaypoint.com/en-us), an early adopter and co-developer of Orleans streaming technology.  [343 Industries](https://www.halowaypoint.com/en-us) developed a recoverable stream provider using EventHub.  This EventHub Stream Provider is being contributed to the Orleans open source project.  During the process of porting this technology to Orleans, the stream provider will be refactored and reorganized to conform to Orleans open source conventions, but the core architecture and requirements must be preserved.

This stream provider will be introduced in the following stages (plan subject to change):
1. Minimal non-recoverable EventHub stream provider
   - Introduction of a new ServiceBus specific project.  OrleansServiceBus.  This will be comparable to the azure specific project OrleansAzureUtils.
   - Development of EventHubQueueAdapter comparable to AzureQueueAdapter, with similar limitations.
     1. Non-rewindable
     2. Will use simple queue cache.
   - Define an EventHubStreamProvider that is a persistent stream provider that uses the EventHubAdapter.
   - Add test coverage for EventHubStreamProvider comparable to that of AzureQueueStreamProvider.
2. Introduce PooledQueueCache (open to better name).  This will be an implementation of the IQueueCache interface which can cache up to 30 minutes of data while minimizing impact to garbage collection.
   - This implementation will cache raw serialized events in pooled blocks of memory that are reused and never collected by garbage collection system.
   - Add PooledQueueCache BVT tests.
3. Add recoverable stream tests using the test stream provider GeneratorStreamProvider with a PooledQueueCache.
4. Update EventHubStreamProvider to be recoverable.
   - Update EventHubQueueAdapter to use PooledQueueCache.
   - EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
   - Add recoverable stream tests comparable to those built against GeneratorStreamProvider.
</Description>
        <CreatedDate>01/12/2015</CreatedDate>
        <ClosedDate>25/02/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1308</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>moved benefits from intro to new benefits.md and merged core-concepts with intro</Title>
    <Description>There was duplication so I merged core-concepts with the introduction. 
also moved the benefits from the introduction to its own document and added link. Part of #1264.
</Description>
    <CreatedDate>20/01/2016</CreatedDate>
    <ClosedDate>20/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1308</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1307</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>moved gettings-started-guide to top</Title>
    <Description>well, it's getting started. doesn't seem right it is after installation :) Part of #1264.
</Description>
    <CreatedDate>20/01/2016</CreatedDate>
    <ClosedDate>20/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1307</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1306</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>added to silos.md</Title>
    <Description> Part of #1264.
</Description>
    <CreatedDate>20/01/2016</CreatedDate>
    <ClosedDate>20/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1306</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1301</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>dVakulen</FixedByID>
    <Title>Don't break outstanding requests for system targets</Title>
    <Description>Addresses #1299
</Description>
    <CreatedDate>19/01/2016</CreatedDate>
    <ClosedDate>20/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1301</PullRequestID>
        <IssueID>1299</IssueID>
        <Title>GrainClient initialization fails quickly when no silos are available yet</Title>
        <Description>Since merging #1017, the dev/test experience for `GrainClient` is a little rough. If I start a client + silo simultaneously from VS, then the client will fail to initialize several times before the silo completes its own initialization. This behavior is worse than before and the error is opaque.

Initialization throws this exception from https://github.com/dotnet/orleans/blob/8cf4d8efb018c84558cb7e4b67f42f1647c26bc2/src/Orleans/Runtime/OutsideRuntimeClient.cs#L291:

``

Could we have `GrainClient` wait until it successfully identifies an active silo before continuing with initialization?
</Description>
        <CreatedDate>19/01/2016</CreatedDate>
        <ClosedDate>05/10/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1296</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Documentation cleanups following #1264</Title>
    <Description>Documentation cleanups following #1264
</Description>
    <CreatedDate>18/01/2016</CreatedDate>
    <ClosedDate>19/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1296</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1294</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>two new top level sections: Configuration and Programmer's Guide</Title>
    <Description>Part of #1264.
I think that current documentation menu can be improved by this PR. I haven't removed any page (other than the link to Runtime Implementation Details - which only contains links which I've moved one level up).
</Description>
    <CreatedDate>17/01/2016</CreatedDate>
    <ClosedDate>18/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1294</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1293</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Update Samples-Overview, fix link</Title>
    <Description> Part of #1264.
</Description>
    <CreatedDate>16/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1293</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1292</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Update Samples-Overview</Title>
    <Description>linked to the prerequisites section so we don't have to update in both places. Part of #1264.
</Description>
    <CreatedDate>16/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1292</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1291</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Update Introduction.md</Title>
    <Description>minor updates that seem right to me. Part of #1264.
</Description>
    <CreatedDate>16/01/2016</CreatedDate>
    <ClosedDate>18/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1291</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1290</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>Update Prerequisites.md</Title>
    <Description>as part of #1264, I'm going through the documentation and updating as necessary.
</Description>
    <CreatedDate>16/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1290</PullRequestID>
        <IssueID>1264</IssueID>
        <Title>Refactor documentation and add MySql config examples</Title>
        <Description>It seems like a good time to update the documentation to include `MySql`. 
While doing that, I want to introduce a new top level section name `Configuration`. Current configuration documentation is scattered across sections and mixes theory, implementation details and configuration options. The new section should be the only one that contains sample xmls and provide an easy to follow enumeration of configuration options. 
@jthelin, @gabikliot, @sergeybykov, @veikkoeeva what do you think ?
PS - do you know of a good editor of md files?
</Description>
        <CreatedDate>09/01/2016</CreatedDate>
        <ClosedDate>23/08/2017</ClosedDate>
        <Labels>
          <Label>documentation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1288</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>galvesribeiro</FixedByID>
    <Title>Coreclr compatibility: xUnit test migration (Tester project)</Title>
    <Description>This PR has the following goals:
1. Remove the MSTest runner from **Tester** project and replace it with xunit.runner
2. Keep MSTest assertion APIs for now so there will be no changes on the assertion and test logic so far
3. Keep the test code with the minimal changes as possible.
4. Make the _Tester_  project to run on Jenking/CI while keeping **TesterInternal** on MSTests.
5. Move one step forward to #368 by removing the dependency at some point of MSTest and adopting xunit which is the most supported test runner for DNX/CoreCLR and is what ASP.Net and CoreCLR teams are already using on it.

After this PR get Merged we will get 2 more steps:
1. Migrate **TesterInternal** to xunit.runner
2. Migrate the assertion APIs to something else but MSTest ones
</Description>
    <CreatedDate>15/01/2016</CreatedDate>
    <ClosedDate>04/02/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1288</PullRequestID>
        <IssueID>368</IssueID>
        <Title>Contribution idea: Port Orleans to coreclr</Title>
        <Description>Port the Orleans code to run on [coreclr](https://github.com/dotnet/coreclr).
Some APIs from the full .NET got deprecated in coreclr (aka .NET Core), mainly around files and reflection, but at large the porting effort shouldn't be too big. This will allow to run Orleans efficiently across different platforms.

---

**Tools:**
[Coreclr api search](https://packagesearch.azurewebsites.net/)
[.NET API Usage](http://dotnetstatus.azurewebsites.net/usage)
[.NET Portability Analyzer](https://visualstudiogallery.msdn.microsoft.com/1177943e-cfb7-4822-a8a6-e56c7905292b) - download and Install
[.NET Portability Analyzer Usage](http://blogs.msdn.com/b/dotnet/archive/2014/08/06/leveraging-existing-code-across-net-platforms.aspx)

**Progress so far**: 
[CoreCLR milestones](https://github.com/dotnet/orleans/issues?utf8=%E2%9C%93&amp;q=milestone%3ACoreCLR)
~~[ApiPortabilityAnalysis result file for all projects](https://github.com/dotnet/orleans/blob/master/misc/ApiPortabilityAnalysis-AllProjects-October.08.2015.htm)~~ (let's find an appropriate place to place updates of this file, please don't pollute the master branch with these big reports)

---

There are 2 types of issues: 
(a) easy, just change an API - we have done all those.
(b) deeper profound issues where API was deprecated or changed significantly and we will need to investigate other ways to achieve the same functionality:

**Need to investigate and consider profound rewrite** - feel to open a GH issue with ideas on how to handle each one of those issues (separate issue for each) : 
High priority
- [ ] Create a v2 branch that changes target for Orleans to .NET Standard 1.6
  - Ideally still use csproj as in https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild (this means that we'll have to update from .NET 4.5.1 in all dependent projects)
- [ ] Remove usage of App Domains for scanning https://github.com/dotnet/coreclr/issues/919
  - [ ] Revisit Assembly Loading (`LoadFrom` -&gt; `AsemblyLoadContext`, Location,...) #2025
- [ ] Provide an alternative fallback serializer (BinaryFormatter is not supported in .NET Core). The biggest concern is serializing exceptions, as they are not typically part of the grain interfaces, and we don't generate Orleans serializers for all exceptions in the system. We have a few workarounds in prototype that need to be enhanced.
- [ ] `PerformanceCounter` - not supported in .NET Core.
- [ ] `Environment.UserName`
- [ ] `CallContext.LogicalSetData` - potentially replace with `AsyncLocal&lt;T&gt;`
- [ ] Update codegen to be more aggressive and generate serializers for Exception types
- [ ] `SerializationInfo` - not supported in .NET Core.

2nd priority
- [ ] Compile time codegen working with new dotnet cli tooling (although be aware that the tooling will drop support for `project.json` once it RTMs, and we are not sure if the build tools will work once they start using csproj once again)
  - [ ] Avoid having OrleansCodeGenerator depend on Orleans project, since that creates a circular dependency to getting codegen to work easily (especially since Orleans.dll requires build time codegen). This is a nice to have, but not required if we solve the previous item in some other way.
- [ ] Allow `TestCluster` to work without creating new AppDomains for each silo (for example, by leveraging containers, or spawning and managing new processes)

3rd priority
- [ ] Separate test projects for each provider that brings in a new dependency (ideally even if that dependency is also supported in .NET Core, otherwise we would need to port the entire codebase before we can start testing each individual component we port)
- [ ] CI servers run tests in many platforms
- [x] `System.Runtime.Serialization.FormatterServices.GetUninitializedObject`
- [x] `System.Diagnostics.Process.Handle` -&gt; `System.Diagnostics.Process.SafeHandle`

---

**Already done issues (for progress tracking):**
- [x] `Type.IsInterface`-&gt; `Type.GetTypeInfo.IsInterface` (`IsClass`, `IsGenericType` , `IsAbstract`, `IsPrimitive`, `IsEnum`).
- [x] `Type` -&gt; `TypeInfo` for most members (in Orleans code, and code generated by OrleansCodeGenerator) #1783 #1894 #1997 
- [x] `TextReader.Close` -&gt; `TextReader.Dispose` #609 #2034
- [x] `Socket.Close` -&gt; `Socket.Dispose`
- [x] `Delegate.CreateDelegate` -&gt; `MethodInfo.CreateDelegate`
- [x] `ApplicationException(string)`
- [x] `System.Data` and `System.Transactions` - used in SQL utils. Create a separate OrleansSQLUtils project and move all [Relational Storage](https://github.com/dotnet/orleans/tree/master/src/Orleans/RelationalStorage) code there.
- [x] `XmlTextWriter` and `XMLNode.SelectNodes`.
- [x] `Dns.GetHostAddresses`.
- [x] `System.String.ToLower(CultureInfo.InvariantCulture)` -&gt; Use `CultureInfo.TextInfo.ToLower(String)` instead
- [x] `System.UriTypeConverter`.
- [x] `System.CodeDom.CodeTypeParameter`.
- [x] `BinaryFormatter.Serialize` - solved via #1047.
- [x] `System.Management.ManagementObjectCollection` -  not supported in .NET Core. Investigate and propose alternative options (if `ManagementObject` itself is supported). We use it now in one place, to find TotalPhysicalMemory. Solved via #1048
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1284</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Check declaring types when performing accessibility checks for code gen.</Title>
    <Description>Fixes #1283.

I haven't run tests on this, it's just a quick fix, so we'll see what CI says.

The change is this: `IsTypeIsInaccessibleForSerialization` now has only one path which can return `false` (signifying that a type is accessible for serialization). Each check can trigger short-circuiting &amp; return `true` if a type is inaccessible, but otherwise execution will fall through to the next check.

Hopefully the code is easier to reason about now that there is only one happy path.

We also check the accessibility of the declaring type to fix #1283.
</Description>
    <CreatedDate>14/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1284</PullRequestID>
        <IssueID>1283</IssueID>
        <Title>CodeGen Serializer is generated for private nested class with enum</Title>
        <Description>CodeGen will try to generate a serializer for the private nested class B in the following code.

If A is not generic, everything is fine.
If B is public everything is fine.
If enum is in A (private or public) everything is fine.
If there is no enum in C, everything is find.
But put them all together, and Codegen thinks it should generate a serializer for the private nested class 
B.
No idea why :)
Very amusing though.

``
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>16/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1284</PullRequestID>
        <IssueID>1283</IssueID>
        <Title>CodeGen Serializer is generated for private nested class with enum</Title>
        <Description>CodeGen will try to generate a serializer for the private nested class B in the following code.

If A is not generic, everything is fine.
If B is public everything is fine.
If enum is in A (private or public) everything is fine.
If there is no enum in C, everything is find.
But put them all together, and Codegen thinks it should generate a serializer for the private nested class 
B.
No idea why :)
Very amusing though.

``
</Description>
        <CreatedDate>14/01/2016</CreatedDate>
        <ClosedDate>16/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1280</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>sebastianburckhardt</FixedByID>
    <Title>fix deepcopy issue #1278</Title>
    <Description>As discussed in #1278, there was a bug in SerializerGenerator.cs causing shallow copying in cases where a field had an auto getter.

I fixed the bug and added unit tests for deep copy, to avoid regressions in the future.
</Description>
    <CreatedDate>13/01/2016</CreatedDate>
    <ClosedDate>14/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1280</PullRequestID>
        <IssueID>1278</IssueID>
        <Title>DeepCopier does shallow copy</Title>
        <Description>Perhaps I am misunderstanding how this is intended to work... but I am using a simple grain state definition

``

Is this is intentionally designed to be this way? That seems confusing -- I would have expected the deep copy to be semantically equivalent to serialization followed by deserialization. What is the right way to make a deep copy efficiently? 
</Description>
        <CreatedDate>12/01/2016</CreatedDate>
        <ClosedDate>14/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1270</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>centur</FixedByID>
    <Title>Make Namespace access modifier public in ImplicitStreamSubscriptionAttribute. Add Provider property.</Title>
    <Description>Issue #1266 : update Namespace access modifier to public. Add Provider property and create constructor which takes it as a second parameter.
</Description>
    <CreatedDate>11/01/2016</CreatedDate>
    <ClosedDate>15/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1270</PullRequestID>
        <IssueID>1266</IssueID>
        <Title>What was the reason to mark ImplicitStreamSubscriptionAttribute.Namespace property internal</Title>
        <Description>Hi, I have a question - what is the reason behind having Namespace property as internal in _ImplicitStreamSubscriptionAttribute_:

``

which allows us to subscribe grains automatically in certain cases.
</Description>
        <CreatedDate>10/01/2016</CreatedDate>
        <ClosedDate>16/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1261</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Fix a race in StreamConsumer.SubscribeAsync.</Title>
    <Description>Fixes #1254 (and #1228 which describes the same problem) and hopefully also #1010.

I was able to run the setup from #1254. It did not reproduce the problem on my box by itself (most probably since my laptop is slow with not enough CPUs).
I added `await Taskk.Delay(1000);` to https://github.com/dotnet/orleans/blob/master/src/Orleans/Streams/Internal/StreamConsumer.cs#L69
in between the lines that I suspected the race was and the bug reproduced 100% reliably every time.

The fix is basically 2 lines - change the order and undo on failure.
</Description>
    <CreatedDate>09/01/2016</CreatedDate>
    <ClosedDate>12/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1261</PullRequestID>
        <IssueID>1254</IssueID>
        <Title>Orleans fails to deliver the first message to client occasionally with "don't have any subscriber for that stream. Dropping on the floor"</Title>
        <Description>Note I'm using [a stream provider](https://github.com/amamh/orleans-PipeStreamProvider) that keeps old messages and sends them always to new subscribers (recovery).  The error is not in the stream provider though, and I'll explain why.
#### Scenario:
- One message is sent on the stream
- A subscriber is added
- Subscriber expects to receive that message
#### Failure:

Sometimes, a new subscriber doesn't receive anything. This happens completely at random, there doesn't seem to be anything to force that error to occur.
#### How to reproduce:

I made a [sample project](https://incraved.cloudapp.net/owncloud/index.php/s/psLweltkCLd3W9S) that can reproduce that error.
- Run Redis\RUN.bat (needed by the stream provider)
- Run solution. This will run:
  - Silo
  - Producer (sends one message on a stream)
  - A Console client subscriber
- The console client will try to reproduce the error every second by creating a new subscriber and checking if it received the message or not. It takes maybe a minute or two until it happens. Sometimes it will occur on the first few tries. It seems to be affected by how fast the PC is and how much pressure there is on the server. A faster CPU/server will produce the error quicker.

You can also run multiple instances of the client to increase the chance of the failure happening.
#### Error message:

``
#### Notes:
- It seems like when I reduce server log from Verbose to Info, the failure happens much quicker.
- I know for sure that this problem is not caused by my custom stream provider because I can see in the log (when set to "Verbose") that:
  - IQueueCacheCursor.MoveNext is being called successfully returning "true" first time for the first message then "false" the second time because there is only one message.
  - IQueueCacheCursor.GetCurrent is being called successfuly returning the first message.
  - The error (quoted above) happens in StreamConsumerExtension.DeliverBatch inside Orleans itself after it has successfully received the message from my stream provider.
</Description>
        <CreatedDate>08/01/2016</CreatedDate>
        <ClosedDate>11/01/2016</ClosedDate>
        <Labels>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1261</PullRequestID>
        <IssueID>1228</IssueID>
        <Title>Response did not arrive on time in 00:00:30 for message. About to break its promise</Title>
        <Description>Hi,
I have a **Producer** app which subscribes to real time market data and internally doe create the Price grain (NB: I have not launched any Client).  After running for 20-25 mins, I get this exception and Prodcuer app stops working.

**Exception**:

``

That's all the code is. I am just starting the Producer (which subscribes to real time data stream from the tick DB) and after some time I get the above exception. Can anyone please point out what I am doing wrong here ?

**NB** I won't have parallel stream source here. The stream is always fired on a singled thread. If an  update comes in succession for a Grain, then internally anyways it will be queued by Orleans Grain. And it is not a CPU intensive task, I am just subscribing and forwarding.

Thanks
Angshuman
</Description>
        <CreatedDate>04/01/2016</CreatedDate>
        <ClosedDate>09/01/2016</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1261</PullRequestID>
        <IssueID>1010</IssueID>
        <Title>Bug when subscribing to stream from timer callback</Title>
        <Description>Hello everyone,
I'm having an exotic issue in Orleans.
I have a grain that has a timer, and on the timer callback function the grain subscribes to a stream.
When I subscribe with a an older token (that is in the QueueCache), I expect the grain to start consuming the messages immediately (this happens when I subscribe to a stream regularly). However, when the subscription happens inside the timer callback, the consuming does not start immediately, but only after another message enters the stream (another message has been produced).

Currently I have a workaround for this problem: In the timer callback, I call `GrainFactory.GetGrain(this.GetPrimaryKey()` (Basically calling to myself) and then with the grain i received I call the function that subscribes to the stream.

Unfortunately, I do not have enough time to look deeper into the problem (hence the workaround), but I would love to get some input if anyone has an idea why this happens.

Cheers.
</Description>
        <CreatedDate>10/11/2015</CreatedDate>
        <ClosedDate>10/02/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1261</PullRequestID>
        <IssueID>1254</IssueID>
        <Title>Orleans fails to deliver the first message to client occasionally with "don't have any subscriber for that stream. Dropping on the floor"</Title>
        <Description>Note I'm using [a stream provider](https://github.com/amamh/orleans-PipeStreamProvider) that keeps old messages and sends them always to new subscribers (recovery).  The error is not in the stream provider though, and I'll explain why.
#### Scenario:
- One message is sent on the stream
- A subscriber is added
- Subscriber expects to receive that message
#### Failure:

Sometimes, a new subscriber doesn't receive anything. This happens completely at random, there doesn't seem to be anything to force that error to occur.
#### How to reproduce:

I made a [sample project](https://incraved.cloudapp.net/owncloud/index.php/s/psLweltkCLd3W9S) that can reproduce that error.
- Run Redis\RUN.bat (needed by the stream provider)
- Run solution. This will run:
  - Silo
  - Producer (sends one message on a stream)
  - A Console client subscriber
- The console client will try to reproduce the error every second by creating a new subscriber and checking if it received the message or not. It takes maybe a minute or two until it happens. Sometimes it will occur on the first few tries. It seems to be affected by how fast the PC is and how much pressure there is on the server. A faster CPU/server will produce the error quicker.

You can also run multiple instances of the client to increase the chance of the failure happening.
#### Error message:

``
#### Notes:
- It seems like when I reduce server log from Verbose to Info, the failure happens much quicker.
- I know for sure that this problem is not caused by my custom stream provider because I can see in the log (when set to "Verbose") that:
  - IQueueCacheCursor.MoveNext is being called successfully returning "true" first time for the first message then "false" the second time because there is only one message.
  - IQueueCacheCursor.GetCurrent is being called successfuly returning the first message.
  - The error (quoted above) happens in StreamConsumerExtension.DeliverBatch inside Orleans itself after it has successfully received the message from my stream provider.
</Description>
        <CreatedDate>08/01/2016</CreatedDate>
        <ClosedDate>11/01/2016</ClosedDate>
        <Labels>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1260</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jdom</FixedByID>
    <Title>Avoid restarting the TestingSiloHost</Title>
    <Description>Previously it was restarting the silos every time a test started. Now we try to preserve the previous silo host whenever we can.

This is WIP, not that far from finishing, but I wanted to show a little progress before polishing it, in case someone was interested. I will wait for #1255 to be merged and then rebase on top of that one after fixing the issues that appear from those new tests (as I changed the UnitTestsSiloHost constructor)
</Description>
    <CreatedDate>09/01/2016</CreatedDate>
    <ClosedDate>12/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1260</PullRequestID>
        <IssueID>1255</IssueID>
        <Title>Test migration phase 8</Title>
        <CreatedDate>08/01/2016</CreatedDate>
        <ClosedDate>09/01/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1249</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Nested serialization of Guid with Json serializer.</Title>
    <Description>Fixes #1187.
</Description>
    <CreatedDate>07/01/2016</CreatedDate>
    <ClosedDate>09/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1249</PullRequestID>
        <IssueID>1187</IssueID>
        <Title>Bug in Json.NET: Guid is not properly deserialized in Json serializer</Title>
        <Description>Seems that ##752 is back again.

When turning on `UseJsonFormat="true"` in config - first silo start is working fine, data is nicely saved in json format and all looks good. On consequent runs  - Silo throws Deserialization exception on first encountered stateful grain (in my case it's current UserGrain to check permissions):

``
</Description>
        <CreatedDate>21/12/2015</CreatedDate>
        <ClosedDate>09/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1245</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jason-bragg</FixedByID>
    <Title>PooledQueueCache</Title>
    <Description>This is the initial prototype of a pooled cache for the recoverable `EventHubStreamProvider`.

See: Recoverable Event Hub Persistent Stream Provider #1096
This is approximately what is described in "2. Introduce BigQueueCache..."

At this point, this queue cache is mainly a set of components that can be assembled into a fast in memory cache.  Further development will work to wrap and simplify these components.

The main goal of this cache is to support the caching of high throughput queues (~2k+ messages / queue / second) for an extended period of time (~30 minutes of data) amounting to gigs worth of data with minimal performance degradation due to garbage collection.

Unlike the simple queue cache, this queue purges data when cache capacity is reached, regardless of whether the events have been delivered or not.  The reasons for this is that it's intended for fast recoverable real time processing, so if processing gets too far behind (~15-30 minutes) it's preferable to drop those events and process new events in a timely manner than to fall further and further behind.

This implementation currently has no mechanism for regulating backpressure from stream processing delays.

Some components this implementation includes:
- A basic object pool
- A fixed size object pool that will trigger a purge of resources when it's capacity is reached.
- A fixed size buffer that allocates blocks of data used to cached serialized message payloads
- A block of tightly packed message metadata structures for cached messages.

Testing:
- Minimal BVT tests have been added - more are needed.
- GeneratorStreamProvider has been updated to use the PooledQueueCache.  It's test now exersize this code.
</Description>
    <CreatedDate>07/01/2016</CreatedDate>
    <ClosedDate>16/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1245</PullRequestID>
        <IssueID>1096</IssueID>
        <Title>Recoverable Event Hub Persistent Stream Provider</Title>
        <Description>Much of Orleans streaming infrastructure was designed to support the following requirements:
- Ordered streams, with data duplication allowed – Events must be delivered to consumers in order.  Duplicate events are allowed.  For instance, a stream of events e1, e2, e3, e4, e5 can be delivered to a consumer ordered as e1, e2, e3, e4, e1, e2, e5, but can’t be delivered in the order e1, e4, e5, e2, e3, e4, e5.
- Recoverable/Rewindable – Consumers can recover from transient errors in stream processing by resuming stream consumption from the sequence token of the last successfully processed event.  Since this is intended only to compensate for transient stream processing errors, only 30 minutes of recoverable stream data is required.
- Persistent streams – Events must be persisted upon generation.  Processing of the event can be delayed, but persistence of the event must be immediate.
- Performant – Must support stream delivery of 2000+ events per second per silo with below 40% CPU utilization.

These requirements came from [343 Industries](https://www.halowaypoint.com/en-us), an early adopter and co-developer of Orleans streaming technology.  [343 Industries](https://www.halowaypoint.com/en-us) developed a recoverable stream provider using EventHub.  This EventHub Stream Provider is being contributed to the Orleans open source project.  During the process of porting this technology to Orleans, the stream provider will be refactored and reorganized to conform to Orleans open source conventions, but the core architecture and requirements must be preserved.

This stream provider will be introduced in the following stages (plan subject to change):
1. Minimal non-recoverable EventHub stream provider
   - Introduction of a new ServiceBus specific project.  OrleansServiceBus.  This will be comparable to the azure specific project OrleansAzureUtils.
   - Development of EventHubQueueAdapter comparable to AzureQueueAdapter, with similar limitations.
     1. Non-rewindable
     2. Will use simple queue cache.
   - Define an EventHubStreamProvider that is a persistent stream provider that uses the EventHubAdapter.
   - Add test coverage for EventHubStreamProvider comparable to that of AzureQueueStreamProvider.
2. Introduce PooledQueueCache (open to better name).  This will be an implementation of the IQueueCache interface which can cache up to 30 minutes of data while minimizing impact to garbage collection.
   - This implementation will cache raw serialized events in pooled blocks of memory that are reused and never collected by garbage collection system.
   - Add PooledQueueCache BVT tests.
3. Add recoverable stream tests using the test stream provider GeneratorStreamProvider with a PooledQueueCache.
4. Update EventHubStreamProvider to be recoverable.
   - Update EventHubQueueAdapter to use PooledQueueCache.
   - EventHubQueueAdapter to persist state that tracks offset into EventHub partition.
   - Add recoverable stream tests comparable to those built against GeneratorStreamProvider.
</Description>
        <CreatedDate>01/12/2015</CreatedDate>
        <ClosedDate>25/02/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1241</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Correctly serialize [Obsolete] fields and properties.</Title>
    <Description>Fixes #1215: in generated code, all [Obsolete] properties/fields are accessed using the IL method instead of directly in order to avoid compiler warnings/errors.
</Description>
    <CreatedDate>06/01/2016</CreatedDate>
    <ClosedDate>14/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1241</PullRequestID>
        <IssueID>1215</IssueID>
        <Title>Orleans Grain interface codegen does not properly observe Obsolete attribute with forceerror</Title>
        <Description>Codegen generates grain interface code for the copier, deepcopier, Serializer and deserializer for a property within a class tagged as obsolete and forceerror=true.

Please find the sample code to repeat this here:
Class with property that causes the problem

``

I then get 4 compiler errors(one for each time the property is used):
Error   14  'GrainInterface.TestMessage.test2' is obsolete: 'Create Compiler Error if this is used.'    C:\code\Test\GrainInterface\Properties\orleans.codegen.cs   1109    13  GrainInterface
</Description>
        <CreatedDate>29/12/2015</CreatedDate>
        <ClosedDate>14/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>1239</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Improve robustness of serializer codegen for obsolete properties &amp; fields</Title>
    <Description>Fixes #1215: in generated code, all `[Obsolete]` properties/fields are accessed using the IL method instead of directly in order to avoid compiler warnings/errors.

Enables code generation for nested classes (why not, right? Let's see if functionals pass :stuck_out_tongue:)

Improves support for Mono by not serializing `Delegate` types: the implementation of `MulticastDelegate` differs between .NET &amp; Mono.
</Description>
    <CreatedDate>06/01/2016</CreatedDate>
    <ClosedDate>06/01/2016</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>1239</PullRequestID>
        <IssueID>1215</IssueID>
        <Title>Orleans Grain interface codegen does not properly observe Obsolete attribute with forceerror</Title>
        <Description>Codegen generates grain interface code for the copier, deepcopier, Serializer and deserializer for a property within a class tagged as obsolete and forceerror=true.

Please find the sample code to repeat this here:
Class with property that causes the problem

``

I then get 4 compiler errors(one for each time the property is used):
Error   14  'GrainInterface.TestMessage.test2' is obsolete: 'Create Compiler Error if this is used.'    C:\code\Test\GrainInterface\Properties\orleans.codegen.cs   1109    13  GrainInterface
</Description>
        <CreatedDate>29/12/2015</CreatedDate>
        <ClosedDate>14/01/2016</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>601</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Fixed a bug related to codegen fails for grain interface method with a param type defined on global namespace.</Title>
    <Description>Fixes #600.
</Description>
    <CreatedDate>13/07/2015</CreatedDate>
    <ClosedDate>15/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>601</PullRequestID>
        <IssueID>600</IssueID>
        <Title>codegen fails for grain interface method with a param type defined on global namespace</Title>
        <Description>the following produces a **NullReferenceException** in codegen:

``
</Description>
        <CreatedDate>13/07/2015</CreatedDate>
        <ClosedDate>13/07/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>590</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>pherbel</FixedByID>
    <Title>Coreclr compatibility: Type -&gt; TypeInfo </Title>
    <Description>It would be a starting point for the Contribution idea: Port Orleans to coreclr #368.

It contains:
- API changes for Type - &gt; TypeInfo
- API SHA256 Hashing
- New vNext files
  - solution file (Microsoft.Orleans.vNext.sln)
  - project file (Microsoft.Orleans.Core.xproj + proejct.json)
  - global.json
  - some gitignore changes for vNext files
</Description>
    <CreatedDate>08/07/2015</CreatedDate>
    <ClosedDate>13/08/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>590</PullRequestID>
        <IssueID>368</IssueID>
        <Title>Contribution idea: Port Orleans to coreclr</Title>
        <Description>Port the Orleans code to run on [coreclr](https://github.com/dotnet/coreclr).
Some APIs from the full .NET got deprecated in coreclr (aka .NET Core), mainly around files and reflection, but at large the porting effort shouldn't be too big. This will allow to run Orleans efficiently across different platforms.

---

**Tools:**
[Coreclr api search](https://packagesearch.azurewebsites.net/)
[.NET API Usage](http://dotnetstatus.azurewebsites.net/usage)
[.NET Portability Analyzer](https://visualstudiogallery.msdn.microsoft.com/1177943e-cfb7-4822-a8a6-e56c7905292b) - download and Install
[.NET Portability Analyzer Usage](http://blogs.msdn.com/b/dotnet/archive/2014/08/06/leveraging-existing-code-across-net-platforms.aspx)

**Progress so far**: 
[CoreCLR milestones](https://github.com/dotnet/orleans/issues?utf8=%E2%9C%93&amp;q=milestone%3ACoreCLR)
~~[ApiPortabilityAnalysis result file for all projects](https://github.com/dotnet/orleans/blob/master/misc/ApiPortabilityAnalysis-AllProjects-October.08.2015.htm)~~ (let's find an appropriate place to place updates of this file, please don't pollute the master branch with these big reports)

---

There are 2 types of issues: 
(a) easy, just change an API - we have done all those.
(b) deeper profound issues where API was deprecated or changed significantly and we will need to investigate other ways to achieve the same functionality:

**Need to investigate and consider profound rewrite** - feel to open a GH issue with ideas on how to handle each one of those issues (separate issue for each) : 
High priority
- [ ] Create a v2 branch that changes target for Orleans to .NET Standard 1.6
  - Ideally still use csproj as in https://docs.microsoft.com/en-us/dotnet/articles/core/tutorials/target-dotnetcore-with-msbuild (this means that we'll have to update from .NET 4.5.1 in all dependent projects)
- [ ] Remove usage of App Domains for scanning https://github.com/dotnet/coreclr/issues/919
  - [ ] Revisit Assembly Loading (`LoadFrom` -&gt; `AsemblyLoadContext`, Location,...) #2025
- [ ] Provide an alternative fallback serializer (BinaryFormatter is not supported in .NET Core). The biggest concern is serializing exceptions, as they are not typically part of the grain interfaces, and we don't generate Orleans serializers for all exceptions in the system. We have a few workarounds in prototype that need to be enhanced.
- [ ] `PerformanceCounter` - not supported in .NET Core.
- [ ] `Environment.UserName`
- [ ] `CallContext.LogicalSetData` - potentially replace with `AsyncLocal&lt;T&gt;`
- [ ] Update codegen to be more aggressive and generate serializers for Exception types
- [ ] `SerializationInfo` - not supported in .NET Core.

2nd priority
- [ ] Compile time codegen working with new dotnet cli tooling (although be aware that the tooling will drop support for `project.json` once it RTMs, and we are not sure if the build tools will work once they start using csproj once again)
  - [ ] Avoid having OrleansCodeGenerator depend on Orleans project, since that creates a circular dependency to getting codegen to work easily (especially since Orleans.dll requires build time codegen). This is a nice to have, but not required if we solve the previous item in some other way.
- [ ] Allow `TestCluster` to work without creating new AppDomains for each silo (for example, by leveraging containers, or spawning and managing new processes)

3rd priority
- [ ] Separate test projects for each provider that brings in a new dependency (ideally even if that dependency is also supported in .NET Core, otherwise we would need to port the entire codebase before we can start testing each individual component we port)
- [ ] CI servers run tests in many platforms
- [x] `System.Runtime.Serialization.FormatterServices.GetUninitializedObject`
- [x] `System.Diagnostics.Process.Handle` -&gt; `System.Diagnostics.Process.SafeHandle`

---

**Already done issues (for progress tracking):**
- [x] `Type.IsInterface`-&gt; `Type.GetTypeInfo.IsInterface` (`IsClass`, `IsGenericType` , `IsAbstract`, `IsPrimitive`, `IsEnum`).
- [x] `Type` -&gt; `TypeInfo` for most members (in Orleans code, and code generated by OrleansCodeGenerator) #1783 #1894 #1997 
- [x] `TextReader.Close` -&gt; `TextReader.Dispose` #609 #2034
- [x] `Socket.Close` -&gt; `Socket.Dispose`
- [x] `Delegate.CreateDelegate` -&gt; `MethodInfo.CreateDelegate`
- [x] `ApplicationException(string)`
- [x] `System.Data` and `System.Transactions` - used in SQL utils. Create a separate OrleansSQLUtils project and move all [Relational Storage](https://github.com/dotnet/orleans/tree/master/src/Orleans/RelationalStorage) code there.
- [x] `XmlTextWriter` and `XMLNode.SelectNodes`.
- [x] `Dns.GetHostAddresses`.
- [x] `System.String.ToLower(CultureInfo.InvariantCulture)` -&gt; Use `CultureInfo.TextInfo.ToLower(String)` instead
- [x] `System.UriTypeConverter`.
- [x] `System.CodeDom.CodeTypeParameter`.
- [x] `BinaryFormatter.Serialize` - solved via #1047.
- [x] `System.Management.ManagementObjectCollection` -  not supported in .NET Core. Investigate and propose alternative options (if `ManagementObject` itself is supported). We use it now in one place, to find TotalPhysicalMemory. Solved via #1048
</Description>
        <CreatedDate>30/04/2015</CreatedDate>
        <ClosedDate>06/01/2018</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>588</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>OMQ-SendMessage</Title>
    <Description>- The `SendMessage` method in `OutboundMessageQueue` is declared as returning a `bool`, but the returned value is always `true` and the returned value is never used anywhere.
  Changing return type to `void` to avoid confusion.
- Throw NullArgumentException if SendMessage is every passed a null message [never happens in current code base], rather than silently ignore.

Replaces #586 
</Description>
    <CreatedDate>07/07/2015</CreatedDate>
    <ClosedDate>08/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>588</PullRequestID>
        <IssueID>586</IssueID>
        <Title>OMQ-SendMessage</Title>
        <Description>- The `SendMessage` method in `OutboundMessageQueue` is declared as returning a `bool`, but the returned value is always `true` and the returned value is never used anywhere.
  Changing return type to `void` to avoid confusion.
- Throw NullArgumentException if SendMessage is every passed a null message [never happens in current code base], rather than silently ignore.
</Description>
        <CreatedDate>07/07/2015</CreatedDate>
        <ClosedDate>07/07/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>585</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Jason Bragg: Delivery Policy for Persistent Stream Providers</Title>
    <Description>Merged #576  with master and resubmitted. This PR is identical to #576.
</Description>
    <CreatedDate>06/07/2015</CreatedDate>
    <ClosedDate>06/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>585</PullRequestID>
        <IssueID>576</IssueID>
        <Title>Delivery Policy for Persistent Stream Providers</Title>
        <Description>Added retry to stream pulling agent.
Added stream error handler to adapter factory.

EDIT: by @gabikliot
Some background on this change: 
As explained in http://dotnet.github.io/orleans/Orleans-Streams/ and http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers Orleans streams guarantees are shaped via [Stream Providers](http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers). Different Stream Providers have different event delivery and ordering guarantees. For example, SMS Provider provides best effort, at most once event delivery guarantee .
AQ provider relies on internal AQ retry mechanism that will hide the event from the queue and if not deleted it will reappear. As such, AQ provider does not guarantee ordering and may deliver the same event more than once (in the presence of message delivery failures).

In addition, we are now actively working on a fully-reliable, recoverable stream provider that guarantees ordering and at most once delivery. 
This PR is a component of this future recoverable stream provider. It allows to specify the retry policy for events that failed to be delivered and also error handling policy that is invoked after all retries fail. One implementaion of this policy, which we ship by default, will be to log the failed event into a special "failed events" Azure table and also "fault" the stream subsription. That way stream consumers will get a clear notification about this error and will be able to recover, by re-subscribing from a previous point in time and by looking at the "failed events" Azure table.
</Description>
        <CreatedDate>03/07/2015</CreatedDate>
        <ClosedDate>06/07/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>585</PullRequestID>
        <IssueID>576</IssueID>
        <Title>Delivery Policy for Persistent Stream Providers</Title>
        <Description>Added retry to stream pulling agent.
Added stream error handler to adapter factory.

EDIT: by @gabikliot
Some background on this change: 
As explained in http://dotnet.github.io/orleans/Orleans-Streams/ and http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers Orleans streams guarantees are shaped via [Stream Providers](http://dotnet.github.io/orleans/Orleans-Streams/Stream-Providers). Different Stream Providers have different event delivery and ordering guarantees. For example, SMS Provider provides best effort, at most once event delivery guarantee .
AQ provider relies on internal AQ retry mechanism that will hide the event from the queue and if not deleted it will reappear. As such, AQ provider does not guarantee ordering and may deliver the same event more than once (in the presence of message delivery failures).

In addition, we are now actively working on a fully-reliable, recoverable stream provider that guarantees ordering and at most once delivery. 
This PR is a component of this future recoverable stream provider. It allows to specify the retry policy for events that failed to be delivered and also error handling policy that is invoked after all retries fail. One implementaion of this policy, which we ship by default, will be to log the failed event into a special "failed events" Azure table and also "fault" the stream subsription. That way stream consumers will get a clear notification about this error and will be able to recover, by re-subscribing from a previous point in time and by looking at the "failed events" Azure table.
</Description>
        <CreatedDate>03/07/2015</CreatedDate>
        <ClosedDate>06/07/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>583</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Fixes float statistics to culture invariant form</Title>
    <Description>This fixes float statistics values to culture invariant form,
especially forces the decimal separator to be dot.
fixes decimal separator to use invariant culture separator

This is done to avoid problems when reading data from a storage
and it is converted back to floating point values.

Fixes #573.
</Description>
    <CreatedDate>06/07/2015</CreatedDate>
    <ClosedDate>06/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>583</PullRequestID>
        <IssueID>573</IssueID>
        <Title>Orleans statistics floats have decimal separators written in culture specific format to storage</Title>
        <Description>Orleans statistics floats have decimal separators written in culture specific format. I think the intention is to store data in culture invariant way. I have verified this is  an issue with SQL Server where statistics are written to the table as

| StatValue | Statistic |
| --- | --- |
| 6,572005 | Runtime.CpuUsage |
| 1,588444 | Runtime.GC.PercentOfTimeInGC |

in systems where decimal separator is not dot (e.g. Finnish). In relational database the code is [here](https://github.com/dotnet/orleans/blob/master/src/Orleans/Storage/OrleansRelationalExtensions.cs#L287). For Table Storage the code is [here](https://github.com/dotnet/orleans/blob/master/src/OrleansAzureUtils/Storage/StatsTableDataManager.cs#L146). I would imagine it has a similar issue.

I recall .NET Design Guidelines tell that `.ToString` is to print culture aware strings, so in that sense the `.ToString` code is right, the callers are wrong. One way to provide a fix is to add an overload to `ToString` that accepts a `CultureInfo` parameter. An example: [Single.ToString Method (IFormatProvider)](https://msdn.microsoft.com/en-us/library/7tdhaxxa%28v=vs.110%29.aspx).

Tangential notes:
- Maybe adding a `DebuggerDisplay` to `ICounter`.
- It would look like sensible to refactor the relational code so that statistic values are always numeric.
</Description>
        <CreatedDate>02/07/2015</CreatedDate>
        <ClosedDate>06/07/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>578</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Minor improvements to SQL System store.</Title>
    <Description>Added logger.IsVerbose before logging statements.
Throw ArgumentNullException is appropriate places.
Renamed Storage folder to RelationalStorage.
Some improvements to line feeds.

Minor improvements over #347.

Also, handles issue #573 .
</Description>
    <CreatedDate>03/07/2015</CreatedDate>
    <ClosedDate>03/07/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>578</PullRequestID>
        <IssueID>347</IssueID>
        <Title>Improvements to relational database handling in Orleans</Title>
        <Description>Starts a fix for #255.

An attempt to improve relational database handling in Orleans. If this approach is all right, I'd appreciate help either someone pointing a place to move the files or pulling this PR in and moving the files around. After which the work would continue with the relocated files (possibly in a separate PR).
#### Points of note:
1. Code is not used anywhere at the moment. A feasible approach to make use of it initially could be use in tests by modifying [Local.testsetting](https://github.com/dotnet/orleans/blob/master/src/Local.testsettings#L6) by adding [CreateTables.sql](https://github.com/dotnet/orleans/blob/master/src/OrleansProviders/SQLServer/CreateTables.sql) to the set of included items in tests [MembershipTablePluginTests](https://github.com/dotnet/orleans/blob/master/src/TesterInternal/StorageTests/MembershipTablePluginTests.cs#L38) and create database as appropriate for testing (code follows) and add the tables in the script in (one has to remove the `DELETE` clauses, likely also the `SELECT` clauses.
2. Laying this foundation should support all databases with ADO.NET providers.
3. Should make it easier to add new relational backends so that they are easily testable. This is achieved chiefly with special template queries. See `RelationalConstants`.
4. Should not hinder adding further features such as using stored procedures or reading
   multiple resultsets.
5. Is asynchronous all the way.
6. Does not have logging facilities added.
7. Includes a few reflection utilities to make use easier, though hand-tune queries are possible too and likely should be favoured. An example of such is at `ExistsAsync`.
8. Current Orleans queries aren't added to the newer code base. One approach would be to turn them to extensions methods.
9. Related to point number eight, currently data would be inserted in a loop, but a more efficient would be multi-row `INSERT INTO VALUES`, which is possible, but having a few methods to assembly the query string from a provided collection string would make it nicer. On the TODO list.
#### Additional notes:
1. Perhaps it would be useful to create a new project, e.g. `Orleans.DataStorage` wherein to put data storage related functionality.
2. Perhaps it would be useful to define an interface according to HTTP verbs (GET/PUT/PATCH/DELETE). This way adding any storage backend would look like being easier. Caveat emptor, I haven't studied this in depth.
3. Perhaps it would be useful to create a special `ReflectionCache` component, which would include the source of type and a timestamp when added.
4. Perhaps it would be feasible to add a project like `Orleans.UnitTests`, which would contain clearly unit test like functionality.

In the following debugger and/or open database might be handy. This is a simpble usage example ("works on my machine")

``
</Description>
        <CreatedDate>19/04/2015</CreatedDate>
        <ClosedDate>30/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>578</PullRequestID>
        <IssueID>573</IssueID>
        <Title>Orleans statistics floats have decimal separators written in culture specific format to storage</Title>
        <Description>Orleans statistics floats have decimal separators written in culture specific format. I think the intention is to store data in culture invariant way. I have verified this is  an issue with SQL Server where statistics are written to the table as

| StatValue | Statistic |
| --- | --- |
| 6,572005 | Runtime.CpuUsage |
| 1,588444 | Runtime.GC.PercentOfTimeInGC |

in systems where decimal separator is not dot (e.g. Finnish). In relational database the code is [here](https://github.com/dotnet/orleans/blob/master/src/Orleans/Storage/OrleansRelationalExtensions.cs#L287). For Table Storage the code is [here](https://github.com/dotnet/orleans/blob/master/src/OrleansAzureUtils/Storage/StatsTableDataManager.cs#L146). I would imagine it has a similar issue.

I recall .NET Design Guidelines tell that `.ToString` is to print culture aware strings, so in that sense the `.ToString` code is right, the callers are wrong. One way to provide a fix is to add an overload to `ToString` that accepts a `CultureInfo` parameter. An example: [Single.ToString Method (IFormatProvider)](https://msdn.microsoft.com/en-us/library/7tdhaxxa%28v=vs.110%29.aspx).

Tangential notes:
- Maybe adding a `DebuggerDisplay` to `ICounter`.
- It would look like sensible to refactor the relational code so that statistic values are always numeric.
</Description>
        <CreatedDate>02/07/2015</CreatedDate>
        <ClosedDate>06/07/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>575</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Switch to using NUnit Test Framework</Title>
    <Description>Switch over to using the `NUnit` test framework (http://nunit.net/) for Project Orleans.

More explanation of the reasons behind this switch are posted in #574

If you have any general comments or suggestions about changing test framework, then please reply to that thread.

Please use this PR thread for any specific feedback about the code-level changes themselves.
</Description>
    <CreatedDate>02/07/2015</CreatedDate>
    <ClosedDate>29/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>575</PullRequestID>
        <IssueID>574</IssueID>
        <Title>Switching to NUnit Test Framework</Title>
        <Description># Switching to NUnit

This post is to raise a proposal to switch the test framework used for Orleans runtime code in GitHub to use **NUnit** instead of _MsTest_, and to solicit community feedback and discussion on that topic.
## Why Not MsTest?

The biggest problem that we have hit several times with MsTest is that **calls to the test class teardown function is non-deterministic**, so there are absolutely no guarantees that the ClassCleanup method for one test file will have been called before the ClassInitialize method for another test class gets called. 

This causes huge problems for some of the most advanced functional test cases for Orleans around cluster membership and other handling of silo failure cases, most recently demonstrated on PR #557.

We have also been hit several times by the unexpected MsTest behavior that it creates a separate instance of the test class **per test case**, which makes TestInitialize vs Constructor code almost completely pointless distinction. 

Most of the Orleans systems tests are grouped into similar functional units that can share test execution environment to amortize test silo start-up time &amp; cost across several test cases, but MsTest does not observe or use that optimization.

Take a look at this (slightly old) blog post for more background info on these issues, and several others:  
[http://madcoderspeak.blogspot.com/2011/11/nunit-vs-mstest-2011-edition.html](http://madcoderspeak.blogspot.com/2011/11/nunit-vs-mstest-2011-edition.html)

The requirements we have for test framework functionality are fairly basic, but we have now run out of tricks to make MsTest work within this model:
- Class-Setup/Teardown - to be executed ONCE before/after ALL tests in that class / source file. 
- Test-Setup/Teardown - to be executed before/after EVERY test 
## Why NUnit?

[NUnit](http://nunit.net/) is one of several test frameworks commonly used for .NET projects, but offers a number of additional advantages compared to MsTest:
1. Generally works exactly the way people expect it to, with fewer example of quirky and unexpected behavior around test class / test case initialization and cleanup.
2. Already runs **cross-platform**, so provides a much easier transition route as we work towards building and running Orleans natively on other platforms, including Mac OSX, Linux, CoreCLR, etc. 
3. There is mostly a [simple direct mapping](http://xunit.codeplex.com/wikipage?title=Comparisons) of terminology, concepts and API attributes / methods between MsTest and NUnit, which is almost all cases make the conversion very easy to automate and check.
4. There is good support for NUnit in .NET editors and IDEs, including test harnesses built in to ReSharper and Visual Studio [through a simple [VS extension](http://nunit.net/index.php?p=vsTestAdapter&amp;r=2.6.4)]. 
   There are also standalone test runners for both GUI and command line use if preferred.
5. Many other .NET Foundation projects on GitHub have already moved away from MsTest for their test suite(s) in order to allow diverse cross-platform testing.
## Why not other test frameworks, such as xUNit?

The main priority of this switch is to minimize the conceptual and API changes we would need to make in order to get the new test suite up and running.

We don't have a dedicated test team assigned to Orleans, so any changes will be made by core developers or community members. 

Therefore **minimizing switching cost is a primary concern**.

For example, xUnit seems to be a very well regarded test framework, but requires some significant changes to the way testing is approached and reasoned about.

Some immediate examples of large conceptual changes when thinking about a move to xUnit:
- Fact vs general TestMethod.
- Constructor+IDisposable instead of Test Setup/Teardown.
- Fixtures instead of Test Class Setup/Teardown.

In short, switching to NUnit seems to have the lowest switching costs, and provide the smoothest transition path for test approach.

Bear in mind that we (the Orleans Core Team) have day jobs too :) 

We also have many other internal test suites and test cases that we want to get into GitHub but we already have problems with finding time to migrate them all to GitHub even as a direct MsTest -&gt; MsTest conversion case. 

So realistically we feel we have even less cycles to make radical changes to the old test cases if there is large test framework porting gap :(
## Next Steps

I have created a prototype of the changes to switch over to use `NUnit` test framework on a branch in my repo.
[https://github.com/jthelin/orleans/tree/NUnit](https://github.com/jthelin/orleans/tree/NUnit)

I will shortly submit that branch as a Pull Request on GH for further community discussion.
That branch should be considered a work-in-progress which will require some ongoing updates to track any test-related changes in `master` but currently build and runs all test cases ok.

Please use that PR #575 for any specific feedback about the code-level changes themselves.

If you have any general comments or suggestions about changing test framework, then please reply to this thread.

We are targeting this switch over to the release after next (1.0.10) after current work in progress are stabilized and released in 1.0.9, but wanted to give early community visibility and feedback opportunity on the change proposal :)
</Description>
        <CreatedDate>02/07/2015</CreatedDate>
        <ClosedDate>15/03/2016</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>558</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>brinkrob</FixedByID>
    <Title>DateTime Serialization</Title>
    <Description>Resolves #552 
</Description>
    <CreatedDate>27/06/2015</CreatedDate>
    <ClosedDate>29/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>558</PullRequestID>
        <IssueID>552</IssueID>
        <Title>DateTime Serialization loses Kind information</Title>
        <Description>When serializing a DateTime object between silos/clients Orleans stores just the Ticks value losing the kind/timezone information.

Currently only the ticks are written to the serialization stream.  

If the source DateTime object is of kind "Local" the ticks are local as well.  On the other side of the serialization, a DateTime object is created without the kind information resulting in a kind of "Unspecified" which is usually treated as UTC.  Thus ticks in local time go in, and ticks in unspecified/UTC time come out.

My proposal:

When serialization is taking place, convert the DateTime to UTC and write the ticks as UTC.  Also write the kind attribute to the stream.

On the Deserialize side, use the UTC ticks and the kind to recreate a DateTime object that is similar to the original.  The kind (local/utc) would be the same, it would refer to the same UTC time, but the ticks/timezone may be different and therefore a basic ToString of the time object would output a different time.
</Description>
        <CreatedDate>25/06/2015</CreatedDate>
        <ClosedDate>29/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>554</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Removed statics from LimitManager.</Title>
    <Description>Made it a member field of configuration.
Another item on the path of solving #467.
</Description>
    <CreatedDate>26/06/2015</CreatedDate>
    <ClosedDate>29/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>554</PullRequestID>
        <IssueID>467</IssueID>
        <Title>Make the GrainClient class non-static</Title>
        <Description>Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving this issue.

Client code will create an instance of `GrainClient` instead of using the static `GrainClient.Initialize` as follows:

``

---

@gabikliot wrote:
TODOs:
- [x] Remove all static mutable fields from client runtime.
- [ ] Static Interners
- [x] `RuntimeClient.Current.SendRequest`
- [ ] Static `TraceLogger` instances
- [ ] Static mutable fields inside `TraceLogger`
- [x] Placement Singletons
- [x] Serializer internal collections
- [ ] All statistics counters
</Description>
        <CreatedDate>29/05/2015</CreatedDate>
        <ClosedDate>19/04/2017</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>553</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Remove static collections from AsynchAgent. </Title>
    <Description>Remove static collections from AsynchAgent. 
Fix thread names allocation to ensure unique thread names.
On the path of solving #467.
</Description>
    <CreatedDate>25/06/2015</CreatedDate>
    <ClosedDate>26/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>553</PullRequestID>
        <IssueID>467</IssueID>
        <Title>Make the GrainClient class non-static</Title>
        <Description>Connecting to multiple Orleans Silos from the same client is not possible because the Orleans client class is static and there can be only one of it in a process. Making the `GrainClient` non-static will help solving this issue.

Client code will create an instance of `GrainClient` instead of using the static `GrainClient.Initialize` as follows:

``

---

@gabikliot wrote:
TODOs:
- [x] Remove all static mutable fields from client runtime.
- [ ] Static Interners
- [x] `RuntimeClient.Current.SendRequest`
- [ ] Static `TraceLogger` instances
- [ ] Static mutable fields inside `TraceLogger`
- [x] Placement Singletons
- [x] Serializer internal collections
- [ ] All statistics counters
</Description>
        <CreatedDate>29/05/2015</CreatedDate>
        <ClosedDate>19/04/2017</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>545</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>shayhatsor</FixedByID>
    <Title>ZK MBR documentation,tweaks and new ZooKeeperNetEx</Title>
    <Description>- Updated ZooKeeperNetEx. (the new version fixes several bugs that came up in testing)
- Only set maxStaleness for GatewayListProvider. from #530
- Use CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag. from #530
- Added lots of documentation
- Using ETags instead of table versions.
- Some implementation tweaks, no logic was changed
</Description>
    <CreatedDate>20/06/2015</CreatedDate>
    <ClosedDate>22/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>545</PullRequestID>
        <IssueID>530</IssueID>
        <Title>A number of small ZK MBR table cleanup fixes.</Title>
        <Description>Only set maxStaleness for GatewayListProvider.
No need in log4Net.
Use CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag.
</Description>
        <CreatedDate>17/06/2015</CreatedDate>
        <ClosedDate>22/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>question</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>545</PullRequestID>
        <IssueID>530</IssueID>
        <Title>A number of small ZK MBR table cleanup fixes.</Title>
        <Description>Only set maxStaleness for GatewayListProvider.
No need in log4Net.
Use CultureInfo.InvariantCulture when converting ZK rowVersion to string eTag.
</Description>
        <CreatedDate>17/06/2015</CreatedDate>
        <ClosedDate>22/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>540</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Deprecated code generation for concrete GetGrain factory methods.</Title>
    <Description>Last nail in the coffin of #469!
</Description>
    <CreatedDate>19/06/2015</CreatedDate>
    <ClosedDate>25/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>540</PullRequestID>
        <IssueID>469</IssueID>
        <Title>Deprecate GetGrain in code-generated concrete factories</Title>
        <Description>We currently have 2 ways to use grain factories:
Code-generated concrete factories (`MyGrainFactory.GetFrain()`) and generic factories (`GrainFactory.GetGrain&lt;IMyGrain&gt;()`). The goal is to completely deprecate and eventually eliminate the code-generated concrete factories. Reasons:
1) 2 ways for application to get grain reference - confusing.
2) Code-generated concrete factories are not testable. Generic factories are (#443).
3) Reduce code duplication - the runtime implementation of the 2 different factories has some code duplication.
4) Overall reduce the amount of generated code. Getting rid of code-generated factories is one step in that direction.
5) Generic factories allow to have Grain interface and implementation in same project, while [Code-generated factories do not](https://orleans.codeplex.com/discussions/577719).

There is a number of steps required to make this possible:
- [x] Port all CI tests to use generic factories. Done via #468.
- [x] Use generic factories for system target references inside the runtime. Done via #470.
- [x] Eliminate all usage of reflection calls to concrete factories (there are still some in streaming code). Done via #527.
- [x] Solve the bug of generic factories used inside generic grain (#423). Done via #479.
- [x] Port all our internal tests to use generic factories
- [x] Deprecate `GetGrain` calls in code-generated factories.
</Description>
        <CreatedDate>02/06/2015</CreatedDate>
        <ClosedDate>25/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>538</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Set Reminder Type to Disabled in case of Zookeper System store.</Title>
    <Description>Disable Reminders if ZK is used for system store.
This is instead of #535.
As opposite to #535, this code will throw earlier, on the caller, if reminders are used from the grain when running with ZK system store.
</Description>
    <CreatedDate>18/06/2015</CreatedDate>
    <ClosedDate>19/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>538</PullRequestID>
        <IssueID>535</IssueID>
        <Title>NotImplementedReminderTable to disable reminders</Title>
        <Description>When using ZooKeeper as a membership provider , the reminders provider is set to GrainBasedReminderTable (as a fallback). This seemed to work fine. But it doesn't.
The scenario:
1) 5 silos are started as secondary and are active in the same deployment. (named Silo1-Silo5)
2) all silos crash
3) Silo1 is restarted
4) Silo1 adds a suspected dead entry for Silo2-Silo5
5) Silo1 tries to get the grain for the GrainBasedReminderTable.
6) the hash result says that Silo3 knows where the GrainBasedReminderTable is.
7) Silo1 suspicion isn't enough to change the ring. 
8) Silo1 can't start its reminder service and crashes. This happens continuously until enough silos are started and the membership table reflects reality.

I've added a NotImplementedReminderTable reminder table implementation that just throws when reminders are used by grains. IMO this is much better than the fallback to GrainBasedReminderTable, which gives grains the illusion of persistent storage which in reality doesn't exist.
</Description>
        <CreatedDate>18/06/2015</CreatedDate>
        <ClosedDate>19/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>538</PullRequestID>
        <IssueID>535</IssueID>
        <Title>NotImplementedReminderTable to disable reminders</Title>
        <Description>When using ZooKeeper as a membership provider , the reminders provider is set to GrainBasedReminderTable (as a fallback). This seemed to work fine. But it doesn't.
The scenario:
1) 5 silos are started as secondary and are active in the same deployment. (named Silo1-Silo5)
2) all silos crash
3) Silo1 is restarted
4) Silo1 adds a suspected dead entry for Silo2-Silo5
5) Silo1 tries to get the grain for the GrainBasedReminderTable.
6) the hash result says that Silo3 knows where the GrainBasedReminderTable is.
7) Silo1 suspicion isn't enough to change the ring. 
8) Silo1 can't start its reminder service and crashes. This happens continuously until enough silos are started and the membership table reflects reality.

I've added a NotImplementedReminderTable reminder table implementation that just throws when reminders are used by grains. IMO this is much better than the fallback to GrainBasedReminderTable, which gives grains the illusion of persistent storage which in reality doesn't exist.
</Description>
        <CreatedDate>18/06/2015</CreatedDate>
        <ClosedDate>19/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>533</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Membership tests cleanup and restructuring.</Title>
    <Description>This will also help @veikkoeeva in his efforts on #347.
</Description>
    <CreatedDate>18/06/2015</CreatedDate>
    <ClosedDate>18/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>533</PullRequestID>
        <IssueID>347</IssueID>
        <Title>Improvements to relational database handling in Orleans</Title>
        <Description>Starts a fix for #255.

An attempt to improve relational database handling in Orleans. If this approach is all right, I'd appreciate help either someone pointing a place to move the files or pulling this PR in and moving the files around. After which the work would continue with the relocated files (possibly in a separate PR).
#### Points of note:
1. Code is not used anywhere at the moment. A feasible approach to make use of it initially could be use in tests by modifying [Local.testsetting](https://github.com/dotnet/orleans/blob/master/src/Local.testsettings#L6) by adding [CreateTables.sql](https://github.com/dotnet/orleans/blob/master/src/OrleansProviders/SQLServer/CreateTables.sql) to the set of included items in tests [MembershipTablePluginTests](https://github.com/dotnet/orleans/blob/master/src/TesterInternal/StorageTests/MembershipTablePluginTests.cs#L38) and create database as appropriate for testing (code follows) and add the tables in the script in (one has to remove the `DELETE` clauses, likely also the `SELECT` clauses.
2. Laying this foundation should support all databases with ADO.NET providers.
3. Should make it easier to add new relational backends so that they are easily testable. This is achieved chiefly with special template queries. See `RelationalConstants`.
4. Should not hinder adding further features such as using stored procedures or reading
   multiple resultsets.
5. Is asynchronous all the way.
6. Does not have logging facilities added.
7. Includes a few reflection utilities to make use easier, though hand-tune queries are possible too and likely should be favoured. An example of such is at `ExistsAsync`.
8. Current Orleans queries aren't added to the newer code base. One approach would be to turn them to extensions methods.
9. Related to point number eight, currently data would be inserted in a loop, but a more efficient would be multi-row `INSERT INTO VALUES`, which is possible, but having a few methods to assembly the query string from a provided collection string would make it nicer. On the TODO list.
#### Additional notes:
1. Perhaps it would be useful to create a new project, e.g. `Orleans.DataStorage` wherein to put data storage related functionality.
2. Perhaps it would be useful to define an interface according to HTTP verbs (GET/PUT/PATCH/DELETE). This way adding any storage backend would look like being easier. Caveat emptor, I haven't studied this in depth.
3. Perhaps it would be useful to create a special `ReflectionCache` component, which would include the source of type and a timestamp when added.
4. Perhaps it would be feasible to add a project like `Orleans.UnitTests`, which would contain clearly unit test like functionality.

In the following debugger and/or open database might be handy. This is a simpble usage example ("works on my machine")

``
</Description>
        <CreatedDate>19/04/2015</CreatedDate>
        <ClosedDate>30/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>528</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ReubenBond</FixedByID>
    <Title>Feature: Runtime Code Generation</Title>
    <Description>This is a proposed fix for #511 &amp; #510.

Runtime code generation is loaded in the GrainFactory and kept current as new assemblies are loaded. `IGrainMethodInvoker` implementations are also loaded in `GrainTypeManager` upon initialization.

Roslyn is used for generating `GrainReference`s and `IGrainMethodInvoker`s and not for generating `GrainReference` serializers, `Cast` methods, or `CreateObjectRefernce`/`DeleteObjectReference` methods . Instead, Expression Trees are used in those cases. In the case of `GrainReference` casters, they of course rely on having a generated `GrainReference` with the correct marker attribute.

Marker attributes (`MethodInvokerAttribute` and `GrainReferenceAttribute`) have been changed to include a `GrainType` parameter which takes the (possibly generic) type of the grain which they relate to.

This is implemented as an optional plugin for Orleans. If `OrleansCodeGenerator.dll` is present at runtime, it will be loaded and used. If it is not present, the existing mechanism of compile-time code generation will have to suffice instead.

I have not created a NuGet package, so if this is the approach we are going to take, that will need to be done before the PR is ready to merge.

All criticism is welcome :)
</Description>
    <CreatedDate>17/06/2015</CreatedDate>
    <ClosedDate>22/10/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>528</PullRequestID>
        <IssueID>511</IssueID>
        <Title>Replace compile-time code generation of GrainReference subclasses (stubs)</Title>
        <Description>This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot mentioned some different techniques for eliminating the need for compile-time code generation of `GrainReference` subclasses including the possibility of using dynamic method invocation, reflection, or runtime code generation (eg, using Roslyn. See #40).

I believe that runtime code generation is the most optimal approach: it has the best amortized performance at runtime. Other options might be sufficient, though. The performance of `dynamic` has apparently improved somewhat, so that might now be a viable option.
</Description>
        <CreatedDate>13/06/2015</CreatedDate>
        <ClosedDate>22/10/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>under-investigation</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>528</PullRequestID>
        <IssueID>510</IssueID>
        <Title>Replace compile-time code generation of IGrainMethodInvoker</Title>
        <Description>This is a sub issue for #474 (Minimize/eliminate the usage of code generation in Orleans). Motivations for this are covered in that issue, so I won't reiterate.

@gabikliot mentioned some different techniques for eliminating the need for compile-time code generation of IGrainMethodInvoker including the possibility of using dynamic method invocation, reflection, or runtime code generation (eg, using Roslyn. See #40).

I believe that runtime code generation is the most optimal approach: it has the best amortized performance at runtime. Other options might be sufficient, though.
</Description>
        <CreatedDate>13/06/2015</CreatedDate>
        <ClosedDate>22/10/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>under-investigation</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>527</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Remove reflection factories</Title>
    <Description>Another step in #469.
</Description>
    <CreatedDate>16/06/2015</CreatedDate>
    <ClosedDate>17/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>527</PullRequestID>
        <IssueID>469</IssueID>
        <Title>Deprecate GetGrain in code-generated concrete factories</Title>
        <Description>We currently have 2 ways to use grain factories:
Code-generated concrete factories (`MyGrainFactory.GetFrain()`) and generic factories (`GrainFactory.GetGrain&lt;IMyGrain&gt;()`). The goal is to completely deprecate and eventually eliminate the code-generated concrete factories. Reasons:
1) 2 ways for application to get grain reference - confusing.
2) Code-generated concrete factories are not testable. Generic factories are (#443).
3) Reduce code duplication - the runtime implementation of the 2 different factories has some code duplication.
4) Overall reduce the amount of generated code. Getting rid of code-generated factories is one step in that direction.
5) Generic factories allow to have Grain interface and implementation in same project, while [Code-generated factories do not](https://orleans.codeplex.com/discussions/577719).

There is a number of steps required to make this possible:
- [x] Port all CI tests to use generic factories. Done via #468.
- [x] Use generic factories for system target references inside the runtime. Done via #470.
- [x] Eliminate all usage of reflection calls to concrete factories (there are still some in streaming code). Done via #527.
- [x] Solve the bug of generic factories used inside generic grain (#423). Done via #479.
- [x] Port all our internal tests to use generic factories
- [x] Deprecate `GetGrain` calls in code-generated factories.
</Description>
        <CreatedDate>02/06/2015</CreatedDate>
        <ClosedDate>25/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>518</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>kumbhare</FixedByID>
    <Title>Issue a compile time warning if a class implements IGrain but does not extend the base Grain or Grain&lt;T&gt; class.</Title>
    <Description>Fixes #492. The fix validate during code generation (for grain implementations) if all grain classes extend Grain or Grain&lt;T&gt; base classes, otherwise issue a compile time warning.

As a result of the fix, there were some compile warning in the orleans runtime:
1. IReminderTable is marked as IGrain because one of the implementations (GrainBasedReminderTable) is a grain while others e.g. Azure, SQL based are not.
2. Similarly for IMembershipTable interface.
Refactored the code so that the base IReminderTable and IMembershipTable interfaces are not IGrain and created a IReminderTableGrain and IMembershipTableGrain interfaces which are used by the GrainBased classes.

There was also an interface:
internal interface IGrainRingRangeListener : IGrain
Need to confirm with @gabikliot  if this really needs be IGrain?
It seems like this is neither a Grain class nor a SystemTarget and hence need not be IGrain. If in future, Grain based implementation is required, we can follow a pattern as above to create that implementation.
</Description>
    <CreatedDate>15/06/2015</CreatedDate>
    <ClosedDate>17/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>518</PullRequestID>
        <IssueID>492</IssueID>
        <Title>TODO: Log warning for grain classes that don't extend Grain base.</Title>
        <Description>TODO: Add an explicit warning message during silo assembly loader scan and / or codegen to flag any `class` that implements an grain `interface` extending from `IGrain` [to any depth] but where the class does not extend the `Grain` or `Grain&lt;T&gt;` abstract base class required to make it a "real" grain.

It is scary how many times I have tripped myself up with this "feature" recently (!) and it's quite hard to diagnose root cause because you currently just get a cryptic error message about grain type code not being found.
</Description>
        <CreatedDate>06/06/2015</CreatedDate>
        <ClosedDate>17/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>513</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>raybooysen</FixedByID>
    <Title>New Samples</Title>
    <Description>This PR accomplishes two things.
- Fixes the HelloWorld sample so that it no longer references packages in the AzureWebSample project
- Creates standalone sample projects in AzureWebSample so that it no longer references the HelloWorld sample.

This is to help new users being able to open a sample and press F5 to get going.  

This fixes #505 
</Description>
    <CreatedDate>13/06/2015</CreatedDate>
    <ClosedDate>14/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>513</PullRequestID>
        <IssueID>505</IssueID>
        <Title>Sample Project Cross Reference</Title>
        <Description>The sample projects seem to cross reference each other.  For example, at the moment, on a clean clone, the HelloWorld sample does not build.  If you open the csproj file, note this line:

``

These lines reference the AzureWebSample project.  Note that the AzureWebSample project references the same HelloWorld projects in the HelloWorld solution, notable HelloWorldGrains and HellowWorldInterfaces.

I suggest that each sample should be able to work on it's own, so the AzureWebSample should have it's own copies of HelloWorld, and HelloWorld should have the references to the AzureWebSample removed.
</Description>
        <CreatedDate>11/06/2015</CreatedDate>
        <ClosedDate>14/06/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>491</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Fix some other script files affected by dir paths with spaces</Title>
    <Description>Fix some other places that are affected by directory paths with spaces in them.

This change is a follow on from PR #462 by @ElanHasson
</Description>
    <CreatedDate>06/06/2015</CreatedDate>
    <ClosedDate>06/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>491</PullRequestID>
        <IssueID>462</IssueID>
        <Title>Wrapped build paths with quotes</Title>
        <Description>You should now be able to run Build.cmd from a path with spaces in it.

This is for #461 
</Description>
        <CreatedDate>29/05/2015</CreatedDate>
        <ClosedDate>06/06/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>481</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Orleans-RestorePackages</Title>
    <Description>Orleans-RestorePackages
- Checked the NuGet restore settings by running the migrateToAutomaticPackageRestore.ps1 script, which found some projects with old style NuGet RestorePackages=True settings.

https://github.com/owen2/AutomaticPackageRestoreMigrationScript
- This is probably a more complete fix for issue #478
</Description>
    <CreatedDate>04/06/2015</CreatedDate>
    <ClosedDate>05/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>481</PullRequestID>
        <IssueID>478</IssueID>
        <Title>Build.cmd fails on a clean environment without the Azure SDK pre installed</Title>
        <Description>There is a bug in the nuget restore process of the build script, only restoring the orleans.csproj project. The Microsoft.WindowsAzure.ServiceRuntime dependency is missing from this project's packages.config file and so it is not installed.
Later, the code gen fails with
error CS0234: The type or namespace name 'ServiceRuntime' does not exist in the namespace 'Microsoft.WindowsAzure'
Which fails the build.

Looking at the CI build logs, the only reason it does not fail it due to the azure SDK being preinstalled on the build machine (assuming this is an Azure instance - it makes sense).

Possible quick fix is to add this dependency to the "orleans" project packages file.

A better long term solution would be to migrate the NuGet restore to it's new approach since the 2.7 Nuget version to avoid the problem in the first place. (restoring from all projects would have solved it)
</Description>
        <CreatedDate>03/06/2015</CreatedDate>
        <ClosedDate>05/06/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>480</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>yoadsn</FixedByID>
    <Title>Migrated nuget package restore to use the new auto-restore approach</Title>
    <Description>These are required by additional project which are not restored from the
build script.
Fixes #478

IMHO this is not the ultimate fix, there should be a change to the way nuget restore works for the build scripts. Avoid using the old approach which suffer problems during the build process such as presented in this case.
</Description>
    <CreatedDate>04/06/2015</CreatedDate>
    <ClosedDate>05/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>480</PullRequestID>
        <IssueID>478</IssueID>
        <Title>Build.cmd fails on a clean environment without the Azure SDK pre installed</Title>
        <Description>There is a bug in the nuget restore process of the build script, only restoring the orleans.csproj project. The Microsoft.WindowsAzure.ServiceRuntime dependency is missing from this project's packages.config file and so it is not installed.
Later, the code gen fails with
error CS0234: The type or namespace name 'ServiceRuntime' does not exist in the namespace 'Microsoft.WindowsAzure'
Which fails the build.

Looking at the CI build logs, the only reason it does not fail it due to the azure SDK being preinstalled on the build machine (assuming this is an Azure instance - it makes sense).

Possible quick fix is to add this dependency to the "orleans" project packages file.

A better long term solution would be to migrate the NuGet restore to it's new approach since the 2.7 Nuget version to avoid the problem in the first place. (restoring from all projects would have solved it)
</Description>
        <CreatedDate>03/06/2015</CreatedDate>
        <ClosedDate>05/06/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>under-investigation</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>470</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Move system targets to use generic factories.</Title>
    <Description>Partly addresses #469.
</Description>
    <CreatedDate>02/06/2015</CreatedDate>
    <ClosedDate>02/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>470</PullRequestID>
        <IssueID>469</IssueID>
        <Title>Deprecate GetGrain in code-generated concrete factories</Title>
        <Description>We currently have 2 ways to use grain factories:
Code-generated concrete factories (`MyGrainFactory.GetFrain()`) and generic factories (`GrainFactory.GetGrain&lt;IMyGrain&gt;()`). The goal is to completely deprecate and eventually eliminate the code-generated concrete factories. Reasons:
1) 2 ways for application to get grain reference - confusing.
2) Code-generated concrete factories are not testable. Generic factories are (#443).
3) Reduce code duplication - the runtime implementation of the 2 different factories has some code duplication.
4) Overall reduce the amount of generated code. Getting rid of code-generated factories is one step in that direction.
5) Generic factories allow to have Grain interface and implementation in same project, while [Code-generated factories do not](https://orleans.codeplex.com/discussions/577719).

There is a number of steps required to make this possible:
- [x] Port all CI tests to use generic factories. Done via #468.
- [x] Use generic factories for system target references inside the runtime. Done via #470.
- [x] Eliminate all usage of reflection calls to concrete factories (there are still some in streaming code). Done via #527.
- [x] Solve the bug of generic factories used inside generic grain (#423). Done via #479.
- [x] Port all our internal tests to use generic factories
- [x] Deprecate `GetGrain` calls in code-generated factories.
</Description>
        <CreatedDate>02/06/2015</CreatedDate>
        <ClosedDate>25/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>462</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>ElanHasson</FixedByID>
    <Title>Wrapped build paths with quotes</Title>
    <Description>You should now be able to run Build.cmd from a path with spaces in it.

This is for #461 
</Description>
    <CreatedDate>29/05/2015</CreatedDate>
    <ClosedDate>06/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>462</PullRequestID>
        <IssueID>461</IssueID>
        <Title>.\Build.cmd and .\src\Build.cmd don't like spaces in path</Title>
        <Description>Steps to reproduce:

1) Get branch into path similar to "C:\Users\Elan\Downloads\New folder (2)\orleans-1.0.8"
2) Run .\Build.cmd 
3) Observe Build Failure:
![image](https://cloud.githubusercontent.com/assets/234704/7875181/99d32072-0587-11e5-9ea2-7163b7f5bdef.png)

4) Correct .\Build.cmd" by putting quotes around line 1
5) Rerun .\Build.cmd
6) Observe Build Failure:
![image](https://cloud.githubusercontent.com/assets/234704/7875193/d324b5e8-0587-11e5-8806-31892439526f.png)

7) Correct issue in .\src\Build.cmd by putting quotes around line 12
8) ReRun .\Build.cmd
9) Observe Failure:
![image](https://cloud.githubusercontent.com/assets/234704/7875358/ffd7332a-0589-11e5-9b13-589002c0d5e5.png)

Several other files have this issue.
</Description>
        <CreatedDate>29/05/2015</CreatedDate>
        <ClosedDate>06/06/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>457</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Make sure we handle all in flight requests correctly when silo is shutting down.</Title>
    <Description>This is a 3rd step towards Gracefull Shutdown, related to:
#381
#320 (comment)

http://orleans.codeplex.com/discussions/637820#post1425137
Continues the work in #413.
Continues the work in #448.

Essentially, the silo was already largely handling this logic correctly. I merely simplified a couple of places, to make more clear what will actually happen. At a high level:
1) Once silo is shutting down, it first updates its membership state. This will cause all other silos not to place new activation on it, not to use this silo as grain directory and not as reminder service. This logic was already handled correctly before. No change.
2) Silo refuses to create any new activations, throws Non-existent activation and tries to forward the request. The activation will be placed on a different silo. This is a new bit added in this PR..
3) Silo starts to deactivate all activations. 
4) Any new requests that arrive to activations on that silo will be queued and after activation is deactivated, they will be forwarded to a new activation. There is no change in that logic.
</Description>
    <CreatedDate>28/05/2015</CreatedDate>
    <ClosedDate>01/06/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>381</IssueID>
        <Title>Call OnDeactivateAsync on silo shutdown</Title>
        <Description>Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains get this call when the silo goes down in a nice way (For host update or grain version refresh) they could do a nicer handover to the next activation by serializing any data they have.  

This would also help in the case where you save data on a timer. If this signal is sent then you could save the data only when the OnDeactiveAsync was received. Even if you did use a timer to save it periodically you would be sure to save the latest data using this. Even if you can recover this would be nicer since no data would be lost. 
</Description>
        <CreatedDate>04/05/2015</CreatedDate>
        <ClosedDate>05/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>320</IssueID>
        <Title>Handling multiple environments / versions of a cluster</Title>
        <Description>Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle this. If there was already a discussion about this (I didn't find one), please point me to it. 

The situation in question:

You (we) have an Orleans application, and there are state-full grains in it. 
Now we want to deploy a new version of the application. There are two main steps for deploying a new version: 
1. Upload the new version to a staging environment. In this phase the old and the new version lives side by side, and the new version is being tested.
2. Deploy the new version to production. Since this requires a cluster restart, it actually means deploy the new version to a new cluster, and then "switch" between the old and new clusters.

Both this steps contain a bag of problems with handling grains and their states.
For the sake of the example, lets assume we have in the application a _UserGrain_ that represents the state of a user. 

So while in staging, if the same user switches between staging and production, there may be a conflict between the states in each environment. Since there's a _UserGrain_ for the user in each environment, each holding its own state, they will be different (even if it gets persisted, the other grain in the second cluster does not know it needs to refresh its state).

A different flavor of the problem appears when switching between the old and new versions. This is never a "singular point in time" event (unless you can sustain downtime, which you normally can't). This means that there might be requests that are still handled by the old version while the new version is already up. So again - a _UserGrain_ of a user might change state in the old version while this not being recognized by the new version. 

This can be potentially handled by "streaming" all changes from the old version to the new version, but this seems to be a huge overhead and complication to the system. 

Are there any best practices for handling this? How do you handle production changes?
</Description>
        <CreatedDate>12/04/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>413</IssueID>
        <Title>Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.</Title>
        <Description>No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/dotnet/orleans/issues/320#issuecomment-101035028
http://orleans.codeplex.com/discussions/637820#post1425137
</Description>
        <CreatedDate>13/05/2015</CreatedDate>
        <ClosedDate>15/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>457</PullRequestID>
        <IssueID>448</IssueID>
        <Title>Added Silo.Shutdown call.</Title>
        <Description>Call Silo.Shutdown  from Azure Orleans Silo host and regular Orleans Silo host Stop() methods.
Deactivate all grains in this silo properly upon Silo.Shutdown call.

This is a 2nd step towards Gracefull Shutdown, related to:
#381
#320 (comment)

http://orleans.codeplex.com/discussions/637820#post1425137
Continues the work in #413.

Still a bit more work is required, to properly unsure that silo does not accept any new grain requests after the grains were deactivated and before silo is fully dead (so that we don't reactivate some grains again). This PR definitely leaves us in a better state than before we Deactivated all grains, so I feel like it can be merged even before the next level of improvements is done.
</Description>
        <CreatedDate>26/05/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>448</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Added Silo.Shutdown call.</Title>
    <Description>Call Silo.Shutdown  from Azure Orleans Silo host and regular Orleans Silo host Stop() methods.
Deactivate all grains in this silo properly upon Silo.Shutdown call.

This is a 2nd step towards Gracefull Shutdown, related to:
#381
#320 (comment)

http://orleans.codeplex.com/discussions/637820#post1425137
Continues the work in #413.

Still a bit more work is required, to properly unsure that silo does not accept any new grain requests after the grains were deactivated and before silo is fully dead (so that we don't reactivate some grains again). This PR definitely leaves us in a better state than before we Deactivated all grains, so I feel like it can be merged even before the next level of improvements is done.
</Description>
    <CreatedDate>26/05/2015</CreatedDate>
    <ClosedDate>27/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>448</PullRequestID>
        <IssueID>381</IssueID>
        <Title>Call OnDeactivateAsync on silo shutdown</Title>
        <Description>Would it be possible to add so OnDeactivateAsync is called on all grains in the silo when a silo is shutdown?

The scenario for this is that a complete crash of a silo is a very rare occurrence so if the grains get this call when the silo goes down in a nice way (For host update or grain version refresh) they could do a nicer handover to the next activation by serializing any data they have.  

This would also help in the case where you save data on a timer. If this signal is sent then you could save the data only when the OnDeactiveAsync was received. Even if you did use a timer to save it periodically you would be sure to save the latest data using this. Even if you can recover this would be nicer since no data would be lost. 
</Description>
        <CreatedDate>04/05/2015</CreatedDate>
        <ClosedDate>05/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>448</PullRequestID>
        <IssueID>320</IssueID>
        <Title>Handling multiple environments / versions of a cluster</Title>
        <Description>Hi 

We're struggling with questions around handling versioning and environments of an Orleans application (details ahead), and I'm hoping there might be some directions or tips on how to handle this. If there was already a discussion about this (I didn't find one), please point me to it. 

The situation in question:

You (we) have an Orleans application, and there are state-full grains in it. 
Now we want to deploy a new version of the application. There are two main steps for deploying a new version: 
1. Upload the new version to a staging environment. In this phase the old and the new version lives side by side, and the new version is being tested.
2. Deploy the new version to production. Since this requires a cluster restart, it actually means deploy the new version to a new cluster, and then "switch" between the old and new clusters.

Both this steps contain a bag of problems with handling grains and their states.
For the sake of the example, lets assume we have in the application a _UserGrain_ that represents the state of a user. 

So while in staging, if the same user switches between staging and production, there may be a conflict between the states in each environment. Since there's a _UserGrain_ for the user in each environment, each holding its own state, they will be different (even if it gets persisted, the other grain in the second cluster does not know it needs to refresh its state).

A different flavor of the problem appears when switching between the old and new versions. This is never a "singular point in time" event (unless you can sustain downtime, which you normally can't). This means that there might be requests that are still handled by the old version while the new version is already up. So again - a _UserGrain_ of a user might change state in the old version while this not being recognized by the new version. 

This can be potentially handled by "streaming" all changes from the old version to the new version, but this seems to be a huge overhead and complication to the system. 

Are there any best practices for handling this? How do you handle production changes?
</Description>
        <CreatedDate>12/04/2015</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <Labels>
          <Label>P2</Label>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>448</PullRequestID>
        <IssueID>413</IssueID>
        <Title>Refactored silo statuses to use IsTerminating and better encapsulation of usage of IsTerminating in various places.</Title>
        <Description>No logic change. 
A first step towards Gracefull Shutdown, related to:
https://github.com/dotnet/orleans/issues/381
https://github.com/dotnet/orleans/issues/320#issuecomment-101035028
http://orleans.codeplex.com/discussions/637820#post1425137
</Description>
        <CreatedDate>13/05/2015</CreatedDate>
        <ClosedDate>15/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>445</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Changed 2 more tests to use await instead of Wait.</Title>
    <Description>Continues #441.
</Description>
    <CreatedDate>26/05/2015</CreatedDate>
    <ClosedDate>27/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>445</PullRequestID>
        <IssueID>441</IssueID>
        <Title>Refactoring tests to async-await</Title>
        <Description>It would make sense to refactor all the code to be async-await too. Some of the testing code arguably is as it returns `TaskDone.Done`, though using .Result and Wait() on the caller side making it more difficult to detect and pushes one into investigating in more detail. But not all code is asynchronous.
</Description>
        <CreatedDate>24/05/2015</CreatedDate>
        <ClosedDate>26/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>443</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>nehmebilal</FixedByID>
    <Title>Add IGrainRuntime and IGrainIdentity to the Grain class.</Title>
    <Description>The constructor of the Grain class now takes an [IGrainRuntime](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-cc7634cf63a0cb7cc44e5a41b086f948) and [IGrainIdentity](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-41432dd7fb2a94ddca7a02ece151dbe3).

The `IGrainRuntime` is the gateway of the Grain to the Orleans runtime. In fact, `IGrainRuntime` groups together the interfaces that the `Grain` needs to interact with the runtime. These interfaces are:
- [IGrainFactory](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-52e8eccfb54116a4decfa9fb4ef2a527)
- [ITimerRegistry](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-7ef9a71887c72435d827de36997f3f26)
- [IReminderRegistry](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-18baf77cc55cfbc0ab140c90b9bc4629)
- [IStreamProviderManager](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-dca4119ddb07f2b3c10ab1f513f379df)

In addition, logging, silo identity and other activation aspects are also handled by IGrainRuntime.

The [IGrainIdentity](https://github.com/dotnet/orleans/compare/master...nehmebilal:pr#diff-41432dd7fb2a94ddca7a02ece151dbe3) groups all identity information of a `Grain` activation. It is the only interface that the `Grain` uses to access identity information.

Because both `IGrainRuntime` and `IGrainIdentity` can be injected through the `Grain` constructor, they can be replaced with test doubles (mocks or stubs) during unit testing.

Furthermore, we completely removed the static `GrainFactory` and made the `IGrainFactory` accessible through the `GrainClient` for outside-grain code and through a `protected` property for `Grain` implementations. We also planned to make the `GrainClient` non-static in the future.

Fixes #362 #48
</Description>
    <CreatedDate>26/05/2015</CreatedDate>
    <ClosedDate>27/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>443</PullRequestID>
        <IssueID>362</IssueID>
        <Title>Make the Grain class unit testable</Title>
        <Description>## Problem

In the current version of Orleans, I faced two issues when writing unit tests. 
1. The GrainFactory is static and cannot be mocked or stubbed in a simple way. 
2. The GetPrimaryKey(),GetPrimaryKeyLong() and GetPrimaryKeyString() methods are also difficult to mock/stub for more than one reason (one of them being that they are extension methods).

For this reason, it is not possible to test Orleans grains without starting a Silo. There are many disadvantages of relying on a Silo:
1. The class under test is not completely isolated because some of the code being tested is communicating with the Orleans runtime.
2. It's not possible to cover all branches/lines of code because there is no simple way to tell the Silo to fail or throw a specific exception (which is possible with mocks).
3. The tests are slower to run and harder to setup.
## Proposal

To solve the above issues, I added two properties to the Grain class:

``

As you can see in the example above, it is very easy to replace the **IGrainLocator** and **IGrainIdentifier** with mocks during unit testing. In addition, using properties instead of a static class or extension methods makes it possible to use **dependency injection** to replace the grain factory and identifier. As a result, with rather simple changes, the unit testing experience of Orleans grains is much better.
## Pull Request
#363
</Description>
        <CreatedDate>27/04/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>443</PullRequestID>
        <IssueID>48</IssueID>
        <Title>Unit testing of grains</Title>
        <Description>@yevhen and @kspeakman expressed some ideas for a better approach to unit testing grains. Let's discuss the ideas here.
</Description>
        <CreatedDate>29/01/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>440</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>veikkoeeva</FixedByID>
    <Title>Added storage emulator auto-start before any tests are run</Title>
    <Description>Currently the test start to fail some time after startup if the storage emulator is not on. This patch provides a thin, programmatic wrapper to start or stop Storage Emulator process and a class to start the emulator before any tests are run.

This looks like being a nice convenience feature, as noted at [PR #412](https://github.com/dotnet/orleans/pull/412#issuecomment-101672812).

This approach might be suitable for refactoring to check if other processes are on too (e.g. database engines) if dependency external libraries such as Fake is not desired.
</Description>
    <CreatedDate>24/05/2015</CreatedDate>
    <ClosedDate>28/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>440</PullRequestID>
        <IssueID>412</IssueID>
        <Title>Azure Table Connection Init Error Handling</Title>
        <Description>- Don't crash silo process (eg mstest agent process) if unable to connect to Azure table -- return exception back to caller for logging and handling.
  [See failure mode below found in Windows Application Error Log]
- Add check for null config object passed to Logger.Initialize
- Use shorter initialization timeout during Azure MT test cases -- don't need to wait a full 2 minutes before each of those test cases report failure.

Failure Mode from Windows Application Error Log:

``
</Description>
        <CreatedDate>13/05/2015</CreatedDate>
        <ClosedDate>13/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>435</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>LeeCampbell</FixedByID>
    <Title>Adding documentation guidelines. Closes #434</Title>
    <Description>As per @jthelin request in #434 
</Description>
    <CreatedDate>22/05/2015</CreatedDate>
    <ClosedDate>22/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>435</PullRequestID>
        <IssueID>434</IssueID>
        <Title>Consistent format in documentation</Title>
        <Description>Hi guys,

Just a small request. I am currently reviewing Orleans after I saw Mark R demo this at Build. The docs are clearly in flux and I have already added some PRs to them.

However, it would be a lot easier to help out if there were some conventions followed
1. If each sentence is on its own line, it makes merging a lot nicer with git. It also has the added benefit of spotting when a sentence is overly verbose. Currently whole paragraphs are on a single line meaning any change to a paragraph by two people will conflict.
2. Have a spell checker turned on? Maybe use http://markdownpad.com/ which has it built in. There are heaps of spelling mistakes in here at the moment. I went to fix a bunch tonight, but the docs all changed under my feet and the merge went to the too-hard basket.
3. Favor headings e.g. ### instead of **bold text** above paragraphs. 
4. Use italics for file names, and paths. e.g. _../dir/file.ext_
</Description>
        <CreatedDate>20/05/2015</CreatedDate>
        <ClosedDate>22/05/2015</ClosedDate>
        <Labels>
          <Label>question</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>422</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Testing Host Part 3</Title>
    <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer

Change:
- Need a different client config for testing client-side streams.

This PR replaces #420 and #421 which got into a bit of a mess!
</Description>
    <CreatedDate>16/05/2015</CreatedDate>
    <ClosedDate>16/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>422</PullRequestID>
        <IssueID>408</IssueID>
        <Title>OrleansTestingHost Package - Part 2</Title>
        <Description>Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with "UnitTest" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with naming convention in other packages.
- Split out some remaining public classes into their own source code files, for easier understanding of the OrleansTestingHost package contents.
- Include some default testing silo / client config files in NuGet package.
- Include NuGet package init.ps1 script to correctly handle install of silo / client config files into target project.

Then, change existing Tester projects over to use the new TestingSiloHost package.
</Description>
        <CreatedDate>11/05/2015</CreatedDate>
        <ClosedDate>12/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>422</PullRequestID>
        <IssueID>420</IssueID>
        <Title>Need a different client config for testing client-side streams.</Title>
        <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>16/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>422</PullRequestID>
        <IssueID>421</IssueID>
        <Title>Testing host part 3</Title>
        <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer

Change:
- Need a different client config for testing client-side streams.

This PR replaces #420 which got into a bit of a mess!
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>16/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>421</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Testing host part 3</Title>
    <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer

Change:
- Need a different client config for testing client-side streams.

This PR replaces #420 which got into a bit of a mess!
</Description>
    <CreatedDate>16/05/2015</CreatedDate>
    <ClosedDate>16/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>421</PullRequestID>
        <IssueID>408</IssueID>
        <Title>OrleansTestingHost Package - Part 2</Title>
        <Description>Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with "UnitTest" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with naming convention in other packages.
- Split out some remaining public classes into their own source code files, for easier understanding of the OrleansTestingHost package contents.
- Include some default testing silo / client config files in NuGet package.
- Include NuGet package init.ps1 script to correctly handle install of silo / client config files into target project.

Then, change existing Tester projects over to use the new TestingSiloHost package.
</Description>
        <CreatedDate>11/05/2015</CreatedDate>
        <ClosedDate>12/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>421</PullRequestID>
        <IssueID>420</IssueID>
        <Title>Need a different client config for testing client-side streams.</Title>
        <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer
</Description>
        <CreatedDate>16/05/2015</CreatedDate>
        <ClosedDate>16/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>420</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Need a different client config for testing client-side streams.</Title>
    <Description>Fixes bug in Nightly test suite introduced by PR #408 

Failure case was: SMSDeactivationTest_ClientConsumer
</Description>
    <CreatedDate>16/05/2015</CreatedDate>
    <ClosedDate>16/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>420</PullRequestID>
        <IssueID>408</IssueID>
        <Title>OrleansTestingHost Package - Part 2</Title>
        <Description>Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with "UnitTest" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with naming convention in other packages.
- Split out some remaining public classes into their own source code files, for easier understanding of the OrleansTestingHost package contents.
- Include some default testing silo / client config files in NuGet package.
- Include NuGet package init.ps1 script to correctly handle install of silo / client config files into target project.

Then, change existing Tester projects over to use the new TestingSiloHost package.
</Description>
        <CreatedDate>11/05/2015</CreatedDate>
        <ClosedDate>12/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>408</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>OrleansTestingHost Package - Part 2</Title>
    <Description>Some final tweaks and fixes to the new TestingSiloHost following on from PR #405
- Eliminate some final places with "UnitTest" in class / file names.
- Normalize namespace in OrleansTestingHost package to align with naming convention in other packages.
- Split out some remaining public classes into their own source code files, for easier understanding of the OrleansTestingHost package contents.
- Include some default testing silo / client config files in NuGet package.
- Include NuGet package init.ps1 script to correctly handle install of silo / client config files into target project.

Then, change existing Tester projects over to use the new TestingSiloHost package.
</Description>
    <CreatedDate>11/05/2015</CreatedDate>
    <ClosedDate>12/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>408</PullRequestID>
        <IssueID>405</IssueID>
        <Title>Add UnitTest nuget package</Title>
        <Description>It could be useful if we are able to add unit test silo host with a nuget package.
</Description>
        <CreatedDate>09/05/2015</CreatedDate>
        <ClosedDate>11/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>396</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Documented IMembershipTable.</Title>
    <Description>To help in #382.
</Description>
    <CreatedDate>06/05/2015</CreatedDate>
    <ClosedDate>06/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>396</PullRequestID>
        <IssueID>382</IssueID>
        <Title>ZooKeeper - new membership provider</Title>
        <Description>#69 says:

&gt; Statically adding a new implementation to the code, and hooking it all the way in the MembershipFactory - sure, great idea! I am in fact planning to post as an issue an open "student idea" for hookup Zookeeper as a membership provider.

I think that membership providers configuration should be consistent with storage providers. This would make Orleans cleaner and alleviate dragging dependencies to various DBs.
While adding this extensibility, It seems natural to remove the GatewayProviderType and LivenessProviderType enums. This will ease the removal of dependencies on Azure. (https://github.com/dotnet/orleans/issues/136).

Going back to the main issue of Zookeeper.
[ZooKeeper Programmer's Guide](http://zookeeper.apache.org/doc/r3.1.2/zookeeperProgrammers.html) states that:

&gt; ZooKeeper does not guarantee that at every instance in time, two different clients will have identical views of ZooKeeper data. Due to factors like network delays, one client may perform an update before another client gets notified of the change.

Consequently, Do we need to use a [Zookeeper Recipe](http://zookeeper.apache.org/doc/r3.1.2/recipes.html) like [Shared Reentrant Read Write Lock](http://curator.apache.org/curator-recipes/shared-reentrant-read-write-lock.html)?
If we only use a [Shared Lock](http://curator.apache.org/curator-recipes/shared-lock.html) for writing, a silo might get a stale value of the membership table. I'm not sure how Orleans deals with this scenario as the current implementations (Azure,Sql Server) guarantee fresh values.
</Description>
        <CreatedDate>04/05/2015</CreatedDate>
        <ClosedDate>11/06/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
          <Label>question</Label>
          <Label>under-investigation</Label>
          <Label>work-in-progress</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>394</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Use .Equals() rather than == for comparing GrainId's</Title>
    <Description>Use .Equals() rather than == for comparing GrainId's
- This is a follow-on fix from PR #391 to fix the same problem in MessageCenter.SendMessage.
</Description>
    <CreatedDate>06/05/2015</CreatedDate>
    <ClosedDate>06/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>394</PullRequestID>
        <IssueID>391</IssueID>
        <Title>Code cleanup 05/05</Title>
        <Description>Code cleanup
- Some minor code cleanup suggested by some internal code walkthroughs + ReSharper.
- The only significant change is likely to be Line 450 in IncomingMessageAcceptor.cs

Changed from: `msg.SendingGrain != Constants.SystemMembershipTableId`
To: `!Constants.SystemMembershipTableId.Equals(msg.SendingGrain)`

ReSharper pointed out a "possible unintended reference comparison" warning, and i think they are right.

Although GrainId's _should_ all be interned so ref-compare should / may work ok,
i think it safest to use .Equals comparison to ensure we really do get the semantics we expect.
</Description>
        <CreatedDate>05/05/2015</CreatedDate>
        <ClosedDate>06/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>389</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>PubSubRendezvousGrain: clear state from storage if it becomes empty upon activation</Title>
    <Description>This is a small improvement over #336.

It addresses an edge case where it is possible for a `PubSubRendezvousGrain` to remove all producers upon activation. 
If the grain has no consumers and the sole reason for activation is a call to `GetAllSubscriptions` (through a call to `GetAllSubscriptionHandles` on the corresponding stream),  the grain will fail to clear its (now empty) state from storage.

Note that I did not add a call to  DeactivateOnIdle() , as the reasons for the grain being activated may include adding consumers/producers.
</Description>
    <CreatedDate>05/05/2015</CreatedDate>
    <ClosedDate>06/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>389</PullRequestID>
        <IssueID>336</IssueID>
        <Title>Clear empty PubSubRendevousGrain state from storage</Title>
        <Description>Clear `PubSubRendevousGrain` state from storage when there are no consumers or subscribers.
Helpful when using a large number of transient, one-time-use, streams.
</Description>
        <CreatedDate>16/04/2015</CreatedDate>
        <ClosedDate>16/04/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>388</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Minor improvements to SMSDeactivationTests.</Title>
    <Description>Minor improvements over @ca-ta PR #380 .
</Description>
    <CreatedDate>05/05/2015</CreatedDate>
    <ClosedDate>05/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>388</PullRequestID>
        <IssueID>380</IssueID>
        <Title>Repro for #378</Title>
        <Description>Repro for #378: Run `SMSDeactivationTest`

Notes:
- The test is marked as BVT, but it takes 3+ minutes to execute - you may want to relegate it to nightly runs only
- I haven't created a similar test for the AQ streams - it's trivial to add one, though.
- The test shows that the deactivation cycle hangs and that subsequent calls to one of the grains involved in the deadlock hang. Adding more tests assessing the extent of the silo degradation may make sense (e.g. trying to activate an unrelated grain, etc.).
- I've observed that if one waits further (minutes?) the silo eventually commits suicide.
</Description>
        <CreatedDate>04/05/2015</CreatedDate>
        <ClosedDate>05/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>380</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Repro for #378</Title>
    <Description>Repro for #378: Run `SMSDeactivationTest`

Notes:
- The test is marked as BVT, but it takes 3+ minutes to execute - you may want to relegate it to nightly runs only
- I haven't created a similar test for the AQ streams - it's trivial to add one, though.
- The test shows that the deactivation cycle hangs and that subsequent calls to one of the grains involved in the deadlock hang. Adding more tests assessing the extent of the silo degradation may make sense (e.g. trying to activate an unrelated grain, etc.).
- I've observed that if one waits further (minutes?) the silo eventually commits suicide.
</Description>
    <CreatedDate>04/05/2015</CreatedDate>
    <ClosedDate>05/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>380</PullRequestID>
        <IssueID>378</IssueID>
        <Title>Silo deadlocks when PubSubRendevousGrain is GC-ed in the same cycle with a Provider</Title>
        <Description>I've just stumbled upon this during testing:

Given a `PubSubRendevousGrain` grain **A**, managing stream **x** and another grain, **B**, publishing to stream **x**:

If **A** and **B** are deactivated during the same Orleans GC cycle, `Catalog.CleanupStreams` never returns. 
The silo hosting the grains deadlocks, further requests to grain **B** timeout and the silo eventually commits suicide.

One way to repro is to use the local silo, set the GC to 1 minute and craft a scenario where one subscribes to stream **x** and then immediately pushes an event to stream **x** from grain **B** (e.g. as a side-effect of calling a method on **B**). 

I haven't tested with a multi-silo scenario - I suspect the problem exists in that case as well.

Here's a relevant log excerpt (had to wait for the silo to die):

``

While battling the above, I've wondered if there is an reasonable way in place for testing this type of activation/deactivation scenarios. Ideally we'd have a way to manually GC a known set of grains during testing - and also to set short timeouts for the deactivation operation. I haven't dug through all the tests/test harnesses in detail - please let me know if such facilities exists and I've missed them.
</Description>
        <CreatedDate>03/05/2015</CreatedDate>
        <ClosedDate>08/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>379</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>PubSubRendezvousGrain: clear empty state on activation (follow-up to #336)</Title>
    <Description>Small addition to #336 - missed the case where the grain can end up with no producers or consumers during activation.

Did not add a call to `DeactivateOnIdle()`, as the reasons for the grain being activated may include adding consumers/producers.
</Description>
    <CreatedDate>04/05/2015</CreatedDate>
    <ClosedDate>04/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>379</PullRequestID>
        <IssueID>336</IssueID>
        <Title>Clear empty PubSubRendevousGrain state from storage</Title>
        <Description>Clear `PubSubRendevousGrain` state from storage when there are no consumers or subscribers.
Helpful when using a large number of transient, one-time-use, streams.
</Description>
        <CreatedDate>16/04/2015</CreatedDate>
        <ClosedDate>16/04/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>374</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>gabikliot</FixedByID>
    <Title>Fixed code gen breaking with type without namespace (empty using statement emitted).</Title>
    <Description>Fixes #369.
</Description>
    <CreatedDate>02/05/2015</CreatedDate>
    <ClosedDate>02/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>374</PullRequestID>
        <IssueID>369</IssueID>
        <Title>Defining a class or enum without namespace will cause codegen to fail</Title>
        <Description>If you do not specify a namespace for a class or enum and try and reference it in an IGrainState, codegen with fail by putting in:

``
</Description>
        <CreatedDate>01/05/2015</CreatedDate>
        <ClosedDate>02/05/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>364</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>AzureWebSample - switch to using NuGet packages plus general cleanup.</Title>
    <Description>AzureWebSample - switch to using NuGet packages plus general cleanup.

Squashed commit:

[6a811e1] AzureWebSample-ReadMe
- Add more introductory info into the ReadMe for this sample.
- Renamed to .md now that it contains Markdown formatting.
- Added ReadMe into .sln for this sample, for easier reference / discoverability / linking.

[21c6a0a] Temporarily remove CounterControl startup task which does not work in local Azure compute emulator.

[61ccb07] Convert Hello grains to use NuGet packages.

[4e8b5ac] Include OrleansHost.exe.config into worker role silo files.

[f024d33] Normalize to ToolsVersion=12.0

[5a85d9c] NuGet Package Manager keeps adding more bindingRedirects!

[ec9e7a8] Add Azure SDK v2.5 diagnostic config settings.

[6fa9f2b] UseIISExpress=True

[2b8b835] Set vmsize=Medium for silo worker role, for more realistic deployment setting.

[59c0e7b] Normalize to ToolsVersion="12.0"
- ToolsVersion 4.0 is out of date.

[d5b704c] Use Orleans Server and Client NuGet
- Use Orleans Server and Client NuGet packages rather than referencing $(OrleansSDK.)

[139bdba] Use PreserveNewest rather than Always copy files.

[4a57908] SpecificVersion=False
- Use unversioned assembly references without SpecificVersion=False.

[7c7d695] Remove junk elements in .csproj files.

[23a07a7] Remove old ServerBin directory &amp; contents.

This change addresses work item #361 
</Description>
    <CreatedDate>28/04/2015</CreatedDate>
    <ClosedDate>30/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>364</PullRequestID>
        <IssueID>361</IssueID>
        <Title>Update AzureWebSample to use NuGet packages</Title>
        <Description>Recording outstanding TODO item to update AzureWebSample to use NuGet packages.
</Description>
        <CreatedDate>27/04/2015</CreatedDate>
        <ClosedDate>30/04/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>363</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>nehmebilal</FixedByID>
    <Title>Add GrainLocator and GrainIdentifier properties to the Grain class.</Title>
    <Description>Adding these two properties makes it possible to unittest a grain without starting a Silo.

Fixes #362 #48 
</Description>
    <CreatedDate>27/04/2015</CreatedDate>
    <ClosedDate>27/05/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>363</PullRequestID>
        <IssueID>362</IssueID>
        <Title>Make the Grain class unit testable</Title>
        <Description>## Problem

In the current version of Orleans, I faced two issues when writing unit tests. 
1. The GrainFactory is static and cannot be mocked or stubbed in a simple way. 
2. The GetPrimaryKey(),GetPrimaryKeyLong() and GetPrimaryKeyString() methods are also difficult to mock/stub for more than one reason (one of them being that they are extension methods).

For this reason, it is not possible to test Orleans grains without starting a Silo. There are many disadvantages of relying on a Silo:
1. The class under test is not completely isolated because some of the code being tested is communicating with the Orleans runtime.
2. It's not possible to cover all branches/lines of code because there is no simple way to tell the Silo to fail or throw a specific exception (which is possible with mocks).
3. The tests are slower to run and harder to setup.
## Proposal

To solve the above issues, I added two properties to the Grain class:

``

As you can see in the example above, it is very easy to replace the **IGrainLocator** and **IGrainIdentifier** with mocks during unit testing. In addition, using properties instead of a static class or extension methods makes it possible to use **dependency injection** to replace the grain factory and identifier. As a result, with rather simple changes, the unit testing experience of Orleans grains is much better.
## Pull Request
#363
</Description>
        <CreatedDate>27/04/2015</CreatedDate>
        <ClosedDate>27/05/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>363</PullRequestID>
        <IssueID>48</IssueID>
        <Title>Unit testing of grains</Title>
        <Description>@yevhen and @kspeakman expressed some ideas for a better approach to unit testing grains. Let's discuss the ideas here.
</Description>
        <CreatedDate>29/01/2015</CreatedDate>
        <ClosedDate>23/10/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>349</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Instantiating grains that directly implement generic interfaces (+ tests)</Title>
    <Description>Fixes #338, Replaces #342

Hi guys, this a one-commit version  of #342, with further changes and tests addressing a couple of edge cases. The one significant change from #342  is that I was forced to serialize the `isGeneric` field in  `GrainClassData`. This is required so that the client can create the correct `GrainId`. Otherwise trying to obtain references to different generic interfaces of the same grain creates one activation per generic interface - see the tests for details, more specifically `GenericGrainTests_ConcreteGrainWithMultipleGenericInterfacesMultiplicity2`.
Another change is that the grain reference creation process now passes along an instance of `GrainCassData` instead of just the grain type code. This should be just fine, as `GrainCassData` can not be mutated (there is some internal caching going on, but that's not an issue).

In essence, with this change one can create grain classes that implement one or more generic interfaces and obtain grain references to those interfaces. This allows for a development  approach where one can define a small number of generic interfaces and then create grains that implement one or more of them, without the need for additional non-generic marker interfaces. Basically we get _type-safe_ uniform interfaces.

And yes, writing tests helps :-) All tests pass, including 9 new ones.
</Description>
    <CreatedDate>20/04/2015</CreatedDate>
    <ClosedDate>21/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>349</PullRequestID>
        <IssueID>338</IssueID>
        <Title>Unable to instantiate grains that only implement generic interfaces</Title>
        <Description>Minimal repro scenario:
- Only one, generic, grain interface is defined. E.g., `IFoo&lt;T&gt; : IGrain`
- Given n types T1...Tn, we create n grain implementations: `Grain_1: IFoo&lt;T1&gt;` ... `Grain_n: IFoo&lt;Tn&gt;`
- Given 1 &lt;= x &lt;= n,  trying to obtain a reference to all but one of `Grain_x` by using ``GrainFactory.GetGrain&lt;IFoo&lt;Tx&gt;&gt;(...)'' will fail. 

The failure stems from a discrepancy between the way keys are calculated in two map members of `GrainInterfaceMap`: `table` and `typeToInterfaceData`. What happens is that while the type key is (correctly) computed based on the complete generic interface name (that is, including the names of the generic parameter types), the string key in `typeToInterfaceData` only contains the generic type definition name, stripped of the generic parameters (via a call to `GetGenericTypeDefinition`).
Because of this, `TryGetGrainTypeCode` fails to locate the correct grain implementation, as only one entry is ever added to `typeToInterfaceData``, for all variations of``IFoo&lt;T&gt;``.

Looking at the code, it appears that `typeToInterfaceData` is an implementation detail meant as an optimization - possibly to avoid having to compute the interface type hash. 

After a quick inspection, I see two possible fixes:
1. remove  `typeToInterfaceData` and use `table` in `TryGetGrainTypeCode`  (and compute the interface type hash on every call). This has the advantage of reducing complexity and being easy to understand. I don't know whether the additional hash computation cost is relevant in the scheme of things, though.
2. keep   `typeToInterfaceData`  and remove the calls to `GetGenericTypeDefinition` when computing the `typeToInterfaceData` keys.

Please let me know which approach you'd rather prefer and I'll submit a PR.
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>21/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>349</PullRequestID>
        <IssueID>342</IssueID>
        <Title>Instantiating grains that implement only generic interfaces</Title>
        <Description>Fixes #338 

All tests in TestAll.cmd pass (and my grains now work, yay :-) ).

Notes:
- One can now instantiate _non-generic_ grains that directly implement one or more generic interfaces
- For _generic_ grain classes, the constraints that were already implied in the code still apply (i.e. the generic class must take the same generic arguments as the implemented generic interface)
  - note that I am unsure if that particular code path was ever hit - I think that scenario was also broken (I have not tested it, though).

Please review, especially the change to `GrainClassData`. I have noticed that it is serializable and I have marked the newly introduced field as `[NonSerialized]` in an attempt to not break a rolling update scenario. I've followed what seems to be an existing pattern, but I am not in love with that particular bit - while it works (the relevant method is only called from the `Catalog`), it feels quite brittle.
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>19/04/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>349</PullRequestID>
        <IssueID>342</IssueID>
        <Title>Instantiating grains that implement only generic interfaces</Title>
        <Description>Fixes #338 

All tests in TestAll.cmd pass (and my grains now work, yay :-) ).

Notes:
- One can now instantiate _non-generic_ grains that directly implement one or more generic interfaces
- For _generic_ grain classes, the constraints that were already implied in the code still apply (i.e. the generic class must take the same generic arguments as the implemented generic interface)
  - note that I am unsure if that particular code path was ever hit - I think that scenario was also broken (I have not tested it, though).

Please review, especially the change to `GrainClassData`. I have noticed that it is serializable and I have marked the newly introduced field as `[NonSerialized]` in an attempt to not break a rolling update scenario. I've followed what seems to be an existing pattern, but I am not in love with that particular bit - while it works (the relevant method is only called from the `Catalog`), it feels quite brittle.
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>19/04/2015</ClosedDate>
        <Labels />
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>349</PullRequestID>
        <IssueID>342</IssueID>
        <Title>Instantiating grains that implement only generic interfaces</Title>
        <Description>Fixes #338 

All tests in TestAll.cmd pass (and my grains now work, yay :-) ).

Notes:
- One can now instantiate _non-generic_ grains that directly implement one or more generic interfaces
- For _generic_ grain classes, the constraints that were already implied in the code still apply (i.e. the generic class must take the same generic arguments as the implemented generic interface)
  - note that I am unsure if that particular code path was ever hit - I think that scenario was also broken (I have not tested it, though).

Please review, especially the change to `GrainClassData`. I have noticed that it is serializable and I have marked the newly introduced field as `[NonSerialized]` in an attempt to not break a rolling update scenario. I've followed what seems to be an existing pattern, but I am not in love with that particular bit - while it works (the relevant method is only called from the `Catalog`), it feels quite brittle.
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>19/04/2015</ClosedDate>
        <Labels />
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>342</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Instantiating grains that implement only generic interfaces</Title>
    <Description>Fixes #338 

All tests in TestAll.cmd pass (and my grains now work, yay :-) ).

Notes:
- One can now instantiate _non-generic_ grains that directly implement one or more generic interfaces
- For _generic_ grain classes, the constraints that were already implied in the code still apply (i.e. the generic class must take the same generic arguments as the implemented generic interface)
  - note that I am unsure if that particular code path was ever hit - I think that scenario was also broken (I have not tested it, though).

Please review, especially the change to `GrainClassData`. I have noticed that it is serializable and I have marked the newly introduced field as `[NonSerialized]` in an attempt to not break a rolling update scenario. I've followed what seems to be an existing pattern, but I am not in love with that particular bit - while it works (the relevant method is only called from the `Catalog`), it feels quite brittle.
</Description>
    <CreatedDate>17/04/2015</CreatedDate>
    <ClosedDate>19/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>342</PullRequestID>
        <IssueID>338</IssueID>
        <Title>Unable to instantiate grains that only implement generic interfaces</Title>
        <Description>Minimal repro scenario:
- Only one, generic, grain interface is defined. E.g., `IFoo&lt;T&gt; : IGrain`
- Given n types T1...Tn, we create n grain implementations: `Grain_1: IFoo&lt;T1&gt;` ... `Grain_n: IFoo&lt;Tn&gt;`
- Given 1 &lt;= x &lt;= n,  trying to obtain a reference to all but one of `Grain_x` by using ``GrainFactory.GetGrain&lt;IFoo&lt;Tx&gt;&gt;(...)'' will fail. 

The failure stems from a discrepancy between the way keys are calculated in two map members of `GrainInterfaceMap`: `table` and `typeToInterfaceData`. What happens is that while the type key is (correctly) computed based on the complete generic interface name (that is, including the names of the generic parameter types), the string key in `typeToInterfaceData` only contains the generic type definition name, stripped of the generic parameters (via a call to `GetGenericTypeDefinition`).
Because of this, `TryGetGrainTypeCode` fails to locate the correct grain implementation, as only one entry is ever added to `typeToInterfaceData``, for all variations of``IFoo&lt;T&gt;``.

Looking at the code, it appears that `typeToInterfaceData` is an implementation detail meant as an optimization - possibly to avoid having to compute the interface type hash. 

After a quick inspection, I see two possible fixes:
1. remove  `typeToInterfaceData` and use `table` in `TryGetGrainTypeCode`  (and compute the interface type hash on every call). This has the advantage of reducing complexity and being easy to understand. I don't know whether the additional hash computation cost is relevant in the scheme of things, though.
2. keep   `typeToInterfaceData`  and remove the calls to `GetGenericTypeDefinition` when computing the `typeToInterfaceData` keys.

Please let me know which approach you'd rather prefer and I'll submit a PR.
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>21/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>340</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>GrainFactory.GetGrain - pass grainClassNamePrefix to _MakeGrainReference</Title>
    <Description>Fixes #339
</Description>
    <CreatedDate>17/04/2015</CreatedDate>
    <ClosedDate>17/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>340</PullRequestID>
        <IssueID>339</IssueID>
        <Title>GrainFactory.GetGrain&lt;&gt;(...) fails to pass grainClassPrefixName to _MakeGrainReference</Title>
        <Description>This only happens for the `IGrainWithStringKey` flavor.
PR coming shortly
</Description>
        <CreatedDate>17/04/2015</CreatedDate>
        <ClosedDate>17/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>335</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>jthelin</FixedByID>
    <Title>Fix Vsix Template for DevTestSiloHost</Title>
    <Description>Fix problems vsix project template for DevTestSiloHost in issue #319.

Includes and supersedes PR #325 from @nicolocodev with some additional required changes.

Main bits of this change are in 129cade and 4de2751

TODO: Update templates to use Orleans v1.0.6 NuGet packages, but will be sent as separate PR once this PR is merged so this can focus on the original bug fix.
</Description>
    <CreatedDate>15/04/2015</CreatedDate>
    <ClosedDate>16/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>335</PullRequestID>
        <IssueID>319</IssueID>
        <Title>Add packages.config and restore on DevHost/TestHost Projects</Title>
        <Description>I've updated to SDK v.1.0.5 and noticed that when I create/add new DevHost/TestHost Project (from VS2013 ultimate) is not included any of Orleans dlls. You must add these references from nuget: `Microsoft.Orleans.Core` and `Microsoft.Orleans.OrleansRuntime` manually :(
</Description>
        <CreatedDate>11/04/2015</CreatedDate>
        <ClosedDate>16/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>335</PullRequestID>
        <IssueID>325</IssueID>
        <Title>Added package.config file in VSProjectSilohost ProjectTemplate</Title>
        <Description>Trying to fix the #319  

This PR doesn't fix the issue at all, as I said, the nuget restore action can't run scripts, so the Orleans.Server's install.ps1 does not run :disappointed:
</Description>
        <CreatedDate>14/04/2015</CreatedDate>
        <ClosedDate>15/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>331</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>cata</FixedByID>
    <Title>Json serialization support for PubSubRendevousGrain state</Title>
    <Description>Fixes #328 
</Description>
    <CreatedDate>15/04/2015</CreatedDate>
    <ClosedDate>15/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>331</PullRequestID>
        <IssueID>328</IssueID>
        <Title>PubSubRendevousGrain state does not support JSON serialization</Title>
        <Description>I am using a custom storage provider (which uses JSON serialization) and I've noticed that the PubSubRendevousGrain state fails to round-trip.

The culprits are `PubSubSubscriptionState`, `PubSubPublisherState` and `GuidId`.

I have it now working locally, but it smells:
- Removing `readonly` from the `PubSubSubscriptionState`,  `PubSubPublisherState`  and `GuidId` properties. 
  - This might be tolerable for the first two, as the classes are internal. Still, it's ugly.
  - I do not think it is acceptable for GuidId
- making the constructors public for all three classes:
  - again, this might be OK for `PubSubSubscriptionState` and `PubSubPublisherState`  
  - However, `GuidId` is a public class and uses a lazy cache (`Interner`). Having a public constructor smells quite badly.

Are there any plans on supporting JSON serialization for PubSubRendevousGrain state? 
Before digging further (or move to using binary serialization) I though of asking if a pattern for addressing this type of issues is already in place...
</Description>
        <CreatedDate>15/04/2015</CreatedDate>
        <ClosedDate>15/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>330</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>carlos-sarmiento</FixedByID>
    <Title>Change ExtendedPrimaryKey to IGrainWith Interface</Title>
    <Description>Removed the ExtendedPrimaryKeyAttribute class
and replaced it with a couple of IGrainWithCompoundKey
interfaces to unify the API and remove the inconsistency
with the new design.

Fix #326
</Description>
    <CreatedDate>15/04/2015</CreatedDate>
    <ClosedDate>15/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>330</PullRequestID>
        <IssueID>326</IssueID>
        <Title>Add IGrainWithCompoundKey inteface and remove ExtendedPrimaryKeyAttribute</Title>
        <Description>This is to make extended primary keys usable with GrainFactory.GetGrain&lt;T&gt; and eliminate the confusion from the fact that ExtendedPrimaryKeyAttribute only works today for grain interfaces that extend IGrain.
</Description>
        <CreatedDate>14/04/2015</CreatedDate>
        <ClosedDate>15/04/2015</ClosedDate>
        <Labels>
          <Label>enhancement</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
  <PullRequest>
    <IssueID>325</IssueID>
    <RepoID>orleans</RepoID>
    <FixedByID>nicolocodev</FixedByID>
    <Title>Added package.config file in VSProjectSilohost ProjectTemplate</Title>
    <Description>Trying to fix the #319  

This PR doesn't fix the issue at all, as I said, the nuget restore action can't run scripts, so the Orleans.Server's install.ps1 does not run :disappointed:
</Description>
    <CreatedDate>14/04/2015</CreatedDate>
    <ClosedDate>15/04/2015</ClosedDate>
    <Issues>
      <Issue>
        <RepoID>orleans</RepoID>
        <PullRequestID>325</PullRequestID>
        <IssueID>319</IssueID>
        <Title>Add packages.config and restore on DevHost/TestHost Projects</Title>
        <Description>I've updated to SDK v.1.0.5 and noticed that when I create/add new DevHost/TestHost Project (from VS2013 ultimate) is not included any of Orleans dlls. You must add these references from nuget: `Microsoft.Orleans.Core` and `Microsoft.Orleans.OrleansRuntime` manually :(
</Description>
        <CreatedDate>11/04/2015</CreatedDate>
        <ClosedDate>16/04/2015</ClosedDate>
        <Labels>
          <Label>bug</Label>
        </Labels>
      </Issue>
    </Issues>
  </PullRequest>
</PullRequests>