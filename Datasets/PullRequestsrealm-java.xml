<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<PullRequests>
      
    <PullRequest>
            
        <IssueID>6786</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for Api Key Auth Provider</Title>
            
        <Description>Depends on being merged first. This PR adds support for the ApiKeyAuthProvider with the following methods A new wrapper class representing the key has been introduced as well Note the server sends a "disabled" key. This has been reversed in the API to enabled as exposing negative booleans is generally discouraged. 
    </Description>
        
        <code>  
createApiKey(name: String): RealmUserApiKey
 fetchApiKey(id: ObjectId): RealmUserApiKey
 fetchAllApiKeys(): List&lt;RealmUserApiKey&gt;
 deleteApiKey(id: ObjectId): Void
 enableApiKey(id: ObjectId): Void
 deleteApiKey(id: ObjectId): Void
 
class RealmUserApiKey {
  val id: ObjectId
  val name: String
  val value?: String
  val enabled: boolean
}
</code>
            
        <CreatedDate>27/03/2020</CreatedDate>
            
        <ClosedDate>03/04/2020</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6785</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add supportforallUsersswitchUserremoveUser</Title>
            
        <Description>Depends on being merged first.  Adds support for  TODO Fix remaining tests once is merged.</Description>
          
        <code>RealmApp.allUsers(): Map&lt;String, RealmUser&gt;
 RealmApp.switchUser(user: RealmUser): RealmUser
 RealmApp.removeUser(user: RealmUser): RealmUser
 RealmApp.removeUser(user: RealmUser, callback: Callback&lt;RealmUser&gt;): RealmUser
</code>
            
        <CreatedDate>25/03/2020</CreatedDate>
            
        <ClosedDate>01/04/2020</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6783</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for Email Password AuthProvider</Title>
            
        <Description>Add support for the Email Password Auth Provider and associated functions. register User confirm User  resend Confirmation Email  send Reset Password Email  call Reset Password Function  reset Password  Integration tests for confirmUser and resetPassword are not possible currently. Added them as TODO items in 
 Callbacks  Getting great callback support between Java and Kotlin is turning out to be fairly problematic. Currently, we have this interface in Java    
This actually works pretty well in Java even with Nullability annotations. The problem is that we have a really common use case of T being Void and that causes problems in Kotlin because you cannot create instances of Void, which means that null is usually used which breaks the type system in Kotlin.      Fixing this through annotations has turned out to be impossible due to where these annotations can be placed. I'll be happy to elaborate on the details if needed.  This leaves us with  options as far as I can tell Make onSuccess always nullable: public void onSuccess(@Nullable T t). This turns into T? on the Kotlin side, which gets really annoying for consumers when the type isn't Void. Create two interfaces Callback and VoidCallback with the later having no arguments for onSuccess. This just feels extremely annoying API wise.  ) Split Callback into  SAM interfaces. OnSuccess, OnVoidSuccess and OnError. We actually do something similar for transactions right now. This approach looks fairly nice in Kotlin and with lamdas in Java. Without Lambdas it is a lot of boilerplate. I also have concerns with regards to how understandable the API is. It is pretty important that people handle the onError case since it involves a network, so both should always be present. Thus splitting into two interfaces feel a bit wrong. Also still having OnSuccess and OnVoidSuccess is annoying.  ) The currently implemented solution. I'm using reflection to hack around not being able to create an instance of Void. But with an instance of Void Kotlin support is no longer broken. It does mean that onSuccess(Void v) in Java will actually return an instance of Void instead of null, but nobody should be checking that anyway. 
 TODO  ntegration tests Describe the tradeoffs of the Callback using reflection for Void  Async implementation
</Description>
        
        <code>
  public interface Callback&lt;T&gt; {
        void onSuccess(T t);
        void onError(ObjectServerError error);
    }
	
val callback = object: RealmApp.Callback&lt;Void&gt; {
  override fun onSuccess(t: Void) { /  Crash with null pointer exception / }
  override fun onError(error: Throwable) {  }
}

</code>
            
        <CreatedDate>24/03/2020</CreatedDate>
            
        <ClosedDate>29/03/2020</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6783</PullRequestID>
                        
                <IssueID>6756</IssueID>
                        
                <Title>MongoDB Realm: Merging Realm and Stitch</Title>
                        
                <Description>DO NOT PUSH DIRECTLY TO THIS PR. All changes should be through other PR's. This PR replaces Closes  This PR is an umbrella PR for all things related to the SDK merge between Stitch and Realm. Currently, it is exp cted to be released after the Core 6 upgrade that is labeled 7.0. After discussion alternatives, this release is tentatively labeled as 10.0 See Goals Local database users should see no changes ideally. Existing sync users using fully synchronized Realms should be able to upgrade with relatively little changes. Remove all references and APIs to Querybased SyncRemove all references and APIs to Permissions and Roles Add functionality required for the merge purposely left vague for now TODO Incomplete Figure out what happens to ROS error codes when using Stitch for Aut Remove all Object Level permission API's. They are now handled on Stitch Realm Cloud Remove Querybasedsync. Support will look different when backed by Atlas.Consider adding support for androidx.startup as a mean to remove Realm.initcontext. This could align us with how SDK's are going to initialize the RealmApp class. Fix Reenable PMD and Checkstyle Reenable unitTestExample Rethink how secureUserStore example works Fix objectServerExample and rename to mongoDbRealmExample Reenable Dokka for Kotlin Extensions Test all transport methods: get, post, patch, delete, putFix transport leak in RealmApp.nativeCreate Move support for proxies and custom headers Move support for custom certificates Add support for JSONErrorCode from ObjectStore Reenable JavaDoc generation Store Stitch logs as CI artifacts Don't use images on AWS, but from Github Docker Registry instead Move old SyncManager.AuthenticationListener to RealmAppDefine what is the default log level. INFO or WARN? Disable Client Resync modes Review JavaDoc for RealmApp.logOut and RealmUser.logOut Cleanup RealmApp/RealmUser responsibility. Remove Client Resync from the public API LinkUser still having issues in ObjectStoreMissing Stitch functionalityRealmApp super class most of old SyncUser methods AppCredentials + tests except thirdparty auth ApiKey credentials CustomFunction credentials RealmUser and tests Finalize RealmAppConfiguration  JavaDoc Realm FCM Push Notifications Email Password Provider Client Api Key Provider Client Realm App link User Custom Data where Remote mongo db client Realm Functions Addpartion Key to Sync Configuration initial support for QB Sinthenew Realm Cloud Openasynced Realm
</Description>
                
                <code>
RealmApp.Login()
  RealmApp.Logout() 
  RealmApp.currentUser()
  RealmApp.allUsers()
  RealmApp.switchUser()
  RealmApp.removeUser()
</code>
                        
                <CreatedDate>24/02/2020</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6770</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Temporarelydisablebrokenunittests</Title>
            
        <Description>Disable all tests using the SyncUser. The new token format is breaking a lot of tests. These should be reenabled as part of 6757 </Description>
            
        <CreatedDate>07/03/2020</CreatedDate>
            
        <ClosedDate>08/03/2020</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6770</PullRequestID>
                        
                <IssueID>6757</IssueID>
                        
                <Title>Add support for RealmApp (and MongoDB Realm)</Title>
                        
                <Description>This PR lays the groundwork for the new RealmApp API interacting with MongoDB Realm. The idea is that local Realms should not be impacted by this change. The way synced Realms are opened should be minimally impacted:     Biggest changes  Most of the API's found on SyncUser moves to RealmApp.  SyncManager is gone. Any relevant functionality has moved to RealmApp.  RealmCredentials replaces SyncCredentials.  RealmUser replaces SyncUser and becomes a more shallow class mostly exposing profile info.  RealmApp is now configured upfront using RealmAppConfiguration instead of using setters that could only be called until the first Realm was opened.  Most of the network logic for defining requests, parsing results, retrying, are now in Object Store. The Java layer is only responsible for executing the request. This is referred to as the Network Transport.  The UserStore interface has been removed. Users are now stored using the RealmApp. An encryption key can be configured in the config object if desired this has not been implemented yet.   Note for Reviewers   There are a lot of FIXME's and code that has been disabled in this commit. All of these will be fixed in other PR's. Sorry for the mess :  The only thing considered "done done" in this PR is the network transport on both the Java and C++ side + their associated tests.  Other important bits are the JenkinsFile and integration test setup.  Naming of public classes are NOT finalized with this PR. This is just the first guess.  This PR contains a TODO List with all remaining tasks: 
 TODO    Finalize naming of public API classes. Implement and test Network Transport. Implement skeleton login  Remove the UserStore abstraction. Depend on OS for storing users punt encryption support to another   RealmUser initial support   RealmCredentials limited   RealmApp initial support   Disable all current integration tests / unit tests of replaced classes   Make it posssible and easy to run integration tests on both CI and locally.</Description>
                        
                <CreatedDate>26/02/2020</CreatedDate>
                        
                <ClosedDate>19/03/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6767</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>joxon</FixedByID>
            
        <Title>Add support for Realm Proxy to String to print length information for binary field</Title>
            
        <Description>Fixes 1650</Description>
            
        <CreatedDate>05/03/2020</CreatedDate>
            
        <ClosedDate>16/03/2020</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>PipelineWaitingforUser</PullRequestLabel>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6767</PullRequestID>
                        
                <IssueID>1650</IssueID>
                        
                <Title>RealmProxytoString() should print length information for binary field</Title>
                        
                <Description>Current implementation simply call generates something like Foo.We should print for binary bytes binaryetc.</Description>
                		
                <code>
		byte[].toString()
		RealmProxy.toString() 
		</code>
                        
                <CreatedDate>23/10/2015</CreatedDate>
                        
                <ClosedDate>16/03/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>FirstGoodIssue</Label>
                              
                    <Label>PipelineIdeaBacklog</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6760</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>UpgradetoSync10.0.0alpha.1.DisableallSyncbuilds</Title>
            
        <Description>This upgrade to latest Core Sync relase, but due to a bug in the Sync release it doesn't work. So all Sync builds have been disabled.  Merging this PR should unblock embedded objects and the new datatypes though  Note there are also a few changes to how AccessTokens are exposed. This is a temporary solution that will be fixed in the RealmApp PR </Description>
            
        <CreatedDate>27/02/2020</CreatedDate>
            
        <ClosedDate>28/02/2020</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6760</PullRequestID>
                        
                <IssueID>6730</IssueID>
                        
                <Title>Add support for Embedded Objects</Title>
                        
                <Description>Closes This PR adds support for Embedded Objects. For nonsynced Realms, the only benefit is that it can be be used to implement cascading deletes in some scenarios. For synced Realms it also describes how the data is serialized once it reaches a MongoDB server. Semantics Embedded objects have slightly different semantics than normal objects When the parent of an embedded object is deleted, so is the embedded object.  Setting the link to the embedded object to null will also delete the embedded object.  Only one parent can ever link to an embedded object. Embedded objects can be parents themselves.  PrimaryKey is not supported on embedded objects.  Freefloating embedded objects with no parents are not possible, not even as a temporary state. This also prevents cycles between embedded objects. Only treestructures are possible.  Queries across all embedded objects are not possible. A query must always be from the perspective of the parent object or the RealmList in the parent object.  The above restrictions also mean it effectively isn't possible to move objects once assigned a parent.  API TODO  Add annotation processor support  test    Add tests for support schema graph types: Simple, Tree, Circular   Restrict queries on embedded classes  tests.    Extend RealmObjectSchema  tests    How should migrations for embedded classes be handled? Not relevant for synchronized Realms I guess, but could be relevant for nonsynced Realms.    Tests for insert and insertOrUpdate    Tests for copyToRealm and copyToRealmOrUpdate    Tests for createObject should fail for embedded classes    Implementation  for createObjectclass, parent  tests    Runtime tests for the possible @LinkingObject configs. Especially in Kotlin.
		</Description>
                        
                <CreatedDate>29/01/2020</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>PipelineInActiveProgress</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6760</PullRequestID>
                        
                <IssueID>6721</IssueID>
                        
                <Title>Add support for Decimal128 and ObjectId</Title>
                        
                <Description>Closes This PR adds support for datatype specific to MongoDB, specifically ObjectId and Decimal   TODO    Measure the impact of adding a dependency on the BSON library. We probably want to make it optional for nonsync no matter what, but we should also check the impact on the sync variant    Core ObjectId release to depend on   Annotation processor    Allow Decimal as a type in ClassMetaData. Indexable: No, Primary key: No    Allow ObjectId as a type in ClassMetaData. Indexable: Yes. Primary Key: Yes    Add support for new types when importing from JSON. Unclear how decimal objectId is represented    Verify howworks with ObjectId and Decimal  Querypredicates    Aggregates are not support for Decimal128 limitation of Core  List    Support primitive lists of Decimal128 and ObjectId   Decimal128    equalTo    notEqualTo    lessThan    lessThanOrEqual     greater     greaterThan  ObjectId    equalTo    notEqualTo    lessThan    lessThanOrEqual     greater     greaterThan</Description>
                	
                <code>RealmResults.toJson()</code>
                        
                <CreatedDate>14/01/2020</CreatedDate>
                        
                <ClosedDate>14/01/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6760</PullRequestID>
                        
                <IssueID>6757</IssueID>
                        
                <Title>Add support for RealmApp (and MongoDB Realm)</Title>
                        
                <Description>This PR lays the groundwork for the new RealmApp API interacting with MongoDB Realm. The idea is that local Realms should not be impacted by this change. The way synced Realms are opened should be minimally impacted:  Biggest changes  Most of the APIs found on SyncUser moves to RealmApp.  SyncManager is gone. Any relevant functionality has moved to RealmApp.  RealmCredentials replaces SyncCredentials.  RealmUser replaces SyncUser and becomes a more shallow class mostly exposing profile info.  RealmApp is now configured upfront using RealmAppConfiguration instead of using setters that could only be called until the first Realm was opened.  Most of the network logic for defining requests, parsing results, retrying, are now in Object Store. The Java layer is only responsible for executing the request. This is referred to as the Network Transport.  The UserStore interface has been removed. Users are now stored using the RealmApp. An encryption key can be configured in the config object if desired this has not been implemented yet.  Note for Reviewers  There are a lot of FIXME's and code that has been disabled in this commit. All of these will be fixed in other PR's. Sorry for the mess  The only thing considered "done done" in this PR is the network transport on both the Java and C side their associated tests.  Other important bits are the JenkinsFile and integration test setup.  Naming of public classes are NOT finalized with this PR. This is just the first guess.  This PR contains a TODO List with all remaining tasks:  TODO  Finalize naming of public API classes.   Implement and test Network Transport.   Implement skeleton login   Remove the UserStore abstraction. Depend on OS for storing users (punt encryption support to another   RealmUser initial support   RealmCredentials limited   RealmApp initial support   Disable all current integration tests unit tests of replaced classes   Make it posssible and easy to run integration tests on both CI and locally.</Description>
                        
                <CreatedDate>26/02/2020</CreatedDate>
                        
                <ClosedDate>19/03/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6697</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Removeallcurrentlydeprecatedmethods</Title>
            
        <Description>Closes 
</Description>
            
        <CreatedDate>18/12/2019</CreatedDate>
            
        <ClosedDate>13/01/2020</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6692</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Better support for Gradle offline mode</Title>
            
        <Description>Closes This PR disables anonymous analytics when Gradle is invoked with the offline parameter. This will speed the build up by 6 seconds, since we are currently waiting for the network layer to throw a timeout exception timeouts configured by us in Realm Analytics java. Tested manually.
</Description>
            
        <CreatedDate>16/12/2019</CreatedDate>
            
        <ClosedDate>16/12/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6692</PullRequestID>
                        
                <IssueID>6691</IssueID>
                        
                <Title>slower build in intranet</Title>
                        
                <Description> Describe your problem or use casetask app:transformClassesWithRealmTransformerForDebug will add 6 sec build time in intranet environmentby analytic the network traffic found out it wait for dns query api.mixpanel.com until timeout. (due to unable connect on internet) Describe the solution you'd likeafter add api.mixpanel.com to hosts the execute time of task app:transformClassesWithRealmTransformerForDebug will less than 1000ms.solution:how to disable realm analytics in my project?or not try to access internet while gradle offline flag is on. Additional contextI already set offline flag on in gradlerealmjava:6.0.0 and 6.0.2</Description>
                        
                <CreatedDate>16/12/2019</CreatedDate>
                        
                <ClosedDate>16/12/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6680</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix transform crashing when you delete transformed objects</Title>
            
        <Description>Closes Also add support for creating OsResults directly from a table, which is much faster than running a query for all objects in a table.</Description>
            
        <CreatedDate>06/12/2019</CreatedDate>
            
        <ClosedDate>16/12/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6680</PullRequestID>
                        
                <IssueID>6657</IssueID>
                        
                <Title>Index out of bounds in migration transformation</Title>
                        
                <Code>
        </Code>
                		
                <Stacktrace>
		 at io.realm.internal.CheckedRow.nativeSetString(CheckedRow.java)
       at io.realm.internal.UncheckedRow.setString(UncheckedRow.java:234)
       at io.realm.DynamicRealmObject.setString(DynamicRealmObject.java:689)
       at de.loewen.lcsmobile.migration.MigrateToVersion23Kt$migrateToVersion23$1$1.apply(MigrateToVersion23Kt.java:36)
       at io.realm.MutableRealmObjectSchema.transform(MutableRealmObjectSchema.java:288)
       at de.loewen.lcsmobile.migration.MigrateToVersion23Kt.migrateToVersion23(MigrateToVersion23Kt.java:26)
       at de.loewen.lcsmobile.migration.RealmMigrationManager.migrate(RealmMigrationManager.java:50)
      Fatal Exception: java.lang.ArrayIndexOutOfBoundsException: rowIndex &gt; available rows: 54 &gt; 53
       at io.realm.internal.Table.nativeMoveLastOver(Table.java)
       at io.realm.internal.Table.moveLastOver(Table.java:330)
       at io.realm.RealmObject.deleteFromRealm(RealmObject.java:115)
       at io.realm.RealmObject.deleteFromRealm(RealmObject.java:87)
       at de.loewen.lcsmobile.migration.MigrateToVersion23Kt$migrateToVersion23$1$1.apply(MigrateToVersion23Kt.java:46)
       at io.realm.MutableRealmObjectSchema.transform(MutableRealmObjectSchema.java:288)
       at de.loewen.lcsmobile.migration.MigrateToVersion23Kt.migrateToVersion23(MigrateToVersion23Kt.java:26)
       at de.loewen.lcsmobile.migration.RealmMigrationManager.migrate(RealmMigrationManager.java:50)
		</Stacktrace>
                        
                <Description> GoalRun transformation in a migration for all elements. If a linking object 		Bar is found I want to set a the string from Bar.bbb on the Dynamic Realm Object Foo aaa 		and if not, I want to remove the Fooobject. Steps 		Code to ReproduceThis seems to happen everytime 		the user opens the app and a migration is needed. 		As said, I cannot reproduce it myself because its working 		on my devices. Version of Realm and toolingRealm versions Realm Sync feature enabled NoAndroid Studio version Beta 3Android Build Tools version Gradle version Which Android version and devices Galaxy S7 crashes on the user Ive tested an S with as well which worked. Also tested Android  all working.</Description>
                         
                <CreatedDate>11/11/2019</CreatedDate>
                        
                <ClosedDate>03/03/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>PipelineTriage</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6617</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Make set List Java doc more accurate.</Title>
            
        <Description>Closes 6616 </Description>
            
        <CreatedDate>12/09/2019</CreatedDate>
            
        <ClosedDate>13/09/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TDoc</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6617</PullRequestID>
                        
                <IssueID>6616</IssueID>
                        
                <Title>Dynamic Realm Object set List documentation is misleading</Title>
                        
                <Description> Goal Setting a listfield of a Dynamic Realm Object by reference and adding values to that list afterwards should result in the Dynamic Realm Object list to contain the added value. Actual Results The list is not set by reference, although the documention implies so. It only copies the values of the list. Steps Code to Reproduce The handle is created in the DB, the token is also created in the DB, but the token is not included in the handle's tokenlist. According to the documention, I would expect that it is included. Version of Realm and tooling Realm versions
        </Description>
                        
                <CreatedDate>11/09/2019</CreatedDate>
                        
                <ClosedDate>13/09/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6602</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>MGaetan89</FixedByID>
            
        <Title>Fix6597DontenforcejCenterrepositoryfollowup6598</Title>
            
        <Description>Follow up PR for 6598 to address @lacasseio comments</Description>
            
        <CreatedDate>30/08/2019</CreatedDate>
            
        <ClosedDate>02/09/2019</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6602</PullRequestID>
                        
                <IssueID>6598</IssueID>
                        
                <Title>Fix 6597  Don't enforce jCenter repository</Title>
                        
                <CreatedDate>28/08/2019</CreatedDate>
                        
                <ClosedDate>28/08/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6596</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for Client Resync</Title>
            
        <Description>Closes The Recover mode has been tested with a sample app running against a local Realm, where I replaced a live Realm with an older version. All local changes from the device were copied correctly. We currently don't have any testing infrastructure in place to do more and it didn't seem worthwhile to build it since OS should already have tests for this. TODO Changelog At least one test making sure that Client Resync works</Description>
            
        <CreatedDate>27/08/2019</CreatedDate>
            
        <ClosedDate>29/08/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6596</PullRequestID>
                        
                <IssueID>6487</IssueID>
                        
                <Title>Add support for Full Sync Client Resync</Title>
                        
                <CreatedDate>09/04/2019</CreatedDate>
                        
                <ClosedDate>29/08/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6590</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for frozen objects</Title>
            
        <Description> Closes  most of it. There is still an open question about schedulers Blocked by This PR adds support for frozen Realm objects. The major benefit of frozen objects is that they are not thread confined and can thus be accessed on any thread. This is especially important for most kinds of streambased architectures (which is most of them at this point). The tradeoff is that the objects are then immutable which is actually considered a positive for most reactive architectures on Android High level API  Semantics Freezing an object will freeze the entire object graph at that version, effectively turning it readonly. Doing this will also lift the threadconfined restriction on it. These are still to be decided, but so far I'm envisioning the following Starting a write transaction on a frozen Realm will throw an exception Trying to add a change listener will throw an exception. Trying to refresh a Realm in any way will throw an exception Trying to write to a frozen object inside the live Realms write transaction will throw. Doing liveRealm copy To Realm Or Update frozen Object should work the same way as using unmanaged objects. Open design questions What are the semantics of Realm get Local Instance Count config for frozen Realms For now global Count Local Thread Count for frozen Realms since these Realms are not thread constrained. What are the semantics if the live Realm spawning frozen Realms is closed There are conflicting interests in terms of making it easy to reason about a Realm files life cycle vs. the Java objects. Ie it becomes difficult to close a Realm file if frozen objects cannot easily close their Realm. I can think of two solutions When all live Realms across all thread are closed, this will also automatically close all frozen Realms or Introduce something like Realm close Frozen Realms config  which will do it manually It is unclear what is better. For now frozen Realms will all be closed when the live Realm spawning them are. This is primarely driven by making RxJava support easier. Freeze existing object or return frozen copy Should freezing objects return a frozen copy or freeze the object in place There are performance benefits to freezing current object, but it seems to conflict with e.g. RxJava support and people need access to the live object in order to get notifications. Kotlin Multiplatform freeze in place. For now we return frozen copies. I suggest we leave it up to user feedback to see if we should change it. We can consider having an internal method that freezes inplace if it will improve performance a lot. Equality and hashcode How should object equality work for frozen objects? Current RealmLists and RealmLists compare objects on pr. object basis. How should frozen Realms and objects be compared? For now Frozen objects with the same values are not considered equal to a live object. Same for Realms. Frozen objects at different versions (but equal values) are also not considered equal. Use cases are unclear The suggestion is to leave it up to user feedback to see if we should change it. Generic parameter on RealmModel So it becomes Realm Model My Implementation  e.g public class Dog extends Realm Object Dog . This enables better return types on freeze as well as the current asFlowable which is kinda annoying to use. Setting the parameter is optional in Java non breaking but seems to be required in Kotlin if present. Unclear if we want to break everyone using Kotlin for this, but it will remove a lot of annoying casts. I will defer changing this to a later PR so we can discuss further (and to prevent cluttering this PR too much). Benchmark results on Emulator Results where frozen with objects. It looks like freezing TableViews are fast enough that we don't need to be too concerned about performance. For a more scalable solution we should look into freezing TableViews off the UI thread (but doing it on the notifier thread also seems like a bad idea). benchmark EMULATOR UNLOCKED Frozen Objects Benchmarks freeze Results benchmark EMULATOR UNLOCKED Frozen Objects Benchmarks freeze List benchmark EMULATOR UNLOCKED Frozen Objects Benchmarks freezeObjectbenchmark EMULATOR UNLOCKED Frozen Objects Benchmarks freeze Realm TODO Changelog Cleanup Finalize and merge it to master Implement Realm Object freeze and Realm Object isFrozen It should be possible to freeze deleted objects which might seem a bit weird, but is needed for us to support event streams that want to notify about deleted objects. Fully closing the live Realm should also close all frozen instances Add benchmarks for freezing Realm Add benchmarks for freezing large RealmResults Add benchmark for freezing large Realm List Add benchmark for freezing Realm Object Change RxObservableFactory so it returns frozen objects. Add option to RealmConfiguration to throw at certain number of active versions. Should be checked when we start a write transaction.   All mutator methods should throw on frozen Realms   Tests  Starting write transactions fail   Tests  Adding Realm listeners fail   Tests  Adding Results listeners fail   Tests  Adding List listeners fail   Tests  Adding Object listeners fail   Tests  refreshing fail   Tests  Equality of frozen Realms   Tests  Equality of frozen RealmObject   Tests  copy Or Update frozen Realm data   Tests  insert Or Update frozen Realm data   Other tests
 </Description>
         
        <Code>
  
 Realm realm = Realm.getInstance(config);
Realm frozenRealm = realm.freeze();
RealmResults&lt;Person&gt; persons = realm.where(Person.class).findAll().freeze();
Person p = realm.where(Person.class).findFirst().freeze();
RealmList&lt;Child&gt; children = realm.where(Person.class).findFirst().getChildren().freeze();

Realm realm = Realm.getInstance(config);
realm.where(Person.class).findAllAsync().asObservable()
  .map((result, changeSet) &gt; {
    result.isFrozen() == true;    
  })
Realm realm = Realm.getInstance(config);
Realm frozenRealm = realm.freeze();
frozenRealm.where(Person.class).findAll().isFrozen() == true;

RealmConfiguration config = new RealmConfiguration.Builder()
  .maxNumberOfActiveVersions(20);
  .build();
Realm.getLocalInstanceCount(config):
</Code>
        	
        <CreatedDate>23/08/2019</CreatedDate>
            
        <ClosedDate>29/11/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>Breaking</PullRequestLabel>
                  
            <PullRequestLabel>PipelineReview</PullRequestLabel>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6590</PullRequestID>
                        
                <IssueID>4291</IssueID>
                        
                <Title>Better RxJava support</Title>
                        
                <Code>		
        public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            return query.findAll().asObservable();
        }

		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Copy into memory before sending data further down the stream
            // Possible this could be done one internally in the asObservable() method
            // TODO solve thread confinement for realm.
            return query.findAll().asObservable()
                .map(result &gt; realm.copyFromRealm(result));        
        }
        public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Pin the version before sending sending data further down the stream
            // Possible this could be one internally in the asObservable() method
            // TODO solve thread confinement for query.
            return query.findAll().asObservable().map(result &gt; result.freeze());        
        }
		
        public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Convert to AutoValue object before sending sending data further down the stream
            return query.findAll().asObservable()
                .map(result &gt; 
                    List l = new ArrayList();
                    for (Person p : result) {
                      l.add(AutoValuePerson.from(p));
                    } 
                    return l;
                );        
        }
		
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            return query.findAll().asObservable();
        }
		
		public Observable&lt;ThreadSafeReference&lt;RealmResults&lt;Person&gt;&gt;&gt; call(ThreadSafeReference&lt;RealmQuery&lt;Person&gt;&gt; query) {
            // .get() resolves the reference.
            return query.get().findAll().asObservable();
        }
		
		public Observable&lt;ThreadSafeReference&lt;RealmResults&lt;Person&gt;&gt;&gt; call(ThreadSafeReference&lt;RealmQuery&lt;Person&gt;&gt; query) {
            return query.get().findAll().asObservable();
        }
		
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // query.isPinned() == true;
            return query.findAll().asObservable().map(results &gt; results.pin());
        }
       </Code>
                        
                <Description> An implementation was started, but never completed here This implementation has a lot of benefts The flatmap function could also do a copy From Realm for those who wants that. And it would happen on a background thread.
 The flatmap operation decide if find All find All Sorted is used. The alternative would be to duplicate all find methods as find Observable which feels like overkill especially considering RxJava2 which have more stream types.  Full interop with all RxJava Schedulers also test schedulers.find All Async and friends would still be available to those not caring about schedulers or uses RxJava. Challenges  Annoying to force flatmap onto everyone. Perhaps we could convert realmResults.asObservable() to an observable on the query behind the scenes. Every RealmResults tracks it's original query anyway, at least on a native level. This could be a v2 of his API. The downside is that it would waste work with findAll().asObservable() as the observable would discard the original query result and rerun the query in the observable.  We need to solve the thread confinement issue (See below) in order to make it easy to move the query object across threads.  Event streams vs live objects RxJava exposes data as streams. This naturally promotes immutable objects as any change should be represented by another event being pushed down the stream. This conflicts with Realms "live" nature where objects are being updated behind the scenes. Specifically, it causes problems with RxJava operators like buffer or any operator that caches items, as the object in the cache might be updated when the developer doesn't expect it. The obvious solution is of course to provide the capability of creating snapshots or pinned versions of Realm objects. This is not trivial, so I'll try to sketch a few solutions Use copy From Realm This will obviously work since it caches the data in memory, but detaching objects from Realm comes with a real cost in terms of memory and performance. Copying an entire object graph can be potentially very expensive and you might end copying a lot of data not really needed. People going down this route should probably consider mapping Realm objects to View models instead. Since View models only contain the data actually required by the UI, nothing will thus be lost by fetching that data ahead of time. This approach has problems for very large query results where it will not be possible to copy them into memory Frozen pinned objects Frozen objects as a concept has been discussed here The basic idea is that it should be possible to freeze or "pin" a Realm Results or Realm Object to a specific version of Realm. With the snapshot concept implemented in Core ObjectStore the native memory concern described in is now solved. The problem with pinning versions is that it can lead to file size explosions since Realm must track the difference between the oldest and newest version of the Realm. So if a version is pinned for a long time it could lead to file size issues. Core is thinking about improving this situation and Java could implement automatic compaction when opening the Realm file but neither would solve the underlying problem completely. Important We miss realworld information about how the filesize will be impacted in RxJava heavy apps if we introduce versioning pinning. This would need further investigation. Thread Safe Reference as implemented by Cocoa  and tracked for Java here will also pin versions, so the concept might be used as a substitute for the API proposed in. Compared to copy From Realm pinning exchanges memory pressure for disk pressure. Challenges With the current proposed API. You cannot tell the difference between frozen/nonfrozen objects unless you call isFrozen()/isPinned(). This is, however, the same for managed/unmanaged objects.  We would also have to introduce pinning for RealmQuery and Realm classes. Autovalue People into RxJava frequently ask for Autovalue support, since it gives immutable objects with no setters (unlike standard Realm model classes) and final fields. Native support for AutoValue would be extremely hard and would under the hood either be implemented as 1) or 2) anyway. Also, updates to an object would be equivalent to a copyToRealm which would be extremely wasteful. See https://github.com/realm/realmjava/issues/2538. For now, the advice would be that if you really want AutoValue support you should make a new class with conversion functions between Realm and the AutoValue object. Effectively splitting your domain into "Entity classes" and "View model classes" as promoted by the Clean Architecture proponents. Thread Confinement Realm's thread confinement and RxJava's streams both attempt to solve the problem of "Concurrent access is really, really hard". Unfortunately, the two approaches are not really compatible. The primary motivating case is: Here we want to do the work on the io() thread and get the results on the UI thread, but this will throw the dreaded llegalStateException: Realm access from incorrect thread. exception. Before discussing solutions I would like to iterate how Realm and RxJava respectively solve the concurrent modifications problems: Realm Each thread operates on its own version of Realm data (MVCC). This gives each thread a fully consistent view of the entire object graph. If we allowed different versions of data to be read on the same thread, it would increase the chance of accidentally trying to operate or compare two objects of different versions which can easily lead to subtle bugs. Each thread advances to the next version at welldefined times (Looper event, transactions) and change listeners are used to notify the user about these events. By definition, threadconfined object cannot be accessed by multiple threads. RxJava All data is exposed as a stream of events. Single objects are not modified, but transformed. This means that any change to data will be modeled as a new event being put into the stream. RxJava does not prevent you from accidentally composing streams that operate on different versions of some data. Because changes should be represented as transformations that result in new objects (events), this naturally promotes immutable objects. Data should only be manipulated inside the stream, never from the outside. By definition, transforming immutable objects inside a stream, cannot cause concurrent modifications. Takeaway One observation from this is that allowing mutable Realm data to be read from any thread is a very huge antipattern. It will conform to neither the original Realm design nor the stream approach. This leads to the conclusion that any solution to thread confinement must operate on a pinned version of the Realm data. Some of the solutions that exist for this Use copy From Realm Copying the data from Realm will prevent them from being updated by Realm. Immutability is not guaranteed since the Realm Model class most likely will have mutator methods. If that is a concern then people should map the classes to a ViewModel class that is immutable.   does not solve the problem on how to move e.g queries and Realm instances across threads as described for custom schedulers. exchanges memory for disk space.  We already have it today, so it is a pragmatic solution. Thread Safe Reference Thread Safe Reference as designed in Cocoa only works once, but we could change semantics so it could be used multiple times. The idea is that all observables are changed, so instead of returning live objects, they returned pinned objects wrapped in a ThreadSafeReference&lt;?&gt;.  Would solve the problem and would expose "pinned" objects in the type system.  Calling everywhere would be a bit annoying.  The downside is that it would force everyone into the ThreadSafeReference class even if not needed.  Lifecycle management of pinned Realms would depend on the GC. It is unclear how many issues this would cause. From Java perspective a Realm is just a long pointer, but it might hold 10's of MB's of native memory. As discussed here The downside is it was originally meant for Realm Object Realm Results Realm List classes. It is not clear how well it would work for e.g Realm Realm Query classes. Effectively it would take the ThreadSafeReference concept and implement it behind the scenes 		Right now the interop between RxJava and Realm is not as good as it could be, which is also the feedback we are constantly getting.This issue is mostly an attempt at summarizing the situation and making sure we have the information in one place instead of being spread out across multiple issues that do not address the full picture. The Current SituationCurrently, we have 3 major issues preventing great compatibility with RxJava:1. No support for [Schedulers](2. Streams work on immutable objects. Realm uses [live objects](3. Thread confinement makes it hard to move work across threads.I'll try to describe each case below and possible solutions.  Challenges 1. Custom SchedulersRealm's async query methods do not allow the use of custom schedulers.Take this example.The internal code changes required to support frozen objects will probably be quite large and could have a quite big impact on performance as all accessors most likely will require additional logic.   4. Other solutionsNo other solution has been thoroughly thought through yet, so a number of solutions could be found here: Implement PinnedRealmResults, PinnedRealmList, PinnedRealm, etc. versions. Could result in quite a lot of new classes Others? Conclussion / TLDR We need to implement RealmQuery.asObservable(). Solving how to move queries across threads will have a lot of influence on how pinning/thread confinement should be solved as well. We need to investigate how pinning versions in RxJava heavy apps effect the file size. This should drive the decision for choosing pinning or copyFromRealm as the default solution. Most likely we will have to offer both in any case. Having the RxObservableFactory interface is nice here as we can easily provide multiple solutions that people can swap easily. copyFromRealm() might not be the "pure" solution, but it is pragmatic. ThreadSafeReference as implemented by Cocoa is not suited for RxJava support. As a minimum we must provide the option of getting the value multiple times on multiple threads.I'll try to keep this post updated with more information and QA.</Description>
                         
                <CreatedDate>06/03/2017</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>PipelineIdeaBacklog</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6590</PullRequestID>
                        
                <IssueID>1208</IssueID>
                        
                <Title>Thread handoff for RealmObject and RealmResults / Frozen state</Title>
                        
                <Description>It should be possible to move objects and query results between threads seamlessly. The underlying concepts introduced in 896 should be useable for this as well.</Description>
                        
                <CreatedDate>11/06/2015</CreatedDate>
                        
                <ClosedDate>03/12/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>PipelineInActiveProgress</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6548</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>AddsupportforAsyncOpen</Title>
            
        <Description>Closes TODO   Update Changelog</Description>
            
        <CreatedDate>27/06/2019</CreatedDate>
            
        <ClosedDate>23/07/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6548</PullRequestID>
                        
                <IssueID>6469</IssueID>
                        
                <Title>Add support for new async open (speed up initial download)</Title>
                        
                <Description>See </Description>
                        
                <CreatedDate>19/03/2019</CreatedDate>
                        
                <ClosedDate>23/07/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6506</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Permission Manager should ignore intermitten terrors</Title>
            
        <Description>Closes Adds functionality for partly working around Before this PR, the PermissionManager held on to any error reported, even intermittent network errors. This caused it to stop working once such an error was encountered. 
With this PR, all errors known to be temporary are just ignored, since the end user cannot do anything besides retrying closing opening the PermissionManager again. Internally we are already retrying sending data which is much more efficient, so no reason to put that burden on the end user.  With this change, only nonrecoverable errors should be reported to end users. 
</Description>
            
        <CreatedDate>03/05/2019</CreatedDate>
            
        <ClosedDate>03/05/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6506</PullRequestID>
                        
                <IssueID>6492</IssueID>
                        
                <Title>PermissionManager.getPermissions() error after connection reset </Title>
                        
                <Description>I am continue with this issue since i dont have solution After connection reset or dropped connection Permission Manager get Permissions return this error REALM SYNC Connection Reading failed Connection reset by peer REALM JAVA Error in permission CONNECTION RESET BY PEER realm basic system Connection reset by peer REALM SYNC Connection Reading failed Connection reset by peer REALM JAVA Error in wild card permissions CONNECTION RESET BY PEER realm basic system Connection reset by peer REALM SYNC Connection Reading failed Connection reset by peer Even if it network error like @cmelchior said i think something wrong here. If you just disable INTERNET manually for a second get Permissions not working anymore even with new PermissionManager instance. as i know permission is a simple fullsync realm, and it should to work like other user Realms and user Realms work fine after connection reset. Goals Call to get the list of permissions for all Realms available to this user Expected results should return Actual results Permission Manager getPermissions triggers on Error with null object but with some addiotinal logs from REALM SYNC Steps to reproduce Call PermissionManager get Permissions then manually disable and enable network then call Permission Manager get Permissions again, only after activity restart(setting configuration and connecting to realm) the PermissionManager.getPermissions() work again. I want to mention that some connection reset happen by itself after about 5 minutes when Permission Manager get Permissions is called, this is happen also in the full sync TODO app example todo app Also does Permission Permission Manager not support offline mode Realm Realm platform cloud  standard plan Android studio Checked API </Description>
                        
                <code>
		PermissionManager.getPermissions()
		RealmResults&lt;Permission&gt;
		</code>
                        
                <CreatedDate>14/04/2019</CreatedDate>
                        
                <ClosedDate>03/05/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6496</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Addsupportforincrementalannotationprocessors</Title>
            
        <Description>Closes I don't think there is any way to add automated tests for this so I did smoke tests doing the following:   Adding Removing simple String fields   Adding Removing Object reference fields   Adding Removing model classes   Modifying nonRealm files.   Check log output. Especially looking for something like Gradle may disable incremental compilation as the following annotation processors are not incremental real mannotation sprocessor   io realm real mannotations processor
</Description>
            
        <CreatedDate>19/04/2019</CreatedDate>
            
        <ClosedDate>24/04/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6496</PullRequestID>
                        
                <IssueID>5906</IssueID>
                        
                <Title>Add support for incremental annotation with Gradle</Title>
                        
                <Description>As Gradle is out, there had to be one issue for this The documentation to handle this is here I think Realmjava could implement this but I might be wrong as I don't fully understand all the works behind annotation processors.
</Description>
                        
                <CreatedDate>18/04/2018</CreatedDate>
                        
                <ClosedDate>24/04/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6470</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Betternullabilitydocs</Title>
            
        <Description>Closes 6358</Description>
            
        <CreatedDate>19/03/2019</CreatedDate>
            
        <ClosedDate>20/03/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TDoc</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6470</PullRequestID>
                        
                <IssueID>6358</IssueID>
                        
                <Title>RealmList of primitive must be marked with @Required in order to work with Swift</Title>
                        
                <Description> Goal I have a RealmObject that contains a field which is a list of Strings. I want to be able to export data containing this realm object to populate a realm on iOS. According to Realms Java docs Fields with primitive types and the RealmList type are required implicitly so I shouldn't need the Required annotation. According to Realms Swift docs, lists of any type cannot be optional so must be declared like: So we should be fine right Actual Results The iOS app will crash when attempting to load the realm file exported from Java. Property Realm Object list Of Strings has been made required. This is because it's interpreting the field in the populated realm file as being optional but the one in the Swift realm is nonoptional. This crash can be fixed by annotating the listOfStrings field with the @Required tag in Java. Steps Code to Reproduce Create a simple RealmObject which has only one field, a RealmList of String type.  Run the app and extract the realm file from the device.  Create a Swift class extending from Object in RealmSwift in the iOS app which again only has one field:  Add your realm file to XCode and open it in the app delegate:       Run that app and you will see it will crash with error mentioned before.  Go back to the Java class and add the Required annotation and repeat the other previous steps.  Observe that the iOS app now runs successfully. Either the docs need to be update to mention this caveat when going between Java and Swift or else the Swift interpreter needs to be a bit smarter.  Version of Realm and tooling Realm versions Java Swift Realm Sync feature enabled No Android Studio version Beta 1 Android Build Tools version NA Gradle version NA Which Android version and devices NA
</Description>
                
                <code>
public RealmList&lt;String&gt; listOfStrings;
let value = List&lt;Type&gt;()
let listOfStrings = List&lt;String&gt;()
RealmObject.listOfStrings
</code>
                        
                <CreatedDate>29/11/2018</CreatedDate>
                        
                <ClosedDate>20/03/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6460</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>AddsupportforNDK21</Title>
            
        <Description>This PR bumps the NDK support from to Closes Closes  Closes It has the following impact:  minSdk is bumped from This will impact of current users  MIPS support is dropped. Google already did this, and to our knowledge, no users would be affected.  Dropping MIPS will reduce universal APK size by MB. People using App Split or App Bundle will not be affected.  Native code is now compiled with Clang instead of GCC.  OpenSSL is upgraded from to TODO   Merge NDK 18 support in Object Store and redirect OS submodule.    Our prebuilt  OpenSSL needs to be built without including ARM assembler code. It breaks Android.   OpenSSL was apparently built with minSDK 21. This was mostly done to include 64 bit support which was added in 21. But 32 bit builds should be done using minSdk 16.   Test size differences for both base and objectServer builds.   Performance benchmarks   Fix Core compiler flags   Fix Sync compiler flags   Fix OpenSSL compiler flags See</Description>
            
        <CreatedDate>12/03/2019</CreatedDate>
            
        <ClosedDate>24/02/2020</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>Breaking</PullRequestLabel>
                  
            <PullRequestLabel>Estimate5</PullRequestLabel>
                  
            <PullRequestLabel>PipelineSoonBacklog</PullRequestLabel>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6460</PullRequestID>
                        
                <IssueID>6408</IssueID>
                        
                <Title>Switch to NDK21</Title>
                        
                <CreatedDate>21/01/2019</CreatedDate>
                        
                <ClosedDate>03/03/2020</ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>PipelineSoonBacklog</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6460</PullRequestID>
                        
                <IssueID>3506</IssueID>
                        
                <Title>Upgrade to NDK R Readd armeabi</Title>
                        
                <Description>The latest versions changelog says armeabi is not supported anymore.But im seeing armeabi is still written in How big is the Realm Base library include armeabi armeabiv7a arm64v8a mips 		Probably you will update this part in website too if i use Realm 		in upcoming update of my app means stopping support for  armeabi devices on market </Description>
                        
                <CreatedDate>27/09/2016</CreatedDate>
                        
                <ClosedDate>27/11/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>Blocked</Label>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>PipelineBacklog</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6460</PullRequestID>
                        
                <IssueID>3623</IssueID>
                        
                <Title>Bump minSDK to API 15</Title>
                        
                <Description>We need to bump theminSDK to as the lib is not usable under API create All From Json target an API 11 which is fine to avoid compile install error under lower SDK but the implementation of Dalvik on lower API fails when the dependencies fails during classloading 		even if this deps is not used. This issue is highlighted by Common Ware here</Description>
                        
                <CreatedDate>12/10/2016</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6456</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>BetterSubscriptionlifecyclemanagement</Title>
            
        <Description>Closes This PR adds support for new timestamps which enables better tracking of Subscriptions. It also makes it possible to set a TTL for subscriptions as well as updating the underlying query. New APIs TODO Finalize OS PR and direct to master. Will need a few adjustments when this is happening. Add find All Async API tests Add  APIs tests Extend Subscription tests Document new API on website</Description>
          
        <code>
  RealmQuery.subscribe(String name, long timeToLive, TimeUnit timeUnit);
RealmQuery.subscribeOrUpdate(String name, long timeToLive, TimeUnit timeUnit);
RealmQuery.subscribeOrUpdate(String name);
RealmQuery.subscribe()
RealmQuery.findAllAsync(String name, boolean update);
RealmQuery.findAllAsync(String name, long timeToLive, TimeUnit timeUnit);
RealmQuery.findAllAsync(String name, long timeToLive, TimeUnit timeUnit, boolean update);
  </code>
            
        <CreatedDate>07/03/2019</CreatedDate>
            
        <ClosedDate>21/03/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6456</PullRequestID>
                        
                <IssueID>6453</IssueID>
                        
                <Title>Support updating queries in subscriptions and expose timestamps</Title>
                        
                <Description>Object store PR with functionality We need to expose  Being able to update the query held by a subscription.  Be able to set the TTL when creating the subscription.  New timestamp fields added to the subscription class. Suggested API:
</Description>
                        
                <CreatedDate>05/03/2019</CreatedDate>
                        
                <ClosedDate>21/03/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6456</PullRequestID>
                        
                <IssueID>2722</IssueID>
                        
                <Title>Add checks for overflow/underflow in time conversion</Title>
                        
                <Description>With the expanded resolution of Date fields, we store dates as (seconds, nanoseconds). Converting to a Date might result in an overflow when seconds &gt; INT64_MAX/1000 (and similar for underflow). This is not a problem for Realm files used on Android only, but other bindings might be able to utilize the full range i.e., seconds &gt; INT64_MAX/1000.</Description>
                        
                <CreatedDate>03/05/2016</CreatedDate>
                        
                <ClosedDate>21/03/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6372</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>RemoveJava8bytecode</Title>
            
        <Description>Closes 6300</Description>
            
        <CreatedDate>19/12/2018</CreatedDate>
            
        <ClosedDate>10/01/2019</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6372</PullRequestID>
                        
                <IssueID>6300</IssueID>
                        
                <Title>Error: Invokecustoms are only supported starting with Android O</Title>
                        
                <Description> Goal What do you want to achieve Cannot build realm with  Actual Results Error Invokecustoms are only supported starting with Android Steps Code to Reproduce Version of Realm and tooling Realm versions Realm Sync feature enabled Yes No Android Studio version Android Build Tools version Gradle version Which Android version and devices
</Description>
                        
                <CreatedDate>15/11/2018</CreatedDate>
                        
                <ClosedDate>10/01/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6270</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for setting acustom User Agent</Title>
            
        <Description>Closes This PR adds an optional parameter when calling Realm init. This will set the user part of the User Agent string. Im using  as people are only calling this once and we also initialize the SyncManager as part of calling it. The extra constructor is only visible when using a build supporting the Object Server.
Usage The String constructed by RealmJava will look like this for e.g. OnePlus Example of String for OnePlus RealmJava SNAPSHOT One Plus ONE PLUS Object Server Example
The server will output something like this Server connection example from emulator info sync Sync Connection Session Client info path Android Linux genymotion SMP PREEMPT RealmJava SNAPSHOT Object Server Example
Specifically we are sending Version name for RealmJava. Build DEVICE Build MODEL Build VERSION SDK_INT named SDK is deprecated Build PRODUCT sees to contain the same information as DEVICE MODEL so doesnt look relevant.
Is this sufficient </Description>
        	
        <code>
		Realm.init(context, "MyApp/" + BuildConfig.VERSION_NAME);
	</code>
            
        <CreatedDate>02/11/2018</CreatedDate>
            
        <ClosedDate>03/11/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6270</PullRequestID>
                        
                <IssueID>6267</IssueID>
                        
                <Title>Add support for custom user agent strings</Title>
                        
                <Description>The latest Sync ROS release added support for defining a custom user agent string that is sent when creating a session. This can help debugging and identifying problematic clients.
The user agent string consists of parts A part defined by Sync A part defined by us Realm version Device OS version A part defined by the user We need to implement and expose to end users.
Suggested API is As the Userv Agent can only be defined up to the point we the C SyncManager this will fit both that and the semantics that the user agent cannot be changed once the Client is started.
Internal ref </Description>
                        
                <CreatedDate>01/11/2018</CreatedDate>
                        
                <ClosedDate>09/11/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>P1Required</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6175</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>FixOJOupload</Title>
            
        <Description>Closes Modified build scripts so shared dependencies are only defined once Bumped to the latest versions of publishing plugins to ensure compatibility with Gradle
Tested by uploading locally to OJO</Description>
            
        <CreatedDate>21/09/2018</CreatedDate>
            
        <ClosedDate>21/09/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6175</PullRequestID>
                        
                <IssueID>6174</IssueID>
                        
                <Title>Publishing to OJO is broken</Title>
                        
                <Code>Task ojoAnnotations FAILED FAILURE Build failed with an exception. What went wrong Execution failed for task annotations artifactory Publish org gradle api publish maven internal publisher Maven Project Identity get ArtifactId Ljava lang String;
		</Code>
                        
                <Description/>
                        
                <CreatedDate>20/09/2018</CreatedDate>
                        
                <ClosedDate>21/09/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6156</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>hdodenhof</FixedByID>
            
        <Title>BumpReLinkerto1.3.0</Title>
            
        <Description>ReLinker 1.3.0 adds support for Android App Bundles, resolving 5977.</Description>
            
        <CreatedDate>12/09/2018</CreatedDate>
            
        <ClosedDate>12/09/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6156</PullRequestID>
                        
                <IssueID>5977</IssueID>
                        
                <Title>App Bundle MissingLibraryException</Title>
                        
                <Code>
		</Code>
                		
                <StackTrace>
		Fatal Exception: java.lang.RuntimeException: Unable to create application my.app.AppMain: com.b.a.b: lib/armeabi/librealmjni.so
       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4715)
       at android.app.ActivityThread.wrap1(ActivityThread.java)
       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)

	   Caused by com.b.a.b: lib/armeabi/librealmjni.so
       at com.b.a.a.a(ApkLibraryInstaller.java:85)
       at com.b.a.d.a(ReLinkerInstance.java:180)
       at com.b.a.d.a(ReLinkerInstance.java:136)
       at com.b.a.c.a(ReLinker.java:1070)
       at io.realm.internal.m.a(RealmCore.java:60)
       at io.realm.v.a(Realm.java:258)
       at my.app.AppMain.onCreate(AppMain.java:256)
       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1013)
       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4712)
       at android.app.ActivityThread.wrap1(ActivityThread.java)
       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)

		</StackTrace>
                        
                <Description>&lt;!Questions: If you have questions about how to use Realm, ask on[StackOverflow](We monitor the realm tag.Feature Request: Just fill in the first two sections below.Bugs: To help you as fast as possible with an issue please describe your issueand the steps you have taken to reproduce it in as many details as possible.&gt; GoalTo find a solution for ABI related problems Expected ResultsTo run all split versions of app successfully Actual Results Version of Realm and toolingRealm version(s): 5.1.0Android Studio version: 3.2 canary 15Which Android version and device: Nexus 5X tries to load x86, but most reported devices try armeabi[Many different devices are affected]([App is not using other so files than Realm.](From the Google Play dashboard I can see that no armeabi version is generated, only the 5 that Realm uses. Edit: removed the x86 from the stacktrace, that was confusing</Description>
                        
                <CreatedDate>28/05/2018</CreatedDate>
                        
                <ClosedDate>27/11/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>PipelineOnHold</Label>
                              
                    <Label>TDuplicate</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6149</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Addsupportforusingthedefaultparameterwhendefiningcustomnames</Title>
            
        <Description>Fixes 6145 </Description>
            
        <CreatedDate>04/09/2018</CreatedDate>
            
        <ClosedDate>04/09/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6149</PullRequestID>
                        
                <IssueID>6145</IssueID>
                        
                <Title>RealmClass RealmField value name </Title>
                        
                <Description> Goal I would like to be able to write Realm Class name of the class or Realm Field name of field instead of Realm Class name name of the class or Realm Field name name of field which is unnecesarilly verbose I think. Expected Results
The annotations classes should use value() for specifying name of the class field. The same concept use e.g. libraries parsing from JSON e g GSON Serialized Name
Actual Results Annotation classes use method name and therefore it must be specified when using the annotations. Version of Realm and tooling Realm version Realm sync feature enabled no
Android Studio version
</Description>
                        
                <CreatedDate>01/09/2018</CreatedDate>
                        
                <ClosedDate>04/09/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>FirstGoodIssue</Label>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6141</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixvariouslifecycleissueswithtests</Title>
            
        <Description>Fixes Fixes This PR fixes various lifecycle issues with tests introduced with It also includes a workaround so we can correctly store roslogs. However the logs are only pulled once ROS is shut down, so I suspect in some cases we might not get logs. We should continue to investigate ways of seeing the logs in real time.</Description>
            
        <CreatedDate>31/08/2018</CreatedDate>
            
        <ClosedDate>31/08/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TInternal</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6141</PullRequestID>
                        
                <IssueID>6138</IssueID>
                        
                <Title>AuthTests are broken when running all integration tests</Title>
                        
                <Description>Some of the tests in AuthTests are not working correctly but only when running the full integration test suite. Running just the class makes all test parse. This indicates a failure in the setup somewhere.
Due to it is currently hard to debug. The class is currently Ignored. We need to fix them.</Description>
                        
                <CreatedDate>31/08/2018</CreatedDate>
                        
                <ClosedDate>31/08/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6141</PullRequestID>
                        
                <IssueID>6137</IssueID>
                        
                <Title>Logs from integration test server is broken</Title>
                        
                <Description>Logs from ROS is no longer correctly piped back to the parent process, which makes debugging test failures a lot harder. We need to fix that.Current output The logs should have been outputted with the ros prefix.</Description>
                        
                <CreatedDate>31/08/2018</CreatedDate>
                        
                <ClosedDate>31/08/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6141</PullRequestID>
                        
                <IssueID>6131</IssueID>
                        
                <Title>Add support for custom headers for improved proxy support.</Title>
                        
                <Code>
		// SyncManager
		SyncManager.addCustomRequestHeader(String header, String headerValue);
		SyncManager.addCustomRequestHeader(String header, String headerValue, String host);
		SyncManager.addCustomRequestHeaders(Map&lt;String, String&gt; headers);
		SyncManager.addCustomRequestHeaders(Map&lt;String, String&gt; headers, String host);
		SyncManager.setAuthorizationHeaderName(String headerName);
		SyncManager.setAuthorizationHeaderName(String headerName, String host);

		// SyncConfiguration.Builder
		SyncConfiguration.Builder urlPrefix(String urlPrefix);
		</Code>
                        
                <Description>Closes This PR improves proxy support for the Realm Object Server by adding the following APIs Login using POST, from Charles custom headers image TODO Add public APIs Unit tests Integration tests if possible</Description>
                        
                <CreatedDate>28/08/2018</CreatedDate>
                        
                <ClosedDate>31/08/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6126</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>SupportLIMIT</Title>
            
        <Description>Closes This PR adds support for the keyword LIMIT when making queries. Note, that OFFSET is still not supported.  Core has not yet been released, so this cannot be completed until that has happend Refactor descriptors to use Cores Descriptor Ordering Refactor Java SortDescriptor to better named Field Descriptor or similar Field Descriptor was already taken renamed to Query Descriptor.   Update to Sync Core release with support for LIMIT  Extend DescriptorOrdering class with correct API calls for specifying the limit Add public LIMIT API Add query tests Add notification tests Add subscription tests   Update ObjectStore to support notifications</Description>
            
        <CreatedDate>24/08/2018</CreatedDate>
            
        <ClosedDate>24/09/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6126</PullRequestID>
                        
                <IssueID>544</IssueID>
                        
                <Title>LIMIT</Title>
                        
                <Description>It would be very useful to be able to specify the maximum number of objects to return in a query, similar to LIMIT in SQL. Otherwise the RealmResults list must be manually trimmed with subList.</Description>
                        
                <CreatedDate>09/11/2014</CreatedDate>
                        
                <ClosedDate>24/09/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>Blocked</Label>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6088</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixdependenciesbeingchangedtoolate.</Title>
            
        <Description>Closes TODO Figure out how to change dependencies at configuration time Gradle</Description>
            
        <CreatedDate>30/07/2018</CreatedDate>
            
        <ClosedDate>31/07/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6088</PullRequestID>
                        
                <IssueID>6080</IssueID>
                        
                <Title>Build fail with 5.4.0</Title>
                        
                <Description>updated from to then gradle build fails. Clean Project returns the same exception.</Description>
                        
                <CreatedDate>23/07/2018</CreatedDate>
                        
                <ClosedDate>03/08/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6087</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>FixnullpointerwhenusingRealmTransformer</Title>
            
        <Description>Closes Converts the util functions to Kotlin and added extra crash safety when sending analytics basically, we should never crash no matter what goes wrong. Now all exceptions are just silently logged to the debug log.</Description>
            
        <CreatedDate>30/07/2018</CreatedDate>
            
        <ClosedDate>31/07/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TInternal</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6087</PullRequestID>
                        
                <IssueID>6082</IssueID>
                        
                <Title>Gradle build error org gradle api tasks Task Execution Exception Execution failed for task sdk transform Classes With Realm Transformer For Debug</Title>
                        
                <Code/>
                        
                <Description>
Questions If you have questions about how to use Realm ask on Stack Overflow We monitor the realm tag. Feature Request Just fill in the first two sections below. Bugs To help you as fast as possible with an issue please describe your issue and the steps you have taken to reproduce it in as many details as possible. Goal On realmgradleplugin the gradle seems to work fine but as I upgrade to realm gradle plugin, the build creation is failing. Expected Results Actual Results Describe your current debugging efforts.Version of Realm and tooling Realm versions Realm sync feature enabled yes no Android Studio version Which Android version and device  
</Description>
                
                <stacktrace>
&gt;  org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':sdk:transformClassesWithRealmTransformerForDebug'.
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:100)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:70)
        at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:62)
        at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:60)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:97)
        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:87)
        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:248)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:241)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:230)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)
        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:626)
        at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:581)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
Caused by: java.lang.NullPointerException
        at io.realm.transformer.Utils.getTargetSdk(Utils.java:67)
        at io.realm.transformer.RealmTransformer.sendAnalytics(RealmTransformer.kt:154)
        at io.realm.transformer.RealmTransformer.exitTransform(RealmTransformer.kt:116)
        at io.realm.transformer.RealmTransformer.transform(RealmTransformer.kt:111)
        at com.android.build.api.transform.Transform.transform(Transform.java:288)
        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:221)
        at com.android.build.gradle.internal.pipeline.TransformTask$2.call(TransformTask.java:217)
        at com.android.builder.profile.ThreadRecorder.record(ThreadRecorder.java:102)
        at com.android.build.gradle.internal.pipeline.TransformTask.transform(TransformTask.java:212)
        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)
        at org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:46)
        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)
        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:121)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:110)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:92)
   </stacktrace>
                        
                <CreatedDate>25/07/2018</CreatedDate>
                        
                <ClosedDate>03/08/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6062</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixbugwhenusingdistinctandcount</Title>
            
        <Description>Fixes 5958 </Description>
            
        <CreatedDate>16/07/2018</CreatedDate>
            
        <ClosedDate>17/07/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6062</PullRequestID>
                        
                <IssueID>5958</IssueID>
                        
                <Title>realmQuery.distinct().count() might return incorrect value</Title>
                        
                <Description>A mapping of a Stack Overflow question that is most likely a bug. Goal What do you want to achieve? Evaluate number of distinct items without having to use Expected Results should work Actual Results Count returns the size of the full table data set.Steps &amp; Code to ReproduceSee Version of Realm and tooling Realm versions Realm sync feature enabled no</Description>
                        
                <code>
		findAll().size()
		realm.where(Blah.class).distinct("birthday").count()
		</code>
                        
                <CreatedDate>17/05/2018</CreatedDate>
                        
                <ClosedDate>17/07/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6025</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kageiit</FixedByID>
            
        <Title>Remove reliance on groovy in realm transformer</Title>
            
        <Description>Ref 3971</Description>
            
        <CreatedDate>15/06/2018</CreatedDate>
            
        <ClosedDate>23/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6025</PullRequestID>
                        
                <IssueID>3971</IssueID>
                        
                <Title>OkBuck support</Title>
                        
                <Code>
                    .schemaVersion(1)
                    .encryptionKey(realmKeyProvider.getRealmKey())
                    .deleteRealmIfMigrationNeeded()
                    .build();

		</Code>
                		
                <stacktrace>
		E/AndroidRuntime( 3447): FATAL EXCEPTION: main
		E/AndroidRuntime( 3447): Process: mobile.nonaka.com.nonakaapp.ci, PID: 3447
		E/AndroidRuntime( 3447): java.lang.ExceptionInInitializerError: RealmTransformer doesn't seem to be applied. Please update the project configuration to use the Realm Gradle plugin. See https://realm.io/news/androidinstallationchange/
		E/AndroidRuntime( 3447): 	at io.realm.RealmConfiguration.&lt;clinit&gt;(RealmConfiguration.java:77)
		E/AndroidRuntime( 3447): 	at io.realm.RealmConfiguration$Builder.initializeBuilder(RealmConfiguration.java:428)
		E/AndroidRuntime( 3447): 	at io.realm.RealmConfiguration$Builder.&lt;init&gt;(RealmConfiguration.java:391)
		E/AndroidRuntime( 3447): 	at mobile.nonaka.com.nonakaapp.NONAKAApplication.onCreate(NONAKAApplication.java:44)
		E/AndroidRuntime( 3447): 	at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1007)
		E/AndroidRuntime( 3447): 	at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4344)
		E/AndroidRuntime( 3447): 	at android.app.ActivityThread.access$1500(ActivityThread.java:135)
		E/AndroidRuntime( 3447): 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1256)
		E/AndroidRuntime( 3447): 	at android.os.Handler.dispatchMessage(Handler.java:102)
		E/AndroidRuntime( 3447): 	at android.os.Looper.loop(Looper.java:136)
		E/AndroidRuntime( 3447): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
		E/AndroidRuntime( 3447): 	at java.lang.reflect.Method.invokeNative(Native Method)
		E/AndroidRuntime( 3447): 	at java.lang.reflect.Method.invoke(Method.java:515)
		E/AndroidRuntime( 3447): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
		E/AndroidRuntime( 3447): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
		E/AndroidRuntime( 3447): 	at dalvik.system.NativeStart.main(Native Method)
		RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this)
		</stacktrace>
                        
                <Description> Goal Build my app that uses Realm with OkBuck. Expected Results Build and runs normally as if I had built with Gradle. Actual Results The build and APK are successfully generated, but when I run the app an error is raised 		forcing close the app. If I build the same dependencies with Gradle, not using 		OkBuck it runs perfectly. Logcat Version of Realm and toolingRealm version 		Realm sync feature enabled noAndroid Studio version 		Which Android version and device Any devicemin Sdk Version target Sdk Version compile Sdk Version 		build Tools Version OkBuck Gradle Android Gradle Plugin Thanks a lot.</Description>
                        
                <CreatedDate>01/01/2017</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6024</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix Realm delete All and Realm isEmpty</Title>
            
        <Description>Closes This PR fixes and  so they now respect the defined schema. This is important if the schema is only a subset of the actual tables found in the Realm.
This means that delete All will only delete the schema defined and will only return the result based on the defined schema as well. TODO Determine what to do about system classes in synced Realms ResultSets and Class. 
 In the old behaviour they were ignored for Realm isEmpty but cleared when doing This feels inconsistent. I think I lean towards ignoring them in both cases.</Description>
           
        <code>
   Realm.deleteAll()
   Realm.isEmpty()
   </code>
           
   
        <CreatedDate>15/06/2018</CreatedDate>
            
        <ClosedDate>19/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6024</PullRequestID>
                        
                <IssueID>5745</IssueID>
                        
                <Title>Realm delete All is trying to delete Realm Objects across module boundaries</Title>
                        
                <Code>
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		Realm.init(this);

		try (Realm realm = Realm.getDefaultInstance()) {
			realm.executeTransaction(r &gt; r.deleteAll());
		}

		RealmConfiguration libraryConfig = new RealmConfiguration.Builder()
				.deleteRealmIfMigrationNeeded()
				.modules(new LibraryModule())
				.build();

		try (Realm realm = Realm.getInstance(libraryConfig)) {
			realm.executeTransaction(r &gt; r.deleteAll());
		}
	}
	</Code>
                	
                <stacktrace>
	 io.realm.exceptions.RealmException: 'AppModel' doesn't exist in current schema.
			  at io.realm.internal.ColumnIndices.getColumnInfo(ColumnIndices.java:112)
			  at io.realm.RealmSchema.getColumnInfo(RealmSchema.java:250)
			  at io.realm.ImmutableRealmSchema.get(ImmutableRealmSchema.java:41)
			  at io.realm.RealmSchema.getAll(RealmSchema.java:88)
			  at io.realm.BaseRealm.deleteAll(BaseRealm.java:602)
			  at io.realm.Realm.deleteAll(Realm.java:135)
			  at com.johnpetitto.realmbug.MainActivity.lambda$onCreate$1$MainActivity(MainActivity.java:30)
			  at com.johnpetitto.realmbug.MainActivity$$Lambda$1.execute(Unknown Source:0)
			  at io.realm.Realm.executeTransaction(Realm.java:1394)
			  at com.johnpetitto.realmbug.MainActivity.onCreate(MainActivity.java:30)
			  at android.app.Activity.performCreate(Activity.java:6998)
			  at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1230)
			  at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2899)
	</stacktrace>
                        
                <Description>Questions If you have questions about how to use Realm ask on Stack Over flow  We monitor the realm tag. Feature Request 		Just fill in the first two sections below Bugs To help you as fast as possible with an issue please describe your issue and the steps you have taken to reproduce it in as many details as possible 		I have a project with multiple modules using Realm. I was hoping that I could just call delete All on a Realm for one of the modules, but it seems to be trying to delete Realm Objects 		from the other modules leading to a runtime exception. Expected Results Id expect to only delete the RealmObjects within the associated Realm. Actual Results When the code runs, I get the following runtime exception when calling delete All on the library Realm instance Version of Realm and tooling Realm version Realm sync feature enabled 		no Android Studio version Which Android version and device Android 8 on a OnePlus T</Description>
                        
                <CreatedDate>08/02/2018</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
                <AST>on|create
	void,Void0|Mth|Nm1,METHOD_NAME
	void,Void0|Mth|Prm|VDID0,saved|instance|state
	void,Void0|Mth|Prm|Cls1,bundle
	void,Void0|Mth|Bk|Ex|Cal0|SupEx0,super
	void,Void0|Mth|Bk|Ex|Cal0|Nm2,saved|instance|state
	void,Void0|Mth|Bk|Ex|Cal0|Nm3,on|create
	void,Void0|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	void,Void0|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	void,Void0|Mth|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	void,Void0|Mth|Bk|Ex|Cal0|Nm2,set|content|view
	void,Void0|Mth|Bk|Ex|Cal0|Nm0,realm
	void,Void0|Mth|Bk|Ex|Cal0|This2,this
	void,Void0|Mth|Bk|Ex|Cal0|Nm3,init
	void,Void0|Mth|Bk|Try|VDE|Cls0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|VDID0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	void,Void0|Mth|Bk|Ex|VDE|Cls0,realm|configuration
	void,Void0|Mth|Bk|Ex|VDE|VD|VDID0,library|config
	void,Void0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	void,Void0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	void,Void0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	void,Void0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	void,Void0|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,build
	void,Void0|Mth|Bk|Try|VDE|Cls0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|VDID0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	void,Void0|Mth|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	void,Void0|Mth|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	void,Void0|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	METHOD_NAME,Nm1|Mth|Prm|VDID0,saved|instance|state
	METHOD_NAME,Nm1|Mth|Prm|Cls1,bundle
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|SupEx0,super
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Nm2,saved|instance|state
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Nm3,on|create
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Nm2,set|content|view
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|This2,this
	METHOD_NAME,Nm1|Mth|Bk|Ex|Cal0|Nm3,init
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|Cls0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|VDID0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls0,realm|configuration
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,library|config
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,build
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|Cls0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|VDID0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	METHOD_NAME,Nm1|Mth|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	METHOD_NAME,Nm1|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	saved|instance|state,VDID0|Prm|Cls1,bundle
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|SupEx0,super
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Nm2,saved|instance|state
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Nm3,on|create
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Nm2,set|content|view
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|This2,this
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|Cal0|Nm3,init
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|Cls0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|VDID0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|Cls0,realm|configuration
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|VDID0,library|config
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	saved|instance|state,VDID0|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,build
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|Cls0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|VDID0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	saved|instance|state,VDID0|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|SupEx0,super
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Nm2,saved|instance|state
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Nm3,on|create
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Nm2,set|content|view
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Nm0,realm
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|This2,this
	bundle,Cls1|Prm|Mth|Bk|Ex|Cal0|Nm3,init
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|Cls0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|VDID0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|Cls0,realm|configuration
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|VDID0,library|config
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	bundle,Cls1|Prm|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,build
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|Cls0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|VDID0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	bundle,Cls1|Prm|Mth|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	bundle,Cls1|Prm|Mth|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	super,SupEx0|Cal|Nm2,saved|instance|state
	super,SupEx0|Cal|Nm3,on|create
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Nm2,set|content|view
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|This2,this
	super,SupEx0|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	super,SupEx0|Cal|Ex|Bk|Try|VDE|Cls0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	super,SupEx0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	super,SupEx0|Cal|Ex|Bk|Try|VDE|Cls0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	super,SupEx0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	super,SupEx0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	saved|instance|state,Nm2|Cal|Nm3,on|create
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Nm2,set|content|view
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|This2,this
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	saved|instance|state,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	saved|instance|state,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm0,r
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Fld1|Fld0|Nm2,layout
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Fld1|Nm2,activity|main
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Nm2,set|content|view
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|This2,this
	on|create,Nm3|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|Cls0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	on|create,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|Cls0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	on|create,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	on|create,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	r,Nm0|Fld0|Nm2,layout
	r,Nm0|Fld0|Fld1|Nm2,activity|main
	r,Nm0|Fld0|Fld1|Cal|Nm2,set|content|view
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|This2,this
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	r,Nm0|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	layout,Nm2|Fld0|Fld1|Nm2,activity|main
	layout,Nm2|Fld0|Fld1|Cal|Nm2,set|content|view
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|This2,this
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	layout,Nm2|Fld0|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	activity|main,Nm2|Fld1|Cal|Nm2,set|content|view
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|Cal0|This2,this
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|Cls0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	activity|main,Nm2|Fld1|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	set|content|view,Nm2|Cal|Ex|Bk|Ex|Cal0|Nm0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Ex|Cal0|This2,this
	set|content|view,Nm2|Cal|Ex|Bk|Ex|Cal0|Nm3,init
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	set|content|view,Nm2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	set|content|view,Nm2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	set|content|view,Nm2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|This2,this
	realm,Nm0|Cal|Nm3,init
	realm,Nm0|Cal|Ex|Bk|Try|VDE|Cls0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	realm,Nm0|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	realm,Nm0|Cal|Ex|Bk|Try|VDE|Cls0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm,Nm0|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	this,This2|Cal|Nm3,init
	this,This2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	this,This2|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	this,This2|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	this,This2|Cal|Ex|Bk|Try|VDE|Cls0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	this,This2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	this,This2|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	this,This2|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	init,Nm3|Cal|Ex|Bk|Try|VDE|Cls0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,get|default|instance
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	init,Nm3|Cal|Ex|Bk|Ex|VDE|Cls0,realm|configuration
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|VDID0,library|config
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	init,Nm3|Cal|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,build
	init,Nm3|Cal|Ex|Bk|Try|VDE|Cls0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|VDID0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	init,Nm3|Cal|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	init,Nm3|Cal|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Cls0|VDE|VD|VDID0,realm
	realm,Cls0|VDE|VD|Cal1|Nm0,realm
	realm,Cls0|VDE|VD|Cal1|Nm2,get|default|instance
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Cls0|VDE|Try|Bk|Ex|VDE|Cls0,realm|configuration
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|VDID0,library|config
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	realm,Cls0|VDE|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	realm,Cls0|VDE|Try|Bk|Try|VDE|Cls0,realm
	realm,Cls0|VDE|Try|Bk|Try|VDE|VD|VDID0,realm
	realm,Cls0|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,Cls0|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm,Cls0|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm,Cls0|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Cls0|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Cls0|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Cls0|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Cls0|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,VDID0|VD|Cal1|Nm0,realm
	realm,VDID0|VD|Cal1|Nm2,get|default|instance
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|Cls0,realm|configuration
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|VDID0,library|config
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	realm,VDID0|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	realm,VDID0|VD|VDE|Try|Bk|Try|VDE|Cls0,realm
	realm,VDID0|VD|VDE|Try|Bk|Try|VDE|VD|VDID0,realm
	realm,VDID0|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,VDID0|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm,VDID0|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm,VDID0|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,VDID0|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,VDID0|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|Nm2,get|default|instance
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|Cls0,realm|configuration
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|VDID0,library|config
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|VDE|Cls0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|VDE|VD|VDID0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|Cls0,realm|configuration
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|VDID0,library|config
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|VDE|Cls0,realm
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|VDE|VD|VDID0,realm
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	get|default|instance,Nm2|Cal|VD|VDE|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|Gt|Nm0,r
	realm,Nm0|Cal|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|Nm3,execute|transaction
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|Cls0,realm|configuration
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|VDID0,library|config
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|VDE|Cls0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|VDID0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	r,Nm0|Gt2|Cal1|Nm0,r
	r,Nm0|Gt2|Cal1|Nm2,delete|all
	r,Nm0|Gt2|Cal|Nm3,execute|transaction
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|Cls0,realm|configuration
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|VDID0,library|config
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|Cls0,realm
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|VDID0,realm
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	r,Nm0|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	r,Nm0|Cal|Nm2,delete|all
	r,Nm0|Cal|Gt2|Cal|Nm3,execute|transaction
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|Cls0,realm|configuration
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|VDID0,library|config
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|Cls0,realm
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|VDID0,realm
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	r,Nm0|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	delete|all,Nm2|Cal|Gt2|Cal|Nm3,execute|transaction
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|Cls0,realm|configuration
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|VDID0,library|config
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|Cls0,realm
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|VDID0,realm
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	delete|all,Nm2|Cal|Gt2|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|Cls0,realm|configuration
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|VDID0,library|config
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Cal0|Nm3,modules
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Ex|VDE|VD|Cal1|Nm2,build
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|VDE|Cls0,realm
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|VDID0,realm
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm0,realm
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	execute|transaction,Nm3|Cal|Ex|Bk|Try|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm|configuration,Cls0|VDE|VD|VDID0,library|config
	realm|configuration,Cls0|VDE|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	realm|configuration,Cls0|VDE|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	realm|configuration,Cls0|VDE|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	realm|configuration,Cls0|VDE|VD|Cal1|Cal0|Nm3,modules
	realm|configuration,Cls0|VDE|VD|Cal1|Nm2,build
	realm|configuration,Cls0|VDE|Ex|Bk|Try|VDE|Cls0,realm
	realm|configuration,Cls0|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	realm|configuration,Cls0|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm|configuration,Cls0|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm|configuration,Cls0|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm|configuration,Cls0|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm|configuration,Cls0|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm|configuration,Cls0|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm|configuration,Cls0|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm|configuration,Cls0|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	library|config,VDID0|VD|Cal1|Cal0|Cal0|ObjEx|Cls|Cls0,realm|configuration
	library|config,VDID0|VD|Cal1|Cal0|Cal0|Nm2,delete|realm|if|migration|needed
	library|config,VDID0|VD|Cal1|Cal0|ObjEx|Cls0,library|module
	library|config,VDID0|VD|Cal1|Cal0|Nm3,modules
	library|config,VDID0|VD|Cal1|Nm2,build
	library|config,VDID0|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	library|config,VDID0|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	library|config,VDID0|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	library|config,VDID0|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	library|config,VDID0|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	library|config,VDID0|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	library|config,VDID0|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	library|config,VDID0|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	library|config,VDID0|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	library|config,VDID0|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Nm2,delete|realm|if|migration|needed
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|ObjEx|Cls0,library|module
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Nm3,modules
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|Nm2,build
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm|configuration,Cls0|Cls|ObjEx0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|ObjEx|Cls0,library|module
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Nm3,modules
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|Nm2,build
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	delete|realm|if|migration|needed,Nm2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	library|module,Cls0|ObjEx2|Cal0|Nm3,modules
	library|module,Cls0|ObjEx2|Cal0|Cal|Nm2,build
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	library|module,Cls0|ObjEx2|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	modules,Nm3|Cal0|Cal|Nm2,build
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	modules,Nm3|Cal0|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|VDE|Cls0,realm
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|VDID0,realm
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm0,realm
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm2,library|config
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|VDE|VD|Cal1|Nm3,get|instance
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm0,realm
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Nm0,r
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	build,Nm2|Cal|VD|VDE|Ex|Bk|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Cls0|VDE|VD|VDID0,realm
	realm,Cls0|VDE|VD|Cal1|Nm0,realm
	realm,Cls0|VDE|VD|Cal1|Nm2,library|config
	realm,Cls0|VDE|VD|Cal1|Nm3,get|instance
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Cls0|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,VDID0|VD|Cal1|Nm0,realm
	realm,VDID0|VD|Cal1|Nm2,library|config
	realm,VDID0|VD|Cal1|Nm3,get|instance
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,VDID0|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|Nm2,library|config
	realm,Nm0|Cal|Nm3,get|instance
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	library|config,Nm2|Cal|Nm3,get|instance
	library|config,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	library|config,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	library|config,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	library|config,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	library|config,Nm2|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	get|instance,Nm3|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm0,realm
	get|instance,Nm3|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Nm0,r
	get|instance,Nm3|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm0,r
	get|instance,Nm3|Cal|VD|VDE|Try|Bk|Ex|Cal0|Gt|Cal1|Nm2,delete|all
	get|instance,Nm3|Cal|VD|VDE|Try|Bk|Ex|Cal0|Nm3,execute|transaction
	realm,Nm0|Cal|Gt|Nm0,r
	realm,Nm0|Cal|Gt|Cal1|Nm0,r
	realm,Nm0|Cal|Gt|Cal1|Nm2,delete|all
	realm,Nm0|Cal|Nm3,execute|transaction
	r,Nm0|Gt2|Cal1|Nm0,r
	r,Nm0|Gt2|Cal1|Nm2,delete|all
	r,Nm0|Gt2|Cal|Nm3,execute|transaction
	r,Nm0|Cal|Nm2,delete|all
	r,Nm0|Cal|Gt2|Cal|Nm3,execute|transaction
	delete|all,Nm2|Cal|Gt2|Cal|Nm3,execute|transaction</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6022</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixrarenativecrash</Title>
            
        <Description>Closes 5300 </Description>
            
        <CreatedDate>15/06/2018</CreatedDate>
            
        <ClosedDate>15/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6022</PullRequestID>
                        
                <IssueID>5300</IssueID>
                        
                <Title>Native crash on realmandroid</Title>
                        
                <Description>Questions If you have questions about how to use Realm ask on Stack Overflow We monitor the realm tag Feature Request Just fill in the first two sections below. Bugs To help you as fast as possible with an issue please describe your issueand the steps you have taken to reproduce it in as many details as possible. 		Steps Code to Reproduce Logging is disabled on the device I cannot know what operation caused this crash.If I remove db and create new one 		clear user data on my app the crash doesnt happen on new db. Version of Realm and toolingRealm versions Realm sync feature enabled 		yes nonoAndroid Studio version build gradle on project level Which Android version and device Sony Android SDK Crash 
		</Description>
                		
                <CreatedDate>21/09/2017</CreatedDate>
                        
                <ClosedDate>27/11/2019</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>PipelineOnHold</Label>
                              
                    <Label>ReproductionRequired</Label>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6002</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>EnablecompactforsynchronizedRealms</Title>
            
        <Description>Fixes 5937 </Description>
            
        <CreatedDate>07/06/2018</CreatedDate>
            
        <ClosedDate>12/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6002</PullRequestID>
                        
                <IssueID>5937</IssueID>
                        
                <Title>Reenable compact for Synced Realms</Title>
                        
                <Description>Core and Sync now have support for compacting Synced Realms.We need to reenable compactOnLaunch for synced Realms and remove the restriction on. Note that probably needs to be called before the Realm is opened as the background Sync thread might keep the Realm open after it is closed making compaction impossible.</Description>
                        
                <code> Realm.compact()</code>
                		
                <CreatedDate>09/05/2018</CreatedDate>
                        
                <ClosedDate>12/06/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>6000</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add get Realm methods</Title>
            
        <Description>Closes We already had this adds the same methods to Realm List Realm Results Realm Query and Ordered Realm Collection Snapshot.</Description>
        	
        <code>RealmObject.getRealm()</code>
            
        <CreatedDate>07/06/2018</CreatedDate>
            
        <ClosedDate>08/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>6000</PullRequestID>
                        
                <IssueID>5997</IssueID>
                        
                <Title>Feature Request Realm Query get Realm</Title>
                        
                <Description> Goal What do you want to achieve Write an extension function Expected Results This should be possible Actual Results which results in Instead of  Version of Realm and toolingRealm versions
		</Description>
                        
                <code>
		realm.where&lt;Dog&gt;().findAllCopied(realm)
		fun &lt;T: RealmModel&gt; RealmQuery&lt;T&gt;.findAllCopied(realm: Realm, depth: Int = 4) = realm.copyFromRealm(this, depth)
		realm.where&lt;Dog&gt;().findAllCopied()
		</code>
                        
                <CreatedDate>06/06/2018</CreatedDate>
                        
                <ClosedDate>08/06/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5952</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Improvedperformancewhenparsingfielddescriptions</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>15/05/2018</CreatedDate>
            
        <ClosedDate>24/05/2018</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5952</PullRequestID>
                        
                <IssueID>5547</IssueID>
                        
                <Title>Optimization Realm doing regex string split and String allocation on every equal To</Title>
                        
                <Code>
			private List&lt;String&gt; parseFieldDescription(String fieldDescription) {
				if (fieldDescription == null || fieldDescription.equals("")) {
					throw new IllegalArgumentException("Invalid query: field name is empty");
				}
				if (fieldDescription.endsWith(".")) {
					throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
				}
				return Arrays.asList(fieldDescription.split("\\."));
			}
		</Code>
                        
                <Description>For a simple query such as r where My class equal To there is a cost of a regex string split causing a String allocation even if the field in question doesnt contain any separators. As it is there is no apparent issue but imagine if the small query is in a scrolling Recycler View done on every on Bind View pass. Now we have an unnecessary allocation problem in a tight loop. I would suggest avoid any parsing if we know ahead of time this field cannot contain. I believe the transformer can keep a mapped cache of ALL mapped fields that do contain a and any negative match against it will skip this parsing code. Cache the parse Field Description in a map and only dynamically parse on first attempt for this Realm class field. </Description>
                        
                <CreatedDate>18/11/2017</CreatedDate>
                        
                <ClosedDate>24/05/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
                <AST>parse|field|description
	string,Cls0|Cls|Mth|Nm1,METHOD_NAME
	string,Cls0|Cls|Mth|Prm|VDID0,field|description
	string,Cls0|Cls|Mth|Prm|Cls1,string
	string,Cls0|Cls|Mth|Bk|If|Or|Eq|Nm0,field|description
	string,Cls0|Cls|Mth|Bk|If|Or|Eq|Null1,null
	string,Cls0|Cls|Mth|Bk|If|Or|Cal1|Nm0,field|description
	string,Cls0|Cls|Mth|Bk|If|Or|Cal1|StrEx2,BLANK
	string,Cls0|Cls|Mth|Bk|If|Or|Cal1|Nm3,equals
	string,Cls0|Cls|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	string,Cls0|Cls|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	string,Cls0|Cls|Mth|Bk|If|Cal0|Nm0,field|description
	string,Cls0|Cls|Mth|Bk|If|Cal0|StrEx2,.
	string,Cls0|Cls|Mth|Bk|If|Cal0|Nm3,ends|with
	string,Cls0|Cls|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	string,Cls0|Cls|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	string,Cls0|Cls|Mth|Bk|Ret|Cal0|Nm0,arrays
	string,Cls0|Cls|Mth|Bk|Ret|Cal0|Cal2|Nm0,field|description
	string,Cls0|Cls|Mth|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	string,Cls0|Cls|Mth|Bk|Ret|Cal0|Cal2|Nm3,split
	string,Cls0|Cls|Mth|Bk|Ret|Cal0|Nm3,as|list
	METHOD_NAME,Nm1|Mth|Prm|VDID0,field|description
	METHOD_NAME,Nm1|Mth|Prm|Cls1,string
	METHOD_NAME,Nm1|Mth|Bk|If|Or|Eq|Nm0,field|description
	METHOD_NAME,Nm1|Mth|Bk|If|Or|Eq|Null1,null
	METHOD_NAME,Nm1|Mth|Bk|If|Or|Cal1|Nm0,field|description
	METHOD_NAME,Nm1|Mth|Bk|If|Or|Cal1|StrEx2,BLANK
	METHOD_NAME,Nm1|Mth|Bk|If|Or|Cal1|Nm3,equals
	METHOD_NAME,Nm1|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	METHOD_NAME,Nm1|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	METHOD_NAME,Nm1|Mth|Bk|If|Cal0|Nm0,field|description
	METHOD_NAME,Nm1|Mth|Bk|If|Cal0|StrEx2,.
	METHOD_NAME,Nm1|Mth|Bk|If|Cal0|Nm3,ends|with
	METHOD_NAME,Nm1|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	METHOD_NAME,Nm1|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	METHOD_NAME,Nm1|Mth|Bk|Ret|Cal0|Nm0,arrays
	METHOD_NAME,Nm1|Mth|Bk|Ret|Cal0|Cal2|Nm0,field|description
	METHOD_NAME,Nm1|Mth|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	METHOD_NAME,Nm1|Mth|Bk|Ret|Cal0|Cal2|Nm3,split
	METHOD_NAME,Nm1|Mth|Bk|Ret|Cal0|Nm3,as|list
	field|description,VDID0|Prm|Cls1,string
	field|description,VDID0|Prm|Mth|Bk|If|Or|Eq|Nm0,field|description
	field|description,VDID0|Prm|Mth|Bk|If|Or|Eq|Null1,null
	field|description,VDID0|Prm|Mth|Bk|If|Or|Cal1|Nm0,field|description
	field|description,VDID0|Prm|Mth|Bk|If|Or|Cal1|StrEx2,BLANK
	field|description,VDID0|Prm|Mth|Bk|If|Or|Cal1|Nm3,equals
	field|description,VDID0|Prm|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,VDID0|Prm|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	field|description,VDID0|Prm|Mth|Bk|If|Cal0|Nm0,field|description
	field|description,VDID0|Prm|Mth|Bk|If|Cal0|StrEx2,.
	field|description,VDID0|Prm|Mth|Bk|If|Cal0|Nm3,ends|with
	field|description,VDID0|Prm|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,VDID0|Prm|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	field|description,VDID0|Prm|Mth|Bk|Ret|Cal0|Nm0,arrays
	field|description,VDID0|Prm|Mth|Bk|Ret|Cal0|Cal2|Nm0,field|description
	field|description,VDID0|Prm|Mth|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	field|description,VDID0|Prm|Mth|Bk|Ret|Cal0|Cal2|Nm3,split
	field|description,VDID0|Prm|Mth|Bk|Ret|Cal0|Nm3,as|list
	string,Cls1|Prm|Mth|Bk|If|Or|Eq|Nm0,field|description
	string,Cls1|Prm|Mth|Bk|If|Or|Eq|Null1,null
	string,Cls1|Prm|Mth|Bk|If|Or|Cal1|Nm0,field|description
	string,Cls1|Prm|Mth|Bk|If|Or|Cal1|StrEx2,BLANK
	string,Cls1|Prm|Mth|Bk|If|Or|Cal1|Nm3,equals
	string,Cls1|Prm|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	string,Cls1|Prm|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	string,Cls1|Prm|Mth|Bk|If|Cal0|Nm0,field|description
	string,Cls1|Prm|Mth|Bk|If|Cal0|StrEx2,.
	string,Cls1|Prm|Mth|Bk|If|Cal0|Nm3,ends|with
	string,Cls1|Prm|Mth|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	string,Cls1|Prm|Mth|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	string,Cls1|Prm|Mth|Bk|Ret|Cal0|Nm0,arrays
	string,Cls1|Prm|Mth|Bk|Ret|Cal0|Cal2|Nm0,field|description
	string,Cls1|Prm|Mth|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	string,Cls1|Prm|Mth|Bk|Ret|Cal0|Cal2|Nm3,split
	string,Cls1|Prm|Mth|Bk|Ret|Cal0|Nm3,as|list
	field|description,Nm0|Eq|Null1,null
	field|description,Nm0|Eq|Or|Cal1|Nm0,field|description
	field|description,Nm0|Eq|Or|Cal1|StrEx2,BLANK
	field|description,Nm0|Eq|Or|Cal1|Nm3,equals
	field|description,Nm0|Eq|Or|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,Nm0|Eq|Or|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	field|description,Nm0|Eq|Or|If|Bk|If|Cal0|Nm0,field|description
	field|description,Nm0|Eq|Or|If|Bk|If|Cal0|StrEx2,.
	field|description,Nm0|Eq|Or|If|Bk|If|Cal0|Nm3,ends|with
	field|description,Nm0|Eq|Or|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,Nm0|Eq|Or|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	field|description,Nm0|Eq|Or|If|Bk|Ret|Cal0|Nm0,arrays
	field|description,Nm0|Eq|Or|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	field|description,Nm0|Eq|Or|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	field|description,Nm0|Eq|Or|If|Bk|Ret|Cal0|Cal2|Nm3,split
	field|description,Nm0|Eq|Or|If|Bk|Ret|Cal0|Nm3,as|list
	null,Null1|Eq|Or|Cal1|Nm0,field|description
	null,Null1|Eq|Or|Cal1|StrEx2,BLANK
	null,Null1|Eq|Or|Cal1|Nm3,equals
	null,Null1|Eq|Or|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	null,Null1|Eq|Or|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	null,Null1|Eq|Or|If|Bk|If|Cal0|Nm0,field|description
	null,Null1|Eq|Or|If|Bk|If|Cal0|StrEx2,.
	null,Null1|Eq|Or|If|Bk|If|Cal0|Nm3,ends|with
	null,Null1|Eq|Or|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	null,Null1|Eq|Or|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	null,Null1|Eq|Or|If|Bk|Ret|Cal0|Nm0,arrays
	null,Null1|Eq|Or|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	null,Null1|Eq|Or|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	null,Null1|Eq|Or|If|Bk|Ret|Cal0|Cal2|Nm3,split
	null,Null1|Eq|Or|If|Bk|Ret|Cal0|Nm3,as|list
	field|description,Nm0|Cal|StrEx2,BLANK
	field|description,Nm0|Cal|Nm3,equals
	field|description,Nm0|Cal|Or|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,Nm0|Cal|Or|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	field|description,Nm0|Cal|Or|If|Bk|If|Cal0|Nm0,field|description
	field|description,Nm0|Cal|Or|If|Bk|If|Cal0|StrEx2,.
	field|description,Nm0|Cal|Or|If|Bk|If|Cal0|Nm3,ends|with
	field|description,Nm0|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,Nm0|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	field|description,Nm0|Cal|Or|If|Bk|Ret|Cal0|Nm0,arrays
	field|description,Nm0|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	field|description,Nm0|Cal|Or|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	field|description,Nm0|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm3,split
	field|description,Nm0|Cal|Or|If|Bk|Ret|Cal0|Nm3,as|list
	BLANK,StrEx2|Cal|Nm3,equals
	BLANK,StrEx2|Cal|Or|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	BLANK,StrEx2|Cal|Or|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	BLANK,StrEx2|Cal|Or|If|Bk|If|Cal0|Nm0,field|description
	BLANK,StrEx2|Cal|Or|If|Bk|If|Cal0|StrEx2,.
	BLANK,StrEx2|Cal|Or|If|Bk|If|Cal0|Nm3,ends|with
	BLANK,StrEx2|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	BLANK,StrEx2|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	BLANK,StrEx2|Cal|Or|If|Bk|Ret|Cal0|Nm0,arrays
	BLANK,StrEx2|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	BLANK,StrEx2|Cal|Or|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	BLANK,StrEx2|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm3,split
	BLANK,StrEx2|Cal|Or|If|Bk|Ret|Cal0|Nm3,as|list
	equals,Nm3|Cal|Or|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	equals,Nm3|Cal|Or|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|is|empty
	equals,Nm3|Cal|Or|If|Bk|If|Cal0|Nm0,field|description
	equals,Nm3|Cal|Or|If|Bk|If|Cal0|StrEx2,.
	equals,Nm3|Cal|Or|If|Bk|If|Cal0|Nm3,ends|with
	equals,Nm3|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	equals,Nm3|Cal|Or|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	equals,Nm3|Cal|Or|If|Bk|Ret|Cal0|Nm0,arrays
	equals,Nm3|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	equals,Nm3|Cal|Or|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	equals,Nm3|Cal|Or|If|Bk|Ret|Cal0|Cal2|Nm3,split
	equals,Nm3|Cal|Or|If|Bk|Ret|Cal0|Nm3,as|list
	illegal|argument|exception,Cls0|ObjEx|StrEx1,invalid|query|field|name|is|empty
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|If|Cal0|Nm0,field|description
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|If|Cal0|StrEx2,.
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|If|Cal0|Nm3,ends|with
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm0,arrays
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm3,split
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm3,as|list
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|If|Cal0|Nm0,field|description
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|If|Cal0|StrEx2,.
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|If|Cal0|Nm3,ends|with
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm0,arrays
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm3,split
	invalid|query|field|name|is|empty,StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm3,as|list
	field|description,Nm0|Cal|StrEx2,.
	field|description,Nm0|Cal|Nm3,ends|with
	field|description,Nm0|Cal|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	field|description,Nm0|Cal|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	field|description,Nm0|Cal|If|Bk|Ret|Cal0|Nm0,arrays
	field|description,Nm0|Cal|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	field|description,Nm0|Cal|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	field|description,Nm0|Cal|If|Bk|Ret|Cal0|Cal2|Nm3,split
	field|description,Nm0|Cal|If|Bk|Ret|Cal0|Nm3,as|list
	.,StrEx2|Cal|Nm3,ends|with
	.,StrEx2|Cal|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	.,StrEx2|Cal|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	.,StrEx2|Cal|If|Bk|Ret|Cal0|Nm0,arrays
	.,StrEx2|Cal|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	.,StrEx2|Cal|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	.,StrEx2|Cal|If|Bk|Ret|Cal0|Cal2|Nm3,split
	.,StrEx2|Cal|If|Bk|Ret|Cal0|Nm3,as|list
	ends|with,Nm3|Cal|If|Bk|Thro|ObjEx|Cls0,illegal|argument|exception
	ends|with,Nm3|Cal|If|Bk|Thro|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	ends|with,Nm3|Cal|If|Bk|Ret|Cal0|Nm0,arrays
	ends|with,Nm3|Cal|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	ends|with,Nm3|Cal|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	ends|with,Nm3|Cal|If|Bk|Ret|Cal0|Cal2|Nm3,split
	ends|with,Nm3|Cal|If|Bk|Ret|Cal0|Nm3,as|list
	illegal|argument|exception,Cls0|ObjEx|StrEx1,invalid|query|field|name|must|not|end|with|a|period|(.)
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm0,arrays
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm3,split
	illegal|argument|exception,Cls0|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm3,as|list
	invalid|query|field|name|must|not|end|with|a|period|(.),StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm0,arrays
	invalid|query|field|name|must|not|end|with|a|period|(.),StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm0,field|description
	invalid|query|field|name|must|not|end|with|a|period|(.),StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|StrEx2,\\.
	invalid|query|field|name|must|not|end|with|a|period|(.),StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Cal2|Nm3,split
	invalid|query|field|name|must|not|end|with|a|period|(.),StrEx1|ObjEx|Thro|Bk|If|Bk|Ret|Cal0|Nm3,as|list
	arrays,Nm0|Cal|Cal2|Nm0,field|description
	arrays,Nm0|Cal|Cal2|StrEx2,\\.
	arrays,Nm0|Cal|Cal2|Nm3,split
	arrays,Nm0|Cal|Nm3,as|list
	field|description,Nm0|Cal2|StrEx2,\\.
	field|description,Nm0|Cal2|Nm3,split
	field|description,Nm0|Cal2|Cal|Nm3,as|list
	\\.,StrEx2|Cal2|Nm3,split
	\\.,StrEx2|Cal2|Cal|Nm3,as|list
	split,Nm3|Cal2|Cal|Nm3,as|list</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5925</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>EnableincrementalbuildsintheRealmTransformer</Title>
            
        <Description>Closes Closes This PR enables incremental builds in the Realm Transformer massively decreasing the time spend there in some cases. Preliminary testing shows that it works, but some corner cases do exists. We need to flesh those out. Known bugs corner cases Changing a model field to Ignore will not include classes using that field in the incremental build. Depending on the situation  it will either look like the field fails to load the value from Realm or crashes with a missing method exception.  To fix this I suspect that we need to trigger a full transform whenever a Realm model class is changed.  This needs to be investigated further. Alternatively, if the only corner cases we have is this one  we could consider just documenting it in the FAQ, since it probably isnt something people will run into a lot  and triggering a full transform every time a model class is modified is pretty painful.  Adding or removing the transient keyword is the same as adding removing the Ignore keyword.  Adding or removing the static keyword from a field is the same as adding removing the Ignore annotation.  If normal Java coventions are followed this will normally also mean renaming the field from UPPER CASE to camelCase circumventing the problem.  FIXED Default Realm Module Mediator generated by the annotation processor is not stable. It appears to be included in the incremental build even if not touched. Benchmarks Some rudimentary testing on the moduleExample. The test was modifying one field in the a Realm model class TODO More benchmarks on larger projects. More testing Figure out how to handle corner cases document for now while gathering feedback Release a SNAPSHOT variant to get community feedback before merging. Get feedback from real life projects </Description>
            
        <CreatedDate>28/04/2018</CreatedDate>
            
        <ClosedDate>06/06/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5925</PullRequestID>
                        
                <IssueID>3034</IssueID>
                        
                <Title>Accelarate Realm transformer</Title>
                        
                <Description>We got some complains about the speed of transformers and there is always space to improve it like Replace slow groovy with kotlin</Description>
                        
                <CreatedDate>21/06/2016</CreatedDate>
                        
                <ClosedDate>06/06/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5925</PullRequestID>
                        
                <IssueID>3709</IssueID>
                        
                <Title>Realm Transformer crashes if you have a class that ends with Realm Proxy but isnt an actual proxy generated by Realm</Title>
                        
                <Description>The transformer attempts to access superclass but it is not guaranteed to exist if you yourself create a class that ends with the name RealmProxy.</Description>
                        
                <CreatedDate>27/10/2016</CreatedDate>
                        
                <ClosedDate>06/06/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5907</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add support for resetting password and email confirmation.</Title>
            
        <Description>Closes TODO Tests Public Javadoc Run tests Tests are currently disabled and waiting for to complete before we can enable them. They have all been run manually and succesfully against a cloud instance. 
	</Description>
            
        <CreatedDate>19/04/2018</CreatedDate>
            
        <ClosedDate>25/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5907</PullRequestID>
                        
                <IssueID>5821</IssueID>
                        
                <Title>Add wrappers for new password provider methods</Title>
                        
                <Description>We added a few additional methods in ROS that allow people to implement password reset and email confirmation flows. While these are simple HTTP API, itd be nice to create wrappers for them. All of these rely on the idea that the username password provider is actually used as email password which we probably have to highlight in the method docs.The url for all actions is POST The body looks like All return an empty response and will not provide indication if the user doesnt exist but will return errors if some of the parameters are invalid. Request password reset a reset password email is sent to the users email with some opaque token. provider id is required action is reset password No other fields in data Confirm password reset after obtaining the token from the email the user can complete the password reset flow.By default, ROS will send an email that will redirect to  where a generic UI will be shown to complete the password reset. However, it's possible to override this URL and e.g. change it to so that its handled by the app itself. Its the developers responsibility to obtain the token if they want to complete the reset flow within the app. provider_id should not be provided action is complete reset data contains the following additional fields token the token sent to the users email address. new password the new password of the user. Initiate email confirmation for a lot of use cases, people may want to know that the user has confirmed their email before allowing them to take certain actions in the app. An email will be sent to the user's email address with an opaque token. provider id is required action is request email confirmation No other fields in data Confirm email similarly to the password reset flow the user obtains the token from the email somehow any must passit to the server. By default well redirect to a generic page hosted in ROS. provider id should not be provided action is confirm email data contains the following additional fields token the token sent to the users email address. Note After the email is confirmed, the json response after logging in with username password will contain isEmailConfirmed field set to true. We should probably surface that on the User object. Implementation testing notes This depends on  being merged and released. 
         </Description>
                        
                <CreatedDate>09/03/2018</CreatedDate>
                        
                <ClosedDate>25/04/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5902</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Migrationthatchangesprimarykeydeletesrows</Title>
            
        <Description>Closes Root cause When changing nullability status on a field, we actually do it by creating a new column move all data there and then delete the old column. This is a problem in the context of primary keys for the following reason Use case Change primary key int column from nullable to required. create tmp int column All rows will have the value default value which actually violates the pk constraint Start moving values from the old column to the new row by row. This is done using a special set_unique instruction.If was present in the old column we will now do a set unique int col row but since all rows have the value the result is that the rows are collapsed causing data loss. Solution Since changing nullability is only supported for nonsync Realms anyway, there shouldnt be any harm in not using the set unique method  since the pk invariant is already is already guaranteed for the old column. We just need to be 100% that this method is never called when using Sync. </Description>
            
        <CreatedDate>17/04/2018</CreatedDate>
            
        <ClosedDate>25/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5902</PullRequestID>
                        
                <IssueID>5899</IssueID>
                        
                <Title>Primary key migration from optional to required deleting rows</Title>
                        
                <Code/>
                        
                <Description> Questions If you have questions about how to use Realm, ask on Stack Overflow We monitor the realm tag. Feature Request Just fill in the first two sections below. Bugs To help you as fast as possible with an issue please describe your issue and the steps you have taken to reproduce it in as many details as possible. Hi guys i just encountered a weird problem and don't know if is a bug or i just don't know how to migrate things. I found a workaround for that, create new field with required attribute, transform to get the value of the old primary key, remove old primary key and set primary key to the newly created field. Goal Change primary key name and required to true Kotlin non null but not Require Expected Results The primary key with the new name and the field to be required Actual Results Migration removing 4 of 5 rows in the table after seting set Required true I checked the operation before and all the rows have the primary key with a value and are not null Steps Code to Reproduce Didnt check with another project but in my case was Have a realm object schema with nullable primary key. Multiple objects of that type with values in the primary key. Make a migration changing the name and required to true The new table contains only one row and not the before the migration Code Sample Version of Realm and tooling Realm version Realm sync feature enabled yes no Android Studio version Which Android version and device </Description>
                        
                <CreatedDate>13/04/2018</CreatedDate>
                        
                <ClosedDate>25/04/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5898</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>SupportemptyinputtoinandalwaysTrueandalwaysFalse</Title>
            
        <Description>Closes This PR will make our in operator mirror Cocoas equivalent where parsing in no values and treat it as always false. At the same time I added support for two new predicates always True and always False always False is used by in. always True isn't terrible useful outside generic code going down a branch in a or expression, but it also provides symmetri. See the operators wasn't that easy, but in the end, I opted for the naming also used in Guava It seems more descriptive in our query language than both true Expression or true Predicate
	</Description>
            
        <CreatedDate>13/04/2018</CreatedDate>
            
        <ClosedDate>17/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5898</PullRequestID>
                        
                <IssueID>4011</IssueID>
                        
                <Title>Why not return an empty realmResults when using "in" query with empty values instead of throwing an exception?</Title>
                        
                <Description> Goal Obtain a realmResults using the in query operator on where the values list is empty. Currently this throws an exception that has to be handled. Expected Results In set theory the empty set already is comply by the full set or the empty set so instead of throwing an exception return an empty realmresults Actual Results An exception </Description>
                        
                <CreatedDate>10/01/2017</CreatedDate>
                        
                <ClosedDate>17/04/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5895</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Addscripttohelpunrollingcrashreports</Title>
            
        <Description>This script is a helper script when unrolling stacktraces provided by users making the process a lot less manual, as it is especially tedious to find and download the unstripped versions of Realm. Example of usage:
   </Description>
            
        <CreatedDate>12/04/2018</CreatedDate>
            
        <ClosedDate>12/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5895</PullRequestID>
                        
                <IssueID>9</IssueID>
                        
                <Title>Write JavaDocs for the public API classes</Title>
                        
                <Description>Write JavaDocs for the public API classes.</Description>
                        
                <CreatedDate>02/05/2012</CreatedDate>
                        
                <ClosedDate>20/11/2012</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5881</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>Nhfixeslocalrefoverflow</Title>
            
        <Description> Some callbacks from the Sync Client Thread were called multiple times to validate SSL certificate error notification or to retrieve the access token 	which may cause the local JNI table to overflow fixes Update ROS Sync client to the latest</Description>
            
        <CreatedDate>07/04/2018</CreatedDate>
            
        <ClosedDate>08/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5881</PullRequestID>
                        
                <IssueID>5880</IssueID>
                        
                <Title>Sync JNI ERROR reference table overflow </Title>
                        
                <Code>
		</Code>
                        
                <Description>This happened while testing sync with a demo app Chat Permissions</Description>
                        
                <CreatedDate>07/04/2018</CreatedDate>
                        
                <ClosedDate>22/06/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5872</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix Realm List move forun managed lists</Title>
            
        <Description>Fixes Apparently a brain fart was made in the unit test for this resulting in a wrong implementation compared to the managed list. Tests have been modified to make sure they test the same behaviour in both managed and unmanaged mode.</Description>
            
        <CreatedDate>03/04/2018</CreatedDate>
            
        <ClosedDate>04/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5872</PullRequestID>
                        
                <IssueID>5860</IssueID>
                        
                <Title>Realm List move behaves incorrectly if RealmList is unmanaged</Title>
                        
                <Description> Goal I have an unmanaged RealmList with multiple elements. I want to update it via the move int oldPos int newPos method to notify it that an element has changed positions. Scenario Move an item to a higher position Expected Results In both scenarios I expect that A and B have swaped places i.e my list is now B A. Actual Results In scenario the list remains unchanged. Still A B In scenario the items have swaped places as expected. Steps Code to Reproduce See my code samples above. The problem only occurs with unmanaged RealmList. The items reorder correctly when the list is managed. Code Sample See above Version of Realm and tooling Realm versions Realm sync feature enabled no Android Studio version Which Android version and device Android on LG </Description>
                        
                <CreatedDate>26/03/2018</CreatedDate>
                        
                <ClosedDate>04/04/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5871</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Object is Valid now returns the correct value for the null argument</Title>
            
        <Description>Fixes 5865 </Description>
            
        <CreatedDate>03/04/2018</CreatedDate>
            
        <ClosedDate>03/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5858</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>Exposetheperuserprivaterole</Title>
            
        <Description>Sync is adding a private peruser role in realm realmsync. Well need to update our schema to accommodate.</Description>
            
        <CreatedDate>24/03/2018</CreatedDate>
            
        <ClosedDate>04/04/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5858</PullRequestID>
                        
                <IssueID>2068</IssueID>
                        
                <Title>Using Realm io with android custom listview adapter getting duplicates. </Title>
                        
                <Description>I am operating with two RealmObjects.First Is for Tv Channels and second is for actual Channel event.This is my Channels adapter 		I think Im not using correctly Realm io to read data from two objects at once.Can someone show me the right way how to use Realm.io with listview and two Db objects</Description>
                        
                <CreatedDate>12/01/2016</CreatedDate>
                        
                <ClosedDate>18/01/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5848</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Expose bugs with find First</Title>
            
        <Description>Fixes findFirst was broken in a lot of scenarios involving sorting which apparently wasnt tested. The issue was that going directly to the Table API wasn't the right choice when sorting is involved, so in those cases, we need to construct a TableView first. The CI failures are unrelated and will hopefully be fixed in another PR.</Description>
             
        <CreatedDate>19/03/2018</CreatedDate>
            
        <ClosedDate>21/03/2018</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5848</PullRequestID>
                        
                <IssueID>5714</IssueID>
                        
                <Title>find First not working with sort</Title>
                        
                <Description>Using DynamicRealm and have different results. A is correct working B not working </Description>
                         
		
                <code>
		DynamicRealmObject lastTrack = realm.where(Model.TRACK).sort("timeStart", Sort.DESCENDING).findAll().first(null);
		DynamicRealmObject lastTrack = realm.where(Model.TRACK).sort("timeStart", Sort.DESCENDING).findFirst();
		</code>
                        
                <CreatedDate>26/01/2018</CreatedDate>
                        
                <ClosedDate>21/03/2018</ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST>f
	some|unknown|return|type,Cls0|Mth|Nm1,METHOD_NAME
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls0,dynamic|realm|object
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,last|track
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm0,realm
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm0,model
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm2,track
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm3,where
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|StrEx2,time|start
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm0,sort
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm2,descending
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm4,sort
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm2,find|all
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Null2,null
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Nm3,first
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls0,dynamic|realm|object
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,last|track
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	some|unknown|return|type,Cls0|Mth|Bk|Ret|Nm0,no|such|return|value
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls0,dynamic|realm|object
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,last|track
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm0,model
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm2,track
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm3,where
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|StrEx2,time|start
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm0,sort
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm2,descending
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm4,sort
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm2,find|all
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Null2,null
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Nm3,first
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls0,dynamic|realm|object
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,last|track
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	METHOD_NAME,Nm1|Mth|Bk|Ret|Nm0,no|such|return|value
	dynamic|realm|object,Cls0|VDE|VD|VDID0,last|track
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm0,realm
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm0,model
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm2,track
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Cal0|Nm3,where
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|StrEx2,time|start
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm0,sort
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Fld3|Nm2,descending
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Nm4,sort
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Nm2,find|all
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Null2,null
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Nm3,first
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Cal0|Nm0,realm
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm0,model
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Cal0|Fld2|Nm2,track
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Cal0|Nm3,where
	last|track,VDID0|VD|Cal1|Cal0|Cal0|StrEx2,time|start
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Fld3|Nm0,sort
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Fld3|Nm2,descending
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Nm4,sort
	last|track,VDID0|VD|Cal1|Cal0|Nm2,find|all
	last|track,VDID0|VD|Cal1|Null2,null
	last|track,VDID0|VD|Cal1|Nm3,first
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	last|track,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	last|track,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	realm,Nm0|Cal0|Fld2|Nm0,model
	realm,Nm0|Cal0|Fld2|Nm2,track
	realm,Nm0|Cal0|Nm3,where
	realm,Nm0|Cal0|Cal0|StrEx2,time|start
	realm,Nm0|Cal0|Cal0|Fld3|Nm0,sort
	realm,Nm0|Cal0|Cal0|Fld3|Nm2,descending
	realm,Nm0|Cal0|Cal0|Nm4,sort
	realm,Nm0|Cal0|Cal0|Cal0|Nm2,find|all
	realm,Nm0|Cal0|Cal0|Cal0|Cal|Null2,null
	realm,Nm0|Cal0|Cal0|Cal0|Cal|Nm3,first
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	realm,Nm0|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	model,Nm0|Fld2|Nm2,track
	model,Nm0|Fld2|Cal0|Nm3,where
	model,Nm0|Fld2|Cal0|Cal0|StrEx2,time|start
	model,Nm0|Fld2|Cal0|Cal0|Fld3|Nm0,sort
	model,Nm0|Fld2|Cal0|Cal0|Fld3|Nm2,descending
	model,Nm0|Fld2|Cal0|Cal0|Nm4,sort
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Nm2,find|all
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|Null2,null
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|Nm3,first
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	model,Nm0|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	track,Nm2|Fld2|Cal0|Nm3,where
	track,Nm2|Fld2|Cal0|Cal0|StrEx2,time|start
	track,Nm2|Fld2|Cal0|Cal0|Fld3|Nm0,sort
	track,Nm2|Fld2|Cal0|Cal0|Fld3|Nm2,descending
	track,Nm2|Fld2|Cal0|Cal0|Nm4,sort
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Nm2,find|all
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|Null2,null
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|Nm3,first
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	track,Nm2|Fld2|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	where,Nm3|Cal0|Cal0|StrEx2,time|start
	where,Nm3|Cal0|Cal0|Fld3|Nm0,sort
	where,Nm3|Cal0|Cal0|Fld3|Nm2,descending
	where,Nm3|Cal0|Cal0|Nm4,sort
	where,Nm3|Cal0|Cal0|Cal0|Nm2,find|all
	where,Nm3|Cal0|Cal0|Cal0|Cal|Null2,null
	where,Nm3|Cal0|Cal0|Cal0|Cal|Nm3,first
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	where,Nm3|Cal0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	time|start,StrEx2|Cal0|Fld3|Nm0,sort
	time|start,StrEx2|Cal0|Fld3|Nm2,descending
	time|start,StrEx2|Cal0|Nm4,sort
	time|start,StrEx2|Cal0|Cal0|Nm2,find|all
	time|start,StrEx2|Cal0|Cal0|Cal|Null2,null
	time|start,StrEx2|Cal0|Cal0|Cal|Nm3,first
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	time|start,StrEx2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	sort,Nm0|Fld3|Nm2,descending
	sort,Nm0|Fld3|Cal0|Nm4,sort
	sort,Nm0|Fld3|Cal0|Cal0|Nm2,find|all
	sort,Nm0|Fld3|Cal0|Cal0|Cal|Null2,null
	sort,Nm0|Fld3|Cal0|Cal0|Cal|Nm3,first
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	sort,Nm0|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	descending,Nm2|Fld3|Cal0|Nm4,sort
	descending,Nm2|Fld3|Cal0|Cal0|Nm2,find|all
	descending,Nm2|Fld3|Cal0|Cal0|Cal|Null2,null
	descending,Nm2|Fld3|Cal0|Cal0|Cal|Nm3,first
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	descending,Nm2|Fld3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	sort,Nm4|Cal0|Cal0|Nm2,find|all
	sort,Nm4|Cal0|Cal0|Cal|Null2,null
	sort,Nm4|Cal0|Cal0|Cal|Nm3,first
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	sort,Nm4|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	find|all,Nm2|Cal0|Cal|Null2,null
	find|all,Nm2|Cal0|Cal|Nm3,first
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	find|all,Nm2|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	null,Null2|Cal|Nm3,first
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	null,Null2|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	null,Null2|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|Cls0,dynamic|realm|object
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,last|track
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|StrEx2,time|start
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Cal0|Nm4,sort
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ex|VDE|VD|Cal1|Nm2,find|first
	first,Nm3|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	dynamic|realm|object,Cls0|VDE|VD|VDID0,last|track
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Nm0,realm
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Cal0|Nm3,where
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|StrEx2,time|start
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Fld3|Nm0,sort
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Fld3|Nm2,descending
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Cal0|Nm4,sort
	dynamic|realm|object,Cls0|VDE|VD|Cal1|Nm2,find|first
	dynamic|realm|object,Cls0|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Nm0,realm
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Fld2|Nm0,model
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Fld2|Nm2,track
	last|track,VDID0|VD|Cal1|Cal0|Cal0|Nm3,where
	last|track,VDID0|VD|Cal1|Cal0|StrEx2,time|start
	last|track,VDID0|VD|Cal1|Cal0|Fld3|Nm0,sort
	last|track,VDID0|VD|Cal1|Cal0|Fld3|Nm2,descending
	last|track,VDID0|VD|Cal1|Cal0|Nm4,sort
	last|track,VDID0|VD|Cal1|Nm2,find|first
	last|track,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	realm,Nm0|Cal0|Fld2|Nm0,model
	realm,Nm0|Cal0|Fld2|Nm2,track
	realm,Nm0|Cal0|Nm3,where
	realm,Nm0|Cal0|Cal0|StrEx2,time|start
	realm,Nm0|Cal0|Cal0|Fld3|Nm0,sort
	realm,Nm0|Cal0|Cal0|Fld3|Nm2,descending
	realm,Nm0|Cal0|Cal0|Nm4,sort
	realm,Nm0|Cal0|Cal0|Cal|Nm2,find|first
	realm,Nm0|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	model,Nm0|Fld2|Nm2,track
	model,Nm0|Fld2|Cal0|Nm3,where
	model,Nm0|Fld2|Cal0|Cal0|StrEx2,time|start
	model,Nm0|Fld2|Cal0|Cal0|Fld3|Nm0,sort
	model,Nm0|Fld2|Cal0|Cal0|Fld3|Nm2,descending
	model,Nm0|Fld2|Cal0|Cal0|Nm4,sort
	model,Nm0|Fld2|Cal0|Cal0|Cal|Nm2,find|first
	model,Nm0|Fld2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	track,Nm2|Fld2|Cal0|Nm3,where
	track,Nm2|Fld2|Cal0|Cal0|StrEx2,time|start
	track,Nm2|Fld2|Cal0|Cal0|Fld3|Nm0,sort
	track,Nm2|Fld2|Cal0|Cal0|Fld3|Nm2,descending
	track,Nm2|Fld2|Cal0|Cal0|Nm4,sort
	track,Nm2|Fld2|Cal0|Cal0|Cal|Nm2,find|first
	track,Nm2|Fld2|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	where,Nm3|Cal0|Cal0|StrEx2,time|start
	where,Nm3|Cal0|Cal0|Fld3|Nm0,sort
	where,Nm3|Cal0|Cal0|Fld3|Nm2,descending
	where,Nm3|Cal0|Cal0|Nm4,sort
	where,Nm3|Cal0|Cal0|Cal|Nm2,find|first
	where,Nm3|Cal0|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	time|start,StrEx2|Cal0|Fld3|Nm0,sort
	time|start,StrEx2|Cal0|Fld3|Nm2,descending
	time|start,StrEx2|Cal0|Nm4,sort
	time|start,StrEx2|Cal0|Cal|Nm2,find|first
	time|start,StrEx2|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	sort,Nm0|Fld3|Nm2,descending
	sort,Nm0|Fld3|Cal0|Nm4,sort
	sort,Nm0|Fld3|Cal0|Cal|Nm2,find|first
	sort,Nm0|Fld3|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	descending,Nm2|Fld3|Cal0|Nm4,sort
	descending,Nm2|Fld3|Cal0|Cal|Nm2,find|first
	descending,Nm2|Fld3|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	sort,Nm4|Cal0|Cal|Nm2,find|first
	sort,Nm4|Cal0|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	find|first,Nm2|Cal|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5098</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Fixclassnameinexceptionmessage</Title>
            
        <Description>This PR fixes The important change is in Cached Field Descriptor compile Field Description. At the end of the method, they passed className as an first argument of. However that argument should be the name of the container class of final field and actually the className is not the one. This PR also improve performance of Cached Field Descriptor compile Field Description.In the method map lookup happened three times with the same key for each field. This PR replaced it with just one lookup for each field.</Description>
           
        <code>
   CachedFieldDescriptorcompileFieldDescription()
   setCompilationResults()
   </code>
            
        <CreatedDate>11/08/2017</CreatedDate>
            
        <ClosedDate>16/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5098</PullRequestID>
                        
                <IssueID>5096</IssueID>
                        
                <Title>Class name in error message from query condition methods is wrong</Title>
                        
                <Description>Following test case will fail with org junit ComparisonFailure expected eld age in table Cat 		is of invalid type but was eld age in table Owner is of invalid type The point is that the test case uses link query.</Description>
                        
                <CreatedDate>11/08/2017</CreatedDate>
                        
                <ClosedDate>16/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5089</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>RxJava2 Add support for changese to bservables</Title>
            
        <Description>Part of Fixes This PR adds support for our fine grained collection notifications by adding  methods to the relevant classes. The name was discussed in but if anyone has better suggestions I'm all ears. The biggest difference is that these are Observables compared to Flowables for our standard listeners. The reason for this is that our various changeset classes depend on the state of the previous one, so just throwing these away would not be acceptable. It would be up to end users to decide what to do if they cannot keep up. For animations, developers would most likely just kill the animation and jump to the new end state, but that is not up to us to decide. TODO Redirect to  onceis merged. </Description>
            
        <code>
	asChangesetObservable()
	</code>
            
        <CreatedDate>10/08/2017</CreatedDate>
            
        <ClosedDate>26/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5089</PullRequestID>
                        
                <IssueID>4991</IssueID>
                        
                <Title>Feature RxJava2 Support</Title>
                        
                <Description>Part of This feature branch contains all changes required to convert our current RxJava1 support to RxJava2. There has been a lot of discussion about how our RxJava support could look like in and. Mostly it came down to a choice between splitting into a separate library like RxRealm or continue to use our optional dependency approach.After thinking about this a lot and trying to prototype the various approaches I came to the conclusion that we should continue to use our optional dependency approach. Reasons Splitting RxJava out is mostly a benefit for our codebase, not so much for users of Realm. Having a fluent API is extremely nice With Kotlin we could introduce the fluent API as extension functions, but right now the numbers still only show  of Realm uses having Kotlin in their code base.  People not using RxJava are not really affected either way. We had a few cases where reflection based libraries broke, like Jackson, but apart from that, we had no complaints about the optional dependency approach.  RxJava1 support is still possible through a RxRealm abstraction We dont have to spend time setting up a new repo CI documentation and distribution for a new library. realm java Let me know if you disagree strongly with this. TODO In Review Convert existing interfaces and method to RxJava2. Mostly Observable Flowable. In Review Implement Wil require moving Pair to public API. POSTPONED Implement  and  for transactions. Consider if RxObservableFactory is still the correct name. Observable has a specific meaning in the context of RxJava 2. RxStreamFactory perhaps Not immediately clear that changing this name is a massive improvement, so no reason to break it for a lot of people.   Update example app to RxJava2 dalinaum  Go through wording and Javadoc to ensure it matches RxJava2 </Description>
                		
                <code>
		DynamicRealm.asCompletable()
		Realm.asCompletable()
		 RealmResults.asChangesetObservable() 
		 RealmList.asChangesetObservable() 
		 RealmObject.asChangesetObservable()
		realm.where(Person.class).findAll().asFlowable() 
		RxRealm.asFlowable(realm.where(Person.class).findAll())
		</code>
                        
                <CreatedDate>19/07/2017</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5089</PullRequestID>
                        
                <IssueID>4277</IssueID>
                        
                <Title>RxJava support for finegrained notifications</Title>
                        
                <Description>We should extend our RxJava support to also include finegrained notifications. It would be relatively easy to expose as a Pair Realm Results 		ChangeSet. However naming it might be a bit difficult since asObservable is already taken. Some suggestions One thing to consider is also that we will get single object notifications in the near future which will have similar requirements. 		Personally I probably favour with a as a close second, both could be reused for single obje notifications I think. Thoughts realm java  Decide on a method name   Add new method to RxObservableFactory interface   Add implementation to RealmObservableFactory class Add methods to RealmList RealmResults Unit tests </Description>
                        
                <CreatedDate>02/03/2017</CreatedDate>
                        
                <ClosedDate>26/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>FirstGoodIssue</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5089</PullRequestID>
                        
                <IssueID>4277</IssueID>
                        
                <Title>RxJava support for finegrained notifications</Title>
                        
                <Description>We should extend our RxJava support to also include finegrained notifications. It would be relatively easy to expose as a Pair RealmResults, ChangeSet. However naming it might be a bit difficult since asObservable() is already taken. Some suggestions One thing to consider is also that we will get single object notifications in the near future which will have similar requirements. Personally I probably favour with a. as a close second, both could be reused for single object notifications I think. Thoughts realm java TODO Decide on a method name Add new method to Rx Observable Factory interface Add implementation to Realm Observable Factory class  Add methods to Realm List Realm Results Unit tests </Description>
                        
                <CreatedDate>02/03/2017</CreatedDate>
                        
                <ClosedDate>26/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>FirstGoodIssue</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5089</PullRequestID>
                        
                <IssueID>4991</IssueID>
                        
                <Title>Feature RxJava2 Support</Title>
                        
                <Description>Part of This feature branch contains all changes required to convert our current RxJava1 support to RxJava2.There has been a lot of discussion about how our RxJava support could look like in and. Mostly it came down to a choice between splitting into a separate library like RxRealm or continue to use our optional dependency approach. After thinking about this a lot and trying to prototype the various approaches, I came to the conclusion that we should continue to use our "optional dependency" approach. Reasons Splitting RxJava out is mostly a benefit for our codebase, not so much for users of Realm. Having a fluent API is extremely nice . With Kotlin we could introduce the fluent API as extension functions, but right now the numbers still only show of Realm uses having Kotlin in their code base. People not using RxJava are not really affected either way. We had a few cases where reflection based libraries broke, like Jackson, but apart from that, we had no complaints about the optional dependency approach. RxJava1 support is still possible through a RxRealm abstraction We dont have to spend time setting up a new repo, CI, documentation, and distribution for a new library.realm java Let me know if you disagree strongly with this. TODO In Review Convert existing interfaces and method to RxJava2. Mostly Observable Flowable. In Review Wil require moving Pair to public API.POSTPONED Implement  for transactions. Consider if RxObservableFactory is still the correct name. Observable has a specific meaning in the context of RxJava 2. RxStreamFactory perhaps Not immediately clear that changing this name is a massive improvement, so no reason to break it for a lot of people. Update example app to RxJava2 dalinaum Go through wording and Javadoc to ensure it matches RxJava2 </Description>
                		
                <code>
			realm.where(Person.class).findAll().asFlowable() 
			RxRealm.asFlowable(realm.where(Person.class).findAll())
			RealmResults.asChangesetObservable() 
			RealmList.asChangesetObservable()
			RealmObject.asChangesetObservable()
			DynamicRealm.asCompletable()
			Realm.asCompletable()
		</code>
                        
                <CreatedDate>19/07/2017</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5084</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Permission Wrapper Remove tasks if callback crashes</Title>
            
        <Description>Part of Found during another review. This ensures that we correctly remove tasks from the task queue even though onSuccess OnError callbacks throw an exception.</Description>
            
        <CreatedDate>09/08/2017</CreatedDate>
            
        <ClosedDate>10/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5084</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission API's</Title>
                        
                <Description>Fixes This is a feature branch. The work will be split into smaller PRs that will be merged into this branch incrementally. TODO Check changelog before final merge. Javadoc Timing issue for permission Realm not being ready Nonpublic PermissionManager constructorapplyPermissions method  getDefaultPermissions method   Remove FIXME Deprecate Management Real Remove task before calling success in case it crashes Optional makeOffer method acceptOffer method revokeOffer method getOffers method</Description>
                         
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5083</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>DeprecateManagementRealm</Title>
            
        <Description>Part of Deprecates  in favour of The implementation should be deleted in</Description>
            
        <CreatedDate>09/08/2017</CreatedDate>
            
        <ClosedDate>10/08/2017</ClosedDate>
        	
        <code>
	getManagementRealm()
	getPermissionManager()
	</code>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5083</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission APIs</Title>
                        
                <Description>Fixes This is a feature branch. The work will be split into smaller PR that will be merged into this branch incrementally. TODO Check changelog before final merge. Javadoc Timing issue for permission Realm not being ready   Non public Permission Manager constructor apply Permissions method  get Default Permissions method Remove FIXME Deprecate Management Realm Remove task before calling success in case it crashes Optional. make Offer method   accept Offer method revoke Offer method get Offers method   </Description>
                        
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5082</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Public Java doc for Permission Manager</Title>
            
        <Description>Part of This PR adds the remaining public Javadoc.</Description>
            
        <CreatedDate>09/08/2017</CreatedDate>
            
        <ClosedDate>10/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5082</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission APIs</Title>
                        
                <Description>Fixes This is a feature branch. The work will be split into smaller PR that will be merged into this branch incrementally. TODO Check changelog before final merge. Javadoc Timing issue for permission Realm not being ready Non public PermissionManager constructor   apply Permissions method get Default Permissions method Remove FIXME Deprecate Management Realm Remove task before calling success in case it crashes Optional make Offer method   accept Offer method revoke Offer method get Offers method</Description>
                        
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5081</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>MovePairintopublicAPI</Title>
            
        <Description>Part of This PR moves Pair into the public API. This is to prepare for changeset observables that need to emit items that look like this Pair Realm Results Ordered Collection Changeset An alternative could also be to create our own custom tuple class for this but Im not sure it is worth the effort</Description>
            
        <code>
	 public void accept(Pair&lt;RealmResults&lt;E&gt;, OrderedCollectionChangeset&gt; change) {
          change.first; // RealmResults
          change.second; // Changeset
       }
	</code>
            
        <CreatedDate>09/08/2017</CreatedDate>
            
        <ClosedDate>10/08/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5081</PullRequestID>
                        
                <IssueID>3497</IssueID>
                        
                <Title>RxJava 2 support</Title>
                        
                <Description> GoalUse RxJava 2.0 with realm.io, since it will be released soon Expected ResultsAdd support for the RxJava 2 same as it was added for the RxJava 1</Description>
                        
                <CreatedDate>27/09/2016</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5047</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>dalinaum</FixedByID>
            
        <Title>AddSyncUser.allSessions</Title>
            
        <Description>Fixes 4783</Description>
            
        <CreatedDate>30/07/2017</CreatedDate>
            
        <ClosedDate>08/08/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5047</PullRequestID>
                        
                <IssueID>4783</IssueID>
                        
                <Title>Add SyncUser.allSessions()</Title>
                        
                <Description>Swift docs mention that they have a SyncUser.allSession() method. 
We should add a similar method.

They also have a SyncUser.getSessionForUrl() method, but that seems covered by our SyncManager.getSession(configuration).</Description>
                        
                <CreatedDate>14/06/2017</CreatedDate>
                        
                <ClosedDate>08/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5039</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Work around j method bug with Android</Title>
            
        <Description> cherry pick to enabled debug in menifest which caused a crash described in. Removed API to create Java Method from jobject class name string.  There seems to be a bug in Android JVM when getting the method by:  The methodID retrieved by the above way triggers a strange bug in JVM, it reports the method cannot be found on a non relevant object. Like cant call on instance of io realm Realm Tests  Where Realm Test has nothing to do with that JNI call. It is not because of the local ref of cls has been deleted  Even if it is deleted, the methodID should still be valid according to the doc  The class references field IDs and method IDs are guaranteed valid until the class is unloaded.Classes are only unloaded if all classes associated with a ClassLoader can be garbage collected, which is rare but will not be impossible in Android. The class should never be unload in this case For safety reasons, the JavaMethod should only be created from a JavaClass right now to avoid future surprise. Close</Description>
            
	
        <code>
	 jclass cls = env&gt;GetObjectClass(obj); 
     jmethodID method = env&gt;GetMethodID(cls, "xxx", "xxx")
	 boolean io.realm.DefaultCompactOnLaunchCallback.shouldCompact(long, long)
	</code>
            
        <CreatedDate>28/07/2017</CreatedDate>
            
        <ClosedDate>02/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5039</PullRequestID>
                        
                <IssueID>4939</IssueID>
                        
                <Title>Options in AndroidManifest for attaching debugger</Title>
                        
                <Description>android permission SET DEBUG APP and android debuggable true areneeded for attaching debugger on some devices Huawei device.</Description>
                        
                <CreatedDate>10/07/2017</CreatedDate>
                        
                <ClosedDate>13/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5039</PullRequestID>
                        
                <IssueID>4964</IssueID>
                        
                <Title>android debuggable true and strange crash with  JNI DETECTED ERROR IN APPLICATION</Title>
                        
                <Code>
		boolean io.realm.DefaultCompactOnLaunchCallback.shouldCompact(long, long) 
		</Code>
                        
                <Description>reverted a change that android:debuggable="true" in AndroidManifest.xml .

When this is set, RealmTests will fail on compactOnLaunch_shouldNotCompact with a native crash:

</Description>
                        
                <CreatedDate>13/07/2017</CreatedDate>
                        
                <ClosedDate>02/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>P1Required</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5039</PullRequestID>
                        
                <IssueID>4964</IssueID>
                        
                <Title>android debuggable true and strange crash with  JNI DETECTED ERROR IN APPLICATION</Title>
                        
                <Code>
		boolean io.realm.DefaultCompactOnLaunchCallback.shouldCompact(long, long) 
		</Code>
                        
                <stacktrace>
		0713 09:19:26.174 F/libc    (24509): Fatal signal 6 (SIGABRT), code 6 in tid 24536 (roidJUnitRunner)
0713 09:19:26.285 F/DEBUG   (  485):                
0713 09:19:26.285 F/DEBUG   (  485): Build fingerprint: 'google/bullhead/bullhead:6.0/MDA89E/2296692:user/releasekeys'
0713 09:19:26.285 F/DEBUG   (  485): Revision: 'rev_1.0'
0713 09:19:26.285 F/DEBUG   (  485): ABI: 'arm64'
0713 09:19:26.285 F/DEBUG   (  485): pid: 24509, tid: 24536, name: roidJUnitRunner  &gt;&gt;&gt; io.realm.test &lt;&lt;&lt;
0713 09:19:26.286 F/DEBUG   (  485): signal 6 (SIGABRT), code 6 (SI_TKILL), fault addr 
0713 09:19:26.275 W/debuggerd64(  485): type=1400 audit(0.0:42592): avc: denied { search } for name="io.realm.test" dev="dm2" ino=392526 scontext=u:r:debuggerd:s0 tcontext=u:object_r:app_data_file:s0:c512,c768 tclass=dir permissive=0
0713 09:19:26.306 F/DEBUG   (  485): Abort message: 'art/runtime/java_vm_ext.cc:410 JNI DETECTED ERROR IN APPLICATION: can't call boolean io.realm.DefaultCompactOnLaunchCallback.shouldCompact(long, long) on instance of io.realm.RealmTests$6'
0713 09:19:26.307 F/DEBUG   (  485):     x0   0000000000000000  x1   0000000000005fd8  x2   0000000000000006  x3   0000000000000000
0713 09:19:26.307 F/DEBUG   (  485):     x4   0000000000000000  x5   0000000000000001  x6   0000000000000000  x7   0000000000000000
0713 09:19:26.307 F/DEBUG   (  485):     x8   0000000000000083  x9   00000000000139c0  x10  00000000862e34f8  x11  00000000862e3638
0713 09:19:26.308 F/DEBUG   (  485):     x12  0000000000000000  x13  0000007f79d30000  x14  0000000000000000  x15  0000000000000000
0713 09:19:26.308 F/DEBUG   (  485):     x16  0000007f79d22568  x17  0000007f79cb4f9c  x18  0000007f79d33f50  x19  0000007f70937500
0713 09:19:26.308 F/DEBUG   (  485):     x20  0000007f70937440  x21  0000000000000000  x22  0000000000000006  x23  0000007f7580b800
0713 09:19:26.308 F/DEBUG   (  485):     x24  0000007f586539c0  x25  0000000000000000  x26  0000007f76969000  x27  0000000000000000
0713 09:19:26.308 F/DEBUG   (  485):     x28  0000007f7580b800  x29  0000007f70935030  x30  0000007f79cb2858
0713 09:19:26.308 F/DEBUG   (  485):     sp   0000007f70935030  pc   0000007f79cb4fa4  pstate 0000000020000000
0713 09:19:26.331 F/DEBUG   (  485): 
0713 09:19:26.331 F/DEBUG   (  485): backtrace:
0713 09:19:26.331 F/DEBUG   (  485):     00 pc 000000000006afa4  /system/lib64/libc.so (tgkill+8)
0713 09:19:26.331 F/DEBUG   (  485):     01 pc 0000000000068854  /system/lib64/libc.so (pthread_kill+68)
0713 09:19:26.332 F/DEBUG   (  485):     02 pc 0000000000023838  /system/lib64/libc.so (raise+28)
0713 09:19:26.332 F/DEBUG   (  485):     03 pc 000000000001dfd8  /system/lib64/libc.so (abort+60)
0713 09:19:26.332 F/DEBUG   (  485):     04 pc 00000000004357d0  /system/lib64/libart.so (art::Runtime::Abort()+324)
0713 09:19:26.332 F/DEBUG   (  485):     05 pc 0000000000138164  /system/lib64/libart.so (art::LogMessage::~LogMessage()+3136)
0713 09:19:26.332 F/DEBUG   (  485):     06 pc 0000000000310ab8  /system/lib64/libart.so (art::JavaVMExt::JniAbort(char const, char const)+2080)
0713 09:19:26.332 F/DEBUG   (  485):     07 pc 0000000000310f38  /system/lib64/libart.so (art::JavaVMExt::JniAbortV(char const, char const, std::__va_list)+116)
0713 09:19:26.332 F/DEBUG   (  485):     08 pc 0000000000143f1c  /system/lib64/libart.so (art::ScopedCheck::AbortF(char const, ...)+144)
0713 09:19:26.333 F/DEBUG   (  485):     09 pc 0000000000144314  /system/lib64/libart.so (art::ScopedCheck::CheckMethodAndSig(art::ScopedObjectAccess&amp;, _jobject, _jclass, _jmethodID, art::Primitive::Type, art::InvokeType)+724)
0713 09:19:26.333 F/DEBUG   (  485):     10 pc 000000000015d9f8  /system/lib64/libart.so (art::CheckJNI::CallMethodV(char const, _JNIEnv, _jobject, _jclass, _jmethodID, std::__va_list, art::Primitive::Type, art::InvokeType)+724)
0713 09:19:26.333 F/DEBUG   (  485):     11 pc 0000000000160490  /system/lib64/libart.so (art::CheckJNI::CallBooleanMethodV(_JNIEnv, _jobject, _jmethodID, std::__va_list)+68)
0713 09:19:26.333 F/DEBUG   (  485):     12 pc 00000000000d370c  /data/app/io.realm.test1/lib/arm64/librealmjni.so (_JNIEnv::CallBooleanMethod(_jobject, _jmethodID, ...)+124)
0713 09:19:26.333 F/DEBUG   (  485):     13 pc 00000000000d3750  /data/app/io.realm.test1/lib/arm64/librealmjni.so (std::_Function_handler&lt;bool (unsigned long, unsigned long), Java_io_realm_internal_SharedRealm_nativeCreateConfig::'lambda'(unsigned long, unsigned long)&gt;::_M_invoke(std::_Any_data const&amp;, unsigned long, unsigned long)+56)
0713 09:19:26.333 F/DEBUG   (  485):     14 pc 000000000014dc68  /data/app/io.realm.test1/lib/arm64/librealmjni.so (std::function&lt;bool (unsigned long, unsigned long)&gt;::operator()(unsigned long, unsigned long) const+24)
0713 09:19:26.333 F/DEBUG   (  485):     15 pc 00000000001509d8  /data/app/io.realm.test1/lib/arm64/librealmjni.so (realm::Realm::open_with_config(realm::Realm::Config const&amp;, std::unique_ptr&lt;realm::Replication, std::default_delete&lt;realm::Replication&gt; &gt;&amp;, std::unique_ptr&lt;realm::SharedGroup, std::default_delete&lt;realm::SharedGroup&gt; &gt;&amp;, std::unique_ptr&lt;realm::Group, std::default_delete&lt;realm::Group&gt; &gt;&amp;, realm::Realm)+3628)
0713 09:19:26.334 F/DEBUG   (  485):     16 pc 0000000000150dc8  /data/app/io.realm.test1/lib/arm64/librealmjni.so (realm::Realm::Realm(realm::Realm::Config, std::shared_ptr&lt;realm::_impl::RealmCoordinator&gt;)+580)
0713 09:19:26.334 F/DEBUG   (  485):     17 pc 000000000016b044  /data/app/io.realm.test1/lib/arm64/librealmjni.so (realm::_impl::RealmCoordinator::get_realm(realm::Realm::Config)+1776)
0713 09:19:26.334 F/DEBUG   (  485):     18 pc 000000000014e0d0  /data/app/io.realm.test1/lib/arm64/librealmjni.so (realm::Realm::get_shared_realm(realm::Realm::Config)+372)
0713 09:19:26.334 F/DEBUG   (  485):     19 pc 00000000000d7b54  /data/app/io.realm.test1/lib/arm64/librealmjni.so (Java_io_realm_internal_SharedRealm_nativeGetSharedRealm+536)
0713 09:19:26.334 F/DEBUG   (  485):     20 pc 0000000001326e1c  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (long io.realm.internal.SharedRealm.nativeGetSharedRealm(long, io.realm.internal.RealmNotifier)+160)
0713 09:19:26.334 F/DEBUG   (  485):     21 pc 0000000001324458  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (void io.realm.internal.SharedRealm.&lt;init&gt;(long, io.realm.RealmConfiguration, io.realm.internal.SharedRealm$SchemaVersionListener)+604)
0713 09:19:26.334 F/DEBUG   (  485):     22 pc 0000000001325418  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.internal.SharedRealm io.realm.internal.SharedRealm.getInstance(io.realm.RealmConfiguration, io.realm.internal.SharedRealm$SchemaVersionListener, boolean)+1884)
0713 09:19:26.335 F/DEBUG   (  485):     23 pc 0000000001324c1c  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.internal.SharedRealm io.realm.internal.SharedRealm.getInstance(io.realm.RealmConfiguration)+112)
0713 09:19:26.335 F/DEBUG   (  485):     24 pc 0000000000c0bba0  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.BaseRealm io.realm.RealmCache.doCreateRealmOrGetFromCache(io.realm.RealmConfiguration, java.lang.Class)+532)
0713 09:19:26.335 F/DEBUG   (  485):     25 pc 0000000000c0b790  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.BaseRealm io.realm.RealmCache.createRealmOrGetFromCache(io.realm.RealmConfiguration, java.lang.Class)+196)
0713 09:19:26.335 F/DEBUG   (  485):     26 pc 0000000001236e00  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.Realm io.realm.Realm.getInstance(io.realm.RealmConfiguration)+340)
0713 09:19:26.335 F/DEBUG   (  485):     27 pc 0000000000cf22e0  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.internal.util.Pair io.realm.RealmTests.populateTestRealmAndCompactOnLaunch(io.realm.CompactOnLaunchCallback, int)+836)
0713 09:19:26.335 F/DEBUG   (  485):     28 pc 0000000000cf1f54  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (io.realm.internal.util.Pair io.realm.RealmTests.populateTestRealmAndCompactOnLaunch(io.realm.CompactOnLaunchCallback)+88)
0713 09:19:26.336 F/DEBUG   (  485):     29 pc 0000000000cf7a38  /data/app/io.realm.test1/oat/arm64/base.odex (offset 0xac2000) (void io.realm.RealmTests.compactOnLaunch_shouldNotCompact()+140)
0713 09:19:26.336 F/DEBUG   (  485):     30 pc 000000000011e164  /system/lib64/libart.so (art_quick_invoke_stub+580)
0713 09:19:26.336 F/DEBUG   (  485):     31 pc 000000000012e01c  /system/lib64/libart.so (art::ArtMethod::Invoke(art::Thread, unsigned int, unsigned int, art::JValue, char const)+176)
0713 09:19:26.336 F/DEBUG   (  485):     32 pc 0000000000430ac8  /system/lib64/libart.so (art::InvokeMethod(art::ScopedObjectAccessAlreadyRunnable const&amp;, _jobject, _jobject, _jobject, unsigned long)+888)
0713 09:19:26.336 F/DEBUG   (  485):     33 pc 00000000003c93dc  /system/lib64/libart.so (art::Method_invoke(_JNIEnv, _jobject, _jobject, _jobject)+40)
0713 09:19:26.336 F/DEBUG   (  485):     34 pc 000000007273f3a4  /data/dalvikcache/arm64/system@framework@boot.oat (offset 0x1ed4000)
0713 09:19:27.055 W/ActivityManager(  880): Error in app io.realm.test running instrumentation ComponentInfo{io.realm.test/android.support.test.runner.AndroidJUnitRunner}:
0713 09:19:27.055 W/ActivityManager(  880):   Native crash
0713 09:19:27.055 W/ActivityManager(  880):   Native crash: Aborted
		</stacktrace>
                		
                <Description>reverted a change that android debuggable true in Android Manifest xml When this is set, RealmTests will fail on 		compact On Launch should Not Compact with a native crash</Description>
                        
                <CreatedDate>13/07/2017</CreatedDate>
                        
                <ClosedDate>02/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>P1Required</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5031</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Support Primitive List feature</Title>
            
        <Description>This PR implements and fixes TODO Required Add modify APIs zaki50   Loosen type restriction on zaki50 Loosen type restriction on zaki50 Implement type parameter check in annotation processor zaki50 Implement Schema related feature used on initialization zaki50 par  Implement proxy's getters/setters logic in annotation processor zaki50 5210 part   Implement support for primitives in Realm List Java side zaki50 part Wire with Core Object Store beeender part part Fix for change listener @beeender part Fix a bug introduced in this feature branch zaki50    If we merge feature branch without optional feature, we need to add a code to throw an exception to some methods which does not support primitive list create Snap shot Optional In prioritized order  copy To Realm copy Or Update zaki50 insert insertOrUpdate zaki50 part copy From Realm zaki50 part APIs for migration mainly methods in Realm Object Schema cmelchior Ordered Realm Collection Impl Ordered Realm Collection Snapshot zaki50 part11 Dynamic API zaki50 Query APIs for list elements Query APIs for object by using primitive list value Implement support for primitives in RealmResults zaki50   JSON APIs</Description>
            
        <code>
	RealmList&lt;RealmModel&gt; 
	RealmList&lt;Object&gt;
	RealmResults&lt;RealmModel&gt; 
	RealmResults&lt;Object&gt;
	createSnapshot()
	</code>
            
        <CreatedDate>27/07/2017</CreatedDate>
            
        <ClosedDate>01/10/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>4165</IssueID>
                        
                <Title>RFC: Primitive List API</Title>
                        
                <Description>With work in Core slowly picking up speed regarding Primitive List support, we need to start thinking about how the public API is going to look like. Also, so it can guide the underlying implementation. This document tries to flesh out the various proposals that have been discusse so we can get feedback on the direction as well as guide Cores design decisions. Thoughts realm java References </Description>
                        
                <CreatedDate>09/02/2017</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>PipelineOnHold</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>575</IssueID>
                        
                <Title>Realm List Integer String</Title>
                        
                <Code> 
		RealmList&lt;RealmString&gt; names;
		public class RealmString extends RealmObject {
		private String name;
		// getter &amp; setter
		</Code>
                        
                <Description>Dear realmTeam Im really impressed by Realm and I do like the way youre providing support and solutions on github SO and gGroups I like working with Realm  however there are three really big drawbacks for me No modelinstantiation by new I know you're on it. I can't wait for this Do we have to wait for the whole JSON Upgrade or will there be an earlier release providing this feature No modelpassing across threads. Thats hindering all the great benefits of EventBus and Android Priority Job Queue. But I read that it will be possible in the further versions and Im looking forward on this. The reason for this issue In my model class I'm allowed to have primitive fields as well as object fields of objects that extend RealmObject. But Im not allowed to have a field type like However it is possible to work around this by It works but its really ugly and should be unnecessary in my opinion. Is there any improvement planned regarding this Thanks again for your great work  I'm glad Realm helps me developing my app Related PRs API design Implementation</Description>
                	   
                <code>
	   RealmList&lt;Integer&gt; or RealmList&lt;String&gt;.
	   </code>
                        
                <CreatedDate>18/11/2014</CreatedDate>
                        
                <ClosedDate>01/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Blocked</Label>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5145</IssueID>
                        
                <Title>Primitive List feature(Part1: API changes)</Title>
                        
                <Description>This PR is following Design in RFC Many classes and methods dont have Javadoc comment for now. Ill add them later.
         </Description>
                        
                <CreatedDate>24/08/2017</CreatedDate>
                        
                <ClosedDate>05/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5145</IssueID>
                        
                <Title>Primitive List feature(Part1: API changes)</Title>
                        
                <Description>This PR is following Design in RFC Many classes and methods don't have Javadoc comment for now. I'll add them later.</Description>
                        
                <CreatedDate>24/08/2017</CreatedDate>
                        
                <ClosedDate>05/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5145</IssueID>
                        
                <Title>Primitive List feature(Part1: API changes)</Title>
                        
                <Description>This PR is following Design 1 in RFC Many classes and methods dont have Javadoc comment for now. Ill add them later.</Description>
                        
                <CreatedDate>24/08/2017</CreatedDate>
                        
                <ClosedDate>05/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5168</IssueID>
                        
                <Title>Primitive List feature Part5 Element type check in annotation processor</Title>
                        
                <Code> 
		public RealmList&lt;java.math.BigInteger&gt; integers;
        </Code>
                        
                <Description>Implemented a type check for Realm Lists type variable If we have a invalid field like public RealmList java math BigInteger integers we will get
		</Description>
                        
                <CreatedDate>29/08/2017</CreatedDate>
                        
                <ClosedDate>05/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
                <AST>f
	some|unknown|return|type,Cls0|Mth|Nm1,METHOD_NAME
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls|Cls|Cls|Cls0,java
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,integers
	some|unknown|return|type,Cls0|Mth|Bk|Ret|Nm0,no|such|return|value
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls|Cls|Cls|Cls0,java
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,integers
	METHOD_NAME,Nm1|Mth|Bk|Ret|Nm0,no|such|return|value
	java,Cls0|Cls|Cls|Cls|VDE|VD|VDID0,integers
	java,Cls0|Cls|Cls|Cls|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	integers,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value</AST>
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5209</IssueID>
                        
                <Title>Primitive List feature Part Schema)</Title>
                        
                <Description>This PR is based on Part This PR implements schema related feature required from proxy class.</Description>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>13/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5210</IssueID>
                        
                <Title>Primitive List feature Part Annotation processor implementation</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>15/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5213</IssueID>
                        
                <Title>Primitive List feature Part RealmList</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>06/09/2017</CreatedDate>
                        
                <ClosedDate>19/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5208</IssueID>
                        
                <Title>Primitive List feature Part OsList</Title>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5216</IssueID>
                        
                <Title> Primitive List feature Part JNI accessors</Title>
                        
                <Description>This PR is based on Part Java Accessor Context. Accessors for OsList. String and binary dont work yet.Tests for OsList.</Description>
                        
                <CreatedDate>07/09/2017</CreatedDate>
                        
                <ClosedDate>14/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5210</IssueID>
                        
                <Title>Primitive List feature(Part8: Annotation processor implementation</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>15/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5210</IssueID>
                        
                <Title>Primitive List feature Part Annotation processor implementation</Title>
                        
                <Description>This PR is based on Part 10</Description>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>15/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5210</IssueID>
                        
                <Title>Primitive List feature Part Annotation processor implementation</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>05/09/2017</CreatedDate>
                        
                <ClosedDate>15/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5220</IssueID>
                        
                <Title>Primitive List feature Part Collection Snapshot</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>07/09/2017</CreatedDate>
                        
                <ClosedDate>02/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5221</IssueID>
                        
                <Title>Primitive List feature Part Dynamic Realm</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>07/09/2017</CreatedDate>
                        
                <ClosedDate>01/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5031</PullRequestID>
                        
                <IssueID>5220</IssueID>
                        
                <Title>Primitive List feature Part Collection Snapshot</Title>
                        
                <Description>This PR is based on Part</Description>
                        
                <CreatedDate>07/09/2017</CreatedDate>
                        
                <ClosedDate>02/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5023</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>copy To Realm Or Update caused up values in list field</Title>
            
        <Description> We are using HashMap to maintain a cache of added managed RealmObject when doing copy Or Update. But if the given object graph contains objects which have same PK but are different java object cache missing will happen. That caused the object got set multiple times. For nonlist fields it is not a problem since it will eventually has the expected value if users objects graph is consistent. 	For list, that results the elements in the list are added multiple times since we don't clear the Realm List in.</Description>
             
	
        <code>
	copy()
	</code>
            
        <CreatedDate>26/07/2017</CreatedDate>
            
        <ClosedDate>01/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5023</PullRequestID>
                        
                <IssueID>4957</IssueID>
                        
                <Title>Duplicate PrimaryKeys with Copy To Realm Or Update how is this possible</Title>
                        
                <Description>Hi Ive got some nested Realm Objects which I try to insert into Realm via copy to Realm Or Update. This is my object If my understanding is correct I expect Realm to loop the object tree recursively and inserts or updates all objects to the database. And because both duplicate objects contain the same primary key I expected Realm to only contain one Site object and only one Campaign object in the database after the appendToRealm method. But the Campaign object was inserted twice. If I see the logs in my app and inspect the database in RealmBrowser they show two instances of the Campaign object with the same uuid as primary key. The Site object is present only once, although it has been twice in the JSON, too. How is this even possible? For all other objects copyToRealmOrUpdate works as expected. Maybe you can clarify this problem? Thanks in advance Version of Realm and tooling Realm versions Realm sync feature enabled Android Studio version Which Android version and device Sony Xperia Android </Description>
                        
                <CreatedDate>12/07/2017</CreatedDate>
                        
                <ClosedDate>01/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>P1Required</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5020</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>Remove Object Server User</Title>
            
        <Description> Removed Object Server User to simplify the handling of SyncUser reduce complexity Fixed bugs in logout where it was possible to logout without checking if the associated Realm instances are still open fixes</Description>
            
        <CreatedDate>25/07/2017</CreatedDate>
            
        <ClosedDate>21/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5020</PullRequestID>
                        
                <IssueID>3741</IssueID>
                        
                <Title>Migrate SyncUser to the ObjectStore</Title>
                        
                <Description>Sync User class should use the ObjectStore SyncUser.</Description>
                        
                <CreatedDate>03/11/2016</CreatedDate>
                        
                <ClosedDate>21/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5020</PullRequestID>
                        
                <IssueID>4962</IssueID>
                        
                <Title>Logout and opend Realm instance</Title>
                        
                <Description>From the document But this is not true. It is checking Object Server User sessions to determine if there is any Realm instance is still opened. But Object Server User sessions is used anymore after we moved session logic to Object Store. To solve this Do we really want to restrict user from logging out when Realm instance are still opened? From my opinion. it is very difficult if there are realm instance in the background in user's app. It the relevant Realm instance stops syncing, then it would be good enough for user. If we allow this we need to ensure user won't open a Realm instance with the same name for a different user even in multiprocesses environment If we disallow this then needs to also consider the corner case for getInstanceAsync().</Description>
                         
                <code>SyncUser.logout()</code>
                		
                <CreatedDate>13/07/2017</CreatedDate>
                        
                <ClosedDate>21/08/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>P1Required</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5017</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>bmeike</FixedByID>
            
        <Title>Counters Merge Mutable Realm Integers Feature</Title>
            
        <Description>Add support for Counters Implements most of</Description>
            
        <CreatedDate>24/07/2017</CreatedDate>
            
        <ClosedDate>26/07/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>P2Expected</PullRequestLabel>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5017</PullRequestID>
                        
                <IssueID>4266</IssueID>
                        
                <Title>Support MutableRealmInteger</Title>
                        
                <Description>The original initial comment for this issue is here This heading reflects the current understanding of the project The basic semantics for this feature now called Mutable Realm Integer have finally been sorted out here This issue now tracks implementation. TODO Support unmanaged Mutable Realm Integers   Support basic managed Mutable Realm Integers atomic increment and decrement Support Required Support Index Support JSON and streams Support Dynamic API Support </Description>
                        
                <code>RealmList&lt;ManagedRealmInteger&gt;</code>
                        
                <CreatedDate>28/02/2017</CreatedDate>
                        
                <ClosedDate>26/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>5007</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>bmeike</FixedByID>
            
        <Title>Counters JSON for Mutable Realm Integers</Title>
            
        <Description>Another step in the implementation of Clean up documentation Add JSON parsing for Mutable Realm Integers Add UTs for new code.</Description>
            
        <CreatedDate>22/07/2017</CreatedDate>
            
        <ClosedDate>24/07/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>P2Expected</PullRequestLabel>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>5007</PullRequestID>
                        
                <IssueID>4266</IssueID>
                        
                <Title>Support Mutable Realm Integer</Title>
                        
                <Description>The original initial comment for this issue is here This heading reflects the current understanding of the project The basic semantics for this feature, now called MutableRealmInteger have finally been sorted out here This issue now tracks implementation. TODO Support unmanaged Mutable Realm Integers Support basic managed Mutable Realm Integers atomic increment and decrement Support Required Support Index Support JSON and streams Support Dynamic API Support 
        </Description>
                        
                <code>RealmList&lt;ManagedRealmInteger&gt;</code>
                        
                <CreatedDate>28/02/2017</CreatedDate>
                        
                <ClosedDate>26/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4992</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Convert RxJava1 to RxJava2</Title>
            
        <Description>Fixes Part of Convert the existing APIs to RxJava 2 types Since Realm is a hot stream, dropping notifications and only using the latest is fine. The naming in the public API reflects this. 	Realm Query is exposed as Single. Note this is still not used in our public API, but the primary use case would move the query to a background scheduler run the query, and convert all types using 	fits that nicely. Also, I dont see any use cases where you would be interested in listening to changes to the query construction.  </Description>
            
        <code>asObservable() &gt; asFlowable()
	copyFromRealm()
	Single()
	</code>
            
        <CreatedDate>19/07/2017</CreatedDate>
            
        <ClosedDate>13/08/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4992</PullRequestID>
                        
                <IssueID>4095</IssueID>
                        
                <Title>Realm Observable Factory unsubscription subscriber order and add Change Listener should be inverted</Title>
                        
                <Description> Goal What do you want to achieve Use take Expected Results Unsubscribe as needed. Actual Results Not sure, but according to Jake Wharton, I think the code in Realm Observable Factory might not work as expected with take and this change in RxBinding can be seen in  Version of Realm and tooling Realm versions</Description>
                        
                <CreatedDate>23/01/2017</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>ReproductionRequired</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4992</PullRequestID>
                        
                <IssueID>4991</IssueID>
                        
                <Title>Feature RxJava2 Support</Title>
                        
                <Description>Part of This feature branch contains all changes required to convert our current RxJava1 support to RxJava2.There has been a lot of discussion about how our RxJava support could look like in 3497 and 4291 . Mostly it came down to a choice between splitting into a separate library like RxRealm or continue to use our "optional dependency" approach. After thinking about this a lot and trying to prototype the various approaches I came to the conclusion that we should continue to use our optional dependency approach. Reasons  Splitting RxJava out is mostly a benefit for our codebase, not so much for users of Realm. Having a fluent API is extremely nice With Kotlin we could introduce the fluent API as extension functions, but right now the numbers still only show of Realm uses having Kotlin in their code base.  People not using RxJava are not really affected either way. We had a few cases where reflection based libraries broke, like Jackson, but apart from that, we had no complaints about the optional dependency approach.  RxJava1 support is still possible through a RxRealm abstraction We dont have to spend time setting up a new repo CI documentation and distribution for a new library. realm java Let me know if you disagree strongly with this. TODO In Review Convert existing interfaces and method to RxJava2. Mostly Observable Flowable. In Review Implement and Wil require moving Pair to public API.   POSTPONED Implement  and  for transactions  Consider if Rx Observable Factory is still the correct name. Observable has a specific meaning in the context of RxJava RxStreamFactory perhaps   Not immediately clear that changing this name is a massive improvement so no reason to break it for a lot of people. Update example app to RxJava2 dalinaum   Go through wording and Javadoc to ensure it matches RxJava2 </Description>
                		
                <code>
			realm.where(Person.class).findAll().asFlowable() 
			RxRealm.asFlowable(realm.where(Person.class).findAll())
			RealmResults.asChangesetObservable()
			RealmList.asChangesetObservable()
			RealmObject.asChangesetObservable()
			Realm.asCompletable()
			DynamicRealm.asCompletable()
		</code>
                        
                <CreatedDate>19/07/2017</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4991</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Feature RxJava2 Support</Title>
            
        <Description>Part of This feature branch contains all changes required to convert our current RxJava1 support to RxJava2.There has been a lot of discussion about how our RxJava support could look like in. Mostly it came down to a choice between splitting into a separate library like RxRealm or continue to use our optional dependency approach. After thinking about this a lot and trying to prototype the various approaches, I came to the conclusion that we should continue to use our optional dependency approach. Reasons Splitting RxJava out is mostly a benefit for our codebase, not so much for users of Realm. Having a fluent API is extremely nice With Kotlin we could introduce the fluent API as extension functions, but right now the numbers still only show of Realm uses having Kotlin in their code base. People not using RxJava are not really affected either way. We had a few cases where reflection based libraries broke, like Jackson, but apart from that, we had no complaints about the optional dependency approach. RxJava1 support is still possible through a RxRealm abstraction  We don't have to spend time setting up a new repo, CI, documentation, and distribution for a new library. realm java Let me know if you disagree strongly with this. TODO In Review Convert existing interfaces and method to RxJava2. Mostly Observable Flowable. In Review Implement and Wil require moving Pair to public API. POSTPONED Implement and  for transactions.  Consider if RxObservableFactory is still the correct name. Observable has a specific meaning in the context of RxJava 2. RxStreamFactory perhaps Not immediately clear that changing this name is a massive improvement so no reason to break it for a lot of people. Update example app to RxJava2 dalinaum Go through wording and Javadoc to ensure it matches RxJava2 </Description>
            
        <code>
	 realm.where(Person.class).findAll().asFlowable()  
	 RxRealm.asFlowable(realm.where(Person.class).findAll())
	 RealmResults.asChangesetObservable()
	 RealmList.asChangesetObservable()
	 RealmObject.asChangesetObservable()
	 Realm.asCompletable()
	 DynamicRealm.asCompletable()
	</code>
            
        <CreatedDate>19/07/2017</CreatedDate>
            
        <ClosedDate>11/09/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>Breaking</PullRequestLabel>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4991</PullRequestID>
                        
                <IssueID>4785</IssueID>
                        
                <Title>Breaking change Wishlist for</Title>
                        
                <Description>This ticket is for general discussion of the breaking changes in the coming release.Please edit the main post to add a topic with a sequence number, and we can discuss it in the comments. If the breaking change is decided to be worthy to add, then create a separated issue for it. POSTPONED Do not allow having both typed Realm instance and Dynamic Realm instance on the same thread. Throw an exception instead. This creates lots of troubles with Realm instance cache management. By disallowing it, the RealmCache implementation can be much simpler and give us an option to totally manage the Realm instance through Object Store. POSTPONED  Change the behavior of distinct to work against query result. See DONE Replace RxJava1 with RxJava2. This issue here 3497 describes an approach where we split RxJava support into a separate library, but after trying that out in a sample project it just feels really clunky. Doing  is just so much nicer than doing and if one thing Kotlin has proved, then it is that small things matter~~  POSTPONED Remove the mips so file since there is NO mips device in the market. DONE NH Rename get Access Token either rename it to reflect the fact that it's returning a refresh token, or abstract the name to the end user. DONE Remove deprecated methods retrieveUser and retrieveUserAsync as well as the deprecated Sync User Callback
         </Description>
                        
                <code>
		realm.where(Person.class).findAll().asFlowable()
		RxRealm.asFlowable(realm.where(Person.class).findAll()) 
		</code>
                		
                <CreatedDate>14/06/2017</CreatedDate>
                        
                <ClosedDate>03/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Breaking</Label>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4991</PullRequestID>
                        
                <IssueID>3497</IssueID>
                        
                <Title>RxJava 2 support</Title>
                        
                <Description>GoalUse RxJava 2.0 with realm io since it will be released soon Expected Results Add support for the RxJava 2 same as it was added for the RxJava 1</Description>
                        
                <CreatedDate>27/09/2016</CreatedDate>
                        
                <ClosedDate>11/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4991</PullRequestID>
                        
                <IssueID>4291</IssueID>
                        
                <Title>Better RxJava support</Title>
                        
                <Code>		
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            return query.findAll().asObservable();
			
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Copy into memory before sending data further down the stream
            // Possible this could be done one internally in the asObservable() method
            // TODO solve thread confinement for realm.
            return query.findAll().asObservable()
                .map(result &gt; realm.copyFromRealm(result));        
        }
		
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Pin the version before sending sending data further down the stream
            // Possible this could be one internally in the asObservable() method
            // TODO solve thread confinement for query.
            return query.findAll().asObservable().map(result &gt; result.freeze());        
        }
		
		public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // Convert to AutoValue object before sending sending data further down the stream
            return query.findAll().asObservable()
                .map(result &gt; 
                    List l = new ArrayList();
                    for (Person p : result) {
                      l.add(AutoValuePerson.from(p));
                    } 
                    return l;
                );        
        }
		
	    public Observable&lt;ThreadSafeReference&lt;RealmResults&lt;Person&gt;&gt;&gt; call(ThreadSafeReference&lt;RealmQuery&lt;Person&gt;&gt; query) {
            // .get() resolves the reference.
            return query.get().findAll().asObservable();
        }
	
	    public Observable&lt;ThreadSafeReference&lt;RealmResults&lt;Person&gt;&gt;&gt; call(ThreadSafeReference&lt;RealmQuery&lt;Person&gt;&gt; query) {
            return query.get().findAll().asObservable();
        }	
		
        public Observable&lt;RealmResults&lt;Person&gt;&gt; call(RealmQuery&lt;Person&gt; query) {
            // query.isPinned() == true;
            return query.findAll().asObservable().map(results &gt; results.pin());
        }

		</Code>
                        
                <Description>Right now the interop between RxJava and Realm is not as good as it could be, which is also the feedback we are constantly getting.This issue is mostly an attempt at summarizing the situation and making sure we have the information in one place instead of being spread out across multiple issues that do not address the full picture. The Current SituationCurrently, we have 3 major issues preventing great compatibility with RxJava:1. No support for Schedulers(2. Streams work on immutable objects. Realm uses live objects(3. Thread confinement makes it hard to move work across threads.I'll try to describe each case below and possible solutions.  Challenges 1. Custom SchedulersRealm's async query methods do not allow the use of custom schedulers.Take this example.The internal code changes required to support frozen objects will probably be quite large and could have a quite big impact on performance as all accessors most likely will require additional logic.   4. Other solutionsNo other solution has been thoroughly thought through yet, so a number of solutions could be found here: Implement PinnedRealmResults, PinnedRealmList, PinnedRealm, etc. versions. Could result in quite a lot of new classes Others? Conclussion / TLDR We need to implement RealmQuery.asObservable(). Solving how to move queries across threads will have a lot of influence on how pinning/thread confinement should be solved as well. We need to investigate how pinning versions in RxJava heavy apps effect the file size. This should drive the decision for choosing pinning or copyFromRealm as the default solution. Most likely we will have to offer both in any case. Having the RxObservableFactory interface is nice here as we can easily provide multiple solutions that people can swap easily. copyFromRealm() might not be the "pure" solution, but it is pragmatic. ThreadSafeReference as implemented by Cocoa is not suited for RxJava support. As a minimum we must provide the option of getting the value multiple times on multiple threads.I'll try to keep this post updated with more information and QA.</Description>
                        
                <CreatedDate>06/03/2017</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>PipelineIdeaBacklog</Label>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4981</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add missing error codes</Title>
            
        <Description>Fixes This adds error codes not documented in the protocol definition. Note, that these new error codes also clashes with existing ones. E.g we have BAD CHANGESET Bad changeset UPLOAD and now BAD CHANGESET DOWNLOAD Bad changeset DOWNLOAD Finding a consistent way of naming all these enums do appear straight forward nor easy to make consistent and easy to use by end users, so I went with the simplest approach and suffixed the conflicting new ones with _DOWNLOAD. Suggestions for making this better is welcome. </Description>
            
        <CreatedDate>18/07/2017</CreatedDate>
            
        <ClosedDate>19/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4981</PullRequestID>
                        
                <IssueID>4980</IssueID>
                        
                <Title>Update ErrorCode enum with new errorcodes</Title>
                        
                <Description>A user has received Illegal Argument Exception Unknown error code 112 because there are more error codes than the ones defined in are not defined here, but are defined in enum class Client Error connection closed Connection closed no error unknown message Unknown type of input message bad syntax Bad syntax in input message head limits exceeded Limits exceeded in input message bad session ident Bad session identifier in input message bad message order Bad input message order  bad file ident pair Bad file identifier pair  ALLOC bad progress Bad progress information  DOWNLOAD  bad changeset header syntax Bad syntax in changeset header  DOWNLOAD bad changeset size Bad changeset size in changeset header  DOWNLOAD bad origin file ident Bad origin file identifier in changeset header  DOWNLOAD bad server version Bad server version in changeset header  DOWNLOAD bad changeset Bad changeset  DOWNLOAD bad request ident Bad request identifier  MARK bad error code Bad error code  ERROR  bad compression Bad compression  DOWNLOAD bad client version Bad last integrated client version in changeset header  DOWNLOAD Since Bad changeset is easy to get with mismatched models a good explanation of this error would be good.</Description>
                        
                <CreatedDate>18/07/2017</CreatedDate>
                        
                <ClosedDate>19/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4953</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>bmeike</FixedByID>
            
        <Title>CountersWiredtocore</Title>
            
        <Description>Next step in  4266 </Description>
            
        <CreatedDate>12/07/2017</CreatedDate>
            
        <ClosedDate>13/07/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>P2Expected</PullRequestLabel>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4953</PullRequestID>
                        
                <IssueID>4266</IssueID>
                        
                <Title>Support MutableRealmInteger</Title>
                        
                <Description> The original initial comment for this issue is here This heading reflects the current understanding of the project The basic semantics for this feature, now called Mutable Realm Integer have finally been sorted out here  This issue now tracks implementation.
TODO
  Support unmanaged MutableRealmIntegers
  Support basic managed MutableRealmIntegers  atomic increment and decrement 
  Support @Required
  Support @Index
  Support JSON and streams
  Support Dynamic API
  Support 
</Description>
                        
                <code>RealmList&lt;ManagedRealmInteger&gt;</code>
                        
                <CreatedDate>28/02/2017</CreatedDate>
                        
                <ClosedDate>26/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4952</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>bmeike</FixedByID>
            
        <Title>CountersWiredtocore</Title>
            
        <Description>Managed counters working: 4266</Description>
            
        <CreatedDate>12/07/2017</CreatedDate>
            
        <ClosedDate>12/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4952</PullRequestID>
                        
                <IssueID>4266</IssueID>
                        
                <Title>Support Mutable Realm Integer</Title>
                        
                <Description> The original initial comment for this issue is here This heading reflects the current understanding of the project The basic semantics for this feature now called Mutable Realm Integer have finally been sorted out here This issue now tracks implementation.TODO Support unmanaged Mutable Realm Integers Support basic managed Mutable Realm Integers  atomic increment and decrement Support Required   Support Index Support JSON and streams Support Dynamic API Support </Description>
                        
                <CreatedDate>28/02/2017</CreatedDate>
                        
                <ClosedDate>26/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4934</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Upgrade Realm Core to</Title>
            
        <Description>This introduces a breaking change to how SSL is configured addressed this Close</Description>
            
        <CreatedDate>07/07/2017</CreatedDate>
            
        <ClosedDate>11/07/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4934</PullRequestID>
                        
                <IssueID>4791</IssueID>
                        
                <Title>Expose bug when querying an indexed field with Case INSENSITIVE</Title>
                        
                <Description>Exposes Waiting for  to be fixed</Description>
                        
                <CreatedDate>15/06/2017</CreatedDate>
                        
                <ClosedDate>14/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Blocked</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4934</PullRequestID>
                        
                <IssueID>4788</IssueID>
                        
                <Title>Case INSENSITIVE query broken at</Title>
                        
                <Code>
		realm.beginTransaction;
		Dog dog1 = realm.copyToRealm Dog.create "ROVER";
		Dog dog2 = realm.copyToRealm Dog.create "Rover";
		realm.commitTransaction;
		</Code>
                        
                <Description>It appears that caseinsensitive queries are broken in some cases. It appears that if you have a field with the same string in different cases querying on the field in a case in sensitive manner returns no results, rather than the expected two results.This behaviour was working in but broke in. I suspect this may have been due to a change to realm core. It is still broken as of. See the Repo here with a failing test The following test fails</Description>
                        
                <CreatedDate>15/06/2017</CreatedDate>
                        
                <ClosedDate>11/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>Blocked</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4933</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Renaming Collection Change Set to OsCollection ChangeSet</Title>
            
        <Description>Part II of 4215.</Description>
            
        <CreatedDate>07/07/2017</CreatedDate>
            
        <ClosedDate>05/09/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4933</PullRequestID>
                        
                <IssueID>4215</IssueID>
                        
                <Title>Common prefix for Object Store Classes</Title>
                        
                <Description>To match the same Results in Object Store. Blame me. I made the confusing name. Use common prefix Collection OsResults
		SharedRealm OsSharedRealm</Description>
                        
                <CreatedDate>21/02/2017</CreatedDate>
                        
                <ClosedDate>31/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4922</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>bmeike</FixedByID>
            
        <Title>CountersFirstpassatimplementation</Title>
            
        <Description>Rewrite of the implementation of counters as Mutable Realm Integers Preliminary implementation of</Description>
            
        <CreatedDate>06/07/2017</CreatedDate>
            
        <ClosedDate>10/07/2017</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4922</PullRequestID>
                        
                <IssueID>4266</IssueID>
                        
                <Title>Support MutableRealmInteger</Title>
                        
                <Description> The original initial comment for this issue is here  This heading reflects the current understanding of the project The basic semantics for this feature now called Mutable Realm Integer have finally been sorted out here This issue now tracks implementation. Support unmanaged Mutable Realm Integers Support basic managed Mutable Realm Integers atomic increment and decrement Support Required Support Index Support JSON and streams Support Dynamic API Support </Description>
                        
                <code>RealmList&lt;ManagedRealmInteger&gt;</code>
                        
                <CreatedDate>28/02/2017</CreatedDate>
                        
                <ClosedDate>26/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4921</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>PermissionWrapperAddsupportforrevokingoffers</Title>
            
        <Description>Last functional part of Adds support for revoking active offers. TODO Redirect to feature permission wrapper once is merged </Description>
            
        <CreatedDate>05/07/2017</CreatedDate>
            
        <ClosedDate>20/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4921</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission APIs</Title>
                        
                <Description>Fixes This is a feature branch. The work will be split into smaller PR's that will be merged into this branch incrementally.
TODO   Check changelog before final merge.
  Javadoc
  Timing issue for permission Realm not being ready
  Nonpublic PermissionManager constructor
  applyPermissions method   4731  
  getDefaultPermissions method   4850  
  Remove FIXME's
  Deprecate Management Realm
  Remove task before calling success  in case it crashes 

Optional
  makeOffer method
  acceptOffer method 
  revokeOffer method
  getOffers method</Description>
                        
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4920</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Permission Wrapper Add support for retrieving list of offers</Title>
            
        <Description>Part of Adds support for returning list of active offers. Mostly to enable to get tokens again or revoke them. TODO Redirect to feature/permissionwrapper once is merged.</Description>
            
        <CreatedDate>05/07/2017</CreatedDate>
            
        <ClosedDate>19/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4920</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission APIs</Title>
                        
                <Description>Fixes 4296 This is a feature branch. The work will be split into smaller PR's that will be merged into this branch incrementally. TODO Check changelog before final merge. Javadoc   Timing issue for permission Realm not being ready Nonpublic Permission Manager constructor apply Permissions method    get Default Permissions method Remove FIXME Deprecate Management Realm Remove task before calling success  in case it crashes  Optional   makeOffer method acceptOffer method revokeOffer method  getOffers method</Description>
                        
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4917</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix wrong java doc in Realm Configuration</Title>
            
        <Description>Fixes realm java</Description>
            
        <CreatedDate>05/07/2017</CreatedDate>
            
        <ClosedDate>06/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realm java</RepoID>
                        
                <PullRequestID>4917</PullRequestID>
                        
                <IssueID>4916</IssueID>
                        
                <Title>Java doc of Realm Configuration still shows builder with context in constructor param</Title>
                        
                <Description>says get Context build But that is not true it is Realm init getContext build </Description>
                        
                <code> 
		RealmConfiguration config = new RealmConfiguration.Builder		
		</code>
                        
                <CreatedDate>05/07/2017</CreatedDate>
                        
                <ClosedDate>06/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4914</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Add missing sync error codes</Title>
            
        <Description>Discovered while adding tests for This PR adds support for all known error codes coming from ROS including standard HTTP error codes. All names are just capitalized versions of this list 	</Description>
            
        <CreatedDate>05/07/2017</CreatedDate>
            
        <ClosedDate>05/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4906</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>List enersand Linking Objects</Title>
            
        <Description>To clarify expected behaviour see also </Description>
            
        <CreatedDate>04/07/2017</CreatedDate>
            
        <ClosedDate>05/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4906</PullRequestID>
                        
                <IssueID>4875</IssueID>
                        
                <Title>Main object not being notified when a Linking Objects collection changes</Title>
                        
                <Description>Hello I have the following structure I only write down the relevant parts I have a parapet with letters asociated. 		When I change one of the associated letters contender the related parapet is not being notified  for example when I use a Realm Results of parapets as a source for a Recycler View Adapter Im using realm Before being a Linking Objects I had it as a and it did notified. 		I don't know if with the new Linking Objects functionallity this kind of notificiations are not being raised anymore.</Description>
                        
                <code>RealmList&lt;Letter&gt;</code>
                		
                <CreatedDate>29/06/2017</CreatedDate>
                        
                <ClosedDate>
        </ClosedDate>
                        
                <Labels>
                              
                    <Label>OCommunity</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4901</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>PermissionWrappersBetterTestSetup</Title>
            
        <Description>Part of Tries to improve the stability of the integration tests.</Description>
            
        <CreatedDate>03/07/2017</CreatedDate>
            
        <ClosedDate>04/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4901</PullRequestID>
                        
                <IssueID>4558</IssueID>
                        
                <Title>Permission APIs</Title>
                        
                <Description>Fixes This is a feature branch. The work will be split into smaller PR that will be merged into this branch incrementally. TODO Check changelog before final merge. Javadoc Timing issue for permission Realm not being ready Non public Permission Manager constructor apply Permissions method get Default Permissions method Remove FIXME   Deprecate Management Realm Remove task before calling success  in case it crashes Optional makeOffer method acceptOffer method revokeOffer method getOffers method</Description>
                         
                <CreatedDate>26/04/2017</CreatedDate>
                        
                <ClosedDate>01/09/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4889</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Last field might be a back link field.</Title>
            
        <Description>When querying a LinkingObjects field  aka backlink field it might be the last isEmpty is a pretty useful predicate, and we need to track down the source table. The changes to the C code is only for code style consistency.Closes</Description>
            
        <CreatedDate>30/06/2017</CreatedDate>
            
        <ClosedDate>03/07/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4889</PullRequestID>
                        
                <IssueID>4864</IssueID>
                        
                <Title>Realm isEmpty for linked relationships causes SIGSEGV</Title>
                        
                <Code>
		Realm.init context ;
		RealmConfiguration realmConfiguration = new RealmConfiguration.Builder  
				.inMemory  
				.schemaVersion 2 
				.build  ;
		Realm realm = Realm.getInstance realmConfiguration ;

         public void execute Realm realm  {
            Dog dog = realm.createObject Dog.class, "dog" ;
            Person person = realm.createObject Person.class, "person" ;
            person.getDogs  .add dog ;
        }
		</Code>
                        
                <Description> Goal Query for empty inverse relationships: get all dogs without owners. Expected Results Query should return the dogs without owners. Actual Results SIGSEGV Version of Realm and tooling Realm versions Realm sync feature enabled no Android Studio version Which Android version and device: API24 Nexus 5X emulator API25 Pixel  emulator </Description>
                        
                <CreatedDate>27/06/2017</CreatedDate>
                        
                <ClosedDate>03/07/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4888</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixreferencetableoverflowwhenloggingfromthesyncthread</Title>
            
        <Description>I discovered this while debugging our unstable integration tests. I havent found a way to reproduce this in a unit test since it depends on the logging happening from a nonjava thread  like the Sync thread .</Description>
            
        <CreatedDate>30/06/2017</CreatedDate>
            
        <ClosedDate>30/06/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4888</PullRequestID>
                        
                <IssueID>9</IssueID>
                        
                <Title>Write JavaDocs for the public API classes</Title>
                        
                <Description>Write JavaDocs for the public API classes.</Description>
                        
                <CreatedDate>02/05/2012</CreatedDate>
                        
                <ClosedDate>20/11/2012</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4888</PullRequestID>
                        
                <IssueID>25</IssueID>
                        
                <Title>What was it with the JDK6 dependency? How can we also support JDK7?</Title>
                        
                <Description>What was it with the JDK6 dependency? How can we also support JDK7?</Description>
                        
                <CreatedDate>20/05/2012</CreatedDate>
                        
                <ClosedDate>06/06/2012</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>4882</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>SyncAddinguseraccountlookup</Title>
            
        <Description>fixes 4828</Description>
            
        <CreatedDate>29/06/2017</CreatedDate>
            
        <ClosedDate>30/06/2017</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>4882</PullRequestID>
                        
                <IssueID>4828</IssueID>
                        
                <Title>Expose User Lookup API</Title>
                        
                <Description> Goal Our users need a way to look up the random generated user IDs to connect those with their own user models of existing backends and can interact with userspecific Realms. We've an API which covers a minimum useful solution to achieve a user lookup. As this is subject to change, it would be desirable to wrap this API endpoint, so that our users can rely on a stable API and we can change the implementation details.  API Proposal Sync User Sync User retrieve User String provider String providerId  Retrieve another user by the provider identifier of one of their accounts. This is done synchronously and involves the network, so calling this method on the Android UI thread will always crash. This user needs admin privilege in order to retrieve another user Realm Async Task Sync User retrieve User Async String provider String providerId SyncUser Callback callback Retrieve another user asynchronously by the provider identifier of one of their accounts. This user needs admin privilege in order to retrieve another user. </Description>
                        
                <CreatedDate>22/06/2017</CreatedDate>
                        
                <ClosedDate>30/06/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2558</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Remove Realm get Table from public API</Title>
            
        <Description>Close</Description>
            
        <CreatedDate>06/04/2016</CreatedDate>
            
        <ClosedDate>07/04/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2558</PullRequestID>
                        
                <IssueID>2546</IssueID>
                        
                <Title>getTable deprecation warnings in generated classes</Title>
                        
                <Code>
public class Choice extends RealmObject {
    private int id;
    private String name;

    public Choice   {
        id = PrimaryKeyFactory.getInstance  .nextKey Choice.class ;
    }
    public Choice String name  {
        this  ;
        this.name = name;
    }
    public int getId   { return id; }
    public void setId int id  { this.id = id; }
    public String getName   { return name; }
    public void setName String name  { this.name = name; }
}
    public static Choice createOrUpdateUsingJsonObject Realm realm, JSONObject json, boolean update 
        throws JSONException {
        Choice obj = null;
        if  update  {
            Table table = realm.getTable Choice.class ; //First warning
            long pkColumnIndex = table.getPrimaryKey  ;
            if  !json.isNull "id"   {
                long rowIndex = table.findFirstLong pkColumnIndex, json.getLong "id"  ;
                if  rowIndex != TableOrView.NO_MATCH  {
                    obj = new ChoiceRealmProxy realm.schema.getColumnInfo Choice.class  ;
                      RealmObject  obj .realm = realm;
                      RealmObject  obj .row = table.getUncheckedRow rowIndex ;
                }
            }
        }
        if  obj == null  {
            if  json.has "id"   {
                if  json.isNull "id"   {
                    obj =  ChoiceRealmProxy  realm.createObject Choice.class, null ;
                } else {
                    obj =  ChoiceRealmProxy  realm.createObject Choice.class, json.getInt "id"  ;
                }
            } else {
                obj =  ChoiceRealmProxy  realm.createObject Choice.class ;
            }
        }
        if  json.has "id"   {
            if  json.isNull "id"   {
                throw new IllegalArgumentException "Trying to set nonnullable field id to null." ;
            } else {
                  ChoiceRealmProxyInterface  obj .realmSet$id  int  json.getInt "id"  ;
            }
        }
        if  json.has "name"   {
            if  json.isNull "name"   {
                  ChoiceRealmProxyInterface  obj .realmSet$name null ;
            } else {
                  ChoiceRealmProxyInterface  obj .realmSet$name  String  json.getString "name"  ;
            }
        }
        return obj;
    }

 public static Choice copyOrUpdate Realm realm, Choice object, boolean update, Map&lt;RealmObject,RealmObjectProxy&gt; cache  {
        if    RealmObject  object .realm != null &amp;&amp;   RealmObject  object .realm.getPath  .equals realm.getPath     {
            return object;
        }
        Choice realmObject = null;
        boolean canUpdate = update;
        if  canUpdate  {
            Table table = realm.getTable Choice.class ; //Second warning
            long pkColumnIndex = table.getPrimaryKey  ;
            long rowIndex = table.findFirstLong pkColumnIndex,   ChoiceRealmProxyInterface  object .realmGet$id   ;
            if  rowIndex != TableOrView.NO_MATCH  {
                realmObject = new ChoiceRealmProxy realm.schema.getColumnInfo Choice.class  ;
                  RealmObject  realmObject .realm = realm;
                  RealmObject  realmObject .row = table.getUncheckedRow rowIndex ;
                cache.put object,  RealmObjectProxy  realmObject ;
            } else {
                canUpdate = false;
            }
        }

        if  canUpdate  {
            return update realm, realmObject, object, cache ;
        } else {
            return copy realm, object, update, cache ;
        }
    }
</Code>
                        
                <Description>First I asked the question on SO   but it seems like noone else noticed the issue or it happens only in my case. GoalSuccessful build with no warnings. Expected ResultsNo warnings on compile build step. Actual ResultsWarning is also present when I do not use PrimaryKeyFactory. Version of Realm and toolingRealm version s : 88.2  and I guess that other new plugin versions too Android Studio version: 2.0 beta7/RC1Which Android version and device: minSdk 16, targetApi 23</Description>
                        
                <CreatedDate>02/04/2016</CreatedDate>
                        
                <ClosedDate>07/04/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2554</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>dalinaum</FixedByID>
            
        <Title>Custom equals to String and hash Code work correctly.</Title>
            
        <Description>To fix if there are some custom methods such as equals toString and hashCode do not create these methods in Realm Proxy Please review this realm java
</Description>
            
        <CreatedDate>05/04/2016</CreatedDate>
            
        <ClosedDate>06/04/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2554</PullRequestID>
                        
                <IssueID>2545</IssueID>
                        
                <Title>toString</Title>
                        
                <Description> Goaloverride toString Expected ResultstoString to return my custom string Actual Resultsmy custom method is not being called and the default realm toString implementation is shown Steps &amp; Code to Reproducecreate custom object, override toString Version of Realm and toolingRealm version s : 0.88.2Android Studio version: 1.5.1Which Android version and device: Icecream,  Samsung S3</Description>
                        
                <CreatedDate>02/04/2016</CreatedDate>
                        
                <ClosedDate>06/04/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2540</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>FixtransformerinlibprojectonWindows</Title>
            
        <Description>The separator in jar file might not be File.separatorChar
Fix 2484
</Description>
            
        <CreatedDate>01/04/2016</CreatedDate>
            
        <ClosedDate>05/04/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2540</PullRequestID>
                        
                <IssueID>2484</IssueID>
                        
                <Title>build execution fails on Windows after update to 88.2</Title>
                        
                <Description> GoalBuild the app successfully after update to 88.2 Expected ResultsI am able to build Actual </Description>
                        
                <CreatedDate>16/03/2016</CreatedDate>
                        
                <ClosedDate>06/04/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>ReproductionRequired</Label>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2493</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Results Objects are no longer accidentially GCed</Title>
            
        <Description>Fixes This change means that Realm Results and Realm Objects are now strongly referenced from their Observable.This was not the case previous which could cause a Realm Result to be prematurely GCed, causing the Observable to stop emitting. Users are now required to unsubscribe or terminate  success error  and Observable to free this reference. They needed to do that anyway to free the Realm instance.realm java</Description>
            
        <CreatedDate>17/03/2016</CreatedDate>
            
        <ClosedDate>31/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2493</PullRequestID>
                        
                <IssueID>2485</IssueID>
                        
                <Title>RealmResults::asObservable not always returns a value when subscription is not kept in memory</Title>
                        
                <Code/>
                		
                <stacktrace>
		java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@b297227 rejected from io.realm.internal.async.RealmThreadPoolExecutor@873a166Running, pool size = 5, active threads = 5, queued tasks = 100, completed tasks = 125
                                                                                             at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution ThreadPoolExecutor.java:2014 
                                                                                             at java.util.concurrent.ThreadPoolExecutor.reject ThreadPoolExecutor.java:794 
                                                                                             at java.util.concurrent.ThreadPoolExecutor.execute ThreadPoolExecutor.java:1340 
                                                                                             at java.util.concurrent.AbstractExecutorService.submit AbstractExecutorService.java:104 
                                                                                             at io.realm.internal.async.RealmThreadPoolExecutor.submit RealmThreadPoolExecutor.java:68 
                                                                                             at io.realm.RealmQuery.findAllAsync RealmQuery.java:1470 
                                                                                             at com.example.hasegawa.testfindallasync.MainActivity$onClick$1.call MainActivity.kt:90 
                                                                                             at com.example.hasegawa.testfindallasync.MainActivity$onClick$1.call MainActivity.kt:19 
                                                                                             at rx.Observable$29.onNext Observable.java:8031 
                                                                                             at rx.observers.SafeSubscriber.onNext SafeSubscriber.java:139 
                                                                                             at rx.internal.operators.OnSubscribeRange$RangeProducer.fastpath OnSubscribeRange.java:126 
                                                                                             at rx.internal.operators.OnSubscribeRange$RangeProducer.request OnSubscribeRange.java:63 
                                                                                             at rx.Subscriber.setProducer Subscriber.java:209 
                                                                                             at rx.Subscriber.setProducer Subscriber.java:205 
                                                                                             at rx.internal.operators.OnSubscribeRange.call OnSubscribeRange.java:38 
                                                                                             at rx.internal.operators.OnSubscribeRange.call OnSubscribeRange.java:26 
                                                                                             at rx.Observable.subscribe Observable.java:8191 
                                                                                             at rx.Observable.subscribe Observable.java:8158 
                                                                                             at rx.Observable.subscribe Observable.java:8017 
                                                                                             at com.example.hasegawa.testfindallasync.MainActivity.onClick MainActivity.kt:85 
                                                                                             at android.view.View.performClick View.java:5198 
                                                                                             at android.view.View$PerformClick.run View.java:21147 
                                                                                             at android.os.Handler.handleCallback Handler.java:739 
                                                                                             at android.os.Handler.dispatchMessage Handler.java:95 
                                                                                             at android.os.Looper.loop Looper.java:148 
                                                                                             at android.app.ActivityThread.main ActivityThread.java:5417 
                                                                                             at java.lang.reflect.Method.invoke Native Method 
                                                                                             at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run ZygoteInit.java:726 
                                                                                             at com.android.internal.os.ZygoteInit.main ZygoteInit.java:616 
		</stacktrace>
                        
                <Description> Goal What do you want to achieve Do a lot of simple realm queries with find All Async asObservable  and have them all return a value even without explicitly holding a reference to its subscription or add a note in the docs about the importance of always holding a reference to the subscriptions 		for the noobs like me Expected Results Whenever we create an observable with find All Async asObservable it would be nice to always get a RealmResults, even when we dont hold a reference to the subscription. 		Actual ResultsSome observables created with findAllAsync as Observable will never call the onNext of the subscription. Steps Code to ReproduceI created a small Android app showing the problem Im facing on a bigger application.The important code is on this line:In this test, one thousand Realm observables are created. Every time one observable is created, a counter gets incremented. For each of those observable 		one subscription is created  and may or may not be explicitly stored in memory. When this subscription returns any value, another counter is incremented. When the subscription is stored in memory then we get the expected behavior one thousand observables created and one thousand results. 		However, when we do not store the subscription in memory, the number of results may not be one thousand.This line determines if the subscription should be kept in memory or not, and it will change the behavior of the program:I also tried a flatMap approach in here:However, flatMap fails with 		Version of Realm and tooling Realm versions Android Studio version Preview Which Android version and device Nexus API emulator </Description>
                        
                <CreatedDate>16/03/2016</CreatedDate>
                        
                <ClosedDate>31/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2483</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Ignored field should not have accessor</Title>
            
        <Description>Fix </Description>
            
        <CreatedDate>16/03/2016</CreatedDate>
            
        <ClosedDate>17/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2483</PullRequestID>
                        
                <IssueID>2478</IssueID>
                        
                <Title>Ignore members of certain types in Realm Object produce errors</Title>
                        
                <Code> 
		private String token;
        private byte[] data;
        private long updated;

        @Ignore
        private jsonBuilder jbRoot;
		</Code>
                        
                <Description>Error reported on SO Consider the following code Thank you. The error above is not actually a blocker but Im just curious why that happens. But I like the changes. </Description>
                        
                <CreatedDate>16/03/2016</CreatedDate>
                        
                <ClosedDate>17/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST>f
	some|unknown|return|type,Cls0|Mth|Nm1,METHOD_NAME
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls0,string
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,token
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Prim0,byte
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,data
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|ArBr2,[]
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Prim0,long
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,updated
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls1,json|builder
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,jb|root
	some|unknown|return|type,Cls0|Mth|Bk|Ret|Nm0,no|such|return|value
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls0,string
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,token
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Prim0,byte
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,data
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|ArBr2,[]
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Prim0,long
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,updated
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls1,json|builder
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,jb|root
	METHOD_NAME,Nm1|Mth|Bk|Ret|Nm0,no|such|return|value
	string,Cls0|VDE|VD|VDID0,token
	string,Cls0|VDE|Ex|Bk|Ex|VDE|Prim0,byte
	string,Cls0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,data
	string,Cls0|VDE|Ex|Bk|Ex|VDE|ArBr2,[]
	string,Cls0|VDE|Ex|Bk|Ex|VDE|Prim0,long
	string,Cls0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,updated
	string,Cls0|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	string,Cls0|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	string,Cls0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	string,Cls0|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Prim0,byte
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,data
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|ArBr2,[]
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Prim0,long
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,updated
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	token,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	token,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	byte,Prim0|VDE|VD|VDID0,data
	byte,Prim0|VDE|ArBr2,[]
	byte,Prim0|VDE|Ex|Bk|Ex|VDE|Prim0,long
	byte,Prim0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,updated
	byte,Prim0|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	byte,Prim0|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	byte,Prim0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	byte,Prim0|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	data,VDID0|VD|VDE|ArBr2,[]
	data,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Prim0,long
	data,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,updated
	data,VDID0|VD|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	data,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	data,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	data,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	[],ArBr2|VDE|Ex|Bk|Ex|VDE|Prim0,long
	[],ArBr2|VDE|Ex|Bk|Ex|VDE|VD|VDID0,updated
	[],ArBr2|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	[],ArBr2|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	[],ArBr2|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	[],ArBr2|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	long,Prim0|VDE|VD|VDID0,updated
	long,Prim0|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	long,Prim0|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	long,Prim0|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	long,Prim0|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	updated,VDID0|VD|VDE|Ex|Bk|Ex|VDE|MarkerExpr|Nm0,ignore
	updated,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls1,json|builder
	updated,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,jb|root
	updated,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	ignore,Nm0|MarkerExpr|VDE|Cls1,json|builder
	ignore,Nm0|MarkerExpr|VDE|VD|VDID0,jb|root
	ignore,Nm0|MarkerExpr|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	json|builder,Cls1|VDE|VD|VDID0,jb|root
	json|builder,Cls1|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	jb|root,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2480</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Thread check for copy To Realm copy To Realm Or Update</Title>
            
        <Description>Might be the reason of</Description>
            
        <CreatedDate>16/03/2016</CreatedDate>
            
        <ClosedDate>17/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2480</PullRequestID>
                        
                <IssueID>2462</IssueID>
                        
                <Title>Unrecoverable error Wrong transactional state</Title>
                        
                <Description> i have the following  error apears some times in the log Version of Realm and toolingRealm version</Description>
                        
                <CreatedDate>15/03/2016</CreatedDate>
                        
                <ClosedDate>29/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2450</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix Bad Version Exception</Title>
            
        <Description>Fixes This replaces Please review this throughly realm java Copy paste from nhachicha I updated the PR. We didn't properly handle Bad Version Exception in our find All Async methods from what I could tell. In a lot of cases we treated that exception as fatal  even though a retry was imminent . I think I fixed it, but still trying to wrap my head around testing it in a sane way. So far I have done manual testing but stubbing out values. Please review especially around retrying and batch updates. </Description>
            
        <CreatedDate>14/03/2016</CreatedDate>
            
        <ClosedDate>15/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2450</PullRequestID>
                        
                <IssueID>2417</IssueID>
                        
                <Title>std exception in io realm internal Table Query cpp line when calling Realm Results load with multiple Realm instances</Title>
                        
                <Code> 
		val realm = Realm.getInstance realmConfiguration 
		realm.executeTransactionAsync {
			it.deleteAll  
		}
		</Code>
                        
                <Description> Steps to reproduce Obtain an instance of Realm Execute an async transaction on it Obtain a second instance of Realm with same configuration and on the same thread  it will return the same instance as the first Realm  Execute an async query Call load   to synchronously wait for the query to execute  IssueThe load   method throws a native exception: std::exception in io_realm_internal_TableQuery.cpp line 1682. this exception is swallowed on the Java side, but I managed to debug it and I discovered it's actually a BadVersionException.After some investigation I think the issue is in the invocation of Realm.getInstance   after submitting the first transaction. If that happens before  or if I reuse the same Realm variable  everything works correctly.I already discussed with @cmelchior on Slack about the issue. Code Sample in Kotlin :stuck_out_tongue:   Version of Realm and toolingRealm version s : 0.88.0Android Studio version: 2.0Which Android version and device: Emulator with 6.0</Description>
                        
                <CreatedDate>10/03/2016</CreatedDate>
                        
                <ClosedDate>15/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2450</PullRequestID>
                        
                <IssueID>2391</IssueID>
                        
                <Title>Bad Version exception. Please stop send error to internal handler. </Title>
                        
                <Description>Bad version exception still happens and you seem dont have solution about this. It happens in find All Async or find All Sorted Async. So I do try catch to all usage of the methods. But bad version exception fires again and kill app cause the methods dont 		allow send exception to us, just kill app why We release our app with realm recently and bad version exception is most number of crash ever every ever.We have more than million users in our app 		and it is now giving users very bad experience I think you should fix it or for temporal solution do not just throw exception in your sdk to kill app If you cant we have to change DB to another 		But I dont want it and I think you too One more it is very bad exception and we get some upset about you havent solved this bug even though this issue happened at Dec 		Please look at this issue seriously.</Description>
                        
                <CreatedDate>05/03/2016</CreatedDate>
                        
                <ClosedDate>15/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2450</PullRequestID>
                        
                <IssueID>2021</IssueID>
                        
                <Title>BadVersionException</Title>
                        
                <Description>
          Hey guys. I keep getting this exception. I am using version of Realm and I use Realm as a singleton.  		My situation looks like this there is navigation button which starts a fragment 		which makes an async query for objects in on Start method. 		This exception rises when user spams this navigation button or just makes fast transactions between fragments java lang Error 		io realm internal async Bad Version Exception std  xception in io realm internal TableQuery.cpp
        </Description>
                         
                <CreatedDate>03/01/2016</CreatedDate>
                        
                <ClosedDate>19/05/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2445</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>is Primary Key on Realm Object Schema</Title>
            
        <Description> Add Realm Object Schema isPrimaryKey Realm Object Schema get Primary Key is not added since it doesn't seem to be necessary. isNullable isRequired didnt throw which is wrong.
 Add throws doc to hasIndex. Close
</Description>
            
        <CreatedDate>14/03/2016</CreatedDate>
            
        <ClosedDate>15/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2445</PullRequestID>
                        
                <IssueID>2440</IssueID>
                        
                <Title>Add is Primary Key and get Primary Key to Realm Object Schema</Title>
                        
                <Description>We used to have Table.getPrimaryKey to return the PK row. But this cannot be achieved by the new Dynamic API anymore.Propose to add two more methods to RealmObjectSchema void RealmObjectSchema.isPrimaryKey String fieldName  String RealmObjectSchema.getPrimaryKey  Requested from SO </Description>
                        
                <CreatedDate>14/03/2016</CreatedDate>
                        
                <ClosedDate>15/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2444</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Merge remote tracking branch origin releases into mcmerge</Title>
            
        <Description>Fixes 
</Description>
            
        <CreatedDate>14/03/2016</CreatedDate>
            
        <ClosedDate>14/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2444</PullRequestID>
                        
                <IssueID>2439</IssueID>
                        
                <Title>Dynamic RealmObject toString does not honor null values</Title>
                        
                <Code>
		public class Nullables extends RealmObject {
			private String str;
			private Boolean bool;
			private Integer num;
			private Date time;
			private byte bytes;
		}
			try {
				final Nullables nullables = new Nullables  ;
				realm.executeTransaction new Realm.Transaction   {
					@Override
					public void execute Realm realm  {
						realm.deleteAll  ;
						realm.copyToRealm nullables ;
					}
				} ;
			} finally {
				realm.close  ;
			}

			final DynamicRealm dynamicRealmBefore = DynamicRealm.getInstance new RealmConfiguration.Builder this .build   ;
			try {
				System.out.println dynamicRealmBefore.allObjects "Nullables" .first  .toString   ;
			} finally {
				dynamicRealmBefore.close  ;
			}
		</Code>
                        
                <Description> Goal DynamicRealmObject.toString   shows null value as "null". Remove "class_" prefix from type name in that String. Align the format to the String from typed RealmObject. Expected Results Version of Realm and toolingRealm version s : 0.88.0Android Studio version: 2.1 Preview1Which Android version and device: N preview1</Description>
                        
                <CreatedDate>14/03/2016</CreatedDate>
                        
                <ClosedDate>14/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2443</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>emanuelez</FixedByID>
            
        <Title>UsealocalcopyofReLinker</Title>
            
        <Description>The problem is that libraries that use Realm were forced to tell users to add the jitpack repo manually, which is inconvenient. Fixes  
</Description>
            
        <CreatedDate>14/03/2016</CreatedDate>
            
        <ClosedDate>14/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2443</PullRequestID>
                        
                <IssueID>2415</IssueID>
                        
                <Title>Gradle Cannot find Relinker</Title>
                        
                <Description>Hi I am getting error when i try to use instead of Error Failed to resolve com github Keep Safe Re Linker</Description>
                        
                <CreatedDate>10/03/2016</CreatedDate>
                        
                <ClosedDate>14/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2441</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>FixtheStringfromDynamicRealmObject.toString.</Title>
            
        <Description>Now Dynamic Realm Object toString shows null value as null class prefix is removed from type name in that String. Align the format to the String from typed Realm Object. This fixes  please review this realm java 
    </Description>
            
        <CreatedDate>14/03/2016</CreatedDate>
            
        <ClosedDate>14/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2441</PullRequestID>
                        
                <IssueID>2439</IssueID>
                        
                <Title>Dynamic Realm Object toString does not honor null values</Title>
                        
                <Code>
			public class Nullables extends RealmObject {

				private String str;
				private Boolean bool;
				private Integer num;
				private Date time;
				private byte bytes;

				// getters and setters
			}

			Realm realm = Realm.getInstance new RealmConfiguration.Builder this .deleteRealmIfMigrationNeeded  .build   ;
			try {
				final Nullables nullables = new Nullables  ;
				realm.executeTransaction new Realm.Transaction   {
					@Override
					public void execute Realm realm  {
						realm.deleteAll  ;
						realm.copyToRealm nullables ;
					}
				} ;
			} finally {
				realm.close  ;
			}
		</Code>
                        
                <Description> Goal Dynamic Realm Object toString shows null value as null. Remove class prefix from type name in that String. Align the format to the String from typed Realm Object. Expected Results Version of Realm and tooling Realm version 0Android Studio version Preview Which Android version and device preview1</Description>
                        
                <CreatedDate>14/03/2016</CreatedDate>
                        
                <ClosedDate>14/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2435</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Merge remote tracking branch origin releases into</Title>
            
        <Description>Fixes 2432 
</Description>
            
        <CreatedDate>12/03/2016</CreatedDate>
            
        <ClosedDate>13/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2435</PullRequestID>
                        
                <IssueID>2432</IssueID>
                        
                <Title>Add DT SONAME header to shared library</Title>
                        
                <Description>reported by takke in twitter Realm shared libraries do not have DT SONAME header in it.current:</Description>
                        
                <CreatedDate>12/03/2016</CreatedDate>
                        
                <ClosedDate>13/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2433</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>add SONAME header to shared libraries</Title>
            
        <Description>Fixes Please review this realm java </Description>
            
        <CreatedDate>12/03/2016</CreatedDate>
            
        <ClosedDate>12/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2433</PullRequestID>
                        
                <IssueID>2432</IssueID>
                        
                <Title>Add DT SONAME header to shared library</Title>
                        
                <Description>reported by takke in twitter Realms shared libraries do not have DT SONAME header in it.current:</Description>
                        
                <CreatedDate>12/03/2016</CreatedDate>
                        
                <ClosedDate>13/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2427</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Merge remote tracking branch origin releases into</Title>
            
        <Description>Fix 
</Description>
            
        <CreatedDate>11/03/2016</CreatedDate>
            
        <ClosedDate>13/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2427</PullRequestID>
                        
                <IssueID>2413</IssueID>
                        
                <Title>fails to build model classes which use the thirdparty annotation conflicts with Jackson annotation processing </Title>
                		
                <stacktrace>
		 Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:transformClassesWithRealmTransformerForDevDebug'.
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions ExecuteActionsTaskExecuter.java:69 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute ExecuteActionsTaskExecuter.java:46 
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute PostExecutionAnalysisTaskExecuter.java:35 
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute SkipUpToDateTaskExecuter.java:64 
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute ValidatingTaskExecuter.java:58 
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute SkipEmptySourceFilesTaskExecuter.java:52 
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute SkipTaskWithNoActionsExecuter.java:52 
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute SkipOnlyIfTaskExecuter.java:53 
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute ExecuteAtMostOnceTaskExecuter.java:43 
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute DefaultTaskGraphExecuter.java:203 
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute DefaultTaskGraphExecuter.java:185 
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask AbstractTaskPlanExecutor.java:66 
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run AbstractTaskPlanExecutor.java:50 
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute ExecutorPolicy.java:54 
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run StoppableExecutorImpl.java:40 
Caused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: com.fasterxml.jackson.annotation.JsonFormat
    at com.android.builder.profile.Recorder$Block.handleException Recorder.java:54 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:57 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:47 
    at com.android.build.gradle.internal.pipeline.TransformTask.transform TransformTask.java:173 
    at org.gradle.internal.reflect.JavaMethod.invoke JavaMethod.java:75 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute AnnotationProcessingTaskFactory.java:244 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute AnnotationProcessingTaskFactory.java:220 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute AnnotationProcessingTaskFactory.java:231 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute AnnotationProcessingTaskFactory.java:209 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction ExecuteActionsTaskExecuter.java:80 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions ExecuteActionsTaskExecuter.java:61 
    ... 14 more
Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.annotation.JsonFormat
    at javassist.CtClassType.toAnnoType CtClassType.java:696 
    at javassist.CtClassType.toAnnotationType CtClassType.java:586 
    at javassist.CtField.getAnnotations CtField.java:317 
    at javassist.CtField.getAnnotations CtField.java:290 
    at javassist.CtField$getAnnotations.call Unknown Source 
    at io.realm.transformer.RealmTransformer$_transform_closure9$_closure16.doCall RealmTransformer.groovy:115 
    at io.realm.transformer.RealmTransformer$_transform_closure9.doCall RealmTransformer.groovy:114 
    at io.realm.transformer.RealmTransformer.transform RealmTransformer.groovy:113 
    at com.android.build.api.transform.Transform.transform Transform.java:308 
    at com.android.build.gradle.internal.pipeline.TransformTask$3.call TransformTask.java:178 
    at com.android.build.gradle.internal.pipeline.TransformTask$3.call TransformTask.java:174 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:55 
    ... 23 more

		</stacktrace>
                        
                <Code>
 @PrimaryKey
    private int id;
    @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd'T'HH:mm:ss'Z'", timezone="UTC")
    private Date date;
</Code>
                        
                <Description>Goal I use bunch of different libraries, including Realm and Jackson. Expected Results Project builds with Jackson annotations. Actual Results Version of Realm and toolingRealm version Android Studio version</Description>
                        
                <CreatedDate>10/03/2016</CreatedDate>
                        
                <ClosedDate>13/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST>f
	some|unknown|return|type,Cls0|Mth|Nm1,METHOD_NAME
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,primary|key
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Prim1,int
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,id
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Nm0,json|format
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls1,date
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,date
	some|unknown|return|type,Cls0|Mth|Bk|Ret|Nm0,no|such|return|value
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,primary|key
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Prim1,int
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,id
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Nm0,json|format
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls1,date
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,date
	METHOD_NAME,Nm1|Mth|Bk|Ret|Nm0,no|such|return|value
	primary|key,Nm0|MarkerExpr|VDE|Prim1,int
	primary|key,Nm0|MarkerExpr|VDE|VD|VDID0,id
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|Cls1,date
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	int,Prim1|VDE|VD|VDID0,id
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	int,Prim1|VDE|Ex|Bk|Ex|VDE|Cls1,date
	int,Prim1|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	int,Prim1|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls1,date
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	id,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	json|format,Nm0|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	json|format,Nm0|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	json|format,Nm0|NormEx|Mvp|Fld0|Nm2,string
	json|format,Nm0|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	json|format,Nm0|NormEx|Mvp|StrEx0,utc
	json|format,Nm0|NormEx|VDE|Cls1,date
	json|format,Nm0|NormEx|VDE|VD|VDID0,date
	json|format,Nm0|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	json|format,Nm0|Fld0|Nm2,shape
	json|format,Nm0|Fld0|Fld|Nm2,string
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|Cls1,date
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	shape,Nm2|Fld0|Fld|Nm2,string
	shape,Nm2|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	shape,Nm2|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|Cls1,date
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	string,Nm2|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	string,Nm2|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	string,Nm2|Fld|Mvp|NormEx|VDE|Cls1,date
	string,Nm2|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	string,Nm2|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|Mvp|StrEx0,utc
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|Cls1,date
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|VD|VDID0,date
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	utc,StrEx0|Mvp|NormEx|VDE|Cls1,date
	utc,StrEx0|Mvp|NormEx|VDE|VD|VDID0,date
	utc,StrEx0|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	date,Cls1|VDE|VD|VDID0,date
	date,Cls1|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	date,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2425</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Merge remote tracking branch origin releases into mcmerge</Title>
            
        <Description>This fixes </Description>
            
        <CreatedDate>11/03/2016</CreatedDate>
            
        <ClosedDate>11/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2425</PullRequestID>
                        
                <IssueID>2420</IssueID>
                        
                <Title>Realm Configuration hashCode should take into account rxObservableFactory</Title>
                        
                <CreatedDate>11/03/2016</CreatedDate>
                        
                <ClosedDate>11/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2424</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Useless line triggers bugs</Title>
            
        <Description>get Annotations will return all Annotation classes if the class doesnt exist in the transformer project, exception will be thrown.</Description>
            
        <CreatedDate>11/03/2016</CreatedDate>
            
        <ClosedDate>11/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2424</PullRequestID>
                        
                <IssueID>2413</IssueID>
                        
                <Title>fails to build model classes which use the third party annotation conflicts with Jackson annotation processing </Title>
                		
                <stacktrace>
		org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:transformClassesWithRealmTransformerForDevDebug'.
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions ExecuteActionsTaskExecuter.java:69 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute ExecuteActionsTaskExecuter.java:46 
    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute PostExecutionAnalysisTaskExecuter.java:35 
    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute SkipUpToDateTaskExecuter.java:64 
    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute ValidatingTaskExecuter.java:58 
    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute SkipEmptySourceFilesTaskExecuter.java:52 
    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute SkipTaskWithNoActionsExecuter.java:52 
    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute SkipOnlyIfTaskExecuter.java:53 
    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute ExecuteAtMostOnceTaskExecuter.java:43 
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute DefaultTaskGraphExecuter.java:203 
    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute DefaultTaskGraphExecuter.java:185 
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask AbstractTaskPlanExecutor.java:66 
    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run AbstractTaskPlanExecutor.java:50 
    at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute ExecutorPolicy.java:54 
    at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run StoppableExecutorImpl.java:40 
Caused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: com.fasterxml.jackson.annotation.JsonFormat
    at com.android.builder.profile.Recorder$Block.handleException Recorder.java:54 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:57 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:47 
    at com.android.build.gradle.internal.pipeline.TransformTask.transform TransformTask.java:173 
    at org.gradle.internal.reflect.JavaMethod.invoke JavaMethod.java:75 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute AnnotationProcessingTaskFactory.java:244 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute AnnotationProcessingTaskFactory.java:220 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute AnnotationProcessingTaskFactory.java:231 
    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute AnnotationProcessingTaskFactory.java:209 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction ExecuteActionsTaskExecuter.java:80 
    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions ExecuteActionsTaskExecuter.java:61 
    ... 14 more
Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.annotation.JsonFormat
    at javassist.CtClassType.toAnnoType CtClassType.java:696 
    at javassist.CtClassType.toAnnotationType CtClassType.java:586 
    at javassist.CtField.getAnnotations CtField.java:317 
    at javassist.CtField.getAnnotations CtField.java:290 
    at javassist.CtField$getAnnotations.call Unknown Source 
    at io.realm.transformer.RealmTransformer$_transform_closure9$_closure16.doCall RealmTransformer.groovy:115 
    at io.realm.transformer.RealmTransformer$_transform_closure9.doCall RealmTransformer.groovy:114 
    at io.realm.transformer.RealmTransformer.transform RealmTransformer.groovy:113 
    at com.android.build.api.transform.Transform.transform Transform.java:308 
    at com.android.build.gradle.internal.pipeline.TransformTask$3.call TransformTask.java:178 
    at com.android.build.gradle.internal.pipeline.TransformTask$3.call TransformTask.java:174 
    at com.android.builder.profile.ThreadRecorder$1.record ThreadRecorder.java:55 
    ... 23 more

		</stacktrace>
                        
                <Code> 
		 @PrimaryKey
    private int id;
    @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd'T'HH:mm:ss'Z'", timezone="UTC")
    private Date date;
		</Code>
                        
                <Description> Goal I use bunch of different libraries including Realm and Jackson. Expected Results Project builds with Jackson annotations. Actual Results Version of Realm and toolingRealm version Android Studio version Gradle Works on</Description>
                        
                <CreatedDate>10/03/2016</CreatedDate>
                        
                <ClosedDate>13/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST>f
	some|unknown|return|type,Cls0|Mth|Nm1,METHOD_NAME
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,primary|key
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Prim1,int
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,id
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Nm0,json|format
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|Cls1,date
	some|unknown|return|type,Cls0|Mth|Bk|Ex|VDE|VD|VDID0,date
	some|unknown|return|type,Cls0|Mth|Bk|Ret|Nm0,no|such|return|value
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|MarkerExpr|Nm0,primary|key
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Prim1,int
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,id
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Nm0,json|format
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|Cls1,date
	METHOD_NAME,Nm1|Mth|Bk|Ex|VDE|VD|VDID0,date
	METHOD_NAME,Nm1|Mth|Bk|Ret|Nm0,no|such|return|value
	primary|key,Nm0|MarkerExpr|VDE|Prim1,int
	primary|key,Nm0|MarkerExpr|VDE|VD|VDID0,id
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|Cls1,date
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	primary|key,Nm0|MarkerExpr|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	int,Prim1|VDE|VD|VDID0,id
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	int,Prim1|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	int,Prim1|VDE|Ex|Bk|Ex|VDE|Cls1,date
	int,Prim1|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	int,Prim1|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Nm0,json|format
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|Fld0|Nm2,string
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|NormEx|Mvp|StrEx0,utc
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|Cls1,date
	id,VDID0|VD|VDE|Ex|Bk|Ex|VDE|VD|VDID0,date
	id,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	json|format,Nm0|NormEx|Mvp|Fld0|Fld0|Nm0,json|format
	json|format,Nm0|NormEx|Mvp|Fld0|Fld0|Nm2,shape
	json|format,Nm0|NormEx|Mvp|Fld0|Nm2,string
	json|format,Nm0|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	json|format,Nm0|NormEx|Mvp|StrEx0,utc
	json|format,Nm0|NormEx|VDE|Cls1,date
	json|format,Nm0|NormEx|VDE|VD|VDID0,date
	json|format,Nm0|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	json|format,Nm0|Fld0|Nm2,shape
	json|format,Nm0|Fld0|Fld|Nm2,string
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|Cls1,date
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	json|format,Nm0|Fld0|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	shape,Nm2|Fld0|Fld|Nm2,string
	shape,Nm2|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	shape,Nm2|Fld0|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|Cls1,date
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	shape,Nm2|Fld0|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	string,Nm2|Fld|Mvp|NormEx|Mvp|StrEx0,yyyymmddthhmmssz
	string,Nm2|Fld|Mvp|NormEx|Mvp|StrEx0,utc
	string,Nm2|Fld|Mvp|NormEx|VDE|Cls1,date
	string,Nm2|Fld|Mvp|NormEx|VDE|VD|VDID0,date
	string,Nm2|Fld|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|Mvp|StrEx0,utc
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|Cls1,date
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|VD|VDID0,date
	yyyymmddthhmmssz,StrEx0|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	utc,StrEx0|Mvp|NormEx|VDE|Cls1,date
	utc,StrEx0|Mvp|NormEx|VDE|VD|VDID0,date
	utc,StrEx0|Mvp|NormEx|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	date,Cls1|VDE|VD|VDID0,date
	date,Cls1|VDE|Ex|Bk|Ret|Nm0,no|such|return|value
	date,VDID0|VD|VDE|Ex|Bk|Ret|Nm0,no|such|return|value</AST>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2421</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Reflect hashcode of rxObservable Factory in Realm Configuration hashCode.</Title>
            
        <Description>This fixes please review this realm java </Description>
            
        <CreatedDate>11/03/2016</CreatedDate>
            
        <ClosedDate>11/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                 
        
                <PullRequestID>2421</PullRequestID>
                        
                <IssueID>2420</IssueID>
                        
                <Title>Realm Configuration hashCode should take into account rxObservableFactory</Title>
                        
                <CreatedDate>11/03/2016</CreatedDate>
                        
                <ClosedDate>11/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2419</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Fix NPE in Realm Configuration equals when RxJava is unavailable.</Title>
            
        <Description>This PR fixes please review this realm java </Description>
            
        <CreatedDate>11/03/2016</CreatedDate>
            
        <ClosedDate>11/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBugCrash</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2419</PullRequestID>
                        
                <IssueID>2416</IssueID>
                        
                <Title>Realm get Instance Realm Configuration error</Title>
                        
                <Description>Hi Ive updated Realm from to and I am getting a Null Pointer Exception error when I try to open a new instance without close the previous opened instance. 		I have an Activity that I open a Realm instance on onCreate and I close it on on Destroy but I have to start an Intent Service and when this Intent Service open an another Realm instance 		I get a Null Pointer Exception If I close the realm of Activity before on Destroy nothing happens I am getting a Null Pointer Exception when I open Realm getInstance config 		twice without close the first one. If I close the first instance, it is ok.</Description>
                        
                <CreatedDate>10/03/2016</CreatedDate>
                        
                <ClosedDate>11/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2407</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Fixthe cast in proxy generator forCacheData</Title>
            
        <Description>Close</Description>
            
        <CreatedDate>10/03/2016</CreatedDate>
            
        <ClosedDate>10/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2407</PullRequestID>
                        
                <IssueID>2354</IssueID>
                        
                <Title>Generated RealmProxy classes cause unchecked warnings</Title>
                        
                <Code/>
                        
                <Description>Im working on a project using Realm which used the following in the project wide build gradle I believe this may be fixed by including the type parameter in thegenerated cast statement  but I'm not certain.</Description>
                        
                <CreatedDate>26/02/2016</CreatedDate>
                        
                <ClosedDate>10/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2395</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Addedmissingchangelogupdate.</Title>
            
        <Description>Missing change log update for realm javagrahamsmith 
</Description>
            
        <CreatedDate>07/03/2016</CreatedDate>
            
        <ClosedDate>08/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2395</PullRequestID>
                        
                <IssueID>2240</IssueID>
                        
                <Title>Notify listeners of async Realm Object even if the result is empty</Title>
                        
                <Description>Fixes 2218 2200</Description>
                        
                <CreatedDate>05/02/2016</CreatedDate>
                        
                <ClosedDate>08/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2390</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>More checkings when modify RealmList</Title>
            
        <Description>Fix New method Link View get Target Table. Proper checking to add Dynamic Realm Object to RealmList. Disallow modifying with RealmObject belongs to another Realm instance.</Description>
            
        <CreatedDate>04/03/2016</CreatedDate>
            
        <ClosedDate>09/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2390</PullRequestID>
                        
                <IssueID>2381</IssueID>
                        
                <Title>Missing checking when call Realm List add set with Dynamic Object</Title>
                        
                <Code>
		public void getList_addWrongTypeTo   {
			DynamicRealm dynamicRealm = DynamicRealm.getInstance realm.configuration ;
			dynamicRealm.beginTransaction  ;

			DynamicRealmObject allTypes = dynamicRealm.createObject AllTypes.CLASS_NAME ;
			allTypes.setString AllTypes.FIELD_STRING, "bender" ;

			DynamicRealmObject cat = dynamicRealm.createObject Cat.CLASS_NAME ;
			cat.setString "name", "nibbler" ;

			RealmList&lt;DynamicRealmObject&gt; list = allTypes.getList AllTypes.FIELD_REALMLIST ;
			list.add cat ;
			thrown.expect IllegalArgumentException.class ;

			dynamicRealm.commitTransaction  ;
		}
	</Code>
                        
                <Description>The below test should pass as well as other RealmList methods add int location object set int location object </Description>
                        
                <CreatedDate>03/03/2016</CreatedDate>
                        
                <ClosedDate>09/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2386</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>stk1m1</FixedByID>
            
        <Title>Implementation of wait for change method.</Title>
            
        <Description>Continuation from Goal Add Realm.waitForChange   which blocks until a change is available, then advance the Realm and continue without triggering Realm Change Listeners. Expose Shared Group wait for change  . We should probably be careful with exactly how a thread is blocked using this method. What is done Reverted Base Realm refresh Commits on after is blown Deprecated Base Realm refresh Base Realm wait For Change  Base Realm stop Wait For Change  Behaviors Base Realm wait For Change will throw Illegal State Exception within a transaction.Base Realm cannot wait in a thread with Looper. Illegal State Exception will be thrown. Shared Group enable Wait For Change true  will be called everytime Base Realm wait For Change is called that users dont need to doubly make sure wait For Change is enabled.When change happens Realm advances for read and does not notify change listeners Base Realm stop Wait For Change from a thread different from the one who created can stop a Base Realm from waiting immediately. Test  </Description>
            
        <CreatedDate>03/03/2016</CreatedDate>
            
        <ClosedDate>03/05/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2386</PullRequestID>
                        
                <IssueID>2319</IssueID>
                        
                <Title>Nh refresh send realmchanged</Title>
                        
                <Description>This PR is the continuation of the wok done in delay notification This will make refresh send a REALM CHANGE instead of advancing the Realm. This adds more consistency and make it more easy to reason about async queries update as now all the changes are processed via the Looper Note the behaviour of refresh is unchanged for non Looper thread</Description>
                        
                <CreatedDate>23/02/2016</CreatedDate>
                        
                <ClosedDate>09/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2386</PullRequestID>
                        
                <IssueID>1300</IssueID>
                        
                <Title>Multiprocess support</Title>
                        
                <Description>This PR will test the possibility of current status of multi process first. Then maybe add more features to make multi process work better.Fixes 1091  Core bug  needs to be fixed  Permission control  Compact Realm when there is an opened Realm in other process  Delete  Share Realm in the app directory with another apk  Example two processes in one apk  Example two processes in two apks  Consider the following implementation with fine grained notification.  Blog post.  Decouple Android only logic from BaseRealm  Optional    Handle schema changes</Description>
                        
                <CreatedDate>17/07/2015</CreatedDate>
                        
                <ClosedDate>26/10/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2386</PullRequestID>
                        
                <IssueID>2319</IssueID>
                        
                <Title>Nh refresh send realmchanged</Title>
                        
                <Description>This PR is the continuation of the wok done in delay notification This will make refresh send a REALM CHANGE instead of advancing the Realm. This adds more consistency and make it more easy to reason about async queries update as now all the changes are processed via the Looper Note the behaviour of refresh is unchanged for nonLooper thread</Description>
                        
                <CreatedDate>23/02/2016</CreatedDate>
                        
                <ClosedDate>09/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2380</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Correct checking in Dynamic Realm Object set List</Title>
            
        <Description>Fix 2368
</Description>
            
        <CreatedDate>03/03/2016</CreatedDate>
            
        <ClosedDate>04/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2380</PullRequestID>
                        
                <IssueID>2368</IssueID>
                        
                <Title>Dynamic Realm Object cant set the list field</Title>
                        
                <Description>
          I have Dynamic Realm Object instance that has list field that is connected to some scheme but when I use Dynamic Realm Object set List I have an exception that says that list items should be the same type as original object is java lang Illegal Argument Exception Element at index is not the proper type. Was class test Inner With List details expected class test Inner With List io realm Dynamic Realm Object set List Dynamic RealmObject
        </Description>
                  
                <CreatedDate>01/03/2016</CreatedDate>
                        
                <ClosedDate>04/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2375</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Addissuetemplate</Title>
            
        <Description>Close 2371 
</Description>
            
        <CreatedDate>02/03/2016</CreatedDate>
            
        <ClosedDate>02/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2375</PullRequestID>
                        
                <IssueID>2371</IssueID>
                        
                <Title>Add template for issues</Title>
                        
                <Description>Add automatic template for new issues like in Cocoa but adjusted for the specific needs of realm Java </Description>
                        
                <CreatedDate>01/03/2016</CreatedDate>
                        
                <ClosedDate>02/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TInternal</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2364</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Observables no holds Realm instance reference</Title>
            
        <Description>Fixes Due to how RxJava executes the chain of Observables currently it isnt possible to use do On Unsubscribe to close Realm instances as the side effect is triggered before the Observable is truly unsubscribed to crashing our remove Change Listeners method.
This PR changes the current implementation so each Observable also holds onto a Realm instance prevent the Realm from being fully closed until the Observable is unsubscribed to. This means we can now guarantee that the Realm is alive for as long as the Observable is subscribed to. The only downside is that you risk leaking Realm instances if you forget to unsubscribe, but that would be a memory leak in any case.
</Description>
            
        <CreatedDate>29/02/2016</CreatedDate>
            
        <ClosedDate>07/03/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2364</PullRequestID>
                        
                <IssueID>2357</IssueID>
                        
                <Title>Realm RxJava asObservable and do On Unsubscribe </Title>
                        
                <Description>I posted a question on stackoverflow describing my issue. But long story short I cant find a clean way to close a realm instance when I unsubscribe from an Observable exposed through the Realm API. Because Realm Observable Factory get Realm Results Observable adds a Subscription to remove Change Listener 		I cant do something like this Something like Realm asObservable boolean close After Unsubscribe would be really helpful for me but someone else might have a good solution that does not involve changing the API.</Description>
                         
                <CreatedDate>27/02/2016</CreatedDate>
                        
                <ClosedDate>07/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2361</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Only load Realm Observable Factory when RxJava exist</Title>
            
        <Description>Close Check RxJava existence only once. Dont load Realm Observable Factory if RxJava doesnt exist. Correct exceptions in the java doc. NOTE When reflection called on the Realm Object Realm Results crash will still happen because of Observable doesn't exist in the class path. In such a case, a dummy rx Observable is still needed as a workaround. </Description>
            
        <CreatedDate>29/02/2016</CreatedDate>
            
        <ClosedDate>07/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2361</PullRequestID>
                        
                <IssueID>1990</IssueID>
                        
                <Title>Info message from art: Rejecting reinit</Title>
                        
                <Code>
       </Code>
                        
                <Description>Just as an information, when I start the app with the most current version of Realm I get the following log messages:We are currently not using the new rxfeature, but just wanted to see if this is something to be concerned about.The device was a Nexus 5 running Android 6.</Description>
                        
                <CreatedDate>22/12/2015</CreatedDate>
                        
                <ClosedDate>07/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2358</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Copy resource files when transforming bytecode.</Title>
            
        <Description>Realm Transformer must copy nonclass files to output dir since Kotlin compiler generates kotlin module file in METAINF This fixes </Description>
            
        <CreatedDate>27/02/2016</CreatedDate>
            
        <ClosedDate>09/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2358</PullRequestID>
                        
                <IssueID>2356</IssueID>
                        
                <Title>Kotlin Package level functions cannot be imported from library project with new gradle plugin</Title>
                        
                <Code> 
		public class LibraryModule {
		}

		public fun Realm.findSpot  : Dog {
			return where Dog::class.java .equalTo "name", "spot" .findFirst  
		}
		</Code>
                        
                <Description>This is a pretty elaborate case so hopefully I can explain it well enough.We have a project consisting of a main application and a library project. The library project contains Realm models that are shared. Using the new plugin on both the main application and the library project causes the main project to not see the package level functions in the library. 		I've attached a small sample project to show what I mean.Given this file in the library project I should be able to import findSpot in the main activity. </Description>
                        
                <CreatedDate>26/02/2016</CreatedDate>
                        
                <ClosedDate>09/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2355</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>removed runtime dependency from realm transformer to com android tools build transform</Title>
            
        <Description>We dont need to have runtime dependency to com android tools build transform api since android gradle plugin has that dependency. Removing this explicit dependency from realmtransformer solves the compatibility issue against android gradle plugin This fixes review this please realm java 
</Description>
            
        <CreatedDate>26/02/2016</CreatedDate>
            
        <ClosedDate>07/03/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TInternal</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2355</PullRequestID>
                        
                <IssueID>2348</IssueID>
                        
                <Title>SNAPSHOT Realm Transformer should support both and beta</Title>
                        
                <Description>Using latest snapshot i get following error during gradle sync Error Unable to load class io realm transformer Realm Transformer.</Description>
                        
                <CreatedDate>26/02/2016</CreatedDate>
                        
                <ClosedDate>07/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2345</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Collection API</Title>
            
        <Description>Fixes TODO Split existing unit tests so they work as parameterised tests. Implement new methods in Realm List. Implement new methods in Realm Results.   Determine exactly what should happen with remove clear for RealmResults. Core doesn't currently support mutating a TableView. Realm Results will have immutable behaviour until is fixed.   Ensure that everybody is onboard with the naming of interfaces. Should we shorten delete From Realm to just delete Realm clear Realm delete delete All Realm Object remove From Realm Realm Object delete From Realm    Change Base Realm Adapter to work with Realm Ordered Collection.Behavior changes first last now returns null instead of throwing an Exception if the collection is empty RealmList did that RealmResults threw an exception before .  remove remove All retain All clear now all throws an Unsupported Exception for Realm Results All methods have been replaced by delete instead. index Of no longer throws UnsupportedOperation on RealmResults.  sort have been added to RealmList and both now returns a sorted copy instead of sorting inplace Base Realm is now public Should it be renamed to something else Abstract RealmBaseRealm </Description>
            
	
        <code>
   public interface RealmCollection&lt;E extends RealmObject&gt; extends Collection {
    // Query methods
    RealmQuery&lt;E&gt; where  ;
    Number min String field ;
    Number max String field ;
    Number sum String field ;
    Number average String field ;
    Date maxDate String field ;
    Date minDate String field ;

    // Removal from the underlying realm. clear will not
    // do that anymore, only remove objects from the Collection.
    boolean deleteAllFromRealm  ;

    // Async methods   
    boolean isLoaded  ;
    boolean load  ;

    boolean isValid  ;
}

public interface OrderedRealmCollection&lt;E extends RealmObject&gt; extends List, RealmCollection {

    // Removal from the underlying realm. remove location  will not
    // do that anymore, only remove objects from the Collection.
    // delete methods returns a boolean where possible to mimic remove behaviour.
    void deleteFromRealm int location ;
    boolean deleteFirstFromRealm  ;
    boolean deleteLastFromRealm  ;

    E first  ;
    E last  ;

    // These have been changed from sortinplace to return a sorted copy. Only way to support      RealmList.sort   which isn't ready in core yet, but behaviour is also more flexible.
    RealmResults&lt;E&gt; sort String field ;
    RealmResults&lt;E&gt; sort String field, Sort sortOrder ;
    RealmResults&lt;E&gt; sort String field1, Sort sortOrder1, String field2, Sort sortOrder2 ;
    RealmResults&lt;E&gt; sort String fields, Sort sortOrders ;
}

public interface RealmUnorderedCollection extends Set, RealmCollection {
    // Not used right now, so don't implement right away.
}
   </code>
            
        <CreatedDate>25/02/2016</CreatedDate>
            
        <ClosedDate>01/04/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TFeature</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2345</PullRequestID>
                        
                <IssueID>1363</IssueID>
                        
                <Title>RealmCollection interface</Title>
                        
                <Description>We need a RealmCollection to be able to parse different lists into UI components.  Figure out exactly which methods should be in the interface   Make RealmResults and RealmList implement the interface  Document the interface on the website  2258 .v1 Needs to support RealmResults and RealmList /cc 972  v2 Support for RealmSet when it becomes available 759 v3 Support for RealmMap. Will most likely require its own interface. 759</Description>
                        
                <CreatedDate>06/08/2015</CreatedDate>
                        
                <ClosedDate>01/04/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2337</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>allow real man drow asa field name of model class. This fixes</Title>
            
        <Description>fixes review this please realm java</Description>
            
        <CreatedDate>25/02/2016</CreatedDate>
            
        <ClosedDate>26/02/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2337</PullRequestID>
                        
                <IssueID>2255</IssueID>
                        
                <Title>Naming restriction of attributes in RealmObjects</Title>
                        
                <Description>Goal create a Realm Object class with an attribute named realm. Expected results No compilation errorsActual results Error realm has private accessor compiler error 		due to internal realm io variable also called realm thus the whole proxy class is getting confused as to which realm to use for the proxy functions Steps to reproduce Create a class extending Realm Object 		add an attribute named realm compileRealm Version Well the problem is pretty obvious. The proxy class is extending the actual class tries to override the attribute named realm because apparently you use a variable called realm 	for the proxy implementation. The proxy class then finds that this variable has a private accessor and throws an exception. 		Either disallow attributes with the name realm  bad idea  or rename the internal attribute to proxyRealm or something like that.</Description>
                        
                <CreatedDate>10/02/2016</CreatedDate>
                        
                <ClosedDate>26/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2327</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>migrateRealmthrowswhendbdoesntexsit</Title>
            
        <Description>Close 2316 .
</Description>
            
        <CreatedDate>24/02/2016</CreatedDate>
            
        <ClosedDate>25/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2327</PullRequestID>
                        
                <IssueID>2316</IssueID>
                        
                <Title>Add a check if database file exists when Realm migrate Realm is called.</Title>
                        
                <Description>if Realm migrate Realm is called when Realm file does not exist, it may create wrong Realm file no schema contained or may cause the exception in Migration code.This issue is reported by @tiro105 on slack chat. Thanks!We have 2 choices in the case of missing Realm file. throw exception if Realm file does not exist create Realm file and execute normal initialization of schema instead of executing migrationWhat do you think? @realm/java </Description>
                        
                <CreatedDate>23/02/2016</CreatedDate>
                        
                <ClosedDate>25/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2320</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Fix unit test example mocks</Title>
            
        <Description>Also we need to enable gradlew check on CI.
</Description>
            
        <CreatedDate>23/02/2016</CreatedDate>
            
        <ClosedDate>29/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2320</PullRequestID>
                        
                <IssueID>2303</IssueID>
                        
                <Title>gradlew test is not running on CI and mockito cannot mock final Realm class</Title>
                        
                <Description>Two issues gradlew test will fail unit Test Example because of will fail. Realm is an static class which cannot be mocked by Mockito. We might have to use PowerMock instead Enable gradlew test on CI.</Description>
                        
                <CreatedDate>19/02/2016</CreatedDate>
                        
                <ClosedDate>16/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2310</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>stk1m1</FixedByID>
            
        <Title>Fixing crash related to duplicate primary key error</Title>
            
        <Description>Fix </Description>
            
        <CreatedDate>22/02/2016</CreatedDate>
            
        <ClosedDate>25/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBugCrash</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2310</PullRequestID>
                        
                <IssueID>2276</IssueID>
                        
                <Title>realm create Or Update Object From Json duplicate primary key fatal error</Title>
                		
                <stacktrace>
		io.realm.exceptions.RealmPrimaryKeyConstraintException: Value already exists: 
    at io.realm.internal.Table.throwDuplicatePrimaryKeyException Table.java:636 
    at io.realm.internal.Table.addEmptyRow Table.java:360 
    at io.realm.Realm.createObject Realm.java:661 
    at io.realm.OrderRealmProxy.createOrUpdateUsingJsonObject OrderRealmProxy.java:741 
    at io.realm.DefaultRealmModuleMediator.createOrUpdateUsingJsonObject DefaultRealmModuleMediator.java:210 
    at io.realm.Realm.createOrUpdateObjectFromJson Realm.java:506 
    at myapp.model.Order.updateOrder Order.java:50 
    at myapp.instances.Server$7.call Server.java:195 
    at io.socket.emitter.Emitter.emit Emitter.java:117 
    at io.socket.client.Socket.onevent Socket.java:317 
    at io.socket.client.Socket.onpacket Socket.java:280 
    at io.socket.client.Socket.access$100 Socket.java:18 
at io.socket.client.Socket$2$2.call Socket.java:101 
		</stacktrace>
                        
                <Code>
 Realm realm = Realm.getDefaultInstance  ;
try {
    realm.beginTransaction  ;
    realm.createOrUpdateObjectFromJson Order.class, json ;
    realm.commitTransaction  ;
} finally {
    realm.close  ;
}
</Code>
                        
                <Description>Here a stack trace Note this is called on a separate network thread handled by Socket Am I doing something wrong, or is this a bug</Description>
                        
                <CreatedDate>14/02/2016</CreatedDate>
                        
                <ClosedDate>25/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2307</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>donnfelker</FixedByID>
            
        <Title>Removing allow backup</Title>
            
        <Description>References The consequence of this is that the developer will have ignore the lint warning in their project because we are not setting it. This can be accomplished by adding a lint.xml file to the application with the following contents: 
		Then, in the applications build gradle add the following lint config in the android block. At that point when gradlew lint is run the AllowBackup warning will be ignored. 
   </Description>
            
        <CreatedDate>19/02/2016</CreatedDate>
            
        <ClosedDate>23/02/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2307</PullRequestID>
                        
                <IssueID>2227</IssueID>
                        
                <Title>Library shouldnt include android allow Backup true</Title>
                        
                <Description>I dont think this should be set in the library. Is there a reason it is there Including android allow Backup true means it is a hassle to override this to false in my app.</Description>
                        
                <CreatedDate>03/02/2016</CreatedDate>
                        
                <ClosedDate>23/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>FirstGoodIssue</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2305</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Added white space check fortry</Title>
            
        <Description>Prevents mistakes seen in realm java</Description>
            
        <CreatedDate>19/02/2016</CreatedDate>
            
        <ClosedDate>20/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TInternal</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2305</PullRequestID>
                        
                <IssueID>2284</IssueID>
                        
                <Title>Support multiarguments distinct for Realm Dynamic Realm Realm Query and Realm Results</Title>
                        
                <Description>Support multiarguments distinct for Realm Dynamic Realm Realm Query and Realm Results Supports for issue</Description>
                        
                <CreatedDate>15/02/2016</CreatedDate>
                        
                <ClosedDate>24/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2304</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Deprecate Realm get Instance Context</Title>
            
        <Description> Deprecate Realm.getInstance Context Replease Realm.getInstance Context in examples. Unit Test Example doesnt work even before. Realm doc needs to be updated as well.
</Description>
            
        <CreatedDate>19/02/2016</CreatedDate>
            
        <ClosedDate>22/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2304</PullRequestID>
                        
                <IssueID>2303</IssueID>
                        
                <Title>gradlew test is not running on CI, and mockito cannot mock final Realm class</Title>
                        
                <Description>Two issues gradlew test will fail unit Test Example because of will fail. Realm is an static class which cannot be mocked by Mockito. 		We might have to use Power Mock instead  Enable gradlew test on CI.</Description>
                        
                <CreatedDate>19/02/2016</CreatedDate>
                        
                <ClosedDate>16/03/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2298</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>donnfelker</FixedByID>
            
        <Title>Adding javadoc to document field mutation behavior of copy To Real mand create From Json methods.</Title>
            
        <Description>Closes Please review realm java</Description>
            
        <CreatedDate>17/02/2016</CreatedDate>
            
        <ClosedDate>18/02/2016</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2298</PullRequestID>
                        
                <IssueID>1483</IssueID>
                        
                <Title>Document difference between copy To Realm and create From Json</Title>
                        
                <Code> public class FooUpdate extends RealmObject {
    private int id;
    private int a;
    private int b;

    public int getA   {
        return a;
    }

    public void setA int a  {
        this.a = a;
    }

    public int getB   {
        return b;
    }

    public void setB int b  {
        this.b = b;
    }

    public int getId   {
        return id;
    }

    public void setId int id  {
        this.id = id;
    }
}
</Code>
                        
                <Description>currently the copy To Realm Or Update will update unset fields to default value, which differs from the json api test</Description>
                        
                <CreatedDate>19/09/2015</CreatedDate>
                        
                <ClosedDate>18/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2294</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>fixes Illegal State Exception Caller thread behind the worker thread</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>17/02/2016</CreatedDate>
            
        <ClosedDate>24/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBugCrash</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2294</PullRequestID>
                        
                <IssueID>2115</IssueID>
                        
                <Title>SNAPSHOT Illegal StateException Caller thread behind the worker thread</Title>
                        
                <Description>This exception is thrown after I migrated my codebase from synchronous to asynchronous realm calls using observables. The stacktrace doesnt show where it went wrong from my code.The above is the only asynchronous call in that problematic activity. Any ideas why the exception is thrown</Description>
                        
                <CreatedDate>19/01/2016</CreatedDate>
                        
                <ClosedDate>24/02/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBugCrash</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>2284</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>stk1m1</FixedByID>
            
        <Title>Support multiarguments distinct for Realm Dynamic Realm Realm Query and Realm Results</Title>
            
        <Description>Support multiarguments distinct for Realm DynamicRealm RealmQuery and RealmResults Supports for issue </Description>
            
        <CreatedDate>15/02/2016</CreatedDate>
            
        <ClosedDate>24/02/2016</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TEnhancement</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>2284</PullRequestID>
                        
                <IssueID>1568</IssueID>
                        
                <Title>Adding distinct to RealmList</Title>
                        
                <Description>For consistency Realm Query distinct and Realm Results distinct should be added.</Description>
                        
                <CreatedDate>09/10/2015</CreatedDate>
                        
                <ClosedDate>24/03/2017</ClosedDate>
                        
                <Labels>
                              
                    <Label>DesignRequired</Label>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1407</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Clean up Shared Group java and Groupjava</Title>
            
        <Description>Cleanup native methods to match earlier discussed style grouped at the bottom of the class Preparing for bugfix for </Description>
            
        <CreatedDate>20/08/2015</CreatedDate>
            
        <ClosedDate>24/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1407</PullRequestID>
                        
                <IssueID>1406</IssueID>
                        
                <Title>Main looper not getting all change events</Title>
                        
                <Description>It seems it is possible to cause a race condition in Realm which will cause the Main Looper to miss updates from background threads Expected output on the screen would be after the background thread is done. However that is not the case  usually around on Geny Motion. 		This indicate that messages are not properly sent to the UI thread.</Description>
                        
                <CreatedDate>20/08/2015</CreatedDate>
                        
                <ClosedDate>28/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1395</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>is Valid should not throw</Title>
            
        <Description>reports a bug in is Valid. When an object is deleted from a Realm the underlaying row is change to an instance of the invalid row. Methods of invalid rows throw an exception unconditionally. Fixes realm java 
</Description>
            
        <CreatedDate>17/08/2015</CreatedDate>
            
        <ClosedDate>17/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1395</PullRequestID>
                        
                <IssueID>1393</IssueID>
                        
                <Title>is Valid doesnt behave as expected</Title>
                        
                <Code> 
Realm realm = Realm.getInstance this;
realm.beginTransaction ;
Dog myDog = realm.createObject Dog.class;
</Code>
                
                <stacktrace>
     Caused by: java.lang.IllegalStateException: Object is no longer managed by Realm. Has it been deleted?
            at io.realm.internal.InvalidRow.getStubException InvalidRow.java:180 
            at io.realm.internal.InvalidRow.isAttached InvalidRow.java:171 
            at io.realm.RealmObject.isValid RealmObject.java:107
</stacktrace>
                        
                <Description>Im using real mandroid. When I run this simple code:How can I check if an object was removed from realm?Or does my little example not work because Im calling this function from the same thread 		However I dont think that is Valid should ever throw such an exception.</Description>
                         
                <CreatedDate>16/08/2015</CreatedDate>
                        
                <ClosedDate>17/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1395</PullRequestID>
                        
                <IssueID>1393</IssueID>
                        
                <Title>is Valid doesnt behave as expected</Title>
                        
                <Code> 
		Realm realm = Realm.getInstance this;
		realm.beginTransaction;
		Dog myDog = realm.createObject Dog.class;
		</Code>
                		
                <stacktrace>
		     Caused by: java.lang.IllegalStateException: Object is no longer managed by Realm. Has it been deleted?
            at io.realm.internal.InvalidRow.getStubException InvalidRow.java:180 
            at io.realm.internal.InvalidRow.isAttached InvalidRow.java:171 
            at io.realm.RealmObject.isValid RealmObject.java:107 
		</stacktrace>
                        
                <Description>Im using real mandroid SNAPSHOT. When I run this simple code How can I check if an object was removed from realm Or does my little example not work because Im calling this function from the same thread However I dont think that isValid should ever throw such an exception.</Description>
                         
		
                <CreatedDate>16/08/2015</CreatedDate>
                        
                <ClosedDate>17/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1379</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Unit test to expose time out in finalizer</Title>
            
        <Description>is reporting a timeout of the finalizer watchdog. When you have many objects in a Realm and you iterate through them in multiple threads many temporary objects are created. 	Disposal of these temporary objects might take too long  Android's limit is seconds and the exception as mentioned in is thrown Relevant background info 	</Description>
            
        <CreatedDate>11/08/2015</CreatedDate>
            
        <ClosedDate>14/08/2015</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TBug</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1379</PullRequestID>
                        
                <IssueID>1342</IssueID>
                        
                <Title>Timeout on Context.finalize  </Title>
                		 
                <Code> </Code>
                        
                <stacktrace>
		java.util.concurrent.TimeoutException: io.realm.internal.Context.finalize   timed out after 10 seconds
			   at java.lang.Object.equals Object.java:205 
			   at java.util.ArrayList.remove ArrayList.java:418 
			   at io.realm.internal.Context.cleanRows Context.java:69 
			   at io.realm.internal.Context.executeDelayedDisposal Context.java:61 
			   at io.realm.internal.Context.finalize Context.java:113 
			   at java.lang.Daemons$FinalizerDaemon.doFinalize Daemons.java:209 
			   at java.lang.Daemons$FinalizerDaemon.run Daemons.java:192 
			   at java.lang.Thread.run Thread.java:818 
	</stacktrace>
                        
                <Description>Hey we started seeing following error with the update to Realm 0.82.0:We also see some longer access times to the Realm after we added some "realm.clear RealmObject.class " calls.Is this a known issue or is there a better way to clear a whole table? </Description>
                        
                <CreatedDate>03/08/2015</CreatedDate>
                        
                <ClosedDate>24/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1364</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>load Library should be asynchronize doperation</Title>
            
        <Description>Otherwise it might cause 1350
</Description>
            
        <CreatedDate>07/08/2015</CreatedDate>
            
        <ClosedDate>10/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1356</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>No longer caches the wrong encryption key</Title>
            
        <Description>Fixes realm java</Description>
            
        <CreatedDate>06/08/2015</CreatedDate>
            
        <ClosedDate>06/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1356</PullRequestID>
                        
                <IssueID>1352</IssueID>
                        
                <Title>Cannot connect to realmdb when passed wrong encryption key for the first time</Title>
                        
                <Description>Hallo I have a problem. I use users password to encrypt databse. When opening application, I ask user for the password, generate encryption key  using SHA  and try to use it to open database. Everything works perfect as long as user pass correct password. But it is impossible to open database, when user pass wrong password for the first time. I have ended in this test:I have default realm database encrypted by password a. make SHA1 Hash is method to generate encryption key based on the password. Source code:This sample code ends in this  wrong  result is wrong a is wrong  b is wrong a is wrong d is wrong When I delete the first try  catch code with X so the fist db open is successful using the password the correct result is MV a is okMV b is wrongMV  a is okMV  d is wrongCould you please help me how to solve situation when user pass wrong password and cannot be than connected even the second password is correct Thank you</Description>
                        
                <CreatedDate>05/08/2015</CreatedDate>
                        
                <ClosedDate>06/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1345</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Handle null value for String in Json when updating</Title>
            
        <Description>Fix Update the object String field to empty string when the corresponding field in Json is null.</Description>
            
        <CreatedDate>03/08/2015</CreatedDate>
            
        <ClosedDate>04/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1345</PullRequestID>
                        
                <IssueID>1344</IssueID>
                        
                <Title>update from JSON will skip null values</Title>
                        
                <Description>When update from JSON which contains property with null values, the property will be ignored.To make the consistency with the create interface, corresponding field should be set to null.</Description>
                        
                <CreatedDate>03/08/2015</CreatedDate>
                        
                <ClosedDate>04/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1341</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>emanuelez</FixedByID>
            
        <Title>Ignore errors in analytics BGthread and allow disabling it</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>03/08/2015</CreatedDate>
            
        <ClosedDate>03/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1341</PullRequestID>
                        
                <IssueID>1336</IssueID>
                        
                <Title>Realm Analytics Null Pointer</Title>
                        
                <Description>Crash Exception in thread Thread</Description>
                	    
                <CreatedDate>01/08/2015</CreatedDate>
                        
                <ClosedDate>03/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1329</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Fixdeadlockmighthappeninshutdownhook.</Title>
            
        <Description>A simple framework is created for multiprocesses testing. And since it can be used to verify merge it earlier.
</Description>
            
        <CreatedDate>29/07/2015</CreatedDate>
            
        <ClosedDate>04/08/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1329</PullRequestID>
                        
                <IssueID>1328</IssueID>
                        
                <Title>Dead lock happens when calling  Runtime get Runtime exit</Title>
                        
                <Description>Issue first reported on SO. When calling Runtime get Runtime with Realm opened before finalizer wont stop running. Lock is waiting forever, process cannot exist.Below code to reproduce this error:</Description>
                        
                <CreatedDate>29/07/2015</CreatedDate>
                        
                <ClosedDate>04/08/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1325</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Configuration now accepts Nullmodules</Title>
            
        <Description>Fixes We had a fair amount of issues over the last weeks where people did not properly understanding when to use Realm get Default Module 	which means they used even when no Default Module was created. This is fairly common when all your Realm Classes are in a library and your application 	just uses the RealmClasses from that library. This PR relaxes the requirements and allows a smaller programmer error by ignoring null values parsed to Realm 	Configuration setModules. It turned out that returning a empty module would require a lot more code. See for possible other solutions. realm java </Description>
            
        <CreatedDate>28/07/2015</CreatedDate>
            
        <ClosedDate>28/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1313</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>emanuelez</FixedByID>
            
        <Title>Clean up native row accessor from the same thread that created them</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>22/07/2015</CreatedDate>
            
        <ClosedDate>24/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1290</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Keep Realm Module class from being obfuscated</Title>
            
        <Description>Issue 1283
</Description>
            
        <CreatedDate>13/07/2015</CreatedDate>
            
        <ClosedDate>16/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1290</PullRequestID>
                        
                <IssueID>1283</IssueID>
                        
                <Title>Annotation processor may not have been executed using Proguard</Title>
                        
                <Code>
		</Code>
                        
                <Description> IssueI got Annotation issue while enabling Proguard. Without it, the package is working. Raw mesage More information My Realm class having Realm Class annotation already</Description>
                        
                <CreatedDate>10/07/2015</CreatedDate>
                        
                <ClosedDate>16/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1284</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Removed Realm Query between for link queries</Title>
            
        <Description>As discussed at length in Realm Query between does not work as expected in many cases. As the underlaying storage engine does not provide a operator directly, I think it is better for remove it. realm java </Description>
            
        <CreatedDate>10/07/2015</CreatedDate>
            
        <ClosedDate>14/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1284</PullRequestID>
                        
                <IssueID>1237</IssueID>
                        
                <Title>Between usage with link query relations</Title>
                        
                <Description>Hi there We are trying to use link query with relations. In our case classes are looked like There are my root objects that contains levels which contains points. I try to find root objects which contains the zoomLevel level with in the range of min and max points.The problem is that, altough equalTo works fine, between gives the root objects that are not in the range of given Xs and Ys.Such example is that Root that contains this object is also returned from query. Thanks for any help</Description>
                        
                <code>Level zoomLevel = 15, points = &lt;{17000, 13000}&gt;</code>
                		
                <CreatedDate>24/06/2015</CreatedDate>
                        
                <ClosedDate>17/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>THelp</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1268</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Document Realm Results first last can throw</Title>
            
        <Description>Documenting that Realm Results first last throw exception if result is empty. I have added a simple unit test and added the exception to the documentation.

Closes @realm/java 
</Description>
            
        <CreatedDate>06/07/2015</CreatedDate>
            
        <ClosedDate>10/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1268</PullRequestID>
                        
                <IssueID>1102</IssueID>
                        
                <Title>Document that Realm Results first and Realm Results last  can throw</Title>
                        
                <Description>JavaDoc does not specify that Realm Results first and Realm Results last can throw an exception if no elements are found.</Description>
                        
                <CreatedDate>08/05/2015</CreatedDate>
                        
                <ClosedDate>10/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1262</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Index primary key</Title>
            
        <Description>needs to be merge first</Description>
            
        <CreatedDate>03/07/2015</CreatedDate>
            
        <ClosedDate>08/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1261</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Replaced all Inherit Doc with proper documentation.</Title>
            
        <Description>Fixes All Inherit Doc tags has been replaced with proper documentation as Inherit Doc doesnt work well with the Android SDK realm java </Description>
            
        <CreatedDate>02/07/2015</CreatedDate>
            
        <ClosedDate>27/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1261</PullRequestID>
                        
                <IssueID>1165</IssueID>
                        
                <Title>inherit Doc doesnt work</Title>
                        
                <Description>We use inherit Doc in both Realm List java and Realm Results java. This doesnt work with Android sigh so we need to copy the JavaDoc from their parent classes. </Description>
                        
                <CreatedDate>29/05/2015</CreatedDate>
                        
                <ClosedDate>27/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1258</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Accessing deleted objects throw Illegal State Exception</Title>
            
        <Description>Fixes After splitting into Unchecked Checked row, the check to see if object was still alive was also removed. That cannot be prevented by the type system, so that check has been readded. realm java 
    </Description>
            
        <CreatedDate>01/07/2015</CreatedDate>
            
        <ClosedDate>02/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1258</PullRequestID>
                        
                <IssueID>1240</IssueID>
                        
                <Title>Unchecked Row should still detect deleted objects.</Title>
                        
                <Code>
        </Code>
                		
                <stacktrace>
		0624 13:52:41.668        8686/? I/DEBUG                
0624 13:52:41.668        8686/? I/DEBUG Build fingerprint: 'generic/vbox86p/vbox86p:5.0/LRX21M/buildbot02241201:userdebug/testkeys'
0624 13:52:41.668        8686/? I/DEBUG Revision: '0'
0624 13:52:41.668        8686/? I/DEBUG ABI: 'x86'
0624 13:52:41.668        8686/? I/DEBUG pid: 17113, tid: 17113, name: .witdot.twinkie  &gt;&gt;&gt; com.witdot.twinkie &lt;&lt;&lt;
0624 13:52:41.668        8686/? I/DEBUG signal 11  SIGSEGV , code 1  SEGV_MAPERR , fault addr 0x90
0624 13:52:41.671        8686/? I/DEBUG eax 00000000  ebx a11cce30  ecx 00000001  edx 00000003
0624 13:52:41.671        8686/? I/DEBUG esi 00000000  edi bf94f14c
0624 13:52:41.671        8686/? I/DEBUG xcs 00000073  xds 0000007b  xes 0000007b  xfs 00000007  xss 0000007b
0624 13:52:41.671        8686/? I/DEBUG eip a112b882  ebp bf94f128  esp bf94f100  flags 00210246
0624 13:52:41.671        8686/? I/DEBUG backtrace:
0624 13:52:41.671        8686/? I/DEBUG 00 pc 000b2882  /data/app/com.witdot.twinkie1/lib/x86/librealmjni.so
0624 13:52:41.671        8686/? I/DEBUG 01 pc 000a9f1c  /data/app/com.witdot.twinkie1/lib/x86/librealmjni.so  Java_io_realm_internal_UncheckedRow_nativeGetLinkView+95 
0624 13:52:41.671        8686/? I/DEBUG 02 pc 003ee6c3  /data/dalvikcache/x86/data@app@com.witdot.twinkie1@base.apk@classes.dex
0624 13:52:41.811        8686/? I/DEBUG Tombstone written to: /data/tombstones/tombstone_00

		</stacktrace>
                        
                <Description>Hey guys Getting this native exception. It doesnt happen all the time. Thats why I didnt narrow it down to the exact line. Will update the issue when find it.P.S. Realm version is</Description>
                        
                <CreatedDate>24/06/2015</CreatedDate>
                        
                <ClosedDate>02/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
                <AST/>
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1257</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Add support for in memory Realm squashed</Title>
            
        <Description>This is squashed commits of to make a better looking of git history.I do guarantee this would be exact the same with SHA: 4d8e9df which is the last merge commit of  .
</Description>
            
        <CreatedDate>01/07/2015</CreatedDate>
            
        <ClosedDate>02/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1246</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Support search indexing for column int bool date</Title>
            
        <Description>Enable the search index annotation on byte, short, int, long, boolean, and Date. Enable add remove search index in java. Annotation processor test to support better detailed test cases. Refactor Realm Query Test to apply all normal query test cases on a Realm Object with indexed fields Modify JNI test cases. Update doc. This is the first PR for Implicit index to int primary keys will be handled in another PR. Make PR for realm.io to update related Doc Modify changelog. Bump version if needed. </Description>
            
        <CreatedDate>26/06/2015</CreatedDate>
            
        <ClosedDate>03/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1246</PullRequestID>
                        
                <IssueID>1039</IssueID>
                        
                <Title>Add support for indexing integer and Date fields</Title>
                        
                <Description>Realm Core supports search index on boolean, integer, and Date fields. Adding support for these types could improve the performance for primary keys.</Description>
                        
                <CreatedDate>16/04/2015</CreatedDate>
                        
                <ClosedDate>08/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1245</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>beeender</FixedByID>
            
        <Title>Throw exception when close called on a diffthread.</Title>
            
        <Description>Without checking the thread in close some weird logic could be triggered which is really hard to think about. I was thinking maybe this would cause but according to the feedback, this might not the root cause. But anyway, it is something worth to fix.
    </Description>
            
        <CreatedDate>26/06/2015</CreatedDate>
            
        <ClosedDate>29/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1245</PullRequestID>
                        
                <IssueID>1241</IssueID>
                        
                <Title>a Null Pointer Expection came out when I call Realm.close</Title>
                        
                <Description>My Realm version is 0.81.1 and the log is </Description>
                		
                <CreatedDate>25/06/2015</CreatedDate>
                        
                <ClosedDate>06/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1218</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Split Row into Checked Row and Unchecked Row</Title>
            
        <Description>Currently our typed API uses Row as the backing wrapper object for all Row access. This object does input validation in JNI for fieldnames types on each access. This is wasted work since all those checks are done upfront when opening the Realm validate Table. This PR paves the way for the Dynamic API by splitting Row into Unchecked Row and Checked Row. The Dynamic API will use CheckedRow, which will include those checks, while our typed API has moved to Unchecked Row.  Row has been converted to an interface. Performance test I did an informal test by running Realm Results Test. The average running time decreased by which means the gain for purely the getterssetters have been even higher.emanuelez kneth nhachicha </Description>
            
        <CreatedDate>17/06/2015</CreatedDate>
            
        <ClosedDate>18/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1214</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>async queries write transaction</Title>
            
        <Description> Support async queries write transactions new methods find All Async find All Sorted Async find First Async they accept the same parameters as their synchronous counterpart, but they return immediately a _promise_, as described here https://github.com/realm/realmwiki/wiki/%5BDRAFT%5DAsynchronousqueriesdesignproposal Note: the interface RealmCollection was not add so far, because we have only one return type RealmResults for both sync async, plus retrieving  RealmList asynchronously was outside of this scope Support async write transactions executeTransaction is overloaded to accept a new parameters Transaction.Callback. This will run the write transaction on a worker thread. The async transaction returns a Request object that can be used to cancel a scheduled/pending write transaction  if it didn't already complete Fixes reflect breaking changes from Core branch build against it rename where to query </Description>
            
        <CreatedDate>15/06/2015</CreatedDate>
            
        <ClosedDate>19/10/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1214</PullRequestID>
                        
                <IssueID>1224</IssueID>
                        
                <Title>Refactor RealmQuery to allow async queries</Title>
                        
                <Code> 
		  public void onSuccess RealmResults&lt;Foo&gt; results  {
			// Use results
		   }
		  public void onSuccess Foo result  {
			// Use result
		  }
       </Code>
                        
                <Description>Now that we have a POC of a working async queries with a convergence strategy  I suggest the following refactor to enable RealmQuery to be used seamlessly for both sync &amp; async queries.Unless we define a DSL that represent a query we can push  in one call  from Java to Core. We need to evaluate lazily the query once we call findAll, findFirst etc. Instead of calling _Core_ for each step  e.g. greaterThan, isNotNull . As suggested by @cmelchior  we should approach it as a command pattern, basically queue all calls to native in a list of Runnable, then call execute to perform each call. at this point we can overload execute to run on a background thread  with a callback the result will be like thisWDYT? @bmunkholm @emanuelez @kneth</Description>
                        
                <CreatedDate>19/06/2015</CreatedDate>
                        
                <ClosedDate>11/09/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realm java</RepoID>
                        
                <PullRequestID>1214</PullRequestID>
                        
                <IssueID>1207</IssueID>
                        
                <Title>Async write</Title>
                        
                <Description>As a complement to Realm Query find All Async callback we should implement Realm execute Transaction Async transaction  which would perform writes on a background thread without blocking</Description>
                        
                <CreatedDate>11/06/2015</CreatedDate>
                        
                <ClosedDate>11/09/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TFeature</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1203</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>emanuelez</FixedByID>
            
        <Title>Uses cmd to perform the deployment of releases</Title>
            
        <Description>Fixes This assumes that the S3 credentials have already been setup with s3cmd configure on the hosting machine
</Description>
            
        <CreatedDate>10/06/2015</CreatedDate>
            
        <ClosedDate>12/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1203</PullRequestID>
                        
                <IssueID>893</IssueID>
                        
                <Title>Automate release in Jenkins</Title>
                        
                <CreatedDate>23/02/2015</CreatedDate>
                        
                <ClosedDate>12/06/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1194</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Added a check for null values inio realm internal Table find First String Date.</Title>
            
        <Description>Closes emanuelez cmelchior nhachicha 
</Description>
            
        <CreatedDate>08/06/2015</CreatedDate>
            
        <ClosedDate>09/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1194</PullRequestID>
                        
                <IssueID>914</IssueID>
                        
                <Title> Add check for null as primary key to avoid JNI DETECTED ERROR IN APPLICATION GetStringChars received null jstring</Title>
                        
                <Description>Found this error while normal development. I haven't been able to reproduce it with what I think is the same data situation. Get String Chars received null jstring in call to Get String Chars from long io realm internal Table </Description>
                        
                <ClosedDate>09/06/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1192</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Checking form is sing generic type during annotation processing</Title>
            
        <Description>Closes emanuelez cmelchior nhachicha 
	</Description>
            
        <CreatedDate>08/06/2015</CreatedDate>
            
        <ClosedDate>10/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1192</PullRequestID>
                        
                <IssueID>1131</IssueID>
                        
                <Title>Add a check in the annotation processor for the existence of the generic type of RealmLists</Title>
                        
                <Description>The annotation processor will crash if a model is defined like this:</Description>
                        
                <CreatedDate>18/05/2015</CreatedDate>
                        
                <ClosedDate>10/06/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1191</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fixed migration example</Title>
            
        <Description>This PR updates the Migration Example to work with Realm Configuration. It also changes the semantics slightly from the original as that allowed you to upgrade from without a migration block. This was slightly odd and caused e.g. the Migration Example to crash, so it has been changed so any attempt to set a version above now require a migration block. No changelog update as Realm Configurations hasn't been released yet. emanuelez nhachicha kneth </Description>
             
        <CreatedDate>08/06/2015</CreatedDate>
            
        <ClosedDate>09/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1180</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Introducing Realm Error</Title>
            
        <Description>reports a number of cases when an app is returning a wrong string value. Investigations by users suggest that a call to mmap failed. When mmap  and it sister kernel calls  fail, Realm Core throws a runtime error.So far, we have thrown a RuntimeException in these cases but exceptions are often ignored. Ignoring a mmap failure is likely to leave the Realm file in a corrupted state which could easily explain the wrong string values. Realm will now throw a RealmError when Realm Core enters an unrecoverable error condition. As errors are typically not ignored, it feels safer rather to crash the app than leave the Realm file corrupt. bmunkholm kspangsege cmelchior emanuelez nhachicha TODO changelog </Description>
            
        <CreatedDate>03/06/2015</CreatedDate>
            
        <ClosedDate>06/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1180</PullRequestID>
                        
                <IssueID>729</IssueID>
                        
                <Title>Getting a weird behavior when saving a string</Title>
                		
                <code/>
                        
                <Stacktrace> 
java.lang.RuntimeException: Unspecified exception. Failure when converting short string to UTF16 0x20 0xae 0x00 0x00 0x90 0xae 0x00 0x00 0x98 0x54 0x01 in io_realm_internal_Row.cpp line 126
            at io.realm.internal.Row.nativeGetString Native Method 
            at io.realm.internal.Row.getString Row.java:126 
            at io.realm.MessageModelRealmProxy.getMessage MessageModelRealmProxy.java:108 
	</Stacktrace>
                        
                <Description/>
                        
                <CreatedDate>08/01/2015</CreatedDate>
                        
                <ClosedDate>20/11/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1178</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>nhachicha</FixedByID>
            
        <Title>add conf to build for x86 64</Title>
            
        <Description>Fixes Please wait for before merging this PR as it provides the static library needed by JNI
</Description>
            
        <CreatedDate>02/06/2015</CreatedDate>
            
        <ClosedDate>24/09/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1178</PullRequestID>
                        
                <IssueID>1167</IssueID>
                        
                <Title>Add x86 64 Support</Title>
                        
                <Description>I know there isnt a ton of devices out there that have this arch yet but there are x86 64 emulators available.Is there a timeline for this to be supported Thanks</Description>
                        
                <CreatedDate>29/05/2015</CreatedDate>
                        
                <ClosedDate>24/09/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1177</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Specified Realm copy To Realm behaviour</Title>
            
        <Description>Fixes kneth emanuelez nhachicha </Description>
            
        <CreatedDate>02/06/2015</CreatedDate>
            
        <ClosedDate>03/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1177</PullRequestID>
                        
                <IssueID>1176</IssueID>
                        
                <Title>Docs not saying will method copy To Realm deeply copy  object to Realm</Title>
                        
                <Description>Docs not saying will method copyToRealm   deeply copy  object to Realm By this I mean including other realm objects which are fields of copy object.</Description>
                        
                <CreatedDate>02/06/2015</CreatedDate>
                        
                <ClosedDate>03/06/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TDoc</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1171</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cypressious</FixedByID>
            
        <Title>Add support for Kotlin</Title>
            
        <Description>Fixes This enables better compatibility with Kotlin's new annotation processing capability.
</Description>
            
        <CreatedDate>30/05/2015</CreatedDate>
            
        <ClosedDate>01/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1171</PullRequestID>
                        
                <IssueID>509</IssueID>
                        
                <Title>Support Kotlin Lang</Title>
                        
                <Description>Current version of Realm not working with Kotlin  A have an exception </Description>
                		
                <CreatedDate>28/10/2014</CreatedDate>
                        
                <ClosedDate>29/09/2016</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1166</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Standalone objects can now beadded to managed Realm Lists</Title>
            
        <Description>Fixes Users can now transparently add standalone objects to RealmLists already in Realm without manually having to call copy To Realm or copy To Realm Or Update.This also mirrors the behaviour the other way where users already can add managed objects to unmanaged Realm Lists.
</Description>
            
        <CreatedDate>29/05/2015</CreatedDate>
            
        <ClosedDate>02/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1166</PullRequestID>
                        
                <IssueID>1140</IssueID>
                        
                <Title>Realm List add throws misleading exception for standalone objects</Title>
                        
                <Description>From this SO question The following will fail with a Null Pointer exception:which would fail if just using copy To Realm. What do you think emanuelez kneth </Description>
                        
                <CreatedDate>20/05/2015</CreatedDate>
                        
                <ClosedDate>02/06/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1164</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Querying Realm Result scan crash</Title>
            
        <Description>A reported inquerying Realm Results might lead to a crash. The reason seems to be that a Table Query might be finalised prematurely, and the native resource is freed. When the native resource is freed, accessing it will cause a segmentation fault. This fixes by adding references to Table View and Table Query in order to prevent premature garbage collection. emanuelez cmelchior beeender </Description>
            
        <CreatedDate>28/05/2015</CreatedDate>
            
        <ClosedDate>11/07/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1164</PullRequestID>
                        
                <IssueID>1161</IssueID>
                        
                <Title>Native crash  signal SIGSEGV code</Title>
                        
                <stacktrace>
		0528 15:30:42.375 28102 28102 F libc    : Fatal signal 11  SIGSEGV , code 2, fault addr 0xbe1faff8 in tid 28102  .kiwian.jiaxiao 
0528 15:30:42.492   237   237 I DEBUG   :                
0528 15:30:42.492   237   237 I DEBUG   : Build fingerprint: 'oneplus/bacon/A0001:5.0.2/LRX22G/YNG1TAS17L:user/releasekeys'
0528 15:30:42.493   237   237 I DEBUG   : Revision: '0'
0528 15:30:42.493   237   237 I DEBUG   : ABI: 'arm'
0528 15:30:42.493   237   237 I DEBUG   : pid: 28102, tid: 28102, name: .kiwian.jiaxiao  &gt;&gt;&gt; com.kiwian.jiaxiao &lt;&lt;&lt;
0528 15:30:42.494   237   237 I DEBUG   : signal 11  SIGSEGV , code 2  SEGV_ACCERR , fault addr 0xbe1faff8
0528 15:30:42.542   237   237 I DEBUG   :     r0 afdefd30  r1 afdefd30  r2 00000006  r3 afdefd38
0528 15:30:42.542   237   237 I DEBUG   :     r4 96a827c0  r5 96a827c0  r6 afdefd30  r7 00000006
0528 15:30:42.542   237   237 I DEBUG   :     r8 00000000  r9 96a827c0  sl 00000006  fp afdefcc4
0528 15:30:42.542   237   237 I DEBUG   :     ip 0000001d  sp be1fb000  lr afdb5827  pc afdcfd06  cpsr 600f0030
0528 15:30:42.542   237   237 I DEBUG   : 
0528 15:30:42.542   237   237 I DEBUG   : backtrace:
0528 15:30:42.542   237   237 I DEBUG   :     00 pc 000a7d06  /data/app/com.kiwian.jiaxiao1/lib/arm/librealmjni.so
0528 15:30:42.542   237   237 I DEBUG   :     01 pc 00000d34  /data/app/com.kiwian.jiaxiao1/lib/arm/librealmjni.so
0528 15:30:42.808   775  1505 W ActivityManager: getTasks: caller 10124 does not hold GET_TASKS; limiting output
0528 15:30:43.765   237   237 I DEBUG   : 


And here is the crash backtrace with my test case:


0528 16:04:10.208   237   237 I DEBUG   :                
0528 16:04:10.208   237   237 I DEBUG   : Build fingerprint: 'oneplus/bacon/A0001:5.0.2/LRX22G/YNG1TAS17L:user/releasekeys'
0528 16:04:10.208   237   237 I DEBUG   : Revision: '0'
0528 16:04:10.208   237   237 I DEBUG   : ABI: 'arm'
0528 16:04:10.208   237   237 I DEBUG   : pid: 14514, tid: 14551, name: ationTestRunner  &gt;&gt;&gt; io.realm.test &lt;&lt;&lt;
0528 16:04:10.208   237   237 I DEBUG   : signal 11  SIGSEGV , code 2  SEGV_ACCERR , fault addr 0xaccd8ff8
0528 16:04:10.212   237   237 I DEBUG   :     r0 afdefd30  r1 afdefd30  r2 00000006  r3 afdefd38
0528 16:04:10.212   237   237 I DEBUG   :     r4 acbd3860  r5 acbd3860  r6 afdefd30  r7 00000006
0528 16:04:10.212   237   237 I DEBUG   :     r8 00000000  r9 acbd3860  sl 00000006  fp afdefcc4
0528 16:04:10.212   237   237 I DEBUG   :     ip 0000001d  sp accd9000  lr afdb5827  pc afdcfd06  cpsr 600f0030
0528 16:04:10.213   237   237 I DEBUG   : 
0528 16:04:10.213   237   237 I DEBUG   : backtrace:
0528 16:04:10.213   237   237 I DEBUG   :     00 pc 000a7d06  /data/app/io.realm.test2/lib/arm/librealmjni.so
0528 16:04:10.213   237   237 I DEBUG   :     01 pc 00000d34  /data/app/io.realm.test2/lib/arm/librealmjni.so


And the testcase to reproduce it:

		</stacktrace>
                        
                <Code>
    private RealmResults&lt;CatOwner&gt; results = null;
    public void testModifyRealmListD   {
        //If it doesn't crash, increase this
        final int count = 100;
        // Enable the list for maintaining the reference will avoid crash!!!!!!!!!!!!!
        //final ArrayList&lt;RealmResults&lt;CatOwner&gt;&gt; arrayList = new ArrayList&lt;RealmResults&lt;CatOwner&gt;&gt;  ;

        results = testRealm.where CatOwner.class .findAll  ;
        RealmChangeListener listener = new RealmChangeListener   {
            @Override
            public void onChange   {
                // Enable the list for maintaining the reference will avoid crash!!!!!!!!!!!!!
                //arrayList.add results ;
                results = results.where  .notEqualTo "name", "asdfas" + count .findAll  ;
                assertEquals count, results.size   ;
                for  int i=0; i&lt;count; i++  {
                    CatOwner catOwner = results.get i ;
                    assertEquals catOwner.getName  , "catOwner"+i ;
                    Log.e "testModifyRealmListD", "loop count " + i ;
                }
                System.gc  ;
            }
        };
        testRealm.addChangeListener listener ;
        for  int i=1; i&lt;=count; i++  {
            doTestModifyRealmList count ;
        }
    }

    private void doTestModifyRealmList final int count  {
        final RealmResults&lt;CatOwner&gt; results = testRealm.where CatOwner.class .findAll  ;
        testRealm.beginTransaction  ;
        for  int i=0; i&lt;count; i++  {
            CatOwner catOwner = new CatOwner  ;
            catOwner.setName "catOwner" + i ;
            catOwner = testRealm.copyToRealmOrUpdate catOwner ;
        }
        testRealm.commitTransaction  ;
    }
</Code>
                        
                <Description>Finally i can reproduce the native crash in my projectHere is the original native crash back trace I am almost sure it is caused by wild native pointer which is released by the GC since if the Releam Results references are maitained by a Array List the crash wont happen.I guess something needs to be done if a query is created from a Realm Results</Description>
                        
                <CreatedDate>28/05/2015</CreatedDate>
                        
                <ClosedDate>11/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1164</PullRequestID>
                        
                <IssueID>1161</IssueID>
                        
                <Title>Native crash  signal 11  SIGSEGV , code 2</Title>
                        
                <Code>
    private RealmResults&lt;CatOwner&gt; results = null;
    public void testModifyRealmListD   {
        //If it doesn't crash, increase this
        final int count = 100;
        // Enable the list for maintaining the reference will avoid crash!!!!!!!!!!!!!
        //final ArrayList&lt;RealmResults&lt;CatOwner&gt;&gt; arrayList = new ArrayList&lt;RealmResults&lt;CatOwner&gt;&gt;  ;

        results = testRealm.where CatOwner.class .findAll  ;
        RealmChangeListener listener = new RealmChangeListener   {
            @Override
            public void onChange   {
                // Enable the list for maintaining the reference will avoid crash!!!!!!!!!!!!!
                //arrayList.add results ;
                results = results.where  .notEqualTo "name", "asdfas" + count .findAll  ;
                assertEquals count, results.size   ;
                for  int i=0; i&lt;count; i++  {
                    CatOwner catOwner = results.get i ;
                    assertEquals catOwner.getName  , "catOwner"+i ;
                    Log.e "testModifyRealmListD", "loop count " + i ;
                }
                System.gc  ;
            }
        };
        testRealm.addChangeListener listener ;
        for  int i=1; i&lt;=count; i++  {
            doTestModifyRealmList count ;
        }
    }

    private void doTestModifyRealmList final int count  {
        final RealmResults&lt;CatOwner&gt; results = testRealm.where CatOwner.class .findAll  ;
        testRealm.beginTransaction  ;
        for  int i=0; i&lt;count; i++  {
            CatOwner catOwner = new CatOwner  ;
            catOwner.setName "catOwner" + i ;
            catOwner = testRealm.copyToRealmOrUpdate catOwner ;
        }
        testRealm.commitTransaction  ;
    }
</Code>
                       
                <stacktrace>
	   0528 15:30:42.375 28102 28102 F libc    : Fatal signal 11  SIGSEGV , code 2, fault addr 0xbe1faff8 in tid 28102  .kiwian.jiaxiao 
0528 15:30:42.492   237   237 I DEBUG   :                
0528 15:30:42.492   237   237 I DEBUG   : Build fingerprint: 'oneplus/bacon/A0001:5.0.2/LRX22G/YNG1TAS17L:user/releasekeys'
0528 15:30:42.493   237   237 I DEBUG   : Revision: '0'
0528 15:30:42.493   237   237 I DEBUG   : ABI: 'arm'
0528 15:30:42.493   237   237 I DEBUG   : pid: 28102, tid: 28102, name: .kiwian.jiaxiao  &gt;&gt;&gt; com.kiwian.jiaxiao &lt;&lt;&lt;
0528 15:30:42.494   237   237 I DEBUG   : signal 11  SIGSEGV , code 2  SEGV_ACCERR , fault addr 0xbe1faff8
0528 15:30:42.542   237   237 I DEBUG   :     r0 afdefd30  r1 afdefd30  r2 00000006  r3 afdefd38
0528 15:30:42.542   237   237 I DEBUG   :     r4 96a827c0  r5 96a827c0  r6 afdefd30  r7 00000006
0528 15:30:42.542   237   237 I DEBUG   :     r8 00000000  r9 96a827c0  sl 00000006  fp afdefcc4
0528 15:30:42.542   237   237 I DEBUG   :     ip 0000001d  sp be1fb000  lr afdb5827  pc afdcfd06  cpsr 600f0030
0528 15:30:42.542   237   237 I DEBUG   : 
0528 15:30:42.542   237   237 I DEBUG   : backtrace:
0528 15:30:42.542   237   237 I DEBUG   :     00 pc 000a7d06  /data/app/com.kiwian.jiaxiao1/lib/arm/librealmjni.so
0528 15:30:42.542   237   237 I DEBUG   :     01 pc 00000d34  /data/app/com.kiwian.jiaxiao1/lib/arm/librealmjni.so
0528 15:30:42.808   775  1505 W ActivityManager: getTasks: caller 10124 does not hold GET_TASKS; limiting output
0528 15:30:43.765   237   237 I DEBUG   : 


And here is the crash backtrace with my test case:


0528 16:04:10.208   237   237 I DEBUG   :                
0528 16:04:10.208   237   237 I DEBUG   : Build fingerprint: 'oneplus/bacon/A0001:5.0.2/LRX22G/YNG1TAS17L:user/releasekeys'
0528 16:04:10.208   237   237 I DEBUG   : Revision: '0'
0528 16:04:10.208   237   237 I DEBUG   : ABI: 'arm'
0528 16:04:10.208   237   237 I DEBUG   : pid: 14514, tid: 14551, name: ationTestRunner  &gt;&gt;&gt; io.realm.test &lt;&lt;&lt;
0528 16:04:10.208   237   237 I DEBUG   : signal 11  SIGSEGV , code 2  SEGV_ACCERR , fault addr 0xaccd8ff8
0528 16:04:10.212   237   237 I DEBUG   :     r0 afdefd30  r1 afdefd30  r2 00000006  r3 afdefd38
0528 16:04:10.212   237   237 I DEBUG   :     r4 acbd3860  r5 acbd3860  r6 afdefd30  r7 00000006
0528 16:04:10.212   237   237 I DEBUG   :     r8 00000000  r9 acbd3860  sl 00000006  fp afdefcc4
0528 16:04:10.212   237   237 I DEBUG   :     ip 0000001d  sp accd9000  lr afdb5827  pc afdcfd06  cpsr 600f0030
0528 16:04:10.213   237   237 I DEBUG   : 
0528 16:04:10.213   237   237 I DEBUG   : backtrace:
0528 16:04:10.213   237   237 I DEBUG   :     00 pc 000a7d06  /data/app/io.realm.test2/lib/arm/librealmjni.so
0528 16:04:10.213   237   237 I DEBUG   :     01 pc 00000d34  /data/app/io.realm.test2/lib/arm/librealmjni.so

	   </stacktrace>
                       
	   
                <Description>Finally i can reproduce the native crash in my projectHere is the original native crash backtrace:I am almost 99% sure it is caused by wild native pointer which is released by the GC since if the ReleamResults's references are maitained by a ArrayList, the crash won't happen.I guess something needs to be done if a query is created from a RealmResults</Description>
                        
                <CreatedDate>28/05/2015</CreatedDate>
                        
                <ClosedDate>11/07/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1158</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>New example for Modules</Title>
            
        <Description>Depends on This adds a new example realm Module Example consisting of two modules showing how Realm can be used with library projects using Realm Modules. It also shows how to setup ProGuard.
    </Description>
            
        <CreatedDate>27/05/2015</CreatedDate>
            
        <ClosedDate>12/06/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1144</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Adding objects usinga Realm Lists now properly clears any previous data.</Title>
            
        <Description>Fixes emanuelez kneth 
</Description>
            
        <CreatedDate>21/05/2015</CreatedDate>
            
        <ClosedDate>21/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1144</PullRequestID>
                        
                <IssueID>1143</IssueID>
                        
                <Title>Setting a new Realm List to an object appends to the old existing Realm List</Title>
                        
                <Code> 
public class Test extends RealmObject {

    private int integerValue;
    private RealmList&lt;Test&gt; tests;

    public int getIntegerValue   {
        return integerValue;
    }

    public void setIntegerValue int integerValue  {
        this.integerValue = integerValue;
    }

    public RealmList&lt;Test&gt; getTests   {
        return tests;
    }

    public void setTests RealmList&lt;Test&gt; tests  {
        this.tests = tests;
    }
}

    public void testLists   {
        Test one = new Test  ;
        one.setIntegerValue 1 ;
        Test two = new Test  ;
        two.setIntegerValue 2 ;

        testRealm.beginTransaction  ;
        try {
            one = testRealm.copyToRealm one ;
            two = testRealm.copyToRealm two ;

            two.setTests new RealmList&lt;Test&gt; one  ;
            two.setTests new RealmList&lt;Test&gt; one  ;

            testRealm.commitTransaction  ;
        } catch  Exception e  {
            testRealm.cancelTransaction  ;
            fail  ;
        }

        assertThat two.getTests  .size  , equalTo 1  ;
    }

		</Code>
                        
                <Description>Using Realm Im a little confused with this test I made:I need to use two. get Tests clear before setting it again to get the expected result.</Description>
                        
                <CreatedDate>21/05/2015</CreatedDate>
                        
                <ClosedDate>21/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1138</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Added sorting and case In sensitive limitations to JavaDoc.</Title>
            
        <Description>Fixes emanuelez kneth </Description>
            
        <CreatedDate>20/05/2015</CreatedDate>
            
        <ClosedDate>20/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1138</PullRequestID>
                        
                <IssueID>1069</IssueID>
                        
                <Title>DOC Realm Query CASE INSENSITIVE is not insensitive for special character</Title>
                        
                <Description>When using the query below on the following text JSANG SJMATit does not get hits on js or J, but hits on JS and js contains name search Edit Text get Text toString Realm Query CASE INSENSITIVE Seems that it does not support nonenglish characters.</Description>
                        
                <CreatedDate>24/04/2015</CreatedDate>
                        
                <ClosedDate>20/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1117</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm List method snow fail if not within write transaction</Title>
            
        <Description>Fixes All Realm List methods that require to be inside a write transaction now throw an exception if they are not. Also added unit tests for Realm and Realm Results.  emanuelez kneth </Description>
            
        <CreatedDate>12/05/2015</CreatedDate>
            
        <ClosedDate>18/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1117</PullRequestID>
                        
                <IssueID>1112</IssueID>
                        
                <Title>Possible to call Realm List clear outside a write transaction</Title>
                        
                <Description>It looks like it is possible to call Realm List clear outside a write transaction which can cause core to crash in some cases. Unit test exposing the issue is here There should be unit tests for all functions that modify Realm</Description>
                        
                <CreatedDate>12/05/2015</CreatedDate>
                        
                <ClosedDate>18/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1116</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Tighter check when validating tables with links</Title>
            
        <Description>This is fixes originally reported in emanuelez cmelchior bmunkholm</Description>
            
        <CreatedDate>12/05/2015</CreatedDate>
            
        <ClosedDate>20/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1116</PullRequestID>
                        
                <IssueID>1114</IssueID>
                        
                <Title>Check if migration is needed is too loose for RealmList</Title>
                        
                <Description>If a model class has a Realm List A field is change to a Realm List B the proxy class validate Table will not throw a Migration Is Needed exception. This can lead to an inconsistent Realm file as discovered in.</Description>
                        
                <CreatedDate>12/05/2015</CreatedDate>
                        
                <ClosedDate>20/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1116</PullRequestID>
                        
                <IssueID>1094</IssueID>
                        
                <Title>Realm List clear causes SIGSEGV in Link View native Clear</Title>
                        
                <Code> 
        long   scanItemId   = 1;
        String partialTitle = "Man";

        ScanItem scanItem = realm.where ScanItem.class .equalTo "id", scanItemId .findFirst  ;

        // Do the search of our local database
        boolean caseSensitive = false;
        RealmResults&lt;Movie&gt; movieList = realm.where Movie.class .contains "title", partialTitle, caseSensitive .findAllSorted "title" ;

        realm.beginTransaction  ;

        scanItem.getMovieResultList  .clear  ;        // &lt; crashes here
        scanItem.getMovieResultList  .addAll movieList ; // &lt; or, sometimes crashes here

        realm.commitTransaction  ;

public class Movie extends RealmObject implements Filterable {


    private long                id = 1;

    private String              title;

    private RealmList&lt;Isbn&gt;     isbns = new RealmList&lt;&gt;  ;

    private int                 year;

    private Series              series;
    private int                 numberInSeries;

    private RealmList&lt;Person&gt;   actors = new RealmList&lt;&gt;  ;
    private RealmList&lt;Person&gt;   directors = new RealmList&lt;&gt;  ;

    private String              imdbId; // eg "tt0796365"

    private String              lentTo;
    private boolean             got;
    private boolean             seen;
    private boolean             want;
    private int                 rating;
    private String              comments;

    private String              description;

    public Movie   {
    }

    public Movie String title  {
        this.title = title;
    }
// getters, setters, etc removed
}

public class ScanItem extends RealmObject {
    @PrimaryKey
    private long                id = 1;

    / If we know the ISBN or movie title, fill them in here /
    private String              isbn = "";
    private String              title = "";

    / The movie stored in the local database /
    private long                dbMovieId = 1;

    / The movie we retrieved from the web /
    private DvdItem             webMovie;

    / A list of movies indicates that the user needs to choose one, as we don't know which one it is /
    private RealmList&lt;Movie&gt;    movieResultList = new RealmList&lt;&gt;  ;

    / A list of movies indicates that the user needs to choose one, as we don't know which one it is /
    private RealmList&lt;DvdItem&gt;  webResultList = new RealmList&lt;&gt;  ;

    / If we are in the process of doing a lookup, track the progress here /
    private int                 lookupStatus = LookupStatus.NONE.ordinal  ;

    / If we need the user to guide us, set this to what we need to know, so the user can be asked /
    private int                 askUserRequest = AskUserRequest.NONE.ordinal  ;

    / If we get an exception, store it here so we can inform the user what happened /
    private String              exceptionMessage = "";

    private boolean             locked = false;

    public ScanItem   {
    }
// getters, setters, etc removed
}
</Code>
                
                <stacktrace>
0506 18:45:43.319  2100721007/? D/dalvikvm Trying to load lib /data/applib/com.stevem.collection.dvd1/librealmjni.so 0xa4f3caa0
0506 18:45:43.319  2100721007/? D/dalvikvm Added shared lib /data/applib/com.stevem.collection.dvd1/librealmjni.so 0xa4f3caa0
0506 18:45:47.069  2100721007/? A/libc Fatal signal 11  SIGSEGV  at 0x49b67510  code=1 , thread 21007  .collection.dvd 
0506 18:45:47.189      936936/? I/DEBUG                
0506 18:45:47.189      936936/? I/DEBUG Build fingerprint: 'generic_x86/sdk_x86/generic_x86:4.4.2/KK/999428:eng/testkeys'
0506 18:45:47.189      936936/? I/DEBUG Revision: '0'
0506 18:45:47.189      936936/? I/DEBUG pid: 21007, tid: 21007, name: .collection.dvd  &gt;&gt;&gt; com.stevem.collection.dvd &lt;&lt;&lt;
0506 18:45:47.189      936936/? I/DEBUG signal 11  SIGSEGV , code 1  SEGV_MAPERR , fault addr 49b67510
0506 18:45:47.339      936936/? I/DEBUG eax b8d74d40  ebx 96714e30  ecx 000c0300  edx bff220c8
0506 18:45:47.339      936936/? I/DEBUG esi b8d74d40  edi 49b6750c
0506 18:45:47.339      936936/? I/DEBUG xcs 00000073  xds 0000007b  xes 0000007b  xfs 00000000  xss 0000007b
0506 18:45:47.339      936936/? I/DEBUG eip 96646630  ebp bff220b8  esp bff220a0  flags 00210217
0506 18:45:47.339      936936/? E/Corkscrew unrecognized dwarf lower part encoding: 0x59
0506 18:45:47.339      936936/? I/DEBUG backtrace:
0506 18:45:47.349      936936/? I/DEBUG 00  pc 00083630  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG 01  pc 000836da  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG 02  pc 0009e7d8  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG stack:
0506 18:45:47.349      936936/? I/DEBUG bff22060  00000088
0506 18:45:47.349      936936/? I/DEBUG bff22064  00000000
0506 18:45:47.349      936936/? I/DEBUG bff22068  bff22088  stack
0506 18:45:47.349      936936/? I/DEBUG bff2206c  9662c9de  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG bff22070  0000005b
0506 18:45:47.349      936936/? I/DEBUG bff22074  b7624196  /system/lib/libc.so  malloc+6 
0506 18:45:47.349      936936/? I/DEBUG bff22078  96714e30  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG bff2207c  966911f8  /data/applib/com.stevem.collection.dvd1/librealmjni.so  operator new unsigned int +40 
0506 18:45:47.349      936936/? I/DEBUG bff22080  00000088
0506 18:45:47.349      936936/? I/DEBUG bff22084  b8c355c8  heap
0506 18:45:47.349      936936/? I/DEBUG bff22088  b8d74c00  heap
0506 18:45:47.349      936936/? I/DEBUG bff2208c  000c0300
0506 18:45:47.349      936936/? I/DEBUG bff22090  b8d74d40  heap
0506 18:45:47.349      936936/? I/DEBUG bff22094  e06c0c9e
0506 18:45:47.349      936936/? I/DEBUG bff22098  bff220b8  stack
0506 18:45:47.349      936936/? I/DEBUG bff2209c  96617cd6  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG 00  bff220a0  b8d28614  heap
0506 18:45:47.349      936936/? I/DEBUG bff220a4  e06c0c9e
0506 18:45:47.349      936936/? I/DEBUG bff220a8  bff220c8  stack
0506 18:45:47.349      936936/? I/DEBUG bff220ac  9664675b  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG bff220b0  b8d74d40  heap
0506 18:45:47.349      936936/? I/DEBUG bff220b4  e06c0c9e
0506 18:45:47.349      936936/? I/DEBUG bff220b8  bff220d8  stack
0506 18:45:47.349      936936/? I/DEBUG bff220bc  966466db  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG 01  bff220c0  00000005
0506 18:45:47.349      936936/? I/DEBUG bff220c4  b8c353b0  heap
0506 18:45:47.349      936936/? I/DEBUG bff220c8  49b6750c
0506 18:45:47.349      936936/? I/DEBUG bff220cc  e06c0c9e
0506 18:45:47.349      936936/? I/DEBUG bff220d0  b8d73e30  heap
0506 18:45:47.349      936936/? I/DEBUG bff220d4  bff22100  stack
0506 18:45:47.349      936936/? I/DEBUG bff220d8  bff22128  stack
0506 18:45:47.349      936936/? I/DEBUG bff220dc  966617d9  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG bff220e0  bff22100  stack
0506 18:45:47.349      936936/? I/DEBUG bff220e4  b8d28614  heap
0506 18:45:47.349      936936/? I/DEBUG bff220e8  e06c0c9e
0506 18:45:47.349      936936/? I/DEBUG bff220ec  96612696  /data/applib/com.stevem.collection.dvd1/librealmjni.so
0506 18:45:47.349      936936/? I/DEBUG bff220f0  ffffffff
0506 18:45:47.349      936936/? I/DEBUG bff220f4  b8d743c0  heap
0506 18:45:47.349      936936/? I/DEBUG bff220f8  0000002e
0506 18:45:47.349      936936/? I/DEBUG bff220fc  b8d73e30  heap
0506 18:45:47.349      936936/? I/DEBUG memory map around fault addr 49b67510:
0506 18:45:47.349      936936/? I/DEBUG  no map below 
0506 18:45:47.349      936936/? I/DEBUG  no map for address 
0506 18:45:47.349      936936/? I/DEBUG 964ff00096500000 rw /data/data/com.stevem.collection.dvd/files/default.realm.lock
0506 18:45:47.409    12751297/system_process D/dalvikvm GC_FOR_ALLOC freed 685K, 22% free 6016K/7652K, paused 0ms, total 0ms
0506 18:45:47.409    12751297/system_process I/BootReceiver Copying /data/tombstones/tombstone_08 to DropBox  SYSTEM_TOMBSTONE 
0506 18:45:47.429      939939/? D/Zygote Process 21007 terminated by signal  11 

</stacktrace>
                        
                <Description>Ive been using Realm in my Android app for a couple of months now, and changed from about a week ago. Ive had no major issues so far, until I added the following code 		Any ideas on what might be causing this, or any suggestions on how I might diagnose this further would be greatly appreciated Thanks Steve</Description>
                        
                <CreatedDate>06/05/2015</CreatedDate>
                        
                <ClosedDate>20/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1115</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>emanuelez</FixedByID>
            
        <Title>Fix a memory leak in Realm Base Adapter</Title>
            
        <Description>Fixes We now use WeakReferences to store the change listeners. This allows the Garbage Collector to clean up the adapters.</Description>
            
        <CreatedDate>12/05/2015</CreatedDate>
            
        <ClosedDate>12/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1115</PullRequestID>
                        
                <IssueID>1109</IssueID>
                        
                <Title>Possibility of a memory leak due to a combination of Realm Change Listener and automatic Update</Title>
                        
                <Description>Reported by Realm Change Listener is added to Realm when automatic Update is true. Then the listener instance was not released until the Realm instance is released because the Realm Change Listener is never deleted. 		Since a listener instance is an anonymous inner class of Realm Base Adapter, it holds a reference to the Realm Base Adapter as an enclosing instance.Realm Base Adapter usually holds a reference to the Activity that uses it as Context. So these instances will not be released until the Realm instance is released.If you use Realm in only one Activity, 		there is no problem because Realm close is called when the Activity is destroyed. Strictly speaking, adapters may be accumulated if recreate a Realm Base Adapter while the Activity is alive. 		On the other hand, if you use two activities, there are main activity and another activity that has List View,each activity uses Realm, the Realm instance is held in cache until onDestroy of main activity is called. 		For example if you transition between the two Activities as follows, Main List back List back List 	I think the Realm Change Listener may be accumulated in the Realm. What do you think cmelchior emanuelez </Description>
                        
                <CreatedDate>11/05/2015</CreatedDate>
                        
                <ClosedDate>12/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1113</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Add java lang prefix to throws comment to avoid ambiguity.</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>12/05/2015</CreatedDate>
            
        <ClosedDate>12/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1108</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Add Java doc comment which specifies that Realm delete Realm File throws Illegal State Exception if target Reealm file is not closed.</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>11/05/2015</CreatedDate>
            
        <ClosedDate>20/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1099</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>zaki50</FixedByID>
            
        <Title>Accept null Realm Results for Realm Base Adapter refs</Title>
            
        <Description>Fixes </Description>
            
        <CreatedDate>08/05/2015</CreatedDate>
            
        <ClosedDate>11/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1099</PullRequestID>
                        
                <IssueID>1086</IssueID>
                        
                <Title>Realm Base Adapter with null Realm Results</Title>
                        
                <Description>Can you please handle null realm Results within Realm Base Adapter if the adapter has no content at all and Realm Query possibly returns null too it doesn't make sense for Realm Base Adapter to not accepting null Example</Description>
                        
                <CreatedDate>04/05/2015</CreatedDate>
                        
                <ClosedDate>11/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1096</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Fix Date and byte being reset when using create Or Update From Json</Title>
            
        <Description>Fixes Date and byte fields where incorrectly reset even though this bug was fixed in the last release. Lesson learned Remember to unit test all types emanuelez kneth </Description>
            
        <CreatedDate>07/05/2015</CreatedDate>
            
        <ClosedDate>11/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1096</PullRequestID>
                        
                <IssueID>1095</IssueID>
                        
                <Title>Date field gets reset to default value on create Or Update All FromJ son</Title>
                        
                <Description>Unlike suggested by the change log Realm create Or Update With Json no longer resets fields to their default value if they are not found in the JSON input 		create Or Update All From Json resets Date fields to beginning of time when the corresponding value is missing in the input JSON</Description>
                        
                <CreatedDate>07/05/2015</CreatedDate>
                        
                <ClosedDate>11/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1075</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>UpdatingtoRealmCore0.89.1</Title>
            
        <Description>This is required for bmunkholm emanuelez cmelchior 
</Description>
            
        <CreatedDate>29/04/2015</CreatedDate>
            
        <ClosedDate>30/04/2015</ClosedDate>
            
        <PullRequestLabels>
                  
            <PullRequestLabel>TInternal</PullRequestLabel>
                
        </PullRequestLabels>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1073</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Primary key table should match Cocoa primary key table</Title>
            
        <Description>Fixes This silently upgrades any Realms that are wrong, but adds a little extra overhead first time we check for primary keys  they are cached after that. We should consider for how long we should support this code snippet, as it is both an overhead plus code we have to maintain.
emanuelez kneth </Description>
            
        <CreatedDate>28/04/2015</CreatedDate>
            
        <ClosedDate>19/05/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1073</PullRequestID>
                        
                <IssueID>1059</IssueID>
                        
                <Title>Unable to use a realm database file created with realm with</Title>
                        
                <Description>I have a realm database file created using realm that works fine under that version. After changing gradle to pull in I get an exception thrown that a migration is needed.  		Using the following I create a migration:It would be helpful if the column type error would actually state what table the error was in to help with debugging. However, the real problem is that I cannot use the realm file.  		All of the tables id field are defined as longs so I am unable to determine why the ColumnType STRING factors in anywhere.</Description>
                        
                <CreatedDate>21/04/2015</CreatedDate>
                        
                <ClosedDate>19/05/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1065</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm Migration Needed Exception can now return the path to the Realm</Title>
            
        <Description>Fixes emanuelez kneth zaki50</Description>
            
        <CreatedDate>23/04/2015</CreatedDate>
            
        <ClosedDate>29/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1065</PullRequestID>
                        
                <IssueID>1060</IssueID>
                        
                <Title>Realm Migration Needed Exception should have get Absolute Path </Title>
                        
                <Description>Id like to write schema check code as follows.</Description>
                        
                <CreatedDate>21/04/2015</CreatedDate>
                        
                <ClosedDate>29/04/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TEnhancement</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1057</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Added quick guide to using Realm with gradle.</Title>
            
        <Description>Fixes Especially the SNAPSHOT description was missing since I have been pointing a lot of people to that lately in order to test bug fixes.bmunkholm timanglade emanuelez kneth 
</Description>
            
        <CreatedDate>21/04/2015</CreatedDate>
            
        <ClosedDate>22/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1056</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Throw exception if using copy To Realm Or Update with a null primary key value</Title>
            
        <Description>Fixes We now throw a proper exception instead of crashing core. emanuelez bmunkholm kneth </Description>
            
        <CreatedDate>21/04/2015</CreatedDate>
            
        <ClosedDate>29/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1056</PullRequestID>
                        
                <IssueID>1051</IssueID>
                        
                <Title>copy To Realm Or Update SIGSEGV</Title>
                		
                <Code> 
		public class PrimaryKeyTest extends RealmObject {

			@PrimaryKey
			private String key;

			public String getKey   {
				return key;
			}

			public void setKey String key  {
				this.key = key;
			}
		}

		public void testPrimKeyMissing   {
				testRealm.beginTransaction  ;
				try {
					testRealm.copyToRealmOrUpdate new PrimaryKeyTest   ;
					testRealm.commitTransaction  ;
				} catch  Exception e  {
					// OK
					testRealm.cancelTransaction  ;
				}
		}
		</Code>
                        
                <Description>Hi Following an update in my code, I randomly found a native crash  SIGSEGV  when using copy To Realm Or Update and an object with a declared Primary Key which was not set before copy.Using Realm To reproduce with a Instrumentation run failed due to Native crash</Description>
                        
                <CreatedDate>20/04/2015</CreatedDate>
                        
                <ClosedDate>29/04/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1054</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm IDs are now its absolute path instead of its hash code</Title>
            
        <Description>Fixes emanuelez bmunkholm kneth </Description>
            
        <CreatedDate>20/04/2015</CreatedDate>
            
        <ClosedDate>28/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1054</PullRequestID>
                        
                <IssueID>1040</IssueID>
                        
                <Title>expecting absolute Path hashCode not to collide each other</Title>
                        
                <Description> absolute Path hash Code is used as key of some HashMaps realmsCache reference Count etc If hash code of absolute Path collides with each other wrong Realm instance is returned on Realm getInstance</Description>
                        
                <CreatedDate>16/04/2015</CreatedDate>
                        
                <ClosedDate>28/04/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1032</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>kneth</FixedByID>
            
        <Title>Update change log due to Realm Core update</Title>
            
        <Description>bmunkholm suggests in that we mention Realm Core updates in the change log bmunkholm emanuelez cmelchior </Description>
            
        <CreatedDate>15/04/2015</CreatedDate>
            
        <ClosedDate>16/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues/>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1022</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm copy Or Update From Json shouldnt update unset properties</Title>
            
        <Description>Fixes Realm copy Or Update From Json shouldnt update properties if the property doesnt exist in the JSON. Right now it gets updated with the default value, which confuses users  and is also a bit weird .</Description>
            
        <CreatedDate>09/04/2015</CreatedDate>
            
        <ClosedDate>16/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1022</PullRequestID>
                        
                <IssueID>933</IssueID>
                        
                <Title>create Or Update From Json also updates fields not set</Title>
                        
                <Description>If you update a existing Realm Object using Realm create Or Update From Json it correctly creates default values for fields not set, however if a existing Realm Object is found the expected behavior would be to only override the fields actually set, eg</Description>
                        
                <CreatedDate>06/03/2015</CreatedDate>
                        
                <ClosedDate>16/04/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
      
    <PullRequest>
            
        <IssueID>1021</IssueID>
            
        <RepoID>realmjava</RepoID>
            
        <FixedByID>cmelchior</FixedByID>
            
        <Title>Realm copy To Realm now ignore referenced Realm objects</Title>
            
        <Description>Fixes This PR fixes a bug in Realm copy To Realm that caused it to try to copy referenced Realm Objects that already existed in the Realm. This would either duplicate them or crash if that object contained a primary key.emanuelez kneth bmunkholm 
</Description>
            
        <CreatedDate>09/04/2015</CreatedDate>
            
        <ClosedDate>14/04/2015</ClosedDate>
            
        <PullRequestLabels/>
            
        <Issues>
                  
            <Issue>
                        
                <RepoID>realmjava</RepoID>
                        
                <PullRequestID>1021</PullRequestID>
                        
                <IssueID>1006</IssueID>
                        
                <Title>copy To Realm tries to copy nested objects even if they are already in the Realm</Title>
                        
                <Code> 
        realm.beginTransaction;
        UserRealm brother = realm.createObject UserRealm.class;
        brother.setToken "brother";
        UserRealm user = new UserRealm;
        user.setToken "token";
        user.setBrother brother;
        realm.copyToRealm user;
        realm.commitTransaction ;  
        </Code>
                        
                <Description>Hey guys This piece of code leads to the exception Caused by io realm exceptions Realm Exception Primary key constraint broken. Value already exists brother Changing copy To Realm to copy To Realm Or Update solves it. 		Using UserRealm user = realm create Object User Realm class  also solves it. It looks like even though brother is an object from the DB Realm anyway treats it as a new object during the copy To Realm. 		Its either a bug or a confusing design.</Description>
                        
                <CreatedDate>01/04/2015</CreatedDate>
                        
                <ClosedDate>14/04/2015</ClosedDate>
                        
                <Labels>
                              
                    <Label>TBug</Label>
                            
                </Labels>
                      
            </Issue>
                
        </Issues>
          
    </PullRequest>
    
</PullRequests>
