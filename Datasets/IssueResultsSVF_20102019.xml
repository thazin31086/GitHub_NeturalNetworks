<Issues>
  <Issue>
    <IssueID>158</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix an incorrect function call #157</Title>
    <Description>Fix an incorrect function call #157</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>157</IssueID>
    <RepoID>1</RepoID>
    <Title>Incorrect function call in SVF</Title>
    <Description>Hi, SVF developers.

At https://github.com/SVF-tools/SVF/blob/master/include/Util/ThreadAPI.h#L159
I think it must call "getActualParmAtForkSite". 
Look like a small mistake. But, it may generate a wrong result.
Is that correct?</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>156</IssueID>
    <RepoID>1</RepoID>
    <Title>Building SVF as a shared library</Title>
    <Description>Hi, first thank you for sharing and maintaining such a great project!

I'm trying to write my own LLVM pass and declare WPAPass as a dependency so as to get alias results of pointers and memory locations. In order to declare WPAPass as a dependency, I need to build a shared library of SVF and load it using `opt`.

SVF is built as a static library by default. I tried to build SVF as a shared library for my project but I encountered the problem described in #53. Even after I removed `${llvm_libs}`, I got segmentation fault querying alias results, which makes me think that SVF is not designed to be used as a shared library at its design phase.

So my questions are, first, what's the initial design reasoning for SVF, why building it as a static library instead of a shared library? Second, is there any way I can build SVF as a shared library so that I can load and declare WPAPass as my dependency to use AliasAnalysis? Thank you!</Description>
    <CreatedDate>18/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>155</IssueID>
    <RepoID>1</RepoID>
    <Title>fix the bug of scc detection before procAddr</Title>
    <Description>
    </Description>
    <CreatedDate>12/10/2019</CreatedDate>
    <ClosedDate>15/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>154</IssueID>
    <RepoID>1</RepoID>
    <Title>Call graph in JSON format</Title>
    <Description>Does SVF provide any options for dumping the call graph in JSON format? (Or other graphs such as class hierarchy graph)

If not, is there any plan for supporting the feature, or could you provide some guidance for implementing one? Thank you!</Description>
    <CreatedDate>09/10/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>153</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion failed: `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"'</Title>
    <Description>While performing a flow-sensitive analysis of the attached C program, SVF-1.7 (commit# 878c3b1eca06f569760ee312996b623986d3525d) fails with the following assertion:

```
$ wpa -fspta -print-pts svf_crash.bc

wpa: svf/include/Util/VFG.h:186: ActualParmVFGNode* VFG::getActualParmVFGNode(const PAGNode*, CallSite) const: Assertion `it!=PAGNodeToActualParmMap.end() &amp;&amp; "acutal parameter VFG node can not be found??"' failed.
```



[svf_crash.zip](https://github.com/SVF-tools/SVF/files/3699920/svf_crash.zip)
</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>152</IssueID>
    <RepoID>1</RepoID>
    <Title>Maintain backwards compatibility</Title>
    <Description>`FunctionCallee` was only introduced in LLVM 9.</Description>
    <CreatedDate>07/10/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>151</IssueID>
    <RepoID>1</RepoID>
    <Title>Add debug-related types to BasicTypes.</Title>
    <Description>As title. </Description>
    <CreatedDate>03/10/2019</CreatedDate>
    <ClosedDate>03/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>150</IssueID>
    <RepoID>1</RepoID>
    <Title>SVF crashes while writing results of Andersen analysis</Title>
    <Description>While writing Andersen analysis result to a file, SVF hits the assertion and crashes.

```
$ ./wpa -ander -write-ander=write_ander.txt test.bc

Storing pointer analysis results to 'write_ander.txt'...wpa: svf/include/MemoryModel/GenericGraph.h:338: GenericGraph&lt;NodeTy, EdgeTy&gt;::NodeType* GenericGraph&lt;NodeTy, EdgeTy&gt;::getGNode(NodeID) const [with NodeTy = PAGNode; EdgeTy = PAGEdge; GenericGraph&lt;NodeTy, EdgeTy&gt;::NodeType = PAGNode; NodeID = unsigned int]: Assertion `it != IDToNodeMap.end() &amp;&amp; "Node not found!"' failed.
Aborted (core dumped)
```

In `PointerAnalysis.cpp:writeToFile()`, when SVF tries to write PAG offset nodes to the file, there are 163 total nodes in the test case (attached). However, the last one has a large `nodeID` (`720000`) which looks like a junk value. Further down in `GepObjPN *gepObjPN = SVFUtil::dyn_cast&lt;GepObjPN&gt;(pag-&gt;getPAGNode(i))`, it fails to find the node when the index (`162`) is used to retrieve the node instead of the `nodeID` (`720000`). Upon further investigation, I noticed the node in question is inserted in the PAG during `WPASolver.h:solve()` call.

The source code and the bitcode of the offending test case are attached.

[test.zip](https://github.com/SVF-tools/SVF/files/3636738/test.zip)
</Description>
    <CreatedDate>20/09/2019</CreatedDate>
    <ClosedDate>04/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>149</IssueID>
    <RepoID>1</RepoID>
    <Title>addrCGEdge</Title>
    <Description>
    </Description>
    <CreatedDate>09/09/2019</CreatedDate>
    <ClosedDate>11/09/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>148</IssueID>
    <RepoID>1</RepoID>
    <Title>Question on usage of pointer analysis</Title>
    <Description>Hi!

Thanks for sharing and maintaining such a great project!

I'm trying to use Andersen's analysis (DiffWave) in order to find aliases between pointer operands. Now there are obvious aliases that I cannot be able to detect, and I highly suspect that I'm just using the analysis in a wrong way. I've read related issues and have been debugging but I didn't get to the correct alias info yet, so I figured it might be faster to ask you directly.

This is an excerpt of the piece of code I'm currently analyzing:

```
  %76 = load %"class.soplex::SVector"**, %"class.soplex::SVector"*** %data.i109, align 8, !dbg !4458
  %arrayidx.i111 = getelementptr inbounds %"class.soplex::SVector"*, %"class.soplex::SVector"** %76, i64 %idxprom.i149, !dbg !4458
  store %"class.soplex::SVector"* %cond-lvalue.i141, %"class.soplex::SVector"** %arrayidx.i111, align 8, !dbg !4459
// .. some irrelevant code (debug info and ++i) ..
  %77 = load %"class.soplex::SVector"**, %"class.soplex::SVector"*** %data.i109, align 8, !dbg !4464
  %arrayidx.i108 = getelementptr inbounds %"class.soplex::SVector"*, %"class.soplex::SVector"** %77, i64 %idxprom.i149, !dbg !4464
  %78 = load %"class.soplex::SVector"*, %"class.soplex::SVector"** %arrayidx.i108, align 8, !dbg !4465
```

The store and the load to %78 should clearly alias, since the store is updating the value that is loaded afterwards. However, I always get NoAlias.

I'm using Andersen in the following way, using it with opt and the -ander flag on my LLVM IR:
```c++
WPAPass *wpa = new WPAPass();
wpa-&gt;runOnModule(&amp;M);
Value *LPointer = Load-&gt;getPointerOperand();
Value *SPointer = Store-&gt;getPointerOperand();
wpa-&gt;alias(LPointer, SPointer) // always gives me NoAlias
```
I plotted the PAG and it is reflected there that they are linked to each other (see [pag](https://gofile.io/?c=qnuE8J) here). Looking at their (LPointer, SPointer) points-to-set (given the node ids in the pag) they are completely empty. 

What am I doing wrong?

I'm currently using the latest version of SVF on LLVM 8.0 (I made a few *syntactical* changes to be updated to the latest LLVM, not anything more than that). I saw that the DominanceFrontier is used in some tools, which doesn't exist in the latest LLVM anymore, but I'm only using the PointerAnalysis itself, which shouldn't be affected.

Best,

Kim

</Description>
    <CreatedDate>05/09/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>147</IssueID>
    <RepoID>1</RepoID>
    <Title>Unable to build getting error: llvm/IR/Attributes.inc: No such file or directory</Title>
    <Description>Getting this below error while trying build SVF from source by following the instruction from [Setup-Guide-(CMake)](https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake)).

using gcc 9.1.0
cmake 3.15.2
Also  built LLVM-7.0.0, clang-7.0.0 and added the paths for it.

```
In file included from /llvm-7.0.0.src/include/llvm/IR/Instructions.h:27,
                 from /SVF/include/Util/BasicTypes.h:39,
                 from /SVF/include/Util/SVFModule.h:33,
                 from /SVF/include/Util/SVFUtil.h:33,
                 from /SVF/lib/Util/SVFUtil.cpp:30:
/llvm-7.0.0.src/include/llvm/IR/Attributes.h:74:14: fatal error: llvm/IR/Attributes.inc: No such file or directory
   74 |     #include "llvm/IR/Attributes.inc"
      |              ^~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```
</Description>
    <CreatedDate>30/08/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>146</IssueID>
    <RepoID>1</RepoID>
    <Title>Unknown command line arguement</Title>
    <Description>Hi, When I follow the simple C program example and type `wpa -type -dump-icfg swap.opt`, it shows unkonwn command line arguement '-dump-icfg'. And I continue to search by wpa -help, there seems no "-dump-icfg' command. Please help. Thank you very much.</Description>
    <CreatedDate>30/08/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>145</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge with private repo of SVF</Title>
    <Description>
    </Description>
    <CreatedDate>30/08/2019</CreatedDate>
    <ClosedDate>30/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>144</IssueID>
    <RepoID>1</RepoID>
    <Title>Partial alias. Question.</Title>
    <Description>Hello,

I have a question about partial aliasing. Does svf (for LLVM version 3.8.1) support it? In case it does not, how does it treat partial aliasing (as may or no alias)? </Description>
    <CreatedDate>15/08/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>143</IssueID>
    <RepoID>1</RepoID>
    <Title>Andersen Analysis on Small program </Title>
    <Description>We ran a small test program using (-ander) the Andersen implementation
int **p,*x,*y,a;
   p=&amp;x;
   p=&amp;y;
   *p=&amp;a;
  NOALIAS(x,y);  // It is giving Success
Is it  not flow-insensitive method should consider x and y as MAYALIAS
</Description>
    <CreatedDate>02/08/2019</CreatedDate>
    <ClosedDate>03/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>142</IssueID>
    <RepoID>1</RepoID>
    <Title>Moving to LLVM 9.0.0</Title>
    <Description>Hello,

I've prepared the patch for LLVM 9.0.0 (this seems to build the Linux kernel):
https://github.com/lifeasageek/SVF/commit/b7c0922ade78da2e13340e25fb5a405ba80b5033

I haven't fully worked through if this is right, so please let me know if something's wrong.
</Description>
    <CreatedDate>25/07/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>141</IssueID>
    <RepoID>1</RepoID>
    <Title>Spelling fix worklist.h</Title>
    <Description>
    </Description>
    <CreatedDate>24/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>140</IssueID>
    <RepoID>1</RepoID>
    <Title>Typo fix in MTA.cpp</Title>
    <Description>
    </Description>
    <CreatedDate>16/07/2019</CreatedDate>
    <ClosedDate>17/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>139</IssueID>
    <RepoID>1</RepoID>
    <Title>ModRef Analysis and Context sensitivity</Title>
    <Description>I was trying the following example
#include "aliascheck.h"
int **p,**q,**r;
int *x,*y,*z,*w,*v;
int a,b,c;
void f(){
 *p=y;
}
void g() {
   p=&amp;w;
   y=&amp;c;
    f();
   v=w;
 MUSTALIAS(v,y);
}
main() {
  p=&amp;x;
  y=&amp;b;
   f();
  z=x;
MUSTALIAS(z,y);
}

modified SVF code to get the points-to Info at MUSTALIAS call, 
main
z points to {c,b} 
y points to {b}
g
v points to {c,b} 
y points to {c}
why the result is context insensitive?ran wpa with fspta option.
May I know the portion of code containing CFL reachability?</Description>
    <CreatedDate>15/07/2019</CreatedDate>
    <ClosedDate>25/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>138</IssueID>
    <RepoID>1</RepoID>
    <Title>Corrected Method Spelling (vefityCallGraph -&gt; verifyCallGraph)</Title>
    <Description>As suggested by https://github.com/nix7965 in https://github.com/SVF-tools/SVF/issues/133</Description>
    <CreatedDate>10/07/2019</CreatedDate>
    <ClosedDate>12/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>137</IssueID>
    <RepoID>1</RepoID>
    <Title>SVF Tool Integration Interface</Title>
    <Description>I'm trying to use SVF in a Static Thread Sharing Analysis project of mine, and I'd like to use the data without having SVF output and then reinterpret it. I mainly looked for something quite simple (getThreads(), getMethods(), getStatements(), etc.), so I may have missed something built-in. 

In the event that this functionality is not built-in however, I assume that an interface must have been made already. Rather than have everyone individually re-code or have to create a custom version of SVF for each project that uses something similar, is there a public version I should know about?

For reference my project is fairly general and requires data of all Threads, Methods, 
Memory Allocation Statements, and Method Call Statements. It would use this information along with the PAG generated by the SVF tool.</Description>
    <CreatedDate>10/07/2019</CreatedDate>
    <ClosedDate>11/08/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>136</IssueID>
    <RepoID>1</RepoID>
    <Title>Broken Link in License</Title>
    <Description>SVF/LICENSE.TXT refers to https://github.com/unsw-corg/SVF/blob/gh-pages/Contributors.txt as the place to find contributors to the SVF project, however this link seems to be outdated (the website no longer works). Perhaps linking to https://github.com/SVF-tools/SVF/graphs/contributors instead would be good although this includes all contributors instead of just main contributors.</Description>
    <CreatedDate>09/07/2019</CreatedDate>
    <ClosedDate>16/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>135</IssueID>
    <RepoID>1</RepoID>
    <Title>Spelling fix in tools/wpa.cpp</Title>
    <Description>
    </Description>
    <CreatedDate>03/07/2019</CreatedDate>
    <ClosedDate>04/07/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>134</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix the arguments to WriteBitcodeToFile function</Title>
    <Description>WriteBitcodeToFile expectes reference to the Module object: https://llvm.org/doxygen/BitcodeWriter_8cpp_source.html#l04360

Error details:
~/SVF/lib/Util/SVFModule.cpp:371:36: error: cannot convert 'llvm::Module' to 'const llvm::Module*' for argument '1' to 'void llvm::WriteBitcodeToFile(const llvm::Module*, llvm::raw_ostream&amp;, bool, const llvm::ModuleSummaryIndex*, bool, llvm::ModuleHash*)'
         WriteBitcodeToFile(*mod, OS);</Description>
    <CreatedDate>30/06/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>133</IssueID>
    <RepoID>1</RepoID>
    <Title>Function name typo in SVF</Title>
    <Description>Hi, developers.

I just realized that there is a function named "vefityCallGraph".
I guess you may want to name it "ve'r'ifyCallGraph".
If what I said is correct, you may want to modify it..?</Description>
    <CreatedDate>28/06/2019</CreatedDate>
    <ClosedDate>18/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>132</IssueID>
    <RepoID>1</RepoID>
    <Title>Imprecise analysis results</Title>
    <Description>Hi,

Thanks a lot for providing such a useful tool. 
I am trying to generate a fine-grained call graph for a (large) kernel. For this problem, I am using SVF to generate points-to sets for pointer operands of indirect call Instructions.  I have used the Diff wave propagation inclusion-based analysis.
After going through the results, one issue that I see is that for 900 of these call sites, the target set is exactly the same and contains more than 6500 functions (which is one third of the total number of functions in my IR). Most of these functions seem completely unrelated to the call sites. 

Can you help me in figuring out what is going on?
Is it possible that you guys are using a conservative approach (e.g. signature matching) to overestimate the points-to set that is leading to this result?

Thanks.</Description>
    <CreatedDate>19/06/2019</CreatedDate>
    <ClosedDate>21/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>131</IssueID>
    <RepoID>1</RepoID>
    <Title>make SVF failed</Title>
    <Description>my environment is：
llvm 6.0.0
clang 6.0.0
when i go to step 6 to make SVF 
```
[ 69%] Built target LLVMCudd
[ 69%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/Conditions.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadCallGraph.cpp.o
[ 70%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ExtAPI.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PathCondAllocator.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/PTAStat.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/Svf.dir/Util/BreakConstantExpr.cpp.o
[ 71%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/ThreadAPI.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/Svf.dir/Util/Conditions.cpp.o
[ 72%] Building CXX object lib/CMakeFiles/LLVMSvf.dir/MemoryModel/ConsG.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod, OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M, raw_ostream &amp;Out,
       ^
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ExtAPI.cpp.o
1 error generated.
lib/CMakeFiles/LLVMSvf.dir/build.make:218: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/LLVMSvf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
[ 73%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PathCondAllocator.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/PTAStat.cpp.o
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/ThreadAPI.cpp.o
CMakeFiles/Makefile2:165: recipe for target 'lib/CMakeFiles/LLVMSvf.dir/all' failed
make[1]: *** [lib/CMakeFiles/LLVMSvf.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
[ 74%] Building CXX object lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/ConsG.cpp.o
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocationSet.cpp.o
/home/wcc/Downloads/SVF/lib/Util/SVFModule.cpp:371:9: error: no matching
      function for call to 'WriteBitcodeToFile'
        WriteBitcodeToFile(*mod, OS);
        ^~~~~~~~~~~~~~~~~~
/home/wcc/Downloads/llvm-6.0.0.src/include/llvm/Bitcode/BitcodeWriter.h:129:8: note: 
      candidate function not viable: no known conversion from 'llvm::Module' to
      'const llvm::Module *' for 1st argument; remove *
  void WriteBitcodeToFile(const Module *M, raw_ostream &amp;Out,
       ^
[ 75%] Building CXX object lib/CMakeFiles/Svf.dir/MemoryModel/LocMemModel.cpp.o
1 error generated.
lib/CMakeFiles/Svf.dir/build.make:218: recipe for target 'lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o' failed
make[2]: *** [lib/CMakeFiles/Svf.dir/Util/SVFModule.cpp.o] Error 1
make[2]: *** Waiting for unfinished jobs....
CMakeFiles/Makefile2:128: recipe for target 'lib/CMakeFiles/Svf.dir/all' failed
make[1]: *** [lib/CMakeFiles/Svf.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
```
I successed making SVF by using llvm7.0.0+clang7.0.0, but failed in using llvm6.0.0+clang6.0.0
thanks for your help!
</Description>
    <CreatedDate>12/06/2019</CreatedDate>
    <ClosedDate>12/06/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>130</IssueID>
    <RepoID>1</RepoID>
    <Title>Built target LLVMCudd  failed</Title>
    <Description>When I went to 6th step, there is an error.
```
[ 63%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddHarwell.c.o
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddPriority.c.o
[ 64%] Linking C shared module Cudd.so
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddSubsetHB.c.o
[ 64%] Built target Cudd
[ 64%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddGroup.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/cuddZddUtil.c.o
[ 65%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/dddmpNodeAdd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/epd.c.o
[ 66%] Building C object lib/CUDD/CMakeFiles/LLVMCudd.dir/restart.c.o
[ 66%] Linking C static library libLLVMCudd.a
[ 66%] Built target LLVMCudd
Makefile:127: recipe for target 'all' failed
make: *** [all] Error 2
```
I am confused.</Description>
    <CreatedDate>30/05/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>129</IssueID>
    <RepoID>1</RepoID>
    <Title>debug  info problem</Title>
    <Description>Hello, I'm new in LLVM,  and I want to use svf to do some static analysis. I want to find where a struct is defined, Loc and source file.
just like function's dbginfo.
```c
&lt;func1&gt; Source Loc: in line: 24 file: test.c 
```
but I cannot find any interface to get such information. 
How can I get such information with svf ?
Apologize for my little stupid problem. ?</Description>
    <CreatedDate>14/05/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>128</IssueID>
    <RepoID>1</RepoID>
    <Title>How do I use SVF for LLVM MIR level?</Title>
    <Description>Hi all,
I am working on our research project and plan to use svf to perform memory dependence analysis on the LLVM MIR level. But I spot svf operating on the IR level. So can I use svf for LLVM MIR instruction?

Thanks.</Description>
    <CreatedDate>10/05/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>127</IssueID>
    <RepoID>1</RepoID>
    <Title>Small fixes</Title>
    <Description>Fixed WPA pass so that opt can run it and eliminated a bunch of compiler warnings.</Description>
    <CreatedDate>08/05/2019</CreatedDate>
    <ClosedDate>08/10/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>126</IssueID>
    <RepoID>1</RepoID>
    <Title>How to handle extractvalue</Title>
    <Description>I'm working on adapting Saber's leak detection to a similar Source-Sink analysis, and have come across some problems resulting from the `extractvalue` instruction. To make this a bit more concrete, we have some LLVM-IR that basically looks like this:

```llvm
%1 = call { [0 x i32]*, i64 } @get_fat_pointer(i64* nonnull %array.0, i64 %array.1)
%2 = extractvalue { [0xi32]*, i64 } %1, 0
%3 = extractvalue { [0xi32]*, i64 } %1, 1
```

Depending on the inliner &amp; optimization passes, this may end up becoming a GEP instruction that then uses `insertvalue` to operate on a struct in an LLVM register(very similar to the above situation), but will sometimes still stay in this form.

After the SVFG is constructed, I can track the arguments to `get_fat_pointer()` through to the return value, but this connection is lost at the callsite, since the return value is not a pointer, but an in register struct. I think part of the problem is also that the "origin" of the `extractvalue` instruction is the BlackHole, but I am tracking a value that does not point back to the BlackHole, so there is no connection in the PAG or resulting SVFG.

Ideally we would like to track this pointer through such a call, regardless of how it is transformed.  In the comments in the PAGBuilder.cpp for[ visitExtractValueInst()](https://github.com/SVF-tools/SVF/blob/206493694931caa8ff3133191e7a4dbb7832fd89/lib/MemoryModel/PAGBuilder.cpp#L560), there are some notes about how to handle `extractvalue` in a way similar to GEP, but I am unsure of how this should be represented in the PAG, since there is no actual pointer.

Do you have any advice for how to handle this? How can the in-register struct be modeled in the PAG or SVFG to support this type of operation?






</Description>
    <CreatedDate>29/04/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>125</IssueID>
    <RepoID>1</RepoID>
    <Title>WPAPass::alias segfaults</Title>
    <Description>I'm trying to use the WPAPass for inter-procedural analysis however it crashes at `PAG::hasValueNode()`. I've detailed my pass registration and usage below.


```
//add to pass manager
 legacy::PassManager pm;
  pm.add(new WPAPass());
.
.
.
//and add pass requirements here.
...::getAnalysisUsage(llvm::AnalysisUsage &amp;info) const {
  info.addPreserved&lt;AAResultsWrapperPass&gt;();
  info.addRequired&lt;WPAPass&gt;();
.
.
.
//Pass Usage as below
auto* wpa = &amp;getAnalysis&lt;WPAPass&gt;();
.
.
.
//getting alias results
llvm::AliasResult experiment = wpa-&gt;alias(storeInst, loadInst);
```

Here's the stack trace from SVF:
```
==18162==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000030 (pc 0x000000ac8a0d bp 0x7ffc91a86cb0 sp 0x7ffc91a86c90 T0)
==18162==The signal is caused by a READ memory access.
==18162==Hint: address points to the zero page.
    #0 0xac8a0c in PAG::hasValueNode(llvm::Value const*) /home/shreeasish/llvm/SVF/include/MemoryModel/PAG.h:368:16
    #1 0xac58d8 in WPAPass::alias(llvm::Value const*, llvm::Value const*) /home/shreeasish/llvm/SVF/lib/WPA/WPAPass.cpp:158:14
```

Am I incorrectly using the pass?
What would be the easiest alternative for getting inter-procedural aliasing results?

Thanks


</Description>
    <CreatedDate>31/03/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>124</IssueID>
    <RepoID>1</RepoID>
    <Title>Does MTA work?</Title>
    <Description>Hi, developers.

MTA does not work and it is not even compilable with the current version.
Also, even after I succeeded in compilation by changing CMake files, it does not work correctly with the simple code described in the bottom. 

Possibly, I incorrectly modify the code to make MTA work. But, what I can tell is that MTA with the current version is not compilable.

---------------------------------------------------------
Here is the crash log first.
#0  0x00007ffff6d6a428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54
#1  0x00007ffff6d6c02a in __GI_abort () at abort.c:89
#2  0x00007ffff6d62bd7 in __assert_fail_base (fmt=&lt;optimized out&gt;, 
    assertion=assertion@entry=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"", 
    file=file@entry=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h", line=line@entry=250, 
    function=function@entry=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:92
#3  0x00007ffff6d62c82 in __GI___assert_fail (
    assertion=0x943e78 "Resolver &amp;&amp;\"Pass has not been inserted into a PassManager object!\"", 
    file=0x943e30 "~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h", line=250, 
    function=0x947940 &lt;llvm::ScalarEvolutionWrapperPass&amp; llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt;(llvm::Function&amp;)::__PRETTY_FUNCTION__&gt; "AnalysisType&amp; llvm::Pass::getAnalysis(llvm::Function&amp;) [with AnalysisType = llvm::ScalarEvolutionWrapperPass]") at assert.c:101
#4  0x00000000004b3470 in llvm::Pass::getAnalysis&lt;llvm::ScalarEvolutionWrapperPass&gt; (this=0xe822e0, F=...)
    at ~/llvm/llvm-7.0.0.src/include/llvm/PassAnalysisSupport.h:250
#5  0x00000000004b1a5e in MTA::getSE (F=0xe85a88) at ~/svf/include/MTA/MTA.h:115
#6  0x0000000000558906 in ForkJoinAnalysis::collectSCEVInfo (this=0xf1e9a0) at ~/svf/lib/MTA/MHP.cpp:630
#7  0x000000000055c397 in ForkJoinAnalysis::ForkJoinAnalysis (this=0xf1e9a0, t=0xf1cf50)
    at ~/svf/include/MTA/MHP.h:259
#8  0x0000000000554ed6 in MHP::MHP (this=0xf1c3e0, t=0xf1cf50) at ~/svf/lib/MTA/MHP.cpp:77
#9  0x000000000049720c in MTA::computeMHP (this=0xe822e0, module=...) at ~/svf/lib/MTA/MTA.cpp:129 -&gt; it was slightly modified but, it may not contribute errors
#10 0x0000000000496b46 in MTA::runOnModule (this=0xe822e0, module=...) at ~/svf/lib/MTA/MTA.cpp:45 -&gt; it was slightly modified but, it may not contribute errors
#11 0x000000000041ccc9 in main (argc=2, argv=0x7fffffffe348) at ~/svf/tools/MTA/mta.cpp:69 -&gt; it was slightly modified but, it may not contribute errors

----------------------------------------------
My test code
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

int Global;

void *Thread1(void *x) {
  Global++;
  return NULL;
}

void *Thread2(void *x) {
  Global--;
  return NULL;
}

int main() {
  pthread_t t[2];
  pthread_create(&amp;t[0], NULL, Thread1, NULL);
  pthread_create(&amp;t[1], NULL, Thread2, NULL);
  pthread_join(t[0], NULL);
  pthread_join(t[1], NULL);
}
-----------------------
Thank you</Description>
    <CreatedDate>20/03/2019</CreatedDate>
    <ClosedDate>24/03/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>123</IssueID>
    <RepoID>1</RepoID>
    <Title>Advise for the "Analyze a Simple C Program" page in Wiki </Title>
    <Description>Hi,
Maybe add `-g` to `clang -c -Xclang -disable-O0-optnone -emit-llvm swap.c -o swap.bc` is better for a beginer to understand what SVF do.</Description>
    <CreatedDate>15/03/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>122</IssueID>
    <RepoID>1</RepoID>
    <Title>where is the stc binary needed by UAFPrediction?</Title>
    <Description>where can I find the binary stc or in any other version?</Description>
    <CreatedDate>13/03/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>121</IssueID>
    <RepoID>1</RepoID>
    <Title>Stop indirect call resolution when limit is hit</Title>
    <Description>Previously, a fencepost error; one extra call can be resolved because it would stop when the limit is exceeded, not when it is reached.

E.g. if the limit is 0, the check would pass since !(0 &gt; 0), which allows an indirect call to be resolved before the check begins to fail (since 1 &gt; 0). </Description>
    <CreatedDate>12/02/2019</CreatedDate>
    <ClosedDate>12/02/2019</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>120</IssueID>
    <RepoID>1</RepoID>
    <Title>deleting PAG?</Title>
    <Description>Is deleting PAG supported?

I tried `delete _pta-&gt;getPAG()` and `PAG::releasePAG()`, both of which cause my program to terminate with a segfault. Valgrind gives this stack trace:

```
==18846==  Bad permissions for mapped region at address 0x40B8B10
==18846==    at 0x40B8B10: ???
==18846==    by 0x7D197D: PAGNode::~PAGNode() (PAGNode.h:75)
==18846==    by 0x7D1E55: ValPN::~ValPN() (in /data/klee/build7.0/bin/klee)
==18846==    by 0x7D1E85: ValPN::~ValPN() (PAGNode.h:255)
==18846==    by 0x79B2DA: destroy (GenericGraph.h:313)
==18846==    by 0x79B2DA: ~GenericGraph (GenericGraph.h:307)
==18846==    by 0x79B2DA: PAG::~PAG() (PAG.h:139)
==18846==    by 0x79A59D: ~PAG (PAG.h:141)
==18846==    by 0x79A59D: releasePAG (PAG.h:133)
```

From what I can tell the problem is the delete on [this line](https://github.com/SVF-tools/SVF/blob/85e2f882680541b3f585328b4c1b5e02723b4000/include/MemoryModel/GenericGraph.h#L147). The address of the destructor seems to be something random. My solution was just to disable the GenericNode destructor for PAGNodes, which seems to free almost all of the memory, but it feels odd. 

I also noticed that deleting pag is commneted out in `PointerAnalysis.h` so I'm wondering if this is something that is simply not supported? </Description>
    <CreatedDate>09/01/2019</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>119</IssueID>
    <RepoID>1</RepoID>
    <Title>Steensgaard analysis</Title>
    <Description>Hi,

Can you please provide some direction I should take to implement Steensgaard analysis using the pointer analysis framework provided?

Thanks</Description>
    <CreatedDate>27/12/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>118</IssueID>
    <RepoID>1</RepoID>
    <Title>Add SymbolTableInfo::getSubStructViaByteOffset()</Title>
    <Description>
    </Description>
    <CreatedDate>18/12/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>117</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing dependant library</Title>
    <Description>This PR adds some missing dependencies to `wpa` and `saber`

The problem occurs when building SVF with llvm that is built as a shared library (`-DBUILD_SHARED_LIBS=ON`), with this error message:

``` Linking CXX executable ../../bin/saber
/usr/bin/ld: ../../lib/libLLVMSvf.a(MemModel.cpp.o): undefined reference to symbol '_ZTVN4llvm22UnifyFunc
tionExitNodesE'
/src/llvm_build/lib/libLLVMTransformUtils.so.7: error adding symbols: DSO missing from command line
```

This change fixes the issue for me.</Description>
    <CreatedDate>17/12/2018</CreatedDate>
    <ClosedDate>18/12/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>116</IssueID>
    <RepoID>1</RepoID>
    <Title>taint analysis</Title>
    <Description>Hi,

I have some questions about using your tool for taint analysis. I want to annotate all function arguments (user inputs) as sources, and annotate left operands of add/sub/mul operations in LLVM as sinks. Then I need to check the reachability from sources to sinks.


1. How can I get names or nodeIDs of function arguments from symbol table?
2. How can I filter out add/sub/mul operations (LLVM statements) and get the names or nodeIDs of the left operands?
3. If reachable from source to sink, can I solve the value of the source to reach sink based on constraint graph?

For example, in the following LLVM assembly code, `%"assign_value.1"` is the left operand of add operation, and `%".15"` propogates data flow to it. We can see that `%".15"` loads from `%"_value_transfer1Function"` which gets value from `%".1"` (user input). So we annotate `%".1"` as source and `%"assign_value.1"` as sink. Apparently, the reachability is yes. Next, we want to solve the value of `%".1"` because we need the code flows into "endRequire" block instesd of "sanityCheckUnsatisfied". So we want to know what value should users feed to `%".1"` when this statement 

`br i1 %"notNull", label %"endRequire", label %"sanityCheckUnsatisfied"`

satisfies the `%"notNull"` condition and branch to label %"endRequire".

Here is the LLVM code example,
```
define i32 @"transfer1Function"(i32 %".1") 

{

entry:

  %"_value_transfer1Function" = alloca i32

  store i32 %".1", i32* %"_value_transfer1Function"

  %"binary_result" = alloca i32

  br label %"requireStart"

requireStart:

  %".5" = load i32, i32* @"balanceOfSender_global"

  %".6" = load i32, i32* %"_value_transfer1Function"

  %"cmpOP" = icmp uge i32 %".5", %".6"

  %".7" = zext i1 %"cmpOP" to i32

  store i32 %".7", i32* %"binary_result"

  %".9" = load i32, i32* %"binary_result"

  %"notNull" = icmp ne i32 %".9", 0

  br i1 %"notNull", label %"endRequire", label %"sanityCheckUnsatisfied"

sanityCheckUnsatisfied:

  ret i32 -1

endRequire:

  %".12" = load i32, i32* %"_value_transfer1Function"

  %".13" = load i32, i32* @"balanceOfSender_global"

  %"assign_value" = sub i32 %".13", %".12"

  store i32 %"assign_value", i32* @"balanceOfSender_global"

  %".15" = load i32, i32* %"_value_transfer1Function"

  %".16" = load i32, i32* @"balanceOfReceiver_global"

  %"assign_value.1" = add i32 %".16", %".15"

  store i32 %"assign_value.1", i32* @"balanceOfReceiver_global"

  ret i32 0

}
```

Thanks</Description>
    <CreatedDate>06/12/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>115</IssueID>
    <RepoID>1</RepoID>
    <Title>SPEC CPUINT 2006 benchmarks call graph stats for gobmk</Title>
    <Description>We ran SVF on speccpu2006 benchmarks,
GOBMK benchmark program has
Number of call sites are 10030
Number of Indirect call sites are 44
If we ran SVF with flow sensitive version to get the number of edges in the call garph, we are getting 46353.  why so many choices?. Help us to resolve the issue
</Description>
    <CreatedDate>03/12/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>114</IssueID>
    <RepoID>1</RepoID>
    <Title>Points-To Representation</Title>
    <Description>I have some questions regarding the points-to representation in the _PointsToDS_.
If the points-to for some node is empty, what does it mean:
- the node points to null?
- there is no points-to information available for the node?

I see that _getPts_ always creates a an empty points-to set (when _getPts_ is called), since it does the following:
```
return ptsMap[var];
```

It seems that this way, the points-to map is a bit polluted with many pointers with empty sets,
and is probably not so memory-efficient.
</Description>
    <CreatedDate>15/11/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>113</IssueID>
    <RepoID>1</RepoID>
    <Title>Update Memmodel</Title>
    <Description>Mapping original field index to flatten field index</Description>
    <CreatedDate>14/11/2018</CreatedDate>
    <ClosedDate>16/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>112</IssueID>
    <RepoID>1</RepoID>
    <Title>Refactoring GepObjNode</Title>
    <Description>
    </Description>
    <CreatedDate>04/11/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>111</IssueID>
    <RepoID>1</RepoID>
    <Title>refactoring getGepObj</Title>
    <Description>
    </Description>
    <CreatedDate>04/11/2018</CreatedDate>
    <ClosedDate>04/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>110</IssueID>
    <RepoID>1</RepoID>
    <Title>Update handleCE()</Title>
    <Description>
    </Description>
    <CreatedDate>03/11/2018</CreatedDate>
    <ClosedDate>12/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>109</IssueID>
    <RepoID>1</RepoID>
    <Title>Tell the different objects from custom alloc functions</Title>
    <Description>Hi Yulei,

I have a question using SVF with sample code below:

`#include &lt;stdlib.h&gt;

void my_malloc(char ** p,unsigned size){
    *p = malloc(size);
}

void f(void){
    char *p1,*p2,*p3,*p4;
    p1 = malloc(1);
    p2 = malloc(2);
    my_malloc(&amp;p3,3);
    my_malloc(&amp;p4,4);
}`

So p1,p2,p3,p4 should point to different objects, right?

By using 'wpa -nander -dump-consG test.bc', I got the following constraint graph:
![image](https://user-images.githubusercontent.com/5728515/47898611-937fbd00-deb1-11e8-8869-20b26cf2cfaf.png)

Here, unlike p1 separating from p2, p3 is connecting with p4 in the graph, which makes them alias to each other.

Is that supposed to be right? How can I tell p3 from p4 with SVF?</Description>
    <CreatedDate>02/11/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>108</IssueID>
    <RepoID>1</RepoID>
    <Title>expose getCallInstToCallGraphEdgesMap for analysis</Title>
    <Description>Sometimes we need `callinstToCallGraphEdgesMap` information to get calling relations between callers and callees; therefore it may be worthy to expose this analysis result.</Description>
    <CreatedDate>31/10/2018</CreatedDate>
    <ClosedDate>01/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>107</IssueID>
    <RepoID>1</RepoID>
    <Title>Avoid executable "registered more than once" error</Title>
    <Description>SVF static/dyanmic libraries (e.g., LLVMSvf.a/Svf.so in Linux) no longer
link LLVM libraries; this requires SVF library users to manually add
LLVM library dependencies. For performance consideration, we only allow
LLVMSvf.a to be used by static library or executable since LLVMSvf.a is
built without -fPIC; shared libraries has to use Svf.so.</Description>
    <CreatedDate>31/10/2018</CreatedDate>
    <ClosedDate>13/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>106</IssueID>
    <RepoID>1</RepoID>
    <Title>Add svf.main()</Title>
    <Description>  svf.main() is used to model the real ENTRY point of a C++ program,
  which initializes all global C++ objects and then call main().</Description>
    <CreatedDate>29/10/2018</CreatedDate>
    <ClosedDate>16/11/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>105</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge pull request #1 from SVF-tools/master</Title>
    <Description>SYNC with SVF master</Description>
    <CreatedDate>29/10/2018</CreatedDate>
    <ClosedDate>29/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>104</IssueID>
    <RepoID>1</RepoID>
    <Title>How to perform a slicing on top of SVFG</Title>
    <Description>Hi, Yulei,
From your previous response in [issue #81](https://github.com/SVF-tools/SVF/issues/81), is it correct to say that the SVFG provided by this tool does not include the value dependency of scalars? For example,
```c
#include &lt;stdio.h&gt;


int func_first(int zeta, int gamma)
{
	zeta = zeta * gamma * 2;
	return (zeta + 1);
}

int func_second(int gamma)
{
	return (gamma + 2);
}

int main()
{
	int number = 5;
	int zeta = 0;
	int gamma = 0;
	int *ptr = &amp;zeta;
	int iter = 1;
	while (iter &lt; number) {
		if (iter &lt; 3)
			zeta = func_first(*ptr, gamma); // slicing criterion
		else 
			zeta = func_first(iter, gamma);
		gamma = func_second(zeta);
		iter++;
	}

	return gamma;
}
```
In this program, I also want to capture the value that flows into `func_first` and flows back to `main`, but the SVFG does not seem to provide that result:
![fs_svfg](https://user-images.githubusercontent.com/11516654/47526144-e41d6780-d86c-11e8-9813-144d583b212d.png)

So, for example, if I want to do both a backward and forward slicing with criterion `zeta = func_first(*ptr, gamma);`, I need to combine your SVFG and the LLVM def-use chains to create a new graph and do the slicing on top of the new graph. Is that correct?

 I am looking forward for your response. Thank you very much!
</Description>
    <CreatedDate>25/10/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>103</IssueID>
    <RepoID>1</RepoID>
    <Title>make build.sh accept external LLVM_DIR</Title>
    <Description>Now if LLVM_DIR is exported outside the script, the build.sh will accept
it.</Description>
    <CreatedDate>25/10/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>102</IssueID>
    <RepoID>1</RepoID>
    <Title>install headers</Title>
    <Description>With this commit, headers will be installed inside $PREFIX/include/svf/ directory</Description>
    <CreatedDate>25/10/2018</CreatedDate>
    <ClosedDate>25/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>101</IssueID>
    <RepoID>1</RepoID>
    <Title>crash dumping svfg</Title>
    <Description>Maybe related to issue of same name ( #98 ), but creating a new one because this issue is mostly an attempt to prevent another instance where I'm sitting on a patch (recent UAF fixes, #100 and sibling commit) that might be useful to folks.  Any lack of sharing was because I haven't had time to do due diligence in terms of investigating things more completely....

Anyway I would feel bad if this was the cause of something like #98 and I didn't at least forward it :).

This patch has been part of my build for a good while in order to stop crashing when dumping the SVFG in my usage:

https://github.com/dtzWill/nur-packages/blob/master/pkgs/svf/svfg-crash-fix.patch

Hope this helps, close or modify the change as you see fit! Thanks again for SVF!</Description>
    <CreatedDate>18/10/2018</CreatedDate>
    <ClosedDate>24/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>100</IssueID>
    <RepoID>1</RepoID>
    <Title>fixing use-after-free in moveOutEdgesToRepNode</Title>
    <Description>
    </Description>
    <CreatedDate>18/10/2018</CreatedDate>
    <ClosedDate>18/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>99</IssueID>
    <RepoID>1</RepoID>
    <Title>Use After Free in moveInEdgesToRepNode</Title>
    <Description>The following code inside _moveInEdgesToRepNode_ references an edge after it's deletion:
```
else if (isa&lt;GepCGEdge&gt;(edge)) {
    removeDirectEdge(edge); // free
    // If the GEP is critical (i.e. may have a non-zero offset),
    // then it brings impact on field-sensitivity.
    if (!isZeroOffsettedGepCGEdge(edge)) { // use
        criticalGepInsideSCC = true;
    }
}
```</Description>
    <CreatedDate>18/10/2018</CreatedDate>
    <ClosedDate>24/10/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>98</IssueID>
    <RepoID>1</RepoID>
    <Title>Segfault when dumping svfg</Title>
    <Description>Got a segmentation fault when trying to -dump-svfg with saber. 

Attached are the results of the following commands and the LLVM bitcode
wpa -ander -svfg  ex.bc  
saber -dfree ex.bc
[svf_bug.zip](https://github.com/SVF-tools/SVF/files/2469947/svf_bug.zip)


Segfault command is
saber -dump-svfg ex.bc

</Description>
    <CreatedDate>11/10/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>97</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix revPts to of TLV pointers of `load` instruction.</Title>
    <Description>revPts fails to get points-to information of TLV pointers corresponding to `load` instructions. This is because we fail to update the revPoints while updating points-to information of TLV pointers when a flow-sensitive analysis is used.

Here, we should use PTData to update the points-to information so that revPts to get updates correctly and furthermore, for TLV pointers points-to information is maintained in a flow-insensitive manner.</Description>
    <CreatedDate>25/09/2018</CreatedDate>
    <ClosedDate>26/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>96</IssueID>
    <RepoID>1</RepoID>
    <Title>Refactoring CHA</Title>
    <Description>
    </Description>
    <CreatedDate>10/09/2018</CreatedDate>
    <ClosedDate>10/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>95</IssueID>
    <RepoID>1</RepoID>
    <Title>Value Flow of an address Taken variable</Title>
    <Description>Hi,

I hope this is the right place to ask this question.

I am hoping to capture the uses of an address taken variable throughout a program, in terms of LLVM values, and then any corresponding Allocations in case of any stores. What I am doing right now is to get the SVFGNode of the variable, and traverse over all outgoing edges. If it's an StmtSVFGNode, I can get the corresponding LLVM value/instruction easily, and I have done that already. However, I'm unable to follow the value inter-procedurally. I'm not sure how to get CallSites where there is a use for this address taken variable as a parameter. Can you please guide me about how to follow the value inter-procedurally?

Thanks</Description>
    <CreatedDate>31/08/2018</CreatedDate>
    <ClosedDate>31/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>94</IssueID>
    <RepoID>1</RepoID>
    <Title>Why is HANDBLACKHOLE by default false?</Title>
    <Description>Hi @yuleisui ,
Is this a sound choice?
This causes the `pointsTo` of `argv` of `main` function to be empty. IMO, this is not correct. We should add a dummy or a black hole node. 
I know that this flag could be turned on, but was wondering whether the value should be by default `true`?
</Description>
    <CreatedDate>24/08/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>93</IssueID>
    <RepoID>1</RepoID>
    <Title>Disabling dynamic call-graph update in FlowSensitive analysis.</Title>
    <Description>Hi @yuleisui ,

I was evaluating something and want to know..if there is some way to disable dynamic call-graph update in `FlowSensitive` analysis? Basically, I want the `FlowSensitive` analysis to use a prebuild call-graph. </Description>
    <CreatedDate>19/08/2018</CreatedDate>
    <ClosedDate>20/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>92</IssueID>
    <RepoID>1</RepoID>
    <Title>Def site of a PAGNode</Title>
    <Description>Hi,
I’m trying to find a definition site (defining SVFGNode) for a given llvm instruction. What I’m doing is first find PAGNode corresponding to given llvm::Instruction*, then call SVFG’s getDefSVFGNode function for it. However it doesn’t seem to return definition node. For example for load instruction the returned svfg node is a StmtSVFGNode corresponding to the same load instruction. Here is the code snippet and part of it's IR I'm using
```
void test(int* b)
{
    int a = 0;
    if (b) {
        a = *b + 42;
    }
    int c = a;
    c++;
}
```
```
define void @test(i32* %b) #0 {
entry:
  %b.addr = alloca i32*, align 8
  %a = alloca i32, align 4
  %c = alloca i32, align 4
  store i32* %b, i32** %b.addr, align 8
  store i32 0, i32* %a, align 4
  **%0 = load i32*, i32** %b.addr, align 8**
  %tobool = icmp ne i32* %0, null
  br i1 %tobool, label %if.then, label %if.end
.....
}
```
The load instruction is _%0 = load i32*, i32** %b.addr, align 8_, getDefSVFGNode returns StmtSVFGNode which instruction is the same load. 

My question is how should I get definition node of a pointer use from SVFG? And is it even the correct approach, or should I use MemSSA instead of SVFG to get this information?

Thanks.</Description>
    <CreatedDate>16/08/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>91</IssueID>
    <RepoID>1</RepoID>
    <Title>"Fix bug for creating gep value node" from yiyuaner</Title>
    <Description>get the original commit form yiyuaner</Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>90</IssueID>
    <RepoID>1</RepoID>
    <Title>Revert "Fix bug for creating gep value node"</Title>
    <Description>Reverts SVF-tools/SVF#89</Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>89</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix bug for creating gep value node</Title>
    <Description>
    </Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>88</IssueID>
    <RepoID>1</RepoID>
    <Title>Are all the tests in PTABench expected to pass?</Title>
    <Description>Hi @yuleisui,

I am seeing that few tests in PTABench https://github.com/SVF-tools/PTABen are failing with existing pointer analysis techniques. 
Is this expected?

Do we have some whitelist/blacklist of tests that are obsolete?</Description>
    <CreatedDate>15/08/2018</CreatedDate>
    <ClosedDate>16/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>87</IssueID>
    <RepoID>1</RepoID>
    <Title>Possible bug when building pag for global struct ?</Title>
    <Description>In function PAGBuilder::InitialGlobal, we have the following code fragment:
```
else if (isa&lt;ConstantStruct&gt;(C)) {
    const StructType *sty = cast&lt;StructType&gt;(C-&gt;getType());
    const std::vector&lt;u32_t&gt;&amp; offsetvect =
        SymbolTableInfo::Symbolnfo()-&gt;getStructOffsetVec(sty);
    for (u32_t i = 0, e = C-&gt;getNumOperands(); i != e; i++) {
        u32_t off = offsetvect[i];
        InitialGlobal(gvar, cast&lt;Constant&gt;(C-&gt;getOperand(i)), offset + off, i);
    }
} 

```

if we have gvar pointing to a nested structure like:
```
struct A {
     double a
     struct B {
         int b;
         int c;
     } b;
     float d;
}
```
and with the initializer C (psudocode):
```
{1.0, {2, 3}, 4.0}
```
then we will get the following calls:
```
InitialGlobal(gvar, Constant(1.0), 0, 0);
InitialGlobal(gvar, ConstantStruct({2,3}), 1, 1);
InitialGlobal(gvar, Constant(4.0), 2, 2);
```
the second call above for initializing inner struct B will invoke another call:
```
InitialGlobal(gvar, Constant(2), 1+0, 0); // here we pass 0 as fieldidx param
```
when we try to get the field, we will invoke the following calls:
```
NodeID field = getGlobalVarField(gvar, 1, 0); 
pag-&gt;getGepValNode(gvar, LocationSet(1), gvartype, 0); // here gvartype is type for struct A.
const std::vector&lt;FieldInfo&gt; &amp;fieldinfo = symInfo-&gt;getFlattenFieldInfoVec(gvartype); // FieldInfoVec for struct A
const Type *type = fieldinfo[0].getFlattenElemTy();
// index into A's FieldInfoVec, get type double, wrong! we should get type int instead.
```
The fieldidx param of getGlobalVarField is the index for the inner struct B but we use the fieldinfo vec of
outter struct A. So we get the wrong type for the gepNode.

Is this a bug ?
</Description>
    <CreatedDate>14/08/2018</CreatedDate>
    <ClosedDate>15/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>86</IssueID>
    <RepoID>1</RepoID>
    <Title>Can I run multiple instances of the same Pointer analysis in a single run?</Title>
    <Description>Hi @yuleisui,

I was trying to run multiple instances of same pointer analysis on the same `svfModule` in a single program. 

I am seeing some inconsistencies w.r.t to field sensitivity of certain objects.
Before trying to debug, I want to know if this is supported or there is certain mutable global state maintained that could affect multiple instances of the same pointer analysis?</Description>
    <CreatedDate>12/08/2018</CreatedDate>
    <ClosedDate>14/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>85</IssueID>
    <RepoID>1</RepoID>
    <Title>Adding Intraedge sanity (Part 2)</Title>
    <Description>Sanity function to verify that nodes of an Intraedge always refer to the same function.</Description>
    <CreatedDate>10/08/2018</CreatedDate>
    <ClosedDate>10/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>84</IssueID>
    <RepoID>1</RepoID>
    <Title>Adding Intraedge sanity (Part 1)</Title>
    <Description>Sanity function to verify that nodes of an Intraedge always refer to the same function.</Description>
    <CreatedDate>10/08/2018</CreatedDate>
    <ClosedDate>10/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>83</IssueID>
    <RepoID>1</RepoID>
    <Title>Can IntraDirSVFGEdge having srcNode and dstNode from different functions?</Title>
    <Description>Hi @yuleisui,

I am facing an issue where an `IntraDirSVFGEdge` has the src node (`getSrcNode` ) and dst node (`getDstNode` ) belong to **different functions**. 

However, by definition *Intra* edges should only connect nodes that belong to the same function.

Can this happen? If yes, could you please describe what does this mean? Why do we need to make it an IntraDir edge?</Description>
    <CreatedDate>09/08/2018</CreatedDate>
    <ClosedDate>12/08/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>82</IssueID>
    <RepoID>1</RepoID>
    <Title>Path Dependence Analysis</Title>
    <Description>Hello, amazing project.

I have a question, it's possible to make  _Path Dependence Analysis_ based on _SVF_? If yes, what's the direction one should take.

Thanks</Description>
    <CreatedDate>28/07/2018</CreatedDate>
    <ClosedDate>28/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>81</IssueID>
    <RepoID>1</RepoID>
    <Title>Question about using this tool</Title>
    <Description>Hi

This is an interesting work and I want to use it for some interesting analysis.
However, I have no idea where to start.
My goal is to find the value flow dependency between two variables:

example:

foo() {
int a = 1;
bar(a);
}

bar(int a) {
int b = a + 1;
}

If I want to find the data dependency between a and b, how should I do?
Which file should I refer to for more information?

Thanks</Description>
    <CreatedDate>24/07/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>80</IssueID>
    <RepoID>1</RepoID>
    <Title>Implementing a flow and context-sensitive pointer analysis</Title>
    <Description>Hi @yuleisui,

Let's say I want to add context-sensitivity to the flow-analysis.
Precisely, I want context-sensitive heap and stack objects.

I am thinking of the following implementation plan, Could you please let me know if this looks okay?

1) Modify `MemModel.h` to add context information to all the PAGNodes. Basically, build a context-sensitive PAG: This will take care of creating the correct constraint graph.

2) Add new pointer analysis to use `CondPTAImpl` that uses context.

Does this plan look valid? Or there is a better way to implement this?</Description>
    <CreatedDate>23/07/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>79</IssueID>
    <RepoID>1</RepoID>
    <Title>Regression test cases?</Title>
    <Description>I noticed there is repo (https://github.com/SVF-tools/PTABen) containing a micro-benchmark suite 

Is it possible to provide a set of real-world projects (maybe just bitcode files) for regression testing?
For example, the cclyzer project (https://github.com/plast-lab/cclyzer) includes some bitcodes from coreutils  and postgresql (https://github.com/plast-lab/cclyzer/tree/master/tests/)</Description>
    <CreatedDate>23/07/2018</CreatedDate>
    <ClosedDate>13/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>78</IssueID>
    <RepoID>1</RepoID>
    <Title>Path-sensitive points-to analysis?</Title>
    <Description>In `MemoryModel/PointerAnalysis.h`,  there are several path-sensitive points-to analyses. 
Are they implemented in current version? If so, does SVF provide command-line interface for choosing them? Thank you!
~~~~
    /// Pointer analysis type list
    enum PTATY {
       // ...
        FSCSPS_WPA,		///&lt; Flow-, context-, path- sensitive WPA
        ADAPTFSCS_WPA,		///&lt; Adaptive Flow-, context-, sensitive WPA
        ADAPTFSCSPS_WPA,	///&lt; Adaptive Flow-, context-, path- sensitive WPA
       //..
    };
~~~~</Description>
    <CreatedDate>20/07/2018</CreatedDate>
    <ClosedDate>20/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>77</IssueID>
    <RepoID>1</RepoID>
    <Title>Multiple NodeIDs for a single instruction?</Title>
    <Description>I am looking at a PAG, where 2 **different** NodeIDs map to the same Value*.
I have never seen this case. Can this happen?</Description>
    <CreatedDate>19/07/2018</CreatedDate>
    <ClosedDate>21/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>76</IssueID>
    <RepoID>1</RepoID>
    <Title>Point-to results inconsistencies</Title>
    <Description>I have following points to information at the following load instruction:
```
%7 = load i8*, i8** @auth_check2.authpath, align 8, !dbg !1478, !tbaa !1470
##&lt;&gt; Source Loc: ln: 1047 fl: libhttpd.c
Ptr 12954         PointsTo: { 11314 11334 }

!!Target NodeID 11314     [&lt;call&gt; Source Loc: ln: 716 fl: libhttpd.c] 
!!Target NodeID 11334     [&lt;call19&gt; Source Loc: ln: 724 fl: libhttpd.c] 
```
This implies that, `@auth_check2.authpath` is a top level pointer that points to some objects which in turn should **atleast** point to the nodes `11314` and  `11334` am I right?

So, I checked the points to of the pointer operand, I get the following:
```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1474         PointsTo: { 1475 }

!!Target NodeID 1475     [&lt;auth_check2.authpath&gt; Source Loc: Glob ] 
```
Ok, this is the first level object, seems to be valid.

Now, when I check the points to objects of the node `1475`, I get:

```
##&lt;auth_check2.authpath&gt; Source Loc: Glob 
Ptr 1475         PointsTo: {empty}
```
I expect to see `11314` and  `11334`. 

How is this possible that the points to are empty whereas the `load` instruction points to is not? I am baffled.</Description>
    <CreatedDate>09/07/2018</CreatedDate>
    <ClosedDate>23/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>75</IssueID>
    <RepoID>1</RepoID>
    <Title>Is SVFG flow-sensitive?</Title>
    <Description>First question: Is SVFG flow-sensitive? It uses memory SSA but doesn't respect the control-flow.  
For example: If a `store` and `load` define and use the same region, they will be connected **irrespective** of whether there is a path from the store to load in the CFG.

If SVFG is not flow-sensitive, How is the `FlowSensitive` pointer analysis (type: `FSSPARSE_WPA`) flow sensitive? As it solves the constraints over the SVFG.</Description>
    <CreatedDate>08/07/2018</CreatedDate>
    <ClosedDate>09/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>74</IssueID>
    <RepoID>1</RepoID>
    <Title>Adding support for vector operands (Patch 2)</Title>
    <Description>Added changes to `PAGBuilder` to correctly handle store instructions, in case of vector operands.</Description>
    <CreatedDate>06/07/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>73</IssueID>
    <RepoID>1</RepoID>
    <Title>Adding support for vector operands.</Title>
    <Description>Adding support for vector operands in BreakConstantExpr.

Note that, I have added the additional break as an optimization.
Reason: It is enough to add instruction once if there is an operand that hasConstantGEP, instead of adding the same instruction once for each operand.</Description>
    <CreatedDate>06/07/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>72</IssueID>
    <RepoID>1</RepoID>
    <Title>Make getRevPts to part of PointerAnalysis class</Title>
    <Description>Make `getRevPts` part of PointerAnalysis base class, this just makes it easy to access the method from base-class pointer, else we need cast to child class before accessing this method.</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>71</IssueID>
    <RepoID>1</RepoID>
    <Title>Fixing fetching getSourceLocOfFunction</Title>
    <Description>The loop is spurious, we use `getSubProgram` directly from the `Function` ptr `F` to get the `DISubprogram`. The loop makes the same information appended multiple times making it unreadable.</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>70</IssueID>
    <RepoID>1</RepoID>
    <Title>Unsound points-to results?</Title>
    <Description>I am trying to find aliases for a pointer, specifically, `netibuf`.

Target (simplified) source of the program (`telnet`):
```
Ring netiring;
unsigned char  netibuf[BUFSIZ];
void init_network (void)
{
 ..
  if (ring_init (&amp;netiring, netibuf, sizeof netibuf) != 1)
    {
      exit (EXIT_FAILURE);
    }
  ..
}

int ring_init (Ring * ring, unsigned char *buffer, int count)
{
  memset ((char *) ring, 0, sizeof *ring);

  ring-&gt;size = count;

  ring-&gt;supply = ring-&gt;consume = ring-&gt;bottom = buffer;
  ...
}
```

I use the following code:

```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("netibuf", true);

// get node id
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);

// then I search for aliases
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                 nIter != currPta-&gt;getAllValidPtrs().end();
                 ++nIter) {
                if (currPta-&gt;alias(*nIter, targetNode) != NoAlias) {
                    if (targetAliases.find(*nIter) == targetAliases.end()) {
                       dbgs() &lt;&lt; "[+] Alias found:" &lt;&lt; *nIter &lt;&lt; "\n";
                    }
                }
  }
```

The above doesn't print any aliases, however, as we can see in the program source above, `netibuf` has aliases. These results are not sound, Am I missing something here?

Attached is the bc file [telnet.0.4.opt.mem2reg.bc.zip](https://github.com/SVF-tools/SVF/files/2157717/telnet.0.4.opt.mem2reg.bc.zip), of the `telnet`, that I am using. The target source code is of `telnet` is available here: https://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.gz
</Description>
    <CreatedDate>03/07/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>69</IssueID>
    <RepoID>1</RepoID>
    <Title>Inconsistencies in Points to information</Title>
    <Description>I am trying to get points to information of a dynamically created object.

Source code:

```
void indirect_allocator(char **ptr, int s) {
    if(*ptr == NULL) {
        *ptr = malloc(s);
    }
}
int main() {
    int h;
    static char *global_ptr;
    scanf("%d", &amp;h);
    if(h &lt; 4) {
        indirect_allocator(&amp;global_ptr, h*3);
    } else {
        indirect_allocator(&amp;global_ptr, h*5);
    }
    
    global_ptr[0] = 'f';
    global_ptr[1] = 'q';
    global_ptr[2] = 'a' + h;
    global_ptr[3] = '\0';
    printf("%s", global_ptr);
} 
```
Here the goal is to identify that `global_ptr[*]` instructions in the `main` function are aliases to the object allocated by the `malloc` call of `indirect_allocator` function.

I am using the following code:
```
PointerAnalysis* currPta = new AndersenWaveDiffWithType();
currPta-&gt;analyze(svfModule);
// get the PAG
PAG *currentPAG = currPta-&gt;getPAG();
// Get the top-level variable
GlobalVariable *targetGlobVar = targetModule-&gt;getGlobalVariable("main.global_ptr", true);

// get points_to
NodeID targetNode = currentPAG-&gt;getValueNode(targetGlobVar);
PointsTo&amp; objs = currPta-&gt;getPts(targetNode);
// here objs contains only one node, which is right i.e., @main.global_ptr = internal global i8* null, align 8

// Now, let's get objects pointed by this node.
PointsTo&amp; objs2 = currPta-&gt;getPts(objs.find_first());
// here objs2 contains only one node, which is correct i.e., %call = call i8* @malloc(i64 %conv)

// Now, when I try to get all aliases to the malloced object i.e., (the above %call..)
std::set&lt;NodeID&gt; targetAliases;
targetAliases.clear();
for (NodeBS::iterator nIter = currPta-&gt;getAllValidPtrs().begin();
                nIter != currPta-&gt;getAllValidPtrs().end();
                ++nIter) {
            if(currPta-&gt;alias(*nIter, objs2.find_first()) != NoAlias) {
                if(targetAliases.find(*nIter) == targetAliases.end()) {
                    targetAliases.insert(*nIter);
                }
            }
        }

// I get NO aliases..
```

I expect to see the `load` and `getelementptr` instructions of the main function..but I do not see anything.

Am I missing something here?

Attached is the source file `global_ptr_head_obj.c` and the corresponding bitcode file (`global_ptr_head_obj.mem2reg.bc`) on which I am trying to run the analysis.

[global_ptr_example.zip](https://github.com/SVF-tools/SVF/files/2154145/global_ptr_example.zip)
</Description>
    <CreatedDate>02/07/2018</CreatedDate>
    <ClosedDate>23/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>68</IssueID>
    <RepoID>1</RepoID>
    <Title>Instructions reachable from function arguments</Title>
    <Description>Hello,

I want to use PAG and SVFG graphs to collect instructions reachability information. Particularly for every function I need to find instructions reachable by each of function arguments. Do I understand it correctly that first I’ll need to extend PAG to include all the instructions as now PAGBuilder doesn’t process all types of instructions. Then traverse extended PAG to find instructions reachable from function arguments. Will PAG reflect aliasing information for pointers, or do I need to use SVFG for it?

Thanks!</Description>
    <CreatedDate>01/07/2018</CreatedDate>
    <ClosedDate>03/07/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>67</IssueID>
    <RepoID>1</RepoID>
    <Title>Which alloc can reach callsite parameters</Title>
    <Description>Hello, 

I am interested in figuring out which instance of a memory allocation function (such as _malloc_) in a program could have allocated memory pointed to by pointers that are passed as arguments to certain functions. Is is possible to extract this information at the source code level with SVF?  I understand that SVF is implemented to use the LLVM IR, but curious to know if there is anyway to extract the underlying source code/AST information. </Description>
    <CreatedDate>29/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>66</IssueID>
    <RepoID>1</RepoID>
    <Title>SPEC cpu2000</Title>
    <Description>can you tell me how can I get the spec cpu2000? what's the website?</Description>
    <CreatedDate>28/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>65</IssueID>
    <RepoID>1</RepoID>
    <Title>Pointer analysis query!</Title>
    <Description>Is there any way to get all the pointers that are aliases to a given pointer or object (ex: alloca).

The way I can think of is..get all the pointers in the IR, do `getPts` and compute the intersection.

Is there any other easier or recommended way?
</Description>
    <CreatedDate>28/06/2018</CreatedDate>
    <ClosedDate>28/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>64</IssueID>
    <RepoID>1</RepoID>
    <Title>Program Dependence Graph</Title>
    <Description>Is it possible to dump Program Dependence Graph (PDG) of an entrypoint (a method in a bitcode file) to a DOT file?

Thanks!</Description>
    <CreatedDate>16/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>63</IssueID>
    <RepoID>1</RepoID>
    <Title>transform from llvm IR to  SVFGNode</Title>
    <Description>Hi, yulei,
Is there any way that we can transform llvm IR (Instruction) to SVFGNode?
I have found that:  “pag-&gt;getValueNode”, and “pag-&gt;getPAGNode“
we can obtain PAGNode from llvm IR.
But I don't know how to obtain SVFGNode.

Besides, the NodeID in PAG and SVFG is different?

thanks

</Description>
    <CreatedDate>12/06/2018</CreatedDate>
    <ClosedDate>13/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>62</IssueID>
    <RepoID>1</RepoID>
    <Title>SVF in VirtualBox</Title>
    <Description>you say we can get the image SVF.ova and we can test the spec2000 and other benchmarks , but i can't connect the image SVF.ova, so I want to know the reason .

Thank you!  </Description>
    <CreatedDate>12/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>61</IssueID>
    <RepoID>1</RepoID>
    <Title>Call run on module from an other pass</Title>
    <Description>Hello again,

I create a pass to use your tool, so i integrate your tools in llvm and i can't figure out how to call WPAPass::runOnModule().

I want to call this function to get PTDataTy for flow sensitive pointer analysis.

But this function requires an svfModule and i have no idea how to instanciate it.

Any ideas?..</Description>
    <CreatedDate>05/06/2018</CreatedDate>
    <ClosedDate>07/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>60</IssueID>
    <RepoID>1</RepoID>
    <Title>Can we avoid node from collapsing to field-insensitive</Title>
    <Description>Hi, I'm using the default AndersonWaveDiff solver to run pointer analysis for c program. But I found the result is not precise, since a lot of nodes collapse to field-insensitive. By checking the code, it seems to be related to PWC Node. Could you give me more information about PWC Node , e.g., when it would be created? Besides, can we avoid node from collapsing to field-insensitive or any other ways to make the result more precise? Thanks!</Description>
    <CreatedDate>04/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>59</IssueID>
    <RepoID>1</RepoID>
    <Title>Is it possible to have pointsTo set for a value for a given line/block?</Title>
    <Description>Hello,
I wrote a pass in LLVM that required yours so i have theorically access to every object that i want in your tool. Do you know if there is a way to have information about the pointsTo set for a value at a given instruction (or a block) of an LLVM program?
Thanks!</Description>
    <CreatedDate>04/06/2018</CreatedDate>
    <ClosedDate>04/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>58</IssueID>
    <RepoID>1</RepoID>
    <Title>Wrong number of templates arguments</Title>
    <Description>Hello, i'm trying to integrate your work as an LLVM pass to reuse the result for an other pass.
I try to build it with llvm 6 but during the build i have severals errors like:

`llvm-6.0.0.src/include/llvm/Util/DataFlowUtil.h:210:85: error: wrong number of template arguments (1, should be 2)
 class IteratedDominanceFrontier: public llvm::DominanceFrontierBase&lt;llvm::BasicBlock&gt; {`

OR

`error: ‘iterator’ does not name a type
     iterator getIDFSet(llvm::BasicBlock *B) {`

Any ideas?</Description>
    <CreatedDate>03/06/2018</CreatedDate>
    <ClosedDate>04/06/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>57</IssueID>
    <RepoID>1</RepoID>
    <Title>How to know the heap object is a struct or array or element of struct or array</Title>
    <Description>eg. 
typedef struct NODE{
	int data;
	int *c;
	struct NODE* next;
}NODE;
void swap(){
	NODE ni;
	ni.c = (int *)malloc(sizeof(int));
	ni.data = 1;
}
I can get the IR like this 
define void @swap() #0 !dbg !10 {
  %1 = alloca %struct.NODE, align 8
  call void @llvm.dbg.declare(metadata %struct.NODE* %1, metadata !13, metadata !DIExpression()), !dbg !21
  %2 = call noalias i8* @malloc(i64 4) #3, !dbg !22
  %3 = bitcast i8* %2 to i32*, !dbg !23
  %4 = getelementptr inbounds %struct.NODE, %struct.NODE* %1, i32 0, i32 1, !dbg !24
  store i32* %3, i32** %4, align 8, !dbg !25
  %5 = getelementptr inbounds %struct.NODE, %struct.NODE* %1, i32 0, i32 0, !dbg !26
  store i32 1, i32* %5, align 8, !dbg !27
  ret void, !dbg !28
}
the instruction is  %2 = call noalias i8* @malloc(i64 4) #3, !dbg !22 , how to judge the malloc the heap is a struct ? can you give me the code ,thank you !</Description>
    <CreatedDate>03/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>56</IssueID>
    <RepoID>1</RepoID>
    <Title>update LLVMModuleSet::loadModules</Title>
    <Description>To use only one LLVMContext object for multiple modules in the same thread.</Description>
    <CreatedDate>02/06/2018</CreatedDate>
    <ClosedDate>26/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>55</IssueID>
    <RepoID>1</RepoID>
    <Title>Support for clang 7.0.0</Title>
    <Description>Changes to SVF source code to support build with clang 7.0.0. Builds target and example analyses given on the setup guide tested with basic programs. </Description>
    <CreatedDate>01/06/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>54</IssueID>
    <RepoID>1</RepoID>
    <Title>data flow between used pointers</Title>
    <Description>Hi,
I have seen the data flow from defined pointer to used pointer.
Do you have any API in SVF to get the data flow between used pointer?
For example, in Use-after free I wantto  know the flow from the memory malloc to free, and its use.
I do not know whether can we derive the flow from memory free to its use?

Thanks! </Description>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>30/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>53</IssueID>
    <RepoID>1</RepoID>
    <Title>Link issues when writing my own pass using SVF</Title>
    <Description>I wrote a pass that leverages SVF, but I got some problems when running this pass.

Initially have the following line in my CMAKE file:
target_link_libraries(${PROJECT_NAME} LLVMSvf LLVMCudd ${llvm_libs})

This is similar to what I saw in the WPA tool of SVF. But this has the following linking issues. The reason is that WPA is an executable, and LLVMSvf and LLVMCudd are static libraries.
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddExact.c.o): requires dynamic R_X86_64_PC32 reloc against 'free' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddAnneal.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddNextLow' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddLinear.c.o): requires dynamic R_X86_64_32 reloc which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddWindow.c.o): requires dynamic R_X86_64_PC32 reloc against 'cuddSwapInPlace' which may overflow at runtime; recompile with -fPIC
/usr/bin/ld: error: /mnt/data/Research/Library/SVF/build/lib/CUDD/libLLVMCudd.a(cuddGenetic.c.o): requires dynamic R_X86_64_PC32 reloc against 'st_lookup_int' which may overflow at runtime; recompile with -fPIC
...


So I changed the CMAKE file to:
target_link_libraries(${PROJECT_LIB_NAME} Svf Cudd ${llvm_libs})

This can successfully generate the .so file for my pass. However, when I ran the pass using opt, I got another error:
opt: CommandLine Error: Option 'bitcode-mdindex-threshold' registered more than once!
LLVM ERROR: inconsistency in registered CommandLine options.

Is anybody encounter the same problem?</Description>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>52</IssueID>
    <RepoID>1</RepoID>
    <Title>svfgNode or PagNode to llvm instruction</Title>
    <Description>Hi, 
Do you have any map from svfgnode or pagnode to llvm instruction,  or its verse.

I'd like to use the result in SVF to other task.

Thanks</Description>
    <CreatedDate>21/05/2018</CreatedDate>
    <ClosedDate>29/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>51</IssueID>
    <RepoID>1</RepoID>
    <Title>isInAWrapper in LeakChecker.cpp</Title>
    <Description>Hi,
I check your -leak function in Saber.
I find the function "isInAWrapper", but I don't know what situation it handles.
For example, the following is not your case. 
char * malloc_wrap(int n){
	char* ptr = malloc(n);
	return ptr;
}

Can you give me an example to illustrate its application?
Thanks!</Description>
    <CreatedDate>17/05/2018</CreatedDate>
    <ClosedDate>21/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>50</IssueID>
    <RepoID>1</RepoID>
    <Title>SABER</Title>
    <Description>your saber is flow-sensitive and field-sensitive and Context-Sensitive Interprocedural pointer analysis or not ?</Description>
    <CreatedDate>16/05/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>49</IssueID>
    <RepoID>1</RepoID>
    <Title>update getSourceLoc</Title>
    <Description>
    </Description>
    <CreatedDate>16/05/2018</CreatedDate>
    <ClosedDate>16/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>48</IssueID>
    <RepoID>1</RepoID>
    <Title>pointer analysis</Title>
    <Description>how can I get the results of pointer analysis? I want to analysis something from the results (eg. a struct to store the information), I didn't need the .dot file.

if I want to write a flow and field insensitive pointer analysis,  can you tell me the detail, I don't know how to   make and run the file that I write.</Description>
    <CreatedDate>14/05/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>47</IssueID>
    <RepoID>1</RepoID>
    <Title>Segmentation fault on Saber</Title>
    <Description>Hi,
When I use saber to try the use after free detection, but I get the segmantation fault.
The command is : ./saber -uaf $file.bc
I guess that i need use other options together, but I don't know which options should I use?

Do you have any documnets about this?</Description>
    <CreatedDate>13/05/2018</CreatedDate>
    <ClosedDate>14/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>46</IssueID>
    <RepoID>1</RepoID>
    <Title>Aborted in cudddTable.c:343</Title>
    <Description>Hello,
After I have installed SVF as https://github.com/SVF-tools/SVF/wiki/Setup-Guide-(CMake),
I run the example in https://github.com/SVF-tools/SVF/wiki/Analyze-a-Simple-C-Program .

When we run wpa -ander -svfg swap.bc,
the program outputs some information, but at last it reported the abort as follows:
wpa: $SVF_Home/lib/CUDD/cuddTable.c:343: cuddAllocNode: Assertion `((ptruint) mem &amp; (sizeof(DdNode) - 1)) == 0' failed.

How to solve this problem? thanks</Description>
    <CreatedDate>10/05/2018</CreatedDate>
    <ClosedDate>13/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>45</IssueID>
    <RepoID>1</RepoID>
    <Title>Def/Use chains</Title>
    <Description>Hello,

Maybe this is a silly question. After constructing the SVFG, how to get all the Defs for each value in IR?

I only found getDefSVFGNode. But this only returns one node. But as a conservative static analysis, there should be several instructions that can possibly write to the same memory location. So how can I get all these instructions? 

Thanks!</Description>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>44</IssueID>
    <RepoID>1</RepoID>
    <Title>DummyValPN &amp; DummyObjPN</Title>
    <Description>Hello, when reading the source code of PointAnalysis, I don't quite understand the meaning of DummyValPN &amp; DummyObjPN. The technical documentation said that 

&gt; ... represents an introduced dummy node to achieve field sensitivity when handling external library calls (e.g., memcpy, where pointers (LLVM Values) that point to the fields of an struct do not explicitly appear at an instruction)

So in field-insensitive analysis, we can entirely ignore these two nodes when trying to get the pts for each node?</Description>
    <CreatedDate>15/04/2018</CreatedDate>
    <ClosedDate>15/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>43</IssueID>
    <RepoID>1</RepoID>
    <Title>Pointer Analysis Types</Title>
    <Description>Hi,

Firstly, Awesome project! Reading through the source code I had a question about this enum: https://github.com/SVF-tools/SVF/blob/3038078e90eb037ea43aa28ff3a28c05d631be5d/include/MemoryModel/PointerAnalysis.h#L58

A number of analysis I'm interested are listed. However, it seems like these are yet to be implemented? Or is there source code available somewhere else that hasn't been merged?</Description>
    <CreatedDate>12/04/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>42</IssueID>
    <RepoID>1</RepoID>
    <Title>Flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis</Title>
    <Description>Hi, I just got to know this library. I am in need of flow sensitive intra-procedural analysis and flow-insensitive context in-sensitive inter-procedural analysis. Can any one give some tips about how to implement these two analyses based on this tool. This may save a lot of time. Thanks!</Description>
    <CreatedDate>09/04/2018</CreatedDate>
    <ClosedDate>27/05/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>41</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix C++ Analysis Error due to LLVM-6.0 changes of Attribute argument No.</Title>
    <Description>An error occurs due to the Argument number is changed in LLVM-6.0. 
```
cs.paramHasAttr(0, ...) 
```
"0" is the first argument now.
Previously, in LLVM-4.0, "1" is the first argument.

This needs to be confirmed if someone knows.
</Description>
    <CreatedDate>03/04/2018</CreatedDate>
    <ClosedDate>05/04/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>40</IssueID>
    <RepoID>1</RepoID>
    <Title>Make external API names/types sourced from a text file</Title>
    <Description>This introduces a new option: "read-extapi" to choose the location of the database file. The old DB was moved to lib/Util/extAPIDB.txt, and in it, the format is specified.</Description>
    <CreatedDate>27/03/2018</CreatedDate>
    <ClosedDate>26/09/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>39</IssueID>
    <RepoID>1</RepoID>
    <Title>Does SVF change the module it analyses? </Title>
    <Description>Hi,

I observed that after running a pointer analysis (AnderesenWaveDiff), the number of instructions in an LLVM module increases. From what I gather the analsysis itself, never changes the module it analyses. Is that true or did I miss something? Another thing I was considering is that SVF registers itself as an LLVM alias analysis and then another transformation uses it's more precise results to emit different code. However I'm not running any other pass after the SVF analysis. Any other ideas?

</Description>
    <CreatedDate>19/03/2018</CreatedDate>
    <ClosedDate>20/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>38</IssueID>
    <RepoID>1</RepoID>
    <Title>Update for LLVM 6.0.0</Title>
    <Description>Relevant LLVM changes for updating to v6.0.0 from v4.0.0:

- The `IsPostDominators` member of `llvm::DominanceFrontierBase` has become a template parameter (https://reviews.llvm.org/D35315).
- The method `llvm::Function::getArgumentList` has been dropped in favour of `llvm::Function::arg_begin`, `llvm::Function::arg_end` and `llvm::Function::args` (https://reviews.llvm.org/rL298010).
- `tool_output_file` has been renamed `ToolOutputFile`.
- `FindAllocaDbgDeclare` has been replaced with `FindDbgAddrUses`, which returns a list of zero or one `llvm.dbg.declare` intrinsics plus zero or more `llvm.dbg.addr` intrinsics (upcast as `DbgInfoIntrinsic` objects) (https://reviews.llvm.org/D37768).

I've run the test script for the `mem_leak` directory and it all looks fine – could you advise any further testing that needs to be done?

Many thanks!
Jack</Description>
    <CreatedDate>17/03/2018</CreatedDate>
    <ClosedDate>20/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>37</IssueID>
    <RepoID>1</RepoID>
    <Title>Question about Points-to Analysis to statically detect all indirect function calls</Title>
    <Description>Hi, 

I am trying to detect all indirect function calls via points-to analysis.
However, some of them are missing from my observation.
I have tried it with Andersen, AndersenWave, AndersenWaveDiff, AndersenWaveDiffWithType, AndersenLCD with LLVM 4.0. 

When I tried it with Andersen, I used the following codes.
&gt; Andersen* pt = new Andersen();
&gt; pt-&gt;analyze(*module);

Then, when I get callsite, I used the following set of codes.
&gt; if(pt-&gt;hasIndCSCallees((CallInst*)cinst)){   // indirect
&gt;      set &lt;const llvm::Function*&gt; indFuncSet = pt-&gt;getIndCSCallees((CallInst*)cinst);
&gt;      for(auto ifs = indFuncSet.begin(); ifs != indFuncSet.end(); ++ifs){
&gt;             calleeFunc = *ifs;           //This is an indirect callee candidate
&gt;             ......
&gt;      }
&gt; }

Am I doing something wrong?
If so, could you tell me what is the most accurate way to detect all indirect callee?</Description>
    <CreatedDate>15/03/2018</CreatedDate>
    <ClosedDate>20/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>36</IssueID>
    <RepoID>1</RepoID>
    <Title>Why are all constant objects treated as the same object?</Title>
    <Description>I'm trying to use the SVF pointer alias analysis to partition the  all abstract memory objects into disjoint sets. So I'm doing something like:

```C++
for(auto&amp; idToType : *pag) {
        if(ObjPN* opn = dyn_cast&lt;ObjPN&gt;(idToType.second)) {
          unsigned nodeId = idToType.first;
          PointsTo&amp; ptsToOrIsPointedTo = _pta-&gt;getPts(nodeId);
          ptsToOrIsPointedTo |= _pta-&gt;getRevPts(nodeId);
          ptsToOrIsPointedTo &amp;= memObjects;
          if(!ptsToOrIsPointedTo.empty()) {
            ptsToOrIsPointedTo.set(nodeId);
            auto foundElem = std::find_if(disjointObjects.begin(), disjointObjects.end(),
              [&amp;ptsToOrIsPointedTo](const PointsTo&amp; e)
                  {return e.intersects(ptsToOrIsPointedTo);});
            if( foundElem == disjointObjects.end()) {
                disjointObjects.push_front(ptsToOrIsPointedTo);
            } else {
                *foundElem |= ptsToOrIsPointedTo;
            }
          }
        }
    }
```

However when considering something like:

```C
  char* p = cond ? "hello" : "world";
  char* q = "some other string"
```

I get disjoint set like: `[ 1(constObjId)  idOfP ifOfQ]`, which makes sense because SVF considers all constants as a single object. So I tried hacking a bit and changed `isConstantObjSym` to always return false. Which kind of gave me the right result in producing 2 disjoint sets: `[idOfP idOfhello idOfWorld]` and `[idOfQ idOfsomeotherstring]`. But it seems that it has assigned multiple ids to the constant string.

I don't understand SVF very well, so I'm wondering if there is a deeper reason (aside performance?) as to why constants are all a single object? 

Thanks!



</Description>
    <CreatedDate>25/02/2018</CreatedDate>
    <ClosedDate>27/02/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>35</IssueID>
    <RepoID>1</RepoID>
    <Title>Error with running LLVM gold plugin to generate whole-program bc file </Title>
    <Description>Dear SVF authors, 

I followed your [tutorial](https://github.com/SVF-tools/SVF/wiki/Install-LLVM-Gold-Plugin-on-Ubuntu) to build and install LLVM gold plugin on Ubuntu 14.04 (one difference from yours is that I built the plugin under LLVM 3.4 since my LLVM pass is based on 3.4). I successfully built binutils and LLVMgold.so and installed them to /usr/bin and /usr/lib, respectively. However, when I tried with the example code on the [official site](https://llvm.org/docs/GoldPlugin.html#example-of-link-time-optimization), an error “ar: /usr/lib/bfd-plugins/libLTO.a: invalid ELF header” occurred when `ar q a.a a.o` is run.

I checked the ELF header of libLTO.a using _readelf_ and it seems nothing abnormal with it. I would much appreciate if you could provide some clue on the error. Thanks very much!
```
$ readelf -h /usr/lib/bfd-plugins/libLTO.a
File: /usr/lib/bfd-plugins/libLTO.a(LTODisassembler.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          856 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         24
  Section header string table index: 21

File: /usr/lib/bfd-plugins/libLTO.a(lto.cpp.o)
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          174848 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         2561
  Section header string table index: 2558
```
</Description>
    <CreatedDate>23/02/2018</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>34</IssueID>
    <RepoID>1</RepoID>
    <Title>Update for LLVM 5.0.0</Title>
    <Description>Many thanks for this excellent codebase! I'm new to SVF but I have updated it for LLVM 5.0.0 for a project of mine – only a couple of changes, namely:

- The `IsPostDominators` member of `llvm::DominanceFrontierBase` has become a template parameter (https://reviews.llvm.org/D35315).
- The method `llvm::Function::getArgumentList` has been dropped in favour of `llvm::Function::arg_begin`, `llvm::Function::arg_end` and `llvm::Function::args` (https://reviews.llvm.org/rL298010).

Note that the `swap.c` example on the Wiki has changed behaviour since LLVM 4: the `-mem2reg` option to `opt` doesn't do anything as written because clang now adds the attribute `optnone` to functions when compiling under `-O0` (https://reviews.llvm.org/D28404).

To replicate the old behaviour, we can pass the flag `-disable-O0-optnone` to `cc1`, e.g.:
```
clang -Xclang -disable-O0-optnone -c -emit-llvm swap.c -o swap.bc
```

The tests pass with the caveat that the `-Xclang -disable-O0-optnone` flags need to be passed to clang (I haven't included this change in the PR).

LLVM 5 features its own `MemorySSA` analysis (https://llvm.org/docs/MemorySSA.html) – I don't know if has some utility for SVF.

Let me know if any issues!</Description>
    <CreatedDate>13/01/2018</CreatedDate>
    <ClosedDate>17/03/2018</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>33</IssueID>
    <RepoID>1</RepoID>
    <Title>Output format</Title>
    <Description>When I conducted PTA, some of the source location is duplicated like
```
!!Target NodeID 16735	 [&lt;__cleanup_mnt&gt; Source Loc: in line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
...
...
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.cin line: 1072 file:
/home/workspace/llvmlinux/targets/x86_64/src/linux/fs/namespace.c]
```

Is this a bug? Please, can you check this?</Description>
    <CreatedDate>02/10/2017</CreatedDate>
    <ClosedDate>02/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>32</IssueID>
    <RepoID>1</RepoID>
    <Title>object-c</Title>
    <Description>hi,
   sir,does this tool support object-c?is there a plan for  it?</Description>
    <CreatedDate>26/09/2017</CreatedDate>
    <ClosedDate>27/09/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>31</IssueID>
    <RepoID>1</RepoID>
    <Title>argv flow hack. I need to formulate results so it can be chained with…</Title>
    <Description>… another pass</Description>
    <CreatedDate>07/08/2017</CreatedDate>
    <ClosedDate>07/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>30</IssueID>
    <RepoID>1</RepoID>
    <Title>Wiki documentation seems out of sync</Title>
    <Description>The two wiki pages that describe using SVF to write
- flow and field insensitive analysis and
- a source/sink analyzer

seem to be out of sync with some of the code. I am guessing there will be no further updates, is this the case? If I could figure out what's what, I would be glad to contribute back.</Description>
    <CreatedDate>04/08/2017</CreatedDate>
    <ClosedDate>05/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>29</IssueID>
    <RepoID>1</RepoID>
    <Title>Minor nit: change souce to source</Title>
    <Description>A few functions and strings are using "Souce" instead of "Source". Guessing this is a typo, so made a page and a pull req.

https://github.com/unsw-corg/SVF/pull/28

</Description>
    <CreatedDate>31/07/2017</CreatedDate>
    <ClosedDate>01/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>28</IssueID>
    <RepoID>1</RepoID>
    <Title>Minor nit: change souce to source.</Title>
    <Description>
    </Description>
    <CreatedDate>31/07/2017</CreatedDate>
    <ClosedDate>01/08/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>27</IssueID>
    <RepoID>1</RepoID>
    <Title>Some questions related to a LLVM-gold plugin and Linux kernel.</Title>
    <Description>I have read some documents related to the gold plugin and LTO, but still not clear for me.
As far as I understood, the reason why we use llvm-gold plugin is becuase
- the linker needs all available bitcode/object files (without any missing functions/files) in order to do the link time optimization, and
- Successful linking (or LTO) guarantees there is no missing part.
- and in order to link all bitcodes/objects together using `clang -flto`, I should give all bitcodes/objects as arguments altogether.

Am I right?


Based on what I guess, I tried to follow your suggestion.
But it looks building Linux kernel is not a trivial. I tried a few things as follows and all fails.

I first tried to build a vmlinux bitcode file with [llvmlinux](http://llvm.linuxfoundation.org/index.php/Main_Page) project.
I used a script as a CC instead of clang or gcc.
It emits both bitcode files and object files for all clang command.
I think it was successful so far. So I was able to generate bitcode files for individual C codes.
And then I ran ``clang -flto $(find . -name '*.bc') -o $OUTPUT``.
I knew there might be some missing files but I wanted to see what would happen.

It generated a lot of multiple definition errors as follows.
```
...
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_audio_codec_disable'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'intel_init_audio'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_init'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
/usr/bin/ld: error: /tmp/intel_audio-5ce78a.o: multiple definition of 'i915_audio_component_cleanup'
/usr/bin/ld: /tmp/built-in-02b6ce.o: previous definition here
...
```

I also tried to build it in the way suggested in [quickstart-for-using-lto-with-autotooled-projects](http://llvm.org/docs/GoldPlugin.html#quickstart-for-using-lto-with-autotooled-projects) without using another project.
It generated following errors.
```
...
In file included from arch/x86/kernel/asm-offsets.c:8:
In file included from include/linux/crypto.h:24:
In file included from include/linux/slab.h:14:
In file included from include/linux/gfp.h:5:
include/linux/mmzone.h:345:22: error: use of undeclared identifier 'MAX_NR_ZONES'; did you mean
      '__MAX_NR_ZONES'?
        long lowmem_reserve[MAX_NR_ZONES];
                            ^~~~~~~~~~~~
                            __MAX_NR_ZONES
...
```

I found the other project [linux-misc](https://github.com/andikleen/linux-misc) whose a purpose is building LTO-applied Linux kernel (based on gcc).
But combining this project and llvmlinux is a little bit confusing me, and I think it will not work properly.

If you have the experience analyzing Linux kernel, please give me an advice how I can link Linux kernel in a proper way.
Thanks!</Description>
    <CreatedDate>30/07/2017</CreatedDate>
    <ClosedDate>02/10/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>26</IssueID>
    <RepoID>1</RepoID>
    <Title>Points-to analysis on Linux kernel</Title>
    <Description>Hi.

I'm trying to do points-to analysis on the Linux kernel with llvmlinux and your SVF tool.
I built vmlinux.bc and run wpa tool. but the wpa is terminated abnormally, and it prints only the 'Killed' message.
I think the problem is caused by out-of-memory.

Have you tried to do analysis on the Linux kernel? and do you have any tips for me?

I built vmlinux.bc by
- using make tinyconfig to generate the smallest kernel configuration.
- adding -emit-llvm flags to all clang commands in order to generate individual bitcodes.
- change the output expansion from .o to .bc.
- using llvm-link to link all .bc files and omitting ld's flags which is not compatible with llvm-link
- and ignore some corner cases.
(I'm not sure this procedure makes sense, but I'm just trying)

My wpa command is
- wpa vmlinux.bc -nander -print-pts -print-type

Thank you for great tools and it will be very helpful if you give me comments.</Description>
    <CreatedDate>07/07/2017</CreatedDate>
    <ClosedDate>22/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>25</IssueID>
    <RepoID>1</RepoID>
    <Title>Update CMakeLists.txt</Title>
    <Description>
    </Description>
    <CreatedDate>06/07/2017</CreatedDate>
    <ClosedDate>07/07/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>24</IssueID>
    <RepoID>1</RepoID>
    <Title>Travis CI Scripts</Title>
    <Description>Script so that travis can be enabled for the repo

https://travis-ci.org/stephengroat/SVF/builds/234668158</Description>
    <CreatedDate>22/05/2017</CreatedDate>
    <ClosedDate>25/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>23</IssueID>
    <RepoID>1</RepoID>
    <Title>LLVM 4 Merge</Title>
    <Description>I tested this with fi_tests under PTABen and while there were 4 failures (I think, it was just handful for sure) I don't think (although I'm not entirely sure) these were unexpected (non-default cases referred to [Questions on PTABen test cases](https://github.com/unsw-corg/PTABen/issues/2) ).  I ran a few other tests and had generally positive results as well so, I didn't run them all (On my Linux VM this went pretty smooth but on my Mac I'm still struggling a bit although I did find some of my issues, perhaps the key ones).  

This has the BridgedGEPIterator solution implemented along with the previous PR's more mundane fixes, again the NodeRef inclusion in the GraphTraits was the most notable as I recall, to update SVF with LLVM 4.  </Description>
    <CreatedDate>06/05/2017</CreatedDate>
    <ClosedDate>07/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>22</IssueID>
    <RepoID>1</RepoID>
    <Title>BddCondManager: fix deallocation to use Cudd_Quit.</Title>
    <Description>Fixes crash near exit when using SABER.</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>05/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>21</IssueID>
    <RepoID>1</RepoID>
    <Title>valgrind errors with "wpa -anders" and PTABen</Title>
    <Description>Using latest master (0800cd1ce7c6799f228f4be9426e075d1a9dbd79), I just added 'valgrind' before the invocation of 'wpa' in PTABen's `run.sh` and am seeing the following:

http://dtz.so/docs/ladeg.log

In particular:

```
fi_tests/spec_tests/gap.c
@@@analyzing fi_tests/spec_tests/gap.c with testwpa.sh
==331== Memcheck, a memory error detector
==331== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==331== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==331== Command: /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa -ander -vgep=true -stat=false fi_tests/spec_tests/gap.opt
==331== 
==331== Invalid read of size 4
==331==    at 0x4B477B: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode*, ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int, llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp;, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Address 0x66eaa58 is 24 bytes inside a block of size 72 free'd
==331==    at 0x4C2C2EB: operator delete(void*) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4B40E7: ConstraintGraph::removeDirectEdge(ConstraintEdge*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B477A: ConstraintGraph::moveInEdgesToRepNode(ConstraintNode*, ConstraintNode*) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x471E33: Andersen::mergeNodeToRep(unsigned int, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x483098: AndersenWaveDiff::mergeNodeToRep(unsigned int, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47061B: Andersen::mergeSccNodes(unsigned int, llvm::SparseBitVector&lt;128u&gt;&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47344B: Andersen::mergeSccCycle() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4755A0: Andersen::SCCDetect() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x47083C: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp;, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==  Block was alloc'd at
==331==    at 0x4C2B22F: operator new(unsigned long) (in /nix/store/cl1jd45s910gq4jzsd0irnis14p2vmj4-valgrind-3.12.0/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==331==    by 0x4AF478: ConstraintGraph::addNormalGepCGEdge(unsigned int, unsigned int, LocationSet const&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4B06C5: ConstraintGraph::buildCG() (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4771DC: Andersen::initialize(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x4707C6: Andersen::analyze(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42CF22: WPAPass::runPointerAnalysis(llvm::Module&amp;, unsigned int) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x42D565: WPAPass::runOnModule(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x61302E: llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
==331==    by 0x417D6D: main (in /nix/store/cwki8ybl3g876zia6m1m7g577rxpzpw1-SVF-3.8.1-2017.05.01/bin/wpa)
```

(apologies for lack of debug info in those traces)

If you could confirm whether this matches in your build/version that would be useful.

Let me know if you need any more information!</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>13/06/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>20</IssueID>
    <RepoID>1</RepoID>
    <Title>Merging in SUPA implementation?</Title>
    <Description>Don't mean to nag, but just a reminder that merging in SUPA implementation would be great and much appreciated! :+1:

The [SUPA website](http://www.cse.unsw.edu.au/~corg/supa/) suggests it's on your TODO, and idea when that will happen? Or is there anything blocking the effort that perhaps folks (such as myself) could help with?

Thanks!</Description>
    <CreatedDate>04/05/2017</CreatedDate>
    <ClosedDate>04/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>19</IssueID>
    <RepoID>1</RepoID>
    <Title>cppUtil::DemangledName cppUtil::demangle does not work in some case</Title>
    <Description>For example, if its argument is "_Z8printtttPj". (Original name "printttt(unsigned int*)")
"cppUtil::DemangledName cppUtil::demangle " cannot demangle it.</Description>
    <CreatedDate>01/05/2017</CreatedDate>
    <ClosedDate>01/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>18</IssueID>
    <RepoID>1</RepoID>
    <Title>LLVM 4</Title>
    <Description>This should be relatively easy to integrate - although I would put this into a separate (a staging or local) branch and then merge back into the GitHub master from there.  The WPAPass no longer inheriting from AliasAnalysis is probably the place I would suggest to be looked at the most.  The "SVF Alterations.rtf" gives a summary of the changes, etc...

Let me know what else I can do to help.  I've gotta move on to a few other things the rest of the week but next week I'm going to start outline a few pivots I'm hoping to expand on :-) </Description>
    <CreatedDate>18/04/2017</CreatedDate>
    <ClosedDate>05/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>17</IssueID>
    <RepoID>1</RepoID>
    <Title>Error on wpa -ander -svfg -dump-svfg example.bc </Title>
    <Description>Hi, I am trying to understand and check SVF capabilities.

However, I found some error with a toy code.
I also attached error messages.
---------------------------  Code     ------------------------------------------------
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Profile
{
    public:
        void printProfile()
        {
            cout &lt;&lt; "Name : " &lt;&lt; _name.c_str() &lt;&lt; endl;
            cout &lt;&lt; "Phone Number : " &lt;&lt; _phoneNumber.c_str() &lt;&lt;endl;
        }
        void setName(string name)
        {
            _name = name;
        }
        void setPhoneNumber(string phoneNumber)
        {
            _phoneNumber = phoneNumber;
        }
    private:
        string _name;
        string _phoneNumber;
};


int main()
{
    Profile myProfile;
    myProfile.setName("Hong");
    myProfile.setPhoneNumber("012319562");
    myProfile.printProfile();
    return 0;
}
------------------------ Error message --------------------------------------

Writing 'ander_svfg.dot'...#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode*, SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode*, SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp;, SVFG* const&amp;, bool, llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp;, std::string const&amp;, SVFG* const&amp;, bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp;, bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp;, unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
Stack dump:
0.	Program arguments: wpa -ander -svfg -dump-svfg c++.bc 
1.	Running pass 'WPAPass' on module 'c++.bc'.
#0 0x0000000000e7870b llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) (~/SVF/build/bin/wpa+0xe7870b)
#1 0x0000000000e78a20 PrintStackTraceSignalHandler(void*) (~/SVF/build/bin/wpa+0xe78a20)
#2 0x0000000000e7706d llvm::sys::RunSignalHandlers() (~/SVF/build/bin/wpa+0xe7706d)
#3 0x0000000000e78181 SignalHandler(int) (~/SVF/build/bin/wpa+0xe78181)
#4 0x00007fe76b13b330 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x10330)
#5 0x000000000045ed78 MRVer::getSSAVersion() const (~/SVF/build/bin/wpa+0x45ed78)
#6 0x0000000000463d4f llvm::DOTGraphTraits&lt;SVFG*&gt;::getCompleteNodeLabel(SVFGNode*, SVFG*) (~/SVF/build/bin/wpa+0x463d4f)
#7 0x0000000000462e08 llvm::DOTGraphTraits&lt;SVFG*&gt;::getNodeLabel(SVFGNode*, SVFG*) (~/SVF/build/bin/wpa+0x462e08)
#8 0x000000000047bec9 llvm::GraphWriter&lt;SVFG*&gt;::writeNode(SVFGNode*) (~/SVF/build/bin/wpa+0x47bec9)
#9 0x0000000000479fe7 llvm::GraphWriter&lt;SVFG*&gt;::writeNodes() (~/SVF/build/bin/wpa+0x479fe7)
#10 0x00000000004769a3 llvm::GraphWriter&lt;SVFG*&gt;::writeGraph(std::string const&amp;) (~/SVF/build/bin/wpa+0x4769a3)
#11 0x000000000047095d llvm::raw_ostream&amp; llvm::WriteGraph&lt;SVFG*&gt;(llvm::raw_ostream&amp;, SVFG* const&amp;, bool, llvm::Twine const&amp;) (~/SVF/build/bin/wpa+0x47095d)
#12 0x000000000046a10b void llvm::GraphPrinter::WriteGraphToFile&lt;SVFG*&gt;(llvm::raw_ostream&amp;, std::string const&amp;, SVFG* const&amp;, bool) (~/SVF/build/bin/wpa+0x46a10b)
#13 0x000000000045c593 SVFG::dump(std::string const&amp;, bool) (~/SVF/build/bin/wpa+0x45c593)
#14 0x0000000000409bc6 WPAPass::runPointerAnalysis(llvm::Module&amp;, unsigned int) (~/SVF/build/bin/wpa+0x409bc6)
#15 0x0000000000409964 WPAPass::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x409964)
#16 0x00000000007b92b6 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b92b6)
#17 0x00000000007b9a20 llvm::legacy::PassManagerImpl::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9a20)
#18 0x00000000007b9c61 llvm::legacy::PassManager::run(llvm::Module&amp;) (~/SVF/build/bin/wpa+0x7b9c61)
#19 0x000000000040772b main (~/SVF/build/bin/wpa+0x40772b)
#20 0x00007fe76a34ef45 __libc_start_main /build/eglibc-oGUzwX/eglibc-2.19/csu/libc-start.c:321:0
#21 0x0000000000407289 _start (~/SVF/build/bin/wpa+0x407289)
llvmhelper.sh: line 26: 26518 Segmentation fault      (core dumped) wpa -ander -svfg -dump-svfg $1.bc</Description>
    <CreatedDate>17/04/2017</CreatedDate>
    <ClosedDate>07/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>16</IssueID>
    <RepoID>1</RepoID>
    <Title>Question for source sink analysis</Title>
    <Description>Hi, I referred to https://github.com/unsw-corg/SVF/wiki/Write-a-source-sink-analyzer
In my case, I have two types of sources.
1) Typical source from some functions.
2) Some variables in "class". (=class variable )

My target program runs in a loop, and class variable will go out via sinks.
This class variable is computed with class variable, arithmetic operations and source (external source).

In this case, is there a way to designate "class variable" as sources?
From my observation, some node contains variable names. So, if I could get such node in some way, there may be some way to do. But I am not sure.

Note that class variable can be changed directly via arithmetic operations (e.g., classA.a = classA.a + 30)</Description>
    <CreatedDate>16/04/2017</CreatedDate>
    <ClosedDate>23/04/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>15</IssueID>
    <RepoID>1</RepoID>
    <Title>Missing a function in musl's PointsTo</Title>
    <Description>Hi,

I've been using WPA in SVF to analyze a library using Andersen's algorithm. The library I'm using is musl-libc version 1.1.15 since it can be compiled using LLVM. 

I notice that, in musl libc, there is an indirect call from function vfprintf to sn_write which is not captured in WPA's output. Particularly, when a program invokes vsnprintf, it prepares a FILE struct with a pointer to sn_write function. "vsnprintf" then issues a direct call to vfprintf with a pointer to this struct as an argument. Finally, vfprintf invokes sn_write at an indirect callsite. 

Source codes for [vsnprintf](https://git.musl-libc.org/cgit/musl/tree/src/stdio/vsnprintf.c?h=v1.1.15) and [vfprintf](https://git.musl-libc.org/cgit/musl/tree/src/stdio/vfprintf.c?h=v1.1.15).

Attached [musl.tar.gz](https://github.com/unsw-corg/SVF/files/901301/musl.tar.gz) contains bitcode file and LLVM assembly file of musl generated by LLVM gold plugin.

Thank you for your help.

</Description>
    <CreatedDate>06/04/2017</CreatedDate>
    <ClosedDate>07/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>14</IssueID>
    <RepoID>1</RepoID>
    <Title>Migrating SVF to LLVM 4</Title>
    <Description>Hello,

I am very new to SVF and somewhat naively I took a quick spin in the 3.8 LLVM code base (as shipped so to speak), and liking the code base, and capabilities, I then started towards migrating SVF towards the LLVM 4.0 release.  Perhaps not unsurprisingly I ran into a few problems, but primarily and this was one of the things that attracted me to SVF, the GraphTraits in 4.0 looks like it has some changes that are marked as a fixme:

  typedef typename GTraits::NodeRef           NodeRef;
  typedef typename GTraits::nodes_iterator    node_iterator;
  typedef typename GTraits::ChildIteratorType child_iterator;
  DOTTraits DTraits;

  static_assert(std::is_pointer&lt;NodeRef&gt;::value,
                "FIXME: Currently GraphWriter requires the NodeRef type to be "
                "a pointer.\nThe pointer usage should be moved to "
                "DOTGraphTraits, and removed from GraphWriter itself.”);


(that’s in the GraphWriter.h from LLVM 4.0 release).

So, is there anywhere, a paper perhaps, that you could refer me towards for understanding some of the details as well as the high level implementation of the graphing algorithms being used?  I come from a numerical background so I’m used to sparse solvers such as GMRES, etc, but the LLVM implementation (while I’m somewhat familiar with a few parts of LLVM) is somewhat new to me - I’ve generally re-used the SCC and other graph related algorithms without needing to dive in headfirst - that said, that looks like it’s on tap for my weekend :)


Another question I had was in the Memory separation capabilities, does this require disjoint regions?  It seems to read as if “no”?  But then that does limit any typical Formal Methods applications where analysis (that I’ve seen at least) typically requires disjoint regions.  For example I’ve seen several FM related LLVM papers replacing PHI nodes with simplifications.

Thanks!
</Description>
    <CreatedDate>01/04/2017</CreatedDate>
    <ClosedDate>07/05/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>13</IssueID>
    <RepoID>1</RepoID>
    <Title>SVFG: Obtain SVFGNode corresponding to argument of CallSite</Title>
    <Description>Hi,

I recently tested SVF (commit 5355fc2e). Great piece of work from my point of view!
Unfortunatly I have problems using the API correctly and I would be pleased if you could guide me a little.
I initialize SVF with the following Instuctions:

```
bool runOnModule(Module &amp;m) override {
        FlowSensitive* fspa = FlowSensitive::createFSWPA(m);
        SVFG* svfg = fspa-&gt;getSVFG();
        PAG* pag = fspa-&gt;getPAG();
        PTACallGraph* ptaCallGraph = fspa-&gt;getPTACallGraph();
```

Later I obtain a llvm::CallSite and want to access the SVFGNodes corresponding to the arguments of that CallSite with


```
if (svfg-&gt;hasActualINSVFGNodes(callSite)) {  // why never true?
    auto set = svfg-&gt;getActualINSVFGNodes(callSite);
    int i = 0;
    for(auto it = set.begin(); it!=set.end(); ++it) {
       errs() &lt;&lt; "param No. " &lt;&lt; i++;
       errs() &lt;&lt; "node id: " &lt;&lt; *it &lt;&lt; "\n";
    }
} else {
    errs() &lt;&lt; "no actual INSVFGNodes\n";
}
```


But the SVFG::callSiteToActualINMap (include/MSSA/SVFG.h:100) is empty everytime. What am I missing here? Do I have wrong initialization steps?
I attached the code of my LLVM Pass as well as source code and LLVM IR of the module under test.
[Logger.zip](https://github.com/unsw-corg/SVF/files/865482/Logger.zip)
See LoggerOO.cpp:  my ultimate goal is to track back the value of parameter 1 of Logger::log2() [line 75] so that SVF reports its value either originates as return value of Encryptor::encrypt() [line 69] or as output parameter of assign() [line 71]

It would be nice if you could help me with this.
Thank you.</Description>
    <CreatedDate>23/03/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>12</IssueID>
    <RepoID>1</RepoID>
    <Title>Assertion triggered after modifying code</Title>
    <Description>Hello!

I'm currently using the SVF analysis for a project and I run into an issue using the analysis
for newly inserted instructions. In short, I get the following error whenever I try to check
whether the newly inserted instruction (AllocaInst) aliases with another value :

SVF/include/MemoryModel/MemModel.h:554:
SymID SymbolTableInfo::getValSym(const llvm::Value*): Assertion `iter!=valSymMap.end() &amp;&amp;"value sym not found"' failed.

Below is a test pass that should throw this error for any loop containing a load.
Weirdly, this **only** happens if I compile Svf &amp; the pass in Debug mode, but not if I build it in
MinSizeRel mode.

In general I believe that I need to update the pointer analysis after having modified the code, however, I'm not sure how to properly update the analysis. The test pass below contains some of my failed trials of naively re-running it (see commented lines).

What I am doing wrong? How do I properly update/re-run the analysis? And, do you know why this is
only happening if compiled in Debug mode?

```c++
#include "llvm/Analysis/LoopPass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/IRBuilder.h"

#include "MemoryModel/PointerAnalysis.h"
#include "WPA/Andersen.h"

using namespace llvm;

namespace {
  struct TestSvf : public LoopPass {
    static char ID;

    TestSvf() : LoopPass(ID) {}

    virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const {
      AU.addRequired&lt;LoopInfoWrapperPass&gt;();
    }
    virtual bool runOnLoop(Loop *L, LPPassManager &amp;LPM);
  };
}

bool TestSvf::runOnLoop(Loop *L, LPPassManager &amp;LPM) {
  // Create AA before changing loop
  Module &amp;M = *L-&gt;getHeader()-&gt;getParent()-&gt;getParent();
  AndersenWaveDiff *AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // Change loop: add an alloca instruction
  BasicBlock *H = L-&gt;getHeader();
  IRBuilder&lt;&gt; Builder(&amp;*(H-&gt;getFirstInsertionPt()));
  AllocaInst *Alloca = Builder.CreateAlloca(Type::getInt1Ty(getGlobalContext()), 0, "test_alloca");

  // Try to recalculate AA
  // 1st try: AA-&gt;analyze(M);

  // 2nd try:
  // AndersenWaveDiff::releaseAndersenWaveDiff();
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  // 3rd try: 
  // delete(AA);
  // AA = AndersenWaveDiff::createAndersenWaveDiff(M);

  
  // Find first load in loop
  for (BasicBlock *BB : L-&gt;getBlocks()) {
    for (Instruction &amp;I : *BB) {
      if (LoadInst *Load = dyn_cast&lt;LoadInst&gt;(&amp;I)) {
	Value *LoadedVal = Load-&gt;getPointerOperand();

	// Check AA information between loaded value &amp; alloca instruction
	// throws error
	errs() &lt;&lt; AA-&gt;alias(Alloca, LoadedVal) &lt;&lt; "\n";
      }
    }
  }
    
  return false;
}

char TestSvf::ID = 0;
static RegisterPass&lt;TestSvf&gt; X("test-svf", "TestSvf_pass", false, true);
```</Description>
    <CreatedDate>20/03/2017</CreatedDate>
    <ClosedDate>21/03/2017</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>11</IssueID>
    <RepoID>1</RepoID>
    <Title>Buffer index sensitivity with non variant GEP instructions</Title>
    <Description>In the following code:
`
int f() {
  char buf[10] = {0,};
  int x = buf[0];
  int y = buf[1];
  return x + y;
}
`
The GEP instructions which correspond to x and y are both constant,
but when we check aliasing, we get MayAlias.
Actually, in both cases, the LocationSet of the GepObjPN is constant and equal to 0.
Is this a bug or SVF handles buffers always in an index insensitive way?
</Description>
    <CreatedDate>27/02/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>10</IssueID>
    <RepoID>1</RepoID>
    <Title>SVFG: Calling a function twice with global pointers as a parameter</Title>
    <Description>Hi,
I'm currently working with your awesome SVF analysis. During some tests with the SVFG, I found a simple test-case that doesn't make sense to me. 

Why does the SVFG in Test1 has a path from "local_x" into the second "init" call?

```
int *global_p1; // NodeID= 1
int *global_p2; // NodeID= 2

void init(int **pp, int *x) {
	*pp = x;
}

void delete(int **pp) {
	*pp = NULL;
}

void test1() {
	int local_x = 1; // NodeID= 10 
	int local_y = 2; // NodeID= 11

	init(&amp;global_p1, &amp;local_x);
	init(&amp;global_p2, &amp;local_y);
	delete(&amp;global_p2);
}

void test2() {
	int local_x = 1;// NodeID= 10
	int local_y = 2;// NodeID= 11
	int *local_p1;  // NodeID= 12
	int *local_p2;  // NodeID= 13

	init(&amp;local_p1, &amp;local_x);
	init(&amp;local_p2, &amp;local_y);
	delete(&amp;local_p2);
}

int main() {

	/*** Test 1:
	 * There will be a path from the "local_x" into the second call of "init",
        * (10 -&gt; 60 -&gt; 20 -&gt; 16 -&gt; 21 -&gt; 53 -&gt; 21 -&gt; ...)
	 * but "local_x" was only written into "global_p1" and not into "global_p2".
	 */ 
	//test1();

	/*** Test 2:
	 * Writing "local_x" into "local_p1" creates the SVFG, which I would
	 * have expected also in Test1.
	 */ 
	//test2();
	return 0;
}
```

These are the result I get with: _saber -leak -dump-svfg main.bc_
SVFG of Test1:
![saber_svfg_test1](https://cloud.githubusercontent.com/assets/15213455/21852134/2f520b32-d812-11e6-8451-09bdf625a71e.png)

SVFG of Test2:
![saber_svfg_test2](https://cloud.githubusercontent.com/assets/15213455/21852145/3b108d18-d812-11e6-88ed-4579ad8a18b5.png)</Description>
    <CreatedDate>11/01/2017</CreatedDate>
    <ClosedDate>
    </ClosedDate>
  </Issue>
  <Issue>
    <IssueID>9</IssueID>
    <RepoID>1</RepoID>
    <Title>Moved CUDD tests from lib dir to tests dir</Title>
    <Description>Moved tests files from CUDD libraries as a prerequisite for creating Cmake files.
</Description>
    <CreatedDate>03/08/2016</CreatedDate>
    <ClosedDate>04/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>8</IssueID>
    <RepoID>1</RepoID>
    <Title>Added CMake support for SVF</Title>
    <Description>As requested, here is a PR for including CMake support for SVF for LLVM 3.8.
</Description>
    <CreatedDate>28/07/2016</CreatedDate>
    <ClosedDate>04/08/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>7</IssueID>
    <RepoID>1</RepoID>
    <Title>PAG: "black hole" and "variant GEP" edges?</Title>
    <Description>Hi,

What are "black hole" and "variant GEP" edges (black hole especially) and what roles do they play in the precision/performance of the various analyses?
</Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>12/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>6</IssueID>
    <RepoID>1</RepoID>
    <Title>AndersenLCD implementation "incomplete": documentation and efficiency</Title>
    <Description>The implementation of lazy cycle detection is [described as 'incomplete' in Andersen.h](https://github.com/unsw-corg/SVF/blob/8ef26adf7d500bec03d241030fc1157c7757a85f/include/WPA/Andersen.h#L389),
is the implemented approach documented somewhere?

If not, could this be documented?

I suppose I'm unsure in what way what's implemented is "lazy cycle detection", is it?
</Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>12/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>5</IssueID>
    <RepoID>1</RepoID>
    <Title>cmake build support (required for use with LLVM newer than 3.8 release)</Title>
    <Description>LLVM deprecated autoconf in favor of CMake around the 3.8 release, which means projects must move to CMake in order to be used with newer versions of LLVM.

Mostly filing issue to track the status of CMake support in SVF :).

Any plans on adding it in order to support continued use with LLVM?
</Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>07/07/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>4</IssueID>
    <RepoID>1</RepoID>
    <Title>Fix memory bug in ConsG, copy to avoid ref into dead object.</Title>
    <Description>
    </Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>12/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>3</IssueID>
    <RepoID>1</RepoID>
    <Title>Add missing paren in stat print.</Title>
    <Description>
    </Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>12/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>2</IssueID>
    <RepoID>1</RepoID>
    <Title>singleton instances, unclear memory ownership</Title>
    <Description>- Data-structures not created by not destroyed
  - unable to run same analysis on different modules (in sequence) due to persisting datastructures (like SymbolInfo).
- Singletons are expected to be initialized for current module/analysis
  - can't analyze modules in parallel.
- Unclear ownership/sharing patterns, especially regarding PAG and SymbolInfo.
- Non-static instances using singletons fail in unexpected ways if singletons already existed for another reason.
  - complicates use of analysis in a PassManager

The current code is remarkably close to being free of these singletons but requires some careful work to remove them while preserving the overall architecture.  I tried locally but it was a bit of a mess O:).

Is this something you could look at?
</Description>
    <CreatedDate>11/05/2016</CreatedDate>
    <ClosedDate>13/05/2016</ClosedDate>
  </Issue>
  <Issue>
    <IssueID>1</IssueID>
    <RepoID>1</RepoID>
    <Title>Merge with master</Title>
    <Description>
    </Description>
    <CreatedDate>24/07/2015</CreatedDate>
    <ClosedDate>24/07/2015</ClosedDate>
  </Issue>
</Issues>